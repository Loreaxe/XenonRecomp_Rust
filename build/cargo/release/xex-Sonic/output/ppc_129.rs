pub fn sub_82A46778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A46778 size=236
    let mut pc: u32 = 0x82A46778;
    'dispatch: loop {
        match pc {
            0x82A46778 => {
    //   block [0x82A46778..0x82A46864)
	// 82A46778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4677C: 487619F1  bl 0x831a816c
	ctx.lr = 0x82A46780;
	sub_831A8130(ctx, base);
	// 82A46780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A46788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A4678C: 4BAC8BD5  bl 0x8250f360
	ctx.lr = 0x82A46790;
	sub_8250F360(ctx, base);
	// 82A46790: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A46794: 408200C8  bne 0x82a4685c
	if !ctx.cr[0].eq {
	pc = 0x82A4685C; continue 'dispatch;
	}
	// 82A46798: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4679C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A467A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A467A4: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82A467A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A467AC: 4BACB33D  bl 0x82511ae8
	ctx.lr = 0x82A467B0;
	sub_82511AE8(ctx, base);
	// 82A467B0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A467B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A467B8: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 82A467BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A467C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A467C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A467C8: 4B9D0BF9  bl 0x824173c0
	ctx.lr = 0x82A467CC;
	sub_824173C0(ctx, base);
	// 82A467CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A467D0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A467D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A467D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A467DC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A467E0: 419A0024  beq cr6, 0x82a46804
	if ctx.cr[6].eq {
	pc = 0x82A46804; continue 'dispatch;
	}
	// 82A467E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A467E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A467EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A467F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A467F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A467F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A467FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A46800: 4082FFE8  bne 0x82a467e8
	if !ctx.cr[0].eq {
	pc = 0x82A467E8; continue 'dispatch;
	}
	// 82A46804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A46808: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A4680C: 485C191D  bl 0x83008128
	ctx.lr = 0x82A46810;
	sub_83008128(ctx, base);
	// 82A46810: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A46814: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A46818: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4681C: 388ACB58  addi r4, r10, -0x34a8
	ctx.r[4].s64 = ctx.r[10].s64 + -13480;
	// 82A46820: 38A001C3  li r5, 0x1c3
	ctx.r[5].s64 = 451;
	// 82A46824: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A46828: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4682C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A46830: 48412211  bl 0x82e58a40
	ctx.lr = 0x82A46834;
	sub_82E58A40(ctx, base);
	// 82A46834: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A46838: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4683C: 419A0008  beq cr6, 0x82a46844
	if ctx.cr[6].eq {
	pc = 0x82A46844; continue 'dispatch;
	}
	// 82A46840: 4B87A051  bl 0x822c0890
	ctx.lr = 0x82A46844;
	sub_822C0890(ctx, base);
	// 82A46844: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A46848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4684C: 419A0008  beq cr6, 0x82a46854
	if ctx.cr[6].eq {
	pc = 0x82A46854; continue 'dispatch;
	}
	// 82A46850: 4B87A041  bl 0x822c0890
	ctx.lr = 0x82A46854;
	sub_822C0890(ctx, base);
	// 82A46854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A46858: 4BAC9D79  bl 0x825105d0
	ctx.lr = 0x82A4685C;
	sub_825105D0(ctx, base);
	// 82A4685C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A46860: 4876195C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A46868 size=108
    let mut pc: u32 = 0x82A46868;
    'dispatch: loop {
        match pc {
            0x82A46868 => {
    //   block [0x82A46868..0x82A468D4)
	// 82A46868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4686C: 48761901  bl 0x831a816c
	ctx.lr = 0x82A46870;
	sub_831A8130(ctx, base);
	// 82A46870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46874: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A46878: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4687C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A46880: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A46884: 41820038  beq 0x82a468bc
	if ctx.cr[0].eq {
	pc = 0x82A468BC; continue 'dispatch;
	}
	// 82A46888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4688C: 487630FD  bl 0x831a9988
	ctx.lr = 0x82A46890;
	sub_831A9988(ctx, base);
	// 82A46890: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A46894: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A46898: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A4689C: 4876185D  bl 0x831a80f8
	ctx.lr = 0x82A468A0;
	sub_831A80F8(ctx, base);
	// 82A468A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A468A4: 41820018  beq 0x82a468bc
	if ctx.cr[0].eq {
	pc = 0x82A468BC; continue 'dispatch;
	}
	// 82A468A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A468AC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82A468B0: 4BFFFB21  bl 0x82a463d0
	ctx.lr = 0x82A468B4;
	sub_82A463D0(ctx, base);
	// 82A468B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A468B8: 48000014  b 0x82a468cc
	pc = 0x82A468CC; continue 'dispatch;
	// 82A468BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A468C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A468C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A468C8: 4BACBD51  bl 0x82512618
	ctx.lr = 0x82A468CC;
	sub_82512618(ctx, base);
	// 82A468CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A468D0: 487618EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A468D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A468D8 size=164
    let mut pc: u32 = 0x82A468D8;
    'dispatch: loop {
        match pc {
            0x82A468D8 => {
    //   block [0x82A468D8..0x82A4697C)
	// 82A468D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A468DC: 4876188D  bl 0x831a8168
	ctx.lr = 0x82A468E0;
	sub_831A8130(ctx, base);
	// 82A468E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A468E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A468E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A468EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A468F0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A468F4: 41820038  beq 0x82a4692c
	if ctx.cr[0].eq {
	pc = 0x82A4692C; continue 'dispatch;
	}
	// 82A468F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A468FC: 4876308D  bl 0x831a9988
	ctx.lr = 0x82A46900;
	sub_831A9988(ctx, base);
	// 82A46900: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A46904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A46908: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A4690C: 487617ED  bl 0x831a80f8
	ctx.lr = 0x82A46910;
	sub_831A80F8(ctx, base);
	// 82A46910: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A46914: 41820018  beq 0x82a4692c
	if ctx.cr[0].eq {
	pc = 0x82A4692C; continue 'dispatch;
	}
	// 82A46918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4691C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A46920: 4BFFFE59  bl 0x82a46778
	ctx.lr = 0x82A46924;
	sub_82A46778(ctx, base);
	// 82A46924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A46928: 4800004C  b 0x82a46974
	pc = 0x82A46974; continue 'dispatch;
	// 82A4692C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A46930: 419A0034  beq cr6, 0x82a46964
	if ctx.cr[6].eq {
	pc = 0x82A46964; continue 'dispatch;
	}
	// 82A46934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A46938: 48763051  bl 0x831a9988
	ctx.lr = 0x82A4693C;
	sub_831A9988(ctx, base);
	// 82A4693C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A46940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A46944: 386B67A0  addi r3, r11, 0x67a0
	ctx.r[3].s64 = ctx.r[11].s64 + 26528;
	// 82A46948: 487617B1  bl 0x831a80f8
	ctx.lr = 0x82A4694C;
	sub_831A80F8(ctx, base);
	// 82A4694C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A46950: 41820014  beq 0x82a46964
	if ctx.cr[0].eq {
	pc = 0x82A46964; continue 'dispatch;
	}
	// 82A46954: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A46958: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A4695C: 4B8796A5  bl 0x822c0000
	ctx.lr = 0x82A46960;
	sub_822C0000(ctx, base);
	// 82A46960: 4BFFFFC4  b 0x82a46924
	pc = 0x82A46924; continue 'dispatch;
	// 82A46964: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A46968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4696C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A46970: 4BACBCA9  bl 0x82512618
	ctx.lr = 0x82A46974;
	sub_82512618(ctx, base);
	// 82A46974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A46978: 48761840  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A46980 size=52
    let mut pc: u32 = 0x82A46980;
    'dispatch: loop {
        match pc {
            0x82A46980 => {
    //   block [0x82A46980..0x82A469B4)
	// 82A46980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A46988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4698C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A46994: 4800793D  bl 0x82a4e2d0
	ctx.lr = 0x82A46998;
	sub_82A4E2D0(ctx, base);
	// 82A46998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4699C: 48007D25  bl 0x82a4e6c0
	ctx.lr = 0x82A469A0;
	sub_82A4E6C0(ctx, base);
	// 82A469A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A469A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A469A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A469AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A469B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A469B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A469B8 size=124
    let mut pc: u32 = 0x82A469B8;
    'dispatch: loop {
        match pc {
            0x82A469B8 => {
    //   block [0x82A469B8..0x82A46A34)
	// 82A469B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A469BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A469C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A469C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A469C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A469CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A469D0: 4870DC31  bl 0x83154600
	ctx.lr = 0x82A469D4;
	sub_83154600(ctx, base);
	// 82A469D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A469D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A469DC: 48007D0D  bl 0x82a4e6e8
	ctx.lr = 0x82A469E0;
	sub_82A4E6E8(ctx, base);
	// 82A469E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A469E4: 4BFF0D8D  bl 0x82a37770
	ctx.lr = 0x82A469E8;
	sub_82A37770(ctx, base);
	// 82A469E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A469EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A469F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A469F4: C00B6218  lfs f0, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A469F8: C1AABC10  lfs f13, -0x43f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A469FC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A46A00: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A46A04: 4BFEB53D  bl 0x82a31f40
	ctx.lr = 0x82A46A08;
	sub_82A31F40(ctx, base);
	// 82A46A08: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A46A0C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A46A10: 396B3904  addi r11, r11, 0x3904
	ctx.r[11].s64 = ctx.r[11].s64 + 14596;
	// 82A46A14: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A46A18: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A46A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A46A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A46A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A46A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A46A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A46A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A46A38 size=852
    let mut pc: u32 = 0x82A46A38;
    'dispatch: loop {
        match pc {
            0x82A46A38 => {
    //   block [0x82A46A38..0x82A46D8C)
	// 82A46A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46A3C: 48761721  bl 0x831a815c
	ctx.lr = 0x82A46A40;
	sub_831A8130(ctx, base);
	// 82A46A40: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A46A44: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A46D90 size=196
    let mut pc: u32 = 0x82A46D90;
    'dispatch: loop {
        match pc {
            0x82A46D90 => {
    //   block [0x82A46D90..0x82A46E54)
	// 82A46D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A46D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A46D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A46DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46DA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A46DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A46DAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A46DB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A46DB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A46DB8: 4B879B81  bl 0x822c0938
	ctx.lr = 0x82A46DBC;
	sub_822C0938(ctx, base);
	// 82A46DBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A46DC0: 41820028  beq 0x82a46de8
	if ctx.cr[0].eq {
	pc = 0x82A46DE8; continue 'dispatch;
	}
	// 82A46DC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A46DC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A46DCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A46DD0: 392BCC08  addi r9, r11, -0x33f8
	ctx.r[9].s64 = ctx.r[11].s64 + -13304;
	// 82A46DD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A46DD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A46DDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A46DE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A46DE4: 48000008  b 0x82a46dec
	pc = 0x82A46DEC; continue 'dispatch;
	// 82A46DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A46DEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A46DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A46DF4: 409A0044  bne cr6, 0x82a46e38
	if !ctx.cr[6].eq {
	pc = 0x82A46E38; continue 'dispatch;
	}
	// 82A46DF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A46DFC: 419A001C  beq cr6, 0x82a46e18
	if ctx.cr[6].eq {
	pc = 0x82A46E18; continue 'dispatch;
	}
	// 82A46E00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A46E04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A46E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A46E0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A46E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A46E14: 4E800421  bctrl
	ctx.lr = 0x82A46E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A46E18: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A46E1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A46E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A46E24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A46E28: 816B392C  lwz r11, 0x392c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14636 as u32) ) } as u64;
	// 82A46E2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A46E30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A46E34: 4B8791CD  bl 0x822c0000
	ctx.lr = 0x82A46E38;
	sub_822C0000(ctx, base);
	// 82A46E38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A46E3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A46E40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A46E44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A46E48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A46E4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A46E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A46E58 size=60
    let mut pc: u32 = 0x82A46E58;
    'dispatch: loop {
        match pc {
            0x82A46E58 => {
    //   block [0x82A46E58..0x82A46E94)
	// 82A46E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A46E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A46E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46E68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A46E6C: 480073FD  bl 0x82a4e268
	ctx.lr = 0x82A46E70;
	sub_82A4E268(ctx, base);
	// 82A46E70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A46E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A46E78: 396BCC1C  addi r11, r11, -0x33e4
	ctx.r[11].s64 = ctx.r[11].s64 + -13284;
	// 82A46E7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A46E80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A46E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A46E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A46E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A46E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A46E98 size=308
    let mut pc: u32 = 0x82A46E98;
    'dispatch: loop {
        match pc {
            0x82A46E98 => {
    //   block [0x82A46E98..0x82A46FCC)
	// 82A46E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46E9C: 487612D1  bl 0x831a816c
	ctx.lr = 0x82A46EA0;
	sub_831A8130(ctx, base);
	// 82A46EA0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A46EA4: 48761BD1  bl 0x831a8a74
	ctx.lr = 0x82A46EA8;
	sub_831A8A40(ctx, base);
	// 82A46EA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A46EAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A46EB0: 4870D751  bl 0x83154600
	ctx.lr = 0x82A46EB4;
	sub_83154600(ctx, base);
	// 82A46EB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A46EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A46EBC: 4BFFFAFD  bl 0x82a469b8
	ctx.lr = 0x82A46EC0;
	sub_82A469B8(ctx, base);
	// 82A46EC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A46EC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A46EC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A46ECC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A46ED0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A46ED4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A46ED8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A46EDC: 4BFF16C5  bl 0x82a385a0
	ctx.lr = 0x82A46EE0;
	sub_82A385A0(ctx, base);
	// 82A46EE0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A46EE4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82A46EE8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A46EEC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A46EF0: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A46EF4: C00B57F0  lfs f0, 0x57f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A46EF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A46EFC: C3AAAA18  lfs f29, -0x55e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21992 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A46F00: C3898498  lfs f28, -0x7b68(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31592 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A46F04: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A46F08: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A46F0C: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A46F10: D3810068  stfs f28, 0x68(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A46F14: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A46F18: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A46F1C: C3C789AC  lfs f30, -0x7654(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A46F20: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A46F24: 4B8895A5  bl 0x822d04c8
	ctx.lr = 0x82A46F28;
	sub_822D04C8(ctx, base);
	// 82A46F28: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A46F2C: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82A46F30: 4B888FF1  bl 0x822cff20
	ctx.lr = 0x82A46F34;
	sub_822CFF20(ctx, base);
	// 82A46F34: EC1B0828  fsubs f0, f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A46F38: C1BD05FC  lfs f13, 0x5fc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A46F3C: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A46F40: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82A46F44: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A46F48: D01D05FC  stfs f0, 0x5fc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A46F4C: 4B888FE5  bl 0x822cff30
	ctx.lr = 0x82A46F50;
	sub_822CFF30(ctx, base);
	// 82A46F50: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A46F54: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A46F58: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A46F5C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A46F60: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A46F64: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A46F68: D3810088  stfs f28, 0x88(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A46F6C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A46F70: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A46F74: C00BCC48  lfs f0, -0x33b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A46F78: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A46F7C: C1AACC44  lfs f13, -0x33bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A46F80: C189CC40  lfs f12, -0x33c0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A46F84: C16813CC  lfs f11, 0x13cc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A46F88: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A46F8C: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A46F90: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A46F94: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A46F98: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A46F9C: 4B88952D  bl 0x822d04c8
	ctx.lr = 0x82A46FA0;
	sub_822D04C8(ctx, base);
	// 82A46FA0: D03E0180  stfs f1, 0x180(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A46FA4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A46FA8: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A46FAC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A46FB0: 4B889519  bl 0x822d04c8
	ctx.lr = 0x82A46FB4;
	sub_822D04C8(ctx, base);
	// 82A46FB4: D03E0184  stfs f1, 0x184(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A46FB8: 9BFE0188  stb r31, 0x188(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(392 as u32), ctx.r[31].u8 ) };
	// 82A46FBC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A46FC0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A46FC4: 48761AFD  bl 0x831a8ac0
	ctx.lr = 0x82A46FC8;
	sub_831A8A8C(ctx, base);
	// 82A46FC8: 487611F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A46FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A46FD0 size=1280
    let mut pc: u32 = 0x82A46FD0;
    'dispatch: loop {
        match pc {
            0x82A46FD0 => {
    //   block [0x82A46FD0..0x82A474D0)
	// 82A46FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A46FD4: 48761189  bl 0x831a815c
	ctx.lr = 0x82A46FD8;
	sub_831A8130(ctx, base);
	// 82A46FD8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82A46FDC: 48761A99  bl 0x831a8a74
	ctx.lr = 0x82A46FE0;
	sub_831A8A40(ctx, base);
	// 82A46FE0: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A474D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A474D0 size=92
    let mut pc: u32 = 0x82A474D0;
    'dispatch: loop {
        match pc {
            0x82A474D0 => {
    //   block [0x82A474D0..0x82A4752C)
	// 82A474D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A474D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A474D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A474DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A474E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A474E4: 4BFEA9D5  bl 0x82a31eb8
	ctx.lr = 0x82A474E8;
	sub_82A31EB8(ctx, base);
	// 82A474E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A474EC: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A474F0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A474F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A474F8: 3929CCA8  addi r9, r9, -0x3358
	ctx.r[9].s64 = ctx.r[9].s64 + -13144;
	// 82A474FC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47500: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A47504: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A47508: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4750C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47510: C00A39AC  lfs f0, 0x39ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14764 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47514: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A47518: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4751C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A47520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A47524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A47528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A47530 size=36
    let mut pc: u32 = 0x82A47530;
    'dispatch: loop {
        match pc {
            0x82A47530 => {
    //   block [0x82A47530..0x82A47554)
	// 82A47530: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A47534: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47538: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4753C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A47540: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A47544: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A47548: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4754C: 41980020  blt cr6, 0x82a4756c
	if ctx.cr[6].lt {
		sub_82A4756C(ctx, base);
		return;
	}
	// 82A47550: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A47554 size=16
    let mut pc: u32 = 0x82A47554;
    'dispatch: loop {
        match pc {
            0x82A47554 => {
    //   block [0x82A47554..0x82A47564)
	// 82A47554: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A47558: C1AB39D0  lfs f13, 0x39d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14800 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4755C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A47560: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47564(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A47564 size=8
    let mut pc: u32 = 0x82A47564;
    'dispatch: loop {
        match pc {
            0x82A47564 => {
    //   block [0x82A47564..0x82A4756C)
	// 82A47564: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A47568: 4800001C  b 0x82a47584
	sub_82A47580(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4756C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4756C size=20
    let mut pc: u32 = 0x82A4756C;
    'dispatch: loop {
        match pc {
            0x82A4756C => {
    //   block [0x82A4756C..0x82A47580)
	// 82A4756C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A47570: 396B39D0  addi r11, r11, 0x39d0
	ctx.r[11].s64 = ctx.r[11].s64 + 14800;
	// 82A47574: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A47578: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4757C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A47580 size=20
    let mut pc: u32 = 0x82A47580;
    'dispatch: loop {
        match pc {
            0x82A47580 => {
    //   block [0x82A47580..0x82A47594)
	// 82A47580: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A47584: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A47588: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4758C: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A47590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A47598 size=28
    let mut pc: u32 = 0x82A47598;
    'dispatch: loop {
        match pc {
            0x82A47598 => {
    //   block [0x82A47598..0x82A475B4)
	// 82A47598: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4759C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A475A0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A475A4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A475A8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A475AC: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A475B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A475B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A475B8 size=208
    let mut pc: u32 = 0x82A475B8;
    'dispatch: loop {
        match pc {
            0x82A475B8 => {
    //   block [0x82A475B8..0x82A47688)
	// 82A475B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A475BC: 48760BB1  bl 0x831a816c
	ctx.lr = 0x82A475C0;
	sub_831A8130(ctx, base);
	// 82A475C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A475C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A475C8: 4870D039  bl 0x83154600
	ctx.lr = 0x82A475CC;
	sub_83154600(ctx, base);
	// 82A475CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A475D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A475D4: 48006F4D  bl 0x82a4e520
	ctx.lr = 0x82A475D8;
	sub_82A4E520(ctx, base);
	// 82A475D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A475DC: 480070E5  bl 0x82a4e6c0
	ctx.lr = 0x82A475E0;
	sub_82A4E6C0(ctx, base);
	// 82A475E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A475E4: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A475E8: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A475EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A475F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A475F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A475F8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A47688 size=300
    let mut pc: u32 = 0x82A47688;
    'dispatch: loop {
        match pc {
            0x82A47688 => {
    //   block [0x82A47688..0x82A477B4)
	// 82A47688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4768C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A47690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A47694: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A47698: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4769C: 4870CF65  bl 0x83154600
	ctx.lr = 0x82A476A0;
	sub_83154600(ctx, base);
	// 82A476A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A476A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A476A8: 388B0488  addi r4, r11, 0x488
	ctx.r[4].s64 = ctx.r[11].s64 + 1160;
	// 82A476AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A476B0: 483AC359  bl 0x82df3a08
	ctx.lr = 0x82A476B4;
	sub_82DF3A08(ctx, base);
	// 82A476B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A476B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A476BC: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A476C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A476C4: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A476C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A476CC: 4816B5ED  bl 0x82bb2cb8
	ctx.lr = 0x82A476D0;
	sub_82BB2CB8(ctx, base);
	// 82A476D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A476D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A476D8: 419A0008  beq cr6, 0x82a476e0
	if ctx.cr[6].eq {
	pc = 0x82A476E0; continue 'dispatch;
	}
	// 82A476DC: 4B8791B5  bl 0x822c0890
	ctx.lr = 0x82A476E0;
	sub_822C0890(ctx, base);
	// 82A476E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A476E4: 483ABD45  bl 0x82df3428
	ctx.lr = 0x82A476E8;
	sub_82DF3428(ctx, base);
	// 82A476E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A476EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A476F0: 388B0468  addi r4, r11, 0x468
	ctx.r[4].s64 = ctx.r[11].s64 + 1128;
	// 82A476F4: 483AC315  bl 0x82df3a08
	ctx.lr = 0x82A476F8;
	sub_82DF3A08(ctx, base);
	// 82A476F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A476FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A47700: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A47704: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A47708: 4816B5B1  bl 0x82bb2cb8
	ctx.lr = 0x82A4770C;
	sub_82BB2CB8(ctx, base);
	// 82A4770C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A47710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A47714: 419A0008  beq cr6, 0x82a4771c
	if ctx.cr[6].eq {
	pc = 0x82A4771C; continue 'dispatch;
	}
	// 82A47718: 4B879179  bl 0x822c0890
	ctx.lr = 0x82A4771C;
	sub_822C0890(ctx, base);
	// 82A4771C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47720: 483ABD09  bl 0x82df3428
	ctx.lr = 0x82A47724;
	sub_82DF3428(ctx, base);
	// 82A47724: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A47728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4772C: 388B0448  addi r4, r11, 0x448
	ctx.r[4].s64 = ctx.r[11].s64 + 1096;
	// 82A47730: 483AC2D9  bl 0x82df3a08
	ctx.lr = 0x82A47734;
	sub_82DF3A08(ctx, base);
	// 82A47734: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A47738: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4773C: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A47740: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A47744: 4816B575  bl 0x82bb2cb8
	ctx.lr = 0x82A47748;
	sub_82BB2CB8(ctx, base);
	// 82A47748: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A4774C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A47750: 419A0008  beq cr6, 0x82a47758
	if ctx.cr[6].eq {
	pc = 0x82A47758; continue 'dispatch;
	}
	// 82A47754: 4B87913D  bl 0x822c0890
	ctx.lr = 0x82A47758;
	sub_822C0890(ctx, base);
	// 82A47758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4775C: 483ABCCD  bl 0x82df3428
	ctx.lr = 0x82A47760;
	sub_82DF3428(ctx, base);
	// 82A47760: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A47764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47768: 388B0424  addi r4, r11, 0x424
	ctx.r[4].s64 = ctx.r[11].s64 + 1060;
	// 82A4776C: 483AC29D  bl 0x82df3a08
	ctx.lr = 0x82A47770;
	sub_82DF3A08(ctx, base);
	// 82A47770: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A47774: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A47778: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4777C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A47780: 4816B539  bl 0x82bb2cb8
	ctx.lr = 0x82A47784;
	sub_82BB2CB8(ctx, base);
	// 82A47784: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A47788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4778C: 419A0008  beq cr6, 0x82a47794
	if ctx.cr[6].eq {
	pc = 0x82A47794; continue 'dispatch;
	}
	// 82A47790: 4B879101  bl 0x822c0890
	ctx.lr = 0x82A47794;
	sub_822C0890(ctx, base);
	// 82A47794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47798: 483ABC91  bl 0x82df3428
	ctx.lr = 0x82A4779C;
	sub_82DF3428(ctx, base);
	// 82A4779C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A477A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A477A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A477A8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A477AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A477B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A477B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A477B8 size=52
    let mut pc: u32 = 0x82A477B8;
    'dispatch: loop {
        match pc {
            0x82A477B8 => {
    //   block [0x82A477B8..0x82A477EC)
	// 82A477B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A477BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A477C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A477C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A477C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A477CC: 4870CE35  bl 0x83154600
	ctx.lr = 0x82A477D0;
	sub_83154600(ctx, base);
	// 82A477D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A477D4: 4BFFFDE5  bl 0x82a475b8
	ctx.lr = 0x82A477D8;
	sub_82A475B8(ctx, base);
	// 82A477D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A477DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A477E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A477E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A477E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A477F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A477F0 size=196
    let mut pc: u32 = 0x82A477F0;
    'dispatch: loop {
        match pc {
            0x82A477F0 => {
    //   block [0x82A477F0..0x82A478B4)
	// 82A477F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A477F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A477F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A477FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A47800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47804: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A47808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4780C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A47810: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A47814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A47818: 4B879121  bl 0x822c0938
	ctx.lr = 0x82A4781C;
	sub_822C0938(ctx, base);
	// 82A4781C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A47820: 41820028  beq 0x82a47848
	if ctx.cr[0].eq {
	pc = 0x82A47848; continue 'dispatch;
	}
	// 82A47824: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A47828: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4782C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A47830: 392BCCD4  addi r9, r11, -0x332c
	ctx.r[9].s64 = ctx.r[11].s64 + -13100;
	// 82A47834: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A47838: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4783C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A47840: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A47844: 48000008  b 0x82a4784c
	pc = 0x82A4784C; continue 'dispatch;
	// 82A47848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4784C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A47850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A47854: 409A0044  bne cr6, 0x82a47898
	if !ctx.cr[6].eq {
	pc = 0x82A47898; continue 'dispatch;
	}
	// 82A47858: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4785C: 419A001C  beq cr6, 0x82a47878
	if ctx.cr[6].eq {
	pc = 0x82A47878; continue 'dispatch;
	}
	// 82A47860: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47864: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A47868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4786C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A47874: 4E800421  bctrl
	ctx.lr = 0x82A47878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A47878: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4787C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A47880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47884: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A47888: 816B39D4  lwz r11, 0x39d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14804 as u32) ) } as u64;
	// 82A4788C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A47890: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A47894: 4B87876D  bl 0x822c0000
	ctx.lr = 0x82A47898;
	sub_822C0000(ctx, base);
	// 82A47898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4789C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A478A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A478A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A478A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A478AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A478B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A478B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A478B8 size=60
    let mut pc: u32 = 0x82A478B8;
    'dispatch: loop {
        match pc {
            0x82A478B8 => {
    //   block [0x82A478B8..0x82A478F4)
	// 82A478B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A478BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A478C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A478C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A478C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A478CC: 4800699D  bl 0x82a4e268
	ctx.lr = 0x82A478D0;
	sub_82A4E268(ctx, base);
	// 82A478D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A478D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A478D8: 396BCCE8  addi r11, r11, -0x3318
	ctx.r[11].s64 = ctx.r[11].s64 + -13080;
	// 82A478DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A478E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A478E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A478E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A478EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A478F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A478F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A478F8 size=412
    let mut pc: u32 = 0x82A478F8;
    'dispatch: loop {
        match pc {
            0x82A478F8 => {
    //   block [0x82A478F8..0x82A47A94)
	// 82A478F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A478FC: 48760871  bl 0x831a816c
	ctx.lr = 0x82A47900;
	sub_831A8130(ctx, base);
	// 82A47900: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A47908: 4870CCF9  bl 0x83154600
	ctx.lr = 0x82A4790C;
	sub_83154600(ctx, base);
	// 82A4790C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A47910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47914: 4BFFF0A5  bl 0x82a469b8
	ctx.lr = 0x82A47918;
	sub_82A469B8(ctx, base);
	// 82A47918: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4791C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A47920: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A47924: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A47928: 3889CD10  addi r4, r9, -0x32f0
	ctx.r[4].s64 = ctx.r[9].s64 + -13040;
	// 82A4792C: C00B9688  lfs f0, -0x6978(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27000 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47930: 38A000DA  li r5, 0xda
	ctx.r[5].s64 = 218;
	// 82A47934: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A47938: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A4793C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A47940: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A47944: 4B878A95  bl 0x822c03d8
	ctx.lr = 0x82A47948;
	sub_822C03D8(ctx, base);
	// 82A47948: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4794C: 41820010  beq 0x82a4795c
	if ctx.cr[0].eq {
	pc = 0x82A4795C; continue 'dispatch;
	}
	// 82A47950: 4BFFFB81  bl 0x82a474d0
	ctx.lr = 0x82A47954;
	sub_82A474D0(ctx, base);
	// 82A47954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A47958: 48000008  b 0x82a47960
	pc = 0x82A47960; continue 'dispatch;
	// 82A4795C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A47960: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A47964: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A47968: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4796C: 4BFFFE85  bl 0x82a477f0
	ctx.lr = 0x82A47970;
	sub_82A477F0(ctx, base);
	// 82A47970: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A47974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A47978: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4797C: 4B878685  bl 0x822c0000
	ctx.lr = 0x82A47980;
	sub_822C0000(ctx, base);
	// 82A47980: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A47984: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A47988: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4798C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A47990: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A47994: 419A0024  beq cr6, 0x82a479b8
	if ctx.cr[6].eq {
	pc = 0x82A479B8; continue 'dispatch;
	}
	// 82A47998: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4799C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A479A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A479A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A479A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A479AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A479B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A479B4: 4082FFE8  bne 0x82a4799c
	if !ctx.cr[0].eq {
	pc = 0x82A4799C; continue 'dispatch;
	}
	// 82A479B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A479BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A479C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A479C4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A479C8: 4BFF0BD9  bl 0x82a385a0
	ctx.lr = 0x82A479CC;
	sub_82A385A0(ctx, base);
	// 82A479CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A479D0: 419A000C  beq cr6, 0x82a479dc
	if ctx.cr[6].eq {
	pc = 0x82A479DC; continue 'dispatch;
	}
	// 82A479D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A479D8: 4B878EB9  bl 0x822c0890
	ctx.lr = 0x82A479DC;
	sub_822C0890(ctx, base);
	// 82A479DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A479E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A479E4: 388B03E8  addi r4, r11, 0x3e8
	ctx.r[4].s64 = ctx.r[11].s64 + 1000;
	// 82A479E8: 483AC021  bl 0x82df3a08
	ctx.lr = 0x82A479EC;
	sub_82DF3A08(ctx, base);
	// 82A479EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A479F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A479F4: 809D04EC  lwz r4, 0x4ec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A479F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A479FC: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A47A00: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A47A04: 4816B975  bl 0x82bb3378
	ctx.lr = 0x82A47A08;
	sub_82BB3378(ctx, base);
	// 82A47A08: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A47A0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A47A10: 419A0008  beq cr6, 0x82a47a18
	if ctx.cr[6].eq {
	pc = 0x82A47A18; continue 'dispatch;
	}
	// 82A47A14: 4B878E7D  bl 0x822c0890
	ctx.lr = 0x82A47A18;
	sub_822C0890(ctx, base);
	// 82A47A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47A1C: 483ABA0D  bl 0x82df3428
	ctx.lr = 0x82A47A20;
	sub_82DF3428(ctx, base);
	// 82A47A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A47A24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A47A28: B17F0182  sth r11, 0x182(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(386 as u32), ctx.r[11].u16 ) };
	// 82A47A2C: 4BAA305D  bl 0x824eaa88
	ctx.lr = 0x82A47A30;
	sub_824EAA88(ctx, base);
	// 82A47A30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A47A34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A47A38: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47A3C: 4BAC798D  bl 0x8250f3c8
	ctx.lr = 0x82A47A40;
	sub_8250F3C8(ctx, base);
	// 82A47A40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A47A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A47A48: 4BAA35C9  bl 0x824eb010
	ctx.lr = 0x82A47A4C;
	sub_824EB010(ctx, base);
	// 82A47A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A47A50: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A47A54: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47A58: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A47A5C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82A47A60: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A47A64: 8961005F  lbz r11, 0x5f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82A47A68: 997F0180  stb r11, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 82A47A6C: 483AA225  bl 0x82df1c90
	ctx.lr = 0x82A47A70;
	sub_82DF1C90(ctx, base);
	// 82A47A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A47A74: 4BFEA4CD  bl 0x82a31f40
	ctx.lr = 0x82A47A78;
	sub_82A31F40(ctx, base);
	// 82A47A78: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82A47A7C: 409A0010  bne cr6, 0x82a47a8c
	if !ctx.cr[6].eq {
	pc = 0x82A47A8C; continue 'dispatch;
	}
	// 82A47A80: 897F0180  lbz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82A47A84: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 82A47A88: 997F0180  stb r11, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 82A47A8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A47A90: 4876072C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A47A98 size=232
    let mut pc: u32 = 0x82A47A98;
    'dispatch: loop {
        match pc {
            0x82A47A98 => {
    //   block [0x82A47A98..0x82A47B80)
	// 82A47A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A47A9C: 487606D1  bl 0x831a816c
	ctx.lr = 0x82A47AA0;
	sub_831A8130(ctx, base);
	// 82A47AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A47AA8: 4870CB59  bl 0x83154600
	ctx.lr = 0x82A47AAC;
	sub_83154600(ctx, base);
	// 82A47AAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A47AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47AB4: 48006A6D  bl 0x82a4e520
	ctx.lr = 0x82A47AB8;
	sub_82A4E520(ctx, base);
	// 82A47AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47ABC: 48006C05  bl 0x82a4e6c0
	ctx.lr = 0x82A47AC0;
	sub_82A4E6C0(ctx, base);
	// 82A47AC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A47AC4: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A47AC8: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A47ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47AD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A47AD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A47AD8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A47B80 size=196
    let mut pc: u32 = 0x82A47B80;
    'dispatch: loop {
        match pc {
            0x82A47B80 => {
    //   block [0x82A47B80..0x82A47C44)
	// 82A47B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A47B84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A47B88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A47B8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A47B90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47B94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A47B98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A47B9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A47BA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A47BA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A47BA8: 4B878D91  bl 0x822c0938
	ctx.lr = 0x82A47BAC;
	sub_822C0938(ctx, base);
	// 82A47BAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A47BB0: 41820028  beq 0x82a47bd8
	if ctx.cr[0].eq {
	pc = 0x82A47BD8; continue 'dispatch;
	}
	// 82A47BB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A47BB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A47BBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A47BC0: 392BCD70  addi r9, r11, -0x3290
	ctx.r[9].s64 = ctx.r[11].s64 + -12944;
	// 82A47BC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A47BC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A47BCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A47BD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A47BD4: 48000008  b 0x82a47bdc
	pc = 0x82A47BDC; continue 'dispatch;
	// 82A47BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A47BDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A47BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A47BE4: 409A0044  bne cr6, 0x82a47c28
	if !ctx.cr[6].eq {
	pc = 0x82A47C28; continue 'dispatch;
	}
	// 82A47BE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A47BEC: 419A001C  beq cr6, 0x82a47c08
	if ctx.cr[6].eq {
	pc = 0x82A47C08; continue 'dispatch;
	}
	// 82A47BF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47BF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A47BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47BFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47C00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A47C04: 4E800421  bctrl
	ctx.lr = 0x82A47C08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A47C08: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A47C0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A47C10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47C14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A47C18: 816B3ACC  lwz r11, 0x3acc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15052 as u32) ) } as u64;
	// 82A47C1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A47C20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A47C24: 4B8783DD  bl 0x822c0000
	ctx.lr = 0x82A47C28;
	sub_822C0000(ctx, base);
	// 82A47C28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A47C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A47C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A47C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A47C38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A47C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A47C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A47C48 size=204
    let mut pc: u32 = 0x82A47C48;
    'dispatch: loop {
        match pc {
            0x82A47C48 => {
    //   block [0x82A47C48..0x82A47D14)
	// 82A47C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A47C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A47C50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A47C54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A47C58: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A47C5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A47C64: 4870C99D  bl 0x83154600
	ctx.lr = 0x82A47C68;
	sub_83154600(ctx, base);
	// 82A47C68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A47C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47C70: 4BFFED49  bl 0x82a469b8
	ctx.lr = 0x82A47C74;
	sub_82A469B8(ctx, base);
	// 82A47C74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A47C78: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A47C7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A47C80: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A47C84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A47C88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A47C8C: C00A093C  lfs f0, 0x93c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47C90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A47C94: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A47C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A47C9C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A47CA0: D3FF006C  stfs f31, 0x6c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A47CA4: C02808A8  lfs f1, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A47CA8: 4BFF08F9  bl 0x82a385a0
	ctx.lr = 0x82A47CAC;
	sub_82A385A0(ctx, base);
	// 82A47CAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A47CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47CB4: 388B03E8  addi r4, r11, 0x3e8
	ctx.r[4].s64 = ctx.r[11].s64 + 1000;
	// 82A47CB8: 483ABD51  bl 0x82df3a08
	ctx.lr = 0x82A47CBC;
	sub_82DF3A08(ctx, base);
	// 82A47CBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A47CC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A47CC4: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A47CC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A47CCC: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A47CD0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A47CD4: 4816B6A5  bl 0x82bb3378
	ctx.lr = 0x82A47CD8;
	sub_82BB3378(ctx, base);
	// 82A47CD8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A47CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A47CE0: 419A0008  beq cr6, 0x82a47ce8
	if ctx.cr[6].eq {
	pc = 0x82A47CE8; continue 'dispatch;
	}
	// 82A47CE4: 4B878BAD  bl 0x822c0890
	ctx.lr = 0x82A47CE8;
	sub_822C0890(ctx, base);
	// 82A47CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A47CEC: 483AB73D  bl 0x82df3428
	ctx.lr = 0x82A47CF0;
	sub_82DF3428(ctx, base);
	// 82A47CF0: D3FF0180  stfs f31, 0x180(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A47CF4: D3FF0184  stfs f31, 0x184(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A47CF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A47CFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A47D00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A47D04: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A47D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A47D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A47D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A47D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A47D18 size=840
    let mut pc: u32 = 0x82A47D18;
    'dispatch: loop {
        match pc {
            0x82A47D18 => {
    //   block [0x82A47D18..0x82A48060)
	// 82A47D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A47D1C: 48760441  bl 0x831a815c
	ctx.lr = 0x82A47D20;
	sub_831A8130(ctx, base);
	// 82A47D20: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82A47D24: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A47D28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A47D2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A47D30: 4870C8D1  bl 0x83154600
	ctx.lr = 0x82A47D34;
	sub_83154600(ctx, base);
	// 82A47D34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A47D38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A47D3C: 48411A3D  bl 0x82e59778
	ctx.lr = 0x82A47D40;
	sub_82E59778(ctx, base);
	// 82A47D40: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A47D44: C01D0180  lfs f0, 0x180(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47D48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A47D4C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A47D50: D01D0180  stfs f0, 0x180(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A47D54: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A47D58: 3B4BCD80  addi r26, r11, -0x3280
	ctx.r[26].s64 = ctx.r[11].s64 + -12928;
	// 82A47D5C: C3EA0A90  lfs f31, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A47D60: C01D0180  lfs f0, 0x180(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47D64: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A47D68: 41980160  blt cr6, 0x82a47ec8
	if ctx.cr[6].lt {
	pc = 0x82A47EC8; continue 'dispatch;
	}
	// 82A47D6C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A47D70: D01D0180  stfs f0, 0x180(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A47D74: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A47D78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A47D7C: 38A00130  li r5, 0x130
	ctx.r[5].s64 = 304;
	// 82A47D80: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 82A47D84: 483AA665  bl 0x82df23e8
	ctx.lr = 0x82A47D88;
	sub_82DF23E8(ctx, base);
	// 82A47D88: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A47D8C: 41820070  beq 0x82a47dfc
	if ctx.cr[0].eq {
	pc = 0x82A47DFC; continue 'dispatch;
	}
	// 82A47D90: 397C052C  addi r11, r28, 0x52c
	ctx.r[11].s64 = ctx.r[28].s64 + 1324;
	// 82A47D94: 815C0530  lwz r10, 0x530(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1328 as u32) ) } as u64;
	// 82A47D98: 817C052C  lwz r11, 0x52c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A47D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A47DA0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A47DA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A47DA8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A47DAC: 419A0024  beq cr6, 0x82a47dd0
	if ctx.cr[6].eq {
	pc = 0x82A47DD0; continue 'dispatch;
	}
	// 82A47DB0: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82A47DB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A47DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47DBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A47DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A47DC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A47DC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47DCC: 4082FFE8  bne 0x82a47db4
	if !ctx.cr[0].eq {
	pc = 0x82A47DB4; continue 'dispatch;
	}
	// 82A47DD0: C3DD0180  lfs f30, 0x180(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A47DD4: 3BDC05E0  addi r30, r28, 0x5e0
	ctx.r[30].s64 = ctx.r[28].s64 + 1504;
	// 82A47DD8: 4B888149  bl 0x822cff20
	ctx.lr = 0x82A47DDC;
	sub_822CFF20(ctx, base);
	// 82A47DDC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A47DE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A47DE4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A47DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47DEC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A47DF0: 4BFFD201  bl 0x82a44ff0
	ctx.lr = 0x82A47DF4;
	sub_82A44FF0(ctx, base);
	// 82A47DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A47DF8: 48000008  b 0x82a47e00
	pc = 0x82A47E00; continue 'dispatch;
	// 82A47DFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A47E00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A47E04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A47E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A47E0C: 4BFFFD75  bl 0x82a47b80
	ctx.lr = 0x82A47E10;
	sub_82A47B80(ctx, base);
	// 82A47E10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A47E14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A47E18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A47E1C: 4B8781E5  bl 0x822c0000
	ctx.lr = 0x82A47E20;
	sub_822C0000(ctx, base);
	// 82A47E20: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A47E24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A47E28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A47E2C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A47E30: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A47E34: 419A0024  beq cr6, 0x82a47e58
	if ctx.cr[6].eq {
	pc = 0x82A47E58; continue 'dispatch;
	}
	// 82A47E38: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A47E3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A47E40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47E44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A47E48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A47E4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A47E50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47E54: 4082FFE8  bne 0x82a47e3c
	if !ctx.cr[0].eq {
	pc = 0x82A47E3C; continue 'dispatch;
	}
	// 82A47E58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A47E5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A47E60: 4BAC7669  bl 0x8250f4c8
	ctx.lr = 0x82A47E64;
	sub_8250F4C8(ctx, base);
	// 82A47E64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A47E6C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A47E70: 409A0008  bne cr6, 0x82a47e78
	if !ctx.cr[6].eq {
	pc = 0x82A47E78; continue 'dispatch;
	}
	// 82A47E74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A47E78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A47E7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A47E80: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 82A47E84: 4BAC7695  bl 0x8250f518
	ctx.lr = 0x82A47E88;
	sub_8250F518(ctx, base);
	// 82A47E88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A47E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47E90: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A47E94: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A47E98: 4BAC5671  bl 0x8250d508
	ctx.lr = 0x82A47E9C;
	sub_8250D508(ctx, base);
	// 82A47E9C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A47EA0: 483A9DF1  bl 0x82df1c90
	ctx.lr = 0x82A47EA4;
	sub_82DF1C90(ctx, base);
	// 82A47EA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A47EA8: 483A9DE9  bl 0x82df1c90
	ctx.lr = 0x82A47EAC;
	sub_82DF1C90(ctx, base);
	// 82A47EAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A47EB0: 419A000C  beq cr6, 0x82a47ebc
	if ctx.cr[6].eq {
	pc = 0x82A47EBC; continue 'dispatch;
	}
	// 82A47EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A47EB8: 4B8789D9  bl 0x822c0890
	ctx.lr = 0x82A47EBC;
	sub_822C0890(ctx, base);
	// 82A47EBC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A47EC0: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82A47EC4: 4198FE9C  blt cr6, 0x82a47d60
	if ctx.cr[6].lt {
	pc = 0x82A47D60; continue 'dispatch;
	}
	// 82A47EC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A47ECC: 484118AD  bl 0x82e59778
	ctx.lr = 0x82A47ED0;
	sub_82E59778(ctx, base);
	// 82A47ED0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A47ED4: C01D0184  lfs f0, 0x184(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47ED8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A47EDC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A47EE0: D01D0184  stfs f0, 0x184(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A47EE4: C3EBD934  lfs f31, -0x26cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9932 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A47EE8: C01D0184  lfs f0, 0x184(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A47EEC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A47EF0: 41980160  blt cr6, 0x82a48050
	if ctx.cr[6].lt {
	pc = 0x82A48050; continue 'dispatch;
	}
	// 82A47EF4: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A47EF8: D01D0184  stfs f0, 0x184(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A47EFC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A47F00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A47F04: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 82A47F08: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 82A47F0C: 483AA4DD  bl 0x82df23e8
	ctx.lr = 0x82A47F10;
	sub_82DF23E8(ctx, base);
	// 82A47F10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A47F14: 41820070  beq 0x82a47f84
	if ctx.cr[0].eq {
	pc = 0x82A47F84; continue 'dispatch;
	}
	// 82A47F18: 397C052C  addi r11, r28, 0x52c
	ctx.r[11].s64 = ctx.r[28].s64 + 1324;
	// 82A47F1C: 815C0530  lwz r10, 0x530(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1328 as u32) ) } as u64;
	// 82A47F20: 817C052C  lwz r11, 0x52c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A47F24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A47F28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A47F2C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A47F30: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A47F34: 419A0024  beq cr6, 0x82a47f58
	if ctx.cr[6].eq {
	pc = 0x82A47F58; continue 'dispatch;
	}
	// 82A47F38: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82A47F3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A47F40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47F44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A47F48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A47F4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A47F50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47F54: 4082FFE8  bne 0x82a47f3c
	if !ctx.cr[0].eq {
	pc = 0x82A47F3C; continue 'dispatch;
	}
	// 82A47F58: C3DD0184  lfs f30, 0x184(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A47F5C: 3BDC05E0  addi r30, r28, 0x5e0
	ctx.r[30].s64 = ctx.r[28].s64 + 1504;
	// 82A47F60: 4B887FC1  bl 0x822cff20
	ctx.lr = 0x82A47F64;
	sub_822CFF20(ctx, base);
	// 82A47F64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A47F68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A47F6C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A47F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A47F74: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A47F78: 4BFFD079  bl 0x82a44ff0
	ctx.lr = 0x82A47F7C;
	sub_82A44FF0(ctx, base);
	// 82A47F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A47F80: 48000008  b 0x82a47f88
	pc = 0x82A47F88; continue 'dispatch;
	// 82A47F84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A47F88: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A47F8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A47F90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A47F94: 4BFFFBED  bl 0x82a47b80
	ctx.lr = 0x82A47F98;
	sub_82A47B80(ctx, base);
	// 82A47F98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A47F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A47FA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A47FA4: 4B87805D  bl 0x822c0000
	ctx.lr = 0x82A47FA8;
	sub_822C0000(ctx, base);
	// 82A47FA8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A47FAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A47FB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A47FB4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A47FB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A47FBC: 419A0024  beq cr6, 0x82a47fe0
	if ctx.cr[6].eq {
	pc = 0x82A47FE0; continue 'dispatch;
	}
	// 82A47FC0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A47FC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A47FC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47FCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A47FD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A47FD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A47FD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A47FDC: 4082FFE8  bne 0x82a47fc4
	if !ctx.cr[0].eq {
	pc = 0x82A47FC4; continue 'dispatch;
	}
	// 82A47FE0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A47FE4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A47FE8: 4BAC74E1  bl 0x8250f4c8
	ctx.lr = 0x82A47FEC;
	sub_8250F4C8(ctx, base);
	// 82A47FEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A47FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A47FF4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A47FF8: 409A0008  bne cr6, 0x82a48000
	if !ctx.cr[6].eq {
	pc = 0x82A48000; continue 'dispatch;
	}
	// 82A47FFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A48000: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A48004: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A48008: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 82A4800C: 4BAC750D  bl 0x8250f518
	ctx.lr = 0x82A48010;
	sub_8250F518(ctx, base);
	// 82A48010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A48014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48018: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A4801C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A48020: 4BAC54E9  bl 0x8250d508
	ctx.lr = 0x82A48024;
	sub_8250D508(ctx, base);
	// 82A48024: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A48028: 483A9C69  bl 0x82df1c90
	ctx.lr = 0x82A4802C;
	sub_82DF1C90(ctx, base);
	// 82A4802C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A48030: 483A9C61  bl 0x82df1c90
	ctx.lr = 0x82A48034;
	sub_82DF1C90(ctx, base);
	// 82A48034: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A48038: 419A000C  beq cr6, 0x82a48044
	if ctx.cr[6].eq {
	pc = 0x82A48044; continue 'dispatch;
	}
	// 82A4803C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A48040: 4B878851  bl 0x822c0890
	ctx.lr = 0x82A48044;
	sub_822C0890(ctx, base);
	// 82A48044: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A48048: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82A4804C: 4198FE9C  blt cr6, 0x82a47ee8
	if ctx.cr[6].lt {
	pc = 0x82A47EE8; continue 'dispatch;
	}
	// 82A48050: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A48054: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82A48058: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A4805C: 48760150  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A48060 size=60
    let mut pc: u32 = 0x82A48060;
    'dispatch: loop {
        match pc {
            0x82A48060 => {
    //   block [0x82A48060..0x82A4809C)
	// 82A48060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4806C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48074: 4870C58D  bl 0x83154600
	ctx.lr = 0x82A48078;
	sub_83154600(ctx, base);
	// 82A48078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4807C: 4BFFFA1D  bl 0x82a47a98
	ctx.lr = 0x82A48080;
	sub_82A47A98(ctx, base);
	// 82A48080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48084: 4BFFFC95  bl 0x82a47d18
	ctx.lr = 0x82A48088;
	sub_82A47D18(ctx, base);
	// 82A48088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4808C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A48098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A480A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A480A0 size=92
    let mut pc: u32 = 0x82A480A0;
    'dispatch: loop {
        match pc {
            0x82A480A0 => {
    //   block [0x82A480A0..0x82A480FC)
	// 82A480A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A480A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A480A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A480AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A480B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A480B4: 4BFE9E05  bl 0x82a31eb8
	ctx.lr = 0x82A480B8;
	sub_82A31EB8(ctx, base);
	// 82A480B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A480BC: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A480C0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A480C4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A480C8: 3929CDD4  addi r9, r9, -0x322c
	ctx.r[9].s64 = ctx.r[9].s64 + -12844;
	// 82A480CC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A480D0: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A480D4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A480D8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A480DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A480E0: C00A3B18  lfs f0, 0x3b18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A480E4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A480E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A480EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A480F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A480F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A480F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A48100 size=36
    let mut pc: u32 = 0x82A48100;
    'dispatch: loop {
        match pc {
            0x82A48100 => {
    //   block [0x82A48100..0x82A48124)
	// 82A48100: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A48104: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48108: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4810C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A48110: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A48114: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A48118: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4811C: 41980020  blt cr6, 0x82a4813c
	if ctx.cr[6].lt {
		sub_82A4813C(ctx, base);
		return;
	}
	// 82A48120: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48124(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A48124 size=16
    let mut pc: u32 = 0x82A48124;
    'dispatch: loop {
        match pc {
            0x82A48124 => {
    //   block [0x82A48124..0x82A48134)
	// 82A48124: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A48128: C1AB3B3C  lfs f13, 0x3b3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4812C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A48130: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48134(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A48134 size=8
    let mut pc: u32 = 0x82A48134;
    'dispatch: loop {
        match pc {
            0x82A48134 => {
    //   block [0x82A48134..0x82A4813C)
	// 82A48134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A48138: 4800001C  b 0x82a48154
	sub_82A48150(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4813C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4813C size=20
    let mut pc: u32 = 0x82A4813C;
    'dispatch: loop {
        match pc {
            0x82A4813C => {
    //   block [0x82A4813C..0x82A48150)
	// 82A4813C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A48140: 396B3B3C  addi r11, r11, 0x3b3c
	ctx.r[11].s64 = ctx.r[11].s64 + 15164;
	// 82A48144: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48148: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4814C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A48150 size=20
    let mut pc: u32 = 0x82A48150;
    'dispatch: loop {
        match pc {
            0x82A48150 => {
    //   block [0x82A48150..0x82A48164)
	// 82A48150: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A48154: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A48158: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4815C: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A48160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A48168 size=64
    let mut pc: u32 = 0x82A48168;
    'dispatch: loop {
        match pc {
            0x82A48168 => {
    //   block [0x82A48168..0x82A481A8)
	// 82A48168: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4816C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A48170: 419800CC  blt cr6, 0x82a4823c
	if ctx.cr[6].lt {
		sub_82A4823C(ctx, base);
		return;
	}
	// 82A48174: 419A0094  beq cr6, 0x82a48208
	if ctx.cr[6].eq {
		sub_82A48208(ctx, base);
		return;
	}
	// 82A48178: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4817C: 41980078  blt cr6, 0x82a481f4
	if ctx.cr[6].lt {
		sub_82A481F4(ctx, base);
		return;
	}
	// 82A48180: 419A0060  beq cr6, 0x82a481e0
	if ctx.cr[6].eq {
		sub_82A481E0(ctx, base);
		return;
	}
	// 82A48184: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A48188: 41980038  blt cr6, 0x82a481c0
	if ctx.cr[6].lt {
		sub_82A481C0(ctx, base);
		return;
	}
	// 82A4818C: 419A001C  beq cr6, 0x82a481a8
	if ctx.cr[6].eq {
		sub_82A481A8(ctx, base);
		return;
	}
	// 82A48190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A48194: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48198: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4819C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A481A0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A481A4: 480000C0  b 0x82a48264
	sub_82A4823C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A481A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A481A8 size=24
    let mut pc: u32 = 0x82A481A8;
    'dispatch: loop {
        match pc {
            0x82A481A8 => {
    //   block [0x82A481A8..0x82A481C0)
	// 82A481A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A481AC: 396B3B30  addi r11, r11, 0x3b30
	ctx.r[11].s64 = ctx.r[11].s64 + 15152;
	// 82A481B0: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A481B4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A481B8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A481BC: 48000060  b 0x82a4821c
	sub_82A48208(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A481C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A481C0 size=32
    let mut pc: u32 = 0x82A481C0;
    'dispatch: loop {
        match pc {
            0x82A481C0 => {
    //   block [0x82A481C0..0x82A481E0)
	// 82A481C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A481C4: 392B3B30  addi r9, r11, 0x3b30
	ctx.r[9].s64 = ctx.r[11].s64 + 15152;
	// 82A481C8: C1AB3B30  lfs f13, 0x3b30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A481CC: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A481D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A481D4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A481D8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A481DC: 48000080  b 0x82a4825c
	sub_82A4823C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A481E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A481E0 size=20
    let mut pc: u32 = 0x82A481E0;
    'dispatch: loop {
        match pc {
            0x82A481E0 => {
    //   block [0x82A481E0..0x82A481F4)
	// 82A481E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A481E4: 396B3B30  addi r11, r11, 0x3b30
	ctx.r[11].s64 = ctx.r[11].s64 + 15152;
	// 82A481E8: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A481EC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A481F0: 4800005C  b 0x82a4824c
	sub_82A4823C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A481F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A481F4 size=20
    let mut pc: u32 = 0x82A481F4;
    'dispatch: loop {
        match pc {
            0x82A481F4 => {
    //   block [0x82A481F4..0x82A48208)
	// 82A481F4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A481F8: 396B3B30  addi r11, r11, 0x3b30
	ctx.r[11].s64 = ctx.r[11].s64 + 15152;
	// 82A481FC: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48200: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A48204: 4BFFFFCC  b 0x82a481d0
	sub_82A481C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A48208 size=52
    let mut pc: u32 = 0x82A48208;
    'dispatch: loop {
        match pc {
            0x82A48208 => {
    //   block [0x82A48208..0x82A4823C)
	// 82A48208: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4820C: 396B3B30  addi r11, r11, 0x3b30
	ctx.r[11].s64 = ctx.r[11].s64 + 15152;
	// 82A48210: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48214: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A48218: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4821C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A48220: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48224: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A48228: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4822C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A48230: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A48234: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A48238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4823C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4823C size=48
    let mut pc: u32 = 0x82A4823C;
    'dispatch: loop {
        match pc {
            0x82A4823C => {
    //   block [0x82A4823C..0x82A4826C)
	// 82A4823C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A48240: 396B3B30  addi r11, r11, 0x3b30
	ctx.r[11].s64 = ctx.r[11].s64 + 15152;
	// 82A48244: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48248: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4824C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A48250: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48254: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A48258: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4825C: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A48260: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A48264: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A48268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A48270 size=196
    let mut pc: u32 = 0x82A48270;
    'dispatch: loop {
        match pc {
            0x82A48270 => {
    //   block [0x82A48270..0x82A48334)
	// 82A48270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4827C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A48280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48284: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4828C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A48290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A48294: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A48298: 4B8786A1  bl 0x822c0938
	ctx.lr = 0x82A4829C;
	sub_822C0938(ctx, base);
	// 82A4829C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A482A0: 41820028  beq 0x82a482c8
	if ctx.cr[0].eq {
	pc = 0x82A482C8; continue 'dispatch;
	}
	// 82A482A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A482A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A482AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A482B0: 392BCE00  addi r9, r11, -0x3200
	ctx.r[9].s64 = ctx.r[11].s64 + -12800;
	// 82A482B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A482B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A482BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A482C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A482C4: 48000008  b 0x82a482cc
	pc = 0x82A482CC; continue 'dispatch;
	// 82A482C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A482CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A482D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A482D4: 409A0044  bne cr6, 0x82a48318
	if !ctx.cr[6].eq {
	pc = 0x82A48318; continue 'dispatch;
	}
	// 82A482D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A482DC: 419A001C  beq cr6, 0x82a482f8
	if ctx.cr[6].eq {
	pc = 0x82A482F8; continue 'dispatch;
	}
	// 82A482E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A482E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A482E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A482EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A482F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A482F4: 4E800421  bctrl
	ctx.lr = 0x82A482F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A482F8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A482FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A48300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A48304: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A48308: 816B3B44  lwz r11, 0x3b44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15172 as u32) ) } as u64;
	// 82A4830C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A48310: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A48314: 4B877CED  bl 0x822c0000
	ctx.lr = 0x82A48318;
	sub_822C0000(ctx, base);
	// 82A48318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4831C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A48320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48328: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4832C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A48330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A48338 size=524
    let mut pc: u32 = 0x82A48338;
    'dispatch: loop {
        match pc {
            0x82A48338 => {
    //   block [0x82A48338..0x82A48544)
	// 82A48338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4833C: 4875FE31  bl 0x831a816c
	ctx.lr = 0x82A48340;
	sub_831A8130(ctx, base);
	// 82A48340: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A48344: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A48348: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48548 size=248
    let mut pc: u32 = 0x82A48548;
    'dispatch: loop {
        match pc {
            0x82A48548 => {
    //   block [0x82A48548..0x82A48640)
	// 82A48548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4854C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A48554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A48558: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4855C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48560: 4870C0A1  bl 0x83154600
	ctx.lr = 0x82A48564;
	sub_83154600(ctx, base);
	// 82A48564: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4856C: 4BFFE44D  bl 0x82a469b8
	ctx.lr = 0x82A48570;
	sub_82A469B8(ctx, base);
	// 82A48570: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A48574: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A48578: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4857C: 388ACE10  addi r4, r10, -0x31f0
	ctx.r[4].s64 = ctx.r[10].s64 + -12784;
	// 82A48580: 38A000E7  li r5, 0xe7
	ctx.r[5].s64 = 231;
	// 82A48584: C00BD72C  lfs f0, -0x28d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48588: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A4858C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A48590: 4B877E49  bl 0x822c03d8
	ctx.lr = 0x82A48594;
	sub_822C03D8(ctx, base);
	// 82A48594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A48598: 41820010  beq 0x82a485a8
	if ctx.cr[0].eq {
	pc = 0x82A485A8; continue 'dispatch;
	}
	// 82A4859C: 4BFFFB05  bl 0x82a480a0
	ctx.lr = 0x82A485A0;
	sub_82A480A0(ctx, base);
	// 82A485A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A485A4: 48000008  b 0x82a485ac
	pc = 0x82A485AC; continue 'dispatch;
	// 82A485A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A485AC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A485B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A485B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A485B8: 4BFFFCB9  bl 0x82a48270
	ctx.lr = 0x82A485BC;
	sub_82A48270(ctx, base);
	// 82A485BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A485C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A485C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A485C8: 4B877A39  bl 0x822c0000
	ctx.lr = 0x82A485CC;
	sub_822C0000(ctx, base);
	// 82A485CC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A485D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A485D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A485D8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A485DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A485E0: 419A0024  beq cr6, 0x82a48604
	if ctx.cr[6].eq {
	pc = 0x82A48604; continue 'dispatch;
	}
	// 82A485E4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A485E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A485EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A485F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A485F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A485F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A485FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A48600: 4082FFE8  bne 0x82a485e8
	if !ctx.cr[0].eq {
	pc = 0x82A485E8; continue 'dispatch;
	}
	// 82A48604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A48608: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A4860C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A48610: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A48614: 4BFEFF8D  bl 0x82a385a0
	ctx.lr = 0x82A48618;
	sub_82A385A0(ctx, base);
	// 82A48618: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4861C: 419A000C  beq cr6, 0x82a48628
	if ctx.cr[6].eq {
	pc = 0x82A48628; continue 'dispatch;
	}
	// 82A48620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48624: 4B87826D  bl 0x822c0890
	ctx.lr = 0x82A48628;
	sub_822C0890(ctx, base);
	// 82A48628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4862C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48634: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A48638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A48640 size=52
    let mut pc: u32 = 0x82A48640;
    'dispatch: loop {
        match pc {
            0x82A48640 => {
    //   block [0x82A48640..0x82A48674)
	// 82A48640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4864C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48654: 4BFFFCE5  bl 0x82a48338
	ctx.lr = 0x82A48658;
	sub_82A48338(ctx, base);
	// 82A48658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4865C: 4870BFA5  bl 0x83154600
	ctx.lr = 0x82A48660;
	sub_83154600(ctx, base);
	// 82A48660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A48664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4866C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A48670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48678 size=292
    let mut pc: u32 = 0x82A48678;
    'dispatch: loop {
        match pc {
            0x82A48678 => {
    //   block [0x82A48678..0x82A4879C)
	// 82A48678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4867C: 4875FAF1  bl 0x831a816c
	ctx.lr = 0x82A48680;
	sub_831A8130(ctx, base);
	// 82A48680: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A48684: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A48688: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4868C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48690: 4870BF71  bl 0x83154600
	ctx.lr = 0x82A48694;
	sub_83154600(ctx, base);
	// 82A48694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4869C: 484110C5  bl 0x82e59760
	ctx.lr = 0x82A486A0;
	sub_82E59760(ctx, base);
	// 82A486A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A486A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A486A8: 396B3BDC  addi r11, r11, 0x3bdc
	ctx.r[11].s64 = ctx.r[11].s64 + 15324;
	// 82A486AC: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A486B0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A486B4: EDA10024  fdivs f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A486B8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82A486BC: 41980008  blt cr6, 0x82a486c4
	if ctx.cr[6].lt {
	pc = 0x82A486C4; continue 'dispatch;
	}
	// 82A486C0: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82A486C4: C19F0180  lfs f12, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A486C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A486CC: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A486D0: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A486D4: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A486D8: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A486DC: 48005FE5  bl 0x82a4e6c0
	ctx.lr = 0x82A486E0;
	sub_82A4E6C0(ctx, base);
	// 82A486E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A486E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A486E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A486EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A486F0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A486F4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A486F8: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A486FC: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A48700: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A48704: 4800609D  bl 0x82a4e7a0
	ctx.lr = 0x82A48708;
	sub_82A4E7A0(ctx, base);
	// 82A48708: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A4870C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A48710: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82A48714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48718: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A4871C: 4800609D  bl 0x82a4e7b8
	ctx.lr = 0x82A48720;
	sub_82A4E7B8(ctx, base);
	// 82A48720: 38BE0610  addi r5, r30, 0x610
	ctx.r[5].s64 = ctx.r[30].s64 + 1552;
	// 82A48724: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A48728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4872C: 48006075  bl 0x82a4e7a0
	ctx.lr = 0x82A48730;
	sub_82A4E7A0(ctx, base);
	// 82A48730: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A48734: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A48738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4873C: 4800607D  bl 0x82a4e7b8
	ctx.lr = 0x82A48740;
	sub_82A4E7B8(ctx, base);
	// 82A48740: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A48744: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A48748: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4874C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A48750: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A48754: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A48758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4875C: 48006045  bl 0x82a4e7a0
	ctx.lr = 0x82A48760;
	sub_82A4E7A0(ctx, base);
	// 82A48760: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A48764: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A48768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4876C: 4800604D  bl 0x82a4e7b8
	ctx.lr = 0x82A48770;
	sub_82A4E7B8(ctx, base);
	// 82A48770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48774: 48410FED  bl 0x82e59760
	ctx.lr = 0x82A48778;
	sub_82E59760(ctx, base);
	// 82A48778: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82A4877C: 40990008  ble cr6, 0x82a48784
	if !ctx.cr[6].gt {
	pc = 0x82A48784; continue 'dispatch;
	}
	// 82A48780: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A48784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48788: 48006069  bl 0x82a4e7f0
	ctx.lr = 0x82A4878C;
	sub_82A4E7F0(ctx, base);
	// 82A4878C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A48790: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A48794: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A48798: 4875FA24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A487A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A487A0 size=196
    let mut pc: u32 = 0x82A487A0;
    'dispatch: loop {
        match pc {
            0x82A487A0 => {
    //   block [0x82A487A0..0x82A48864)
	// 82A487A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A487A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A487A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A487AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A487B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A487B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A487B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A487BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A487C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A487C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A487C8: 4B878171  bl 0x822c0938
	ctx.lr = 0x82A487CC;
	sub_822C0938(ctx, base);
	// 82A487CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A487D0: 41820028  beq 0x82a487f8
	if ctx.cr[0].eq {
	pc = 0x82A487F8; continue 'dispatch;
	}
	// 82A487D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A487D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A487DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A487E0: 392BCE68  addi r9, r11, -0x3198
	ctx.r[9].s64 = ctx.r[11].s64 + -12696;
	// 82A487E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A487E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A487EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A487F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A487F4: 48000008  b 0x82a487fc
	pc = 0x82A487FC; continue 'dispatch;
	// 82A487F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A487FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A48800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A48804: 409A0044  bne cr6, 0x82a48848
	if !ctx.cr[6].eq {
	pc = 0x82A48848; continue 'dispatch;
	}
	// 82A48808: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4880C: 419A001C  beq cr6, 0x82a48828
	if ctx.cr[6].eq {
	pc = 0x82A48828; continue 'dispatch;
	}
	// 82A48810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A48814: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A48818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4881C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A48820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A48824: 4E800421  bctrl
	ctx.lr = 0x82A48828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A48828: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4882C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A48830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A48834: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A48838: 816B3C58  lwz r11, 0x3c58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15448 as u32) ) } as u64;
	// 82A4883C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A48840: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A48844: 4B8777BD  bl 0x822c0000
	ctx.lr = 0x82A48848;
	sub_822C0000(ctx, base);
	// 82A48848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4884C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A48850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48858: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4885C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A48860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48868 size=184
    let mut pc: u32 = 0x82A48868;
    'dispatch: loop {
        match pc {
            0x82A48868 => {
    //   block [0x82A48868..0x82A48920)
	// 82A48868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4886C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A48874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A48878: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4887C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48880: 4870BD81  bl 0x83154600
	ctx.lr = 0x82A48884;
	sub_83154600(ctx, base);
	// 82A48884: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4888C: 4BFFE12D  bl 0x82a469b8
	ctx.lr = 0x82A48890;
	sub_82A469B8(ctx, base);
	// 82A48890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A48894: C01E05FC  lfs f0, 0x5fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48898: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4889C: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A488A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A488A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A488A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A488AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A488B0: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A488B4: 4BFEFCED  bl 0x82a385a0
	ctx.lr = 0x82A488B8;
	sub_82A385A0(ctx, base);
	// 82A488B8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A488BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A488C0: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A488C4: 483AB145  bl 0x82df3a08
	ctx.lr = 0x82A488C8;
	sub_82DF3A08(ctx, base);
	// 82A488C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A488CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A488D0: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A488D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A488D8: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A488DC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A488E0: 4816AA99  bl 0x82bb3378
	ctx.lr = 0x82A488E4;
	sub_82BB3378(ctx, base);
	// 82A488E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A488E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A488EC: 419A0008  beq cr6, 0x82a488f4
	if ctx.cr[6].eq {
	pc = 0x82A488F4; continue 'dispatch;
	}
	// 82A488F0: 4B877FA1  bl 0x822c0890
	ctx.lr = 0x82A488F4;
	sub_822C0890(ctx, base);
	// 82A488F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A488F8: 483AAB31  bl 0x82df3428
	ctx.lr = 0x82A488FC;
	sub_82DF3428(ctx, base);
	// 82A488FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A48900: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48904: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A48908: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4890C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48914: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A48918: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4891C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48920 size=536
    let mut pc: u32 = 0x82A48920;
    'dispatch: loop {
        match pc {
            0x82A48920 => {
    //   block [0x82A48920..0x82A48B38)
	// 82A48920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48924: 4875F82D  bl 0x831a8150
	ctx.lr = 0x82A48928;
	sub_831A8130(ctx, base);
	// 82A48928: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82A4892C: 4876014D  bl 0x831a8a78
	ctx.lr = 0x82A48930;
	sub_831A8A40(ctx, base);
	// 82A48930: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48934: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A48938: 4870BCC9  bl 0x83154600
	ctx.lr = 0x82A4893C;
	sub_83154600(ctx, base);
	// 82A4893C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A48940: C3BA0184  lfs f29, 0x184(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A48944: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A48948: 48410E31  bl 0x82e59778
	ctx.lr = 0x82A4894C;
	sub_82E59778(ctx, base);
	// 82A4894C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A48950: C01A0184  lfs f0, 0x184(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48954: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 82A48958: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A4895C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A48960: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A48964: D01A0184  stfs f0, 0x184(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A48968: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A4896C: C3C808A4  lfs f30, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A48970: 3F208338  lis r25, -0x7cc8
	ctx.r[25].s64 = -2093481984;
	// 82A48974: 3BC93C20  addi r30, r9, 0x3c20
	ctx.r[30].s64 = ctx.r[9].s64 + 15392;
	// 82A48978: 3B6ADEE0  addi r27, r10, -0x2120
	ctx.r[27].s64 = ctx.r[10].s64 + -8480;
	// 82A4897C: 3AEBCE78  addi r23, r11, -0x3188
	ctx.r[23].s64 = ctx.r[11].s64 + -12680;
	// 82A48980: 397EFFCC  addi r11, r30, -0x34
	ctx.r[11].s64 = ctx.r[30].s64 + -52;
	// 82A48984: 7C185C2E  lfsx f0, r24, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48988: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82A4898C: 41990190  bgt cr6, 0x82a48b1c
	if ctx.cr[6].gt {
	pc = 0x82A48B1C; continue 'dispatch;
	}
	// 82A48990: C1BA0184  lfs f13, 0x184(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48994: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A48998: 40980184  bge cr6, 0x82a48b1c
	if !ctx.cr[6].lt {
	pc = 0x82A48B1C; continue 'dispatch;
	}
	// 82A4899C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A489A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A489A4: 38A0013F  li r5, 0x13f
	ctx.r[5].s64 = 319;
	// 82A489A8: 38600360  li r3, 0x360
	ctx.r[3].s64 = 864;
	// 82A489AC: 483A9A3D  bl 0x82df23e8
	ctx.lr = 0x82A489B0;
	sub_82DF23E8(ctx, base);
	// 82A489B0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A489B4: 418200A8  beq 0x82a48a5c
	if ctx.cr[0].eq {
	pc = 0x82A48A5C; continue 'dispatch;
	}
	// 82A489B8: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A489BC: C01E0034  lfs f0, 0x34(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A489C0: C1B9DED0  lfs f13, -0x2130(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-8496 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A489C4: 7D98F42E  lfsx f12, r24, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A489C8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A489CC: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A489D0: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A489D4: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A489D8: 815D053C  lwz r10, 0x53c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A489DC: 817D0540  lwz r11, 0x540(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1344 as u32) ) } as u64;
	// 82A489E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A489E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A489E8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A489EC: 419A0024  beq cr6, 0x82a48a10
	if ctx.cr[6].eq {
	pc = 0x82A48A10; continue 'dispatch;
	}
	// 82A489F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A489F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A489F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A489FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A48A00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A48A04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A48A08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A48A0C: 4082FFE8  bne 0x82a489f4
	if !ctx.cr[0].eq {
	pc = 0x82A489F4; continue 'dispatch;
	}
	// 82A48A10: C3FEFFC4  lfs f31, -0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A48A14: 4B88750D  bl 0x822cff20
	ctx.lr = 0x82A48A18;
	sub_822CFF20(ctx, base);
	// 82A48A18: C01EFFC8  lfs f0, -0x38(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48A1C: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82A48A20: EF81002A  fadds f28, f1, f0
	ctx.f[28].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A48A24: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 82A48A28: 3AC10058  addi r22, r1, 0x58
	ctx.r[22].s64 = ctx.r[1].s64 + 88;
	// 82A48A2C: 485C058D  bl 0x83008fb8
	ctx.lr = 0x82A48A30;
	sub_83008FB8(ctx, base);
	// 82A48A30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A48A34: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82A48A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48A3C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A48A40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A48A44: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82A48A48: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A48A4C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82A48A50: 48010981  bl 0x82a593d0
	ctx.lr = 0x82A48A54;
	sub_82A593D0(ctx, base);
	// 82A48A54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48A58: 48000008  b 0x82a48a60
	pc = 0x82A48A60; continue 'dispatch;
	// 82A48A5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A48A60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A48A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A48A68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A48A6C: 4BFFFD35  bl 0x82a487a0
	ctx.lr = 0x82A48A70;
	sub_82A487A0(ctx, base);
	// 82A48A70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A48A74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A48A78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A48A7C: 4B877585  bl 0x822c0000
	ctx.lr = 0x82A48A80;
	sub_822C0000(ctx, base);
	// 82A48A80: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A48A84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A48A88: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A48A8C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A48A90: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A48A94: 419A0024  beq cr6, 0x82a48ab8
	if ctx.cr[6].eq {
	pc = 0x82A48AB8; continue 'dispatch;
	}
	// 82A48A98: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A48A9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A48AA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A48AA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A48AA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A48AAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A48AB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A48AB4: 4082FFE8  bne 0x82a48a9c
	if !ctx.cr[0].eq {
	pc = 0x82A48A9C; continue 'dispatch;
	}
	// 82A48AB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A48ABC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A48AC0: 4BAC6A09  bl 0x8250f4c8
	ctx.lr = 0x82A48AC4;
	sub_8250F4C8(ctx, base);
	// 82A48AC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A48AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A48ACC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A48AD0: 409A0008  bne cr6, 0x82a48ad8
	if !ctx.cr[6].eq {
	pc = 0x82A48AD8; continue 'dispatch;
	}
	// 82A48AD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A48AD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A48ADC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A48AE0: 3AC10060  addi r22, r1, 0x60
	ctx.r[22].s64 = ctx.r[1].s64 + 96;
	// 82A48AE4: 4BAC6A35  bl 0x8250f518
	ctx.lr = 0x82A48AE8;
	sub_8250F518(ctx, base);
	// 82A48AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A48AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48AF0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82A48AF4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A48AF8: 4BAC4A11  bl 0x8250d508
	ctx.lr = 0x82A48AFC;
	sub_8250D508(ctx, base);
	// 82A48AFC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A48B00: 483A9191  bl 0x82df1c90
	ctx.lr = 0x82A48B04;
	sub_82DF1C90(ctx, base);
	// 82A48B04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A48B08: 483A9189  bl 0x82df1c90
	ctx.lr = 0x82A48B0C;
	sub_82DF1C90(ctx, base);
	// 82A48B0C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A48B10: 419A000C  beq cr6, 0x82a48b1c
	if ctx.cr[6].eq {
	pc = 0x82A48B1C; continue 'dispatch;
	}
	// 82A48B14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A48B18: 4B877D79  bl 0x822c0890
	ctx.lr = 0x82A48B1C;
	sub_822C0890(ctx, base);
	// 82A48B1C: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 82A48B20: 2F180034  cmpwi cr6, r24, 0x34
	ctx.cr[6].compare_i32(ctx.r[24].s32, 52, &mut ctx.xer);
	// 82A48B24: 4198FE5C  blt cr6, 0x82a48980
	if ctx.cr[6].lt {
	pc = 0x82A48980; continue 'dispatch;
	}
	// 82A48B28: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A48B2C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82A48B30: 4875FF95  bl 0x831a8ac4
	ctx.lr = 0x82A48B34;
	sub_831A8A8C(ctx, base);
	// 82A48B34: 4875F66C  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A48B38 size=52
    let mut pc: u32 = 0x82A48B38;
    'dispatch: loop {
        match pc {
            0x82A48B38 => {
    //   block [0x82A48B38..0x82A48B6C)
	// 82A48B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A48B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A48B44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48B48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48B4C: 4BFFFB2D  bl 0x82a48678
	ctx.lr = 0x82A48B50;
	sub_82A48678(ctx, base);
	// 82A48B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48B54: 4BFFFDCD  bl 0x82a48920
	ctx.lr = 0x82A48B58;
	sub_82A48920(ctx, base);
	// 82A48B58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A48B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A48B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A48B64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A48B68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48B70 size=260
    let mut pc: u32 = 0x82A48B70;
    'dispatch: loop {
        match pc {
            0x82A48B70 => {
    //   block [0x82A48B70..0x82A48C74)
	// 82A48B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48B74: 4875F5F9  bl 0x831a816c
	ctx.lr = 0x82A48B78;
	sub_831A8130(ctx, base);
	// 82A48B78: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A48B7C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48B80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48B84: 4870BA7D  bl 0x83154600
	ctx.lr = 0x82A48B88;
	sub_83154600(ctx, base);
	// 82A48B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A48B8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A48B90: 4BFFDE29  bl 0x82a469b8
	ctx.lr = 0x82A48B94;
	sub_82A469B8(ctx, base);
	// 82A48B94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A48B98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A48B9C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A48BA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A48BA4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A48BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A48BAC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A48BB0: 4BFEF9F1  bl 0x82a385a0
	ctx.lr = 0x82A48BB4;
	sub_82A385A0(ctx, base);
	// 82A48BB4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A48BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A48BBC: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A48BC0: 483AAE49  bl 0x82df3a08
	ctx.lr = 0x82A48BC4;
	sub_82DF3A08(ctx, base);
	// 82A48BC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A48BC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A48BCC: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A48BD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A48BD4: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A48BD8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A48BDC: 4816A79D  bl 0x82bb3378
	ctx.lr = 0x82A48BE0;
	sub_82BB3378(ctx, base);
	// 82A48BE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A48BE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A48BE8: 419A0008  beq cr6, 0x82a48bf0
	if ctx.cr[6].eq {
	pc = 0x82A48BF0; continue 'dispatch;
	}
	// 82A48BEC: 4B877CA5  bl 0x822c0890
	ctx.lr = 0x82A48BF0;
	sub_822C0890(ctx, base);
	// 82A48BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A48BF4: 483AA835  bl 0x82df3428
	ctx.lr = 0x82A48BF8;
	sub_82DF3428(ctx, base);
	// 82A48BF8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A48BFC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82A48C00: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A48C04: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A48C08: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A48C0C: C00B57F0  lfs f0, 0x57f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A48C10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A48C14: C1AAAA18  lfs f13, -0x55e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21992 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48C18: C1898498  lfs f12, -0x7b68(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31592 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A48C1C: C16808A4  lfs f11, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A48C20: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A48C24: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A48C28: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A48C2C: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A48C30: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A48C34: C02789AC  lfs f1, -0x7654(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A48C38: 4B887891  bl 0x822d04c8
	ctx.lr = 0x82A48C3C;
	sub_822D04C8(ctx, base);
	// 82A48C3C: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A48C40: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A48C44: 4B8872DD  bl 0x822cff20
	ctx.lr = 0x82A48C48;
	sub_822CFF20(ctx, base);
	// 82A48C48: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A48C4C: C1BF05FC  lfs f13, 0x5fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A48C50: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A48C54: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A48C58: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A48C5C: D01F05FC  stfs f0, 0x5fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A48C60: 4B8872D1  bl 0x822cff30
	ctx.lr = 0x82A48C64;
	sub_822CFF30(ctx, base);
	// 82A48C64: 9BBE0180  stb r29, 0x180(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), ctx.r[29].u8 ) };
	// 82A48C68: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A48C6C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A48C70: 4875F54C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A48C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A48C78 size=1256
    let mut pc: u32 = 0x82A48C78;
    'dispatch: loop {
        match pc {
            0x82A48C78 => {
    //   block [0x82A48C78..0x82A49160)
	// 82A48C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A48C7C: 4875F4E5  bl 0x831a8160
	ctx.lr = 0x82A48C80;
	sub_831A8130(ctx, base);
	// 82A48C80: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82A48C84: 4875FDF5  bl 0x831a8a78
	ctx.lr = 0x82A48C88;
	sub_831A8A40(ctx, base);
	// 82A48C88: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A48C8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A48C90: 4870B971  bl 0x83154600
	ctx.lr = 0x82A48C94;
	sub_83154600(ctx, base);
	// 82A48C94: 897C0180  lbz r11, 0x180(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(384 as u32) ) } as u64;
	// 82A48C98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A48C9C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82A48CA0: 41980054  blt cr6, 0x82a48cf4
	if ctx.cr[6].lt {
	pc = 0x82A48CF4; continue 'dispatch;
	}
	// 82A48CA4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A48CA8: 39400610  li r10, 0x610
	ctx.r[10].s64 = 1552;
	// 82A48CAC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A48CB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A48CB4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49160 size=92
    let mut pc: u32 = 0x82A49160;
    'dispatch: loop {
        match pc {
            0x82A49160 => {
    //   block [0x82A49160..0x82A491BC)
	// 82A49160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49168: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4916C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49174: 4BFE8D45  bl 0x82a31eb8
	ctx.lr = 0x82A49178;
	sub_82A31EB8(ctx, base);
	// 82A49178: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4917C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A49180: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A49184: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A49188: 3929CF34  addi r9, r9, -0x30cc
	ctx.r[9].s64 = ctx.r[9].s64 + -12492;
	// 82A4918C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49190: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A49194: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A49198: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4919C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A491A0: C00A3CE4  lfs f0, 0x3ce4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A491A4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A491A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A491AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A491B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A491B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A491B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A491C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A491C0 size=36
    let mut pc: u32 = 0x82A491C0;
    'dispatch: loop {
        match pc {
            0x82A491C0 => {
    //   block [0x82A491C0..0x82A491E4)
	// 82A491C0: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A491C4: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A491C8: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A491CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A491D0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A491D4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A491D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A491DC: 41980020  blt cr6, 0x82a491fc
	if ctx.cr[6].lt {
		sub_82A491FC(ctx, base);
		return;
	}
	// 82A491E0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A491E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A491E4 size=16
    let mut pc: u32 = 0x82A491E4;
    'dispatch: loop {
        match pc {
            0x82A491E4 => {
    //   block [0x82A491E4..0x82A491F4)
	// 82A491E4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A491E8: C1AB3D08  lfs f13, 0x3d08(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15624 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A491EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A491F0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A491F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A491F4 size=8
    let mut pc: u32 = 0x82A491F4;
    'dispatch: loop {
        match pc {
            0x82A491F4 => {
    //   block [0x82A491F4..0x82A491FC)
	// 82A491F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A491F8: 4800001C  b 0x82a49214
	sub_82A49210(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A491FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A491FC size=20
    let mut pc: u32 = 0x82A491FC;
    'dispatch: loop {
        match pc {
            0x82A491FC => {
    //   block [0x82A491FC..0x82A49210)
	// 82A491FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A49200: 396B3D08  addi r11, r11, 0x3d08
	ctx.r[11].s64 = ctx.r[11].s64 + 15624;
	// 82A49204: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A49208: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4920C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A49210 size=20
    let mut pc: u32 = 0x82A49210;
    'dispatch: loop {
        match pc {
            0x82A49210 => {
    //   block [0x82A49210..0x82A49224)
	// 82A49210: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A49214: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A49218: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4921C: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A49220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A49228 size=64
    let mut pc: u32 = 0x82A49228;
    'dispatch: loop {
        match pc {
            0x82A49228 => {
    //   block [0x82A49228..0x82A49268)
	// 82A49228: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4922C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A49230: 419800CC  blt cr6, 0x82a492fc
	if ctx.cr[6].lt {
		sub_82A492FC(ctx, base);
		return;
	}
	// 82A49234: 419A0094  beq cr6, 0x82a492c8
	if ctx.cr[6].eq {
		sub_82A492C8(ctx, base);
		return;
	}
	// 82A49238: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4923C: 41980078  blt cr6, 0x82a492b4
	if ctx.cr[6].lt {
		sub_82A492B4(ctx, base);
		return;
	}
	// 82A49240: 419A0060  beq cr6, 0x82a492a0
	if ctx.cr[6].eq {
		sub_82A492A0(ctx, base);
		return;
	}
	// 82A49244: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A49248: 41980038  blt cr6, 0x82a49280
	if ctx.cr[6].lt {
		sub_82A49280(ctx, base);
		return;
	}
	// 82A4924C: 419A001C  beq cr6, 0x82a49268
	if ctx.cr[6].eq {
		sub_82A49268(ctx, base);
		return;
	}
	// 82A49250: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A49254: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49258: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4925C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A49260: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A49264: 480000C0  b 0x82a49324
	sub_82A492FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A49268 size=24
    let mut pc: u32 = 0x82A49268;
    'dispatch: loop {
        match pc {
            0x82A49268 => {
    //   block [0x82A49268..0x82A49280)
	// 82A49268: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4926C: 396B3CFC  addi r11, r11, 0x3cfc
	ctx.r[11].s64 = ctx.r[11].s64 + 15612;
	// 82A49270: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49274: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A49278: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4927C: 48000060  b 0x82a492dc
	sub_82A492C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A49280 size=32
    let mut pc: u32 = 0x82A49280;
    'dispatch: loop {
        match pc {
            0x82A49280 => {
    //   block [0x82A49280..0x82A492A0)
	// 82A49280: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A49284: 392B3CFC  addi r9, r11, 0x3cfc
	ctx.r[9].s64 = ctx.r[11].s64 + 15612;
	// 82A49288: C1AB3CFC  lfs f13, 0x3cfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4928C: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A49290: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49294: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49298: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4929C: 48000080  b 0x82a4931c
	sub_82A492FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A492A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A492A0 size=20
    let mut pc: u32 = 0x82A492A0;
    'dispatch: loop {
        match pc {
            0x82A492A0 => {
    //   block [0x82A492A0..0x82A492B4)
	// 82A492A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A492A4: 396B3CFC  addi r11, r11, 0x3cfc
	ctx.r[11].s64 = ctx.r[11].s64 + 15612;
	// 82A492A8: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A492AC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A492B0: 4800005C  b 0x82a4930c
	sub_82A492FC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A492B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A492B4 size=20
    let mut pc: u32 = 0x82A492B4;
    'dispatch: loop {
        match pc {
            0x82A492B4 => {
    //   block [0x82A492B4..0x82A492C8)
	// 82A492B4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A492B8: 396B3CFC  addi r11, r11, 0x3cfc
	ctx.r[11].s64 = ctx.r[11].s64 + 15612;
	// 82A492BC: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A492C0: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A492C4: 4BFFFFCC  b 0x82a49290
	sub_82A49280(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A492C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A492C8 size=52
    let mut pc: u32 = 0x82A492C8;
    'dispatch: loop {
        match pc {
            0x82A492C8 => {
    //   block [0x82A492C8..0x82A492FC)
	// 82A492C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A492CC: 396B3CFC  addi r11, r11, 0x3cfc
	ctx.r[11].s64 = ctx.r[11].s64 + 15612;
	// 82A492D0: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A492D4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A492D8: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A492DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A492E0: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A492E4: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A492E8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A492EC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A492F0: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A492F4: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A492F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A492FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A492FC size=48
    let mut pc: u32 = 0x82A492FC;
    'dispatch: loop {
        match pc {
            0x82A492FC => {
    //   block [0x82A492FC..0x82A4932C)
	// 82A492FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A49300: 396B3CFC  addi r11, r11, 0x3cfc
	ctx.r[11].s64 = ctx.r[11].s64 + 15612;
	// 82A49304: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49308: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4930C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49310: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A49314: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A49318: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4931C: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A49320: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A49324: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A49328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A49330 size=196
    let mut pc: u32 = 0x82A49330;
    'dispatch: loop {
        match pc {
            0x82A49330 => {
    //   block [0x82A49330..0x82A493F4)
	// 82A49330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4933C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4934C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A49350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A49354: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A49358: 4B8775E1  bl 0x822c0938
	ctx.lr = 0x82A4935C;
	sub_822C0938(ctx, base);
	// 82A4935C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A49360: 41820028  beq 0x82a49388
	if ctx.cr[0].eq {
	pc = 0x82A49388; continue 'dispatch;
	}
	// 82A49364: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A49368: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4936C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A49370: 392BCF60  addi r9, r11, -0x30a0
	ctx.r[9].s64 = ctx.r[11].s64 + -12448;
	// 82A49374: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A49378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4937C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A49380: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A49384: 48000008  b 0x82a4938c
	pc = 0x82A4938C; continue 'dispatch;
	// 82A49388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4938C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A49390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A49394: 409A0044  bne cr6, 0x82a493d8
	if !ctx.cr[6].eq {
	pc = 0x82A493D8; continue 'dispatch;
	}
	// 82A49398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4939C: 419A001C  beq cr6, 0x82a493b8
	if ctx.cr[6].eq {
	pc = 0x82A493B8; continue 'dispatch;
	}
	// 82A493A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A493A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A493A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A493AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A493B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A493B4: 4E800421  bctrl
	ctx.lr = 0x82A493B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A493B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A493BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A493C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A493C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A493C8: 816B3D10  lwz r11, 0x3d10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15632 as u32) ) } as u64;
	// 82A493CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A493D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A493D4: 4B876C2D  bl 0x822c0000
	ctx.lr = 0x82A493D8;
	sub_822C0000(ctx, base);
	// 82A493D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A493DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A493E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A493E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A493E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A493EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A493F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A493F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A493F8 size=524
    let mut pc: u32 = 0x82A493F8;
    'dispatch: loop {
        match pc {
            0x82A493F8 => {
    //   block [0x82A493F8..0x82A49604)
	// 82A493F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A493FC: 4875ED71  bl 0x831a816c
	ctx.lr = 0x82A49400;
	sub_831A8130(ctx, base);
	// 82A49400: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A49404: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A49408: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49608 size=248
    let mut pc: u32 = 0x82A49608;
    'dispatch: loop {
        match pc {
            0x82A49608 => {
    //   block [0x82A49608..0x82A49700)
	// 82A49608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4960C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A49614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4961C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49620: 4870AFE1  bl 0x83154600
	ctx.lr = 0x82A49624;
	sub_83154600(ctx, base);
	// 82A49624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4962C: 4BFFD38D  bl 0x82a469b8
	ctx.lr = 0x82A49630;
	sub_82A469B8(ctx, base);
	// 82A49630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A49634: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A49638: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4963C: 388ACF70  addi r4, r10, -0x3090
	ctx.r[4].s64 = ctx.r[10].s64 + -12432;
	// 82A49640: 38A000E7  li r5, 0xe7
	ctx.r[5].s64 = 231;
	// 82A49644: C00B093C  lfs f0, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49648: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A4964C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A49650: 4B876D89  bl 0x822c03d8
	ctx.lr = 0x82A49654;
	sub_822C03D8(ctx, base);
	// 82A49654: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A49658: 41820010  beq 0x82a49668
	if ctx.cr[0].eq {
	pc = 0x82A49668; continue 'dispatch;
	}
	// 82A4965C: 4BFFFB05  bl 0x82a49160
	ctx.lr = 0x82A49660;
	sub_82A49160(ctx, base);
	// 82A49660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49664: 48000008  b 0x82a4966c
	pc = 0x82A4966C; continue 'dispatch;
	// 82A49668: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4966C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A49670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A49674: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A49678: 4BFFFCB9  bl 0x82a49330
	ctx.lr = 0x82A4967C;
	sub_82A49330(ctx, base);
	// 82A4967C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A49680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A49684: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A49688: 4B876979  bl 0x822c0000
	ctx.lr = 0x82A4968C;
	sub_822C0000(ctx, base);
	// 82A4968C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A49690: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A49694: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A49698: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A4969C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A496A0: 419A0024  beq cr6, 0x82a496c4
	if ctx.cr[6].eq {
	pc = 0x82A496C4; continue 'dispatch;
	}
	// 82A496A4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A496A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A496AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A496B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A496B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A496B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A496BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A496C0: 4082FFE8  bne 0x82a496a8
	if !ctx.cr[0].eq {
	pc = 0x82A496A8; continue 'dispatch;
	}
	// 82A496C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A496C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A496CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A496D0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A496D4: 4BFEEECD  bl 0x82a385a0
	ctx.lr = 0x82A496D8;
	sub_82A385A0(ctx, base);
	// 82A496D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A496DC: 419A000C  beq cr6, 0x82a496e8
	if ctx.cr[6].eq {
	pc = 0x82A496E8; continue 'dispatch;
	}
	// 82A496E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A496E4: 4B8771AD  bl 0x822c0890
	ctx.lr = 0x82A496E8;
	sub_822C0890(ctx, base);
	// 82A496E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A496EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A496F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A496F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A496F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A496FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A49700 size=52
    let mut pc: u32 = 0x82A49700;
    'dispatch: loop {
        match pc {
            0x82A49700 => {
    //   block [0x82A49700..0x82A49734)
	// 82A49700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4970C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49714: 4BFFFCE5  bl 0x82a493f8
	ctx.lr = 0x82A49718;
	sub_82A493F8(ctx, base);
	// 82A49718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4971C: 4870AEE5  bl 0x83154600
	ctx.lr = 0x82A49720;
	sub_83154600(ctx, base);
	// 82A49720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A49724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A49728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4972C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A49730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49738 size=52
    let mut pc: u32 = 0x82A49738;
    'dispatch: loop {
        match pc {
            0x82A49738 => {
    //   block [0x82A49738..0x82A4976C)
	// 82A49738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4973C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49740: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49744: 4870AEBD  bl 0x83154600
	ctx.lr = 0x82A49748;
	sub_83154600(ctx, base);
	// 82A49748: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4974C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A49750: 994305BC  stb r10, 0x5bc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1468 as u32), ctx.r[10].u8 ) };
	// 82A49754: C00B967C  lfs f0, -0x6984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49758: D00305F8  stfs f0, 0x5f8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 82A4975C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A49760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A49764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A49768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49770 size=344
    let mut pc: u32 = 0x82A49770;
    'dispatch: loop {
        match pc {
            0x82A49770 => {
    //   block [0x82A49770..0x82A498C8)
	// 82A49770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49774: 4875E9F9  bl 0x831a816c
	ctx.lr = 0x82A49778;
	sub_831A8130(ctx, base);
	// 82A49778: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A4977C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A49780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49788: 4870AE79  bl 0x83154600
	ctx.lr = 0x82A4978C;
	sub_83154600(ctx, base);
	// 82A4978C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49790: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49794: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A49798: 897E054C  lbz r11, 0x54c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A4979C: C01E05FC  lfs f0, 0x5fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A497A0: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A497A4: 396B00F5  addi r11, r11, 0xf5
	ctx.r[11].s64 = ctx.r[11].s64 + 245;
	// 82A497A8: C3C908A8  lfs f30, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A497AC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A497B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A497B4: 40980010  bge cr6, 0x82a497c4
	if !ctx.cr[6].lt {
	pc = 0x82A497C4; continue 'dispatch;
	}
	// 82A497B8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A497BC: C00B7A10  lfs f0, 0x7a10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A497C0: 4800003C  b 0x82a497fc
	pc = 0x82A497FC; continue 'dispatch;
	// 82A497C4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A497C8: 556B15BA  rlwinm r11, r11, 2, 0x16, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82A497CC: 394ACFE8  addi r10, r10, -0x3018
	ctx.r[10].s64 = ctx.r[10].s64 + -12312;
	// 82A497D0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A497D4: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 82A497D8: 3929CFD4  addi r9, r9, -0x302c
	ctx.r[9].s64 = ctx.r[9].s64 + -12332;
	// 82A497DC: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A497E0: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A497E4: C0087A10  lfs f0, 0x7a10(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(31248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A497E8: 7D6B4C2E  lfsx f11, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A497EC: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A497F0: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82A497F4: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A497F8: EC0D02FA  fmadds f0, f13, f11, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A497FC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A49800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49804: 48004BD5  bl 0x82a4e3d8
	ctx.lr = 0x82A49808;
	sub_82A4E3D8(ctx, base);
	// 82A49808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4980C: 48004EB5  bl 0x82a4e6c0
	ctx.lr = 0x82A49810;
	sub_82A4E6C0(ctx, base);
	// 82A49810: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A49814: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A49818: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A4981C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A49820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49824: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A49828: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A498C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A498C8 size=4
    let mut pc: u32 = 0x82A498C8;
    'dispatch: loop {
        match pc {
            0x82A498C8 => {
    //   block [0x82A498C8..0x82A498CC)
	// 82A498C8: 4BFFFEA8  b 0x82a49770
	sub_82A49770(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A498D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A498D0 size=188
    let mut pc: u32 = 0x82A498D0;
    'dispatch: loop {
        match pc {
            0x82A498D0 => {
    //   block [0x82A498D0..0x82A4998C)
	// 82A498D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A498D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A498D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A498DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A498E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A498E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A498E8: 4870AD19  bl 0x83154600
	ctx.lr = 0x82A498EC;
	sub_83154600(ctx, base);
	// 82A498EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A498F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A498F4: 4BFFD0C5  bl 0x82a469b8
	ctx.lr = 0x82A498F8;
	sub_82A469B8(ctx, base);
	// 82A498F8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A498FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A49900: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A49904: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A49908: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4990C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A49910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A49914: C00AE25C  lfs f0, -0x1da4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49918: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4991C: C02908A8  lfs f1, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A49920: C01E05FC  lfs f0, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49924: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A49928: 997E05BC  stb r11, 0x5bc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1468 as u32), ctx.r[11].u8 ) };
	// 82A4992C: 4BFEEC75  bl 0x82a385a0
	ctx.lr = 0x82A49930;
	sub_82A385A0(ctx, base);
	// 82A49930: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A49934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49938: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A4993C: 483AA0CD  bl 0x82df3a08
	ctx.lr = 0x82A49940;
	sub_82DF3A08(ctx, base);
	// 82A49940: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A49944: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A49948: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4994C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A49950: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A49954: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A49958: 48169A21  bl 0x82bb3378
	ctx.lr = 0x82A4995C;
	sub_82BB3378(ctx, base);
	// 82A4995C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A49960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A49964: 419A0008  beq cr6, 0x82a4996c
	if ctx.cr[6].eq {
	pc = 0x82A4996C; continue 'dispatch;
	}
	// 82A49968: 4B876F29  bl 0x822c0890
	ctx.lr = 0x82A4996C;
	sub_822C0890(ctx, base);
	// 82A4996C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49970: 483A9AB9  bl 0x82df3428
	ctx.lr = 0x82A49974;
	sub_82DF3428(ctx, base);
	// 82A49974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A49978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4997C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A49980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A49984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A49988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49990 size=84
    let mut pc: u32 = 0x82A49990;
    'dispatch: loop {
        match pc {
            0x82A49990 => {
    //   block [0x82A49990..0x82A499E4)
	// 82A49990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4999C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A499A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A499A4: 4BFE8515  bl 0x82a31eb8
	ctx.lr = 0x82A499A8;
	sub_82A31EB8(ctx, base);
	// 82A499A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A499AC: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A499B0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A499B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A499B8: 3929D030  addi r9, r9, -0x2fd0
	ctx.r[9].s64 = ctx.r[9].s64 + -12240;
	// 82A499BC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A499C0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A499C4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A499C8: C00A3DDC  lfs f0, 0x3ddc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15836 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A499CC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A499D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A499D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A499D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A499DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A499E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A499E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A499E8 size=772
    let mut pc: u32 = 0x82A499E8;
    'dispatch: loop {
        match pc {
            0x82A499E8 => {
    //   block [0x82A499E8..0x82A49CEC)
	// 82A499E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A499EC: 4875E781  bl 0x831a816c
	ctx.lr = 0x82A499F0;
	sub_831A8130(ctx, base);
	// 82A499F0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A499F4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A499F8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A499FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49A00: 4870AC01  bl 0x83154600
	ctx.lr = 0x82A49A04;
	sub_83154600(ctx, base);
	// 82A49A04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A0C: 897E054C  lbz r11, 0x54c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A49A10: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A49A14: 419A000C  beq cr6, 0x82a49a20
	if ctx.cr[6].eq {
	pc = 0x82A49A20; continue 'dispatch;
	}
	// 82A49A18: 480049C1  bl 0x82a4e3d8
	ctx.lr = 0x82A49A1C;
	sub_82A4E3D8(ctx, base);
	// 82A49A1C: 48000008  b 0x82a49a24
	pc = 0x82A49A24; continue 'dispatch;
	// 82A49A20: 48004B01  bl 0x82a4e520
	ctx.lr = 0x82A49A24;
	sub_82A4E520(ctx, base);
	// 82A49A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A28: 48004C99  bl 0x82a4e6c0
	ctx.lr = 0x82A49A2C;
	sub_82A4E6C0(ctx, base);
	// 82A49A2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A49A30: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82A49A34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A49A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A3C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A49A40: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82A49A44: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82A49A48: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82A49A4C: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82A49A50: 48004D51  bl 0x82a4e7a0
	ctx.lr = 0x82A49A54;
	sub_82A4E7A0(ctx, base);
	// 82A49A54: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A49A58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A49A5C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82A49A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A49A68: 48004D51  bl 0x82a4e7b8
	ctx.lr = 0x82A49A6C;
	sub_82A4E7B8(ctx, base);
	// 82A49A6C: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A49A70: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A49A74: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A49A78: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A49A7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A49A80: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A49A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A88: 48004D19  bl 0x82a4e7a0
	ctx.lr = 0x82A49A8C;
	sub_82A4E7A0(ctx, base);
	// 82A49A8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A49A90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A49A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49A98: 48004D21  bl 0x82a4e7b8
	ctx.lr = 0x82A49A9C;
	sub_82A4E7B8(ctx, base);
	// 82A49A9C: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A49AA0: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A49AA4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82A49AA8: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A49AAC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A49AB0: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A49AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49AB8: 48004CE9  bl 0x82a4e7a0
	ctx.lr = 0x82A49ABC;
	sub_82A4E7A0(ctx, base);
	// 82A49ABC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A49AC0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A49AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49AC8: 48004CF1  bl 0x82a4e7b8
	ctx.lr = 0x82A49ACC;
	sub_82A4E7B8(ctx, base);
	// 82A49ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49AD0: 4840FC91  bl 0x82e59760
	ctx.lr = 0x82A49AD4;
	sub_82E59760(ctx, base);
	// 82A49AD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A49AD8: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A49ADC: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82A49AE0: 40990008  ble cr6, 0x82a49ae8
	if !ctx.cr[6].gt {
	pc = 0x82A49AE8; continue 'dispatch;
	}
	// 82A49AE4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A49AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49AEC: 48004D05  bl 0x82a4e7f0
	ctx.lr = 0x82A49AF0;
	sub_82A4E7F0(ctx, base);
	// 82A49AF0: 897E054C  lbz r11, 0x54c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A49AF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A49AF8: 419A000C  beq cr6, 0x82a49b04
	if ctx.cr[6].eq {
	pc = 0x82A49B04; continue 'dispatch;
	}
	// 82A49AFC: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 82A49B00: 409A01DC  bne cr6, 0x82a49cdc
	if !ctx.cr[6].eq {
	pc = 0x82A49CDC; continue 'dispatch;
	}
	// 82A49B04: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A49B08: 807E0534  lwz r3, 0x534(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1332 as u32) ) } as u64;
	// 82A49B0C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82A49B10: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82A49B14: 4B886545  bl 0x822d0058
	ctx.lr = 0x82A49B18;
	sub_822D0058(ctx, base);
	// 82A49B18: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A49B1C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A49B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49B24: 484337FD  bl 0x82e7d320
	ctx.lr = 0x82A49B28;
	sub_82E7D320(ctx, base);
	// 82A49B28: D3E100E0  stfs f31, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82A49B2C: D3C100E4  stfs f30, 0xe4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A49B30: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 82A49B34: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82A49B38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A49B3C: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82A49B40: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82A49B44: 484337DD  bl 0x82e7d320
	ctx.lr = 0x82A49B48;
	sub_82E7D320(ctx, base);
	// 82A49B48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A49B4C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A49B50: 48433901  bl 0x82e7d450
	ctx.lr = 0x82A49B54;
	sub_82E7D450(ctx, base);
	// 82A49B54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A49B58: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A49B5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A49B60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A49B64: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A49B68: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A49CF0 size=196
    let mut pc: u32 = 0x82A49CF0;
    'dispatch: loop {
        match pc {
            0x82A49CF0 => {
    //   block [0x82A49CF0..0x82A49DB4)
	// 82A49CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A49CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A49D0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A49D10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A49D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A49D18: 4B876C21  bl 0x822c0938
	ctx.lr = 0x82A49D1C;
	sub_822C0938(ctx, base);
	// 82A49D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A49D20: 41820028  beq 0x82a49d48
	if ctx.cr[0].eq {
	pc = 0x82A49D48; continue 'dispatch;
	}
	// 82A49D24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A49D28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A49D2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A49D30: 392BD05C  addi r9, r11, -0x2fa4
	ctx.r[9].s64 = ctx.r[11].s64 + -12196;
	// 82A49D34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A49D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A49D3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A49D40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A49D44: 48000008  b 0x82a49d4c
	pc = 0x82A49D4C; continue 'dispatch;
	// 82A49D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A49D4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A49D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A49D54: 409A0044  bne cr6, 0x82a49d98
	if !ctx.cr[6].eq {
	pc = 0x82A49D98; continue 'dispatch;
	}
	// 82A49D58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A49D5C: 419A001C  beq cr6, 0x82a49d78
	if ctx.cr[6].eq {
	pc = 0x82A49D78; continue 'dispatch;
	}
	// 82A49D60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A49D64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A49D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49D6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A49D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A49D74: 4E800421  bctrl
	ctx.lr = 0x82A49D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A49D78: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A49D7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49D84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A49D88: 816B3E04  lwz r11, 0x3e04(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15876 as u32) ) } as u64;
	// 82A49D8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A49D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A49D94: 4B87626D  bl 0x822c0000
	ctx.lr = 0x82A49D98;
	sub_822C0000(ctx, base);
	// 82A49D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A49D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A49DA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A49DA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A49DA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A49DAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A49DB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49DB8 size=180
    let mut pc: u32 = 0x82A49DB8;
    'dispatch: loop {
        match pc {
            0x82A49DB8 => {
    //   block [0x82A49DB8..0x82A49E6C)
	// 82A49DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49DCC: 4870A835  bl 0x83154600
	ctx.lr = 0x82A49DD0;
	sub_83154600(ctx, base);
	// 82A49DD0: 8963063C  lbz r11, 0x63c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1596 as u32) ) } as u64;
	// 82A49DD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A49DD8: 40820080  bne 0x82a49e58
	if !ctx.cr[0].eq {
	pc = 0x82A49E58; continue 'dispatch;
	}
	// 82A49DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49DE0: 4BFFFC09  bl 0x82a499e8
	ctx.lr = 0x82A49DE4;
	sub_82A499E8(ctx, base);
	// 82A49DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49DE8: 4870A819  bl 0x83154600
	ctx.lr = 0x82A49DEC;
	sub_83154600(ctx, base);
	// 82A49DEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A49DF0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A49DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49DF8: 394ACFFC  addi r10, r10, -0x3004
	ctx.r[10].s64 = ctx.r[10].s64 + -12292;
	// 82A49DFC: 896B054C  lbz r11, 0x54c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A49E00: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82A49E04: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49E08: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A49E0C: 4870A7F5  bl 0x83154600
	ctx.lr = 0x82A49E10;
	sub_83154600(ctx, base);
	// 82A49E10: 8963054C  lbz r11, 0x54c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A49E14: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82A49E18: 409A0040  bne cr6, 0x82a49e58
	if !ctx.cr[6].eq {
	pc = 0x82A49E58; continue 'dispatch;
	}
	// 82A49E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49E20: 4840F941  bl 0x82e59760
	ctx.lr = 0x82A49E24;
	sub_82E59760(ctx, base);
	// 82A49E24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A49E28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49E2C: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49E30: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A49E34: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A49E38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A49E3C: 41980008  blt cr6, 0x82a49e44
	if ctx.cr[6].lt {
	pc = 0x82A49E44; continue 'dispatch;
	}
	// 82A49E40: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82A49E44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A49E48: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A49E4C: C1AB967C  lfs f13, -0x6984(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A49E50: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A49E54: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A49E58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A49E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A49E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A49E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A49E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49E70 size=340
    let mut pc: u32 = 0x82A49E70;
    'dispatch: loop {
        match pc {
            0x82A49E70 => {
    //   block [0x82A49E70..0x82A49FC4)
	// 82A49E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A49E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49E80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49E88: 4870A779  bl 0x83154600
	ctx.lr = 0x82A49E8C;
	sub_83154600(ctx, base);
	// 82A49E8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A49E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49E94: 4BFFCB25  bl 0x82a469b8
	ctx.lr = 0x82A49E98;
	sub_82A469B8(ctx, base);
	// 82A49E98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A49E9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A49EA0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A49EA4: 396BCFFC  addi r11, r11, -0x3004
	ctx.r[11].s64 = ctx.r[11].s64 + -12292;
	// 82A49EA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A49EAC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49EB0: 3889D070  addi r4, r9, -0x2f90
	ctx.r[4].s64 = ctx.r[9].s64 + -12176;
	// 82A49EB4: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 82A49EB8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A49EBC: 895E054C  lbz r10, 0x54c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A49EC0: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82A49EC4: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A49EC8: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A49ECC: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A49ED0: 4B876509  bl 0x822c03d8
	ctx.lr = 0x82A49ED4;
	sub_822C03D8(ctx, base);
	// 82A49ED4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A49ED8: 41820010  beq 0x82a49ee8
	if ctx.cr[0].eq {
	pc = 0x82A49EE8; continue 'dispatch;
	}
	// 82A49EDC: 4BFFFAB5  bl 0x82a49990
	ctx.lr = 0x82A49EE0;
	sub_82A49990(ctx, base);
	// 82A49EE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49EE4: 48000008  b 0x82a49eec
	pc = 0x82A49EEC; continue 'dispatch;
	// 82A49EE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A49EEC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A49EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A49EF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A49EF8: 4BFFFDF9  bl 0x82a49cf0
	ctx.lr = 0x82A49EFC;
	sub_82A49CF0(ctx, base);
	// 82A49EFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A49F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A49F04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A49F08: 4B8760F9  bl 0x822c0000
	ctx.lr = 0x82A49F0C;
	sub_822C0000(ctx, base);
	// 82A49F0C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A49F10: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A49F14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A49F18: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A49F1C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A49F20: 419A0024  beq cr6, 0x82a49f44
	if ctx.cr[6].eq {
	pc = 0x82A49F44; continue 'dispatch;
	}
	// 82A49F24: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A49F28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A49F2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A49F30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A49F34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A49F38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A49F3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A49F40: 4082FFE8  bne 0x82a49f28
	if !ctx.cr[0].eq {
	pc = 0x82A49F28; continue 'dispatch;
	}
	// 82A49F44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A49F48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A49F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A49F50: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A49F54: 4BFEE64D  bl 0x82a385a0
	ctx.lr = 0x82A49F58;
	sub_82A385A0(ctx, base);
	// 82A49F58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A49F5C: 419A000C  beq cr6, 0x82a49f68
	if ctx.cr[6].eq {
	pc = 0x82A49F68; continue 'dispatch;
	}
	// 82A49F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49F64: 4B87692D  bl 0x822c0890
	ctx.lr = 0x82A49F68;
	sub_822C0890(ctx, base);
	// 82A49F68: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A49F6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49F70: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A49F74: 483A9A95  bl 0x82df3a08
	ctx.lr = 0x82A49F78;
	sub_82DF3A08(ctx, base);
	// 82A49F78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A49F7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A49F80: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A49F84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A49F88: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A49F8C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A49F90: 481693E9  bl 0x82bb3378
	ctx.lr = 0x82A49F94;
	sub_82BB3378(ctx, base);
	// 82A49F94: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A49F98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A49F9C: 419A0008  beq cr6, 0x82a49fa4
	if ctx.cr[6].eq {
	pc = 0x82A49FA4; continue 'dispatch;
	}
	// 82A49FA0: 4B8768F1  bl 0x822c0890
	ctx.lr = 0x82A49FA4;
	sub_822C0890(ctx, base);
	// 82A49FA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A49FA8: 483A9481  bl 0x82df3428
	ctx.lr = 0x82A49FAC;
	sub_82DF3428(ctx, base);
	// 82A49FAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A49FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A49FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A49FB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A49FBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A49FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A49FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A49FC8 size=84
    let mut pc: u32 = 0x82A49FC8;
    'dispatch: loop {
        match pc {
            0x82A49FC8 => {
    //   block [0x82A49FC8..0x82A4A01C)
	// 82A49FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A49FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A49FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A49FD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A49FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A49FDC: 4BFE7EDD  bl 0x82a31eb8
	ctx.lr = 0x82A49FE0;
	sub_82A31EB8(ctx, base);
	// 82A49FE0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A49FE4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A49FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A49FEC: 3929D0C4  addi r9, r9, -0x2f3c
	ctx.r[9].s64 = ctx.r[9].s64 + -12092;
	// 82A49FF0: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A49FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A49FF8: C00A3E9C  lfs f0, 0x3e9c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A49FFC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4A000: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4A004: 997F0015  stb r11, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82A4A008: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4A00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4A010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4A014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4A018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A020 size=32
    let mut pc: u32 = 0x82A4A020;
    'dispatch: loop {
        match pc {
            0x82A4A020 => {
    //   block [0x82A4A020..0x82A4A040)
	// 82A4A020: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4A024: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4A028: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4A02C: 419800AC  blt cr6, 0x82a4a0d8
	if ctx.cr[6].lt {
		sub_82A4A0D8(ctx, base);
		return;
	}
	// 82A4A030: 419A0088  beq cr6, 0x82a4a0b8
	if ctx.cr[6].eq {
		sub_82A4A0B8(ctx, base);
		return;
	}
	// 82A4A034: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4A038: 41980034  blt cr6, 0x82a4a06c
	if ctx.cr[6].lt {
		sub_82A4A06C(ctx, base);
		return;
	}
	// 82A4A03C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A040 size=20
    let mut pc: u32 = 0x82A4A040;
    'dispatch: loop {
        match pc {
            0x82A4A040 => {
    //   block [0x82A4A040..0x82A4A054)
	// 82A4A040: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A044: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A048: C1AB3EBC  lfs f13, 0x3ebc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A04C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4A050: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A054(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A054 size=24
    let mut pc: u32 = 0x82A4A054;
    'dispatch: loop {
        match pc {
            0x82A4A054 => {
    //   block [0x82A4A054..0x82A4A06C)
	// 82A4A054: 89630015  lbz r11, 0x15(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A4A058: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A4A05C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A4A060: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82A4A064: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82A4A068: 48000090  b 0x82a4a0f8
	sub_82A4A0F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A06C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A06C size=48
    let mut pc: u32 = 0x82A4A06C;
    'dispatch: loop {
        match pc {
            0x82A4A06C => {
    //   block [0x82A4A06C..0x82A4A09C)
	// 82A4A06C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A070: 89430015  lbz r10, 0x15(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A4A074: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A078: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 82A4A07C: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A4A080: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A4A084: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A4A088: 4098001C  bge cr6, 0x82a4a0a4
	if !ctx.cr[6].lt {
		sub_82A4A0A4(ctx, base);
		return;
	}
	// 82A4A08C: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A090: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A094: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4A098: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A09C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A09C size=8
    let mut pc: u32 = 0x82A4A09C;
    'dispatch: loop {
        match pc {
            0x82A4A09C => {
    //   block [0x82A4A09C..0x82A4A0A4)
	// 82A4A09C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A4A0A0: 48000054  b 0x82a4a0f4
	sub_82A4A0F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A0A4 size=16
    let mut pc: u32 = 0x82A4A0A4;
    'dispatch: loop {
        match pc {
            0x82A4A0A4 => {
    //   block [0x82A4A0A4..0x82A4A0B4)
	// 82A4A0A4: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A0A8: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A0AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4A0B0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A0B4 size=4
    let mut pc: u32 = 0x82A4A0B4;
    'dispatch: loop {
        match pc {
            0x82A4A0B4 => {
    //   block [0x82A4A0B4..0x82A4A0B8)
	// 82A4A0B4: 48000048  b 0x82a4a0fc
	sub_82A4A0F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A0B8 size=24
    let mut pc: u32 = 0x82A4A0B8;
    'dispatch: loop {
        match pc {
            0x82A4A0B8 => {
    //   block [0x82A4A0B8..0x82A4A0D0)
	// 82A4A0B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A0BC: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A0C0: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A0C4: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A0C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4A0CC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A0D0 size=8
    let mut pc: u32 = 0x82A4A0D0;
    'dispatch: loop {
        match pc {
            0x82A4A0D0 => {
    //   block [0x82A4A0D0..0x82A4A0D8)
	// 82A4A0D0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A4A0D4: 48000020  b 0x82a4a0f4
	sub_82A4A0F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A0D8 size=24
    let mut pc: u32 = 0x82A4A0D8;
    'dispatch: loop {
        match pc {
            0x82A4A0D8 => {
    //   block [0x82A4A0D8..0x82A4A0F0)
	// 82A4A0D8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A0DC: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A0E0: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A0E4: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A0E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4A0EC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A0F0 size=20
    let mut pc: u32 = 0x82A4A0F0;
    'dispatch: loop {
        match pc {
            0x82A4A0F0 => {
    //   block [0x82A4A0F0..0x82A4A104)
	// 82A4A0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A4A0F4: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A4A0F8: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4A0FC: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4A100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A108 size=40
    let mut pc: u32 = 0x82A4A108;
    'dispatch: loop {
        match pc {
            0x82A4A108 => {
    //   block [0x82A4A108..0x82A4A130)
	// 82A4A108: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4A10C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4A110: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4A114: 4198001C  blt cr6, 0x82a4a130
	if ctx.cr[6].lt {
		sub_82A4A130(ctx, base);
		return;
	}
	// 82A4A118: 419A0010  beq cr6, 0x82a4a128
	if ctx.cr[6].eq {
	pc = 0x82A4A128; continue 'dispatch;
	}
	// 82A4A11C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4A120: 41980010  blt cr6, 0x82a4a130
	if ctx.cr[6].lt {
		sub_82A4A130(ctx, base);
		return;
	}
	// 82A4A124: 409A000C  bne cr6, 0x82a4a130
	if !ctx.cr[6].eq {
		sub_82A4A130(ctx, base);
		return;
	}
	// 82A4A128: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A4A12C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A130 size=8
    let mut pc: u32 = 0x82A4A130;
    'dispatch: loop {
        match pc {
            0x82A4A130 => {
    //   block [0x82A4A130..0x82A4A138)
	// 82A4A130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A4A134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A138 size=44
    let mut pc: u32 = 0x82A4A138;
    'dispatch: loop {
        match pc {
            0x82A4A138 => {
    //   block [0x82A4A138..0x82A4A164)
	// 82A4A138: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4A13C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4A140: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4A144: 4198004C  blt cr6, 0x82a4a190
	if ctx.cr[6].lt {
		sub_82A4A190(ctx, base);
		return;
	}
	// 82A4A148: 419A0038  beq cr6, 0x82a4a180
	if ctx.cr[6].eq {
		sub_82A4A180(ctx, base);
		return;
	}
	// 82A4A14C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4A150: 41980020  blt cr6, 0x82a4a170
	if ctx.cr[6].lt {
		sub_82A4A170(ctx, base);
		return;
	}
	// 82A4A154: 419A0010  beq cr6, 0x82a4a164
	if ctx.cr[6].eq {
		sub_82A4A164(ctx, base);
		return;
	}
	// 82A4A158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4A15C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4A160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A164(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A164 size=12
    let mut pc: u32 = 0x82A4A164;
    'dispatch: loop {
        match pc {
            0x82A4A164 => {
    //   block [0x82A4A164..0x82A4A170)
	// 82A4A164: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A168: C00B3EBC  lfs f0, 0x3ebc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A16C: 48000030  b 0x82a4a19c
	sub_82A4A190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A170 size=16
    let mut pc: u32 = 0x82A4A170;
    'dispatch: loop {
        match pc {
            0x82A4A170 => {
    //   block [0x82A4A170..0x82A4A180)
	// 82A4A170: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A174: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A178: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A17C: 48000020  b 0x82a4a19c
	sub_82A4A190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A180 size=16
    let mut pc: u32 = 0x82A4A180;
    'dispatch: loop {
        match pc {
            0x82A4A180 => {
    //   block [0x82A4A180..0x82A4A190)
	// 82A4A180: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A184: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A188: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A18C: 48000010  b 0x82a4a19c
	sub_82A4A190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4A190 size=24
    let mut pc: u32 = 0x82A4A190;
    'dispatch: loop {
        match pc {
            0x82A4A190 => {
    //   block [0x82A4A190..0x82A4A1A8)
	// 82A4A190: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A194: 396B3EBC  addi r11, r11, 0x3ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 16060;
	// 82A4A198: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A19C: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A1A0: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4A1A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4A1A8 size=252
    let mut pc: u32 = 0x82A4A1A8;
    'dispatch: loop {
        match pc {
            0x82A4A1A8 => {
    //   block [0x82A4A1A8..0x82A4A2A4)
	// 82A4A1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A1AC: 4875DFC1  bl 0x831a816c
	ctx.lr = 0x82A4A1B0;
	sub_831A8130(ctx, base);
	// 82A4A1B0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A4A1B4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4A1B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A1BC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4A1C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4A1C4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82A4A1C8: 409A0030  bne cr6, 0x82a4a1f8
	if !ctx.cr[6].eq {
	pc = 0x82A4A1F8; continue 'dispatch;
	}
	// 82A4A1CC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A1D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A1D4: 396B3EA0  addi r11, r11, 0x3ea0
	ctx.r[11].s64 = ctx.r[11].s64 + 16032;
	// 82A4A1D8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A1DC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A1E0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A1E4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4A1E8: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4A1EC: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4A1F0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4A1F4: 4800009C  b 0x82a4a290
	pc = 0x82A4A290; continue 'dispatch;
	// 82A4A1F8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A4A1FC: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A200: 3FC0832E  lis r30, -0x7cd2
	ctx.r[30].s64 = -2094137344;
	// 82A4A204: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A4A208: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A4A20C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82A4A210: 3BBE3EA0  addi r29, r30, 0x3ea0
	ctx.r[29].s64 = ctx.r[30].s64 + 16032;
	// 82A4A214: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82A4A218: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A4A21C: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A220: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4A224: ED4D0024  fdivs f10, f13, f0
	ctx.f[10].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4A228: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4A22C: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A230: C1AAD5B8  lfs f13, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A234: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A238: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4A23C: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4A240: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4A244: EFC06B3A  fmadds f30, f0, f12, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4A248: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4A24C: 4875EC5D  bl 0x831a8ea8
	ctx.lr = 0x82A4A250;
	sub_831A8EA8(ctx, base);
	// 82A4A250: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4A254: C01E3EA0  lfs f0, 0x3ea0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A258: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4A25C: C3FD0004  lfs f31, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4A260: EFC00372  fmuls f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4A264: 4875EB65  bl 0x831a8dc8
	ctx.lr = 0x82A4A268;
	sub_831A8DC8(ctx, base);
	// 82A4A268: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4A26C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4A270: C1BE3EA0  lfs f13, 0x3ea0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A274: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A278: D3DF0000  stfs f30, 0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4A27C: D3FF0004  stfs f31, 4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4A280: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A284: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4A288: EC0D62FA  fmadds f0, f13, f11, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A4A28C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4A290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A294: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4A298: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A4A29C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4A2A0: 4875DF1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4A2A8 size=196
    let mut pc: u32 = 0x82A4A2A8;
    'dispatch: loop {
        match pc {
            0x82A4A2A8 => {
    //   block [0x82A4A2A8..0x82A4A36C)
	// 82A4A2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4A2B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4A2B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4A2B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4A2C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4A2C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4A2C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4A2CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4A2D0: 4B876669  bl 0x822c0938
	ctx.lr = 0x82A4A2D4;
	sub_822C0938(ctx, base);
	// 82A4A2D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4A2D8: 41820028  beq 0x82a4a300
	if ctx.cr[0].eq {
	pc = 0x82A4A300; continue 'dispatch;
	}
	// 82A4A2DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4A2E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4A2E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4A2E8: 392BD0F0  addi r9, r11, -0x2f10
	ctx.r[9].s64 = ctx.r[11].s64 + -12048;
	// 82A4A2EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4A2F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4A2F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4A2F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4A2FC: 48000008  b 0x82a4a304
	pc = 0x82A4A304; continue 'dispatch;
	// 82A4A300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4A304: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4A308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4A30C: 409A0044  bne cr6, 0x82a4a350
	if !ctx.cr[6].eq {
	pc = 0x82A4A350; continue 'dispatch;
	}
	// 82A4A310: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4A314: 419A001C  beq cr6, 0x82a4a330
	if ctx.cr[6].eq {
	pc = 0x82A4A330; continue 'dispatch;
	}
	// 82A4A318: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4A31C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4A320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A324: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4A328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4A32C: 4E800421  bctrl
	ctx.lr = 0x82A4A330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4A330: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4A334: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4A33C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4A340: 816B3ED0  lwz r11, 0x3ed0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16080 as u32) ) } as u64;
	// 82A4A344: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4A348: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4A34C: 4B875CB5  bl 0x822c0000
	ctx.lr = 0x82A4A350;
	sub_822C0000(ctx, base);
	// 82A4A350: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4A354: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4A358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4A35C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4A360: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4A364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4A368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4A370 size=620
    let mut pc: u32 = 0x82A4A370;
    'dispatch: loop {
        match pc {
            0x82A4A370 => {
    //   block [0x82A4A370..0x82A4A5DC)
	// 82A4A370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A374: 4875DDF5  bl 0x831a8168
	ctx.lr = 0x82A4A378;
	sub_831A8130(ctx, base);
	// 82A4A378: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A4A37C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A4A380: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4A5E0 size=244
    let mut pc: u32 = 0x82A4A5E0;
    'dispatch: loop {
        match pc {
            0x82A4A5E0 => {
    //   block [0x82A4A5E0..0x82A4A6D4)
	// 82A4A5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A5E4: 4875DB89  bl 0x831a816c
	ctx.lr = 0x82A4A5E8;
	sub_831A8130(ctx, base);
	// 82A4A5E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A5EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4A5F0: 4870A011  bl 0x83154600
	ctx.lr = 0x82A4A5F4;
	sub_83154600(ctx, base);
	// 82A4A5F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4A5F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4A5FC: 4BFFC3BD  bl 0x82a469b8
	ctx.lr = 0x82A4A600;
	sub_82A469B8(ctx, base);
	// 82A4A600: C01D05FC  lfs f0, 0x5fc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A604: D01E0180  stfs f0, 0x180(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4A608: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4A60C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4A610: 388BD100  addi r4, r11, -0x2f00
	ctx.r[4].s64 = ctx.r[11].s64 + -12032;
	// 82A4A614: 38A00173  li r5, 0x173
	ctx.r[5].s64 = 371;
	// 82A4A618: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A4A61C: 4B875DBD  bl 0x822c03d8
	ctx.lr = 0x82A4A620;
	sub_822C03D8(ctx, base);
	// 82A4A620: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4A624: 41820010  beq 0x82a4a634
	if ctx.cr[0].eq {
	pc = 0x82A4A634; continue 'dispatch;
	}
	// 82A4A628: 4BFFF9A1  bl 0x82a49fc8
	ctx.lr = 0x82A4A62C;
	sub_82A49FC8(ctx, base);
	// 82A4A62C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4A630: 48000008  b 0x82a4a638
	pc = 0x82A4A638; continue 'dispatch;
	// 82A4A634: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4A638: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A4A63C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4A640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4A644: 4BFFFC65  bl 0x82a4a2a8
	ctx.lr = 0x82A4A648;
	sub_82A4A2A8(ctx, base);
	// 82A4A648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A4A64C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4A650: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4A654: 4B8759AD  bl 0x822c0000
	ctx.lr = 0x82A4A658;
	sub_822C0000(ctx, base);
	// 82A4A658: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4A65C: 3BFE0184  addi r31, r30, 0x184
	ctx.r[31].s64 = ctx.r[30].s64 + 388;
	// 82A4A660: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A4A664: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A4A668: 917E0184  stw r11, 0x184(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82A4A66C: 4B879DF5  bl 0x822c4460
	ctx.lr = 0x82A4A670;
	sub_822C4460(ctx, base);
	// 82A4A670: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4A674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4A678: 419A0008  beq cr6, 0x82a4a680
	if ctx.cr[6].eq {
	pc = 0x82A4A680; continue 'dispatch;
	}
	// 82A4A67C: 4B876215  bl 0x822c0890
	ctx.lr = 0x82A4A680;
	sub_822C0890(ctx, base);
	// 82A4A680: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A4A684: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4A688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4A68C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4A690: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4A694: 419A0024  beq cr6, 0x82a4a6b8
	if ctx.cr[6].eq {
	pc = 0x82A4A6B8; continue 'dispatch;
	}
	// 82A4A698: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A4A69C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4A6A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4A6A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4A6A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4A6AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4A6B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4A6B4: 4082FFE8  bne 0x82a4a69c
	if !ctx.cr[0].eq {
	pc = 0x82A4A69C; continue 'dispatch;
	}
	// 82A4A6B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4A6BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4A6C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4A6C4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4A6C8: 4BFEDED9  bl 0x82a385a0
	ctx.lr = 0x82A4A6CC;
	sub_82A385A0(ctx, base);
	// 82A4A6CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4A6D0: 4875DAEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4A6D8 size=52
    let mut pc: u32 = 0x82A4A6D8;
    'dispatch: loop {
        match pc {
            0x82A4A6D8 => {
    //   block [0x82A4A6D8..0x82A4A70C)
	// 82A4A6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4A6E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4A6E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A6E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4A6EC: 4BFFFC85  bl 0x82a4a370
	ctx.lr = 0x82A4A6F0;
	sub_82A4A370(ctx, base);
	// 82A4A6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A6F4: 48709F0D  bl 0x83154600
	ctx.lr = 0x82A4A6F8;
	sub_83154600(ctx, base);
	// 82A4A6F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4A6FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4A700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4A704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4A708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4A710 size=160
    let mut pc: u32 = 0x82A4A710;
    'dispatch: loop {
        match pc {
            0x82A4A710 => {
    //   block [0x82A4A710..0x82A4A7B0)
	// 82A4A710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4A718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4A71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4A720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4A728: 48709ED9  bl 0x83154600
	ctx.lr = 0x82A4A72C;
	sub_83154600(ctx, base);
	// 82A4A72C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4A730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A734: 4BFFC285  bl 0x82a469b8
	ctx.lr = 0x82A4A738;
	sub_82A469B8(ctx, base);
	// 82A4A738: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A73C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4A740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4A744: 997F0181  stb r11, 0x181(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(385 as u32), ctx.r[11].u8 ) };
	// 82A4A748: 997F0180  stb r11, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 82A4A74C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A750: 997F0188  stb r11, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u8 ) };
	// 82A4A754: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4A758: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4A75C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A4A760: 4BFE77E1  bl 0x82a31f40
	ctx.lr = 0x82A4A764;
	sub_82A31F40(ctx, base);
	// 82A4A764: 987F0194  stb r3, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u8 ) };
	// 82A4A768: C01E05FC  lfs f0, 0x5fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A76C: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82A4A770: 807E04BC  lwz r3, 0x4bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4A774: 4BDAAC5D  bl 0x827f53d0
	ctx.lr = 0x82A4A778;
	sub_827F53D0(ctx, base);
	// 82A4A778: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4A77C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A780: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82A4A784: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A4A788: C00B9D1C  lfs f0, -0x62e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A78C: C1AA89AC  lfs f13, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A790: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4A794: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4A798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4A79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4A7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4A7A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4A7A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4A7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4A7B0 size=576
    //   switch @ 0x82A4A8D8: r11 with 10 label(s)
    //       case  0  0x82A4A8E8
    //       case  1  0x82A4A8F4
    //       case  2  0x82A4A924
    //       case  3  0x82A4A924
    //       case  4  0x82A4A924
    //       case  5  0x82A4A92C
    //       case  6  0x82A4A98C
    //       case  7  0x82A4A924
    //       case  8  0x82A4A924
    //       case  9  0x82A4A994
    let mut pc: u32 = 0x82A4A7B0;
    'dispatch: loop {
        match pc {
            0x82A4A7B0 => {
    //   block [0x82A4A7B0..0x82A4A8E8)
	// 82A4A7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4A7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4A7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4A7C0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A4A7C4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A4A7C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4A7CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4A7D0: 48709E31  bl 0x83154600
	ctx.lr = 0x82A4A7D4;
	sub_83154600(ctx, base);
	// 82A4A7D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4A7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A7DC: 897E05F4  lbz r11, 0x5f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82A4A7E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4A7E4: 4182001C  beq 0x82a4a800
	if ctx.cr[0].eq {
	pc = 0x82A4A800; continue 'dispatch;
	}
	// 82A4A7E8: 4840EF91  bl 0x82e59778
	ctx.lr = 0x82A4A7EC;
	sub_82E59778(ctx, base);
	// 82A4A7EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4A7F0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A4A7F4: C3CBD72C  lfs f30, -0x28d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4A7F8: C3EA6970  lfs f31, 0x6970(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26992 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4A7FC: 48000024  b 0x82a4a820
	pc = 0x82A4A820; continue 'dispatch;
	// 82A4A800: 897E05F5  lbz r11, 0x5f5(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1525 as u32) ) } as u64;
	// 82A4A804: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4A808: 41820054  beq 0x82a4a85c
	if ctx.cr[0].eq {
	pc = 0x82A4A85C; continue 'dispatch;
	}
	// 82A4A80C: 4840EF6D  bl 0x82e59778
	ctx.lr = 0x82A4A810;
	sub_82E59778(ctx, base);
	// 82A4A810: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4A814: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A818: C3CB95F4  lfs f30, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4A81C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4A820: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A824: EC0107BC  fnmsubs f0, f1, f30, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4A828: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4A82C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4A830: 40980008  bge cr6, 0x82a4a838
	if !ctx.cr[6].lt {
	pc = 0x82A4A838; continue 'dispatch;
	}
	// 82A4A834: D3FF018C  stfs f31, 0x18c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4A838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A83C: 4840EF3D  bl 0x82e59778
	ctx.lr = 0x82A4A840;
	sub_82E59778(ctx, base);
	// 82A4A840: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A844: EC0107BC  fnmsubs f0, f1, f30, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4A848: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4A84C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4A850: 40980060  bge cr6, 0x82a4a8b0
	if !ctx.cr[6].lt {
	pc = 0x82A4A8B0; continue 'dispatch;
	}
	// 82A4A854: D3FF0190  stfs f31, 0x190(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4A858: 48000058  b 0x82a4a8b0
	pc = 0x82A4A8B0; continue 'dispatch;
	// 82A4A85C: 4840EF1D  bl 0x82e59778
	ctx.lr = 0x82A4A860;
	sub_82E59778(ctx, base);
	// 82A4A860: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4A864: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A868: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4A86C: C3EB959C  lfs f31, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4A870: EDA107FA  fmadds f13, f1, f31, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4A874: C00A9D1C  lfs f0, -0x62e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A878: D1BF018C  stfs f13, 0x18c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4A87C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4A880: 40990008  ble cr6, 0x82a4a888
	if !ctx.cr[6].gt {
	pc = 0x82A4A888; continue 'dispatch;
	}
	// 82A4A884: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4A888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A88C: 4840EEED  bl 0x82e59778
	ctx.lr = 0x82A4A890;
	sub_82E59778(ctx, base);
	// 82A4A890: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A894: EDA107FA  fmadds f13, f1, f31, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4A898: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4A89C: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4A8A0: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A8A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4A8A8: 40990008  ble cr6, 0x82a4a8b0
	if !ctx.cr[6].gt {
	pc = 0x82A4A8B0; continue 'dispatch;
	}
	// 82A4A8AC: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4A8B0: 897F0181  lbz r11, 0x181(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(385 as u32) ) } as u64;
	// 82A4A8B4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4A8B8: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82A4A8BC: 4199010C  bgt cr6, 0x82a4a9c8
	if ctx.cr[6].gt {
	pc = 0x82A4A9C8; continue 'dispatch;
	}
	// 82A4A8C0: 3D80820B  lis r12, -0x7df5
	ctx.r[12].s64 = -2113208320;
	// 82A4A8C4: 398CD1C8  addi r12, r12, -0x2e38
	ctx.r[12].s64 = ctx.r[12].s64 + -11832;
	// 82A4A8C8: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A4A8CC: 3D8082A5  lis r12, -0x7d5b
	ctx.r[12].s64 = -2103115776;
	// 82A4A8D0: 398CA8E8  addi r12, r12, -0x5718
	ctx.r[12].s64 = ctx.r[12].s64 + -22296;
	// 82A4A8D4: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82A4A8D8: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82A4A8DC: 60000000  nop
	// 82A4A8E0: 60000000  nop
	// 82A4A8E4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x82A4A8E8 => {
    //   block [0x82A4A8E8..0x82A4A8F4)
	// 82A4A8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A8EC: 48003C35  bl 0x82a4e520
	ctx.lr = 0x82A4A8F0;
	sub_82A4E520(ctx, base);
	// 82A4A8F0: 480000D8  b 0x82a4a9c8
	pc = 0x82A4A9C8; continue 'dispatch;
            }
            0x82A4A8F4 => {
    //   block [0x82A4A8F4..0x82A4A924)
	// 82A4A8F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4A8F8: C1BF0184  lfs f13, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A8FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A900: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A904: C17F0198  lfs f11, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4A908: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A90C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4A910: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A914: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4A918: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4A91C: EC006AFA  fmadds f0, f0, f11, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4A920: 480000A4  b 0x82a4a9c4
	pc = 0x82A4A9C4; continue 'dispatch;
            }
            0x82A4A924 => {
    //   block [0x82A4A924..0x82A4A92C)
	// 82A4A924: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A928: 4800009C  b 0x82a4a9c4
	pc = 0x82A4A9C4; continue 'dispatch;
            }
            0x82A4A92C => {
    //   block [0x82A4A92C..0x82A4A98C)
	// 82A4A92C: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4A930: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A4A934: 895F0194  lbz r10, 0x194(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A4A938: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82A4A93C: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82A4A940: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A944: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 82A4A948: C19F0190  lfs f12, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A94C: 1D470003  mulli r10, r7, 3
	ctx.r[10].s64 = ctx.r[7].s64 * 3;
	// 82A4A950: C17F018C  lfs f11, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4A954: 3968D160  addi r11, r8, -0x2ea0
	ctx.r[11].s64 = ctx.r[8].s64 + -11936;
	// 82A4A958: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A4A95C: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A4A960: 390B003C  addi r8, r11, 0x3c
	ctx.r[8].s64 = ctx.r[11].s64 + 60;
	// 82A4A964: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A4A968: 38EB0050  addi r7, r11, 0x50
	ctx.r[7].s64 = ctx.r[11].s64 + 80;
	// 82A4A96C: 7C09442E  lfsx f0, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A970: 7D4A5C2E  lfsx f10, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A4A974: ED405024  fdivs f10, f0, f10
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82A4A978: 7D293C2E  lfsx f9, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A4A97C: C00608A8  lfs f0, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A980: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82A4A984: EDAD5024  fdivs f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 82A4A988: 4BFFFF8C  b 0x82a4a914
	pc = 0x82A4A914; continue 'dispatch;
            }
            0x82A4A98C => {
    //   block [0x82A4A98C..0x82A4A994)
	// 82A4A98C: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A990: 48000034  b 0x82a4a9c4
	pc = 0x82A4A9C4; continue 'dispatch;
            }
            0x82A4A994 => {
    //   block [0x82A4A994..0x82A4A9F0)
	// 82A4A994: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4A998: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A99C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4A9A0: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4A9A4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4A9A8: C00B603C  lfs f0, 0x603c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A9AC: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4A9B0: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4A9B4: C1A9967C  lfs f13, -0x6984(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4A9B8: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A4A9BC: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4A9C0: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4A9C4: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4A9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4A9CC: 48003CF5  bl 0x82a4e6c0
	ctx.lr = 0x82A4A9D0;
	sub_82A4E6C0(ctx, base);
	// 82A4A9D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4A9D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4A9D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4A9DC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4A9E0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A4A9E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4A9E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4A9EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4A9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4A9F0 size=956
    let mut pc: u32 = 0x82A4A9F0;
    'dispatch: loop {
        match pc {
            0x82A4A9F0 => {
    //   block [0x82A4A9F0..0x82A4ADAC)
	// 82A4A9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4A9F4: 4875D771  bl 0x831a8164
	ctx.lr = 0x82A4A9F8;
	sub_831A8130(ctx, base);
	// 82A4A9F8: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82A4A9FC: 4875E07D  bl 0x831a8a78
	ctx.lr = 0x82A4AA00;
	sub_831A8A40(ctx, base);
	// 82A4AA00: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4AA04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4AA08: 48709BF9  bl 0x83154600
	ctx.lr = 0x82A4AA0C;
	sub_83154600(ctx, base);
	// 82A4AA0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4AA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4AA14: 4840ED65  bl 0x82e59778
	ctx.lr = 0x82A4AA18;
	sub_82E59778(ctx, base);
	// 82A4AA18: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A4AA1C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A4AA20: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4AA24: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82A4AA28: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4AA2C: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82A4AA30: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4AA34: C38908A4  lfs f28, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A4AA38: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A4AA3C: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 82A4AA40: C3A808AC  lfs f29, 0x8ac(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2220 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A4AA44: C3C79450  lfs f30, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4AA48: 3B6BD748  addi r27, r11, -0x28b8
	ctx.r[27].s64 = ctx.r[11].s64 + -10424;
	// 82A4AA4C: C3E6964C  lfs f31, -0x69b4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4AA50: 3BAAD160  addi r29, r10, -0x2ea0
	ctx.r[29].s64 = ctx.r[10].s64 + -11936;
	// 82A4AA54: 3B893F80  addi r28, r9, 0x3f80
	ctx.r[28].s64 = ctx.r[9].s64 + 16256;
	// 82A4AA58: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A4AA5C: 897F0181  lbz r11, 0x181(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(385 as u32) ) } as u64;
	// 82A4AA60: 7D680774  extsb r8, r11
	ctx.r[8].s64 = ctx.r[11].s8 as i64;
	// 82A4AA64: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82A4AA68: 41980284  blt cr6, 0x82a4acec
	if ctx.cr[6].lt {
	pc = 0x82A4ACEC; continue 'dispatch;
	}
	// 82A4AA6C: 419A0264  beq cr6, 0x82a4acd0
	if ctx.cr[6].eq {
	pc = 0x82A4ACD0; continue 'dispatch;
	}
	// 82A4AA70: 2B080003  cmplwi cr6, r8, 3
	ctx.cr[6].compare_u32(ctx.r[8].u32, 3 as u32, &mut ctx.xer);
	// 82A4AA74: 41980180  blt cr6, 0x82a4abf4
	if ctx.cr[6].lt {
	pc = 0x82A4ABF4; continue 'dispatch;
	}
	// 82A4AA78: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 82A4AA7C: 4198005C  blt cr6, 0x82a4aad8
	if ctx.cr[6].lt {
	pc = 0x82A4AAD8; continue 'dispatch;
	}
	// 82A4AA80: 409A0308  bne cr6, 0x82a4ad88
	if !ctx.cr[6].eq {
	pc = 0x82A4AD88; continue 'dispatch;
	}
	// 82A4AA84: 897F0180  lbz r11, 0x180(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82A4AA88: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 82A4AA8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A4AA90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A4AA94: 995F0181  stb r10, 0x181(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(385 as u32), ctx.r[10].u8 ) };
	// 82A4AA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4AA9C: 997F0180  stb r11, 0x180(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 82A4AAA0: 483A8F69  bl 0x82df3a08
	ctx.lr = 0x82A4AAA4;
	sub_82DF3A08(ctx, base);
	// 82A4AAA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4AAA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4AAAC: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4AAB0: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A4AAB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4AAB8: 481688C1  bl 0x82bb3378
	ctx.lr = 0x82A4AABC;
	sub_82BB3378(ctx, base);
	// 82A4AABC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A4AAC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4AAC4: 419A0008  beq cr6, 0x82a4aacc
	if ctx.cr[6].eq {
	pc = 0x82A4AACC; continue 'dispatch;
	}
	// 82A4AAC8: 4B875DC9  bl 0x822c0890
	ctx.lr = 0x82A4AACC;
	sub_822C0890(ctx, base);
	// 82A4AACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4AAD0: 483A8959  bl 0x82df3428
	ctx.lr = 0x82A4AAD4;
	sub_82DF3428(ctx, base);
	// 82A4AAD4: 4BFFFF88  b 0x82a4aa5c
	pc = 0x82A4AA5C; continue 'dispatch;
	// 82A4AAD8: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4AADC: 38FD003C  addi r7, r29, 0x3c
	ctx.r[7].s64 = ctx.r[29].s64 + 60;
	// 82A4AAE0: 895F0194  lbz r10, 0x194(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A4AAE4: 38DD0050  addi r6, r29, 0x50
	ctx.r[6].s64 = ctx.r[29].s64 + 80;
	// 82A4AAE8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4AAEC: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4AAF0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A4AAF4: 1D2B0003  mulli r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 * 3;
	// 82A4AAF8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A4AAFC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A4AB00: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A4AB04: 7DA93C2E  lfsx f13, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4AB08: 7D8AEC2E  lfsx f12, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4AB0C: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82A4AB10: 7D89342E  lfsx f12, r9, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4AB14: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A4AB18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4AB1C: 41980280  blt cr6, 0x82a4ad9c
	if ctx.cr[6].lt {
	pc = 0x82A4AD9C; continue 'dispatch;
	}
	// 82A4AB20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A4AB24: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4AB28: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82A4AB2C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A4AB30: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4AB34: 995F0181  stb r10, 0x181(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(385 as u32), ctx.r[10].u8 ) };
	// 82A4AB38: 997F0188  stb r11, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u8 ) };
	// 82A4AB3C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82A4AB40: 4098FF1C  bge cr6, 0x82a4aa5c
	if !ctx.cr[6].lt {
	pc = 0x82A4AA5C; continue 'dispatch;
	}
	// 82A4AB44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A4AB48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4AB4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4AB50: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4AB54: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82A4AB58: 483A8EB1  bl 0x82df3a08
	ctx.lr = 0x82A4AB5C;
	sub_82DF3A08(ctx, base);
	// 82A4AB5C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A4AB60: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4AB64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4AB68: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A4AB6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4AB70: 48168809  bl 0x82bb3378
	ctx.lr = 0x82A4AB74;
	sub_82BB3378(ctx, base);
	// 82A4AB74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A4AB78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4AB7C: 419A0008  beq cr6, 0x82a4ab84
	if ctx.cr[6].eq {
	pc = 0x82A4AB84; continue 'dispatch;
	}
	// 82A4AB80: 4B875D11  bl 0x822c0890
	ctx.lr = 0x82A4AB84;
	sub_822C0890(ctx, base);
	// 82A4AB84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4AB88: 483A88A1  bl 0x82df3428
	ctx.lr = 0x82A4AB8C;
	sub_82DF3428(ctx, base);
	// 82A4AB8C: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4AB90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4AB94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4AB98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4AB9C: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82A4ABA0: 483A8E69  bl 0x82df3a08
	ctx.lr = 0x82A4ABA4;
	sub_82DF3A08(ctx, base);
	// 82A4ABA4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A4ABA8: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4ABAC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A4ABB0: 48168019  bl 0x82bb2bc8
	ctx.lr = 0x82A4ABB4;
	sub_82BB2BC8(ctx, base);
	// 82A4ABB4: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4ABB8: 895F0194  lbz r10, 0x194(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A4ABBC: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 82A4ABC0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4ABC4: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 82A4ABC8: 1D490003  mulli r10, r9, 3
	ctx.r[10].s64 = ctx.r[9].s64 * 3;
	// 82A4ABCC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A4ABD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4ABD4: 7C2BEC2E  lfsx f1, r11, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4ABD8: 4816DE99  bl 0x82bb8a70
	ctx.lr = 0x82A4ABDC;
	sub_82BB8A70(ctx, base);
	// 82A4ABDC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A4ABE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4ABE4: 419A0008  beq cr6, 0x82a4abec
	if ctx.cr[6].eq {
	pc = 0x82A4ABEC; continue 'dispatch;
	}
	// 82A4ABE8: 4B875CA9  bl 0x822c0890
	ctx.lr = 0x82A4ABEC;
	sub_822C0890(ctx, base);
	// 82A4ABEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4ABF0: 4BFFFEE0  b 0x82a4aad0
	pc = 0x82A4AAD0; continue 'dispatch;
	// 82A4ABF4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A4ABF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A4ABFC: 997F0181  stb r11, 0x181(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(385 as u32), ctx.r[11].u8 ) };
	// 82A4AC00: 995F0188  stb r10, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[10].u8 ) };
	// 82A4AC04: C01E05FC  lfs f0, 0x5fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4AC08: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82A4AC0C: 807E04BC  lwz r3, 0x4bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4AC10: 4BDAA7C1  bl 0x827f53d0
	ctx.lr = 0x82A4AC14;
	sub_827F53D0(ctx, base);
	// 82A4AC14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4AC18: 895F0188  lbz r10, 0x188(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4AC1C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A4AC20: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A4AC24: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4AC28: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4AC2C: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A4AC30: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82A4AC34: 483A8DD5  bl 0x82df3a08
	ctx.lr = 0x82A4AC38;
	sub_82DF3A08(ctx, base);
	// 82A4AC38: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A4AC3C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A4AC40: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4AC44: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A4AC48: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4AC4C: 4816872D  bl 0x82bb3378
	ctx.lr = 0x82A4AC50;
	sub_82BB3378(ctx, base);
	// 82A4AC50: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A4AC54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4AC58: 419A0008  beq cr6, 0x82a4ac60
	if ctx.cr[6].eq {
	pc = 0x82A4AC60; continue 'dispatch;
	}
	// 82A4AC5C: 4B875C35  bl 0x822c0890
	ctx.lr = 0x82A4AC60;
	sub_822C0890(ctx, base);
	// 82A4AC60: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A4AC64: 483A87C5  bl 0x82df3428
	ctx.lr = 0x82A4AC68;
	sub_82DF3428(ctx, base);
	// 82A4AC68: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4AC6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4AC70: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4AC74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4AC78: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82A4AC7C: 483A8D8D  bl 0x82df3a08
	ctx.lr = 0x82A4AC80;
	sub_82DF3A08(ctx, base);
	// 82A4AC80: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4AC84: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4AC88: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A4AC8C: 48167F3D  bl 0x82bb2bc8
	ctx.lr = 0x82A4AC90;
	sub_82BB2BC8(ctx, base);
	// 82A4AC90: 897F0188  lbz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A4AC94: 895F0194  lbz r10, 0x194(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A4AC98: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 82A4AC9C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4ACA0: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 82A4ACA4: 1D490003  mulli r10, r9, 3
	ctx.r[10].s64 = ctx.r[9].s64 * 3;
	// 82A4ACA8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A4ACAC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4ACB0: 7C2BEC2E  lfsx f1, r11, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4ACB4: 4816DDBD  bl 0x82bb8a70
	ctx.lr = 0x82A4ACB8;
	sub_82BB8A70(ctx, base);
	// 82A4ACB8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A4ACBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4ACC0: 419A0008  beq cr6, 0x82a4acc8
	if ctx.cr[6].eq {
	pc = 0x82A4ACC8; continue 'dispatch;
	}
	// 82A4ACC4: 4B875BCD  bl 0x822c0890
	ctx.lr = 0x82A4ACC8;
	sub_822C0890(ctx, base);
	// 82A4ACC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4ACCC: 4BFFFE04  b 0x82a4aad0
	pc = 0x82A4AAD0; continue 'dispatch;
	// 82A4ACD0: C01F0184  lfs f0, 0x184(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4ACD4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82A4ACD8: 419800C4  blt cr6, 0x82a4ad9c
	if ctx.cr[6].lt {
	pc = 0x82A4AD9C; continue 'dispatch;
	}
	// 82A4ACDC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A4ACE0: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4ACE4: 997F0181  stb r11, 0x181(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(385 as u32), ctx.r[11].u8 ) };
	// 82A4ACE8: 4BFFFD70  b 0x82a4aa58
	pc = 0x82A4AA58; continue 'dispatch;
	// 82A4ACEC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82A4ACF0: 807E052C  lwz r3, 0x52c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4ACF4: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82A4ACF8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A4ACFC: 4B88535D  bl 0x822d0058
	ctx.lr = 0x82A4AD00;
	sub_822D0058(ctx, base);
	// 82A4AD00: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4ADB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4ADB0 size=888
    let mut pc: u32 = 0x82A4ADB0;
    'dispatch: loop {
        match pc {
            0x82A4ADB0 => {
    //   block [0x82A4ADB0..0x82A4B128)
	// 82A4ADB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4ADB4: 4875D3B9  bl 0x831a816c
	ctx.lr = 0x82A4ADB8;
	sub_831A8130(ctx, base);
	// 82A4ADB8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4ADBC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4ADC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4ADC4: 4870983D  bl 0x83154600
	ctx.lr = 0x82A4ADC8;
	sub_83154600(ctx, base);
	// 82A4ADC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4ADCC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A4ADD0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4ADD4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A4ADD8: 807E053C  lwz r3, 0x53c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4ADDC: 4B88527D  bl 0x822d0058
	ctx.lr = 0x82A4ADE0;
	sub_822D0058(ctx, base);
	// 82A4ADE0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4ADE4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A4ADE8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A4ADEC: 48432535  bl 0x82e7d320
	ctx.lr = 0x82A4ADF0;
	sub_82E7D320(ctx, base);
	// 82A4ADF0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82A4ADF4: 394005E0  li r10, 0x5e0
	ctx.r[10].s64 = 1504;
	// 82A4ADF8: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82A4ADFC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A4AE00: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A4AE04: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4AE08: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4B128 size=660
    let mut pc: u32 = 0x82A4B128;
    'dispatch: loop {
        match pc {
            0x82A4B128 => {
    //   block [0x82A4B128..0x82A4B3BC)
	// 82A4B128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4B130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4B134: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A4B138: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B13C: 487094C5  bl 0x83154600
	ctx.lr = 0x82A4B140;
	sub_83154600(ctx, base);
	// 82A4B140: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4B148: 388B065C  addi r4, r11, 0x65c
	ctx.r[4].s64 = ctx.r[11].s64 + 1628;
	// 82A4B14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B150: 483A88B9  bl 0x82df3a08
	ctx.lr = 0x82A4B154;
	sub_82DF3A08(ctx, base);
	// 82A4B154: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4B158: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B15C: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4B164: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4B168: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B16C: 48167B4D  bl 0x82bb2cb8
	ctx.lr = 0x82A4B170;
	sub_82BB2CB8(ctx, base);
	// 82A4B170: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4B174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B178: 419A0008  beq cr6, 0x82a4b180
	if ctx.cr[6].eq {
	pc = 0x82A4B180; continue 'dispatch;
	}
	// 82A4B17C: 4B875715  bl 0x822c0890
	ctx.lr = 0x82A4B180;
	sub_822C0890(ctx, base);
	// 82A4B180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B184: 483A82A5  bl 0x82df3428
	ctx.lr = 0x82A4B188;
	sub_82DF3428(ctx, base);
	// 82A4B188: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B190: 388B0624  addi r4, r11, 0x624
	ctx.r[4].s64 = ctx.r[11].s64 + 1572;
	// 82A4B194: 483A8875  bl 0x82df3a08
	ctx.lr = 0x82A4B198;
	sub_82DF3A08(ctx, base);
	// 82A4B198: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B19C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4B1A0: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B1A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B1A8: 48167B11  bl 0x82bb2cb8
	ctx.lr = 0x82A4B1AC;
	sub_82BB2CB8(ctx, base);
	// 82A4B1AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4B1B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B1B4: 419A0008  beq cr6, 0x82a4b1bc
	if ctx.cr[6].eq {
	pc = 0x82A4B1BC; continue 'dispatch;
	}
	// 82A4B1B8: 4B8756D9  bl 0x822c0890
	ctx.lr = 0x82A4B1BC;
	sub_822C0890(ctx, base);
	// 82A4B1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B1C0: 483A8269  bl 0x82df3428
	ctx.lr = 0x82A4B1C4;
	sub_82DF3428(ctx, base);
	// 82A4B1C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B1C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B1CC: 388B05F8  addi r4, r11, 0x5f8
	ctx.r[4].s64 = ctx.r[11].s64 + 1528;
	// 82A4B1D0: 483A8839  bl 0x82df3a08
	ctx.lr = 0x82A4B1D4;
	sub_82DF3A08(ctx, base);
	// 82A4B1D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B1D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4B1DC: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B1E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B1E4: 48167AD5  bl 0x82bb2cb8
	ctx.lr = 0x82A4B1E8;
	sub_82BB2CB8(ctx, base);
	// 82A4B1E8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A4B1EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B1F0: 419A0008  beq cr6, 0x82a4b1f8
	if ctx.cr[6].eq {
	pc = 0x82A4B1F8; continue 'dispatch;
	}
	// 82A4B1F4: 4B87569D  bl 0x822c0890
	ctx.lr = 0x82A4B1F8;
	sub_822C0890(ctx, base);
	// 82A4B1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B1FC: 483A822D  bl 0x82df3428
	ctx.lr = 0x82A4B200;
	sub_82DF3428(ctx, base);
	// 82A4B200: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B208: 388B05CC  addi r4, r11, 0x5cc
	ctx.r[4].s64 = ctx.r[11].s64 + 1484;
	// 82A4B20C: 483A87FD  bl 0x82df3a08
	ctx.lr = 0x82A4B210;
	sub_82DF3A08(ctx, base);
	// 82A4B210: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B214: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4B218: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B21C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B220: 48167A99  bl 0x82bb2cb8
	ctx.lr = 0x82A4B224;
	sub_82BB2CB8(ctx, base);
	// 82A4B224: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A4B228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B22C: 419A0008  beq cr6, 0x82a4b234
	if ctx.cr[6].eq {
	pc = 0x82A4B234; continue 'dispatch;
	}
	// 82A4B230: 4B875661  bl 0x822c0890
	ctx.lr = 0x82A4B234;
	sub_822C0890(ctx, base);
	// 82A4B234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B238: 483A81F1  bl 0x82df3428
	ctx.lr = 0x82A4B23C;
	sub_82DF3428(ctx, base);
	// 82A4B23C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B244: 388B0598  addi r4, r11, 0x598
	ctx.r[4].s64 = ctx.r[11].s64 + 1432;
	// 82A4B248: 483A87C1  bl 0x82df3a08
	ctx.lr = 0x82A4B24C;
	sub_82DF3A08(ctx, base);
	// 82A4B24C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B250: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A4B254: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B258: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B25C: 48167A5D  bl 0x82bb2cb8
	ctx.lr = 0x82A4B260;
	sub_82BB2CB8(ctx, base);
	// 82A4B260: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A4B264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B268: 419A0008  beq cr6, 0x82a4b270
	if ctx.cr[6].eq {
	pc = 0x82A4B270; continue 'dispatch;
	}
	// 82A4B26C: 4B875625  bl 0x822c0890
	ctx.lr = 0x82A4B270;
	sub_822C0890(ctx, base);
	// 82A4B270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B274: 483A81B5  bl 0x82df3428
	ctx.lr = 0x82A4B278;
	sub_82DF3428(ctx, base);
	// 82A4B278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B27C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B280: 388B0568  addi r4, r11, 0x568
	ctx.r[4].s64 = ctx.r[11].s64 + 1384;
	// 82A4B284: 483A8785  bl 0x82df3a08
	ctx.lr = 0x82A4B288;
	sub_82DF3A08(ctx, base);
	// 82A4B288: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B28C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A4B290: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B294: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B298: 48167A21  bl 0x82bb2cb8
	ctx.lr = 0x82A4B29C;
	sub_82BB2CB8(ctx, base);
	// 82A4B29C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A4B2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B2A4: 419A0008  beq cr6, 0x82a4b2ac
	if ctx.cr[6].eq {
	pc = 0x82A4B2AC; continue 'dispatch;
	}
	// 82A4B2A8: 4B8755E9  bl 0x822c0890
	ctx.lr = 0x82A4B2AC;
	sub_822C0890(ctx, base);
	// 82A4B2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B2B0: 483A8179  bl 0x82df3428
	ctx.lr = 0x82A4B2B4;
	sub_82DF3428(ctx, base);
	// 82A4B2B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B2BC: 388B0538  addi r4, r11, 0x538
	ctx.r[4].s64 = ctx.r[11].s64 + 1336;
	// 82A4B2C0: 483A8749  bl 0x82df3a08
	ctx.lr = 0x82A4B2C4;
	sub_82DF3A08(ctx, base);
	// 82A4B2C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B2C8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A4B2CC: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B2D0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B2D4: 481679E5  bl 0x82bb2cb8
	ctx.lr = 0x82A4B2D8;
	sub_82BB2CB8(ctx, base);
	// 82A4B2D8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A4B2DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B2E0: 419A0008  beq cr6, 0x82a4b2e8
	if ctx.cr[6].eq {
	pc = 0x82A4B2E8; continue 'dispatch;
	}
	// 82A4B2E4: 4B8755AD  bl 0x822c0890
	ctx.lr = 0x82A4B2E8;
	sub_822C0890(ctx, base);
	// 82A4B2E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B2EC: 483A813D  bl 0x82df3428
	ctx.lr = 0x82A4B2F0;
	sub_82DF3428(ctx, base);
	// 82A4B2F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B2F8: 388B0510  addi r4, r11, 0x510
	ctx.r[4].s64 = ctx.r[11].s64 + 1296;
	// 82A4B2FC: 483A870D  bl 0x82df3a08
	ctx.lr = 0x82A4B300;
	sub_82DF3A08(ctx, base);
	// 82A4B300: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B304: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A4B308: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B30C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B310: 481679A9  bl 0x82bb2cb8
	ctx.lr = 0x82A4B314;
	sub_82BB2CB8(ctx, base);
	// 82A4B314: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A4B318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B31C: 419A0008  beq cr6, 0x82a4b324
	if ctx.cr[6].eq {
	pc = 0x82A4B324; continue 'dispatch;
	}
	// 82A4B320: 4B875571  bl 0x822c0890
	ctx.lr = 0x82A4B324;
	sub_822C0890(ctx, base);
	// 82A4B324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B328: 483A8101  bl 0x82df3428
	ctx.lr = 0x82A4B32C;
	sub_82DF3428(ctx, base);
	// 82A4B32C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B334: 388B04E4  addi r4, r11, 0x4e4
	ctx.r[4].s64 = ctx.r[11].s64 + 1252;
	// 82A4B338: 483A86D1  bl 0x82df3a08
	ctx.lr = 0x82A4B33C;
	sub_82DF3A08(ctx, base);
	// 82A4B33C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B340: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A4B344: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B348: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B34C: 4816796D  bl 0x82bb2cb8
	ctx.lr = 0x82A4B350;
	sub_82BB2CB8(ctx, base);
	// 82A4B350: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A4B354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B358: 419A0008  beq cr6, 0x82a4b360
	if ctx.cr[6].eq {
	pc = 0x82A4B360; continue 'dispatch;
	}
	// 82A4B35C: 4B875535  bl 0x822c0890
	ctx.lr = 0x82A4B360;
	sub_822C0890(ctx, base);
	// 82A4B360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B364: 483A80C5  bl 0x82df3428
	ctx.lr = 0x82A4B368;
	sub_82DF3428(ctx, base);
	// 82A4B368: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4B36C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B370: 388B04B4  addi r4, r11, 0x4b4
	ctx.r[4].s64 = ctx.r[11].s64 + 1204;
	// 82A4B374: 483A8695  bl 0x82df3a08
	ctx.lr = 0x82A4B378;
	sub_82DF3A08(ctx, base);
	// 82A4B378: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B37C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A4B380: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B384: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4B388: 48167931  bl 0x82bb2cb8
	ctx.lr = 0x82A4B38C;
	sub_82BB2CB8(ctx, base);
	// 82A4B38C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A4B390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B394: 419A0008  beq cr6, 0x82a4b39c
	if ctx.cr[6].eq {
	pc = 0x82A4B39C; continue 'dispatch;
	}
	// 82A4B398: 4B8754F9  bl 0x822c0890
	ctx.lr = 0x82A4B39C;
	sub_822C0890(ctx, base);
	// 82A4B39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B3A0: 483A8089  bl 0x82df3428
	ctx.lr = 0x82A4B3A4;
	sub_82DF3428(ctx, base);
	// 82A4B3A4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A4B3A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4B3AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4B3B0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4B3B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4B3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4B3C0 size=68
    let mut pc: u32 = 0x82A4B3C0;
    'dispatch: loop {
        match pc {
            0x82A4B3C0 => {
    //   block [0x82A4B3C0..0x82A4B404)
	// 82A4B3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4B3C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4B3CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4B3D4: 4BFFF61D  bl 0x82a4a9f0
	ctx.lr = 0x82A4B3D8;
	sub_82A4A9F0(ctx, base);
	// 82A4B3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4B3DC: 4BFFF3D5  bl 0x82a4a7b0
	ctx.lr = 0x82A4B3E0;
	sub_82A4A7B0(ctx, base);
	// 82A4B3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4B3E4: 480032DD  bl 0x82a4e6c0
	ctx.lr = 0x82A4B3E8;
	sub_82A4E6C0(ctx, base);
	// 82A4B3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4B3EC: 4BFFF9C5  bl 0x82a4adb0
	ctx.lr = 0x82A4B3F0;
	sub_82A4ADB0(ctx, base);
	// 82A4B3F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4B3F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4B3F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4B3FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4B400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4B408 size=196
    let mut pc: u32 = 0x82A4B408;
    'dispatch: loop {
        match pc {
            0x82A4B408 => {
    //   block [0x82A4B408..0x82A4B4CC)
	// 82A4B408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4B410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4B414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4B418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4B420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4B424: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4B428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4B42C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4B430: 4B875509  bl 0x822c0938
	ctx.lr = 0x82A4B434;
	sub_822C0938(ctx, base);
	// 82A4B434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4B438: 41820028  beq 0x82a4b460
	if ctx.cr[0].eq {
	pc = 0x82A4B460; continue 'dispatch;
	}
	// 82A4B43C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4B440: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4B444: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4B448: 392BD1E8  addi r9, r11, -0x2e18
	ctx.r[9].s64 = ctx.r[11].s64 + -11800;
	// 82A4B44C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4B450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4B454: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4B458: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4B45C: 48000008  b 0x82a4b464
	pc = 0x82A4B464; continue 'dispatch;
	// 82A4B460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4B464: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4B468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4B46C: 409A0044  bne cr6, 0x82a4b4b0
	if !ctx.cr[6].eq {
	pc = 0x82A4B4B0; continue 'dispatch;
	}
	// 82A4B470: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4B474: 419A001C  beq cr6, 0x82a4b490
	if ctx.cr[6].eq {
	pc = 0x82A4B490; continue 'dispatch;
	}
	// 82A4B478: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4B47C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4B480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4B484: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4B488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4B48C: 4E800421  bctrl
	ctx.lr = 0x82A4B490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4B490: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4B494: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4B498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B49C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4B4A0: 816B3FE0  lwz r11, 0x3fe0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16352 as u32) ) } as u64;
	// 82A4B4A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4B4A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4B4AC: 4B874B55  bl 0x822c0000
	ctx.lr = 0x82A4B4B0;
	sub_822C0000(ctx, base);
	// 82A4B4B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4B4B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4B4B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4B4BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4B4C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4B4C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4B4C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4B4D0 size=292
    let mut pc: u32 = 0x82A4B4D0;
    'dispatch: loop {
        match pc {
            0x82A4B4D0 => {
    //   block [0x82A4B4D0..0x82A4B5F4)
	// 82A4B4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B4D4: 4875CC99  bl 0x831a816c
	ctx.lr = 0x82A4B4D8;
	sub_831A8130(ctx, base);
	// 82A4B4D8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A4B4DC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4B4E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B4E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4B4E8: 48709119  bl 0x83154600
	ctx.lr = 0x82A4B4EC;
	sub_83154600(ctx, base);
	// 82A4B4EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4B4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4B4F4: 4BFFB4C5  bl 0x82a469b8
	ctx.lr = 0x82A4B4F8;
	sub_82A469B8(ctx, base);
	// 82A4B4F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A4B4FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4B500: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A4B504: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4B508: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A4B50C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4B510: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4B514: 4BFED08D  bl 0x82a385a0
	ctx.lr = 0x82A4B518;
	sub_82A385A0(ctx, base);
	// 82A4B518: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4B51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B520: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A4B524: 483A84E5  bl 0x82df3a08
	ctx.lr = 0x82A4B528;
	sub_82DF3A08(ctx, base);
	// 82A4B528: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4B52C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4B530: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4B534: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4B538: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4B53C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4B540: 48167E39  bl 0x82bb3378
	ctx.lr = 0x82A4B544;
	sub_82BB3378(ctx, base);
	// 82A4B544: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4B548: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4B54C: 419A0008  beq cr6, 0x82a4b554
	if ctx.cr[6].eq {
	pc = 0x82A4B554; continue 'dispatch;
	}
	// 82A4B550: 4B875341  bl 0x822c0890
	ctx.lr = 0x82A4B554;
	sub_822C0890(ctx, base);
	// 82A4B554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4B558: 483A7ED1  bl 0x82df3428
	ctx.lr = 0x82A4B55C;
	sub_82DF3428(ctx, base);
	// 82A4B55C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4B560: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82A4B564: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4B568: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A4B56C: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A4B570: C00B57F0  lfs f0, 0x57f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4B574: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A4B578: C1AAAA18  lfs f13, -0x55e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21992 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4B57C: C1898498  lfs f12, -0x7b68(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31592 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4B580: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4B584: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A4B588: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A4B58C: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4B590: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4B594: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4B598: C02789AC  lfs f1, -0x7654(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4B59C: 4B884F2D  bl 0x822d04c8
	ctx.lr = 0x82A4B5A0;
	sub_822D04C8(ctx, base);
	// 82A4B5A0: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4B5A4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A4B5A8: 4B884979  bl 0x822cff20
	ctx.lr = 0x82A4B5AC;
	sub_822CFF20(ctx, base);
	// 82A4B5AC: EC1E0828  fsubs f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A4B5B0: C1BF05FC  lfs f13, 0x5fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4B5B4: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4B5B8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4B5BC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4B5C0: D01F05FC  stfs f0, 0x5fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4B5C4: 4B88496D  bl 0x822cff30
	ctx.lr = 0x82A4B5C8;
	sub_822CFF30(ctx, base);
	// 82A4B5C8: D3FE0068  stfs f31, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4B5CC: D3FE006C  stfs f31, 0x6c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4B5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4B5D4: 48002F4D  bl 0x82a4e520
	ctx.lr = 0x82A4B5D8;
	sub_82A4E520(ctx, base);
	// 82A4B5D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4B5DC: 480030E5  bl 0x82a4e6c0
	ctx.lr = 0x82A4B5E0;
	sub_82A4E6C0(ctx, base);
	// 82A4B5E0: 93BE0190  stw r29, 0x190(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(400 as u32), ctx.r[29].u32 ) };
	// 82A4B5E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A4B5E8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A4B5EC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4B5F0: 4875CBCC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4B5F8 size=60
    let mut pc: u32 = 0x82A4B5F8;
    'dispatch: loop {
        match pc {
            0x82A4B5F8 => {
    //   block [0x82A4B5F8..0x82A4B634)
	// 82A4B5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4B600: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B604: 48708FFD  bl 0x83154600
	ctx.lr = 0x82A4B608;
	sub_83154600(ctx, base);
	// 82A4B608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4B60C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4B610: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A4B614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4B618: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4B61C: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4B620: 4BFECF81  bl 0x82a385a0
	ctx.lr = 0x82A4B624;
	sub_82A385A0(ctx, base);
	// 82A4B624: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4B628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4B62C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4B630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4B638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4B638 size=1040
    let mut pc: u32 = 0x82A4B638;
    'dispatch: loop {
        match pc {
            0x82A4B638 => {
    //   block [0x82A4B638..0x82A4BA48)
	// 82A4B638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4B63C: 4875CB11  bl 0x831a814c
	ctx.lr = 0x82A4B640;
	sub_831A8130(ctx, base);
	// 82A4B640: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 82A4B644: 4875D415  bl 0x831a8a58
	ctx.lr = 0x82A4B648;
	sub_831A8A40(ctx, base);
	// 82A4B648: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4B64C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A4B650: 48708FB1  bl 0x83154600
	ctx.lr = 0x82A4B654;
	sub_83154600(ctx, base);
	// 82A4B654: 817C0190  lwz r11, 0x190(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(400 as u32) ) } as u64;
	// 82A4B658: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4B65C: 2B0B0120  cmplwi cr6, r11, 0x120
	ctx.cr[6].compare_u32(ctx.r[11].u32, 288 as u32, &mut ctx.xer);
	// 82A4B660: 41980054  blt cr6, 0x82a4b6b4
	if ctx.cr[6].lt {
	pc = 0x82A4B6B4; continue 'dispatch;
	}
	// 82A4B664: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4B668: 39400610  li r10, 0x610
	ctx.r[10].s64 = 1552;
	// 82A4B66C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A4B670: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A4B674: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4BA48 size=52
    let mut pc: u32 = 0x82A4BA48;
    'dispatch: loop {
        match pc {
            0x82A4BA48 => {
    //   block [0x82A4BA48..0x82A4BA7C)
	// 82A4BA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4BA50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4BA54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BA58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BA5C: 4BFFFBDD  bl 0x82a4b638
	ctx.lr = 0x82A4BA60;
	sub_82A4B638(ctx, base);
	// 82A4BA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BA64: 48708B9D  bl 0x83154600
	ctx.lr = 0x82A4BA68;
	sub_83154600(ctx, base);
	// 82A4BA68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4BA6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4BA70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4BA74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4BA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4BA80 size=72
    let mut pc: u32 = 0x82A4BA80;
    'dispatch: loop {
        match pc {
            0x82A4BA80 => {
    //   block [0x82A4BA80..0x82A4BAC8)
	// 82A4BA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4BA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4BA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BA94: 4BFE6425  bl 0x82a31eb8
	ctx.lr = 0x82A4BA98;
	sub_82A31EB8(ctx, base);
	// 82A4BA98: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4BA9C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A4BAA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BAA4: 394AD278  addi r10, r10, -0x2d88
	ctx.r[10].s64 = ctx.r[10].s64 + -11656;
	// 82A4BAA8: C00B4030  lfs f0, 0x4030(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BAAC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A4BAB0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4BAB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4BAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4BABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4BAC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4BAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4BAC8 size=104
    let mut pc: u32 = 0x82A4BAC8;
    'dispatch: loop {
        match pc {
            0x82A4BAC8 => {
    //   block [0x82A4BAC8..0x82A4BB30)
	// 82A4BAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4BAD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4BAD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BAD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4BADC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4BAE0: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82A4BAE4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A4BAE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4BAEC: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4BAF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BAF4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BAF8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A4BAFC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A4BB00: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A4BB04: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A4BB08: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BB0C: C1A89530  lfs f13, -0x6ad0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4BB10: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4BB14: 4843112D  bl 0x82e7cc40
	ctx.lr = 0x82A4BB18;
	sub_82E7CC40(ctx, base);
	// 82A4BB18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BB1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4BB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4BB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4BB28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4BB2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4BB30 size=196
    let mut pc: u32 = 0x82A4BB30;
    'dispatch: loop {
        match pc {
            0x82A4BB30 => {
    //   block [0x82A4BB30..0x82A4BBF4)
	// 82A4BB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4BB38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4BB3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4BB40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BB44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4BB48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4BB4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4BB50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4BB54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4BB58: 4B874DE1  bl 0x822c0938
	ctx.lr = 0x82A4BB5C;
	sub_822C0938(ctx, base);
	// 82A4BB5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4BB60: 41820028  beq 0x82a4bb88
	if ctx.cr[0].eq {
	pc = 0x82A4BB88; continue 'dispatch;
	}
	// 82A4BB64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4BB68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4BB6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4BB70: 392BD2A4  addi r9, r11, -0x2d5c
	ctx.r[9].s64 = ctx.r[11].s64 + -11612;
	// 82A4BB74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4BB78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4BB7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4BB80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4BB84: 48000008  b 0x82a4bb8c
	pc = 0x82A4BB8C; continue 'dispatch;
	// 82A4BB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4BB8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4BB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4BB94: 409A0044  bne cr6, 0x82a4bbd8
	if !ctx.cr[6].eq {
	pc = 0x82A4BBD8; continue 'dispatch;
	}
	// 82A4BB98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4BB9C: 419A001C  beq cr6, 0x82a4bbb8
	if ctx.cr[6].eq {
	pc = 0x82A4BBB8; continue 'dispatch;
	}
	// 82A4BBA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BBA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4BBA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BBAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4BBB4: 4E800421  bctrl
	ctx.lr = 0x82A4BBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4BBB8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4BBBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4BBC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4BBC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4BBC8: 816B407C  lwz r11, 0x407c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16508 as u32) ) } as u64;
	// 82A4BBCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4BBD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4BBD4: 4B87442D  bl 0x822c0000
	ctx.lr = 0x82A4BBD8;
	sub_822C0000(ctx, base);
	// 82A4BBD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4BBDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4BBE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4BBE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4BBE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4BBEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4BBF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4BBF8 size=268
    let mut pc: u32 = 0x82A4BBF8;
    'dispatch: loop {
        match pc {
            0x82A4BBF8 => {
    //   block [0x82A4BBF8..0x82A4BD04)
	// 82A4BBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BBFC: 4875C565  bl 0x831a8160
	ctx.lr = 0x82A4BC00;
	sub_831A8130(ctx, base);
	// 82A4BC00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BC08: 487089F9  bl 0x83154600
	ctx.lr = 0x82A4BC0C;
	sub_83154600(ctx, base);
	// 82A4BC0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4BC10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BC14: 4840DB65  bl 0x82e59778
	ctx.lr = 0x82A4BC18;
	sub_82E59778(ctx, base);
	// 82A4BC18: C01F0180  lfs f0, 0x180(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BC1C: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4BC20: 3F60832E  lis r27, -0x7cd2
	ctx.r[27].s64 = -2094137344;
	// 82A4BC24: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4BC28: C01B4044  lfs f0, 0x4044(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BC2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4BC30: 419800CC  blt cr6, 0x82a4bcfc
	if ctx.cr[6].lt {
	pc = 0x82A4BCFC; continue 'dispatch;
	}
	// 82A4BC34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4BC38: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A4BC3C: 3B8BD2B4  addi r28, r11, -0x2d4c
	ctx.r[28].s64 = ctx.r[11].s64 + -11596;
	// 82A4BC40: 3BAA6910  addi r29, r10, 0x6910
	ctx.r[29].s64 = ctx.r[10].s64 + 26896;
	// 82A4BC44: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4BC48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4BC4C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4BC50: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4BC54: 80BE0584  lwz r5, 0x584(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1412 as u32) ) } as u64;
	// 82A4BC58: 809E04E4  lwz r4, 0x4e4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1252 as u32) ) } as u64;
	// 82A4BC5C: 483C96DD  bl 0x82e15338
	ctx.lr = 0x82A4BC60;
	sub_82E15338(ctx, base);
	// 82A4BC60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4BC64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BC68: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A4BC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4BC70: 4E800421  bctrl
	ctx.lr = 0x82A4BC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4BC74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4BC78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4BC7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A4BC80: 48430049  bl 0x82e7bcc8
	ctx.lr = 0x82A4BC84;
	sub_82E7BCC8(ctx, base);
	// 82A4BC84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4BC88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4BC8C: 419A0008  beq cr6, 0x82a4bc94
	if ctx.cr[6].eq {
	pc = 0x82A4BC94; continue 'dispatch;
	}
	// 82A4BC90: 4B874C01  bl 0x822c0890
	ctx.lr = 0x82A4BC94;
	sub_822C0890(ctx, base);
	// 82A4BC94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4BC98: 4BA9EDF1  bl 0x824eaa88
	ctx.lr = 0x82A4BC9C;
	sub_824EAA88(ctx, base);
	// 82A4BC9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4BCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4BCA4: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BCA8: 4BAC3721  bl 0x8250f3c8
	ctx.lr = 0x82A4BCAC;
	sub_8250F3C8(ctx, base);
	// 82A4BCAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4BCB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A4BCB4: 4BA9F35D  bl 0x824eb010
	ctx.lr = 0x82A4BCB8;
	sub_824EB010(ctx, base);
	// 82A4BCB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4BCBC: 483A5FD5  bl 0x82df1c90
	ctx.lr = 0x82A4BCC0;
	sub_82DF1C90(ctx, base);
	// 82A4BCC0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BCC4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A4BCC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A4BCCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4BCD0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A4BCD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4BCD8: 4E800421  bctrl
	ctx.lr = 0x82A4BCDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4BCDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4BCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4BCE4: 419A0008  beq cr6, 0x82a4bcec
	if ctx.cr[6].eq {
	pc = 0x82A4BCEC; continue 'dispatch;
	}
	// 82A4BCE8: 4B874BA9  bl 0x822c0890
	ctx.lr = 0x82A4BCEC;
	sub_822C0890(ctx, base);
	// 82A4BCEC: C1BF0180  lfs f13, 0x180(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4BCF0: C01B4044  lfs f0, 0x4044(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BCF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4BCF8: 4098FF4C  bge cr6, 0x82a4bc44
	if !ctx.cr[6].lt {
	pc = 0x82A4BC44; continue 'dispatch;
	}
	// 82A4BCFC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A4BD00: 4875C4B0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4BD08 size=720
    let mut pc: u32 = 0x82A4BD08;
    'dispatch: loop {
        match pc {
            0x82A4BD08 => {
    //   block [0x82A4BD08..0x82A4BFD8)
	// 82A4BD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BD0C: 4875C445  bl 0x831a8150
	ctx.lr = 0x82A4BD10;
	sub_831A8130(ctx, base);
	// 82A4BD10: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 82A4BD14: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82A4BD18: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82A4BD1C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BD20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BD24: 487088DD  bl 0x83154600
	ctx.lr = 0x82A4BD28;
	sub_83154600(ctx, base);
	// 82A4BD28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4BD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BD30: 4BFFAC89  bl 0x82a469b8
	ctx.lr = 0x82A4BD34;
	sub_82A469B8(ctx, base);
	// 82A4BD34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4BD38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4BD3C: 3AEBD2D0  addi r23, r11, -0x2d30
	ctx.r[23].s64 = ctx.r[11].s64 + -11568;
	// 82A4BD40: 38A000CF  li r5, 0xcf
	ctx.r[5].s64 = 207;
	// 82A4BD44: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A4BD48: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A4BD4C: 4B87468D  bl 0x822c03d8
	ctx.lr = 0x82A4BD50;
	sub_822C03D8(ctx, base);
	// 82A4BD50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4BD54: 41820010  beq 0x82a4bd64
	if ctx.cr[0].eq {
	pc = 0x82A4BD64; continue 'dispatch;
	}
	// 82A4BD58: 4BFFFD29  bl 0x82a4ba80
	ctx.lr = 0x82A4BD5C;
	sub_82A4BA80(ctx, base);
	// 82A4BD5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4BD60: 48000008  b 0x82a4bd68
	pc = 0x82A4BD68; continue 'dispatch;
	// 82A4BD64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A4BD68: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A4BD6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A4BD70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4BD74: 4BFFFDBD  bl 0x82a4bb30
	ctx.lr = 0x82A4BD78;
	sub_82A4BB30(ctx, base);
	// 82A4BD78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A4BD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A4BD80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4BD84: 4B87427D  bl 0x822c0000
	ctx.lr = 0x82A4BD88;
	sub_822C0000(ctx, base);
	// 82A4BD88: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4BD8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4BD90: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4BD94: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A4BD98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A4BD9C: 419A0024  beq cr6, 0x82a4bdc0
	if ctx.cr[6].eq {
	pc = 0x82A4BDC0; continue 'dispatch;
	}
	// 82A4BDA0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4BDA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4BDA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BDAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4BDB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4BDB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4BDB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BDBC: 4082FFE8  bne 0x82a4bda4
	if !ctx.cr[0].eq {
	pc = 0x82A4BDA4; continue 'dispatch;
	}
	// 82A4BDC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4BDC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A4BDC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4BDCC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4BDD0: 4BFEC7D1  bl 0x82a385a0
	ctx.lr = 0x82A4BDD4;
	sub_82A385A0(ctx, base);
	// 82A4BDD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4BDD8: 419A000C  beq cr6, 0x82a4bde4
	if ctx.cr[6].eq {
	pc = 0x82A4BDE4; continue 'dispatch;
	}
	// 82A4BDDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4BDE0: 4B874AB1  bl 0x822c0890
	ctx.lr = 0x82A4BDE4;
	sub_822C0890(ctx, base);
	// 82A4BDE4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4BDE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4BDEC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4BDF0: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A4BDF4: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A4BDF8: C1ABD7A4  lfs f13, -0x285c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10332 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4BDFC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A4BE00: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BE04: C1890A98  lfs f12, 0xa98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4BE08: C168D2C8  lfs f11, -0x2d38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11576 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4BE0C: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A4BE10: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4BE14: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A4BE18: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A4BE1C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A4BE20: 807D052C  lwz r3, 0x52c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4BE24: C02789AC  lfs f1, -0x7654(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4BE28: 4B8846A1  bl 0x822d04c8
	ctx.lr = 0x82A4BE2C;
	sub_822D04C8(ctx, base);
	// 82A4BE2C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4BE30: 3BCB4074  addi r30, r11, 0x4074
	ctx.r[30].s64 = ctx.r[11].s64 + 16500;
	// 82A4BE34: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4BE38: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4BE3C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A4BE40: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A4BE44: 3B9EFFE8  addi r28, r30, -0x18
	ctx.r[28].s64 = ctx.r[30].s64 + -24;
	// 82A4BE48: 3B2B4080  addi r25, r11, 0x4080
	ctx.r[25].s64 = ctx.r[11].s64 + 16512;
	// 82A4BE4C: 3B0ADF30  addi r24, r10, -0x20d0
	ctx.r[24].s64 = ctx.r[10].s64 + -8400;
	// 82A4BE50: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A4BE54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4BE58: 38A000DC  li r5, 0xdc
	ctx.r[5].s64 = 220;
	// 82A4BE5C: 38600360  li r3, 0x360
	ctx.r[3].s64 = 864;
	// 82A4BE60: 483A6589  bl 0x82df23e8
	ctx.lr = 0x82A4BE64;
	sub_82DF23E8(ctx, base);
	// 82A4BE64: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A4BE68: 41820084  beq 0x82a4beec
	if ctx.cr[0].eq {
	pc = 0x82A4BEEC; continue 'dispatch;
	}
	// 82A4BE6C: 817D0540  lwz r11, 0x540(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1344 as u32) ) } as u64;
	// 82A4BE70: 815D053C  lwz r10, 0x53c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4BE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4BE78: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A4BE7C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A4BE80: 419A0024  beq cr6, 0x82a4bea4
	if ctx.cr[6].eq {
	pc = 0x82A4BEA4; continue 'dispatch;
	}
	// 82A4BE84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A4BE88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4BE8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BE90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4BE94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4BE98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4BE9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BEA0: 4082FFE8  bne 0x82a4be88
	if !ctx.cr[0].eq {
	pc = 0x82A4BE88; continue 'dispatch;
	}
	// 82A4BEA4: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4BEA8: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82A4BEAC: C3DEFFE4  lfs f30, -0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4BEB0: 7F7AF0AE  lbzx r27, r26, r30
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82A4BEB4: EFA0F82A  fadds f29, f0, f31
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A4BEB8: 3AC10058  addi r22, r1, 0x58
	ctx.r[22].s64 = ctx.r[1].s64 + 88;
	// 82A4BEBC: 485BD0FD  bl 0x83008fb8
	ctx.lr = 0x82A4BEC0;
	sub_83008FB8(ctx, base);
	// 82A4BEC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4BEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BEC8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A4BECC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A4BED0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A4BED4: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 82A4BED8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82A4BEDC: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82A4BEE0: 4800D4F1  bl 0x82a593d0
	ctx.lr = 0x82A4BEE4;
	sub_82A593D0(ctx, base);
	// 82A4BEE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BEE8: 48000008  b 0x82a4bef0
	pc = 0x82A4BEF0; continue 'dispatch;
	// 82A4BEEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4BEF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A4BEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4BEF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4BEFC: 4BFFC8A5  bl 0x82a487a0
	ctx.lr = 0x82A4BF00;
	sub_82A487A0(ctx, base);
	// 82A4BF00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A4BF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4BF08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4BF0C: 4B8740F5  bl 0x822c0000
	ctx.lr = 0x82A4BF10;
	sub_822C0000(ctx, base);
	// 82A4BF10: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4BF14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4BF18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A4BF1C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82A4BF20: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A4BF24: 419A0024  beq cr6, 0x82a4bf48
	if ctx.cr[6].eq {
	pc = 0x82A4BF48; continue 'dispatch;
	}
	// 82A4BF28: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A4BF2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4BF30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BF34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4BF38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4BF3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4BF40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4BF44: 4082FFE8  bne 0x82a4bf2c
	if !ctx.cr[0].eq {
	pc = 0x82A4BF2C; continue 'dispatch;
	}
	// 82A4BF48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A4BF4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4BF50: 4BAC3579  bl 0x8250f4c8
	ctx.lr = 0x82A4BF54;
	sub_8250F4C8(ctx, base);
	// 82A4BF54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4BF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4BF5C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A4BF60: 409A0008  bne cr6, 0x82a4bf68
	if !ctx.cr[6].eq {
	pc = 0x82A4BF68; continue 'dispatch;
	}
	// 82A4BF64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4BF68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A4BF6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4BF70: 3AC10060  addi r22, r1, 0x60
	ctx.r[22].s64 = ctx.r[1].s64 + 96;
	// 82A4BF74: 4BAC35A5  bl 0x8250f518
	ctx.lr = 0x82A4BF78;
	sub_8250F518(ctx, base);
	// 82A4BF78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4BF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BF80: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82A4BF84: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A4BF88: 4BAC1581  bl 0x8250d508
	ctx.lr = 0x82A4BF8C;
	sub_8250D508(ctx, base);
	// 82A4BF8C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4BF90: 483A5D01  bl 0x82df1c90
	ctx.lr = 0x82A4BF94;
	sub_82DF1C90(ctx, base);
	// 82A4BF94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4BF98: 483A5CF9  bl 0x82df1c90
	ctx.lr = 0x82A4BF9C;
	sub_82DF1C90(ctx, base);
	// 82A4BF9C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A4BFA0: 419A000C  beq cr6, 0x82a4bfac
	if ctx.cr[6].eq {
	pc = 0x82A4BFAC; continue 'dispatch;
	}
	// 82A4BFA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A4BFA8: 4B8748E9  bl 0x822c0890
	ctx.lr = 0x82A4BFAC;
	sub_822C0890(ctx, base);
	// 82A4BFAC: 397EFFE8  addi r11, r30, -0x18
	ctx.r[11].s64 = ctx.r[30].s64 + -24;
	// 82A4BFB0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A4BFB4: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A4BFB8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82A4BFBC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A4BFC0: 4198FE90  blt cr6, 0x82a4be50
	if ctx.cr[6].lt {
	pc = 0x82A4BE50; continue 'dispatch;
	}
	// 82A4BFC4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A4BFC8: CBA1FF90  lfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82A4BFCC: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82A4BFD0: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82A4BFD4: 4875C1CC  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4BFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4BFD8 size=52
    let mut pc: u32 = 0x82A4BFD8;
    'dispatch: loop {
        match pc {
            0x82A4BFD8 => {
    //   block [0x82A4BFD8..0x82A4C00C)
	// 82A4BFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4BFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4BFE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4BFE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4BFE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4BFEC: 4BFFBAAD  bl 0x82a47a98
	ctx.lr = 0x82A4BFF0;
	sub_82A47A98(ctx, base);
	// 82A4BFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4BFF4: 4BFFFC05  bl 0x82a4bbf8
	ctx.lr = 0x82A4BFF8;
	sub_82A4BBF8(ctx, base);
	// 82A4BFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4BFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4C000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4C004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4C008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4C010 size=284
    let mut pc: u32 = 0x82A4C010;
    'dispatch: loop {
        match pc {
            0x82A4C010 => {
    //   block [0x82A4C010..0x82A4C12C)
	// 82A4C010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C014: 4875C159  bl 0x831a816c
	ctx.lr = 0x82A4C018;
	sub_831A8130(ctx, base);
	// 82A4C018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C01C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4C020: 487085E1  bl 0x83154600
	ctx.lr = 0x82A4C024;
	sub_83154600(ctx, base);
	// 82A4C024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4C028: 897E054C  lbz r11, 0x54c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A4C02C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82A4C030: 41990010  bgt cr6, 0x82a4c040
	if ctx.cr[6].gt {
	pc = 0x82A4C040; continue 'dispatch;
	}
	// 82A4C034: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4C038: C00B967C  lfs f0, -0x6984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4C03C: 4800000C  b 0x82a4c048
	pc = 0x82A4C048; continue 'dispatch;
	// 82A4C040: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4C044: C00B08AC  lfs f0, 0x8ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4C048: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4C04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C050: 4BFFA931  bl 0x82a46980
	ctx.lr = 0x82A4C054;
	sub_82A46980(ctx, base);
	// 82A4C054: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4C058: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A4C05C: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A4C060: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A4C064: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82A4C068: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A4C06C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4C070: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4C074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4C130 size=196
    let mut pc: u32 = 0x82A4C130;
    'dispatch: loop {
        match pc {
            0x82A4C130 => {
    //   block [0x82A4C130..0x82A4C1F4)
	// 82A4C130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4C138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4C13C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4C140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4C148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4C14C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4C150: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4C154: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4C158: 4B8747E1  bl 0x822c0938
	ctx.lr = 0x82A4C15C;
	sub_822C0938(ctx, base);
	// 82A4C15C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4C160: 41820028  beq 0x82a4c188
	if ctx.cr[0].eq {
	pc = 0x82A4C188; continue 'dispatch;
	}
	// 82A4C164: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4C168: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4C16C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4C170: 392BD324  addi r9, r11, -0x2cdc
	ctx.r[9].s64 = ctx.r[11].s64 + -11484;
	// 82A4C174: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4C178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4C17C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4C180: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4C184: 48000008  b 0x82a4c18c
	pc = 0x82A4C18C; continue 'dispatch;
	// 82A4C188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4C18C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4C190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4C194: 409A0044  bne cr6, 0x82a4c1d8
	if !ctx.cr[6].eq {
	pc = 0x82A4C1D8; continue 'dispatch;
	}
	// 82A4C198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4C19C: 419A001C  beq cr6, 0x82a4c1b8
	if ctx.cr[6].eq {
	pc = 0x82A4C1B8; continue 'dispatch;
	}
	// 82A4C1A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4C1A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4C1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C1AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4C1B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4C1B4: 4E800421  bctrl
	ctx.lr = 0x82A4C1B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4C1B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4C1BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4C1C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C1C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4C1C8: 816B4124  lwz r11, 0x4124(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16676 as u32) ) } as u64;
	// 82A4C1CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4C1D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4C1D4: 4B873E2D  bl 0x822c0000
	ctx.lr = 0x82A4C1D8;
	sub_822C0000(ctx, base);
	// 82A4C1D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4C1DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4C1E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4C1E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4C1E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4C1EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4C1F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4C1F8 size=160
    let mut pc: u32 = 0x82A4C1F8;
    'dispatch: loop {
        match pc {
            0x82A4C1F8 => {
    //   block [0x82A4C1F8..0x82A4C298)
	// 82A4C1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C1FC: 4875BF71  bl 0x831a816c
	ctx.lr = 0x82A4C200;
	sub_831A8130(ctx, base);
	// 82A4C200: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4C204: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C208: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A4C20C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4C210: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A4C214: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A4C218: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A4C21C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A4C220: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 82A4C224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4C228: 4BAC6039  bl 0x82512260
	ctx.lr = 0x82A4C22C;
	sub_82512260(ctx, base);
	// 82A4C22C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4C230: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A4C234: 392BD34C  addi r9, r11, -0x2cb4
	ctx.r[9].s64 = ctx.r[11].s64 + -11444;
	// 82A4C238: 394AD338  addi r10, r10, -0x2cc8
	ctx.r[10].s64 = ctx.r[10].s64 + -11464;
	// 82A4C23C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4C240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4C244: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82A4C248: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A4C24C: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82A4C250: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A4C254: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A4C258: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A4C25C: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 82A4C260: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4C264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4C298 size=396
    let mut pc: u32 = 0x82A4C298;
    'dispatch: loop {
        match pc {
            0x82A4C298 => {
    //   block [0x82A4C298..0x82A4C424)
	// 82A4C298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C29C: 4875BED1  bl 0x831a816c
	ctx.lr = 0x82A4C2A0;
	sub_831A8130(ctx, base);
	// 82A4C2A0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A4C2A4: 4875C7D5  bl 0x831a8a78
	ctx.lr = 0x82A4C2A8;
	sub_831A8A40(ctx, base);
	// 82A4C2A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C2AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4C2B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A4C2B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4C2B8: C1BF0110  lfs f13, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4C2BC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4C2C0: EFC0682A  fadds f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4C2C4: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A4C2C8: D3DF0110  stfs f30, 0x110(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A4C2CC: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82A4C2D0: 41980008  blt cr6, 0x82a4c2d8
	if ctx.cr[6].lt {
	pc = 0x82A4C2D8; continue 'dispatch;
	}
	// 82A4C2D4: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	// 82A4C2D8: 38BF0100  addi r5, r31, 0x100
	ctx.r[5].s64 = ctx.r[31].s64 + 256;
	// 82A4C2DC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4C2E0: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 82A4C2E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A4C2E8: 48431359  bl 0x82e7d640
	ctx.lr = 0x82A4C2EC;
	sub_82E7D640(ctx, base);
	// 82A4C2EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4C2F0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A4C2F4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A4C2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C2FC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4C428 size=332
    let mut pc: u32 = 0x82A4C428;
    'dispatch: loop {
        match pc {
            0x82A4C428 => {
    //   block [0x82A4C428..0x82A4C574)
	// 82A4C428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C42C: 4875BD41  bl 0x831a816c
	ctx.lr = 0x82A4C430;
	sub_831A8130(ctx, base);
	// 82A4C430: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4C434: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4C43C: 487081C5  bl 0x83154600
	ctx.lr = 0x82A4C440;
	sub_83154600(ctx, base);
	// 82A4C440: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4C444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C448: 4BFFA571  bl 0x82a469b8
	ctx.lr = 0x82A4C44C;
	sub_82A469B8(ctx, base);
	// 82A4C44C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4C450: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A4C454: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4C458: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A4C45C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4C460: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A4C464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4C468: C00B08AC  lfs f0, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4C46C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4C470: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4C474: 4BFEC12D  bl 0x82a385a0
	ctx.lr = 0x82A4C478;
	sub_82A385A0(ctx, base);
	// 82A4C478: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4C47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C480: 388BC598  addi r4, r11, -0x3a68
	ctx.r[4].s64 = ctx.r[11].s64 + -14952;
	// 82A4C484: 483A7585  bl 0x82df3a08
	ctx.lr = 0x82A4C488;
	sub_82DF3A08(ctx, base);
	// 82A4C488: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4C48C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4C490: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4C494: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4C498: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4C49C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4C4A0: 48166ED9  bl 0x82bb3378
	ctx.lr = 0x82A4C4A4;
	sub_82BB3378(ctx, base);
	// 82A4C4A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4C4A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4C4AC: 419A0008  beq cr6, 0x82a4c4b4
	if ctx.cr[6].eq {
	pc = 0x82A4C4B4; continue 'dispatch;
	}
	// 82A4C4B0: 4B8743E1  bl 0x822c0890
	ctx.lr = 0x82A4C4B4;
	sub_822C0890(ctx, base);
	// 82A4C4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C4B8: 483A6F71  bl 0x82df3428
	ctx.lr = 0x82A4C4BC;
	sub_82DF3428(ctx, base);
	// 82A4C4BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4C4C0: 39400610  li r10, 0x610
	ctx.r[10].s64 = 1552;
	// 82A4C4C4: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A4C4C8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4C4CC: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82A4C4D0: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A4C4D4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82A4C4D8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4C4DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4C578 size=760
    let mut pc: u32 = 0x82A4C578;
    'dispatch: loop {
        match pc {
            0x82A4C578 => {
    //   block [0x82A4C578..0x82A4C870)
	// 82A4C578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C57C: 4875BBDD  bl 0x831a8158
	ctx.lr = 0x82A4C580;
	sub_831A8130(ctx, base);
	// 82A4C580: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82A4C584: 4875C4F1  bl 0x831a8a74
	ctx.lr = 0x82A4C588;
	sub_831A8A40(ctx, base);
	// 82A4C588: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4C870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4C870 size=652
    let mut pc: u32 = 0x82A4C870;
    'dispatch: loop {
        match pc {
            0x82A4C870 => {
    //   block [0x82A4C870..0x82A4CAFC)
	// 82A4C870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4C874: 4875B8F5  bl 0x831a8168
	ctx.lr = 0x82A4C878;
	sub_831A8130(ctx, base);
	// 82A4C878: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4C87C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4C880: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A4C884: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A4C888: 4BAC5151  bl 0x825119d8
	ctx.lr = 0x82A4C88C;
	sub_825119D8(ctx, base);
	// 82A4C88C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A4C890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C894: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A4C898: 483A7171  bl 0x82df3a08
	ctx.lr = 0x82A4C89C;
	sub_82DF3A08(ctx, base);
	// 82A4C89C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A4C8A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4C8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C8A8: 4BABBED9  bl 0x82508780
	ctx.lr = 0x82A4C8AC;
	sub_82508780(ctx, base);
	// 82A4C8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C8B0: 483A6B79  bl 0x82df3428
	ctx.lr = 0x82A4C8B4;
	sub_82DF3428(ctx, base);
	// 82A4C8B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4C8B8: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 82A4C8BC: 409A0008  bne cr6, 0x82a4c8c4
	if !ctx.cr[6].eq {
	pc = 0x82A4C8C4; continue 'dispatch;
	}
	// 82A4C8C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4C8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C8C8: 4BABBED9  bl 0x825087a0
	ctx.lr = 0x82A4C8CC;
	sub_825087A0(ctx, base);
	// 82A4C8CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4C8D0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4C8D4: 483DE215  bl 0x82e2aae8
	ctx.lr = 0x82A4C8D8;
	sub_82E2AAE8(ctx, base);
	// 82A4C8D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4C8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C8E0: 388B08C0  addi r4, r11, 0x8c0
	ctx.r[4].s64 = ctx.r[11].s64 + 2240;
	// 82A4C8E4: 483A7125  bl 0x82df3a08
	ctx.lr = 0x82A4C8E8;
	sub_82DF3A08(ctx, base);
	// 82A4C8E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4C8EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4C8F0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A4C8F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4C8F8: 483E2579  bl 0x82e2ee70
	ctx.lr = 0x82A4C8FC;
	sub_82E2EE70(ctx, base);
	// 82A4C8FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4C900: 483A6B29  bl 0x82df3428
	ctx.lr = 0x82A4C904;
	sub_82DF3428(ctx, base);
	// 82A4C904: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4C908: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4C90C: 3BEBD3A8  addi r31, r11, -0x2c58
	ctx.r[31].s64 = ctx.r[11].s64 + -11352;
	// 82A4C910: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 82A4C914: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4C918: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A4C91C: 483A5ACD  bl 0x82df23e8
	ctx.lr = 0x82A4C920;
	sub_82DF23E8(ctx, base);
	// 82A4C920: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4C924: 41820014  beq 0x82a4c938
	if ctx.cr[0].eq {
	pc = 0x82A4C938; continue 'dispatch;
	}
	// 82A4C928: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A4C92C: 483C9F65  bl 0x82e16890
	ctx.lr = 0x82A4C930;
	sub_82E16890(ctx, base);
	// 82A4C930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4C934: 48000008  b 0x82a4c93c
	pc = 0x82A4C93C; continue 'dispatch;
	// 82A4C938: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4C93C: 3BBE00E4  addi r29, r30, 0xe4
	ctx.r[29].s64 = ctx.r[30].s64 + 228;
	// 82A4C940: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4C944: 4B910A2D  bl 0x8235d370
	ctx.lr = 0x82A4C948;
	sub_8235D370(ctx, base);
	// 82A4C948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4C94C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4C950: 38A000A8  li r5, 0xa8
	ctx.r[5].s64 = 168;
	// 82A4C954: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A4C958: 483A5A91  bl 0x82df23e8
	ctx.lr = 0x82A4C95C;
	sub_82DF23E8(ctx, base);
	// 82A4C95C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A4C960: 41820030  beq 0x82a4c990
	if ctx.cr[0].eq {
	pc = 0x82A4C990; continue 'dispatch;
	}
	// 82A4C964: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4C968: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A4C96C: C06BFD2C  lfs f3, -0x2d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-724 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A4C970: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 82A4C974: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82A4C978: 4842F5F9  bl 0x82e7bf70
	ctx.lr = 0x82A4C97C;
	sub_82E7BF70(ctx, base);
	// 82A4C97C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4C980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4C984: 483C676D  bl 0x82e130f0
	ctx.lr = 0x82A4C988;
	sub_82E130F0(ctx, base);
	// 82A4C988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4C98C: 48000008  b 0x82a4c994
	pc = 0x82A4C994; continue 'dispatch;
	// 82A4C990: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4C994: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A4C998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4C99C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4C9A0: 4B894679  bl 0x822e1018
	ctx.lr = 0x82A4C9A4;
	sub_822E1018(ctx, base);
	// 82A4C9A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A4C9A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4C9AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4C9B0: 4B873651  bl 0x822c0000
	ctx.lr = 0x82A4C9B4;
	sub_822C0000(ctx, base);
	// 82A4C9B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A4C9B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4C9BC: 4BAC575D  bl 0x82512118
	ctx.lr = 0x82A4C9C0;
	sub_82512118(ctx, base);
	// 82A4C9C0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4C9C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4C9C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A4C9CC: 483C6465  bl 0x82e12e30
	ctx.lr = 0x82A4C9D0;
	sub_82E12E30(ctx, base);
	// 82A4C9D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A4C9D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4C9D8: 419A0008  beq cr6, 0x82a4c9e0
	if ctx.cr[6].eq {
	pc = 0x82A4C9E0; continue 'dispatch;
	}
	// 82A4C9DC: 4B873EB5  bl 0x822c0890
	ctx.lr = 0x82A4C9E0;
	sub_822C0890(ctx, base);
	// 82A4C9E0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4C9E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A4C9E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4C9EC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A4C9F0: 419A0024  beq cr6, 0x82a4ca14
	if ctx.cr[6].eq {
	pc = 0x82A4CA14; continue 'dispatch;
	}
	// 82A4C9F4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A4C9F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4C9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4CA00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4CA04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4CA08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4CA0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4CA10: 4082FFE8  bne 0x82a4c9f8
	if !ctx.cr[0].eq {
	pc = 0x82A4C9F8; continue 'dispatch;
	}
	// 82A4CA14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4CA18: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4CA1C: 483C8695  bl 0x82e150b0
	ctx.lr = 0x82A4CA20;
	sub_82E150B0(ctx, base);
	// 82A4CA20: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A4CA24: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A4CA28: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A4CA2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4CA30: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A4CA34: 4BAC4125  bl 0x82510b58
	ctx.lr = 0x82A4CA38;
	sub_82510B58(ctx, base);
	// 82A4CA38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4CA3C: 419A000C  beq cr6, 0x82a4ca48
	if ctx.cr[6].eq {
	pc = 0x82A4CA48; continue 'dispatch;
	}
	// 82A4CA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CA44: 4B873E4D  bl 0x822c0890
	ctx.lr = 0x82A4CA48;
	sub_822C0890(ctx, base);
	// 82A4CA48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4CA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4CA50: 419A0008  beq cr6, 0x82a4ca58
	if ctx.cr[6].eq {
	pc = 0x82A4CA58; continue 'dispatch;
	}
	// 82A4CA54: 4B873E3D  bl 0x822c0890
	ctx.lr = 0x82A4CA58;
	sub_822C0890(ctx, base);
	// 82A4CA58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4CA5C: 483DE0A5  bl 0x82e2ab00
	ctx.lr = 0x82A4CA60;
	sub_82E2AB00(ctx, base);
	// 82A4CA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4CA64: 4BAC6035  bl 0x82512a98
	ctx.lr = 0x82A4CA68;
	sub_82512A98(ctx, base);
	// 82A4CA68: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4CA6C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A4CA70: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A4CA74: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A4CA78: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A4CA7C: 48453CB5  bl 0x82ea0730
	ctx.lr = 0x82A4CA80;
	sub_82EA0730(ctx, base);
	// 82A4CA80: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82A4CA84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4CA88: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82A4CA8C: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4CA90: 484CD761  bl 0x82f1a1f0
	ctx.lr = 0x82A4CA94;
	sub_82F1A1F0(ctx, base);
	// 82A4CA94: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A4CA98: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A4CA9C: 4182000C  beq 0x82a4caa8
	if ctx.cr[0].eq {
	pc = 0x82A4CAA8; continue 'dispatch;
	}
	// 82A4CAA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CAA4: 4B89B7A5  bl 0x822e8248
	ctx.lr = 0x82A4CAA8;
	sub_822E8248(ctx, base);
	// 82A4CAA8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A4CAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4CAB0: 388B6064  addi r4, r11, 0x6064
	ctx.r[4].s64 = ctx.r[11].s64 + 24676;
	// 82A4CAB4: 483ACA7D  bl 0x82df9530
	ctx.lr = 0x82A4CAB8;
	sub_82DF9530(ctx, base);
	// 82A4CAB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A4CABC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A4CAC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A4CAC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4CAC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4CACC: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 82A4CAD0: 4BAC6619  bl 0x825130e8
	ctx.lr = 0x82A4CAD4;
	sub_825130E8(ctx, base);
	// 82A4CAD4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A4CAD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4CADC: 419A0008  beq cr6, 0x82a4cae4
	if ctx.cr[6].eq {
	pc = 0x82A4CAE4; continue 'dispatch;
	}
	// 82A4CAE0: 4B89B789  bl 0x822e8268
	ctx.lr = 0x82A4CAE4;
	sub_822E8268(ctx, base);
	// 82A4CAE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4CAE8: 419A000C  beq cr6, 0x82a4caf4
	if ctx.cr[6].eq {
	pc = 0x82A4CAF4; continue 'dispatch;
	}
	// 82A4CAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CAF0: 4B89B779  bl 0x822e8268
	ctx.lr = 0x82A4CAF4;
	sub_822E8268(ctx, base);
	// 82A4CAF4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A4CAF8: 4875B6C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4CB00 size=240
    let mut pc: u32 = 0x82A4CB00;
    'dispatch: loop {
        match pc {
            0x82A4CB00 => {
    //   block [0x82A4CB00..0x82A4CBF0)
	// 82A4CB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CB04: 4875B669  bl 0x831a816c
	ctx.lr = 0x82A4CB08;
	sub_831A8130(ctx, base);
	// 82A4CB08: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4CB0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CB10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4CB14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4CB18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A4CB1C: C01F0118  lfs f0, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CB20: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4CB24: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4CB28: 409900BC  ble cr6, 0x82a4cbe4
	if !ctx.cr[6].gt {
	pc = 0x82A4CBE4; continue 'dispatch;
	}
	// 82A4CB2C: D3FF0118  stfs f31, 0x118(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82A4CB30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4CB34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A4CB38: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82A4CB3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4CB40: 4BAC4FA9  bl 0x82511ae8
	ctx.lr = 0x82A4CB44;
	sub_82511AE8(ctx, base);
	// 82A4CB44: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A4CB48: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4CB4C: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 82A4CB50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4CB54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4CB58: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A4CB5C: 4B9CA865  bl 0x824173c0
	ctx.lr = 0x82A4CB60;
	sub_824173C0(ctx, base);
	// 82A4CB60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4CB64: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A4CB68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A4CB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4CB70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A4CB74: 419A0024  beq cr6, 0x82a4cb98
	if ctx.cr[6].eq {
	pc = 0x82A4CB98; continue 'dispatch;
	}
	// 82A4CB78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A4CB7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4CB80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4CB84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4CB88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4CB8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4CB90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4CB94: 4082FFE8  bne 0x82a4cb7c
	if !ctx.cr[0].eq {
	pc = 0x82A4CB7C; continue 'dispatch;
	}
	// 82A4CB98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4CB9C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A4CBA0: 485BB589  bl 0x83008128
	ctx.lr = 0x82A4CBA4;
	sub_83008128(ctx, base);
	// 82A4CBA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4CBA8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4CBAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4CBB0: 388BD3A8  addi r4, r11, -0x2c58
	ctx.r[4].s64 = ctx.r[11].s64 + -11352;
	// 82A4CBB4: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A4CBB8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A4CBBC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A4CBC0: 4840BE81  bl 0x82e58a40
	ctx.lr = 0x82A4CBC4;
	sub_82E58A40(ctx, base);
	// 82A4CBC4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4CBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4CBCC: 419A0008  beq cr6, 0x82a4cbd4
	if ctx.cr[6].eq {
	pc = 0x82A4CBD4; continue 'dispatch;
	}
	// 82A4CBD0: 4B873CC1  bl 0x822c0890
	ctx.lr = 0x82A4CBD4;
	sub_822C0890(ctx, base);
	// 82A4CBD4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4CBD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4CBDC: 419A0008  beq cr6, 0x82a4cbe4
	if ctx.cr[6].eq {
	pc = 0x82A4CBE4; continue 'dispatch;
	}
	// 82A4CBE0: 4B873CB1  bl 0x822c0890
	ctx.lr = 0x82A4CBE4;
	sub_822C0890(ctx, base);
	// 82A4CBE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4CBE8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4CBEC: 4875B5D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4CBF0 size=52
    let mut pc: u32 = 0x82A4CBF0;
    'dispatch: loop {
        match pc {
            0x82A4CBF0 => {
    //   block [0x82A4CBF0..0x82A4CC24)
	// 82A4CBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4CBF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4CBFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CC00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4CC04: 4BFFF40D  bl 0x82a4c010
	ctx.lr = 0x82A4CC08;
	sub_82A4C010(ctx, base);
	// 82A4CC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CC0C: 4BFFF96D  bl 0x82a4c578
	ctx.lr = 0x82A4CC10;
	sub_82A4C578(ctx, base);
	// 82A4CC10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4CC14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4CC18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4CC1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4CC20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4CC28 size=164
    let mut pc: u32 = 0x82A4CC28;
    'dispatch: loop {
        match pc {
            0x82A4CC28 => {
    //   block [0x82A4CC28..0x82A4CCCC)
	// 82A4CC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CC2C: 4875B53D  bl 0x831a8168
	ctx.lr = 0x82A4CC30;
	sub_831A8130(ctx, base);
	// 82A4CC30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CC34: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A4CC38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4CC3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4CC40: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A4CC44: 41820038  beq 0x82a4cc7c
	if ctx.cr[0].eq {
	pc = 0x82A4CC7C; continue 'dispatch;
	}
	// 82A4CC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CC4C: 4875CD3D  bl 0x831a9988
	ctx.lr = 0x82A4CC50;
	sub_831A9988(ctx, base);
	// 82A4CC50: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A4CC54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4CC58: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A4CC5C: 4875B49D  bl 0x831a80f8
	ctx.lr = 0x82A4CC60;
	sub_831A80F8(ctx, base);
	// 82A4CC60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4CC64: 41820018  beq 0x82a4cc7c
	if ctx.cr[0].eq {
	pc = 0x82A4CC7C; continue 'dispatch;
	}
	// 82A4CC68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4CC6C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A4CC70: 4BFFFE91  bl 0x82a4cb00
	ctx.lr = 0x82A4CC74;
	sub_82A4CB00(ctx, base);
	// 82A4CC74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A4CC78: 4800004C  b 0x82a4ccc4
	pc = 0x82A4CCC4; continue 'dispatch;
	// 82A4CC7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A4CC80: 419A0034  beq cr6, 0x82a4ccb4
	if ctx.cr[6].eq {
	pc = 0x82A4CCB4; continue 'dispatch;
	}
	// 82A4CC84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CC88: 4875CD01  bl 0x831a9988
	ctx.lr = 0x82A4CC8C;
	sub_831A9988(ctx, base);
	// 82A4CC8C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A4CC90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4CC94: 386B67A0  addi r3, r11, 0x67a0
	ctx.r[3].s64 = ctx.r[11].s64 + 26528;
	// 82A4CC98: 4875B461  bl 0x831a80f8
	ctx.lr = 0x82A4CC9C;
	sub_831A80F8(ctx, base);
	// 82A4CC9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4CCA0: 41820014  beq 0x82a4ccb4
	if ctx.cr[0].eq {
	pc = 0x82A4CCB4; continue 'dispatch;
	}
	// 82A4CCA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4CCA8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A4CCAC: 480BFAF5  bl 0x82b0c7a0
	ctx.lr = 0x82A4CCB0;
	sub_82B0C7A0(ctx, base);
	// 82A4CCB0: 4BFFFFC4  b 0x82a4cc74
	pc = 0x82A4CC74; continue 'dispatch;
	// 82A4CCB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A4CCB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4CCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4CCC0: 4BAC5959  bl 0x82512618
	ctx.lr = 0x82A4CCC4;
	sub_82512618(ctx, base);
	// 82A4CCC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4CCC8: 4875B4F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4CCD0 size=108
    let mut pc: u32 = 0x82A4CCD0;
    'dispatch: loop {
        match pc {
            0x82A4CCD0 => {
    //   block [0x82A4CCD0..0x82A4CD3C)
	// 82A4CCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4CCD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4CCDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4CCE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4CCE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A4CCEC: 4BFE51CD  bl 0x82a31eb8
	ctx.lr = 0x82A4CCF0;
	sub_82A31EB8(ctx, base);
	// 82A4CCF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4CCF4: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A4CCF8: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A4CCFC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4CD00: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82A4CD04: 3929D480  addi r9, r9, -0x2b80
	ctx.r[9].s64 = ctx.r[9].s64 + -11136;
	// 82A4CD08: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CD0C: 991F001C  stb r8, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	// 82A4CD10: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4CD14: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4CD18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CD1C: C00A4194  lfs f0, 0x4194(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CD20: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4CD24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4CD28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4CD2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4CD30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4CD34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4CD38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CD40 size=36
    let mut pc: u32 = 0x82A4CD40;
    'dispatch: loop {
        match pc {
            0x82A4CD40 => {
    //   block [0x82A4CD40..0x82A4CD64)
	// 82A4CD40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CD44: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CD48: C00B41BC  lfs f0, 0x41bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CD4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A4CD50: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4CD54: 40980008  bge cr6, 0x82a4cd5c
	if !ctx.cr[6].lt {
	pc = 0x82A4CD5C; continue 'dispatch;
	}
	// 82A4CD58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4CD5C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A4CD60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CD68 size=92
    let mut pc: u32 = 0x82A4CD68;
    'dispatch: loop {
        match pc {
            0x82A4CD68 => {
    //   block [0x82A4CD68..0x82A4CDC4)
	// 82A4CD68: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4CD6C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4CD70: 419800C4  blt cr6, 0x82a4ce34
	if ctx.cr[6].lt {
		sub_82A4CE34(ctx, base);
		return;
	}
	// 82A4CD74: 419A0068  beq cr6, 0x82a4cddc
	if ctx.cr[6].eq {
		sub_82A4CDDC(ctx, base);
		return;
	}
	// 82A4CD78: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4CD7C: 409800C8  bge cr6, 0x82a4ce44
	if !ctx.cr[6].lt {
		sub_82A4CE34(ctx, base);
		return;
	}
	// 82A4CD80: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4CD84: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4CD88: 4198003C  blt cr6, 0x82a4cdc4
	if ctx.cr[6].lt {
		sub_82A4CDC4(ctx, base);
		return;
	}
	// 82A4CD8C: 409A00B8  bne cr6, 0x82a4ce44
	if !ctx.cr[6].eq {
		sub_82A4CE34(ctx, base);
		return;
	}
	// 82A4CD90: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CD94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4CD98: 392B41B0  addi r9, r11, 0x41b0
	ctx.r[9].s64 = ctx.r[11].s64 + 16816;
	// 82A4CD9C: C00B41B0  lfs f0, 0x41b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16816 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CDA0: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4CDA4: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4CDA8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CDAC: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CDB0: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4CDB4: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4CDB8: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4CDBC: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4CDC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CDC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CDC4 size=24
    let mut pc: u32 = 0x82A4CDC4;
    'dispatch: loop {
        match pc {
            0x82A4CDC4 => {
    //   block [0x82A4CDC4..0x82A4CDDC)
	// 82A4CDC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CDC8: 392B41B0  addi r9, r11, 0x41b0
	ctx.r[9].s64 = ctx.r[11].s64 + 16816;
	// 82A4CDCC: C00B41B0  lfs f0, 0x41b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16816 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CDD0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CDD4: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4CDD8: 480000B8  b 0x82a4ce90
	sub_82A4CE7C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CDDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CDDC size=64
    let mut pc: u32 = 0x82A4CDDC;
    'dispatch: loop {
        match pc {
            0x82A4CDDC => {
    //   block [0x82A4CDDC..0x82A4CE1C)
	// 82A4CDDC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4CDE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4CDE4: 41980038  blt cr6, 0x82a4ce1c
	if ctx.cr[6].lt {
		sub_82A4CE1C(ctx, base);
		return;
	}
	// 82A4CDE8: 409A005C  bne cr6, 0x82a4ce44
	if !ctx.cr[6].eq {
		sub_82A4CE34(ctx, base);
		return;
	}
	// 82A4CDEC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CDF0: 396B41B0  addi r11, r11, 0x41b0
	ctx.r[11].s64 = ctx.r[11].s64 + 16816;
	// 82A4CDF4: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CDF8: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4CDFC: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CE00: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4CE08: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4CE0C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4CE10: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4CE14: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4CE18: 4800008C  b 0x82a4cea4
	sub_82A4CE7C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CE1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CE1C size=24
    let mut pc: u32 = 0x82A4CE1C;
    'dispatch: loop {
        match pc {
            0x82A4CE1C => {
    //   block [0x82A4CE1C..0x82A4CE34)
	// 82A4CE1C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CE20: 396B41B0  addi r11, r11, 0x41b0
	ctx.r[11].s64 = ctx.r[11].s64 + 16816;
	// 82A4CE24: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE28: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CE2C: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4CE30: 48000060  b 0x82a4ce90
	sub_82A4CE7C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CE34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CE34 size=44
    let mut pc: u32 = 0x82A4CE34;
    'dispatch: loop {
        match pc {
            0x82A4CE34 => {
    //   block [0x82A4CE34..0x82A4CE60)
	// 82A4CE34: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4CE38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4CE3C: 41980040  blt cr6, 0x82a4ce7c
	if ctx.cr[6].lt {
		sub_82A4CE7C(ctx, base);
		return;
	}
	// 82A4CE40: 419A0020  beq cr6, 0x82a4ce60
	if ctx.cr[6].eq {
		sub_82A4CE60(ctx, base);
		return;
	}
	// 82A4CE44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4CE48: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE4C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4CE50: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4CE54: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4CE58: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4CE5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CE60 size=28
    let mut pc: u32 = 0x82A4CE60;
    'dispatch: loop {
        match pc {
            0x82A4CE60 => {
    //   block [0x82A4CE60..0x82A4CE7C)
	// 82A4CE60: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CE64: 396B41B0  addi r11, r11, 0x41b0
	ctx.r[11].s64 = ctx.r[11].s64 + 16816;
	// 82A4CE68: C00BFFE8  lfs f0, -0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE6C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4CE70: C1ABFFEC  lfs f13, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CE74: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE78: 4BFFFF8C  b 0x82a4ce04
	sub_82A4CDDC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CE7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4CE7C size=48
    let mut pc: u32 = 0x82A4CE7C;
    'dispatch: loop {
        match pc {
            0x82A4CE7C => {
    //   block [0x82A4CE7C..0x82A4CEAC)
	// 82A4CE7C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4CE80: 396B41B0  addi r11, r11, 0x41b0
	ctx.r[11].s64 = ctx.r[11].s64 + 16816;
	// 82A4CE84: C00BFFE8  lfs f0, -0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CE88: C1ABFFEC  lfs f13, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4CE8C: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4CE90: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4CE94: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4CE98: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4CE9C: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4CEA0: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4CEA4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4CEA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4CEB0 size=96
    let mut pc: u32 = 0x82A4CEB0;
    'dispatch: loop {
        match pc {
            0x82A4CEB0 => {
    //   block [0x82A4CEB0..0x82A4CF10)
	// 82A4CEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CEB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4CEB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4CEBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4CEC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CEC4: 4870773D  bl 0x83154600
	ctx.lr = 0x82A4CEC8;
	sub_83154600(ctx, base);
	// 82A4CEC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4CECC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4CED0: 997F05BD  stb r11, 0x5bd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1469 as u32), ctx.r[11].u8 ) };
	// 82A4CED4: 4BFE53AD  bl 0x82a32280
	ctx.lr = 0x82A4CED8;
	sub_82A32280(ctx, base);
	// 82A4CED8: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 82A4CEDC: 3BE00048  li r31, 0x48
	ctx.r[31].s64 = 72;
	// 82A4CEE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4CEE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4CEE8: 48434859  bl 0x82e81740
	ctx.lr = 0x82A4CEEC;
	sub_82E81740(ctx, base);
	// 82A4CEEC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A4CEF0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A4CEF4: 4082FFEC  bne 0x82a4cee0
	if !ctx.cr[0].eq {
	pc = 0x82A4CEE0; continue 'dispatch;
	}
	// 82A4CEF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4CEFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4CF00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4CF04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4CF08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4CF0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4CF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4CF10 size=568
    //   switch @ 0x82A4D030: r11 with 11 label(s)
    //       case  0  0x82A4D040
    //       case  1  0x82A4D040
    //       case  2  0x82A4D04C
    //       case  3  0x82A4D070
    //       case  4  0x82A4D070
    //       case  5  0x82A4D070
    //       case  6  0x82A4D078
    //       case  7  0x82A4D0E0
    //       case  8  0x82A4D070
    //       case  9  0x82A4D070
    //       case 10  0x82A4D100
    let mut pc: u32 = 0x82A4CF10;
    'dispatch: loop {
        match pc {
            0x82A4CF10 => {
    //   block [0x82A4CF10..0x82A4D040)
	// 82A4CF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4CF14: 4875B255  bl 0x831a8168
	ctx.lr = 0x82A4CF18;
	sub_831A8130(ctx, base);
	// 82A4CF18: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A4CF1C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A4CF20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4CF24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4CF28: 487076D9  bl 0x83154600
	ctx.lr = 0x82A4CF2C;
	sub_83154600(ctx, base);
	// 82A4CF2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4CF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CF34: 897E05F4  lbz r11, 0x5f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82A4CF38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4CF3C: 4182001C  beq 0x82a4cf58
	if ctx.cr[0].eq {
	pc = 0x82A4CF58; continue 'dispatch;
	}
	// 82A4CF40: 4840C839  bl 0x82e59778
	ctx.lr = 0x82A4CF44;
	sub_82E59778(ctx, base);
	// 82A4CF44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4CF48: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A4CF4C: C3CBD72C  lfs f30, -0x28d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4CF50: C3EA6970  lfs f31, 0x6970(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26992 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4CF54: 48000024  b 0x82a4cf78
	pc = 0x82A4CF78; continue 'dispatch;
	// 82A4CF58: 897E05F5  lbz r11, 0x5f5(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1525 as u32) ) } as u64;
	// 82A4CF5C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4CF60: 41820054  beq 0x82a4cfb4
	if ctx.cr[0].eq {
	pc = 0x82A4CFB4; continue 'dispatch;
	}
	// 82A4CF64: 4840C815  bl 0x82e59778
	ctx.lr = 0x82A4CF68;
	sub_82E59778(ctx, base);
	// 82A4CF68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4CF6C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4CF70: C3CB95F4  lfs f30, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4CF74: C3EAD0B0  lfs f31, -0x2f50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4CF78: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CF7C: EC0107BC  fnmsubs f0, f1, f30, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4CF80: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4CF84: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4CF88: 40980008  bge cr6, 0x82a4cf90
	if !ctx.cr[6].lt {
	pc = 0x82A4CF90; continue 'dispatch;
	}
	// 82A4CF8C: D3FF018C  stfs f31, 0x18c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4CF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CF94: 4840C7E5  bl 0x82e59778
	ctx.lr = 0x82A4CF98;
	sub_82E59778(ctx, base);
	// 82A4CF98: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CF9C: EC0107BC  fnmsubs f0, f1, f30, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4CFA0: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4CFA4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4CFA8: 40980060  bge cr6, 0x82a4d008
	if !ctx.cr[6].lt {
	pc = 0x82A4D008; continue 'dispatch;
	}
	// 82A4CFAC: D3FF0190  stfs f31, 0x190(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4CFB0: 48000058  b 0x82a4d008
	pc = 0x82A4D008; continue 'dispatch;
	// 82A4CFB4: 4840C7C5  bl 0x82e59778
	ctx.lr = 0x82A4CFB8;
	sub_82E59778(ctx, base);
	// 82A4CFB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4CFBC: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CFC0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4CFC4: C3EB959C  lfs f31, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4CFC8: EDA107FA  fmadds f13, f1, f31, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4CFCC: C00A9D1C  lfs f0, -0x62e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CFD0: D1BF018C  stfs f13, 0x18c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4CFD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4CFD8: 40990008  ble cr6, 0x82a4cfe0
	if !ctx.cr[6].gt {
	pc = 0x82A4CFE0; continue 'dispatch;
	}
	// 82A4CFDC: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4CFE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4CFE4: 4840C795  bl 0x82e59778
	ctx.lr = 0x82A4CFE8;
	sub_82E59778(ctx, base);
	// 82A4CFE8: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CFEC: EDA107FA  fmadds f13, f1, f31, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4CFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A4CFF4: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4CFF8: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4CFFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4D000: 40990008  ble cr6, 0x82a4d008
	if !ctx.cr[6].gt {
	pc = 0x82A4D008; continue 'dispatch;
	}
	// 82A4D004: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4D008: 897F0189  lbz r11, 0x189(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(393 as u32) ) } as u64;
	// 82A4D00C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4D010: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82A4D014: 41990124  bgt cr6, 0x82a4d138
	if ctx.cr[6].gt {
	pc = 0x82A4D138; continue 'dispatch;
	}
	// 82A4D018: 3D80820B  lis r12, -0x7df5
	ctx.r[12].s64 = -2113208320;
	// 82A4D01C: 398CD460  addi r12, r12, -0x2ba0
	ctx.r[12].s64 = ctx.r[12].s64 + -11168;
	// 82A4D020: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A4D024: 3D8082A5  lis r12, -0x7d5b
	ctx.r[12].s64 = -2103115776;
	// 82A4D028: 398CD040  addi r12, r12, -0x2fc0
	ctx.r[12].s64 = ctx.r[12].s64 + -12224;
	// 82A4D02C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82A4D030: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82A4D034: 60000000  nop
	// 82A4D038: 60000000  nop
	// 82A4D03C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            0x82A4D040 => {
    //   block [0x82A4D040..0x82A4D04C)
	// 82A4D040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D044: 480014DD  bl 0x82a4e520
	ctx.lr = 0x82A4D048;
	sub_82A4E520(ctx, base);
	// 82A4D048: 480000F0  b 0x82a4d138
	pc = 0x82A4D138; continue 'dispatch;
            }
            0x82A4D04C => {
    //   block [0x82A4D04C..0x82A4D070)
	// 82A4D04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D050: 4840C711  bl 0x82e59760
	ctx.lr = 0x82A4D054;
	sub_82E59760(ctx, base);
	// 82A4D054: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4D058: C1BF018C  lfs f13, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4D05C: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4D060: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D064: ED610032  fmuls f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4D068: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82A4D06C: 480000B8  b 0x82a4d124
	pc = 0x82A4D124; continue 'dispatch;
            }
            0x82A4D070 => {
    //   block [0x82A4D070..0x82A4D078)
	// 82A4D070: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D074: 480000C0  b 0x82a4d134
	pc = 0x82A4D134; continue 'dispatch;
            }
            0x82A4D078 => {
    //   block [0x82A4D078..0x82A4D0E0)
	// 82A4D078: 897F018A  lbz r11, 0x18a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(394 as u32) ) } as u64;
	// 82A4D07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D080: 7D7D0774  extsb r29, r11
	ctx.r[29].s64 = ctx.r[11].s8 as i64;
	// 82A4D084: 57BC103A  slwi r28, r29, 2
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A4D088: 4840C6D9  bl 0x82e59760
	ctx.lr = 0x82A4D08C;
	sub_82E59760(ctx, base);
	// 82A4D08C: C1BF0190  lfs f13, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4D090: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4D094: 895F0194  lbz r10, 0x194(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A4D098: 1D7D0003  mulli r11, r29, 3
	ctx.r[11].s64 = ctx.r[29].s64 * 3;
	// 82A4D09C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A4D0A0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4D0A4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A4D0A8: 3969D3F8  addi r11, r9, -0x2c08
	ctx.r[11].s64 = ctx.r[9].s64 + -11272;
	// 82A4D0AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A4D0B0: 392B003C  addi r9, r11, 0x3c
	ctx.r[9].s64 = ctx.r[11].s64 + 60;
	// 82A4D0B4: 390B0050  addi r8, r11, 0x50
	ctx.r[8].s64 = ctx.r[11].s64 + 80;
	// 82A4D0B8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A4D0BC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D0C0: 7D7C4C2E  lfsx f11, r28, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4D0C4: ED6B0024  fdivs f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4D0C8: 7D5C442E  lfsx f10, r28, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A4D0CC: C00708A8  lfs f0, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D0D0: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82A4D0D4: ED615824  fdivs f11, f1, f11
	ctx.f[11].f64 = ((ctx.f[1].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A4D0D8: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82A4D0DC: 48000050  b 0x82a4d12c
	pc = 0x82A4D12C; continue 'dispatch;
            }
            0x82A4D0E0 => {
    //   block [0x82A4D0E0..0x82A4D100)
	// 82A4D0E0: 897F018A  lbz r11, 0x18a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(394 as u32) ) } as u64;
	// 82A4D0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D0E8: 7D7D0774  extsb r29, r11
	ctx.r[29].s64 = ctx.r[11].s8 as i64;
	// 82A4D0EC: 57BC103A  slwi r28, r29, 2
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A4D0F0: 4840C671  bl 0x82e59760
	ctx.lr = 0x82A4D0F4;
	sub_82E59760(ctx, base);
	// 82A4D0F4: C1BF018C  lfs f13, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4D0F8: C19F0190  lfs f12, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4D0FC: 4BFFFF98  b 0x82a4d094
	pc = 0x82A4D094; continue 'dispatch;
            }
            0x82A4D100 => {
    //   block [0x82A4D100..0x82A4D148)
	// 82A4D100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D104: 4840C65D  bl 0x82e59760
	ctx.lr = 0x82A4D108;
	sub_82E59760(ctx, base);
	// 82A4D108: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4D10C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4D110: C19F018C  lfs f12, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4D114: C00B603C  lfs f0, 0x603c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D118: ED610032  fmuls f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4D11C: C1A9967C  lfs f13, -0x6984(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4D120: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4D124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4D128: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4D12C: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A4D130: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4D134: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4D138: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4D13C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A4D140: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A4D144: 4875B074  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4D148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4D148 size=920
    let mut pc: u32 = 0x82A4D148;
    'dispatch: loop {
        match pc {
            0x82A4D148 => {
    //   block [0x82A4D148..0x82A4D4E0)
	// 82A4D148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4D14C: 4875B01D  bl 0x831a8168
	ctx.lr = 0x82A4D150;
	sub_831A8130(ctx, base);
	// 82A4D150: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A4D154: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A4D158: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4D15C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4D160: 487074A1  bl 0x83154600
	ctx.lr = 0x82A4D164;
	sub_83154600(ctx, base);
	// 82A4D164: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4D168: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A4D16C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4D170: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A4D174: 807E053C  lwz r3, 0x53c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4D178: 4B882EE1  bl 0x822d0058
	ctx.lr = 0x82A4D17C;
	sub_822D0058(ctx, base);
	// 82A4D17C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4D180: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A4D184: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A4D188: 48430199  bl 0x82e7d320
	ctx.lr = 0x82A4D18C;
	sub_82E7D320(ctx, base);
	// 82A4D18C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82A4D190: 394005E0  li r10, 0x5e0
	ctx.r[10].s64 = 1504;
	// 82A4D194: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82A4D198: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A4D19C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A4D1A0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4D1A4: 13FE50C7  vcmpequd (lvx128) v31, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4D4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4D4E0 size=196
    let mut pc: u32 = 0x82A4D4E0;
    'dispatch: loop {
        match pc {
            0x82A4D4E0 => {
    //   block [0x82A4D4E0..0x82A4D5A4)
	// 82A4D4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4D4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4D4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4D4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4D4F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4D4F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4D4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4D4FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4D500: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4D504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4D508: 4B873431  bl 0x822c0938
	ctx.lr = 0x82A4D50C;
	sub_822C0938(ctx, base);
	// 82A4D50C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4D510: 41820028  beq 0x82a4d538
	if ctx.cr[0].eq {
	pc = 0x82A4D538; continue 'dispatch;
	}
	// 82A4D514: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4D518: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4D51C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4D520: 392BD4AC  addi r9, r11, -0x2b54
	ctx.r[9].s64 = ctx.r[11].s64 + -11092;
	// 82A4D524: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4D528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4D52C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4D530: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4D534: 48000008  b 0x82a4d53c
	pc = 0x82A4D53C; continue 'dispatch;
	// 82A4D538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4D53C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4D540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4D544: 409A0044  bne cr6, 0x82a4d588
	if !ctx.cr[6].eq {
	pc = 0x82A4D588; continue 'dispatch;
	}
	// 82A4D548: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4D54C: 419A001C  beq cr6, 0x82a4d568
	if ctx.cr[6].eq {
	pc = 0x82A4D568; continue 'dispatch;
	}
	// 82A4D550: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4D554: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4D558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4D55C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4D560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4D564: 4E800421  bctrl
	ctx.lr = 0x82A4D568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4D568: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4D56C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4D570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4D574: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4D578: 816B4218  lwz r11, 0x4218(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16920 as u32) ) } as u64;
	// 82A4D57C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4D580: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4D584: 4B872A7D  bl 0x822c0000
	ctx.lr = 0x82A4D588;
	sub_822C0000(ctx, base);
	// 82A4D588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4D58C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4D590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4D594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4D598: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4D59C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4D5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4D5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4D5A8 size=1668
    let mut pc: u32 = 0x82A4D5A8;
    'dispatch: loop {
        match pc {
            0x82A4D5A8 => {
    //   block [0x82A4D5A8..0x82A4DC2C)
	// 82A4D5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4D5AC: 4875ABA9  bl 0x831a8154
	ctx.lr = 0x82A4D5B0;
	sub_831A8130(ctx, base);
	// 82A4D5B0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82A4D5B4: 4875B4C1  bl 0x831a8a74
	ctx.lr = 0x82A4D5B8;
	sub_831A8A40(ctx, base);
	// 82A4D5B8: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4DC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4DC30 size=576
    let mut pc: u32 = 0x82A4DC30;
    'dispatch: loop {
        match pc {
            0x82A4DC30 => {
    //   block [0x82A4DC30..0x82A4DE70)
	// 82A4DC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4DC34: 4875A535  bl 0x831a8168
	ctx.lr = 0x82A4DC38;
	sub_831A8130(ctx, base);
	// 82A4DC38: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A4DC3C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4DC40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4DC44: 487069BD  bl 0x83154600
	ctx.lr = 0x82A4DC48;
	sub_83154600(ctx, base);
	// 82A4DC48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4DC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DC50: 4BFF8D69  bl 0x82a469b8
	ctx.lr = 0x82A4DC54;
	sub_82A469B8(ctx, base);
	// 82A4DC54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4DC58: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A4DC5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4DC60: 388AD4F0  addi r4, r10, -0x2b10
	ctx.r[4].s64 = ctx.r[10].s64 + -11024;
	// 82A4DC64: 38A001BE  li r5, 0x1be
	ctx.r[5].s64 = 446;
	// 82A4DC68: C00B093C  lfs f0, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DC6C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A4DC70: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4DC74: 4B872765  bl 0x822c03d8
	ctx.lr = 0x82A4DC78;
	sub_822C03D8(ctx, base);
	// 82A4DC78: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A4DC7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A4DC80: 41820020  beq 0x82a4dca0
	if ctx.cr[0].eq {
	pc = 0x82A4DCA0; continue 'dispatch;
	}
	// 82A4DC84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4DC88: 4BFE42B9  bl 0x82a31f40
	ctx.lr = 0x82A4DC8C;
	sub_82A31F40(ctx, base);
	// 82A4DC8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4DC90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4DC94: 4BFFF03D  bl 0x82a4ccd0
	ctx.lr = 0x82A4DC98;
	sub_82A4CCD0(ctx, base);
	// 82A4DC98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4DC9C: 48000008  b 0x82a4dca4
	pc = 0x82A4DCA4; continue 'dispatch;
	// 82A4DCA0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A4DCA4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A4DCA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A4DCAC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A4DCB0: 4BFFF831  bl 0x82a4d4e0
	ctx.lr = 0x82A4DCB4;
	sub_82A4D4E0(ctx, base);
	// 82A4DCB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A4DCB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A4DCBC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A4DCC0: 4B872341  bl 0x822c0000
	ctx.lr = 0x82A4DCC4;
	sub_822C0000(ctx, base);
	// 82A4DCC4: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4DCC8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A4DCCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A4DCD0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A4DCD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A4DCD8: 419A0024  beq cr6, 0x82a4dcfc
	if ctx.cr[6].eq {
	pc = 0x82A4DCFC; continue 'dispatch;
	}
	// 82A4DCDC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A4DCE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4DCE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4DCE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4DCEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4DCF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4DCF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4DCF8: 4082FFE8  bne 0x82a4dce0
	if !ctx.cr[0].eq {
	pc = 0x82A4DCE0; continue 'dispatch;
	}
	// 82A4DCFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4DD00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A4DD04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4DD08: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4DD0C: 4BFEA895  bl 0x82a385a0
	ctx.lr = 0x82A4DD10;
	sub_82A385A0(ctx, base);
	// 82A4DD10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A4DD14: 419A000C  beq cr6, 0x82a4dd20
	if ctx.cr[6].eq {
	pc = 0x82A4DD20; continue 'dispatch;
	}
	// 82A4DD18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4DD1C: 4B872B75  bl 0x822c0890
	ctx.lr = 0x82A4DD20;
	sub_822C0890(ctx, base);
	// 82A4DD20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4DD24: 4BFE421D  bl 0x82a31f40
	ctx.lr = 0x82A4DD28;
	sub_82A31F40(ctx, base);
	// 82A4DD28: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82A4DD2C: 41980098  blt cr6, 0x82a4ddc4
	if ctx.cr[6].lt {
	pc = 0x82A4DDC4; continue 'dispatch;
	}
	// 82A4DD30: 419A0050  beq cr6, 0x82a4dd80
	if ctx.cr[6].eq {
	pc = 0x82A4DD80; continue 'dispatch;
	}
	// 82A4DD34: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82A4DD38: 409800D0  bge cr6, 0x82a4de08
	if !ctx.cr[6].lt {
	pc = 0x82A4DE08; continue 'dispatch;
	}
	// 82A4DD3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4DD40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4DD44: 388BC598  addi r4, r11, -0x3a68
	ctx.r[4].s64 = ctx.r[11].s64 + -14952;
	// 82A4DD48: 483A5CC1  bl 0x82df3a08
	ctx.lr = 0x82A4DD4C;
	sub_82DF3A08(ctx, base);
	// 82A4DD4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4DD50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4DD54: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4DD58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A4DD5C: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4DD60: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4DD64: 48165615  bl 0x82bb3378
	ctx.lr = 0x82A4DD68;
	sub_82BB3378(ctx, base);
	// 82A4DD68: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A4DD6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4DD70: 419A0008  beq cr6, 0x82a4dd78
	if ctx.cr[6].eq {
	pc = 0x82A4DD78; continue 'dispatch;
	}
	// 82A4DD74: 4B872B1D  bl 0x822c0890
	ctx.lr = 0x82A4DD78;
	sub_822C0890(ctx, base);
	// 82A4DD78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4DD7C: 48000088  b 0x82a4de04
	pc = 0x82A4DE04; continue 'dispatch;
	// 82A4DD80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4DD84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4DD88: 388BC598  addi r4, r11, -0x3a68
	ctx.r[4].s64 = ctx.r[11].s64 + -14952;
	// 82A4DD8C: 483A5C7D  bl 0x82df3a08
	ctx.lr = 0x82A4DD90;
	sub_82DF3A08(ctx, base);
	// 82A4DD90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4DD94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A4DD98: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4DD9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4DDA0: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4DDA4: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4DDA8: 481655D1  bl 0x82bb3378
	ctx.lr = 0x82A4DDAC;
	sub_82BB3378(ctx, base);
	// 82A4DDAC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A4DDB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4DDB4: 419A0008  beq cr6, 0x82a4ddbc
	if ctx.cr[6].eq {
	pc = 0x82A4DDBC; continue 'dispatch;
	}
	// 82A4DDB8: 4B872AD9  bl 0x822c0890
	ctx.lr = 0x82A4DDBC;
	sub_822C0890(ctx, base);
	// 82A4DDBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4DDC0: 48000044  b 0x82a4de04
	pc = 0x82A4DE04; continue 'dispatch;
	// 82A4DDC4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4DDC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4DDCC: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A4DDD0: 483A5C39  bl 0x82df3a08
	ctx.lr = 0x82A4DDD4;
	sub_82DF3A08(ctx, base);
	// 82A4DDD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4DDD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4DDDC: 809E04EC  lwz r4, 0x4ec(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4DDE0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A4DDE4: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4DDE8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4DDEC: 4816558D  bl 0x82bb3378
	ctx.lr = 0x82A4DDF0;
	sub_82BB3378(ctx, base);
	// 82A4DDF0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A4DDF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4DDF8: 419A0008  beq cr6, 0x82a4de00
	if ctx.cr[6].eq {
	pc = 0x82A4DE00; continue 'dispatch;
	}
	// 82A4DDFC: 4B872A95  bl 0x822c0890
	ctx.lr = 0x82A4DE00;
	sub_822C0890(ctx, base);
	// 82A4DE00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4DE04: 483A5625  bl 0x82df3428
	ctx.lr = 0x82A4DE08;
	sub_82DF3428(ctx, base);
	// 82A4DE08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4DE0C: 9B9F0188  stb r28, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[28].u8 ) };
	// 82A4DE10: 9B9F0189  stb r28, 0x189(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(393 as u32), ctx.r[28].u8 ) };
	// 82A4DE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4DE18: 9B9F018A  stb r28, 0x18a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(394 as u32), ctx.r[28].u8 ) };
	// 82A4DE1C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4DE20: D3FF0180  stfs f31, 0x180(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4DE24: D3FF0184  stfs f31, 0x184(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A4DE28: 4BFE4119  bl 0x82a31f40
	ctx.lr = 0x82A4DE2C;
	sub_82A31F40(ctx, base);
	// 82A4DE2C: 987F0194  stb r3, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u8 ) };
	// 82A4DE30: C01E05FC  lfs f0, 0x5fc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DE34: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82A4DE38: 807E04BC  lwz r3, 0x4bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4DE3C: 4BDA7595  bl 0x827f53d0
	ctx.lr = 0x82A4DE40;
	sub_827F53D0(ctx, base);
	// 82A4DE40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4DE44: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DE48: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A4DE4C: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A4DE50: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A4DE54: C00B9D1C  lfs f0, -0x62e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DE58: C1AAD7BC  lfs f13, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4DE5C: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4DE60: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4DE64: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A4DE68: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A4DE6C: 4875A34C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4DE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4DE70 size=76
    let mut pc: u32 = 0x82A4DE70;
    'dispatch: loop {
        match pc {
            0x82A4DE70 => {
    //   block [0x82A4DE70..0x82A4DEBC)
	// 82A4DE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4DE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4DE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4DE7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4DE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4DE84: 4BFFF725  bl 0x82a4d5a8
	ctx.lr = 0x82A4DE88;
	sub_82A4D5A8(ctx, base);
	// 82A4DE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DE8C: 4BFFF085  bl 0x82a4cf10
	ctx.lr = 0x82A4DE90;
	sub_82A4CF10(ctx, base);
	// 82A4DE90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DE94: 4800082D  bl 0x82a4e6c0
	ctx.lr = 0x82A4DE98;
	sub_82A4E6C0(ctx, base);
	// 82A4DE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DE9C: 4BFFF2AD  bl 0x82a4d148
	ctx.lr = 0x82A4DEA0;
	sub_82A4D148(ctx, base);
	// 82A4DEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DEA4: 4870675D  bl 0x83154600
	ctx.lr = 0x82A4DEA8;
	sub_83154600(ctx, base);
	// 82A4DEA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4DEAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4DEB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4DEB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4DEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4DEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4DEC0 size=48
    let mut pc: u32 = 0x82A4DEC0;
    'dispatch: loop {
        match pc {
            0x82A4DEC0 => {
    //   block [0x82A4DEC0..0x82A4DEF0)
	// 82A4DEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4DEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4DEC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4DECC: 48706735  bl 0x83154600
	ctx.lr = 0x82A4DED0;
	sub_83154600(ctx, base);
	// 82A4DED0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A4DED4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A4DED8: 996305BC  stb r11, 0x5bc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1468 as u32), ctx.r[11].u8 ) };
	// 82A4DEDC: B14305C0  sth r10, 0x5c0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(1472 as u32), ctx.r[10].u16 ) };
	// 82A4DEE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4DEE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4DEE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4DEEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4DEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4DEF0 size=336
    let mut pc: u32 = 0x82A4DEF0;
    'dispatch: loop {
        match pc {
            0x82A4DEF0 => {
    //   block [0x82A4DEF0..0x82A4E040)
	// 82A4DEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4DEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4DEF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4DEFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4DF00: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82A4DF04: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A4DF08: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A4DF0C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4DF10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4DF14: 487066ED  bl 0x83154600
	ctx.lr = 0x82A4DF18;
	sub_83154600(ctx, base);
	// 82A4DF18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4DF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DF20: 4840B841  bl 0x82e59760
	ctx.lr = 0x82A4DF24;
	sub_82E59760(ctx, base);
	// 82A4DF24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4DF28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4DF2C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A4DF30: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DF34: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4DF38: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4DF3C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4DF40: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4DF44: 41990018  bgt cr6, 0x82a4df5c
	if ctx.cr[6].gt {
	pc = 0x82A4DF5C; continue 'dispatch;
	}
	// 82A4DF48: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82A4DF4C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4DF50: 4098000C  bge cr6, 0x82a4df5c
	if !ctx.cr[6].lt {
	pc = 0x82A4DF5C; continue 'dispatch;
	}
	// 82A4DF54: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82A4DF58: 48000008  b 0x82a4df60
	pc = 0x82A4DF60; continue 'dispatch;
	// 82A4DF5C: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 82A4DF60: 897E0148  lbz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A4DF64: C1BE05FC  lfs f13, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4DF68: C19F0180  lfs f12, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4DF6C: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4DF70: 40810010  ble 0x82a4df80
	if !ctx.cr[0].gt {
	pc = 0x82A4DF80; continue 'dispatch;
	}
	// 82A4DF74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4DF78: C00B967C  lfs f0, -0x6984(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DF7C: 4800000C  b 0x82a4df88
	pc = 0x82A4DF88; continue 'dispatch;
	// 82A4DF80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4DF84: C00B9584  lfs f0, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4DF88: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A4DF8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DF90: EC0067BA  fmadds f0, f0, f30, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A4DF94: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4DF98: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4DF9C: 4840B7DD  bl 0x82e59778
	ctx.lr = 0x82A4DFA0;
	sub_82E59778(ctx, base);
	// 82A4DFA0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A4DFA4: 4199000C  bgt cr6, 0x82a4dfb0
	if ctx.cr[6].gt {
	pc = 0x82A4DFB0; continue 'dispatch;
	}
	// 82A4DFA8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82A4DFAC: 48000010  b 0x82a4dfbc
	pc = 0x82A4DFBC; continue 'dispatch;
	// 82A4DFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DFB4: 4840B7C5  bl 0x82e59778
	ctx.lr = 0x82A4DFB8;
	sub_82E59778(ctx, base);
	// 82A4DFB8: EC1D0824  fdivs f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[1].f64) as f32) as f64;
	// 82A4DFBC: D01E05F8  stfs f0, 0x5f8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 82A4DFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4DFC4: 480006FD  bl 0x82a4e6c0
	ctx.lr = 0x82A4DFC8;
	sub_82A4E6C0(ctx, base);
	// 82A4DFC8: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A4DFCC: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A4DFD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4DFD4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A4DFD8: 389F0190  addi r4, r31, 0x190
	ctx.r[4].s64 = ctx.r[31].s64 + 400;
	// 82A4DFDC: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A4DFE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A4DFE4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4DFE8: 4842F659  bl 0x82e7d640
	ctx.lr = 0x82A4DFEC;
	sub_82E7D640(ctx, base);
	// 82A4DFEC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A4DFF0: 807E04BC  lwz r3, 0x4bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4DFF4: 4BB3CE75  bl 0x8258ae68
	ctx.lr = 0x82A4DFF8;
	sub_8258AE68(ctx, base);
	// 82A4DFF8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A4DFFC: 389F01A0  addi r4, r31, 0x1a0
	ctx.r[4].s64 = ctx.r[31].s64 + 416;
	// 82A4E000: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A4E004: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82A4E008: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4E00C: 4842F2BD  bl 0x82e7d2c8
	ctx.lr = 0x82A4E010;
	sub_82E7D2C8(ctx, base);
	// 82A4E010: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A4E014: 807E04BC  lwz r3, 0x4bc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4E018: 4BB3CE99  bl 0x8258aeb0
	ctx.lr = 0x82A4E01C;
	sub_8258AEB0(ctx, base);
	// 82A4E01C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A4E020: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E024: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E028: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A4E02C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4E030: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A4E034: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4E038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E040 size=276
    let mut pc: u32 = 0x82A4E040;
    'dispatch: loop {
        match pc {
            0x82A4E040 => {
    //   block [0x82A4E040..0x82A4E154)
	// 82A4E040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4E04C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E050: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A4E054: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E058: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4E05C: 487065A5  bl 0x83154600
	ctx.lr = 0x82A4E060;
	sub_83154600(ctx, base);
	// 82A4E060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4E068: 897F0148  lbz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A4E06C: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4E070: 40810048  ble 0x82a4e0b8
	if !ctx.cr[0].gt {
	pc = 0x82A4E0B8; continue 'dispatch;
	}
	// 82A4E074: 4840B6ED  bl 0x82e59760
	ctx.lr = 0x82A4E078;
	sub_82E59760(ctx, base);
	// 82A4E078: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E07C: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E080: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A4E084: 409900AC  ble cr6, 0x82a4e130
	if !ctx.cr[6].gt {
	pc = 0x82A4E130; continue 'dispatch;
	}
	// 82A4E088: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4E08C: 895F054C  lbz r10, 0x54c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A4E090: 396B42C8  addi r11, r11, 0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + 17096;
	// 82A4E094: 7C8A58AE  lbzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A4E098: 7C8B0775  extsb. r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4E09C: 40800010  bge 0x82a4e0ac
	if !ctx.cr[0].lt {
	pc = 0x82A4E0AC; continue 'dispatch;
	}
	// 82A4E0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E0A4: 4BFE3ECD  bl 0x82a31f70
	ctx.lr = 0x82A4E0A8;
	sub_82A31F70(ctx, base);
	// 82A4E0A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4E0AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E0B0: 4BFEB0B1  bl 0x82a39160
	ctx.lr = 0x82A4E0B4;
	sub_82A39160(ctx, base);
	// 82A4E0B4: 4800007C  b 0x82a4e130
	pc = 0x82A4E130; continue 'dispatch;
	// 82A4E0B8: 4840B6A9  bl 0x82e59760
	ctx.lr = 0x82A4E0BC;
	sub_82E59760(ctx, base);
	// 82A4E0BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4E0C0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4E0C4: 4840B6B5  bl 0x82e59778
	ctx.lr = 0x82A4E0C8;
	sub_82E59778(ctx, base);
	// 82A4E0C8: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A4E0CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E0D0: C3EB9524  lfs f31, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E0D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4E0D8: 41990058  bgt cr6, 0x82a4e130
	if ctx.cr[6].gt {
	pc = 0x82A4E130; continue 'dispatch;
	}
	// 82A4E0DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4E0E0: 4840B681  bl 0x82e59760
	ctx.lr = 0x82A4E0E4;
	sub_82E59760(ctx, base);
	// 82A4E0E4: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A4E0E8: 40990048  ble cr6, 0x82a4e130
	if !ctx.cr[6].gt {
	pc = 0x82A4E130; continue 'dispatch;
	}
	// 82A4E0EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A4E0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4E0F4: 388B06EC  addi r4, r11, 0x6ec
	ctx.r[4].s64 = ctx.r[11].s64 + 1772;
	// 82A4E0F8: 483A5911  bl 0x82df3a08
	ctx.lr = 0x82A4E0FC;
	sub_82DF3A08(ctx, base);
	// 82A4E0FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4E100: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4E104: 809F04EC  lwz r4, 0x4ec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4E108: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4E10C: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4E110: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4E114: 48165265  bl 0x82bb3378
	ctx.lr = 0x82A4E118;
	sub_82BB3378(ctx, base);
	// 82A4E118: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4E11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4E120: 419A0008  beq cr6, 0x82a4e128
	if ctx.cr[6].eq {
	pc = 0x82A4E128; continue 'dispatch;
	}
	// 82A4E124: 4B87276D  bl 0x822c0890
	ctx.lr = 0x82A4E128;
	sub_822C0890(ctx, base);
	// 82A4E128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4E12C: 483A52FD  bl 0x82df3428
	ctx.lr = 0x82A4E130;
	sub_82DF3428(ctx, base);
	// 82A4E130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4E134: 4BFFFDBD  bl 0x82a4def0
	ctx.lr = 0x82A4E138;
	sub_82A4DEF0(ctx, base);
	// 82A4E138: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4E13C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E144: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A4E148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4E14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E158 size=272
    let mut pc: u32 = 0x82A4E158;
    'dispatch: loop {
        match pc {
            0x82A4E158 => {
    //   block [0x82A4E158..0x82A4E268)
	// 82A4E158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E15C: 4875A011  bl 0x831a816c
	ctx.lr = 0x82A4E160;
	sub_831A8130(ctx, base);
	// 82A4E160: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E164: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4E168: 48706499  bl 0x83154600
	ctx.lr = 0x82A4E16C;
	sub_83154600(ctx, base);
	// 82A4E16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E170: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4E174: 4BFF8845  bl 0x82a469b8
	ctx.lr = 0x82A4E178;
	sub_82A469B8(ctx, base);
	// 82A4E178: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A4E17C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4E180: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A4E184: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4E188: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A4E18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E190: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4E194: 4BFEA40D  bl 0x82a385a0
	ctx.lr = 0x82A4E198;
	sub_82A385A0(ctx, base);
	// 82A4E198: C01F05FC  lfs f0, 0x5fc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E19C: 9BDF05BC  stb r30, 0x5bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1468 as u32), ctx.r[30].u8 ) };
	// 82A4E1A0: D01D0180  stfs f0, 0x180(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4E1A4: 807F04BC  lwz r3, 0x4bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A4E1A8: 4BDA7229  bl 0x827f53d0
	ctx.lr = 0x82A4E1AC;
	sub_827F53D0(ctx, base);
	// 82A4E1AC: 39600190  li r11, 0x190
	ctx.r[11].s64 = 400;
	// 82A4E1B0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E268 size=100
    let mut pc: u32 = 0x82A4E268;
    'dispatch: loop {
        match pc {
            0x82A4E268 => {
    //   block [0x82A4E268..0x82A4E2CC)
	// 82A4E268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E27C: 4840E6AD  bl 0x82e5c928
	ctx.lr = 0x82A4E280;
	sub_82E5C928(ctx, base);
	// 82A4E280: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4E284: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A4E288: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4E28C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A4E290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E294: 3908D544  addi r8, r8, -0x2abc
	ctx.r[8].s64 = ctx.r[8].s64 + -10940;
	// 82A4E298: C00B08AC  lfs f0, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E29C: C1AA6218  lfs f13, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E2A0: C189959C  lfs f12, -0x6a64(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E2A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A4E2A8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A4E2AC: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A4E2B0: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4E2B4: D19F006C  stfs f12, 0x6c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4E2B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4E2BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E2C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E2C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E2D0 size=260
    let mut pc: u32 = 0x82A4E2D0;
    'dispatch: loop {
        match pc {
            0x82A4E2D0 => {
    //   block [0x82A4E2D0..0x82A4E3D4)
	// 82A4E2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4E2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E2E0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E2E4: 4875A795  bl 0x831a8a78
	ctx.lr = 0x82A4E2E8;
	sub_831A8A40(ctx, base);
	// 82A4E2E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E2EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E2F0: 48706311  bl 0x83154600
	ctx.lr = 0x82A4E2F4;
	sub_83154600(ctx, base);
	// 82A4E2F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4E2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E2FC: 4840B47D  bl 0x82e59778
	ctx.lr = 0x82A4E300;
	sub_82E59778(ctx, base);
	// 82A4E300: C01F0174  lfs f0, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E304: ED81002A  fadds f12, f1, f0
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4E308: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4E30C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4E310: D19F0174  stfs f12, 0x174(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A4E314: C00B42E8  lfs f0, 0x42e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E318: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E31C: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4E324: 4098000C  bge cr6, 0x82a4e330
	if !ctx.cr[6].lt {
	pc = 0x82A4E330; continue 'dispatch;
	}
	// 82A4E328: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82A4E32C: 48000008  b 0x82a4e334
	pc = 0x82A4E334; continue 'dispatch;
	// 82A4E330: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	// 82A4E334: 807E053C  lwz r3, 0x53c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4E338: 4B881BE9  bl 0x822cff20
	ctx.lr = 0x82A4E33C;
	sub_822CFF20(ctx, base);
	// 82A4E33C: C01E0600  lfs f0, 0x600(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E340: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E344: C1BE05FC  lfs f13, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E348: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E34C: EDADF028  fsubs f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E350: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E354: 4098000C  bge cr6, 0x82a4e360
	if !ctx.cr[6].lt {
	pc = 0x82A4E360; continue 'dispatch;
	}
	// 82A4E358: C3FF0068  lfs f31, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E35C: 4800001C  b 0x82a4e378
	pc = 0x82A4E378; continue 'dispatch;
	// 82A4E360: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E364: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4E368: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4E36C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E370: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82A4E374: EFED0024  fdivs f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E37C: C39F0170  lfs f28, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A4E380: 4840B3F9  bl 0x82e59778
	ctx.lr = 0x82A4E384;
	sub_82E59778(ctx, base);
	// 82A4E384: EDBFE028  fsubs f13, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 82A4E388: C19E05FC  lfs f12, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E38C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4E390: D3FE05F8  stfs f31, 0x5f8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 82A4E394: C00BDF40  lfs f0, -0x20c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E398: EDADE77A  fmadds f13, f13, f29, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 82A4E39C: EDA1F378  fmsubs f13, f1, f13, f30
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E3A0: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4E3A4: D1BE05FC  stfs f13, 0x5fc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E3A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E3AC: 40980008  bge cr6, 0x82a4e3b4
	if !ctx.cr[6].lt {
	pc = 0x82A4E3B4; continue 'dispatch;
	}
	// 82A4E3B0: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E3B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4E3B8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E3BC: 4875A709  bl 0x831a8ac4
	ctx.lr = 0x82A4E3C0;
	sub_831A8A8C(ctx, base);
	// 82A4E3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E3C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4E3CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E3D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E3D8 size=324
    let mut pc: u32 = 0x82A4E3D8;
    'dispatch: loop {
        match pc {
            0x82A4E3D8 => {
    //   block [0x82A4E3D8..0x82A4E51C)
	// 82A4E3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4E3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E3E8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E3EC: 4875A68D  bl 0x831a8a78
	ctx.lr = 0x82A4E3F0;
	sub_831A8A40(ctx, base);
	// 82A4E3F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E3F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E3F8: 48706209  bl 0x83154600
	ctx.lr = 0x82A4E3FC;
	sub_83154600(ctx, base);
	// 82A4E3FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4E400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E404: 4840B375  bl 0x82e59778
	ctx.lr = 0x82A4E408;
	sub_82E59778(ctx, base);
	// 82A4E408: C01F0174  lfs f0, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E40C: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4E410: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4E414: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4E418: D1BF0174  stfs f13, 0x174(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A4E41C: C00B42E8  lfs f0, 0x42e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E420: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E424: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E428: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4E42C: 4098000C  bge cr6, 0x82a4e438
	if !ctx.cr[6].lt {
	pc = 0x82A4E438; continue 'dispatch;
	}
	// 82A4E430: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82A4E434: 48000008  b 0x82a4e43c
	pc = 0x82A4E43C; continue 'dispatch;
	// 82A4E438: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82A4E43C: 807E053C  lwz r3, 0x53c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4E440: 4B881AE1  bl 0x822cff20
	ctx.lr = 0x82A4E444;
	sub_822CFF20(ctx, base);
	// 82A4E444: C01E0600  lfs f0, 0x600(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E448: 897E05F4  lbz r11, 0x5f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82A4E44C: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E450: C01E05FC  lfs f0, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E454: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4E458: EDA0F028  fsubs f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E45C: 41820010  beq 0x82a4e46c
	if ctx.cr[0].eq {
	pc = 0x82A4E46C; continue 'dispatch;
	}
	// 82A4E460: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A4E464: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E468: 4800000C  b 0x82a4e474
	pc = 0x82A4E474; continue 'dispatch;
	// 82A4E46C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E470: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E474: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E478: 40980044  bge cr6, 0x82a4e4bc
	if !ctx.cr[6].lt {
	pc = 0x82A4E4BC; continue 'dispatch;
	}
	// 82A4E47C: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E480: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A4E484: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E488: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4E48C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4E490: 4875AA19  bl 0x831a8ea8
	ctx.lr = 0x82A4E494;
	sub_831A8EA8(ctx, base);
	// 82A4E494: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4E498: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E49C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4E4A0: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4E4A4: C1AB9664  lfs f13, -0x699c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E4A8: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E4AC: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A4E4B0: EC0C003C  fnmsubs f0, f12, f0, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E4B4: EFED583A  fmadds f31, f13, f0, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A4E4B8: 48000008  b 0x82a4e4c0
	pc = 0x82A4E4C0; continue 'dispatch;
	// 82A4E4BC: C3FF0068  lfs f31, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E4C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E4C4: C39F0170  lfs f28, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A4E4C8: 4840B2B1  bl 0x82e59778
	ctx.lr = 0x82A4E4CC;
	sub_82E59778(ctx, base);
	// 82A4E4CC: EDBFE028  fsubs f13, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 82A4E4D0: C19E05FC  lfs f12, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E4D4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4E4D8: D3FE05F8  stfs f31, 0x5f8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 82A4E4DC: C00BDF40  lfs f0, -0x20c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E4E0: EDADE77A  fmadds f13, f13, f29, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 82A4E4E4: EDA1F378  fmsubs f13, f1, f13, f30
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E4E8: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4E4EC: D1BE05FC  stfs f13, 0x5fc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E4F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E4F4: 40980008  bge cr6, 0x82a4e4fc
	if !ctx.cr[6].lt {
	pc = 0x82A4E4FC; continue 'dispatch;
	}
	// 82A4E4F8: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E4FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4E500: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E504: 4875A5C1  bl 0x831a8ac4
	ctx.lr = 0x82A4E508;
	sub_831A8A8C(ctx, base);
	// 82A4E508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E50C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E510: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4E514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E520 size=416
    let mut pc: u32 = 0x82A4E520;
    'dispatch: loop {
        match pc {
            0x82A4E520 => {
    //   block [0x82A4E520..0x82A4E6C0)
	// 82A4E520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4E52C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E530: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E534: 4875A545  bl 0x831a8a78
	ctx.lr = 0x82A4E538;
	sub_831A8A40(ctx, base);
	// 82A4E538: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E53C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E540: 487060C1  bl 0x83154600
	ctx.lr = 0x82A4E544;
	sub_83154600(ctx, base);
	// 82A4E544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4E548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E54C: 4840B22D  bl 0x82e59778
	ctx.lr = 0x82A4E550;
	sub_82E59778(ctx, base);
	// 82A4E550: C01F0174  lfs f0, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E554: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4E558: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4E55C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4E560: D1BF0174  stfs f13, 0x174(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A4E564: C00B42E8  lfs f0, 0x42e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E568: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E56C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E570: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A4E574: 4098000C  bge cr6, 0x82a4e580
	if !ctx.cr[6].lt {
	pc = 0x82A4E580; continue 'dispatch;
	}
	// 82A4E578: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82A4E57C: 48000008  b 0x82a4e584
	pc = 0x82A4E584; continue 'dispatch;
	// 82A4E580: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82A4E584: 807E053C  lwz r3, 0x53c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4E588: 4B881999  bl 0x822cff20
	ctx.lr = 0x82A4E58C;
	sub_822CFF20(ctx, base);
	// 82A4E58C: C01E0600  lfs f0, 0x600(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E590: 897E05F4  lbz r11, 0x5f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1524 as u32) ) } as u64;
	// 82A4E594: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E598: C01E05FC  lfs f0, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E59C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4E5A0: ED80F028  fsubs f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E5A4: 41820018  beq 0x82a4e5bc
	if ctx.cr[0].eq {
	pc = 0x82A4E5BC; continue 'dispatch;
	}
	// 82A4E5A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4E5AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4E5B0: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E5B4: C00A78D8  lfs f0, 0x78d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E5B8: 48000014  b 0x82a4e5cc
	pc = 0x82A4E5CC; continue 'dispatch;
	// 82A4E5BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E5C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4E5C4: C1AB959C  lfs f13, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E5C8: C00A9C28  lfs f0, -0x63d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E5CC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82A4E5D0: 4098004C  bge cr6, 0x82a4e61c
	if !ctx.cr[6].lt {
	pc = 0x82A4E61C; continue 'dispatch;
	}
	// 82A4E5D4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E5D8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A4E5DC: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E5E0: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E5E4: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82A4E5E8: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4E5EC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4E5F0: 4875A8B9  bl 0x831a8ea8
	ctx.lr = 0x82A4E5F4;
	sub_831A8EA8(ctx, base);
	// 82A4E5F4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4E5F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4E5FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4E600: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4E604: C1AB9664  lfs f13, -0x699c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E608: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E60C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A4E610: EC0C003C  fnmsubs f0, f12, f0, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E614: EFED583A  fmadds f31, f13, f0, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A4E618: 4800004C  b 0x82a4e664
	pc = 0x82A4E664; continue 'dispatch;
	// 82A4E61C: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E620: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82A4E624: 4098000C  bge cr6, 0x82a4e630
	if !ctx.cr[6].lt {
	pc = 0x82A4E630; continue 'dispatch;
	}
	// 82A4E628: C3FF0068  lfs f31, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E62C: 48000038  b 0x82a4e664
	pc = 0x82A4E664; continue 'dispatch;
	// 82A4E630: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E634: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82A4E638: 4099000C  ble cr6, 0x82a4e644
	if !ctx.cr[6].gt {
	pc = 0x82A4E644; continue 'dispatch;
	}
	// 82A4E63C: C3FF006C  lfs f31, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4E640: 48000024  b 0x82a4e664
	pc = 0x82A4E664; continue 'dispatch;
	// 82A4E644: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A4E648: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4E64C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4E650: C1BF006C  lfs f13, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E654: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A4E658: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4E65C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4E660: EFE05B7A  fmadds f31, f0, f13, f11
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A4E664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E668: C39F0170  lfs f28, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A4E66C: 4840B10D  bl 0x82e59778
	ctx.lr = 0x82A4E670;
	sub_82E59778(ctx, base);
	// 82A4E670: EDBFE028  fsubs f13, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 82A4E674: C19E05FC  lfs f12, 0x5fc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1532 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E678: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4E67C: D3FE05F8  stfs f31, 0x5f8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1528 as u32), tmp.u32 ) };
	// 82A4E680: C00BDF40  lfs f0, -0x20c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E684: EDADE77A  fmadds f13, f13, f29, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 82A4E688: EDA1F378  fmsubs f13, f1, f13, f30
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4E68C: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4E690: D1BE05FC  stfs f13, 0x5fc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E694: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E698: 40980008  bge cr6, 0x82a4e6a0
	if !ctx.cr[6].lt {
	pc = 0x82A4E6A0; continue 'dispatch;
	}
	// 82A4E69C: D01E05FC  stfs f0, 0x5fc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1532 as u32), tmp.u32 ) };
	// 82A4E6A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A4E6A4: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82A4E6A8: 4875A41D  bl 0x831a8ac4
	ctx.lr = 0x82A4E6AC;
	sub_831A8A8C(ctx, base);
	// 82A4E6AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E6B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E6B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4E6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4E6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4E6C0 size=36
    let mut pc: u32 = 0x82A4E6C0;
    'dispatch: loop {
        match pc {
            0x82A4E6C0 => {
    //   block [0x82A4E6C0..0x82A4E6E4)
	// 82A4E6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E6C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E6CC: 48705F35  bl 0x83154600
	ctx.lr = 0x82A4E6D0;
	sub_83154600(ctx, base);
	// 82A4E6D0: 4BFED2B1  bl 0x82a3b980
	ctx.lr = 0x82A4E6D4;
	sub_82A3B980(ctx, base);
	// 82A4E6D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4E6D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4E6DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4E6E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E6E8 size=180
    let mut pc: u32 = 0x82A4E6E8;
    'dispatch: loop {
        match pc {
            0x82A4E6E8 => {
    //   block [0x82A4E6E8..0x82A4E79C)
	// 82A4E6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E6EC: 48759A79  bl 0x831a8164
	ctx.lr = 0x82A4E6F0;
	sub_831A8130(ctx, base);
	// 82A4E6F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E6F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4E6F8: 48705F09  bl 0x83154600
	ctx.lr = 0x82A4E6FC;
	sub_83154600(ctx, base);
	// 82A4E6FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A4E700: 3BFD0134  addi r31, r29, 0x134
	ctx.r[31].s64 = ctx.r[29].s64 + 308;
	// 82A4E704: 3BDB04BC  addi r30, r27, 0x4bc
	ctx.r[30].s64 = ctx.r[27].s64 + 1212;
	// 82A4E708: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82A4E70C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4E710: 4BDA6CC1  bl 0x827f53d0
	ctx.lr = 0x82A4E714;
	sub_827F53D0(ctx, base);
	// 82A4E714: 3960FF7C  li r11, -0x84
	ctx.r[11].s64 = -132;
	// 82A4E718: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4E71C: 3940FF3C  li r10, -0xc4
	ctx.r[10].s64 = -196;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4E7A0 size=24
    let mut pc: u32 = 0x82A4E7A0;
    'dispatch: loop {
        match pc {
            0x82A4E7A0 => {
    //   block [0x82A4E7A0..0x82A4E7B8)
	// 82A4E7A0: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 82A4E7A4: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4E7A8: 396B0007  addi r11, r11, 7
	ctx.r[11].s64 = ctx.r[11].s64 + 7;
	// 82A4E7AC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4E7B8 size=52
    let mut pc: u32 = 0x82A4E7B8;
    'dispatch: loop {
        match pc {
            0x82A4E7B8 => {
    //   block [0x82A4E7B8..0x82A4E7EC)
	// 82A4E7B8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 82A4E7BC: C0050000  lfs f0, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E7C0: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 82A4E7C4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A4E7C8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A4E7CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4E7D0: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E7D4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4E7D8: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E7DC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4E7E0: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E7E4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4E7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E7F0 size=292
    let mut pc: u32 = 0x82A4E7F0;
    'dispatch: loop {
        match pc {
            0x82A4E7F0 => {
    //   block [0x82A4E7F0..0x82A4E914)
	// 82A4E7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E7F4: 4875996D  bl 0x831a8160
	ctx.lr = 0x82A4E7F8;
	sub_831A8130(ctx, base);
	// 82A4E7F8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A4E7FC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E804: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4E808: 48705DF9  bl 0x83154600
	ctx.lr = 0x82A4E80C;
	sub_83154600(ctx, base);
	// 82A4E80C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A4E810: 3BFF00B0  addi r31, r31, 0xb0
	ctx.r[31].s64 = ctx.r[31].s64 + 176;
	// 82A4E814: 3B9B04BC  addi r28, r27, 0x4bc
	ctx.r[28].s64 = ctx.r[27].s64 + 1212;
	// 82A4E818: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 82A4E81C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82A4E820: 38BFFFC0  addi r5, r31, -0x40
	ctx.r[5].s64 = ctx.r[31].s64 + -64;
	// 82A4E824: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4E828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4E82C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4E830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4E834: 4842EE0D  bl 0x82e7d640
	ctx.lr = 0x82A4E838;
	sub_82E7D640(ctx, base);
	// 82A4E838: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4E83C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A4E840: 4BB3C629  bl 0x8258ae68
	ctx.lr = 0x82A4E844;
	sub_8258AE68(ctx, base);
	// 82A4E844: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 82A4E848: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 82A4E84C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4E850: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A4E854: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4E858: 4842EA71  bl 0x82e7d2c8
	ctx.lr = 0x82A4E85C;
	sub_82E7D2C8(ctx, base);
	// 82A4E85C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4E860: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A4E864: 4BB3C64D  bl 0x8258aeb0
	ctx.lr = 0x82A4E868;
	sub_8258AEB0(ctx, base);
	// 82A4E868: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A4E86C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A4E870: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A4E874: 4082FFAC  bne 0x82a4e820
	if !ctx.cr[0].eq {
	pc = 0x82A4E820; continue 'dispatch;
	}
	// 82A4E878: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4E87C: 4BDA6B55  bl 0x827f53d0
	ctx.lr = 0x82A4E880;
	sub_827F53D0(ctx, base);
	// 82A4E880: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A4E884: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4E888: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82A4E88C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A4E890: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E918 size=132
    let mut pc: u32 = 0x82A4E918;
    'dispatch: loop {
        match pc {
            0x82A4E918 => {
    //   block [0x82A4E918..0x82A4E99C)
	// 82A4E918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E91C: 48759851  bl 0x831a816c
	ctx.lr = 0x82A4E920;
	sub_831A8130(ctx, base);
	// 82A4E920: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4E924: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E92C: 48705CD5  bl 0x83154600
	ctx.lr = 0x82A4E930;
	sub_83154600(ctx, base);
	// 82A4E930: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4E934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E938: 4BFFFDB1  bl 0x82a4e6e8
	ctx.lr = 0x82A4E93C;
	sub_82A4E6E8(ctx, base);
	// 82A4E93C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4E940: 4BFE90C1  bl 0x82a37a00
	ctx.lr = 0x82A4E944;
	sub_82A37A00(ctx, base);
	// 82A4E944: 807E052C  lwz r3, 0x52c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4E948: 83BE053C  lwz r29, 0x53c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4E94C: 4B8815D5  bl 0x822cff20
	ctx.lr = 0x82A4E950;
	sub_822CFF20(ctx, base);
	// 82A4E950: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4E954: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4E958: 4B8815C9  bl 0x822cff20
	ctx.lr = 0x82A4E95C;
	sub_822CFF20(ctx, base);
	// 82A4E95C: EDBF0828  fsubs f13, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A4E960: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4E964: D1BF018C  stfs f13, 0x18c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4E968: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E96C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4E970: 40980018  bge cr6, 0x82a4e988
	if !ctx.cr[6].lt {
	pc = 0x82A4E988; continue 'dispatch;
	}
	// 82A4E974: 807E052C  lwz r3, 0x52c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4E978: 4B881599  bl 0x822cff10
	ctx.lr = 0x82A4E97C;
	sub_822CFF10(ctx, base);
	// 82A4E97C: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E980: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4E984: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4E988: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E98C: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A4E990: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4E994: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4E998: 48759824  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4E9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4E9A0 size=116
    let mut pc: u32 = 0x82A4E9A0;
    'dispatch: loop {
        match pc {
            0x82A4E9A0 => {
    //   block [0x82A4E9A0..0x82A4EA14)
	// 82A4E9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4E9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4E9A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4E9AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4E9B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4E9B4: 4BFFF8B5  bl 0x82a4e268
	ctx.lr = 0x82A4E9B8;
	sub_82A4E268(ctx, base);
	// 82A4E9B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4E9BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4E9C0: 392B42F0  addi r9, r11, 0x42f0
	ctx.r[9].s64 = ctx.r[11].s64 + 17136;
	// 82A4E9C4: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A4E9C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A4E9CC: 3908D56C  addi r8, r8, -0x2a94
	ctx.r[8].s64 = ctx.r[8].s64 + -10900;
	// 82A4E9D0: C18B42F0  lfs f12, 0x42f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4E9D4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E9D8: 98FF01A4  stb r7, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[7].u8 ) };
	// 82A4E9DC: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A4E9E0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A4E9E4: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4E9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4E9EC: C1A9002C  lfs f13, 0x2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4E9F0: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A4E9F4: D19F0188  stfs f12, 0x188(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82A4E9F8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4E9FC: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A4EA00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4EA04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4EA08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4EA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4EA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4EA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4EA18 size=368
    let mut pc: u32 = 0x82A4EA18;
    'dispatch: loop {
        match pc {
            0x82A4EA18 => {
    //   block [0x82A4EA18..0x82A4EB88)
	// 82A4EA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4EA1C: 48759751  bl 0x831a816c
	ctx.lr = 0x82A4EA20;
	sub_831A8130(ctx, base);
	// 82A4EA20: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4EA24: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4EA28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4EA2C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A4EA30: 83DF053C  lwz r30, 0x53c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4EA34: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4EA38: 4B8814E9  bl 0x822cff20
	ctx.lr = 0x82A4EA3C;
	sub_822CFF20(ctx, base);
	// 82A4EA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4EA40: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A4EA44: 4B8814DD  bl 0x822cff20
	ctx.lr = 0x82A4EA48;
	sub_822CFF20(ctx, base);
	// 82A4EA48: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A4EA4C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4EA50: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4EA54: 3BCB4338  addi r30, r11, 0x4338
	ctx.r[30].s64 = ctx.r[11].s64 + 17208;
	// 82A4EA58: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EA5C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A4EA60: 41980020  blt cr6, 0x82a4ea80
	if ctx.cr[6].lt {
	pc = 0x82A4EA80; continue 'dispatch;
	}
	// 82A4EA64: 4B8814BD  bl 0x822cff20
	ctx.lr = 0x82A4EA68;
	sub_822CFF20(ctx, base);
	// 82A4EA68: C01EFFF8  lfs f0, -8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EA6C: C1BEFFFC  lfs f13, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4EA70: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4EA74: EDBF6828  fsubs f13, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4EA78: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4EA7C: 48000010  b 0x82a4ea8c
	pc = 0x82A4EA8C; continue 'dispatch;
	// 82A4EA80: 4B8814A1  bl 0x822cff20
	ctx.lr = 0x82A4EA84;
	sub_822CFF20(ctx, base);
	// 82A4EA84: C01EFFF8  lfs f0, -8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EA88: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4EA8C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82A4EA90: 807F052C  lwz r3, 0x52c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4EA94: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A4EA98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4EA9C: 4B881685  bl 0x822d0120
	ctx.lr = 0x82A4EAA0;
	sub_822D0120(ctx, base);
	// 82A4EAA0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82A4EAA4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A4EAA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A4EAAC: 4842E875  bl 0x82e7d320
	ctx.lr = 0x82A4EAB0;
	sub_82E7D320(ctx, base);
	// 82A4EAB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4EAB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A4EAB8: 4842E999  bl 0x82e7d450
	ctx.lr = 0x82A4EABC;
	sub_82E7D450(ctx, base);
	// 82A4EABC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A4EAC0: 394005E0  li r10, 0x5e0
	ctx.r[10].s64 = 1504;
	// 82A4EAC4: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EAC8: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82A4EACC: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4EB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4EB88 size=2128
    let mut pc: u32 = 0x82A4EB88;
    'dispatch: loop {
        match pc {
            0x82A4EB88 => {
    //   block [0x82A4EB88..0x82A4F3D8)
	// 82A4EB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4EB8C: 487595BD  bl 0x831a8148
	ctx.lr = 0x82A4EB90;
	sub_831A8130(ctx, base);
	// 82A4EB90: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82A4EB94: 48759EE1  bl 0x831a8a74
	ctx.lr = 0x82A4EB98;
	sub_831A8A40(ctx, base);
	// 82A4EB98: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4EB9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4EBA0: 48705A61  bl 0x83154600
	ctx.lr = 0x82A4EBA4;
	sub_83154600(ctx, base);
	// 82A4EBA4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A4EBA8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A4EBAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A4EBB0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A4EBB4: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 82A4EBB8: 483A3041  bl 0x82df1bf8
	ctx.lr = 0x82A4EBBC;
	sub_82DF1BF8(ctx, base);
	// 82A4EBBC: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A4EBC0: 480F8681  bl 0x82b47240
	ctx.lr = 0x82A4EBC4;
	sub_82B47240(ctx, base);
	// 82A4EBC4: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82A4EBC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A4EBCC: 483A30C5  bl 0x82df1c90
	ctx.lr = 0x82A4EBD0;
	sub_82DF1C90(ctx, base);
	// 82A4EBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4EBD4: 4840ABA5  bl 0x82e59778
	ctx.lr = 0x82A4EBD8;
	sub_82E59778(ctx, base);
	// 82A4EBD8: C01F01A8  lfs f0, 0x1a8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EBDC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4EBE0: D01F01A8  stfs f0, 0x1a8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EBE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4EBE8: 4BA23711  bl 0x824722f8
	ctx.lr = 0x82A4EBEC;
	sub_824722F8(ctx, base);
	// 82A4EBEC: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4EBF0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4EBF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4EBF8: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A4EBFC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A4EC00: 419A0024  beq cr6, 0x82a4ec24
	if ctx.cr[6].eq {
	pc = 0x82A4EC24; continue 'dispatch;
	}
	// 82A4EC04: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4EC08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4EC0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4EC10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4EC14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4EC18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4EC1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4EC20: 4082FFE8  bne 0x82a4ec08
	if !ctx.cr[0].eq {
	pc = 0x82A4EC08; continue 'dispatch;
	}
	// 82A4EC24: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A4EC28: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A4EC2C: 4BAC089D  bl 0x8250f4c8
	ctx.lr = 0x82A4EC30;
	sub_8250F4C8(ctx, base);
	// 82A4EC30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4EC34: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82A4EC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4EC3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A4EC40: 409A0008  bne cr6, 0x82a4ec48
	if !ctx.cr[6].eq {
	pc = 0x82A4EC48; continue 'dispatch;
	}
	// 82A4EC44: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A4EC48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4EC4C: 3B960028  addi r28, r22, 0x28
	ctx.r[28].s64 = ctx.r[22].s64 + 40;
	// 82A4EC50: 3B410068  addi r26, r1, 0x68
	ctx.r[26].s64 = ctx.r[1].s64 + 104;
	// 82A4EC54: 4BAB9DC5  bl 0x82508a18
	ctx.lr = 0x82A4EC58;
	sub_82508A18(ctx, base);
	// 82A4EC58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4EC5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4EC60: 3B6BD590  addi r27, r11, -0x2a70
	ctx.r[27].s64 = ctx.r[11].s64 + -10864;
	// 82A4EC64: 38A001AD  li r5, 0x1ad
	ctx.r[5].s64 = 429;
	// 82A4EC68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A4EC6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A4EC70: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A4EC74: 48408375  bl 0x82e56fe8
	ctx.lr = 0x82A4EC78;
	sub_82E56FE8(ctx, base);
	// 82A4EC78: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A4EC7C: 483A3015  bl 0x82df1c90
	ctx.lr = 0x82A4EC80;
	sub_82DF1C90(ctx, base);
	// 82A4EC80: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A4EC84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4EC88: 419A0008  beq cr6, 0x82a4ec90
	if ctx.cr[6].eq {
	pc = 0x82A4EC90; continue 'dispatch;
	}
	// 82A4EC8C: 4B871C05  bl 0x822c0890
	ctx.lr = 0x82A4EC90;
	sub_822C0890(ctx, base);
	// 82A4EC90: 8B1D0034  lbz r24, 0x34(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A4EC94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4EC98: 419A000C  beq cr6, 0x82a4eca4
	if ctx.cr[6].eq {
	pc = 0x82A4ECA4; continue 'dispatch;
	}
	// 82A4EC9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4ECA0: 4B871BF1  bl 0x822c0890
	ctx.lr = 0x82A4ECA4;
	sub_822C0890(ctx, base);
	// 82A4ECA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4ECA8: 4BF3C241  bl 0x8298aee8
	ctx.lr = 0x82A4ECAC;
	sub_8298AEE8(ctx, base);
	// 82A4ECAC: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4ECB0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4ECB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4ECB8: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82A4ECBC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A4ECC0: 419A0024  beq cr6, 0x82a4ece4
	if ctx.cr[6].eq {
	pc = 0x82A4ECE4; continue 'dispatch;
	}
	// 82A4ECC4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4ECC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4ECCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4ECD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4ECD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4ECD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4ECDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4ECE0: 4082FFE8  bne 0x82a4ecc8
	if !ctx.cr[0].eq {
	pc = 0x82A4ECC8; continue 'dispatch;
	}
	// 82A4ECE4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A4ECE8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A4ECEC: 4BAC07DD  bl 0x8250f4c8
	ctx.lr = 0x82A4ECF0;
	sub_8250F4C8(ctx, base);
	// 82A4ECF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4ECF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4ECF8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A4ECFC: 409A0008  bne cr6, 0x82a4ed04
	if !ctx.cr[6].eq {
	pc = 0x82A4ED04; continue 'dispatch;
	}
	// 82A4ED00: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A4ED04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4ED08: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 82A4ED0C: 4BAB9D0D  bl 0x82508a18
	ctx.lr = 0x82A4ED10;
	sub_82508A18(ctx, base);
	// 82A4ED10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4ED14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A4ED18: 38A001B4  li r5, 0x1b4
	ctx.r[5].s64 = 436;
	// 82A4ED1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A4ED20: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A4ED24: 484082C5  bl 0x82e56fe8
	ctx.lr = 0x82A4ED28;
	sub_82E56FE8(ctx, base);
	// 82A4ED28: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A4ED2C: 483A2F65  bl 0x82df1c90
	ctx.lr = 0x82A4ED30;
	sub_82DF1C90(ctx, base);
	// 82A4ED30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A4ED34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4ED38: 419A0008  beq cr6, 0x82a4ed40
	if ctx.cr[6].eq {
	pc = 0x82A4ED40; continue 'dispatch;
	}
	// 82A4ED3C: 4B871B55  bl 0x822c0890
	ctx.lr = 0x82A4ED40;
	sub_822C0890(ctx, base);
	// 82A4ED40: 8B3D001C  lbz r25, 0x1c(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A4ED44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4ED48: 419A000C  beq cr6, 0x82a4ed54
	if ctx.cr[6].eq {
	pc = 0x82A4ED54; continue 'dispatch;
	}
	// 82A4ED4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4ED50: 4B871B41  bl 0x822c0890
	ctx.lr = 0x82A4ED54;
	sub_822C0890(ctx, base);
	// 82A4ED54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4ED58: 4BDB96A9  bl 0x82808400
	ctx.lr = 0x82A4ED5C;
	sub_82808400(ctx, base);
	// 82A4ED5C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4ED60: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4ED64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4ED68: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82A4ED6C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82A4ED70: 419A0024  beq cr6, 0x82a4ed94
	if ctx.cr[6].eq {
	pc = 0x82A4ED94; continue 'dispatch;
	}
	// 82A4ED74: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4ED78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4ED7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4ED80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4ED84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4ED88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4ED8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4ED90: 4082FFE8  bne 0x82a4ed78
	if !ctx.cr[0].eq {
	pc = 0x82A4ED78; continue 'dispatch;
	}
	// 82A4ED94: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A4ED98: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A4ED9C: 4BAC072D  bl 0x8250f4c8
	ctx.lr = 0x82A4EDA0;
	sub_8250F4C8(ctx, base);
	// 82A4EDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4EDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4EDA8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A4EDAC: 409A0008  bne cr6, 0x82a4edb4
	if !ctx.cr[6].eq {
	pc = 0x82A4EDB4; continue 'dispatch;
	}
	// 82A4EDB0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A4EDB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4EDB8: 3B410078  addi r26, r1, 0x78
	ctx.r[26].s64 = ctx.r[1].s64 + 120;
	// 82A4EDBC: 4BAB9C5D  bl 0x82508a18
	ctx.lr = 0x82A4EDC0;
	sub_82508A18(ctx, base);
	// 82A4EDC0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4EDC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A4EDC8: 38A001BB  li r5, 0x1bb
	ctx.r[5].s64 = 443;
	// 82A4EDCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A4EDD0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A4EDD4: 48408215  bl 0x82e56fe8
	ctx.lr = 0x82A4EDD8;
	sub_82E56FE8(ctx, base);
	// 82A4EDD8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A4EDDC: 483A2EB5  bl 0x82df1c90
	ctx.lr = 0x82A4EDE0;
	sub_82DF1C90(ctx, base);
	// 82A4EDE0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A4EDE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4EDE8: 419A0008  beq cr6, 0x82a4edf0
	if ctx.cr[6].eq {
	pc = 0x82A4EDF0; continue 'dispatch;
	}
	// 82A4EDEC: 4B871AA5  bl 0x822c0890
	ctx.lr = 0x82A4EDF0;
	sub_822C0890(ctx, base);
	// 82A4EDF0: 8B5D0018  lbz r26, 0x18(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A4EDF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4EDF8: 419A000C  beq cr6, 0x82a4ee04
	if ctx.cr[6].eq {
	pc = 0x82A4EE04; continue 'dispatch;
	}
	// 82A4EDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4EE00: 4B871A91  bl 0x822c0890
	ctx.lr = 0x82A4EE04;
	sub_822C0890(ctx, base);
	// 82A4EE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4EE08: 4BDC9971  bl 0x82818778
	ctx.lr = 0x82A4EE0C;
	sub_82818778(ctx, base);
	// 82A4EE0C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4EE10: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4EE14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4EE18: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A4EE1C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A4EE20: 419A0024  beq cr6, 0x82a4ee44
	if ctx.cr[6].eq {
	pc = 0x82A4EE44; continue 'dispatch;
	}
	// 82A4EE24: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A4EE28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4EE2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4EE30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4EE34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4EE38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4EE3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4EE40: 4082FFE8  bne 0x82a4ee28
	if !ctx.cr[0].eq {
	pc = 0x82A4EE28; continue 'dispatch;
	}
	// 82A4EE44: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A4EE48: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A4EE4C: 4BAC067D  bl 0x8250f4c8
	ctx.lr = 0x82A4EE50;
	sub_8250F4C8(ctx, base);
	// 82A4EE50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4EE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4EE58: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A4EE5C: 409A0008  bne cr6, 0x82a4ee64
	if !ctx.cr[6].eq {
	pc = 0x82A4EE64; continue 'dispatch;
	}
	// 82A4EE60: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A4EE64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4EE68: 3A810060  addi r20, r1, 0x60
	ctx.r[20].s64 = ctx.r[1].s64 + 96;
	// 82A4EE6C: 4BAB9BAD  bl 0x82508a18
	ctx.lr = 0x82A4EE70;
	sub_82508A18(ctx, base);
	// 82A4EE70: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A4EE74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A4EE78: 38A001C2  li r5, 0x1c2
	ctx.r[5].s64 = 450;
	// 82A4EE7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A4EE80: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82A4EE84: 48408165  bl 0x82e56fe8
	ctx.lr = 0x82A4EE88;
	sub_82E56FE8(ctx, base);
	// 82A4EE88: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A4EE8C: 483A2E05  bl 0x82df1c90
	ctx.lr = 0x82A4EE90;
	sub_82DF1C90(ctx, base);
	// 82A4EE90: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A4EE94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4EE98: 419A0008  beq cr6, 0x82a4eea0
	if ctx.cr[6].eq {
	pc = 0x82A4EEA0; continue 'dispatch;
	}
	// 82A4EE9C: 4B8719F5  bl 0x822c0890
	ctx.lr = 0x82A4EEA0;
	sub_822C0890(ctx, base);
	// 82A4EEA0: 8BBD0018  lbz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A4EEA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A4EEA8: 419A000C  beq cr6, 0x82a4eeb4
	if ctx.cr[6].eq {
	pc = 0x82A4EEB4; continue 'dispatch;
	}
	// 82A4EEAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4EEB0: 4B8719E1  bl 0x822c0890
	ctx.lr = 0x82A4EEB4;
	sub_822C0890(ctx, base);
	// 82A4EEB4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4EEB8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EEBC: 41820010  beq 0x82a4eecc
	if ctx.cr[0].eq {
	pc = 0x82A4EECC; continue 'dispatch;
	}
	// 82A4EEC0: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EEC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4EEC8: 40820008  bne 0x82a4eed0
	if !ctx.cr[0].eq {
	pc = 0x82A4EED0; continue 'dispatch;
	}
	// 82A4EECC: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82A4EED0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4EED4: 893F01A4  lbz r9, 0x1a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82A4EED8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A4EEDC: 3BCB431C  addi r30, r11, 0x431c
	ctx.r[30].s64 = ctx.r[11].s64 + 17180;
	// 82A4EEE0: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 82A4EEE4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A4EEE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4EEEC: C3A808A4  lfs f29, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A4EEF0: 41980080  blt cr6, 0x82a4ef70
	if ctx.cr[6].lt {
	pc = 0x82A4EF70; continue 'dispatch;
	}
	// 82A4EEF4: 419A006C  beq cr6, 0x82a4ef60
	if ctx.cr[6].eq {
	pc = 0x82A4EF60; continue 'dispatch;
	}
	// 82A4EEF8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4EEFC: 4198004C  blt cr6, 0x82a4ef48
	if ctx.cr[6].lt {
	pc = 0x82A4EF48; continue 'dispatch;
	}
	// 82A4EF00: 419A0028  beq cr6, 0x82a4ef28
	if ctx.cr[6].eq {
	pc = 0x82A4EF28; continue 'dispatch;
	}
	// 82A4EF04: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A4EF08: 41980018  blt cr6, 0x82a4ef20
	if ctx.cr[6].lt {
	pc = 0x82A4EF20; continue 'dispatch;
	}
	// 82A4EF0C: 409A00B4  bne cr6, 0x82a4efc0
	if !ctx.cr[6].eq {
	pc = 0x82A4EFC0; continue 'dispatch;
	}
	// 82A4EF10: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF14: 408200AC  bne 0x82a4efc0
	if !ctx.cr[0].eq {
	pc = 0x82A4EFC0; continue 'dispatch;
	}
	// 82A4EF18: 9AFF01A4  stb r23, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[23].u8 ) };
	// 82A4EF1C: 480000A0  b 0x82a4efbc
	pc = 0x82A4EFBC; continue 'dispatch;
	// 82A4EF20: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF24: 4BFFFFF0  b 0x82a4ef14
	pc = 0x82A4EF14; continue 'dispatch;
	// 82A4EF28: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF2C: 4182000C  beq 0x82a4ef38
	if ctx.cr[0].eq {
	pc = 0x82A4EF38; continue 'dispatch;
	}
	// 82A4EF30: D3BF01A8  stfs f29, 0x1a8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EF34: 9AFF01A4  stb r23, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[23].u8 ) };
	// 82A4EF38: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF3C: 4182005C  beq 0x82a4ef98
	if ctx.cr[0].eq {
	pc = 0x82A4EF98; continue 'dispatch;
	}
	// 82A4EF40: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A4EF44: 4800004C  b 0x82a4ef90
	pc = 0x82A4EF90; continue 'dispatch;
	// 82A4EF48: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF4C: 40820074  bne 0x82a4efc0
	if !ctx.cr[0].eq {
	pc = 0x82A4EFC0; continue 'dispatch;
	}
	// 82A4EF50: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EF54: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A4EF58: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82A4EF5C: 4800005C  b 0x82a4efb8
	pc = 0x82A4EFB8; continue 'dispatch;
	// 82A4EF60: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF64: 40820034  bne 0x82a4ef98
	if !ctx.cr[0].eq {
	pc = 0x82A4EF98; continue 'dispatch;
	}
	// 82A4EF68: 9AFF01A4  stb r23, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[23].u8 ) };
	// 82A4EF6C: 48000028  b 0x82a4ef94
	pc = 0x82A4EF94; continue 'dispatch;
	// 82A4EF70: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF74: 41820010  beq 0x82a4ef84
	if ctx.cr[0].eq {
	pc = 0x82A4EF84; continue 'dispatch;
	}
	// 82A4EF78: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A4EF7C: D3BF01A8  stfs f29, 0x1a8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EF80: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 82A4EF84: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF88: 41820010  beq 0x82a4ef98
	if ctx.cr[0].eq {
	pc = 0x82A4EF98; continue 'dispatch;
	}
	// 82A4EF8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A4EF90: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 82A4EF94: D3BF01A8  stfs f29, 0x1a8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EF98: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EF9C: 41820010  beq 0x82a4efac
	if ctx.cr[0].eq {
	pc = 0x82A4EFAC; continue 'dispatch;
	}
	// 82A4EFA0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A4EFA4: D3BF01A8  stfs f29, 0x1a8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EFA8: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 82A4EFAC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4EFB0: 41820010  beq 0x82a4efc0
	if ctx.cr[0].eq {
	pc = 0x82A4EFC0; continue 'dispatch;
	}
	// 82A4EFB4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A4EFB8: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 82A4EFBC: D3BF01A8  stfs f29, 0x1a8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82A4EFC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4EFC4: C1B50010  lfs f13, 0x10(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4EFC8: C01EFFDC  lfs f0, -0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4EFCC: FD80E890  fmr f12, f29
	ctx.f[12].f64 = ctx.f[29].f64;
	// 82A4EFD0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4EFD4: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A4EFD8: 41980010  blt cr6, 0x82a4efe8
	if ctx.cr[6].lt {
	pc = 0x82A4EFE8; continue 'dispatch;
	}
	// 82A4EFDC: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4EFE0: ED7C0028  fsubs f11, f28, f0
	ctx.f[11].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4EFE4: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A4EFE8: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4EFEC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A4EFF0: 41990010  bgt cr6, 0x82a4f000
	if ctx.cr[6].gt {
	pc = 0x82A4F000; continue 'dispatch;
	}
	// 82A4EFF4: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A4EFF8: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4EFFC: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4F000: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82A4F004: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4F008: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 82A4F00C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4F010: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4F014: C36A9450  lfs f27, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82A4F018: 419800C0  blt cr6, 0x82a4f0d8
	if ctx.cr[6].lt {
	pc = 0x82A4F0D8; continue 'dispatch;
	}
	// 82A4F01C: 419A00A4  beq cr6, 0x82a4f0c0
	if ctx.cr[6].eq {
	pc = 0x82A4F0C0; continue 'dispatch;
	}
	// 82A4F020: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4F024: 41980094  blt cr6, 0x82a4f0b8
	if ctx.cr[6].lt {
	pc = 0x82A4F0B8; continue 'dispatch;
	}
	// 82A4F028: 419A0024  beq cr6, 0x82a4f04c
	if ctx.cr[6].eq {
	pc = 0x82A4F04C; continue 'dispatch;
	}
	// 82A4F02C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A4F030: 41980014  blt cr6, 0x82a4f044
	if ctx.cr[6].lt {
	pc = 0x82A4F044; continue 'dispatch;
	}
	// 82A4F034: 409A00AC  bne cr6, 0x82a4f0e0
	if !ctx.cr[6].eq {
	pc = 0x82A4F0E0; continue 'dispatch;
	}
	// 82A4F038: C01EFFF4  lfs f0, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F03C: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4F040: 480000A0  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F044: C3FEFFF0  lfs f31, -0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4F048: 48000098  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F04C: C01F01A8  lfs f0, 0x1a8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F050: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F054: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4F058: 41990080  bgt cr6, 0x82a4f0d8
	if ctx.cr[6].gt {
	pc = 0x82A4F0D8; continue 'dispatch;
	}
	// 82A4F05C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82A4F060: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A4F064: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F068: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4F06C: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82A4F070: 48759D59  bl 0x831a8dc8
	ctx.lr = 0x82A4F074;
	sub_831A8DC8(ctx, base);
	// 82A4F074: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F078: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4F07C: C19F019C  lfs f12, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F084: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F088: EFEC037A  fmadds f31, f12, f13, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4F08C: 4840A6ED  bl 0x82e59778
	ctx.lr = 0x82A4F090;
	sub_82E59778(ctx, base);
	// 82A4F090: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82A4F094: 4099001C  ble cr6, 0x82a4f0b0
	if !ctx.cr[6].gt {
	pc = 0x82A4F0B0; continue 'dispatch;
	}
	// 82A4F098: C01F018C  lfs f0, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F0A0: EFE0F828  fsubs f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A4F0A4: 4840A6D5  bl 0x82e59778
	ctx.lr = 0x82A4F0A8;
	sub_82E59778(ctx, base);
	// 82A4F0A8: EFFF0824  fdivs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[1].f64) as f32) as f64;
	// 82A4F0AC: 48000034  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F0B0: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 82A4F0B4: 4800002C  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F0B8: C3FEFFE8  lfs f31, -0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4F0BC: 48000024  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F0C4: 4840A6B5  bl 0x82e59778
	ctx.lr = 0x82A4F0C8;
	sub_82E59778(ctx, base);
	// 82A4F0C8: C1BF0198  lfs f13, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F0CC: C01EFFE4  lfs f0, -0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F0D0: EFE1683C  fnmsubs f31, f1, f0, f13
	ctx.f[31].f64 = -(((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4F0D4: 4800000C  b 0x82a4f0e0
	pc = 0x82A4F0E0; continue 'dispatch;
	// 82A4F0D8: C01EFFE0  lfs f0, -0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F0DC: EFE00332  fmuls f31, f0, f12
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A4F0E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F0E4: 4840A695  bl 0x82e59778
	ctx.lr = 0x82A4F0E8;
	sub_82E59778(ctx, base);
	// 82A4F0E8: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F0EC: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F0F0: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4F0F4: D3FF0198  stfs f31, 0x198(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82A4F0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F0FC: 4840A67D  bl 0x82e59778
	ctx.lr = 0x82A4F100;
	sub_82E59778(ctx, base);
	// 82A4F100: C01F0194  lfs f0, 0x194(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F104: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F108: C01EFFF8  lfs f0, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F10C: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82A4F110: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4F114: FF0CE000  fcmpu cr6, f12, f28
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[28].f64);
	// 82A4F118: 40990008  ble cr6, 0x82a4f120
	if !ctx.cr[6].gt {
	pc = 0x82A4F120; continue 'dispatch;
	}
	// 82A4F11C: FD80E090  fmr f12, f28
	ctx.f[12].f64 = ctx.f[28].f64;
	// 82A4F120: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82A4F124: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F128: C1BEFFFC  lfs f13, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F12C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82A4F130: 409A0018  bne cr6, 0x82a4f148
	if !ctx.cr[6].eq {
	pc = 0x82A4F148; continue 'dispatch;
	}
	// 82A4F134: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A4F138: C15F01A0  lfs f10, 0x1a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A4F13C: C16BDF44  lfs f11, -0x20bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8380 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4F140: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4F144: EDAB6ABA  fmadds f13, f11, f10, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4F148: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F14C: ED6B033A  fmadds f11, f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4F150: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A4F154: 41980008  blt cr6, 0x82a4f15c
	if ctx.cr[6].lt {
	pc = 0x82A4F15C; continue 'dispatch;
	}
	// 82A4F158: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	// 82A4F15C: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4F160: ED4B0028  fsubs f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F164: EC0A033A  fmadds f0, f10, f12, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4F168: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82A4F16C: 40990008  ble cr6, 0x82a4f174
	if !ctx.cr[6].gt {
	pc = 0x82A4F174; continue 'dispatch;
	}
	// 82A4F170: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 82A4F174: C19F018C  lfs f12, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F178: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82A4F17C: 40980008  bge cr6, 0x82a4f184
	if !ctx.cr[6].lt {
	pc = 0x82A4F184; continue 'dispatch;
	}
	// 82A4F180: D1BF018C  stfs f13, 0x18c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4F184: C1BF018C  lfs f13, 0x18c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F188: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4F18C: 40990008  ble cr6, 0x82a4f194
	if !ctx.cr[6].gt {
	pc = 0x82A4F194; continue 'dispatch;
	}
	// 82A4F190: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A4F194: 8076053C  lwz r3, 0x53c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1340 as u32) ) } as u64;
	// 82A4F198: 4B880D89  bl 0x822cff20
	ctx.lr = 0x82A4F19C;
	sub_822CFF20(ctx, base);
	// 82A4F19C: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F1A0: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1A4: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F1A8: 4B880D89  bl 0x822cff30
	ctx.lr = 0x82A4F1AC;
	sub_822CFF30(ctx, base);
	// 82A4F1AC: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1B0: 4B880D71  bl 0x822cff20
	ctx.lr = 0x82A4F1B4;
	sub_822CFF20(ctx, base);
	// 82A4F1B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4F1B8: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1BC: C3CB9524  lfs f30, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4F1C0: EFE1F02A  fadds f31, f1, f30
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[30].f64) as f32) as f64;
	// 82A4F1C4: 4B880D4D  bl 0x822cff10
	ctx.lr = 0x82A4F1C8;
	sub_822CFF10(ctx, base);
	// 82A4F1C8: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82A4F1CC: 41980010  blt cr6, 0x82a4f1dc
	if ctx.cr[6].lt {
	pc = 0x82A4F1DC; continue 'dispatch;
	}
	// 82A4F1D0: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1D4: 4B880D3D  bl 0x822cff10
	ctx.lr = 0x82A4F1D8;
	sub_822CFF10(ctx, base);
	// 82A4F1D8: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A4F1DC: 38E10190  addi r7, r1, 0x190
	ctx.r[7].s64 = ctx.r[1].s64 + 400;
	// 82A4F1E0: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1E4: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 82A4F1E8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4F1EC: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 82A4F1F0: 4B880F31  bl 0x822d0120
	ctx.lr = 0x82A4F1F4;
	sub_822D0120(ctx, base);
	// 82A4F1F4: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F1F8: 4B880D29  bl 0x822cff20
	ctx.lr = 0x82A4F1FC;
	sub_822CFF20(ctx, base);
	// 82A4F1FC: EFE1F028  fsubs f31, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A4F200: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82A4F204: 40980010  bge cr6, 0x82a4f214
	if !ctx.cr[6].lt {
	pc = 0x82A4F214; continue 'dispatch;
	}
	// 82A4F208: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F20C: 4B880D05  bl 0x822cff10
	ctx.lr = 0x82A4F210;
	sub_822CFF10(ctx, base);
	// 82A4F210: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A4F214: 38E10160  addi r7, r1, 0x160
	ctx.r[7].s64 = ctx.r[1].s64 + 352;
	// 82A4F218: 8076052C  lwz r3, 0x52c(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(1324 as u32) ) } as u64;
	// 82A4F21C: 38C10170  addi r6, r1, 0x170
	ctx.r[6].s64 = ctx.r[1].s64 + 368;
	// 82A4F220: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A4F224: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82A4F228: 4B880EF9  bl 0x822d0120
	ctx.lr = 0x82A4F22C;
	sub_822D0120(ctx, base);
	// 82A4F22C: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82A4F230: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82A4F234: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82A4F238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4F23C: 4842E405  bl 0x82e7d640
	ctx.lr = 0x82A4F240;
	sub_82E7D640(ctx, base);
	// 82A4F240: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4F244: 39410150  addi r10, r1, 0x150
	ctx.r[10].s64 = ctx.r[1].s64 + 336;
	// 82A4F248: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 82A4F24C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A4F250: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4F3D8 size=36
    let mut pc: u32 = 0x82A4F3D8;
    'dispatch: loop {
        match pc {
            0x82A4F3D8 => {
    //   block [0x82A4F3D8..0x82A4F3FC)
	// 82A4F3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4F3E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F3E4: 4870521D  bl 0x83154600
	ctx.lr = 0x82A4F3E8;
	sub_83154600(ctx, base);
	// 82A4F3E8: 4BFE61A1  bl 0x82a35588
	ctx.lr = 0x82A4F3EC;
	sub_82A35588(ctx, base);
	// 82A4F3EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4F3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4F3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4F3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F400 size=264
    let mut pc: u32 = 0x82A4F400;
    'dispatch: loop {
        match pc {
            0x82A4F400 => {
    //   block [0x82A4F400..0x82A4F508)
	// 82A4F400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4F408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4F40C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4F410: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A4F414: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F41C: 487051E5  bl 0x83154600
	ctx.lr = 0x82A4F420;
	sub_83154600(ctx, base);
	// 82A4F420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F424: 4BFFF765  bl 0x82a4eb88
	ctx.lr = 0x82A4F428;
	sub_82A4EB88(ctx, base);
	// 82A4F428: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F430: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4F434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4F438: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4F43C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A4F440: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A4F444: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A4F448: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A4F44C: 4BFFF355  bl 0x82a4e7a0
	ctx.lr = 0x82A4F450;
	sub_82A4E7A0(ctx, base);
	// 82A4F450: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A4F454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F458: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 82A4F45C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A4F460: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A4F464: 4BFFF355  bl 0x82a4e7b8
	ctx.lr = 0x82A4F468;
	sub_82A4E7B8(ctx, base);
	// 82A4F468: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A4F46C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A4F470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F474: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4F478: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A4F47C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4F480: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4F484: 4BFFF31D  bl 0x82a4e7a0
	ctx.lr = 0x82A4F488;
	sub_82A4E7A0(ctx, base);
	// 82A4F488: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A4F48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F490: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4F494: 4BFFF325  bl 0x82a4e7b8
	ctx.lr = 0x82A4F498;
	sub_82A4E7B8(ctx, base);
	// 82A4F498: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A4F49C: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A4F4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F4A4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A4F4A8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A4F4AC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A4F4B0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A4F4B4: 4BFFF2ED  bl 0x82a4e7a0
	ctx.lr = 0x82A4F4B8;
	sub_82A4E7A0(ctx, base);
	// 82A4F4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F4BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A4F4C0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A4F4C4: 4BFFF2F5  bl 0x82a4e7b8
	ctx.lr = 0x82A4F4C8;
	sub_82A4E7B8(ctx, base);
	// 82A4F4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F4CC: 4840A295  bl 0x82e59760
	ctx.lr = 0x82A4F4D0;
	sub_82E59760(ctx, base);
	// 82A4F4D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F4D4: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F4D8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A4F4DC: 40990008  ble cr6, 0x82a4f4e4
	if !ctx.cr[6].gt {
	pc = 0x82A4F4E4; continue 'dispatch;
	}
	// 82A4F4E0: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82A4F4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F4E8: 4BFFF309  bl 0x82a4e7f0
	ctx.lr = 0x82A4F4EC;
	sub_82A4E7F0(ctx, base);
	// 82A4F4EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A4F4F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4F4F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4F4F8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A4F4FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4F500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4F504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F508 size=156
    let mut pc: u32 = 0x82A4F508;
    'dispatch: loop {
        match pc {
            0x82A4F508 => {
    //   block [0x82A4F508..0x82A4F5A4)
	// 82A4F508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F50C: 48758C61  bl 0x831a816c
	ctx.lr = 0x82A4F510;
	sub_831A8130(ctx, base);
	// 82A4F510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F518: 487050E9  bl 0x83154600
	ctx.lr = 0x82A4F51C;
	sub_83154600(ctx, base);
	// 82A4F51C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4F520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F524: 4BFFF3F5  bl 0x82a4e918
	ctx.lr = 0x82A4F528;
	sub_82A4E918(ctx, base);
	// 82A4F528: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A4F52C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F530: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A4F534: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4F538: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A4F53C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4F540: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4F544: 4BFE905D  bl 0x82a385a0
	ctx.lr = 0x82A4F548;
	sub_82A385A0(ctx, base);
	// 82A4F548: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A4F54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4F550: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A4F554: 483A44B5  bl 0x82df3a08
	ctx.lr = 0x82A4F558;
	sub_82DF3A08(ctx, base);
	// 82A4F558: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4F55C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4F560: 809D04EC  lwz r4, 0x4ec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4F564: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4F568: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4F56C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4F570: 48163E09  bl 0x82bb3378
	ctx.lr = 0x82A4F574;
	sub_82BB3378(ctx, base);
	// 82A4F574: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4F578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4F57C: 419A0008  beq cr6, 0x82a4f584
	if ctx.cr[6].eq {
	pc = 0x82A4F584; continue 'dispatch;
	}
	// 82A4F580: 4B871311  bl 0x822c0890
	ctx.lr = 0x82A4F584;
	sub_822C0890(ctx, base);
	// 82A4F584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4F588: 483A3EA1  bl 0x82df3428
	ctx.lr = 0x82A4F58C;
	sub_82DF3428(ctx, base);
	// 82A4F58C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F590: 9BDF01BC  stb r30, 0x1bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[30].u8 ) };
	// 82A4F594: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F598: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A4F59C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4F5A0: 48758C1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F5A8 size=540
    let mut pc: u32 = 0x82A4F5A8;
    'dispatch: loop {
        match pc {
            0x82A4F5A8 => {
    //   block [0x82A4F5A8..0x82A4F7C4)
	// 82A4F5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F5AC: 48758BB9  bl 0x831a8164
	ctx.lr = 0x82A4F5B0;
	sub_831A8130(ctx, base);
	// 82A4F5B0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A4F5B4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A4F5B8: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F5BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F5C0: 48705041  bl 0x83154600
	ctx.lr = 0x82A4F5C4;
	sub_83154600(ctx, base);
	// 82A4F5C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4F5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F5CC: 4840A1AD  bl 0x82e59778
	ctx.lr = 0x82A4F5D0;
	sub_82E59778(ctx, base);
	// 82A4F5D0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A4F5D4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A4F5D8: C01F01B8  lfs f0, 0x1b8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F5DC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4F5E0: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F5E4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A4F5E8: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A4F5EC: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82A4F5F0: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4F5F4: 3BAB4348  addi r29, r11, 0x4348
	ctx.r[29].s64 = ctx.r[11].s64 + 17224;
	// 82A4F5F8: C3C708A8  lfs f30, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A4F5FC: 3B6AD2B4  addi r27, r10, -0x2d4c
	ctx.r[27].s64 = ctx.r[10].s64 + -11596;
	// 82A4F600: 3B896910  addi r28, r9, 0x6910
	ctx.r[28].s64 = ctx.r[9].s64 + 26896;
	// 82A4F604: 897F01BC  lbz r11, 0x1bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82A4F608: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F60C: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82A4F610: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82A4F614: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82A4F618: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A4F61C: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4F620: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 82A4F624: 41980008  blt cr6, 0x82a4f62c
	if ctx.cr[6].lt {
	pc = 0x82A4F62C; continue 'dispatch;
	}
	// 82A4F628: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	// 82A4F62C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F630: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F634: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F638: C1BF01B8  lfs f13, 0x1b8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F63C: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4F640: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4F644: 41980170  blt cr6, 0x82a4f7b4
	if ctx.cr[6].lt {
	pc = 0x82A4F7B4; continue 'dispatch;
	}
	// 82A4F648: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F64C: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A4F650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4F654: 80BE0584  lwz r5, 0x584(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1412 as u32) ) } as u64;
	// 82A4F658: 809E04E4  lwz r4, 0x4e4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1252 as u32) ) } as u64;
	// 82A4F65C: 483C5CDD  bl 0x82e15338
	ctx.lr = 0x82A4F660;
	sub_82E15338(ctx, base);
	// 82A4F660: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4F664: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4F668: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A4F66C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4F670: 4E800421  bctrl
	ctx.lr = 0x82A4F674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4F674: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A4F678: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A4F67C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A4F680: 4842C649  bl 0x82e7bcc8
	ctx.lr = 0x82A4F684;
	sub_82E7BCC8(ctx, base);
	// 82A4F684: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4F688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4F68C: 419A0008  beq cr6, 0x82a4f694
	if ctx.cr[6].eq {
	pc = 0x82A4F694; continue 'dispatch;
	}
	// 82A4F690: 4B871201  bl 0x822c0890
	ctx.lr = 0x82A4F694;
	sub_822C0890(ctx, base);
	// 82A4F694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4F698: 4BAC2451  bl 0x82511ae8
	ctx.lr = 0x82A4F69C;
	sub_82511AE8(ctx, base);
	// 82A4F69C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A4F6A0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A4F6A4: 4BAC2A75  bl 0x82512118
	ctx.lr = 0x82A4F6A8;
	sub_82512118(ctx, base);
	// 82A4F6A8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4F6AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4F6B0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A4F6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4F6B8: 4E800421  bctrl
	ctx.lr = 0x82A4F6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4F6BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4F6C0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A4F6C4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A4F6C8: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82A4F6CC: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82A4F6D0: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 82A4F6D4: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82A4F6D8: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4F6DC: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4F6E0: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82A4F6E4: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82A4F6E8: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4F6EC: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4F6F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4F7C8 size=60
    let mut pc: u32 = 0x82A4F7C8;
    'dispatch: loop {
        match pc {
            0x82A4F7C8 => {
    //   block [0x82A4F7C8..0x82A4F804)
	// 82A4F7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4F7D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4F7D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F7D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F7DC: 4BFFFC25  bl 0x82a4f400
	ctx.lr = 0x82A4F7E0;
	sub_82A4F400(ctx, base);
	// 82A4F7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F7E4: 4B87081D  bl 0x822c0000
	ctx.lr = 0x82A4F7E8;
	sub_822C0000(ctx, base);
	// 82A4F7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F7EC: 4BFFFDBD  bl 0x82a4f5a8
	ctx.lr = 0x82A4F7F0;
	sub_82A4F5A8(ctx, base);
	// 82A4F7F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4F7F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4F7F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4F7FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4F800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F808 size=92
    let mut pc: u32 = 0x82A4F808;
    'dispatch: loop {
        match pc {
            0x82A4F808 => {
    //   block [0x82A4F808..0x82A4F864)
	// 82A4F808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4F810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4F814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F81C: 4BFE269D  bl 0x82a31eb8
	ctx.lr = 0x82A4F820;
	sub_82A31EB8(ctx, base);
	// 82A4F820: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A4F824: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4F828: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4F82C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A4F830: 3929D5E0  addi r9, r9, -0x2a20
	ctx.r[9].s64 = ctx.r[9].s64 + -10784;
	// 82A4F834: C00B6A70  lfs f0, 0x6a70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F838: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A4F83C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F840: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4F844: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4F848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4F84C: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4F850: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4F854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4F858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4F85C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4F860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4F868 size=28
    let mut pc: u32 = 0x82A4F868;
    'dispatch: loop {
        match pc {
            0x82A4F868 => {
    //   block [0x82A4F868..0x82A4F884)
	// 82A4F868: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F86C: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4F870: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F874: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F878: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4F87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4F880: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F884(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4F884 size=16
    let mut pc: u32 = 0x82A4F884;
    'dispatch: loop {
        match pc {
            0x82A4F884 => {
    //   block [0x82A4F884..0x82A4F894)
	// 82A4F884: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4F888: C00B4368  lfs f0, 0x4368(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F88C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4F890: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F894(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4F894 size=20
    let mut pc: u32 = 0x82A4F894;
    'dispatch: loop {
        match pc {
            0x82A4F894 => {
    //   block [0x82A4F894..0x82A4F8A8)
	// 82A4F894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A4F898: EC0D0028  fsubs f0, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F89C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4F8A0: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A4F8A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F8A8 size=284
    let mut pc: u32 = 0x82A4F8A8;
    'dispatch: loop {
        match pc {
            0x82A4F8A8 => {
    //   block [0x82A4F8A8..0x82A4F9C4)
	// 82A4F8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F8AC: 487588C1  bl 0x831a816c
	ctx.lr = 0x82A4F8B0;
	sub_831A8130(ctx, base);
	// 82A4F8B0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4F8B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F8B8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A4F8BC: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4F8C0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A4F8C4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4F8C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4F8CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A4F8D0: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4F8D4: 3BEA4358  addi r31, r10, 0x4358
	ctx.r[31].s64 = ctx.r[10].s64 + 17240;
	// 82A4F8D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4F8DC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82A4F8E0: 41980080  blt cr6, 0x82a4f960
	if ctx.cr[6].lt {
	pc = 0x82A4F960; continue 'dispatch;
	}
	// 82A4F8E4: 409A00B8  bne cr6, 0x82a4f99c
	if !ctx.cr[6].eq {
	pc = 0x82A4F99C; continue 'dispatch;
	}
	// 82A4F8E8: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F8EC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A4F8F0: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F8F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A4F8F8: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4F8FC: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F900: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F904: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A4F908: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4F90C: 487594BD  bl 0x831a8dc8
	ctx.lr = 0x82A4F910;
	sub_831A8DC8(ctx, base);
	// 82A4F910: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4F914: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F918: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F91C: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4F920: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A4F924: 41820008  beq 0x82a4f92c
	if ctx.cr[0].eq {
	pc = 0x82A4F92C; continue 'dispatch;
	}
	// 82A4F928: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4F92C: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F930: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4F934: C18BDB98  lfs f12, -0x2468(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F938: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 82A4F93C: 40980008  bge cr6, 0x82a4f944
	if !ctx.cr[6].lt {
	pc = 0x82A4F944; continue 'dispatch;
	}
	// 82A4F940: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4F944: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4F948: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4F94C: C18B0A98  lfs f12, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F950: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 82A4F954: 40990048  ble cr6, 0x82a4f99c
	if !ctx.cr[6].gt {
	pc = 0x82A4F99C; continue 'dispatch;
	}
	// 82A4F958: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A4F95C: 48000040  b 0x82a4f99c
	pc = 0x82A4F99C; continue 'dispatch;
	// 82A4F960: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F964: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F968: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F96C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4F970: C18B08A8  lfs f12, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F974: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82A4F978: 40980008  bge cr6, 0x82a4f980
	if !ctx.cr[6].lt {
	pc = 0x82A4F980; continue 'dispatch;
	}
	// 82A4F97C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82A4F980: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F984: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A4F988: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F98C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4F990: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A4F994: 41820008  beq 0x82a4f99c
	if ctx.cr[0].eq {
	pc = 0x82A4F99C; continue 'dispatch;
	}
	// 82A4F998: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4F99C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F9A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4F9A4: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4F9A8: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4F9AC: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4F9B0: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4F9B4: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4F9B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A4F9BC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A4F9C0: 487587FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4F9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4F9C8 size=104
    let mut pc: u32 = 0x82A4F9C8;
    'dispatch: loop {
        match pc {
            0x82A4F9C8 => {
    //   block [0x82A4F9C8..0x82A4FA30)
	// 82A4F9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4F9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4F9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4F9D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4F9D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4F9DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4F9E0: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82A4F9E4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A4F9E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4F9EC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4F9F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4F9F4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4F9F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A4F9FC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A4FA00: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A4FA04: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A4FA08: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FA0C: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FA10: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4FA14: 4842D22D  bl 0x82e7cc40
	ctx.lr = 0x82A4FA18;
	sub_82E7CC40(ctx, base);
	// 82A4FA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FA1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4FA20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4FA24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4FA28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4FA2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4FA30 size=368
    let mut pc: u32 = 0x82A4FA30;
    'dispatch: loop {
        match pc {
            0x82A4FA30 => {
    //   block [0x82A4FA30..0x82A4FBA0)
	// 82A4FA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4FA34: 48758739  bl 0x831a816c
	ctx.lr = 0x82A4FA38;
	sub_831A8130(ctx, base);
	// 82A4FA38: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A4FA3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4FA40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4FA44: 48704BBD  bl 0x83154600
	ctx.lr = 0x82A4FA48;
	sub_83154600(ctx, base);
	// 82A4FA48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4FA4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FA50: 4BFFF139  bl 0x82a4eb88
	ctx.lr = 0x82A4FA54;
	sub_82A4EB88(ctx, base);
	// 82A4FA54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4FA58: C3EB9524  lfs f31, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A4FA5C: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A4FA60: 896B0014  lbz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4FA64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4FA68: 409A0070  bne cr6, 0x82a4fad8
	if !ctx.cr[6].eq {
	pc = 0x82A4FAD8; continue 'dispatch;
	}
	// 82A4FA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FA70: 48409D09  bl 0x82e59778
	ctx.lr = 0x82A4FA74;
	sub_82E59778(ctx, base);
	// 82A4FA74: C01F01B8  lfs f0, 0x1b8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FA78: ED81002A  fadds f12, f1, f0
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4FA7C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FA80: D19F01B8  stfs f12, 0x1b8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A4FA84: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82A4FA88: 3BAB436C  addi r29, r11, 0x436c
	ctx.r[29].s64 = ctx.r[11].s64 + 17260;
	// 82A4FA8C: C00B436C  lfs f0, 0x436c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FA90: C1AADFAC  lfs f13, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FA94: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A4FA98: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A4FA9C: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A4FAA0: 48759329  bl 0x831a8dc8
	ctx.lr = 0x82A4FAA4;
	sub_831A8DC8(ctx, base);
	// 82A4FAA4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A4FAA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4FAAC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A4FAB0: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FAB4: 39200610  li r9, 0x610
	ctx.r[9].s64 = 1552;
	// 82A4FAB8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FABC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A4FAC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A4FAC4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A4FAC8: EC0D0332  fmuls f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A4FACC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A4FAD0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4FBA0 size=140
    let mut pc: u32 = 0x82A4FBA0;
    'dispatch: loop {
        match pc {
            0x82A4FBA0 => {
    //   block [0x82A4FBA0..0x82A4FC2C)
	// 82A4FBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4FBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4FBA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4FBAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4FBB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4FBB4: 4BFFFE7D  bl 0x82a4fa30
	ctx.lr = 0x82A4FBB8;
	sub_82A4FA30(ctx, base);
	// 82A4FBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FBBC: 4B870445  bl 0x822c0000
	ctx.lr = 0x82A4FBC0;
	sub_822C0000(ctx, base);
	// 82A4FBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FBC4: 48704A3D  bl 0x83154600
	ctx.lr = 0x82A4FBC8;
	sub_83154600(ctx, base);
	// 82A4FBC8: 8963054C  lbz r11, 0x54c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A4FBCC: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82A4FBD0: 41980048  blt cr6, 0x82a4fc18
	if ctx.cr[6].lt {
	pc = 0x82A4FC18; continue 'dispatch;
	}
	// 82A4FBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FBD8: 48409BA1  bl 0x82e59778
	ctx.lr = 0x82A4FBDC;
	sub_82E59778(ctx, base);
	// 82A4FBDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4FBE0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FBE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FBE8: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FBEC: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A4FBF0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FBF4: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A4FBF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4FBFC: 41990014  bgt cr6, 0x82a4fc10
	if ctx.cr[6].gt {
	pc = 0x82A4FC10; continue 'dispatch;
	}
	// 82A4FC00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4FC04: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FC08: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A4FC0C: 40980008  bge cr6, 0x82a4fc14
	if !ctx.cr[6].lt {
	pc = 0x82A4FC14; continue 'dispatch;
	}
	// 82A4FC10: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82A4FC14: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A4FC18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4FC1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4FC20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4FC24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4FC28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A4FC30 size=196
    let mut pc: u32 = 0x82A4FC30;
    'dispatch: loop {
        match pc {
            0x82A4FC30 => {
    //   block [0x82A4FC30..0x82A4FCF4)
	// 82A4FC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4FC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4FC38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A4FC3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4FC40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4FC44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4FC48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4FC4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A4FC50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A4FC54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4FC58: 4B870CE1  bl 0x822c0938
	ctx.lr = 0x82A4FC5C;
	sub_822C0938(ctx, base);
	// 82A4FC5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4FC60: 41820028  beq 0x82a4fc88
	if ctx.cr[0].eq {
	pc = 0x82A4FC88; continue 'dispatch;
	}
	// 82A4FC64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4FC68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A4FC6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A4FC70: 392BD60C  addi r9, r11, -0x29f4
	ctx.r[9].s64 = ctx.r[11].s64 + -10740;
	// 82A4FC74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A4FC78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A4FC7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4FC80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A4FC84: 48000008  b 0x82a4fc8c
	pc = 0x82A4FC8C; continue 'dispatch;
	// 82A4FC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4FC8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A4FC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4FC94: 409A0044  bne cr6, 0x82a4fcd8
	if !ctx.cr[6].eq {
	pc = 0x82A4FCD8; continue 'dispatch;
	}
	// 82A4FC98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A4FC9C: 419A001C  beq cr6, 0x82a4fcb8
	if ctx.cr[6].eq {
	pc = 0x82A4FCB8; continue 'dispatch;
	}
	// 82A4FCA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4FCA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A4FCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FCAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4FCB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A4FCB4: 4E800421  bctrl
	ctx.lr = 0x82A4FCB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A4FCB8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FCBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FCC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4FCC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A4FCC8: 816B4374  lwz r11, 0x4374(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17268 as u32) ) } as u64;
	// 82A4FCCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4FCD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4FCD4: 4B87032D  bl 0x822c0000
	ctx.lr = 0x82A4FCD8;
	sub_822C0000(ctx, base);
	// 82A4FCD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4FCDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A4FCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4FCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4FCE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A4FCEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4FCF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4FCF8 size=336
    let mut pc: u32 = 0x82A4FCF8;
    'dispatch: loop {
        match pc {
            0x82A4FCF8 => {
    //   block [0x82A4FCF8..0x82A4FE48)
	// 82A4FCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4FCFC: 48758471  bl 0x831a816c
	ctx.lr = 0x82A4FD00;
	sub_831A8130(ctx, base);
	// 82A4FD00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4FD04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A4FD08: 487048F9  bl 0x83154600
	ctx.lr = 0x82A4FD0C;
	sub_83154600(ctx, base);
	// 82A4FD0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A4FD10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A4FD14: 4BFFEC05  bl 0x82a4e918
	ctx.lr = 0x82A4FD18;
	sub_82A4E918(ctx, base);
	// 82A4FD18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4FD1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A4FD20: 388BD620  addi r4, r11, -0x29e0
	ctx.r[4].s64 = ctx.r[11].s64 + -10720;
	// 82A4FD24: 38A000F9  li r5, 0xf9
	ctx.r[5].s64 = 249;
	// 82A4FD28: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A4FD2C: 4B8706AD  bl 0x822c03d8
	ctx.lr = 0x82A4FD30;
	sub_822C03D8(ctx, base);
	// 82A4FD30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A4FD34: 41820010  beq 0x82a4fd44
	if ctx.cr[0].eq {
	pc = 0x82A4FD44; continue 'dispatch;
	}
	// 82A4FD38: 4BFFFAD1  bl 0x82a4f808
	ctx.lr = 0x82A4FD3C;
	sub_82A4F808(ctx, base);
	// 82A4FD3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4FD40: 48000008  b 0x82a4fd48
	pc = 0x82A4FD48; continue 'dispatch;
	// 82A4FD44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A4FD48: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A4FD4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4FD50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4FD54: 4BFFFEDD  bl 0x82a4fc30
	ctx.lr = 0x82A4FD58;
	sub_82A4FC30(ctx, base);
	// 82A4FD58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A4FD5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A4FD60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A4FD64: 4B87029D  bl 0x822c0000
	ctx.lr = 0x82A4FD68;
	sub_822C0000(ctx, base);
	// 82A4FD68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A4FD6C: 3BFE01B0  addi r31, r30, 0x1b0
	ctx.r[31].s64 = ctx.r[30].s64 + 432;
	// 82A4FD70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A4FD74: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A4FD78: 917E01B0  stw r11, 0x1b0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82A4FD7C: 4B8746E5  bl 0x822c4460
	ctx.lr = 0x82A4FD80;
	sub_822C4460(ctx, base);
	// 82A4FD80: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A4FD84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4FD88: 419A0008  beq cr6, 0x82a4fd90
	if ctx.cr[6].eq {
	pc = 0x82A4FD90; continue 'dispatch;
	}
	// 82A4FD8C: 4B870B05  bl 0x822c0890
	ctx.lr = 0x82A4FD90;
	sub_822C0890(ctx, base);
	// 82A4FD90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A4FD94: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A4FD98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A4FD9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A4FDA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A4FDA4: 419A0024  beq cr6, 0x82a4fdc8
	if ctx.cr[6].eq {
	pc = 0x82A4FDC8; continue 'dispatch;
	}
	// 82A4FDA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A4FDAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A4FDB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4FDB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A4FDB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A4FDBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A4FDC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A4FDC4: 4082FFE8  bne 0x82a4fdac
	if !ctx.cr[0].eq {
	pc = 0x82A4FDAC; continue 'dispatch;
	}
	// 82A4FDC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4FDCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A4FDD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A4FDD4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A4FDD8: 4BFE87C9  bl 0x82a385a0
	ctx.lr = 0x82A4FDDC;
	sub_82A385A0(ctx, base);
	// 82A4FDDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A4FDE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4FDE4: 388BC598  addi r4, r11, -0x3a68
	ctx.r[4].s64 = ctx.r[11].s64 + -14952;
	// 82A4FDE8: 483A3C21  bl 0x82df3a08
	ctx.lr = 0x82A4FDEC;
	sub_82DF3A08(ctx, base);
	// 82A4FDEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A4FDF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A4FDF4: 809D04EC  lwz r4, 0x4ec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A4FDF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A4FDFC: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A4FE00: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A4FE04: 48163575  bl 0x82bb3378
	ctx.lr = 0x82A4FE08;
	sub_82BB3378(ctx, base);
	// 82A4FE08: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A4FE0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A4FE10: 419A0008  beq cr6, 0x82a4fe18
	if ctx.cr[6].eq {
	pc = 0x82A4FE18; continue 'dispatch;
	}
	// 82A4FE14: 4B870A7D  bl 0x822c0890
	ctx.lr = 0x82A4FE18;
	sub_822C0890(ctx, base);
	// 82A4FE18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A4FE1C: 483A360D  bl 0x82df3428
	ctx.lr = 0x82A4FE20;
	sub_82DF3428(ctx, base);
	// 82A4FE20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A4FE24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FE28: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A4FE2C: 39200610  li r9, 0x610
	ctx.r[9].s64 = 1552;
	// 82A4FE30: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FE34: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A4FE38: D01E01B8  stfs f0, 0x1b8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(440 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A4FE48 size=92
    let mut pc: u32 = 0x82A4FE48;
    'dispatch: loop {
        match pc {
            0x82A4FE48 => {
    //   block [0x82A4FE48..0x82A4FEA4)
	// 82A4FE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A4FE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A4FE50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A4FE54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A4FE58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A4FE5C: 4BFE205D  bl 0x82a31eb8
	ctx.lr = 0x82A4FE60;
	sub_82A31EB8(ctx, base);
	// 82A4FE60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4FE64: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A4FE68: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A4FE6C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A4FE70: 3929D674  addi r9, r9, -0x298c
	ctx.r[9].s64 = ctx.r[9].s64 + -10636;
	// 82A4FE74: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FE78: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A4FE7C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4FE80: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A4FE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A4FE88: C00A4408  lfs f0, 0x4408(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FE8C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4FE90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A4FE94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A4FE98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A4FE9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A4FEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FEA8 size=28
    let mut pc: u32 = 0x82A4FEA8;
    'dispatch: loop {
        match pc {
            0x82A4FEA8 => {
    //   block [0x82A4FEA8..0x82A4FEC4)
	// 82A4FEA8: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FEAC: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4FEB0: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FEB4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A4FEB8: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4FEBC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4FEC0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FEC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FEC4 size=16
    let mut pc: u32 = 0x82A4FEC4;
    'dispatch: loop {
        match pc {
            0x82A4FEC4 => {
    //   block [0x82A4FEC4..0x82A4FED4)
	// 82A4FEC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FEC8: C00B4428  lfs f0, 0x4428(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FECC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A4FED0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FED4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FED4 size=20
    let mut pc: u32 = 0x82A4FED4;
    'dispatch: loop {
        match pc {
            0x82A4FED4 => {
    //   block [0x82A4FED4..0x82A4FEE8)
	// 82A4FED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A4FED8: EC0D0028  fsubs f0, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A4FEDC: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A4FEE0: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A4FEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A4FEE8 size=20
    let mut pc: u32 = 0x82A4FEE8;
    'dispatch: loop {
        match pc {
            0x82A4FEE8 => {
    //   block [0x82A4FEE8..0x82A4FEFC)
	// 82A4FEE8: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A4FEEC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A4FEF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A4FEF4: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A4FEF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FF00 size=64
    let mut pc: u32 = 0x82A4FF00;
    'dispatch: loop {
        match pc {
            0x82A4FF00 => {
    //   block [0x82A4FF00..0x82A4FF40)
	// 82A4FF00: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A4FF04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A4FF08: 419800CC  blt cr6, 0x82a4ffd4
	if ctx.cr[6].lt {
		sub_82A4FFD4(ctx, base);
		return;
	}
	// 82A4FF0C: 419A0094  beq cr6, 0x82a4ffa0
	if ctx.cr[6].eq {
		sub_82A4FFA0(ctx, base);
		return;
	}
	// 82A4FF10: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A4FF14: 41980078  blt cr6, 0x82a4ff8c
	if ctx.cr[6].lt {
		sub_82A4FF8C(ctx, base);
		return;
	}
	// 82A4FF18: 419A0060  beq cr6, 0x82a4ff78
	if ctx.cr[6].eq {
		sub_82A4FF78(ctx, base);
		return;
	}
	// 82A4FF1C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A4FF20: 41980038  blt cr6, 0x82a4ff58
	if ctx.cr[6].lt {
		sub_82A4FF58(ctx, base);
		return;
	}
	// 82A4FF24: 419A001C  beq cr6, 0x82a4ff40
	if ctx.cr[6].eq {
		sub_82A4FF40(ctx, base);
		return;
	}
	// 82A4FF28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A4FF2C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FF30: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4FF34: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4FF38: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4FF3C: 480000C0  b 0x82a4fffc
	sub_82A4FFD4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FF40 size=24
    let mut pc: u32 = 0x82A4FF40;
    'dispatch: loop {
        match pc {
            0x82A4FF40 => {
    //   block [0x82A4FF40..0x82A4FF58)
	// 82A4FF40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FF44: 396B4420  addi r11, r11, 0x4420
	ctx.r[11].s64 = ctx.r[11].s64 + 17440;
	// 82A4FF48: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FF4C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4FF50: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FF54: 48000060  b 0x82a4ffb4
	sub_82A4FFA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FF58 size=32
    let mut pc: u32 = 0x82A4FF58;
    'dispatch: loop {
        match pc {
            0x82A4FF58 => {
    //   block [0x82A4FF58..0x82A4FF78)
	// 82A4FF58: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FF5C: 392B4420  addi r9, r11, 0x4420
	ctx.r[9].s64 = ctx.r[11].s64 + 17440;
	// 82A4FF60: C1AB4420  lfs f13, 0x4420(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FF64: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4FF68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FF6C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FF70: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4FF74: 48000080  b 0x82a4fff4
	sub_82A4FFD4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FF78 size=20
    let mut pc: u32 = 0x82A4FF78;
    'dispatch: loop {
        match pc {
            0x82A4FF78 => {
    //   block [0x82A4FF78..0x82A4FF8C)
	// 82A4FF78: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FF7C: 396B4420  addi r11, r11, 0x4420
	ctx.r[11].s64 = ctx.r[11].s64 + 17440;
	// 82A4FF80: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FF84: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4FF88: 4800005C  b 0x82a4ffe4
	sub_82A4FFD4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FF8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FF8C size=20
    let mut pc: u32 = 0x82A4FF8C;
    'dispatch: loop {
        match pc {
            0x82A4FF8C => {
    //   block [0x82A4FF8C..0x82A4FFA0)
	// 82A4FF8C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FF90: 396B4420  addi r11, r11, 0x4420
	ctx.r[11].s64 = ctx.r[11].s64 + 17440;
	// 82A4FF94: C1ABFFFC  lfs f13, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FF98: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4FF9C: 4BFFFFCC  b 0x82a4ff68
	sub_82A4FF58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FFA0 size=52
    let mut pc: u32 = 0x82A4FFA0;
    'dispatch: loop {
        match pc {
            0x82A4FFA0 => {
    //   block [0x82A4FFA0..0x82A4FFD4)
	// 82A4FFA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FFA4: 396B4420  addi r11, r11, 0x4420
	ctx.r[11].s64 = ctx.r[11].s64 + 17440;
	// 82A4FFA8: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FFAC: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A4FFB0: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FFB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FFB8: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FFBC: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A4FFC0: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4FFC4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4FFC8: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4FFCC: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4FFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A4FFD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A4FFD4 size=48
    let mut pc: u32 = 0x82A4FFD4;
    'dispatch: loop {
        match pc {
            0x82A4FFD4 => {
    //   block [0x82A4FFD4..0x82A50004)
	// 82A4FFD4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A4FFD8: 396B4420  addi r11, r11, 0x4420
	ctx.r[11].s64 = ctx.r[11].s64 + 17440;
	// 82A4FFDC: C00BFFEC  lfs f0, -0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A4FFE0: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A4FFE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A4FFE8: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A4FFEC: C16A08A4  lfs f11, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A4FFF0: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A4FFF4: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A4FFF8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A4FFFC: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A50000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50008 size=204
    let mut pc: u32 = 0x82A50008;
    'dispatch: loop {
        match pc {
            0x82A50008 => {
    //   block [0x82A50008..0x82A500D4)
	// 82A50008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5000C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50014: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50018: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A5001C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50020: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A50024: 4198005C  blt cr6, 0x82a50080
	if ctx.cr[6].lt {
	pc = 0x82A50080; continue 'dispatch;
	}
	// 82A50028: 419A0030  beq cr6, 0x82a50058
	if ctx.cr[6].eq {
	pc = 0x82A50058; continue 'dispatch;
	}
	// 82A5002C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A50030: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 82A50034: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50038: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A5003C: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50040: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A50044: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50048: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A5004C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50050: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A50054: 4800006C  b 0x82a500c0
	pc = 0x82A500C0; continue 'dispatch;
	// 82A50058: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A5005C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A50060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A50064: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50068: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5006C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A50070: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A50074: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A50078: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A5007C: 48000028  b 0x82a500a4
	pc = 0x82A500A4; continue 'dispatch;
	// 82A50080: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A50084: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A50088: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A5008C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50090: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A50094: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A50098: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A5009C: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A500A0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A500A4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A500A8: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82A500AC: C1A89450  lfs f13, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A500B0: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A500B4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A500B8: 4842CB89  bl 0x82e7cc40
	ctx.lr = 0x82A500BC;
	sub_82E7CC40(ctx, base);
	// 82A500BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A500C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A500C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A500C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A500CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A500D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A500D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A500D8 size=608
    let mut pc: u32 = 0x82A500D8;
    'dispatch: loop {
        match pc {
            0x82A500D8 => {
    //   block [0x82A500D8..0x82A50338)
	// 82A500D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A500DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A500E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A500E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A500E8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A500EC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A500F0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A500F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A500F8: 48704509  bl 0x83154600
	ctx.lr = 0x82A500FC;
	sub_83154600(ctx, base);
	// 82A500FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50104: 4BFFEA85  bl 0x82a4eb88
	ctx.lr = 0x82A50108;
	sub_82A4EB88(ctx, base);
	// 82A50108: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A5010C: 38BE0610  addi r5, r30, 0x610
	ctx.r[5].s64 = ctx.r[30].s64 + 1552;
	// 82A50110: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A50114: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A50118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5011C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50338 size=196
    let mut pc: u32 = 0x82A50338;
    'dispatch: loop {
        match pc {
            0x82A50338 => {
    //   block [0x82A50338..0x82A503FC)
	// 82A50338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5033C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A50344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5034C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A50354: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A50358: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5035C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50360: 4B8705D9  bl 0x822c0938
	ctx.lr = 0x82A50364;
	sub_822C0938(ctx, base);
	// 82A50364: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A50368: 41820028  beq 0x82a50390
	if ctx.cr[0].eq {
	pc = 0x82A50390; continue 'dispatch;
	}
	// 82A5036C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50370: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A50374: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A50378: 392BD6A0  addi r9, r11, -0x2960
	ctx.r[9].s64 = ctx.r[11].s64 + -10592;
	// 82A5037C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A50380: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A50384: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A50388: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5038C: 48000008  b 0x82a50394
	pc = 0x82A50394; continue 'dispatch;
	// 82A50390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A50394: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5039C: 409A0044  bne cr6, 0x82a503e0
	if !ctx.cr[6].eq {
	pc = 0x82A503E0; continue 'dispatch;
	}
	// 82A503A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A503A4: 419A001C  beq cr6, 0x82a503c0
	if ctx.cr[6].eq {
	pc = 0x82A503C0; continue 'dispatch;
	}
	// 82A503A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A503AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A503B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A503B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A503B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A503BC: 4E800421  bctrl
	ctx.lr = 0x82A503C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A503C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A503C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A503C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A503CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A503D0: 816B443C  lwz r11, 0x443c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17468 as u32) ) } as u64;
	// 82A503D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A503D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A503DC: 4B86FC25  bl 0x822c0000
	ctx.lr = 0x82A503E0;
	sub_822C0000(ctx, base);
	// 82A503E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A503E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A503E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A503EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A503F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A503F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A503F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A50400 size=704
    let mut pc: u32 = 0x82A50400;
    'dispatch: loop {
        match pc {
            0x82A50400 => {
    //   block [0x82A50400..0x82A506C0)
	// 82A50400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50404: 48757D65  bl 0x831a8168
	ctx.lr = 0x82A50408;
	sub_831A8130(ctx, base);
	// 82A50408: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82A5040C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A50410: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A50414: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A506C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A506C0 size=264
    let mut pc: u32 = 0x82A506C0;
    'dispatch: loop {
        match pc {
            0x82A506C0 => {
    //   block [0x82A506C0..0x82A507C8)
	// 82A506C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A506C4: 48757AA9  bl 0x831a816c
	ctx.lr = 0x82A506C8;
	sub_831A8130(ctx, base);
	// 82A506C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A506CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A506D0: 48703F31  bl 0x83154600
	ctx.lr = 0x82A506D4;
	sub_83154600(ctx, base);
	// 82A506D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A506D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A506DC: 4BFFE23D  bl 0x82a4e918
	ctx.lr = 0x82A506E0;
	sub_82A4E918(ctx, base);
	// 82A506E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A506E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A506E8: 388BD6B0  addi r4, r11, -0x2950
	ctx.r[4].s64 = ctx.r[11].s64 + -10576;
	// 82A506EC: 38A000EF  li r5, 0xef
	ctx.r[5].s64 = 239;
	// 82A506F0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A506F4: 4B86FCE5  bl 0x822c03d8
	ctx.lr = 0x82A506F8;
	sub_822C03D8(ctx, base);
	// 82A506F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A506FC: 41820010  beq 0x82a5070c
	if ctx.cr[0].eq {
	pc = 0x82A5070C; continue 'dispatch;
	}
	// 82A50700: 4BFFF749  bl 0x82a4fe48
	ctx.lr = 0x82A50704;
	sub_82A4FE48(ctx, base);
	// 82A50704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50708: 48000008  b 0x82a50710
	pc = 0x82A50710; continue 'dispatch;
	// 82A5070C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A50710: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A50714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50718: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A5071C: 4BFFFC1D  bl 0x82a50338
	ctx.lr = 0x82A50720;
	sub_82A50338(ctx, base);
	// 82A50720: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A50724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50728: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A5072C: 4B86F8D5  bl 0x822c0000
	ctx.lr = 0x82A50730;
	sub_822C0000(ctx, base);
	// 82A50730: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A50734: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A50738: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5073C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A50740: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A50744: 419A0024  beq cr6, 0x82a50768
	if ctx.cr[6].eq {
	pc = 0x82A50768; continue 'dispatch;
	}
	// 82A50748: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A5074C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A50750: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50754: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A50758: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5075C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A50760: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50764: 4082FFE8  bne 0x82a5074c
	if !ctx.cr[0].eq {
	pc = 0x82A5074C; continue 'dispatch;
	}
	// 82A50768: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A5076C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A50770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A50774: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A50778: 4BFE7E29  bl 0x82a385a0
	ctx.lr = 0x82A5077C;
	sub_82A385A0(ctx, base);
	// 82A5077C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50780: 419A000C  beq cr6, 0x82a5078c
	if ctx.cr[6].eq {
	pc = 0x82A5078C; continue 'dispatch;
	}
	// 82A50784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50788: 4B870109  bl 0x822c0890
	ctx.lr = 0x82A5078C;
	sub_822C0890(ctx, base);
	// 82A5078C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A50790: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A50794: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A50798: 392001C0  li r9, 0x1c0
	ctx.r[9].s64 = 448;
	// 82A5079C: 390001D0  li r8, 0x1d0
	ctx.r[8].s64 = 464;
	// 82A507A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A507A4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A507A8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A507AC: 98FE01B0  stb r7, 0x1b0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(432 as u32), ctx.r[7].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A507C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A507C8 size=108
    let mut pc: u32 = 0x82A507C8;
    'dispatch: loop {
        match pc {
            0x82A507C8 => {
    //   block [0x82A507C8..0x82A50834)
	// 82A507C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A507CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A507D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A507D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A507D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A507DC: 48408F9D  bl 0x82e59778
	ctx.lr = 0x82A507E0;
	sub_82E59778(ctx, base);
	// 82A507E0: C01F01B4  lfs f0, 0x1b4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A507E4: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A507E8: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A507EC: D1BF01B4  stfs f13, 0x1b4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82A507F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A507F4: 409A002C  bne cr6, 0x82a50820
	if !ctx.cr[6].eq {
	pc = 0x82A50820; continue 'dispatch;
	}
	// 82A507F8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A507FC: C00B4438  lfs f0, 0x4438(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50800: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A50804: 4198001C  blt cr6, 0x82a50820
	if ctx.cr[6].lt {
	pc = 0x82A50820; continue 'dispatch;
	}
	// 82A50808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5080C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A50810: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82A50814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50818: 997F01B0  stb r11, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u8 ) };
	// 82A5081C: 4BFFFBE5  bl 0x82a50400
	ctx.lr = 0x82A50820;
	sub_82A50400(ctx, base);
	// 82A50820: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A50824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5082C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50838 size=68
    let mut pc: u32 = 0x82A50838;
    'dispatch: loop {
        match pc {
            0x82A50838 => {
    //   block [0x82A50838..0x82A5087C)
	// 82A50838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5083C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50844: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5084C: 4BFFFF7D  bl 0x82a507c8
	ctx.lr = 0x82A50850;
	sub_82A507C8(ctx, base);
	// 82A50850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50854: 4BFFF885  bl 0x82a500d8
	ctx.lr = 0x82A50858;
	sub_82A500D8(ctx, base);
	// 82A50858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5085C: 4B86F7A5  bl 0x822c0000
	ctx.lr = 0x82A50860;
	sub_822C0000(ctx, base);
	// 82A50860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50864: 48703D9D  bl 0x83154600
	ctx.lr = 0x82A50868;
	sub_83154600(ctx, base);
	// 82A50868: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A5086C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50880 size=84
    let mut pc: u32 = 0x82A50880;
    'dispatch: loop {
        match pc {
            0x82A50880 => {
    //   block [0x82A50880..0x82A508D4)
	// 82A50880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50888: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5088C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50890: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50894: 4BFE1625  bl 0x82a31eb8
	ctx.lr = 0x82A50898;
	sub_82A31EB8(ctx, base);
	// 82A50898: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A5089C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A508A0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A508A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A508A8: 3929D710  addi r9, r9, -0x28f0
	ctx.r[9].s64 = ctx.r[9].s64 + -10480;
	// 82A508AC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A508B0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A508B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A508B8: C00A44F4  lfs f0, 0x44f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A508BC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A508C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A508C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A508C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A508CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A508D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A508D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A508D8 size=52
    let mut pc: u32 = 0x82A508D8;
    'dispatch: loop {
        match pc {
            0x82A508D8 => {
    //   block [0x82A508D8..0x82A5090C)
	// 82A508D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A508DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A508E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A508E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A508E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A508EC: 4BFFEB15  bl 0x82a4f400
	ctx.lr = 0x82A508F0;
	sub_82A4F400(ctx, base);
	// 82A508F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A508F4: 4B86F70D  bl 0x822c0000
	ctx.lr = 0x82A508F8;
	sub_822C0000(ctx, base);
	// 82A508F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A508FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50910 size=196
    let mut pc: u32 = 0x82A50910;
    'dispatch: loop {
        match pc {
            0x82A50910 => {
    //   block [0x82A50910..0x82A509D4)
	// 82A50910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5091C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5092C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A50930: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A50934: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50938: 4B870001  bl 0x822c0938
	ctx.lr = 0x82A5093C;
	sub_822C0938(ctx, base);
	// 82A5093C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A50940: 41820028  beq 0x82a50968
	if ctx.cr[0].eq {
	pc = 0x82A50968; continue 'dispatch;
	}
	// 82A50944: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50948: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A5094C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A50950: 392BD73C  addi r9, r11, -0x28c4
	ctx.r[9].s64 = ctx.r[11].s64 + -10436;
	// 82A50954: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A50958: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5095C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A50960: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A50964: 48000008  b 0x82a5096c
	pc = 0x82A5096C; continue 'dispatch;
	// 82A50968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5096C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A50974: 409A0044  bne cr6, 0x82a509b8
	if !ctx.cr[6].eq {
	pc = 0x82A509B8; continue 'dispatch;
	}
	// 82A50978: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5097C: 419A001C  beq cr6, 0x82a50998
	if ctx.cr[6].eq {
	pc = 0x82A50998; continue 'dispatch;
	}
	// 82A50980: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A50984: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A50988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5098C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A50990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A50994: 4E800421  bctrl
	ctx.lr = 0x82A50998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A50998: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A5099C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A509A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A509A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A509A8: 816B4518  lwz r11, 0x4518(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17688 as u32) ) } as u64;
	// 82A509AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A509B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A509B4: 4B86F64D  bl 0x822c0000
	ctx.lr = 0x82A509B8;
	sub_822C0000(ctx, base);
	// 82A509B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A509BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A509C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A509C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A509C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A509CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A509D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A509D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A509D8 size=236
    let mut pc: u32 = 0x82A509D8;
    'dispatch: loop {
        match pc {
            0x82A509D8 => {
    //   block [0x82A509D8..0x82A50AC4)
	// 82A509D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A509DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A509E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A509E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A509E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A509EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A509F0: 48703C11  bl 0x83154600
	ctx.lr = 0x82A509F4;
	sub_83154600(ctx, base);
	// 82A509F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A509F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A509FC: 4BFFDF1D  bl 0x82a4e918
	ctx.lr = 0x82A50A00;
	sub_82A4E918(ctx, base);
	// 82A50A00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50A04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A50A08: 388BD750  addi r4, r11, -0x28b0
	ctx.r[4].s64 = ctx.r[11].s64 + -10416;
	// 82A50A0C: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 82A50A10: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A50A14: 4B86F9C5  bl 0x822c03d8
	ctx.lr = 0x82A50A18;
	sub_822C03D8(ctx, base);
	// 82A50A18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A50A1C: 41820010  beq 0x82a50a2c
	if ctx.cr[0].eq {
	pc = 0x82A50A2C; continue 'dispatch;
	}
	// 82A50A20: 4BFFFE61  bl 0x82a50880
	ctx.lr = 0x82A50A24;
	sub_82A50880(ctx, base);
	// 82A50A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50A28: 48000008  b 0x82a50a30
	pc = 0x82A50A30; continue 'dispatch;
	// 82A50A2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A50A30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A50A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50A38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50A3C: 4BFFFED5  bl 0x82a50910
	ctx.lr = 0x82A50A40;
	sub_82A50910(ctx, base);
	// 82A50A40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A50A44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50A48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50A4C: 4B86F5B5  bl 0x822c0000
	ctx.lr = 0x82A50A50;
	sub_822C0000(ctx, base);
	// 82A50A50: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A50A54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A50A58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50A5C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A50A60: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A50A64: 419A0024  beq cr6, 0x82a50a88
	if ctx.cr[6].eq {
	pc = 0x82A50A88; continue 'dispatch;
	}
	// 82A50A68: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A50A6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A50A70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50A74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A50A78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A50A7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A50A80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50A84: 4082FFE8  bne 0x82a50a6c
	if !ctx.cr[0].eq {
	pc = 0x82A50A6C; continue 'dispatch;
	}
	// 82A50A88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A50A8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A50A90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A50A94: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A50A98: 4BFE7B09  bl 0x82a385a0
	ctx.lr = 0x82A50A9C;
	sub_82A385A0(ctx, base);
	// 82A50A9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50AA0: 419A000C  beq cr6, 0x82a50aac
	if ctx.cr[6].eq {
	pc = 0x82A50AAC; continue 'dispatch;
	}
	// 82A50AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50AA8: 4B86FDE9  bl 0x822c0890
	ctx.lr = 0x82A50AAC;
	sub_822C0890(ctx, base);
	// 82A50AAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A50AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50AB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A50ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50AC8 size=280
    let mut pc: u32 = 0x82A50AC8;
    'dispatch: loop {
        match pc {
            0x82A50AC8 => {
    //   block [0x82A50AC8..0x82A50BE0)
	// 82A50AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A50AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50AD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50ADC: 48703B25  bl 0x83154600
	ctx.lr = 0x82A50AE0;
	sub_83154600(ctx, base);
	// 82A50AE0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50AE8: 388BD750  addi r4, r11, -0x28b0
	ctx.r[4].s64 = ctx.r[11].s64 + -10416;
	// 82A50AEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A50AF0: 38A000E8  li r5, 0xe8
	ctx.r[5].s64 = 232;
	// 82A50AF4: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 82A50AF8: 483A18F1  bl 0x82df23e8
	ctx.lr = 0x82A50AFC;
	sub_82DF23E8(ctx, base);
	// 82A50AFC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A50B00: 4182001C  beq 0x82a50b1c
	if ctx.cr[0].eq {
	pc = 0x82A50B1C; continue 'dispatch;
	}
	// 82A50B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50B08: 4BFFD761  bl 0x82a4e268
	ctx.lr = 0x82A50B0C;
	sub_82A4E268(ctx, base);
	// 82A50B0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50B10: 396BC180  addi r11, r11, -0x3e80
	ctx.r[11].s64 = ctx.r[11].s64 + -16000;
	// 82A50B14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50B18: 48000008  b 0x82a50b20
	pc = 0x82A50B20; continue 'dispatch;
	// 82A50B1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A50B20: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A50B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50B28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50B2C: 4BFE2A75  bl 0x82a335a0
	ctx.lr = 0x82A50B30;
	sub_82A335A0(ctx, base);
	// 82A50B30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A50B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50B38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50B3C: 4B86F4C5  bl 0x822c0000
	ctx.lr = 0x82A50B40;
	sub_822C0000(ctx, base);
	// 82A50B40: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A50B44: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A50B48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50B4C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A50B50: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A50B54: 419A0024  beq cr6, 0x82a50b78
	if ctx.cr[6].eq {
	pc = 0x82A50B78; continue 'dispatch;
	}
	// 82A50B58: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A50B5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A50B60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50B64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A50B68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A50B6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A50B70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50B74: 4082FFE8  bne 0x82a50b5c
	if !ctx.cr[0].eq {
	pc = 0x82A50B5C; continue 'dispatch;
	}
	// 82A50B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A50B7C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A50B80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A50B84: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A50B88: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 82A50B8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A50B90: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A50B94: 4840DB15  bl 0x82e5e6a8
	ctx.lr = 0x82A50B98;
	sub_82E5E6A8(ctx, base);
	// 82A50B98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A50B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A50BA0: 419A0008  beq cr6, 0x82a50ba8
	if ctx.cr[6].eq {
	pc = 0x82A50BA8; continue 'dispatch;
	}
	// 82A50BA4: 4B86FCED  bl 0x822c0890
	ctx.lr = 0x82A50BA8;
	sub_822C0890(ctx, base);
	// 82A50BA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A50BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A50BB0: 419A0008  beq cr6, 0x82a50bb8
	if ctx.cr[6].eq {
	pc = 0x82A50BB8; continue 'dispatch;
	}
	// 82A50BB4: 4B86FCDD  bl 0x822c0890
	ctx.lr = 0x82A50BB8;
	sub_822C0890(ctx, base);
	// 82A50BB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50BBC: 419A000C  beq cr6, 0x82a50bc8
	if ctx.cr[6].eq {
	pc = 0x82A50BC8; continue 'dispatch;
	}
	// 82A50BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50BC4: 4B86FCCD  bl 0x822c0890
	ctx.lr = 0x82A50BC8;
	sub_822C0890(ctx, base);
	// 82A50BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A50BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50BD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A50BD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50BE0 size=72
    let mut pc: u32 = 0x82A50BE0;
    'dispatch: loop {
        match pc {
            0x82A50BE0 => {
    //   block [0x82A50BE0..0x82A50C28)
	// 82A50BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50BE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50BEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50BF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50BF4: 4BFE12C5  bl 0x82a31eb8
	ctx.lr = 0x82A50BF8;
	sub_82A31EB8(ctx, base);
	// 82A50BF8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A50BFC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A50C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50C04: 394AD7A4  addi r10, r10, -0x285c
	ctx.r[10].s64 = ctx.r[10].s64 + -10332;
	// 82A50C08: C00B45B4  lfs f0, 0x45b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17844 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50C0C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A50C10: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A50C14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A50C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50C20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50C24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50C28 size=68
    let mut pc: u32 = 0x82A50C28;
    'dispatch: loop {
        match pc {
            0x82A50C28 => {
    //   block [0x82A50C28..0x82A50C6C)
	// 82A50C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50C34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50C3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50C40: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A50C44: 396BBC10  addi r11, r11, -0x43f0
	ctx.r[11].s64 = ctx.r[11].s64 + -17392;
	// 82A50C48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50C4C: 41820008  beq 0x82a50c54
	if ctx.cr[0].eq {
	pc = 0x82A50C54; continue 'dispatch;
	}
	// 82A50C50: 4B86F619  bl 0x822c0268
	ctx.lr = 0x82A50C54;
	sub_822C0268(ctx, base);
	// 82A50C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50C58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A50C5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50C60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50C64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50C70 size=248
    let mut pc: u32 = 0x82A50C70;
    'dispatch: loop {
        match pc {
            0x82A50C70 => {
    //   block [0x82A50C70..0x82A50D68)
	// 82A50C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A50C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50C80: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A50C84: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A50C88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50C8C: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A50C90: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A50C94: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A50C98: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A50C9C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A50CA0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A50CA4: 3BCB45B8  addi r30, r11, 0x45b8
	ctx.r[30].s64 = ctx.r[11].s64 + 17848;
	// 82A50CA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A50CAC: FD406818  frsp f10, f13
	ctx.f[10].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A50CB0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50CB4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82A50CB8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A50CBC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A50CC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50CC4: C1ABD910  lfs f13, -0x26f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9968 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A50CC8: ED200372  fmuls f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A50CCC: C1AAE830  lfs f13, -0x17d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A50CD0: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A50CD4: ED0D5028  fsubs f8, f13, f10
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82A50CD8: EDA95ABC  fnmsubs f13, f9, f10, f11
	ctx.f[13].f64 = -(((ctx.f[9].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82A50CDC: EFC80332  fmuls f30, f8, f12
	ctx.f[30].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A50CE0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82A50CE4: 41990008  bgt cr6, 0x82a50cec
	if ctx.cr[6].gt {
	pc = 0x82A50CEC; continue 'dispatch;
	}
	// 82A50CE8: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82A50CEC: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A50CF0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82A50CF4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A50CF8: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50CFC: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A50D00: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A50D04: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A50D08: 487581A1  bl 0x831a8ea8
	ctx.lr = 0x82A50D0C;
	sub_831A8EA8(ctx, base);
	// 82A50D0C: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A50D10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A50D14: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A50D18: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A50D1C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A50D20: D3DF0000  stfs f30, 0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A50D24: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A50D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50D2C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A50D30: C16ADF4C  lfs f11, -0x20b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8372 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A50D34: C1A9D0B0  lfs f13, -0x2f50(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A50D38: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A50D3C: EC0A003C  fnmsubs f0, f10, f0, f0
	ctx.f[0].f64 = -(((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A50D40: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A50D44: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A50D48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A50D4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50D50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50D54: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A50D58: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A50D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A50D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50D68 size=224
    let mut pc: u32 = 0x82A50D68;
    'dispatch: loop {
        match pc {
            0x82A50D68 => {
    //   block [0x82A50D68..0x82A50E48)
	// 82A50D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50D6C: 48757401  bl 0x831a816c
	ctx.lr = 0x82A50D70;
	sub_831A8130(ctx, base);
	// 82A50D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50D78: 48703889  bl 0x83154600
	ctx.lr = 0x82A50D7C;
	sub_83154600(ctx, base);
	// 82A50D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50D80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50D84: 4BFFDE05  bl 0x82a4eb88
	ctx.lr = 0x82A50D88;
	sub_82A4EB88(ctx, base);
	// 82A50D88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A50D8C: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A50D90: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A50D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50D98: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A50D9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A50DA0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50E48 size=60
    let mut pc: u32 = 0x82A50E48;
    'dispatch: loop {
        match pc {
            0x82A50E48 => {
    //   block [0x82A50E48..0x82A50E84)
	// 82A50E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50E50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50E54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50E5C: 4BFFFF0D  bl 0x82a50d68
	ctx.lr = 0x82A50E60;
	sub_82A50D68(ctx, base);
	// 82A50E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50E64: 4B86F19D  bl 0x822c0000
	ctx.lr = 0x82A50E68;
	sub_822C0000(ctx, base);
	// 82A50E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50E6C: 48703795  bl 0x83154600
	ctx.lr = 0x82A50E70;
	sub_83154600(ctx, base);
	// 82A50E70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A50E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A50E88 size=196
    let mut pc: u32 = 0x82A50E88;
    'dispatch: loop {
        match pc {
            0x82A50E88 => {
    //   block [0x82A50E88..0x82A50F4C)
	// 82A50E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A50E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A50E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A50E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A50EA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A50EA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A50EAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50EB0: 4B86FA89  bl 0x822c0938
	ctx.lr = 0x82A50EB4;
	sub_822C0938(ctx, base);
	// 82A50EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A50EB8: 41820028  beq 0x82a50ee0
	if ctx.cr[0].eq {
	pc = 0x82A50EE0; continue 'dispatch;
	}
	// 82A50EBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50EC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A50EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A50EC8: 392BD7D0  addi r9, r11, -0x2830
	ctx.r[9].s64 = ctx.r[11].s64 + -10288;
	// 82A50ECC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A50ED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A50ED4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A50ED8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A50EDC: 48000008  b 0x82a50ee4
	pc = 0x82A50EE4; continue 'dispatch;
	// 82A50EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A50EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A50EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A50EEC: 409A0044  bne cr6, 0x82a50f30
	if !ctx.cr[6].eq {
	pc = 0x82A50F30; continue 'dispatch;
	}
	// 82A50EF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50EF4: 419A001C  beq cr6, 0x82a50f10
	if ctx.cr[6].eq {
	pc = 0x82A50F10; continue 'dispatch;
	}
	// 82A50EF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A50EFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A50F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50F04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A50F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A50F0C: 4E800421  bctrl
	ctx.lr = 0x82A50F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A50F10: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A50F14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A50F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A50F1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A50F20: 816B45C8  lwz r11, 0x45c8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17864 as u32) ) } as u64;
	// 82A50F24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A50F28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A50F2C: 4B86F0D5  bl 0x822c0000
	ctx.lr = 0x82A50F30;
	sub_822C0000(ctx, base);
	// 82A50F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A50F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A50F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A50F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A50F40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A50F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A50F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A50F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A50F50 size=396
    let mut pc: u32 = 0x82A50F50;
    'dispatch: loop {
        match pc {
            0x82A50F50 => {
    //   block [0x82A50F50..0x82A510DC)
	// 82A50F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A50F54: 48757219  bl 0x831a816c
	ctx.lr = 0x82A50F58;
	sub_831A8130(ctx, base);
	// 82A50F58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A50F5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50F60: 487036A1  bl 0x83154600
	ctx.lr = 0x82A50F64;
	sub_83154600(ctx, base);
	// 82A50F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A50F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A50F6C: 4BFFD9AD  bl 0x82a4e918
	ctx.lr = 0x82A50F70;
	sub_82A4E918(ctx, base);
	// 82A50F70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A50F74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A50F78: 3BABD7E0  addi r29, r11, -0x2820
	ctx.r[29].s64 = ctx.r[11].s64 + -10272;
	// 82A50F7C: 38A000A9  li r5, 0xa9
	ctx.r[5].s64 = 169;
	// 82A50F80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A50F84: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A50F88: 4B86F451  bl 0x822c03d8
	ctx.lr = 0x82A50F8C;
	sub_822C03D8(ctx, base);
	// 82A50F8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A50F90: 41820010  beq 0x82a50fa0
	if ctx.cr[0].eq {
	pc = 0x82A50FA0; continue 'dispatch;
	}
	// 82A50F94: 4BFFFC4D  bl 0x82a50be0
	ctx.lr = 0x82A50F98;
	sub_82A50BE0(ctx, base);
	// 82A50F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A50F9C: 48000008  b 0x82a50fa4
	pc = 0x82A50FA4; continue 'dispatch;
	// 82A50FA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A50FA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A50FA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50FAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50FB0: 4BFFFED9  bl 0x82a50e88
	ctx.lr = 0x82A50FB4;
	sub_82A50E88(ctx, base);
	// 82A50FB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A50FB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A50FBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A50FC0: 4B86F041  bl 0x822c0000
	ctx.lr = 0x82A50FC4;
	sub_822C0000(ctx, base);
	// 82A50FC4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A50FC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A50FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A50FD0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A50FD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A50FD8: 419A0024  beq cr6, 0x82a50ffc
	if ctx.cr[6].eq {
	pc = 0x82A50FFC; continue 'dispatch;
	}
	// 82A50FDC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A50FE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A50FE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50FE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A50FEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A50FF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A50FF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A50FF8: 4082FFE8  bne 0x82a50fe0
	if !ctx.cr[0].eq {
	pc = 0x82A50FE0; continue 'dispatch;
	}
	// 82A50FFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51000: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A51004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A51008: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A5100C: 4BFE7595  bl 0x82a385a0
	ctx.lr = 0x82A51010;
	sub_82A385A0(ctx, base);
	// 82A51010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A51014: 419A000C  beq cr6, 0x82a51020
	if ctx.cr[6].eq {
	pc = 0x82A51020; continue 'dispatch;
	}
	// 82A51018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5101C: 4B86F875  bl 0x822c0890
	ctx.lr = 0x82A51020;
	sub_822C0890(ctx, base);
	// 82A51020: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A51024: 4BCDA0A5  bl 0x8272b0c8
	ctx.lr = 0x82A51028;
	sub_8272B0C8(ctx, base);
	// 82A51028: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5102C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A51030: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A51034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A51038: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5103C: 419A0024  beq cr6, 0x82a51060
	if ctx.cr[6].eq {
	pc = 0x82A51060; continue 'dispatch;
	}
	// 82A51040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A51044: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A51048: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5104C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A51050: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A51054: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A51058: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5105C: 4082FFE8  bne 0x82a51044
	if !ctx.cr[0].eq {
	pc = 0x82A51044; continue 'dispatch;
	}
	// 82A51060: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A51064: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A51068: 4BABE461  bl 0x8250f4c8
	ctx.lr = 0x82A5106C;
	sub_8250F4C8(ctx, base);
	// 82A5106C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A51074: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A51078: 409A0008  bne cr6, 0x82a51080
	if !ctx.cr[6].eq {
	pc = 0x82A51080; continue 'dispatch;
	}
	// 82A5107C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A51080: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A51084: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82A51088: 4BAB7991  bl 0x82508a18
	ctx.lr = 0x82A5108C;
	sub_82508A18(ctx, base);
	// 82A5108C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51090: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A51094: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A51098: 38A000B1  li r5, 0xb1
	ctx.r[5].s64 = 177;
	// 82A5109C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A510A0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A510A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A510A8: 48407999  bl 0x82e58a40
	ctx.lr = 0x82A510AC;
	sub_82E58A40(ctx, base);
	// 82A510AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A510B0: 483A0BE1  bl 0x82df1c90
	ctx.lr = 0x82A510B4;
	sub_82DF1C90(ctx, base);
	// 82A510B4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A510B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A510BC: 419A0008  beq cr6, 0x82a510c4
	if ctx.cr[6].eq {
	pc = 0x82A510C4; continue 'dispatch;
	}
	// 82A510C0: 4B86F7D1  bl 0x822c0890
	ctx.lr = 0x82A510C4;
	sub_822C0890(ctx, base);
	// 82A510C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A510C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A510CC: 419A0008  beq cr6, 0x82a510d4
	if ctx.cr[6].eq {
	pc = 0x82A510D4; continue 'dispatch;
	}
	// 82A510D0: 4B86F7C1  bl 0x822c0890
	ctx.lr = 0x82A510D4;
	sub_822C0890(ctx, base);
	// 82A510D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A510D8: 487570E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A510E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A510E0 size=36
    let mut pc: u32 = 0x82A510E0;
    'dispatch: loop {
        match pc {
            0x82A510E0 => {
    //   block [0x82A510E0..0x82A51104)
	// 82A510E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A510E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A510E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A510EC: 48703515  bl 0x83154600
	ctx.lr = 0x82A510F0;
	sub_83154600(ctx, base);
	// 82A510F0: 4BFE1191  bl 0x82a32280
	ctx.lr = 0x82A510F4;
	sub_82A32280(ctx, base);
	// 82A510F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A510F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A510FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51108 size=452
    let mut pc: u32 = 0x82A51108;
    'dispatch: loop {
        match pc {
            0x82A51108 => {
    //   block [0x82A51108..0x82A512CC)
	// 82A51108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5110C: 48757061  bl 0x831a816c
	ctx.lr = 0x82A51110;
	sub_831A8130(ctx, base);
	// 82A51110: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A51114: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5111C: 487034E5  bl 0x83154600
	ctx.lr = 0x82A51120;
	sub_83154600(ctx, base);
	// 82A51120: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A51124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51128: 4BFFDA61  bl 0x82a4eb88
	ctx.lr = 0x82A5112C;
	sub_82A4EB88(ctx, base);
	// 82A5112C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51130: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A51134: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A51138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5113C: 409A0024  bne cr6, 0x82a51160
	if !ctx.cr[6].eq {
	pc = 0x82A51160; continue 'dispatch;
	}
	// 82A51140: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51144: C1BF01E4  lfs f13, 0x1e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51148: 38BF01C0  addi r5, r31, 0x1c0
	ctx.r[5].s64 = ctx.r[31].s64 + 448;
	// 82A5114C: 389F01B0  addi r4, r31, 0x1b0
	ctx.r[4].s64 = ctx.r[31].s64 + 432;
	// 82A51150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A51154: C00B4694  lfs f0, 0x4694(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51158: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A5115C: 480000A0  b 0x82a511fc
	pc = 0x82A511FC; continue 'dispatch;
	// 82A51160: 897F01E8  lbz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A51164: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A51168: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A5116C: 419800A4  blt cr6, 0x82a51210
	if ctx.cr[6].lt {
	pc = 0x82A51210; continue 'dispatch;
	}
	// 82A51170: 419A00A0  beq cr6, 0x82a51210
	if ctx.cr[6].eq {
	pc = 0x82A51210; continue 'dispatch;
	}
	// 82A51174: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A51178: 41980028  blt cr6, 0x82a511a0
	if ctx.cr[6].lt {
	pc = 0x82A511A0; continue 'dispatch;
	}
	// 82A5117C: 419A001C  beq cr6, 0x82a51198
	if ctx.cr[6].eq {
	pc = 0x82A51198; continue 'dispatch;
	}
	// 82A51180: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A51184: 4098009C  bge cr6, 0x82a51220
	if !ctx.cr[6].lt {
	pc = 0x82A51220; continue 'dispatch;
	}
	// 82A51188: 38BF01C0  addi r5, r31, 0x1c0
	ctx.r[5].s64 = ctx.r[31].s64 + 448;
	// 82A5118C: 389F01D0  addi r4, r31, 0x1d0
	ctx.r[4].s64 = ctx.r[31].s64 + 464;
	// 82A51190: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A51194: 48000018  b 0x82a511ac
	pc = 0x82A511AC; continue 'dispatch;
	// 82A51198: 396001D0  li r11, 0x1d0
	ctx.r[11].s64 = 464;
	// 82A5119C: 48000078  b 0x82a51214
	pc = 0x82A51214; continue 'dispatch;
	// 82A511A0: 38BF01D0  addi r5, r31, 0x1d0
	ctx.r[5].s64 = ctx.r[31].s64 + 464;
	// 82A511A4: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 82A511A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A511AC: 895F01E8  lbz r10, 0x1e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A511B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A511B4: 893F01E9  lbz r9, 0x1e9(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(489 as u32) ) } as u64;
	// 82A511B8: C01F01E4  lfs f0, 0x1e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A511BC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A511C0: 396BD83C  addi r11, r11, -0x27c4
	ctx.r[11].s64 = ctx.r[11].s64 + -10180;
	// 82A511C4: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A511C8: 390B0050  addi r8, r11, 0x50
	ctx.r[8].s64 = ctx.r[11].s64 + 80;
	// 82A511CC: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 * 3;
	// 82A511D0: 7DA7442E  lfsx f13, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A511D4: EDBF6824  fdivs f13, f31, f13
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 82A511D8: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 82A511DC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A511E0: 392B003C  addi r9, r11, 0x3c
	ctx.r[9].s64 = ctx.r[11].s64 + 60;
	// 82A511E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A511E8: 7D874C2E  lfsx f12, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A511EC: 7D6A5C2E  lfsx f11, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A511F0: EDAD5824  fdivs f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A511F4: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A511F8: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A511FC: 4842C445  bl 0x82e7d640
	ctx.lr = 0x82A51200;
	sub_82E7D640(ctx, base);
	// 82A51200: 39600610  li r11, 0x610
	ctx.r[11].s64 = 1552;
	// 82A51204: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A512D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A512D0 size=500
    let mut pc: u32 = 0x82A512D0;
    'dispatch: loop {
        match pc {
            0x82A512D0 => {
    //   block [0x82A512D0..0x82A514C4)
	// 82A512D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A512D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A512D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A512DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A512E0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A512E4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A512E8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A514C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A514C8 size=120
    let mut pc: u32 = 0x82A514C8;
    'dispatch: loop {
        match pc {
            0x82A514C8 => {
    //   block [0x82A514C8..0x82A51540)
	// 82A514C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A514CC: 48756CA1  bl 0x831a816c
	ctx.lr = 0x82A514D0;
	sub_831A8130(ctx, base);
	// 82A514D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A514D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A514D8: 48703129  bl 0x83154600
	ctx.lr = 0x82A514DC;
	sub_83154600(ctx, base);
	// 82A514DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A514E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A514E4: 4BFFD435  bl 0x82a4e918
	ctx.lr = 0x82A514E8;
	sub_82A4E918(ctx, base);
	// 82A514E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A514EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A514F0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A514F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A514F8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A514FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A51500: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A51504: 4BFE709D  bl 0x82a385a0
	ctx.lr = 0x82A51508;
	sub_82A385A0(ctx, base);
	// 82A51508: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5150C: 4BFE0D0D  bl 0x82a32218
	ctx.lr = 0x82A51510;
	sub_82A32218(ctx, base);
	// 82A51510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51514: 9BFE01E0  stb r31, 0x1e0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(480 as u32), ctx.r[31].u8 ) };
	// 82A51518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5151C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51520: D01E01E4  stfs f0, 0x1e4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82A51524: 4BFFFDAD  bl 0x82a512d0
	ctx.lr = 0x82A51528;
	sub_82A512D0(ctx, base);
	// 82A51528: 9BFE01E8  stb r31, 0x1e8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(488 as u32), ctx.r[31].u8 ) };
	// 82A5152C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A51530: 4BFE0A11  bl 0x82a31f40
	ctx.lr = 0x82A51534;
	sub_82A31F40(ctx, base);
	// 82A51534: 987E01E9  stb r3, 0x1e9(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(489 as u32), ctx.r[3].u8 ) };
	// 82A51538: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5153C: 48756C80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51540 size=432
    let mut pc: u32 = 0x82A51540;
    'dispatch: loop {
        match pc {
            0x82A51540 => {
    //   block [0x82A51540..0x82A516F0)
	// 82A51540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51544: 48756C25  bl 0x831a8168
	ctx.lr = 0x82A51548;
	sub_831A8130(ctx, base);
	// 82A51548: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5154C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51550: 487030B1  bl 0x83154600
	ctx.lr = 0x82A51554;
	sub_83154600(ctx, base);
	// 82A51554: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A51558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5155C: 4840821D  bl 0x82e59778
	ctx.lr = 0x82A51560;
	sub_82E59778(ctx, base);
	// 82A51560: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82A51564: C01F01E4  lfs f0, 0x1e4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51568: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A5156C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A51570: D01F01E4  stfs f0, 0x1e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82A51574: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A51578: 41980144  blt cr6, 0x82a516bc
	if ctx.cr[6].lt {
	pc = 0x82A516BC; continue 'dispatch;
	}
	// 82A5157C: 409A016C  bne cr6, 0x82a516e8
	if !ctx.cr[6].eq {
	pc = 0x82A516E8; continue 'dispatch;
	}
	// 82A51580: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A51584: 895F01E8  lbz r10, 0x1e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A51588: 893F01E9  lbz r9, 0x1e9(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(489 as u32) ) } as u64;
	// 82A5158C: 3BCBD83C  addi r30, r11, -0x27c4
	ctx.r[30].s64 = ctx.r[11].s64 + -10180;
	// 82A51590: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 82A51594: 7D2A0774  extsb r10, r9
	ctx.r[10].s64 = ctx.r[9].s8 as i64;
	// 82A51598: 1D2B0003  mulli r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 * 3;
	// 82A5159C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A515A0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A515A4: 391E003C  addi r8, r30, 0x3c
	ctx.r[8].s64 = ctx.r[30].s64 + 60;
	// 82A515A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A515AC: 38FE0050  addi r7, r30, 0x50
	ctx.r[7].s64 = ctx.r[30].s64 + 80;
	// 82A515B0: 7DA9442E  lfsx f13, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A515B4: 7D8AF42E  lfsx f12, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A515B8: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82A515BC: 7D893C2E  lfsx f12, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A515C0: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A515C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A515C8: 41980120  blt cr6, 0x82a516e8
	if ctx.cr[6].lt {
	pc = 0x82A516E8; continue 'dispatch;
	}
	// 82A515CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A515D0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A515D4: D01F01E4  stfs f0, 0x1e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82A515D8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A515DC: 997F01E8  stb r11, 0x1e8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[11].u8 ) };
	// 82A515E0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82A515E4: 409800C4  bge cr6, 0x82a516a8
	if !ctx.cr[6].lt {
	pc = 0x82A516A8; continue 'dispatch;
	}
	// 82A515E8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A515EC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A515F0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A515F4: 3BAB4680  addi r29, r11, 0x4680
	ctx.r[29].s64 = ctx.r[11].s64 + 18048;
	// 82A515F8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A515FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A51600: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A51604: 483A2405  bl 0x82df3a08
	ctx.lr = 0x82A51608;
	sub_82DF3A08(ctx, base);
	// 82A51608: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A5160C: 809C04EC  lwz r4, 0x4ec(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A51610: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A51614: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A51618: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A5161C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A51620: 48161D59  bl 0x82bb3378
	ctx.lr = 0x82A51624;
	sub_82BB3378(ctx, base);
	// 82A51624: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A51628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5162C: 419A0008  beq cr6, 0x82a51634
	if ctx.cr[6].eq {
	pc = 0x82A51634; continue 'dispatch;
	}
	// 82A51630: 4B86F261  bl 0x822c0890
	ctx.lr = 0x82A51634;
	sub_822C0890(ctx, base);
	// 82A51634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A51638: 483A1DF1  bl 0x82df3428
	ctx.lr = 0x82A5163C;
	sub_82DF3428(ctx, base);
	// 82A5163C: 897F01E8  lbz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A51640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A51644: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A51648: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5164C: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A51650: 483A23B9  bl 0x82df3a08
	ctx.lr = 0x82A51654;
	sub_82DF3A08(ctx, base);
	// 82A51654: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A51658: 809C04EC  lwz r4, 0x4ec(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A5165C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A51660: 48161569  bl 0x82bb2bc8
	ctx.lr = 0x82A51664;
	sub_82BB2BC8(ctx, base);
	// 82A51664: 897F01E8  lbz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A51668: 895F01E9  lbz r10, 0x1e9(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(489 as u32) ) } as u64;
	// 82A5166C: 7D690774  extsb r9, r11
	ctx.r[9].s64 = ctx.r[11].s8 as i64;
	// 82A51670: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51674: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 82A51678: 1D490003  mulli r10, r9, 3
	ctx.r[10].s64 = ctx.r[9].s64 * 3;
	// 82A5167C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A51680: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A51684: 7C2BF42E  lfsx f1, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A51688: 481673E9  bl 0x82bb8a70
	ctx.lr = 0x82A5168C;
	sub_82BB8A70(ctx, base);
	// 82A5168C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A51690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A51694: 419A0008  beq cr6, 0x82a5169c
	if ctx.cr[6].eq {
	pc = 0x82A5169C; continue 'dispatch;
	}
	// 82A51698: 4B86F1F9  bl 0x822c0890
	ctx.lr = 0x82A5169C;
	sub_822C0890(ctx, base);
	// 82A5169C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A516A0: 483A1D89  bl 0x82df3428
	ctx.lr = 0x82A516A4;
	sub_82DF3428(ctx, base);
	// 82A516A4: 48000044  b 0x82a516e8
	pc = 0x82A516E8; continue 'dispatch;
	// 82A516A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A516AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A516B0: 997F01E0  stb r11, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u8 ) };
	// 82A516B4: 4BFFFC1D  bl 0x82a512d0
	ctx.lr = 0x82A516B8;
	sub_82A512D0(ctx, base);
	// 82A516B8: 48000030  b 0x82a516e8
	pc = 0x82A516E8; continue 'dispatch;
	// 82A516BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A516C0: 396B4680  addi r11, r11, 0x4680
	ctx.r[11].s64 = ctx.r[11].s64 + 18048;
	// 82A516C4: C1AB0014  lfs f13, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A516C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A516CC: 4198001C  blt cr6, 0x82a516e8
	if ctx.cr[6].lt {
	pc = 0x82A516E8; continue 'dispatch;
	}
	// 82A516D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A516D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A516D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A516DC: D01F01E4  stfs f0, 0x1e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82A516E0: 997F01E0  stb r11, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u8 ) };
	// 82A516E4: 995F01E8  stb r10, 0x1e8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[10].u8 ) };
	// 82A516E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A516EC: 48756ACC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A516F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A516F0 size=60
    let mut pc: u32 = 0x82A516F0;
    'dispatch: loop {
        match pc {
            0x82A516F0 => {
    //   block [0x82A516F0..0x82A5172C)
	// 82A516F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A516F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A516F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A516FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51704: 4BFFFE3D  bl 0x82a51540
	ctx.lr = 0x82A51708;
	sub_82A51540(ctx, base);
	// 82A51708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5170C: 4BFFF9FD  bl 0x82a51108
	ctx.lr = 0x82A51710;
	sub_82A51108(ctx, base);
	// 82A51710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51714: 4B86E8ED  bl 0x822c0000
	ctx.lr = 0x82A51718;
	sub_822C0000(ctx, base);
	// 82A51718: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A5171C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A51720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A51728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51730 size=112
    let mut pc: u32 = 0x82A51730;
    'dispatch: loop {
        match pc {
            0x82A51730 => {
    //   block [0x82A51730..0x82A517A0)
	// 82A51730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A51738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5173C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A51740: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A51744: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5174C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A51750: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A51754: 4BFE0765  bl 0x82a31eb8
	ctx.lr = 0x82A51758;
	sub_82A31EB8(ctx, base);
	// 82A51758: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A5175C: D3FF0018  stfs f31, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A51760: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A51764: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A51768: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5176C: 394AD8A4  addi r10, r10, -0x275c
	ctx.r[10].s64 = ctx.r[10].s64 + -10076;
	// 82A51770: 993F001C  stb r9, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 82A51774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51778: C00B46A4  lfs f0, 0x46a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5177C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A51780: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A51784: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A51788: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5178C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51790: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A51794: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A51798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5179C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A517A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A517A0 size=24
    let mut pc: u32 = 0x82A517A0;
    'dispatch: loop {
        match pc {
            0x82A517A0 => {
    //   block [0x82A517A0..0x82A517B8)
	// 82A517A0: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82A517A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82A517A8: 41980010  blt cr6, 0x82a517b8
	if ctx.cr[6].lt {
		sub_82A517B8(ctx, base);
		return;
	}
	// 82A517AC: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 82A517B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A517B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A517B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A517B8 size=8
    let mut pc: u32 = 0x82A517B8;
    'dispatch: loop {
        match pc {
            0x82A517B8 => {
    //   block [0x82A517B8..0x82A517C0)
	// 82A517B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A517BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A517C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A517C0 size=64
    let mut pc: u32 = 0x82A517C0;
    'dispatch: loop {
        match pc {
            0x82A517C0 => {
    //   block [0x82A517C0..0x82A51800)
	// 82A517C0: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A517C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A517C8: 41980130  blt cr6, 0x82a518f8
	if ctx.cr[6].lt {
		sub_82A518F8(ctx, base);
		return;
	}
	// 82A517CC: 419A0120  beq cr6, 0x82a518ec
	if ctx.cr[6].eq {
		sub_82A518EC(ctx, base);
		return;
	}
	// 82A517D0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A517D4: 419800C8  blt cr6, 0x82a5189c
	if ctx.cr[6].lt {
		sub_82A5189C(ctx, base);
		return;
	}
	// 82A517D8: 419A009C  beq cr6, 0x82a51874
	if ctx.cr[6].eq {
		sub_82A51874(ctx, base);
		return;
	}
	// 82A517DC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A517E0: 4198005C  blt cr6, 0x82a5183c
	if ctx.cr[6].lt {
		sub_82A5183C(ctx, base);
		return;
	}
	// 82A517E4: 419A001C  beq cr6, 0x82a51800
	if ctx.cr[6].eq {
		sub_82A51800(ctx, base);
		return;
	}
	// 82A517E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A517EC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A517F0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A517F4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A517F8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A517FC: 48000124  b 0x82a51920
	sub_82A518F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51800 size=44
    let mut pc: u32 = 0x82A51800;
    'dispatch: loop {
        match pc {
            0x82A51800 => {
    //   block [0x82A51800..0x82A5182C)
	// 82A51800: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A51804: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A51808: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A5180C: 40980020  bge cr6, 0x82a5182c
	if !ctx.cr[6].lt {
		sub_82A5182C(ctx, base);
		return;
	}
	// 82A51810: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51814: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A51818: 392B46B8  addi r9, r11, 0x46b8
	ctx.r[9].s64 = ctx.r[11].s64 + 18104;
	// 82A5181C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A51820: C00B46B8  lfs f0, 0x46b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51824: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51828: 480000E8  b 0x82a51910
	sub_82A518F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5182C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5182C size=16
    let mut pc: u32 = 0x82A5182C;
    'dispatch: loop {
        match pc {
            0x82A5182C => {
    //   block [0x82A5182C..0x82A5183C)
	// 82A5182C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A51830: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 82A51834: C00A2514  lfs f0, 0x2514(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51838: 48000088  b 0x82a518c0
	sub_82A518B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5183C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5183C size=44
    let mut pc: u32 = 0x82A5183C;
    'dispatch: loop {
        match pc {
            0x82A5183C => {
    //   block [0x82A5183C..0x82A51868)
	// 82A5183C: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A51840: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A51844: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51848: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 82A5184C: 4098001C  bge cr6, 0x82a51868
	if !ctx.cr[6].lt {
		sub_82A51868(ctx, base);
		return;
	}
	// 82A51850: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51854: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A51858: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A5185C: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51860: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51864: 480000AC  b 0x82a51910
	sub_82A518F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51868 size=12
    let mut pc: u32 = 0x82A51868;
    'dispatch: loop {
        match pc {
            0x82A51868 => {
    //   block [0x82A51868..0x82A51874)
	// 82A51868: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A5186C: C00A2960  lfs f0, 0x2960(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51870: 48000050  b 0x82a518c0
	sub_82A518B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51874(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51874 size=24
    let mut pc: u32 = 0x82A51874;
    'dispatch: loop {
        match pc {
            0x82A51874 => {
    //   block [0x82A51874..0x82A5188C)
	// 82A51874: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A51878: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5187C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51880: 4098000C  bge cr6, 0x82a5188c
	if !ctx.cr[6].lt {
		sub_82A5188C(ctx, base);
		return;
	}
	// 82A51884: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51888: 4BFFFF90  b 0x82a51818
	sub_82A51800(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5188C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5188C size=16
    let mut pc: u32 = 0x82A5188C;
    'dispatch: loop {
        match pc {
            0x82A5188C => {
    //   block [0x82A5188C..0x82A5189C)
	// 82A5188C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A51890: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 82A51894: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51898: 48000028  b 0x82a518c0
	sub_82A518B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5189C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5189C size=28
    let mut pc: u32 = 0x82A5189C;
    'dispatch: loop {
        match pc {
            0x82A5189C => {
    //   block [0x82A5189C..0x82A518B8)
	// 82A5189C: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A518A0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A518A4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A518A8: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 82A518AC: 4098000C  bge cr6, 0x82a518b8
	if !ctx.cr[6].lt {
		sub_82A518B8(ctx, base);
		return;
	}
	// 82A518B0: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A518B4: 4BFFFFA4  b 0x82a51858
	sub_82A5183C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A518B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A518B8 size=52
    let mut pc: u32 = 0x82A518B8;
    'dispatch: loop {
        match pc {
            0x82A518B8 => {
    //   block [0x82A518B8..0x82A518EC)
	// 82A518B8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A518BC: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A518C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A518C4: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A518C8: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A518CC: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A518D0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A518D4: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A518D8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A518DC: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A518E0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A518E4: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A518E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A518EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A518EC size=12
    let mut pc: u32 = 0x82A518EC;
    'dispatch: loop {
        match pc {
            0x82A518EC => {
    //   block [0x82A518EC..0x82A518F8)
	// 82A518EC: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A518F0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A518F4: 48000008  b 0x82a518fc
	sub_82A518F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A518F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A518F8 size=48
    let mut pc: u32 = 0x82A518F8;
    'dispatch: loop {
        match pc {
            0x82A518F8 => {
    //   block [0x82A518F8..0x82A51928)
	// 82A518F8: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A518FC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51900: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A51904: 396B46B8  addi r11, r11, 0x46b8
	ctx.r[11].s64 = ctx.r[11].s64 + 18104;
	// 82A51908: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5190C: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51910: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A51914: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A51918: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A5191C: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A51920: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A51924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51928 size=556
    let mut pc: u32 = 0x82A51928;
    'dispatch: loop {
        match pc {
            0x82A51928 => {
    //   block [0x82A51928..0x82A51B54)
	// 82A51928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5192C: 48756841  bl 0x831a816c
	ctx.lr = 0x82A51930;
	sub_831A8130(ctx, base);
	// 82A51930: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A51934: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5193C: 48702CC5  bl 0x83154600
	ctx.lr = 0x82A51940;
	sub_83154600(ctx, base);
	// 82A51940: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A51944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51948: 4BFFD241  bl 0x82a4eb88
	ctx.lr = 0x82A5194C;
	sub_82A4EB88(ctx, base);
	// 82A5194C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51950: 48407E29  bl 0x82e59778
	ctx.lr = 0x82A51954;
	sub_82E59778(ctx, base);
	// 82A51954: 897F01B5  lbz r11, 0x1b5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(437 as u32) ) } as u64;
	// 82A51958: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A5195C: C01F01B8  lfs f0, 0x1b8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51960: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A51964: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A51968: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A5196C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A51970: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A51974: 419800B4  blt cr6, 0x82a51a28
	if ctx.cr[6].lt {
	pc = 0x82A51A28; continue 'dispatch;
	}
	// 82A51978: 409A0148  bne cr6, 0x82a51ac0
	if !ctx.cr[6].eq {
	pc = 0x82A51AC0; continue 'dispatch;
	}
	// 82A5197C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51980: C1AB46D4  lfs f13, 0x46d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51984: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A51988: 41980138  blt cr6, 0x82a51ac0
	if ctx.cr[6].lt {
	pc = 0x82A51AC0; continue 'dispatch;
	}
	// 82A5198C: 815F01D0  lwz r10, 0x1d0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82A51990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A51994: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A51998: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A5199C: 997F01B5  stb r11, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[11].u8 ) };
	// 82A519A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A519A4: 996A001C  stb r11, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82A519A8: 4BA990E1  bl 0x824eaa88
	ctx.lr = 0x82A519AC;
	sub_824EAA88(ctx, base);
	// 82A519AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A519B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A519B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A519B8: 4BABDA11  bl 0x8250f3c8
	ctx.lr = 0x82A519BC;
	sub_8250F3C8(ctx, base);
	// 82A519BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A519C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A519C4: 4BA9964D  bl 0x824eb010
	ctx.lr = 0x82A519C8;
	sub_824EB010(ctx, base);
	// 82A519C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A519CC: 895F01BC  lbz r10, 0x1bc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82A519D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A519D4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A519D8: C00B2960  lfs f0, 0x2960(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A519DC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A519E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A519E4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A519E8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A519EC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A519F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A519F4: 997F01BC  stb r11, 0x1bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 82A519F8: 483A0299  bl 0x82df1c90
	ctx.lr = 0x82A519FC;
	sub_82DF1C90(ctx, base);
	// 82A519FC: 897F01BC  lbz r11, 0x1bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 82A51A00: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A51A04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A51A08: 4198000C  blt cr6, 0x82a51a14
	if ctx.cr[6].lt {
	pc = 0x82A51A14; continue 'dispatch;
	}
	// 82A51A0C: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 82A51A10: 997F01BC  stb r11, 0x1bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 82A51A14: 39600610  li r11, 0x610
	ctx.r[11].s64 = 1552;
	// 82A51A18: 394001C0  li r10, 0x1c0
	ctx.r[10].s64 = 448;
	// 82A51A1C: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A51B58 size=60
    let mut pc: u32 = 0x82A51B58;
    'dispatch: loop {
        match pc {
            0x82A51B58 => {
    //   block [0x82A51B58..0x82A51B94)
	// 82A51B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A51B60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A51B64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51B6C: 4BFFFDBD  bl 0x82a51928
	ctx.lr = 0x82A51B70;
	sub_82A51928(ctx, base);
	// 82A51B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51B74: 4B86E48D  bl 0x822c0000
	ctx.lr = 0x82A51B78;
	sub_822C0000(ctx, base);
	// 82A51B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51B7C: 48702A85  bl 0x83154600
	ctx.lr = 0x82A51B80;
	sub_83154600(ctx, base);
	// 82A51B80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A51B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A51B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A51B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A51B98 size=196
    let mut pc: u32 = 0x82A51B98;
    'dispatch: loop {
        match pc {
            0x82A51B98 => {
    //   block [0x82A51B98..0x82A51C5C)
	// 82A51B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A51BA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A51BA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A51BA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51BAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A51BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A51BB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A51BB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A51BBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A51BC0: 4B86ED79  bl 0x822c0938
	ctx.lr = 0x82A51BC4;
	sub_822C0938(ctx, base);
	// 82A51BC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A51BC8: 41820028  beq 0x82a51bf0
	if ctx.cr[0].eq {
	pc = 0x82A51BF0; continue 'dispatch;
	}
	// 82A51BCC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A51BD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A51BD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A51BD8: 392BD8D0  addi r9, r11, -0x2730
	ctx.r[9].s64 = ctx.r[11].s64 + -10032;
	// 82A51BDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A51BE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A51BE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A51BE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A51BEC: 48000008  b 0x82a51bf4
	pc = 0x82A51BF4; continue 'dispatch;
	// 82A51BF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A51BF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A51BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A51BFC: 409A0044  bne cr6, 0x82a51c40
	if !ctx.cr[6].eq {
	pc = 0x82A51C40; continue 'dispatch;
	}
	// 82A51C00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A51C04: 419A001C  beq cr6, 0x82a51c20
	if ctx.cr[6].eq {
	pc = 0x82A51C20; continue 'dispatch;
	}
	// 82A51C08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51C0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A51C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51C14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A51C1C: 4E800421  bctrl
	ctx.lr = 0x82A51C20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A51C20: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51C24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A51C28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A51C2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A51C30: 816B46F0  lwz r11, 0x46f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18160 as u32) ) } as u64;
	// 82A51C34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A51C38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A51C3C: 4B86E3C5  bl 0x822c0000
	ctx.lr = 0x82A51C40;
	sub_822C0000(ctx, base);
	// 82A51C40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A51C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A51C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A51C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51C50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A51C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A51C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51C60 size=460
    let mut pc: u32 = 0x82A51C60;
    'dispatch: loop {
        match pc {
            0x82A51C60 => {
    //   block [0x82A51C60..0x82A51E2C)
	// 82A51C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51C64: 48756505  bl 0x831a8168
	ctx.lr = 0x82A51C68;
	sub_831A8130(ctx, base);
	// 82A51C68: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A51C6C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51C74: 4870298D  bl 0x83154600
	ctx.lr = 0x82A51C78;
	sub_83154600(ctx, base);
	// 82A51C78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A51C7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51C80: 4BFFCC99  bl 0x82a4e918
	ctx.lr = 0x82A51C84;
	sub_82A4E918(ctx, base);
	// 82A51C84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A51C88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A51C8C: 388BD8E0  addi r4, r11, -0x2720
	ctx.r[4].s64 = ctx.r[11].s64 + -10016;
	// 82A51C90: 38A001EF  li r5, 0x1ef
	ctx.r[5].s64 = 495;
	// 82A51C94: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A51C98: 4B86E741  bl 0x822c03d8
	ctx.lr = 0x82A51C9C;
	sub_822C03D8(ctx, base);
	// 82A51C9C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A51CA0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A51CA4: 4182002C  beq 0x82a51cd0
	if ctx.cr[0].eq {
	pc = 0x82A51CD0; continue 'dispatch;
	}
	// 82A51CA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51CAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A51CB0: C3EB46C4  lfs f31, 0x46c4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18116 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A51CB4: 4BFE028D  bl 0x82a31f40
	ctx.lr = 0x82A51CB8;
	sub_82A31F40(ctx, base);
	// 82A51CB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A51CBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A51CC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A51CC4: 4BFFFA6D  bl 0x82a51730
	ctx.lr = 0x82A51CC8;
	sub_82A51730(ctx, base);
	// 82A51CC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A51CCC: 48000008  b 0x82a51cd4
	pc = 0x82A51CD4; continue 'dispatch;
	// 82A51CD0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82A51CD4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A51CD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A51CDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A51CE0: 4BFFFEB9  bl 0x82a51b98
	ctx.lr = 0x82A51CE4;
	sub_82A51B98(ctx, base);
	// 82A51CE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A51CE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A51CEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A51CF0: 4B86E311  bl 0x822c0000
	ctx.lr = 0x82A51CF4;
	sub_822C0000(ctx, base);
	// 82A51CF4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A51CF8: 3BDF01D0  addi r30, r31, 0x1d0
	ctx.r[30].s64 = ctx.r[31].s64 + 464;
	// 82A51CFC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A51D00: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A51D04: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82A51D08: 4B872759  bl 0x822c4460
	ctx.lr = 0x82A51D0C;
	sub_822C4460(ctx, base);
	// 82A51D0C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A51D10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A51D14: 419A0008  beq cr6, 0x82a51d1c
	if ctx.cr[6].eq {
	pc = 0x82A51D1C; continue 'dispatch;
	}
	// 82A51D18: 4B86EB79  bl 0x822c0890
	ctx.lr = 0x82A51D1C;
	sub_822C0890(ctx, base);
	// 82A51D1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A51D20: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A51D28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A51D2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A51D30: 419A0024  beq cr6, 0x82a51d54
	if ctx.cr[6].eq {
	pc = 0x82A51D54; continue 'dispatch;
	}
	// 82A51D34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A51D38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A51D3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A51D40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A51D44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A51D48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A51D4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A51D50: 4082FFE8  bne 0x82a51d38
	if !ctx.cr[0].eq {
	pc = 0x82A51D38; continue 'dispatch;
	}
	// 82A51D54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A51D5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A51D60: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A51D64: 4BFE683D  bl 0x82a385a0
	ctx.lr = 0x82A51D68;
	sub_82A385A0(ctx, base);
	// 82A51D68: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A51D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A51D70: 388BD748  addi r4, r11, -0x28b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10424;
	// 82A51D74: 483A1C95  bl 0x82df3a08
	ctx.lr = 0x82A51D78;
	sub_82DF3A08(ctx, base);
	// 82A51D78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A51D7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A51D80: 809D04EC  lwz r4, 0x4ec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A51D84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A51D88: C04B964C  lfs f2, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A51D8C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A51D90: 481615E9  bl 0x82bb3378
	ctx.lr = 0x82A51D94;
	sub_82BB3378(ctx, base);
	// 82A51D94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A51D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A51D9C: 419A0008  beq cr6, 0x82a51da4
	if ctx.cr[6].eq {
	pc = 0x82A51DA4; continue 'dispatch;
	}
	// 82A51DA0: 4B86EAF1  bl 0x822c0890
	ctx.lr = 0x82A51DA4;
	sub_822C0890(ctx, base);
	// 82A51DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A51DA8: 483A1681  bl 0x82df3428
	ctx.lr = 0x82A51DAC;
	sub_82DF3428(ctx, base);
	// 82A51DAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51DB0: 9B9F01B4  stb r28, 0x1b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[28].u8 ) };
	// 82A51DB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A51DB8: 9B9F01B5  stb r28, 0x1b5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(437 as u32), ctx.r[28].u8 ) };
	// 82A51DBC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51DC0: D01F01B0  stfs f0, 0x1b0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82A51DC4: D01F01B8  stfs f0, 0x1b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82A51DC8: 4BA98CC1  bl 0x824eaa88
	ctx.lr = 0x82A51DCC;
	sub_824EAA88(ctx, base);
	// 82A51DCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A51DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A51DD4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A51DD8: 4BABD5F1  bl 0x8250f3c8
	ctx.lr = 0x82A51DDC;
	sub_8250F3C8(ctx, base);
	// 82A51DDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A51DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A51DE4: 4BA9922D  bl 0x824eb010
	ctx.lr = 0x82A51DE8;
	sub_824EB010(ctx, base);
	// 82A51DE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A51DEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A51DF0: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51DF4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A51DF8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A51DFC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82A51E00: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A51E04: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 82A51E08: 997F01BC  stb r11, 0x1bc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u8 ) };
	// 82A51E0C: 4839FE85  bl 0x82df1c90
	ctx.lr = 0x82A51E10;
	sub_82DF1C90(ctx, base);
	// 82A51E10: 39600610  li r11, 0x610
	ctx.r[11].s64 = 1552;
	// 82A51E14: 394001C0  li r10, 0x1c0
	ctx.r[10].s64 = 448;
	// 82A51E18: 13FD58C7  vcmpequd (lvx128) v31, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51E30 size=92
    let mut pc: u32 = 0x82A51E30;
    'dispatch: loop {
        match pc {
            0x82A51E30 => {
    //   block [0x82A51E30..0x82A51E8C)
	// 82A51E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A51E38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A51E3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51E40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51E44: 4BFE0075  bl 0x82a31eb8
	ctx.lr = 0x82A51E48;
	sub_82A31EB8(ctx, base);
	// 82A51E48: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A51E4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A51E50: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A51E54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A51E58: 3929D934  addi r9, r9, -0x26cc
	ctx.r[9].s64 = ctx.r[9].s64 + -9932;
	// 82A51E5C: C00B6A70  lfs f0, 0x6a70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51E60: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 82A51E64: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51E68: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A51E6C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A51E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51E74: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A51E78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A51E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A51E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A51E84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A51E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51E90 size=28
    let mut pc: u32 = 0x82A51E90;
    'dispatch: loop {
        match pc {
            0x82A51E90 => {
    //   block [0x82A51E90..0x82A51EAC)
	// 82A51E90: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51E94: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A51E98: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51E9C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A51EA0: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A51EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A51EA8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51EAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51EAC size=16
    let mut pc: u32 = 0x82A51EAC;
    'dispatch: loop {
        match pc {
            0x82A51EAC => {
    //   block [0x82A51EAC..0x82A51EBC)
	// 82A51EAC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A51EB0: C00B4798  lfs f0, 0x4798(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51EB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A51EB8: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51EBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51EBC size=20
    let mut pc: u32 = 0x82A51EBC;
    'dispatch: loop {
        match pc {
            0x82A51EBC => {
    //   block [0x82A51EBC..0x82A51ED0)
	// 82A51EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A51EC0: EC0D0028  fsubs f0, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A51EC4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A51EC8: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A51ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51ED0 size=48
    let mut pc: u32 = 0x82A51ED0;
    'dispatch: loop {
        match pc {
            0x82A51ED0 => {
    //   block [0x82A51ED0..0x82A51F00)
	// 82A51ED0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A51ED4: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A51ED8: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A51EDC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A51EE0: 394A478C  addi r10, r10, 0x478c
	ctx.r[10].s64 = ctx.r[10].s64 + 18316;
	// 82A51EE4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A51EE8: C16908A4  lfs f11, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A51EEC: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 82A51EF0: 41980010  blt cr6, 0x82a51f00
	if ctx.cr[6].lt {
		sub_82A51F00(ctx, base);
		return;
	}
	// 82A51EF4: 409A003C  bne cr6, 0x82a51f30
	if !ctx.cr[6].eq {
		sub_82A51F00(ctx, base);
		return;
	}
	// 82A51EF8: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51EFC: 48000034  b 0x82a51f30
	sub_82A51F00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A51F00 size=92
    let mut pc: u32 = 0x82A51F00;
    'dispatch: loop {
        match pc {
            0x82A51F00 => {
    //   block [0x82A51F00..0x82A51F5C)
	// 82A51F00: C1A40018  lfs f13, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51F04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A51F08: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51F0C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82A51F10: C18B08A8  lfs f12, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A51F14: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82A51F18: 40980008  bge cr6, 0x82a51f20
	if !ctx.cr[6].lt {
	pc = 0x82A51F20; continue 'dispatch;
	}
	// 82A51F1C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82A51F20: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51F24: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51F28: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A51F2C: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A51F30: 54AB07FF  clrlwi. r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A51F34: 41820008  beq 0x82a51f3c
	if ctx.cr[0].eq {
	pc = 0x82A51F3C; continue 'dispatch;
	}
	// 82A51F38: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A51F3C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A51F40: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A51F44: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A51F48: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A51F4C: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A51F50: C00BDF50  lfs f0, -0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A51F54: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A51F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A51F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A51F60 size=248
    let mut pc: u32 = 0x82A51F60;
    'dispatch: loop {
        match pc {
            0x82A51F60 => {
    //   block [0x82A51F60..0x82A52058)
	// 82A51F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A51F64: 48756209  bl 0x831a816c
	ctx.lr = 0x82A51F68;
	sub_831A8130(ctx, base);
	// 82A51F68: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A51F6C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A51F70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A51F74: 4870268D  bl 0x83154600
	ctx.lr = 0x82A51F78;
	sub_83154600(ctx, base);
	// 82A51F78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A51F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51F80: 4BFFCC09  bl 0x82a4eb88
	ctx.lr = 0x82A51F84;
	sub_82A4EB88(ctx, base);
	// 82A51F84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A51F88: 3BDE0610  addi r30, r30, 0x610
	ctx.r[30].s64 = ctx.r[30].s64 + 1552;
	// 82A51F8C: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A51F90: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A51F94: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82A51F98: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A51F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A51FA0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A51FA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A52058 size=452
    let mut pc: u32 = 0x82A52058;
    'dispatch: loop {
        match pc {
            0x82A52058 => {
    //   block [0x82A52058..0x82A5221C)
	// 82A52058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5205C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A52060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A52064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A52068: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A5206C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A52220 size=196
    let mut pc: u32 = 0x82A52220;
    'dispatch: loop {
        match pc {
            0x82A52220 => {
    //   block [0x82A52220..0x82A522E4)
	// 82A52220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A52224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A52228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5222C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A52230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52234: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A52238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5223C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A52240: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A52244: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52248: 4B86E6F1  bl 0x822c0938
	ctx.lr = 0x82A5224C;
	sub_822C0938(ctx, base);
	// 82A5224C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A52250: 41820028  beq 0x82a52278
	if ctx.cr[0].eq {
	pc = 0x82A52278; continue 'dispatch;
	}
	// 82A52254: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52258: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A5225C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A52260: 392BD960  addi r9, r11, -0x26a0
	ctx.r[9].s64 = ctx.r[11].s64 + -9888;
	// 82A52264: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A52268: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5226C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A52270: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A52274: 48000008  b 0x82a5227c
	pc = 0x82A5227C; continue 'dispatch;
	// 82A52278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5227C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52284: 409A0044  bne cr6, 0x82a522c8
	if !ctx.cr[6].eq {
	pc = 0x82A522C8; continue 'dispatch;
	}
	// 82A52288: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5228C: 419A001C  beq cr6, 0x82a522a8
	if ctx.cr[6].eq {
	pc = 0x82A522A8; continue 'dispatch;
	}
	// 82A52290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52294: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A52298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5229C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A522A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A522A4: 4E800421  bctrl
	ctx.lr = 0x82A522A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A522A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A522AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A522B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A522B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A522B8: 816B479C  lwz r11, 0x479c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18332 as u32) ) } as u64;
	// 82A522BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A522C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A522C4: 4B86DD3D  bl 0x822c0000
	ctx.lr = 0x82A522C8;
	sub_822C0000(ctx, base);
	// 82A522C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A522CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A522D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A522D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A522D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A522DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A522E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A522E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A522E8 size=196
    let mut pc: u32 = 0x82A522E8;
    'dispatch: loop {
        match pc {
            0x82A522E8 => {
    //   block [0x82A522E8..0x82A523AC)
	// 82A522E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A522EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A522F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A522F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A522F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A522FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A52300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A52304: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A52308: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5230C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52310: 4B86E629  bl 0x822c0938
	ctx.lr = 0x82A52314;
	sub_822C0938(ctx, base);
	// 82A52314: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A52318: 41820028  beq 0x82a52340
	if ctx.cr[0].eq {
	pc = 0x82A52340; continue 'dispatch;
	}
	// 82A5231C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52320: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A52324: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A52328: 392BD974  addi r9, r11, -0x268c
	ctx.r[9].s64 = ctx.r[11].s64 + -9868;
	// 82A5232C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A52330: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A52334: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A52338: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5233C: 48000008  b 0x82a52344
	pc = 0x82A52344; continue 'dispatch;
	// 82A52340: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A52344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5234C: 409A0044  bne cr6, 0x82a52390
	if !ctx.cr[6].eq {
	pc = 0x82A52390; continue 'dispatch;
	}
	// 82A52350: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A52354: 419A001C  beq cr6, 0x82a52370
	if ctx.cr[6].eq {
	pc = 0x82A52370; continue 'dispatch;
	}
	// 82A52358: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5235C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A52360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52364: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52368: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A5236C: 4E800421  bctrl
	ctx.lr = 0x82A52370;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A52370: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A52374: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A52378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5237C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A52380: 816B479C  lwz r11, 0x479c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18332 as u32) ) } as u64;
	// 82A52384: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A52388: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5238C: 4B86DC75  bl 0x822c0000
	ctx.lr = 0x82A52390;
	sub_822C0000(ctx, base);
	// 82A52390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A52394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A52398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5239C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A523A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A523A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A523A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A523B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A523B0 size=148
    let mut pc: u32 = 0x82A523B0;
    'dispatch: loop {
        match pc {
            0x82A523B0 => {
    //   block [0x82A523B0..0x82A52444)
	// 82A523B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A523B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A523B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A523BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A523C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A523C4: 4BFFFB9D  bl 0x82a51f60
	ctx.lr = 0x82A523C8;
	sub_82A51F60(ctx, base);
	// 82A523C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A523CC: 4BFFFC8D  bl 0x82a52058
	ctx.lr = 0x82A523D0;
	sub_82A52058(ctx, base);
	// 82A523D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A523D4: 4B86DC2D  bl 0x822c0000
	ctx.lr = 0x82A523D8;
	sub_822C0000(ctx, base);
	// 82A523D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A523DC: 48702225  bl 0x83154600
	ctx.lr = 0x82A523E0;
	sub_83154600(ctx, base);
	// 82A523E0: 8963054C  lbz r11, 0x54c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1356 as u32) ) } as u64;
	// 82A523E4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82A523E8: 41980048  blt cr6, 0x82a52430
	if ctx.cr[6].lt {
	pc = 0x82A52430; continue 'dispatch;
	}
	// 82A523EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A523F0: 48407389  bl 0x82e59778
	ctx.lr = 0x82A523F4;
	sub_82E59778(ctx, base);
	// 82A523F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A523F8: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A523FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A52400: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A52404: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A52408: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5240C: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A52410: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A52414: 41990014  bgt cr6, 0x82a52428
	if ctx.cr[6].gt {
	pc = 0x82A52428; continue 'dispatch;
	}
	// 82A52418: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A5241C: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A52420: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A52424: 40980008  bge cr6, 0x82a5242c
	if !ctx.cr[6].lt {
	pc = 0x82A5242C; continue 'dispatch;
	}
	// 82A52428: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82A5242C: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82A52430: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A52434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A52438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5243C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A52440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A52448 size=200
    let mut pc: u32 = 0x82A52448;
    'dispatch: loop {
        match pc {
            0x82A52448 => {
    //   block [0x82A52448..0x82A52510)
	// 82A52448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5244C: 48755D1D  bl 0x831a8168
	ctx.lr = 0x82A52450;
	sub_831A8130(ctx, base);
	// 82A52450: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A52454: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52458: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5245C: 487021A5  bl 0x83154600
	ctx.lr = 0x82A52460;
	sub_83154600(ctx, base);
	// 82A52460: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A52464: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52468: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A5246C: 3B830028  addi r28, r3, 0x28
	ctx.r[28].s64 = ctx.r[3].s64 + 40;
	// 82A52470: 3BABD988  addi r29, r11, -0x2678
	ctx.r[29].s64 = ctx.r[11].s64 + -9848;
	// 82A52474: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A52478: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5247C: 4B98148D  bl 0x823d3908
	ctx.lr = 0x82A52480;
	sub_823D3908(ctx, base);
	// 82A52480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52484: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A52488: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5248C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52490: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A52494: 419A0024  beq cr6, 0x82a524b8
	if ctx.cr[6].eq {
	pc = 0x82A524B8; continue 'dispatch;
	}
	// 82A52498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5249C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A524A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A524A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A524A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A524AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A524B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A524B4: 4082FFE8  bne 0x82a5249c
	if !ctx.cr[0].eq {
	pc = 0x82A5249C; continue 'dispatch;
	}
	// 82A524B8: 817E01B4  lwz r11, 0x1b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(436 as u32) ) } as u64;
	// 82A524BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A524C0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A524C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A524C8: 38A00103  li r5, 0x103
	ctx.r[5].s64 = 259;
	// 82A524CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A524D0: 7CCBF82E  lwzx r6, r11, r31
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A524D4: 4840656D  bl 0x82e58a40
	ctx.lr = 0x82A524D8;
	sub_82E58A40(ctx, base);
	// 82A524D8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A524DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A524E0: 419A0008  beq cr6, 0x82a524e8
	if ctx.cr[6].eq {
	pc = 0x82A524E8; continue 'dispatch;
	}
	// 82A524E4: 4B86E3AD  bl 0x822c0890
	ctx.lr = 0x82A524E8;
	sub_822C0890(ctx, base);
	// 82A524E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A524EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A524F0: 419A0008  beq cr6, 0x82a524f8
	if ctx.cr[6].eq {
	pc = 0x82A524F8; continue 'dispatch;
	}
	// 82A524F4: 4B86E39D  bl 0x822c0890
	ctx.lr = 0x82A524F8;
	sub_822C0890(ctx, base);
	// 82A524F8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A524FC: 2F1F0014  cmpwi cr6, r31, 0x14
	ctx.cr[6].compare_i32(ctx.r[31].s32, 20, &mut ctx.xer);
	// 82A52500: 4198FF78  blt cr6, 0x82a52478
	if ctx.cr[6].lt {
	pc = 0x82A52478; continue 'dispatch;
	}
	// 82A52504: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A52508: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A5250C: 48755CAC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A52510 size=976
    let mut pc: u32 = 0x82A52510;
    'dispatch: loop {
        match pc {
            0x82A52510 => {
    //   block [0x82A52510..0x82A528E0)
	// 82A52510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A52514: 48755C31  bl 0x831a8144
	ctx.lr = 0x82A52518;
	sub_831A8130(ctx, base);
	// 82A52518: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 82A5251C: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 82A52520: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82A52524: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52528: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5252C: 487020D5  bl 0x83154600
	ctx.lr = 0x82A52530;
	sub_83154600(ctx, base);
	// 82A52530: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A52534: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A52538: 4BFFC3E1  bl 0x82a4e918
	ctx.lr = 0x82A5253C;
	sub_82A4E918(ctx, base);
	// 82A5253C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52540: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A52544: 3AABD988  addi r21, r11, -0x2678
	ctx.r[21].s64 = ctx.r[11].s64 + -9848;
	// 82A52548: 38A000D9  li r5, 0xd9
	ctx.r[5].s64 = 217;
	// 82A5254C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A52550: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A52554: 4B86DE85  bl 0x822c03d8
	ctx.lr = 0x82A52558;
	sub_822C03D8(ctx, base);
	// 82A52558: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A5255C: 41820010  beq 0x82a5256c
	if ctx.cr[0].eq {
	pc = 0x82A5256C; continue 'dispatch;
	}
	// 82A52560: 4BFFF8D1  bl 0x82a51e30
	ctx.lr = 0x82A52564;
	sub_82A51E30(ctx, base);
	// 82A52564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A52568: 48000008  b 0x82a52570
	pc = 0x82A52570; continue 'dispatch;
	// 82A5256C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A52570: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A52574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A52578: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A5257C: 4BFFFCA5  bl 0x82a52220
	ctx.lr = 0x82A52580;
	sub_82A52220(ctx, base);
	// 82A52580: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A52584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A52588: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A5258C: 4B86DA75  bl 0x822c0000
	ctx.lr = 0x82A52590;
	sub_822C0000(ctx, base);
	// 82A52590: 82810054  lwz r20, 0x54(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A52594: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A52598: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82A5259C: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 82A525A0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A525A4: 419A0024  beq cr6, 0x82a525c8
	if ctx.cr[6].eq {
	pc = 0x82A525C8; continue 'dispatch;
	}
	// 82A525A8: 39740004  addi r11, r20, 4
	ctx.r[11].s64 = ctx.r[20].s64 + 4;
	// 82A525AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A525B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A525B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A525B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A525BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A525C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A525C4: 4082FFE8  bne 0x82a525ac
	if !ctx.cr[0].eq {
	pc = 0x82A525AC; continue 'dispatch;
	}
	// 82A525C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A525CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A525D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A525D4: C3AB08A8  lfs f29, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A525D8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A525DC: 4BFE5FC5  bl 0x82a385a0
	ctx.lr = 0x82A525E0;
	sub_82A385A0(ctx, base);
	// 82A525E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A525E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A525E8: 388BC598  addi r4, r11, -0x3a68
	ctx.r[4].s64 = ctx.r[11].s64 + -14952;
	// 82A525EC: 483A141D  bl 0x82df3a08
	ctx.lr = 0x82A525F0;
	sub_82DF3A08(ctx, base);
	// 82A525F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A525F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A525F8: 809C04EC  lwz r4, 0x4ec(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1260 as u32) ) } as u64;
	// 82A525FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A52600: C04B6150  lfs f2, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A52604: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82A52608: 48160D71  bl 0x82bb3378
	ctx.lr = 0x82A5260C;
	sub_82BB3378(ctx, base);
	// 82A5260C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A52610: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52614: 419A0008  beq cr6, 0x82a5261c
	if ctx.cr[6].eq {
	pc = 0x82A5261C; continue 'dispatch;
	}
	// 82A52618: 4B86E279  bl 0x822c0890
	ctx.lr = 0x82A5261C;
	sub_822C0890(ctx, base);
	// 82A5261C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52620: 483A0E09  bl 0x82df3428
	ctx.lr = 0x82A52624;
	sub_82DF3428(ctx, base);
	// 82A52624: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A52628: 39400610  li r10, 0x610
	ctx.r[10].s64 = 1552;
	// 82A5262C: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 82A52630: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82A52634: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A52638: 3ADB01C0  addi r22, r27, 0x1c0
	ctx.r[22].s64 = ctx.r[27].s64 + 448;
	// 82A5263C: 3AFB01B0  addi r23, r27, 0x1b0
	ctx.r[23].s64 = ctx.r[27].s64 + 432;
	// 82A52640: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A52644: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A528E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A528E0 size=196
    let mut pc: u32 = 0x82A528E0;
    'dispatch: loop {
        match pc {
            0x82A528E0 => {
    //   block [0x82A528E0..0x82A529A4)
	// 82A528E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A528E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A528E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A528EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A528F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A528F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A528F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A528FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A52900: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A52904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52908: 4B86E031  bl 0x822c0938
	ctx.lr = 0x82A5290C;
	sub_822C0938(ctx, base);
	// 82A5290C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A52910: 41820028  beq 0x82a52938
	if ctx.cr[0].eq {
	pc = 0x82A52938; continue 'dispatch;
	}
	// 82A52914: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52918: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A5291C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A52920: 392BDA08  addi r9, r11, -0x25f8
	ctx.r[9].s64 = ctx.r[11].s64 + -9720;
	// 82A52924: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A52928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5292C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A52930: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A52934: 48000008  b 0x82a5293c
	pc = 0x82A5293C; continue 'dispatch;
	// 82A52938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5293C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52944: 409A0044  bne cr6, 0x82a52988
	if !ctx.cr[6].eq {
	pc = 0x82A52988; continue 'dispatch;
	}
	// 82A52948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5294C: 419A001C  beq cr6, 0x82a52968
	if ctx.cr[6].eq {
	pc = 0x82A52968; continue 'dispatch;
	}
	// 82A52950: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52954: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A52958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5295C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A52964: 4E800421  bctrl
	ctx.lr = 0x82A52968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A52968: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A5296C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A52970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52974: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A52978: 816B4880  lwz r11, 0x4880(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18560 as u32) ) } as u64;
	// 82A5297C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A52980: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A52984: 4B86D67D  bl 0x822c0000
	ctx.lr = 0x82A52988;
	sub_822C0000(ctx, base);
	// 82A52988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5298C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A52990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A52994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A52998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5299C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A529A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A529A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A529A8 size=108
    let mut pc: u32 = 0x82A529A8;
    'dispatch: loop {
        match pc {
            0x82A529A8 => {
    //   block [0x82A529A8..0x82A52A14)
	// 82A529A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A529AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A529B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A529B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A529B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A529BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A529C0: 396BC234  addi r11, r11, -0x3dcc
	ctx.r[11].s64 = ctx.r[11].s64 + -15820;
	// 82A529C4: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82A529C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A529CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A529D0: 419A0008  beq cr6, 0x82a529d8
	if ctx.cr[6].eq {
	pc = 0x82A529D8; continue 'dispatch;
	}
	// 82A529D4: 4813BB4D  bl 0x82b8e520
	ctx.lr = 0x82A529D8;
	sub_82B8E520(ctx, base);
	// 82A529D8: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82A529DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A529E0: 419A0008  beq cr6, 0x82a529e8
	if ctx.cr[6].eq {
	pc = 0x82A529E8; continue 'dispatch;
	}
	// 82A529E4: 4B86DEAD  bl 0x822c0890
	ctx.lr = 0x82A529E8;
	sub_822C0890(ctx, base);
	// 82A529E8: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82A529EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A529F0: 419A0008  beq cr6, 0x82a529f8
	if ctx.cr[6].eq {
	pc = 0x82A529F8; continue 'dispatch;
	}
	// 82A529F4: 4B86DE9D  bl 0x822c0890
	ctx.lr = 0x82A529F8;
	sub_822C0890(ctx, base);
	// 82A529F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A529FC: 48409B8D  bl 0x82e5c588
	ctx.lr = 0x82A52A00;
	sub_82E5C588(ctx, base);
	// 82A52A00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A52A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A52A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A52A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A52A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A52A18 size=432
    let mut pc: u32 = 0x82A52A18;
    'dispatch: loop {
        match pc {
            0x82A52A18 => {
    //   block [0x82A52A18..0x82A52BC8)
	// 82A52A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A52A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A52A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A52A24: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 82A52A28: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82A52A2C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A52A30: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52A34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A52A38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A52A3C: 419A016C  beq cr6, 0x82a52ba8
	if ctx.cr[6].eq {
	pc = 0x82A52BA8; continue 'dispatch;
	}
	// 82A52A40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52A48: 388BDA3C  addi r4, r11, -0x25c4
	ctx.r[4].s64 = ctx.r[11].s64 + -9668;
	// 82A52A4C: 483A0FBD  bl 0x82df3a08
	ctx.lr = 0x82A52A50;
	sub_82DF3A08(ctx, base);
	// 82A52A50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A52A54: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A52A58: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A52A5C: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82A52A60: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A52A64: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A52A68: 3888DF54  addi r4, r8, -0x20ac
	ctx.r[4].s64 = ctx.r[8].s64 + -8364;
	// 82A52A6C: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A52A70: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A52A74: C3A90210  lfs f29, 0x210(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(528 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A52A78: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A52A7C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A52A80: 4BB50731  bl 0x825a31b0
	ctx.lr = 0x82A52A84;
	sub_825A31B0(ctx, base);
	// 82A52A84: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A52A88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A52A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52A90: 4BB4ECE1  bl 0x825a1770
	ctx.lr = 0x82A52A94;
	sub_825A1770(ctx, base);
	// 82A52A94: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A52A98: 483A0991  bl 0x82df3428
	ctx.lr = 0x82A52A9C;
	sub_82DF3428(ctx, base);
	// 82A52A9C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A52AA0: 4B876219  bl 0x822c8cb8
	ctx.lr = 0x82A52AA4;
	sub_822C8CB8(ctx, base);
	// 82A52AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52AA8: 483A0981  bl 0x82df3428
	ctx.lr = 0x82A52AAC;
	sub_82DF3428(ctx, base);
	// 82A52AAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52AB4: 388BDA30  addi r4, r11, -0x25d0
	ctx.r[4].s64 = ctx.r[11].s64 + -9680;
	// 82A52AB8: 483A0F51  bl 0x82df3a08
	ctx.lr = 0x82A52ABC;
	sub_82DF3A08(ctx, base);
	// 82A52ABC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A52AC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A52AC4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A52AC8: 388BDF58  addi r4, r11, -0x20a8
	ctx.r[4].s64 = ctx.r[11].s64 + -8360;
	// 82A52ACC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A52AD0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A52AD4: 4BB506DD  bl 0x825a31b0
	ctx.lr = 0x82A52AD8;
	sub_825A31B0(ctx, base);
	// 82A52AD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A52ADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A52AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52AE4: 4BB4EC8D  bl 0x825a1770
	ctx.lr = 0x82A52AE8;
	sub_825A1770(ctx, base);
	// 82A52AE8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A52AEC: 483A093D  bl 0x82df3428
	ctx.lr = 0x82A52AF0;
	sub_82DF3428(ctx, base);
	// 82A52AF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A52AF4: 4B8761C5  bl 0x822c8cb8
	ctx.lr = 0x82A52AF8;
	sub_822C8CB8(ctx, base);
	// 82A52AF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52AFC: 483A092D  bl 0x82df3428
	ctx.lr = 0x82A52B00;
	sub_82DF3428(ctx, base);
	// 82A52B00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52B04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52B08: 388BDA24  addi r4, r11, -0x25dc
	ctx.r[4].s64 = ctx.r[11].s64 + -9692;
	// 82A52B0C: 483A0EFD  bl 0x82df3a08
	ctx.lr = 0x82A52B10;
	sub_82DF3A08(ctx, base);
	// 82A52B10: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A52B14: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A52B18: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A52B1C: 388BDF5C  addi r4, r11, -0x20a4
	ctx.r[4].s64 = ctx.r[11].s64 + -8356;
	// 82A52B20: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A52B24: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A52B28: 4BB50689  bl 0x825a31b0
	ctx.lr = 0x82A52B2C;
	sub_825A31B0(ctx, base);
	// 82A52B2C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A52B30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A52B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52B38: 4BB4EC39  bl 0x825a1770
	ctx.lr = 0x82A52B3C;
	sub_825A1770(ctx, base);
	// 82A52B3C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A52B40: 483A08E9  bl 0x82df3428
	ctx.lr = 0x82A52B44;
	sub_82DF3428(ctx, base);
	// 82A52B44: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A52B48: 4B876171  bl 0x822c8cb8
	ctx.lr = 0x82A52B4C;
	sub_822C8CB8(ctx, base);
	// 82A52B4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52B50: 483A08D9  bl 0x82df3428
	ctx.lr = 0x82A52B54;
	sub_82DF3428(ctx, base);
	// 82A52B54: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52B5C: 388BDA18  addi r4, r11, -0x25e8
	ctx.r[4].s64 = ctx.r[11].s64 + -9704;
	// 82A52B60: 483A0EA9  bl 0x82df3a08
	ctx.lr = 0x82A52B64;
	sub_82DF3A08(ctx, base);
	// 82A52B64: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A52B68: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A52B6C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A52B70: 388BDF60  addi r4, r11, -0x20a0
	ctx.r[4].s64 = ctx.r[11].s64 + -8352;
	// 82A52B74: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A52B78: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A52B7C: 4BB50635  bl 0x825a31b0
	ctx.lr = 0x82A52B80;
	sub_825A31B0(ctx, base);
	// 82A52B80: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A52B84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A52B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52B8C: 4BB4EBE5  bl 0x825a1770
	ctx.lr = 0x82A52B90;
	sub_825A1770(ctx, base);
	// 82A52B90: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82A52B94: 483A0895  bl 0x82df3428
	ctx.lr = 0x82A52B98;
	sub_82DF3428(ctx, base);
	// 82A52B98: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82A52B9C: 4B87611D  bl 0x822c8cb8
	ctx.lr = 0x82A52BA0;
	sub_822C8CB8(ctx, base);
	// 82A52BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A52BA4: 483A0885  bl 0x82df3428
	ctx.lr = 0x82A52BA8;
	sub_82DF3428(ctx, base);
	// 82A52BA8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82A52BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A52BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A52BB4: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A52BB8: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A52BBC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A52BC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A52BC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A52BC8 size=124
    let mut pc: u32 = 0x82A52BC8;
    'dispatch: loop {
        match pc {
            0x82A52BC8 => {
    //   block [0x82A52BC8..0x82A52C44)
	// 82A52BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A52BCC: 487555A1  bl 0x831a816c
	ctx.lr = 0x82A52BD0;
	sub_831A8130(ctx, base);
	// 82A52BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52BD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A52BD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A52BDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A52BE0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A52BE4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A52BE8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A52BEC: 4839F7FD  bl 0x82df23e8
	ctx.lr = 0x82A52BF0;
	sub_82DF23E8(ctx, base);
	// 82A52BF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A52BF4: 4182001C  beq 0x82a52c10
	if ctx.cr[0].eq {
	pc = 0x82A52C10; continue 'dispatch;
	}
	// 82A52BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52BFC: 48406A85  bl 0x82e59680
	ctx.lr = 0x82A52C00;
	sub_82E59680(ctx, base);
	// 82A52C00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52C04: 396BDA00  addi r11, r11, -0x2600
	ctx.r[11].s64 = ctx.r[11].s64 + -9728;
	// 82A52C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A52C0C: 48000008  b 0x82a52c14
	pc = 0x82A52C14; continue 'dispatch;
	// 82A52C10: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A52C14: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A52C18: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A52C1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A52C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A52C24: 4BFFFCBD  bl 0x82a528e0
	ctx.lr = 0x82A52C28;
	sub_82A528E0(ctx, base);
	// 82A52C28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A52C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A52C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A52C34: 4B86D3CD  bl 0x822c0000
	ctx.lr = 0x82A52C38;
	sub_822C0000(ctx, base);
	// 82A52C38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A52C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A52C40: 4875557C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A52C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A52C48 size=924
    let mut pc: u32 = 0x82A52C48;
    'dispatch: loop {
        match pc {
            0x82A52C48 => {
    //   block [0x82A52C48..0x82A52FE4)
	// 82A52C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A52C4C: 4875550D  bl 0x831a8158
	ctx.lr = 0x82A52C50;
	sub_831A8130(ctx, base);
	// 82A52C50: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A52C54: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A52C58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A52C5C: 487019A5  bl 0x83154600
	ctx.lr = 0x82A52C60;
	sub_83154600(ctx, base);
	// 82A52C60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A52C64: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82A52C68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A52C6C: 9B1C063C  stb r24, 0x63c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1596 as u32), ctx.r[24].u8 ) };
	// 82A52C70: 4BABCED1  bl 0x8250fb40
	ctx.lr = 0x82A52C74;
	sub_8250FB40(ctx, base);
	// 82A52C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52C78: 4BFF3D41  bl 0x82a469b8
	ctx.lr = 0x82A52C7C;
	sub_82A469B8(ctx, base);
	// 82A52C7C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A52C80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A52C84: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82A52C88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A52C8C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82A52C90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A52C94: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A52C98: 4BFE5909  bl 0x82a385a0
	ctx.lr = 0x82A52C9C;
	sub_82A385A0(ctx, base);
	// 82A52C9C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A52CA0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A52CA4: 9B3F0188  stb r25, 0x188(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[25].u8 ) };
	// 82A52CA8: 3BDC04BC  addi r30, r28, 0x4bc
	ctx.r[30].s64 = ctx.r[28].s64 + 1212;
	// 82A52CAC: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 82A52CB0: 3B6BBA80  addi r27, r11, -0x4580
	ctx.r[27].s64 = ctx.r[11].s64 + -17792;
	// 82A52CB4: 3B4A6910  addi r26, r10, 0x6910
	ctx.r[26].s64 = ctx.r[10].s64 + 26896;
	// 82A52CB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A52CBC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52CC0: 4BB381A9  bl 0x8258ae68
	ctx.lr = 0x82A52CC4;
	sub_8258AE68(ctx, base);
	// 82A52CC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A52CC8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52CCC: 4BB381E5  bl 0x8258aeb0
	ctx.lr = 0x82A52CD0;
	sub_8258AEB0(ctx, base);
	// 82A52CD0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A52CD4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A52CD8: 4082FFE0  bne 0x82a52cb8
	if !ctx.cr[0].eq {
	pc = 0x82A52CB8; continue 'dispatch;
	}
	// 82A52CDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A52CE0: 83DC04E4  lwz r30, 0x4e4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1252 as u32) ) } as u64;
	// 82A52CE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A52CE8: 4BABF431  bl 0x82512118
	ctx.lr = 0x82A52CEC;
	sub_82512118(ctx, base);
	// 82A52CEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A52CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A52CF4: 483C23BD  bl 0x82e150b0
	ctx.lr = 0x82A52CF8;
	sub_82E150B0(ctx, base);
	// 82A52CF8: 9B3F0194  stb r25, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[25].u8 ) };
	// 82A52CFC: 3BDC0390  addi r30, r28, 0x390
	ctx.r[30].s64 = ctx.r[28].s64 + 912;
	// 82A52D00: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 82A52D04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A52D08: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52D0C: 4842EA35  bl 0x82e81740
	ctx.lr = 0x82A52D10;
	sub_82E81740(ctx, base);
	// 82A52D10: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A52D14: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A52D18: 4082FFEC  bne 0x82a52d04
	if !ctx.cr[0].eq {
	pc = 0x82A52D04; continue 'dispatch;
	}
	// 82A52D1C: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82A52D20: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A52D24: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 82A52D28: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A52D2C: 4BF68DFD  bl 0x829bbb28
	ctx.lr = 0x82A52D30;
	sub_829BBB28(ctx, base);
	// 82A52D30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52D34: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A52D38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A52D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52D40: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A52D44: 419A0024  beq cr6, 0x82a52d68
	if ctx.cr[6].eq {
	pc = 0x82A52D68; continue 'dispatch;
	}
	// 82A52D48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A52D4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A52D50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52D54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A52D58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A52D5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A52D60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52D64: 4082FFE8  bne 0x82a52d4c
	if !ctx.cr[0].eq {
	pc = 0x82A52D4C; continue 'dispatch;
	}
	// 82A52D68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A52D6C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A52D70: 4BABC759  bl 0x8250f4c8
	ctx.lr = 0x82A52D74;
	sub_8250F4C8(ctx, base);
	// 82A52D74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52D7C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A52D80: 409A0008  bne cr6, 0x82a52d88
	if !ctx.cr[6].eq {
	pc = 0x82A52D88; continue 'dispatch;
	}
	// 82A52D84: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A52D88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A52D8C: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82A52D90: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A52D94: 4BAB5C85  bl 0x82508a18
	ctx.lr = 0x82A52D98;
	sub_82508A18(ctx, base);
	// 82A52D98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A52D9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A52DA0: 3BCBDA48  addi r30, r11, -0x25b8
	ctx.r[30].s64 = ctx.r[11].s64 + -9656;
	// 82A52DA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A52DA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A52DAC: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 82A52DB0: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A52DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52DB8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A52DBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A52DC0: 48405C81  bl 0x82e58a40
	ctx.lr = 0x82A52DC4;
	sub_82E58A40(ctx, base);
	// 82A52DC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A52DC8: 4839EEC9  bl 0x82df1c90
	ctx.lr = 0x82A52DCC;
	sub_82DF1C90(ctx, base);
	// 82A52DCC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A52DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52DD4: 419A0008  beq cr6, 0x82a52ddc
	if ctx.cr[6].eq {
	pc = 0x82A52DDC; continue 'dispatch;
	}
	// 82A52DD8: 4B86DAB9  bl 0x822c0890
	ctx.lr = 0x82A52DDC;
	sub_822C0890(ctx, base);
	// 82A52DDC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A52DE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52DE4: 419A0008  beq cr6, 0x82a52dec
	if ctx.cr[6].eq {
	pc = 0x82A52DEC; continue 'dispatch;
	}
	// 82A52DE8: 4B86DAA9  bl 0x822c0890
	ctx.lr = 0x82A52DEC;
	sub_822C0890(ctx, base);
	// 82A52DEC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A52DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52DF4: 419A0044  beq cr6, 0x82a52e38
	if ctx.cr[6].eq {
	pc = 0x82A52E38; continue 'dispatch;
	}
	// 82A52DF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A52DFC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A52E00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A52E04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52E08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A52E0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A52E10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A52E14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52E18: 4082FFE8  bne 0x82a52e00
	if !ctx.cr[0].eq {
	pc = 0x82A52E00; continue 'dispatch;
	}
	// 82A52E1C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A52E20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A52E24: 409A0014  bne cr6, 0x82a52e38
	if !ctx.cr[6].eq {
	pc = 0x82A52E38; continue 'dispatch;
	}
	// 82A52E28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52E2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A52E30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A52E34: 4E800421  bctrl
	ctx.lr = 0x82A52E38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A52E38: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A52E3C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A52E40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A52E44: 388B4DF0  addi r4, r11, 0x4df0
	ctx.r[4].s64 = ctx.r[11].s64 + 19952;
	// 82A52E48: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A52E4C: 4BA0DA05  bl 0x82460850
	ctx.lr = 0x82A52E50;
	sub_82460850(ctx, base);
	// 82A52E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52E54: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A52E58: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A52E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52E60: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A52E64: 419A0024  beq cr6, 0x82a52e88
	if ctx.cr[6].eq {
	pc = 0x82A52E88; continue 'dispatch;
	}
	// 82A52E68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A52E6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A52E70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52E74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A52E78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A52E7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A52E80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52E84: 4082FFE8  bne 0x82a52e6c
	if !ctx.cr[0].eq {
	pc = 0x82A52E6C; continue 'dispatch;
	}
	// 82A52E88: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A52E8C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A52E90: 4BABC689  bl 0x8250f518
	ctx.lr = 0x82A52E94;
	sub_8250F518(ctx, base);
	// 82A52E94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52E9C: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A52EA0: 409A0008  bne cr6, 0x82a52ea8
	if !ctx.cr[6].eq {
	pc = 0x82A52EA8; continue 'dispatch;
	}
	// 82A52EA4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A52EA8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A52EAC: 4BAD51A5  bl 0x82528050
	ctx.lr = 0x82A52EB0;
	sub_82528050(ctx, base);
	// 82A52EB0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A52EB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A52EB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A52EBC: 38A000B7  li r5, 0xb7
	ctx.r[5].s64 = 183;
	// 82A52EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52EC4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A52EC8: 48405B79  bl 0x82e58a40
	ctx.lr = 0x82A52ECC;
	sub_82E58A40(ctx, base);
	// 82A52ECC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A52ED0: 4839EDC1  bl 0x82df1c90
	ctx.lr = 0x82A52ED4;
	sub_82DF1C90(ctx, base);
	// 82A52ED4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A52ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52EDC: 419A0008  beq cr6, 0x82a52ee4
	if ctx.cr[6].eq {
	pc = 0x82A52EE4; continue 'dispatch;
	}
	// 82A52EE0: 4B86D9B1  bl 0x822c0890
	ctx.lr = 0x82A52EE4;
	sub_822C0890(ctx, base);
	// 82A52EE4: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A52EE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52EEC: 419A0008  beq cr6, 0x82a52ef4
	if ctx.cr[6].eq {
	pc = 0x82A52EF4; continue 'dispatch;
	}
	// 82A52EF0: 4B86D9A1  bl 0x822c0890
	ctx.lr = 0x82A52EF4;
	sub_822C0890(ctx, base);
	// 82A52EF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A52EF8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A52EFC: 4BABC5CD  bl 0x8250f4c8
	ctx.lr = 0x82A52F00;
	sub_8250F4C8(ctx, base);
	// 82A52F00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52F08: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A52F0C: 409A0008  bne cr6, 0x82a52f14
	if !ctx.cr[6].eq {
	pc = 0x82A52F14; continue 'dispatch;
	}
	// 82A52F10: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A52F14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A52F18: 4BAB55C9  bl 0x825084e0
	ctx.lr = 0x82A52F1C;
	sub_825084E0(ctx, base);
	// 82A52F1C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A52F20: 4839ED71  bl 0x82df1c90
	ctx.lr = 0x82A52F24;
	sub_82DF1C90(ctx, base);
	// 82A52F24: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 82A52F28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A52F2C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A52F30: 4BA6FB69  bl 0x824c2a98
	ctx.lr = 0x82A52F34;
	sub_824C2A98(ctx, base);
	// 82A52F34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52F38: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A52F3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A52F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52F44: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A52F48: 419A0024  beq cr6, 0x82a52f6c
	if ctx.cr[6].eq {
	pc = 0x82A52F6C; continue 'dispatch;
	}
	// 82A52F4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A52F50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A52F54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52F58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A52F5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A52F60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A52F64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A52F68: 4082FFE8  bne 0x82a52f50
	if !ctx.cr[0].eq {
	pc = 0x82A52F50; continue 'dispatch;
	}
	// 82A52F6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A52F70: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A52F74: 4BABC555  bl 0x8250f4c8
	ctx.lr = 0x82A52F78;
	sub_8250F4C8(ctx, base);
	// 82A52F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A52F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A52F80: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A52F84: 409A0008  bne cr6, 0x82a52f8c
	if !ctx.cr[6].eq {
	pc = 0x82A52F8C; continue 'dispatch;
	}
	// 82A52F88: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A52F8C: 3BA10078  addi r29, r1, 0x78
	ctx.r[29].s64 = ctx.r[1].s64 + 120;
	// 82A52F90: 4BAB5AF1  bl 0x82508a80
	ctx.lr = 0x82A52F94;
	sub_82508A80(ctx, base);
	// 82A52F94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A52F98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A52F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A52FA0: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 82A52FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A52FA8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A52FAC: 48405A95  bl 0x82e58a40
	ctx.lr = 0x82A52FB0;
	sub_82E58A40(ctx, base);
	// 82A52FB0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A52FB4: 4839ECDD  bl 0x82df1c90
	ctx.lr = 0x82A52FB8;
	sub_82DF1C90(ctx, base);
	// 82A52FB8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A52FBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52FC0: 419A0008  beq cr6, 0x82a52fc8
	if ctx.cr[6].eq {
	pc = 0x82A52FC8; continue 'dispatch;
	}
	// 82A52FC4: 4B86D8CD  bl 0x822c0890
	ctx.lr = 0x82A52FC8;
	sub_822C0890(ctx, base);
	// 82A52FC8: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A52FCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A52FD0: 419A0008  beq cr6, 0x82a52fd8
	if ctx.cr[6].eq {
	pc = 0x82A52FD8; continue 'dispatch;
	}
	// 82A52FD4: 4B86D8BD  bl 0x822c0890
	ctx.lr = 0x82A52FD8;
	sub_822C0890(ctx, base);
	// 82A52FD8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A52FDC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82A52FE0: 487551C8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


