pub fn sub_828982E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828982E8 size=144
    let mut pc: u32 = 0x828982E8;
    'dispatch: loop {
        match pc {
            0x828982E8 => {
    //   block [0x828982E8..0x82898378)
	// 828982E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828982EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828982F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828982F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828982F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828982FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898308: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 8289830C: 4855B6FD  bl 0x82df3a08
	ctx.lr = 0x82898310;
	sub_82DF3A08(ctx, base);
	// 82898310: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82898314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898318: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8289831C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82898320: C3EB614C  lfs f31, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82898324: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898328: 48074359  bl 0x8290c680
	ctx.lr = 0x8289832C;
	sub_8290C680(ctx, base);
	// 8289832C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898330: 4855B0F9  bl 0x82df3428
	ctx.lr = 0x82898334;
	sub_82DF3428(ctx, base);
	// 82898334: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289833C: 388B8A10  addi r4, r11, -0x75f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30192;
	// 82898340: 4855B6C9  bl 0x82df3a08
	ctx.lr = 0x82898344;
	sub_82DF3A08(ctx, base);
	// 82898344: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82898348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289834C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898354: 4807432D  bl 0x8290c680
	ctx.lr = 0x82898358;
	sub_8290C680(ctx, base);
	// 82898358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289835C: 4855B0CD  bl 0x82df3428
	ctx.lr = 0x82898360;
	sub_82DF3428(ctx, base);
	// 82898360: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289836C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898378 size=144
    let mut pc: u32 = 0x82898378;
    'dispatch: loop {
        match pc {
            0x82898378 => {
    //   block [0x82898378..0x82898408)
	// 82898378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289837C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898384: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82898388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289838C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898398: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 8289839C: 4855B66D  bl 0x82df3a08
	ctx.lr = 0x828983A0;
	sub_82DF3A08(ctx, base);
	// 828983A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828983A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828983A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828983AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828983B0: C3EB614C  lfs f31, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828983B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828983B8: 48074369  bl 0x8290c720
	ctx.lr = 0x828983BC;
	sub_8290C720(ctx, base);
	// 828983BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828983C0: 4855B069  bl 0x82df3428
	ctx.lr = 0x828983C4;
	sub_82DF3428(ctx, base);
	// 828983C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828983C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828983CC: 388B8A10  addi r4, r11, -0x75f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30192;
	// 828983D0: 4855B639  bl 0x82df3a08
	ctx.lr = 0x828983D4;
	sub_82DF3A08(ctx, base);
	// 828983D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828983D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828983DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828983E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828983E4: 4807433D  bl 0x8290c720
	ctx.lr = 0x828983E8;
	sub_8290C720(ctx, base);
	// 828983E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828983EC: 4855B03D  bl 0x82df3428
	ctx.lr = 0x828983F0;
	sub_82DF3428(ctx, base);
	// 828983F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828983F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828983F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828983FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898400: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898408 size=144
    let mut pc: u32 = 0x82898408;
    'dispatch: loop {
        match pc {
            0x82898408 => {
    //   block [0x82898408..0x82898498)
	// 82898408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289840C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898414: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82898418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289841C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898420: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898428: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 8289842C: 4855B5DD  bl 0x82df3a08
	ctx.lr = 0x82898430;
	sub_82DF3A08(ctx, base);
	// 82898430: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82898434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898438: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8289843C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82898440: C3EB614C  lfs f31, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82898444: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898448: 48074239  bl 0x8290c680
	ctx.lr = 0x8289844C;
	sub_8290C680(ctx, base);
	// 8289844C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898450: 4855AFD9  bl 0x82df3428
	ctx.lr = 0x82898454;
	sub_82DF3428(ctx, base);
	// 82898454: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289845C: 388B8A10  addi r4, r11, -0x75f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30192;
	// 82898460: 4855B5A9  bl 0x82df3a08
	ctx.lr = 0x82898464;
	sub_82DF3A08(ctx, base);
	// 82898464: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82898468: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289846C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898474: 4807420D  bl 0x8290c680
	ctx.lr = 0x82898478;
	sub_8290C680(ctx, base);
	// 82898478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289847C: 4855AFAD  bl 0x82df3428
	ctx.lr = 0x82898480;
	sub_82DF3428(ctx, base);
	// 82898480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289848C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898498 size=144
    let mut pc: u32 = 0x82898498;
    'dispatch: loop {
        match pc {
            0x82898498 => {
    //   block [0x82898498..0x82898528)
	// 82898498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289849C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828984A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828984A4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828984A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828984AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828984B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828984B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828984B8: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828984BC: 4855B54D  bl 0x82df3a08
	ctx.lr = 0x828984C0;
	sub_82DF3A08(ctx, base);
	// 828984C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828984C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828984C8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828984CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828984D0: C3EB614C  lfs f31, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828984D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828984D8: 48074249  bl 0x8290c720
	ctx.lr = 0x828984DC;
	sub_8290C720(ctx, base);
	// 828984DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828984E0: 4855AF49  bl 0x82df3428
	ctx.lr = 0x828984E4;
	sub_82DF3428(ctx, base);
	// 828984E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828984E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828984EC: 388B8A10  addi r4, r11, -0x75f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30192;
	// 828984F0: 4855B519  bl 0x82df3a08
	ctx.lr = 0x828984F4;
	sub_82DF3A08(ctx, base);
	// 828984F4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828984F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828984FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898504: 4807421D  bl 0x8290c720
	ctx.lr = 0x82898508;
	sub_8290C720(ctx, base);
	// 82898508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289850C: 4855AF1D  bl 0x82df3428
	ctx.lr = 0x82898510;
	sub_82DF3428(ctx, base);
	// 82898510: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289851C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898528 size=12
    let mut pc: u32 = 0x82898528;
    'dispatch: loop {
        match pc {
            0x82898528 => {
    //   block [0x82898528..0x82898534)
	// 82898528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289852C: 996303E0  stb r11, 0x3e0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(992 as u32), ctx.r[11].u8 ) };
	// 82898530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898538 size=20
    let mut pc: u32 = 0x82898538;
    'dispatch: loop {
        match pc {
            0x82898538 => {
    //   block [0x82898538..0x8289854C)
	// 82898538: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289853C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82898540: 996303B8  stb r11, 0x3b8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(952 as u32), ctx.r[11].u8 ) };
	// 82898544: 994303A4  stb r10, 0x3a4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(932 as u32), ctx.r[10].u8 ) };
	// 82898548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898550 size=20
    let mut pc: u32 = 0x82898550;
    'dispatch: loop {
        match pc {
            0x82898550 => {
    //   block [0x82898550..0x82898564)
	// 82898550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82898554: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82898558: 996303B8  stb r11, 0x3b8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(952 as u32), ctx.r[11].u8 ) };
	// 8289855C: 994303A4  stb r10, 0x3a4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(932 as u32), ctx.r[10].u8 ) };
	// 82898560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898568 size=8
    let mut pc: u32 = 0x82898568;
    'dispatch: loop {
        match pc {
            0x82898568 => {
    //   block [0x82898568..0x82898570)
	// 82898568: 386303C0  addi r3, r3, 0x3c0
	ctx.r[3].s64 = ctx.r[3].s64 + 960;
	// 8289856C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898570 size=260
    let mut pc: u32 = 0x82898570;
    'dispatch: loop {
        match pc {
            0x82898570 => {
    //   block [0x82898570..0x82898674)
	// 82898570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898574: 4890FBF9  bl 0x831a816c
	ctx.lr = 0x82898578;
	sub_831A8130(ctx, base);
	// 82898578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289857C: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898580: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898584: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82898588: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289858C: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898590: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898594: 38898A74  addi r4, r9, -0x758c
	ctx.r[4].s64 = ctx.r[9].s64 + -30092;
	// 82898598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289859C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828985A0: 4855B469  bl 0x82df3a08
	ctx.lr = 0x828985A4;
	sub_82DF3A08(ctx, base);
	// 828985A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828985A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828985AC: 4855AD5D  bl 0x82df3308
	ctx.lr = 0x828985B0;
	sub_82DF3308(ctx, base);
	// 828985B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828985B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828985B8: 4855AE71  bl 0x82df3428
	ctx.lr = 0x828985BC;
	sub_82DF3428(ctx, base);
	// 828985BC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828985C0: 4182000C  beq 0x828985cc
	if ctx.cr[0].eq {
	pc = 0x828985CC; continue 'dispatch;
	}
	// 828985C4: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 828985C8: 480000A4  b 0x8289866c
	pc = 0x8289866C; continue 'dispatch;
	// 828985CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828985D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828985D4: 388B8A58  addi r4, r11, -0x75a8
	ctx.r[4].s64 = ctx.r[11].s64 + -30120;
	// 828985D8: 4855B431  bl 0x82df3a08
	ctx.lr = 0x828985DC;
	sub_82DF3A08(ctx, base);
	// 828985DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828985E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828985E4: 4855AD25  bl 0x82df3308
	ctx.lr = 0x828985E8;
	sub_82DF3308(ctx, base);
	// 828985E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828985EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828985F0: 4855AE39  bl 0x82df3428
	ctx.lr = 0x828985F4;
	sub_82DF3428(ctx, base);
	// 828985F4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828985F8: 4182000C  beq 0x82898604
	if ctx.cr[0].eq {
	pc = 0x82898604; continue 'dispatch;
	}
	// 828985FC: 387E00FC  addi r3, r30, 0xfc
	ctx.r[3].s64 = ctx.r[30].s64 + 252;
	// 82898600: 4800006C  b 0x8289866c
	pc = 0x8289866C; continue 'dispatch;
	// 82898604: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289860C: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 82898610: 4855B3F9  bl 0x82df3a08
	ctx.lr = 0x82898614;
	sub_82DF3A08(ctx, base);
	// 82898614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82898618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289861C: 4855ACED  bl 0x82df3308
	ctx.lr = 0x82898620;
	sub_82DF3308(ctx, base);
	// 82898620: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82898624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898628: 4855AE01  bl 0x82df3428
	ctx.lr = 0x8289862C;
	sub_82DF3428(ctx, base);
	// 8289862C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898630: 4182000C  beq 0x8289863c
	if ctx.cr[0].eq {
	pc = 0x8289863C; continue 'dispatch;
	}
	// 82898634: 387E010C  addi r3, r30, 0x10c
	ctx.r[3].s64 = ctx.r[30].s64 + 268;
	// 82898638: 48000034  b 0x8289866c
	pc = 0x8289866C; continue 'dispatch;
	// 8289863C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898644: 388B8A28  addi r4, r11, -0x75d8
	ctx.r[4].s64 = ctx.r[11].s64 + -30168;
	// 82898648: 4855B3C1  bl 0x82df3a08
	ctx.lr = 0x8289864C;
	sub_82DF3A08(ctx, base);
	// 8289864C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82898650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898654: 4855ACB5  bl 0x82df3308
	ctx.lr = 0x82898658;
	sub_82DF3308(ctx, base);
	// 82898658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289865C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898660: 4855ADC9  bl 0x82df3428
	ctx.lr = 0x82898664;
	sub_82DF3428(ctx, base);
	// 82898664: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898668: 387E011C  addi r3, r30, 0x11c
	ctx.r[3].s64 = ctx.r[30].s64 + 284;
	// 8289866C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82898670: 4890FB4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898678 size=28
    let mut pc: u32 = 0x82898678;
    'dispatch: loop {
        match pc {
            0x82898678 => {
    //   block [0x82898678..0x82898694)
	// 82898678: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 8289867C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898680: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898684: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898688: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289868C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82898690: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898694(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898694 size=8
    let mut pc: u32 = 0x82898694;
    'dispatch: loop {
        match pc {
            0x82898694 => {
    //   block [0x82898694..0x8289869C)
	// 82898694: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82898698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828986A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828986A0 size=28
    let mut pc: u32 = 0x828986A0;
    'dispatch: loop {
        match pc {
            0x828986A0 => {
    //   block [0x828986A0..0x828986BC)
	// 828986A0: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 828986A4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828986A8: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 828986AC: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 828986B0: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828986B4: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 828986B8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828986BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828986BC size=8
    let mut pc: u32 = 0x828986BC;
    'dispatch: loop {
        match pc {
            0x828986BC => {
    //   block [0x828986BC..0x828986C4)
	// 828986BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828986C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828986C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828986C8 size=92
    let mut pc: u32 = 0x828986C8;
    'dispatch: loop {
        match pc {
            0x828986C8 => {
    //   block [0x828986C8..0x82898724)
	// 828986C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828986CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828986D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828986D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828986D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828986DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828986E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828986E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828986E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828986EC: 388B8A8C  addi r4, r11, -0x7574
	ctx.r[4].s64 = ctx.r[11].s64 + -30068;
	// 828986F0: 4855B319  bl 0x82df3a08
	ctx.lr = 0x828986F4;
	sub_82DF3A08(ctx, base);
	// 828986F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828986F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828986FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898700: 48075751  bl 0x8290de50
	ctx.lr = 0x82898704;
	sub_8290DE50(ctx, base);
	// 82898704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898708: 4855AD21  bl 0x82df3428
	ctx.lr = 0x8289870C;
	sub_82DF3428(ctx, base);
	// 8289870C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898710: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898714: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82898718: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289871C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898728 size=12
    let mut pc: u32 = 0x82898728;
    'dispatch: loop {
        match pc {
            0x82898728 => {
    //   block [0x82898728..0x82898734)
	// 82898728: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289872C: 806B0AF8  lwz r3, 0xaf8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 82898730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898738 size=136
    let mut pc: u32 = 0x82898738;
    'dispatch: loop {
        match pc {
            0x82898738 => {
    //   block [0x82898738..0x828987C0)
	// 82898738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289873C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82898744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289874C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82898750: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82898754: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82898758: 409A0020  bne cr6, 0x82898778
	if !ctx.cr[6].eq {
	pc = 0x82898778; continue 'dispatch;
	}
	// 8289875C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82898760: 419A0048  beq cr6, 0x828987a8
	if ctx.cr[6].eq {
	pc = 0x828987A8; continue 'dispatch;
	}
	// 82898764: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82898768: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8289876C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82898770: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82898774: 48000034  b 0x828987a8
	pc = 0x828987A8; continue 'dispatch;
	// 82898778: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8289877C: 419A002C  beq cr6, 0x828987a8
	if ctx.cr[6].eq {
	pc = 0x828987A8; continue 'dispatch;
	}
	// 82898780: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82898784: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898788: 388BFAA0  addi r4, r11, -0x560
	ctx.r[4].s64 = ctx.r[11].s64 + -1376;
	// 8289878C: 4890F96D  bl 0x831a80f8
	ctx.lr = 0x82898790;
	sub_831A80F8(ctx, base);
	// 82898790: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898794: 4182000C  beq 0x828987a0
	if ctx.cr[0].eq {
	pc = 0x828987A0; continue 'dispatch;
	}
	// 82898798: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8289879C: 4800000C  b 0x828987a8
	pc = 0x828987A8; continue 'dispatch;
	// 828987A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828987A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828987A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828987AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828987B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828987B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828987B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828987BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828987C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828987C0 size=136
    let mut pc: u32 = 0x828987C0;
    'dispatch: loop {
        match pc {
            0x828987C0 => {
    //   block [0x828987C0..0x82898848)
	// 828987C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828987C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828987C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828987CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828987D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828987D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828987D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828987DC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828987E0: 409A0020  bne cr6, 0x82898800
	if !ctx.cr[6].eq {
	pc = 0x82898800; continue 'dispatch;
	}
	// 828987E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828987E8: 419A0048  beq cr6, 0x82898830
	if ctx.cr[6].eq {
	pc = 0x82898830; continue 'dispatch;
	}
	// 828987EC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828987F0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828987F4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828987F8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828987FC: 48000034  b 0x82898830
	pc = 0x82898830; continue 'dispatch;
	// 82898800: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82898804: 419A002C  beq cr6, 0x82898830
	if ctx.cr[6].eq {
	pc = 0x82898830; continue 'dispatch;
	}
	// 82898808: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289880C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898810: 388BFB50  addi r4, r11, -0x4b0
	ctx.r[4].s64 = ctx.r[11].s64 + -1200;
	// 82898814: 4890F8E5  bl 0x831a80f8
	ctx.lr = 0x82898818;
	sub_831A80F8(ctx, base);
	// 82898818: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289881C: 4182000C  beq 0x82898828
	if ctx.cr[0].eq {
	pc = 0x82898828; continue 'dispatch;
	}
	// 82898820: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82898824: 4800000C  b 0x82898830
	pc = 0x82898830; continue 'dispatch;
	// 82898828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289882C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82898830: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289883C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898840: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898848 size=332
    let mut pc: u32 = 0x82898848;
    'dispatch: loop {
        match pc {
            0x82898848 => {
    //   block [0x82898848..0x82898994)
	// 82898848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289884C: 4890F91D  bl 0x831a8168
	ctx.lr = 0x82898850;
	sub_831A8130(ctx, base);
	// 82898850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898854: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82898858: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289885C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82898860: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82898864: 41820038  beq 0x8289889c
	if ctx.cr[0].eq {
	pc = 0x8289889C; continue 'dispatch;
	}
	// 82898868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289886C: 4891111D  bl 0x831a9988
	ctx.lr = 0x82898870;
	sub_831A9988(ctx, base);
	// 82898870: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82898874: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82898878: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 8289887C: 4890F87D  bl 0x831a80f8
	ctx.lr = 0x82898880;
	sub_831A80F8(ctx, base);
	// 82898880: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898884: 41820018  beq 0x8289889c
	if ctx.cr[0].eq {
	pc = 0x8289889C; continue 'dispatch;
	}
	// 82898888: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289888C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82898890: 48041681  bl 0x828d9f10
	ctx.lr = 0x82898894;
	sub_828D9F10(ctx, base);
	// 82898894: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82898898: 480000F4  b 0x8289898c
	pc = 0x8289898C; continue 'dispatch;
	// 8289889C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828988A0: 419A00DC  beq cr6, 0x8289897c
	if ctx.cr[6].eq {
	pc = 0x8289897C; continue 'dispatch;
	}
	// 828988A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828988A8: 489110E1  bl 0x831a9988
	ctx.lr = 0x828988AC;
	sub_831A9988(ctx, base);
	// 828988AC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828988B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828988B4: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828988B8: 4890F841  bl 0x831a80f8
	ctx.lr = 0x828988BC;
	sub_831A80F8(ctx, base);
	// 828988BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828988C0: 41820014  beq 0x828988d4
	if ctx.cr[0].eq {
	pc = 0x828988D4; continue 'dispatch;
	}
	// 828988C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828988C8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828988CC: 48041615  bl 0x828d9ee0
	ctx.lr = 0x828988D0;
	sub_828D9EE0(ctx, base);
	// 828988D0: 4BFFFFC4  b 0x82898894
	pc = 0x82898894; continue 'dispatch;
	// 828988D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828988D8: 419A00A4  beq cr6, 0x8289897c
	if ctx.cr[6].eq {
	pc = 0x8289897C; continue 'dispatch;
	}
	// 828988DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828988E0: 489110A9  bl 0x831a9988
	ctx.lr = 0x828988E4;
	sub_831A9988(ctx, base);
	// 828988E4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828988E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828988EC: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828988F0: 4890F809  bl 0x831a80f8
	ctx.lr = 0x828988F4;
	sub_831A80F8(ctx, base);
	// 828988F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828988F8: 41820014  beq 0x8289890c
	if ctx.cr[0].eq {
	pc = 0x8289890C; continue 'dispatch;
	}
	// 828988FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82898900: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82898904: 4804161D  bl 0x828d9f20
	ctx.lr = 0x82898908;
	sub_828D9F20(ctx, base);
	// 82898908: 4BFFFF8C  b 0x82898894
	pc = 0x82898894; continue 'dispatch;
	// 8289890C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82898910: 419A006C  beq cr6, 0x8289897c
	if ctx.cr[6].eq {
	pc = 0x8289897C; continue 'dispatch;
	}
	// 82898914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898918: 48911071  bl 0x831a9988
	ctx.lr = 0x8289891C;
	sub_831A9988(ctx, base);
	// 8289891C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82898920: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82898924: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 82898928: 4890F7D1  bl 0x831a80f8
	ctx.lr = 0x8289892C;
	sub_831A80F8(ctx, base);
	// 8289892C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898930: 41820014  beq 0x82898944
	if ctx.cr[0].eq {
	pc = 0x82898944; continue 'dispatch;
	}
	// 82898934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82898938: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8289893C: 480415B5  bl 0x828d9ef0
	ctx.lr = 0x82898940;
	sub_828D9EF0(ctx, base);
	// 82898940: 4BFFFF54  b 0x82898894
	pc = 0x82898894; continue 'dispatch;
	// 82898944: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82898948: 419A0034  beq cr6, 0x8289897c
	if ctx.cr[6].eq {
	pc = 0x8289897C; continue 'dispatch;
	}
	// 8289894C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898950: 48911039  bl 0x831a9988
	ctx.lr = 0x82898954;
	sub_831A9988(ctx, base);
	// 82898954: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82898958: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289895C: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 82898960: 4890F799  bl 0x831a80f8
	ctx.lr = 0x82898964;
	sub_831A80F8(ctx, base);
	// 82898964: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898968: 41820014  beq 0x8289897c
	if ctx.cr[0].eq {
	pc = 0x8289897C; continue 'dispatch;
	}
	// 8289896C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82898970: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82898974: 4804158D  bl 0x828d9f00
	ctx.lr = 0x82898978;
	sub_828D9F00(ctx, base);
	// 82898978: 4BFFFF1C  b 0x82898894
	pc = 0x82898894; continue 'dispatch;
	// 8289897C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82898980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82898984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82898988: 48077109  bl 0x8290fa90
	ctx.lr = 0x8289898C;
	sub_8290FA90(ctx, base);
	// 8289898C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82898990: 4890F828  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898998 size=144
    let mut pc: u32 = 0x82898998;
    'dispatch: loop {
        match pc {
            0x82898998 => {
    //   block [0x82898998..0x82898A28)
	// 82898998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289899C: 4890F7C9  bl 0x831a8164
	ctx.lr = 0x828989A0;
	sub_831A8130(ctx, base);
	// 828989A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828989A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828989A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828989AC: 4BF53775  bl 0x827ec120
	ctx.lr = 0x828989B0;
	sub_827EC120(ctx, base);
	// 828989B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828989B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828989B8: 4BF538B9  bl 0x827ec270
	ctx.lr = 0x828989BC;
	sub_827EC270(ctx, base);
	// 828989BC: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 828989C0: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 828989C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828989C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828989CC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828989D0: 4BC7A139  bl 0x82512b08
	ctx.lr = 0x828989D4;
	sub_82512B08(ctx, base);
	// 828989D4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828989D8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828989DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828989E0: 4082FFE8  bne 0x828989c8
	if !ctx.cr[0].eq {
	pc = 0x828989C8; continue 'dispatch;
	}
	// 828989E4: 3BDF03A8  addi r30, r31, 0x3a8
	ctx.r[30].s64 = ctx.r[31].s64 + 936;
	// 828989E8: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 828989EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828989F0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828989F4: 4BC7A115  bl 0x82512b08
	ctx.lr = 0x828989F8;
	sub_82512B08(ctx, base);
	// 828989F8: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828989FC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82898A00: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82898A04: 4082FFE8  bne 0x828989ec
	if !ctx.cr[0].eq {
	pc = 0x828989EC; continue 'dispatch;
	}
	// 82898A08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82898A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898A10: 48075721  bl 0x8290e130
	ctx.lr = 0x82898A14;
	sub_8290E130(ctx, base);
	// 82898A14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82898A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898A1C: 48078765  bl 0x82911180
	ctx.lr = 0x82898A20;
	sub_82911180(ctx, base);
	// 82898A20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82898A24: 4890F790  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82898A28 size=28
    let mut pc: u32 = 0x82898A28;
    'dispatch: loop {
        match pc {
            0x82898A28 => {
    //   block [0x82898A28..0x82898A44)
	// 82898A28: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898A2C: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898A30: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898A34: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898A38: 396B0058  addi r11, r11, 0x58
	ctx.r[11].s64 = ctx.r[11].s64 + 88;
	// 82898A3C: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82898A48 size=28
    let mut pc: u32 = 0x82898A48;
    'dispatch: loop {
        match pc {
            0x82898A48 => {
    //   block [0x82898A48..0x82898A64)
	// 82898A48: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898A4C: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898A50: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898A54: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898A58: 396B005C  addi r11, r11, 0x5c
	ctx.r[11].s64 = ctx.r[11].s64 + 92;
	// 82898A5C: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898A68 size=24
    let mut pc: u32 = 0x82898A68;
    'dispatch: loop {
        match pc {
            0x82898A68 => {
    //   block [0x82898A68..0x82898A80)
	// 82898A68: 81630448  lwz r11, 0x448(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898A6C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 82898A70: 394AB210  addi r10, r10, -0x4df0
	ctx.r[10].s64 = ctx.r[10].s64 + -19952;
	// 82898A74: 1D6B023C  mulli r11, r11, 0x23c
	ctx.r[11].s64 = ctx.r[11].s64 * 572;
	// 82898A78: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82898A7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82898A80 size=28
    let mut pc: u32 = 0x82898A80;
    'dispatch: loop {
        match pc {
            0x82898A80 => {
    //   block [0x82898A80..0x82898A9C)
	// 82898A80: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898A84: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898A88: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898A8C: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898A90: 396B0044  addi r11, r11, 0x44
	ctx.r[11].s64 = ctx.r[11].s64 + 68;
	// 82898A94: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82898AA0 size=28
    let mut pc: u32 = 0x82898AA0;
    'dispatch: loop {
        match pc {
            0x82898AA0 => {
    //   block [0x82898AA0..0x82898ABC)
	// 82898AA0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 82898AA4: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898AA8: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 82898AAC: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 82898AB0: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 82898AB4: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898AB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898AC0 size=100
    let mut pc: u32 = 0x82898AC0;
    'dispatch: loop {
        match pc {
            0x82898AC0 => {
    //   block [0x82898AC0..0x82898B24)
	// 82898AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898AC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898ACC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898AD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898AD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82898AD8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898ADC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898AE0: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82898AE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82898AE8: 4E800421  bctrl
	ctx.lr = 0x82898AEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82898AEC: 817F0448  lwz r11, 0x448(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898AF0: 3D208337  lis r9, -0x7cc9
	ctx.r[9].s64 = -2093547520;
	// 82898AF4: 1D4B023C  mulli r10, r11, 0x23c
	ctx.r[10].s64 = ctx.r[11].s64 * 572;
	// 82898AF8: 3969B210  addi r11, r9, -0x4df0
	ctx.r[11].s64 = ctx.r[9].s64 + -19952;
	// 82898AFC: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82898B00: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82898B04: C0096218  lfs f0, 0x6218(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82898B08: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82898B0C: 480086FD  bl 0x828a1208
	ctx.lr = 0x82898B10;
	sub_828A1208(ctx, base);
	// 82898B10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82898B14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898B18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82898B1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B28 size=8
    let mut pc: u32 = 0x82898B28;
    'dispatch: loop {
        match pc {
            0x82898B28 => {
    //   block [0x82898B28..0x82898B30)
	// 82898B28: 80630400  lwz r3, 0x400(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82898B2C: 4BF519B4  b 0x827ea4e0
	sub_827EA4E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B30 size=16
    let mut pc: u32 = 0x82898B30;
    'dispatch: loop {
        match pc {
            0x82898B30 => {
    //   block [0x82898B30..0x82898B40)
	// 82898B30: 816300EC  lwz r11, 0xec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 82898B34: 38A300EC  addi r5, r3, 0xec
	ctx.r[5].s64 = ctx.r[3].s64 + 236;
	// 82898B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82898B3C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B40 size=16
    let mut pc: u32 = 0x82898B40;
    'dispatch: loop {
        match pc {
            0x82898B40 => {
    //   block [0x82898B40..0x82898B50)
	// 82898B40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82898B44: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82898B48: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82898B4C: 4BC7800C  b 0x82510b58
	sub_82510B58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B50 size=4
    let mut pc: u32 = 0x82898B50;
    'dispatch: loop {
        match pc {
            0x82898B50 => {
    //   block [0x82898B50..0x82898B54)
	// 82898B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B58 size=8
    let mut pc: u32 = 0x82898B58;
    'dispatch: loop {
        match pc {
            0x82898B58 => {
    //   block [0x82898B58..0x82898B60)
	// 82898B58: 80630408  lwz r3, 0x408(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82898B5C: 4BA662E4  b 0x822fee40
	sub_822FEE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B60 size=20
    let mut pc: u32 = 0x82898B60;
    'dispatch: loop {
        match pc {
            0x82898B60 => {
    //   block [0x82898B60..0x82898B74)
	// 82898B60: 8163043C  lwz r11, 0x43c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1084 as u32) ) } as u64;
	// 82898B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82898B68: 409A000C  bne cr6, 0x82898b74
	if !ctx.cr[6].eq {
		sub_82898B74(ctx, base);
		return;
	}
	// 82898B6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82898B70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B74 size=16
    let mut pc: u32 = 0x82898B74;
    'dispatch: loop {
        match pc {
            0x82898B74 => {
    //   block [0x82898B74..0x82898B84)
	// 82898B74: 81430440  lwz r10, 0x440(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1088 as u32) ) } as u64;
	// 82898B78: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82898B7C: 7D631670  srawi r3, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82898B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B88 size=8
    let mut pc: u32 = 0x82898B88;
    'dispatch: loop {
        match pc {
            0x82898B88 => {
    //   block [0x82898B88..0x82898B90)
	// 82898B88: 80630410  lwz r3, 0x410(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82898B8C: 4BFFF574  b 0x82898100
	sub_82898100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898B90 size=28
    let mut pc: u32 = 0x82898B90;
    'dispatch: loop {
        match pc {
            0x82898B90 => {
    //   block [0x82898B90..0x82898BAC)
	// 82898B90: 81630448  lwz r11, 0x448(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82898B94: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 82898B98: 394AB210  addi r10, r10, -0x4df0
	ctx.r[10].s64 = ctx.r[10].s64 + -19952;
	// 82898B9C: 1D6B023C  mulli r11, r11, 0x23c
	ctx.r[11].s64 = ctx.r[11].s64 * 572;
	// 82898BA0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82898BA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82898BA8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898BAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898BAC size=32
    let mut pc: u32 = 0x82898BAC;
    'dispatch: loop {
        match pc {
            0x82898BAC => {
    //   block [0x82898BAC..0x82898BCC)
	// 82898BAC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82898BB0: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82898BB4: 409A000C  bne cr6, 0x82898bc0
	if !ctx.cr[6].eq {
	pc = 0x82898BC0; continue 'dispatch;
	}
	// 82898BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82898BBC: 9963036C  stb r11, 0x36c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(876 as u32), ctx.r[11].u8 ) };
	// 82898BC0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82898BC4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82898BC8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898BCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898BCC size=12
    let mut pc: u32 = 0x82898BCC;
    'dispatch: loop {
        match pc {
            0x82898BCC => {
    //   block [0x82898BCC..0x82898BD8)
	// 82898BCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82898BD0: 9963036C  stb r11, 0x36c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(876 as u32), ctx.r[11].u8 ) };
	// 82898BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898BD8 size=8
    let mut pc: u32 = 0x82898BD8;
    'dispatch: loop {
        match pc {
            0x82898BD8 => {
    //   block [0x82898BD8..0x82898BE0)
	// 82898BD8: 80630400  lwz r3, 0x400(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82898BDC: 4BF5178C  b 0x827ea368
	sub_827EA368(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82898BE0 size=8
    let mut pc: u32 = 0x82898BE0;
    'dispatch: loop {
        match pc {
            0x82898BE0 => {
    //   block [0x82898BE0..0x82898BE8)
	// 82898BE0: 80630400  lwz r3, 0x400(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82898BE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898BE8 size=144
    let mut pc: u32 = 0x82898BE8;
    'dispatch: loop {
        match pc {
            0x82898BE8 => {
    //   block [0x82898BE8..0x82898C78)
	// 82898BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82898BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898C00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82898C04: 485BD7C5  bl 0x82e563c8
	ctx.lr = 0x82898C08;
	sub_82E563C8(ctx, base);
	// 82898C08: 57DE063E  clrlwi r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82898C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898C10: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 82898C14: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82898C18: 4BC76F29  bl 0x8250fb40
	ctx.lr = 0x82898C1C;
	sub_8250FB40(ctx, base);
	// 82898C1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82898C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898C24: 419A0028  beq cr6, 0x82898c4c
	if ctx.cr[6].eq {
	pc = 0x82898C4C; continue 'dispatch;
	}
	// 82898C28: 4BC79061  bl 0x82511c88
	ctx.lr = 0x82898C2C;
	sub_82511C88(ctx, base);
	// 82898C2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82898C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898C34: 4BF5363D  bl 0x827ec270
	ctx.lr = 0x82898C38;
	sub_827EC270(ctx, base);
	// 82898C38: 807F0308  lwz r3, 0x308(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(776 as u32) ) } as u64;
	// 82898C3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82898C40: 419A0020  beq cr6, 0x82898c60
	if ctx.cr[6].eq {
	pc = 0x82898C60; continue 'dispatch;
	}
	// 82898C44: 48088795  bl 0x829213d8
	ctx.lr = 0x82898C48;
	sub_829213D8(ctx, base);
	// 82898C48: 48000018  b 0x82898c60
	pc = 0x82898C60; continue 'dispatch;
	// 82898C4C: 4BC7905D  bl 0x82511ca8
	ctx.lr = 0x82898C50;
	sub_82511CA8(ctx, base);
	// 82898C50: 807F0308  lwz r3, 0x308(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(776 as u32) ) } as u64;
	// 82898C54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82898C58: 419A0008  beq cr6, 0x82898c60
	if ctx.cr[6].eq {
	pc = 0x82898C60; continue 'dispatch;
	}
	// 82898C5C: 48088795  bl 0x829213f0
	ctx.lr = 0x82898C60;
	sub_829213F0(ctx, base);
	// 82898C60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82898C6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82898C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898C78 size=116
    let mut pc: u32 = 0x82898C78;
    'dispatch: loop {
        match pc {
            0x82898C78 => {
    //   block [0x82898C78..0x82898CEC)
	// 82898C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898C7C: 4890F4ED  bl 0x831a8168
	ctx.lr = 0x82898C80;
	sub_831A8130(ctx, base);
	// 82898C80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898C84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82898C88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82898C8C: 9B830060  stb r28, 0x60(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 82898C90: 9B830061  stb r28, 0x61(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(97 as u32), ctx.r[28].u8 ) };
	// 82898C94: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82898C98: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82898C9C: 488BB965  bl 0x83154600
	ctx.lr = 0x82898CA0;
	sub_83154600(ctx, base);
	// 82898CA0: 4BF54B79  bl 0x827ed818
	ctx.lr = 0x82898CA4;
	sub_827ED818(ctx, base);
	// 82898CA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82898CA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82898CAC: 4BF535C5  bl 0x827ec270
	ctx.lr = 0x82898CB0;
	sub_827EC270(ctx, base);
	// 82898CB0: 897D0360  lbz r11, 0x360(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 82898CB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82898CB8: 4182002C  beq 0x82898ce4
	if ctx.cr[0].eq {
	pc = 0x82898CE4; continue 'dispatch;
	}
	// 82898CBC: 3BFD037C  addi r31, r29, 0x37c
	ctx.r[31].s64 = ctx.r[29].s64 + 892;
	// 82898CC0: 3BC0000A  li r30, 0xa
	ctx.r[30].s64 = 10;
	// 82898CC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82898CC8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898CCC: 4BC79E3D  bl 0x82512b08
	ctx.lr = 0x82898CD0;
	sub_82512B08(ctx, base);
	// 82898CD0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82898CD4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82898CD8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82898CDC: 4082FFE8  bne 0x82898cc4
	if !ctx.cr[0].eq {
	pc = 0x82898CC4; continue 'dispatch;
	}
	// 82898CE0: 9B9D0360  stb r28, 0x360(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(864 as u32), ctx.r[28].u8 ) };
	// 82898CE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82898CE8: 4890F4D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898CF0 size=312
    let mut pc: u32 = 0x82898CF0;
    'dispatch: loop {
        match pc {
            0x82898CF0 => {
    //   block [0x82898CF0..0x82898E28)
	// 82898CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898CF4: 4890F471  bl 0x831a8164
	ctx.lr = 0x82898CF8;
	sub_831A8130(ctx, base);
	// 82898CF8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82898CFC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898D00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82898D04: 488BB8FD  bl 0x83154600
	ctx.lr = 0x82898D08;
	sub_83154600(ctx, base);
	// 82898D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898D0C: 48007065  bl 0x8289fd70
	ctx.lr = 0x82898D10;
	sub_8289FD70(ctx, base);
	// 82898D10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82898D14: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82898D18: 485C0A49  bl 0x82e59760
	ctx.lr = 0x82898D1C;
	sub_82E59760(ctx, base);
	// 82898D1C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82898D20: 419900FC  bgt cr6, 0x82898e1c
	if ctx.cr[6].gt {
	pc = 0x82898E1C; continue 'dispatch;
	}
	// 82898D24: 897E0061  lbz r11, 0x61(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(97 as u32) ) } as u64;
	// 82898D28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82898D2C: 408200B4  bne 0x82898de0
	if !ctx.cr[0].eq {
	pc = 0x82898DE0; continue 'dispatch;
	}
	// 82898D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898D34: 4BF54AE5  bl 0x827ed818
	ctx.lr = 0x82898D38;
	sub_827ED818(ctx, base);
	// 82898D38: 39630364  addi r11, r3, 0x364
	ctx.r[11].s64 = ctx.r[3].s64 + 868;
	// 82898D3C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82898D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898D44: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898D48: 83AA671C  lwz r29, 0x671c(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26396 as u32) ) } as u64;
	// 82898D4C: 48006FB5  bl 0x8289fd00
	ctx.lr = 0x82898D50;
	sub_8289FD00(ctx, base);
	// 82898D50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898D54: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82898D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898D5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82898D60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82898D64: 4E800421  bctrl
	ctx.lr = 0x82898D68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82898D68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82898D6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82898D70: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82898D74: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82898D78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82898D7C: 4BA51C2D  bl 0x822ea9a8
	ctx.lr = 0x82898D80;
	sub_822EA9A8(ctx, base);
	// 82898D80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82898D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898D88: 480071E1  bl 0x8289ff68
	ctx.lr = 0x82898D8C;
	sub_8289FF68(ctx, base);
	// 82898D8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898D90: 4182008C  beq 0x82898e1c
	if ctx.cr[0].eq {
	pc = 0x82898E1C; continue 'dispatch;
	}
	// 82898D94: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898D98: 40820084  bne 0x82898e1c
	if !ctx.cr[0].eq {
	pc = 0x82898E1C; continue 'dispatch;
	}
	// 82898D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898DA0: 48006FA9  bl 0x8289fd48
	ctx.lr = 0x82898DA4;
	sub_8289FD48(ctx, base);
	// 82898DA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82898DA8: 4182002C  beq 0x82898dd4
	if ctx.cr[0].eq {
	pc = 0x82898DD4; continue 'dispatch;
	}
	// 82898DAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82898DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898DB4: 808BFE48  lwz r4, -0x1b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-440 as u32) ) } as u64;
	// 82898DB8: 4855AC51  bl 0x82df3a08
	ctx.lr = 0x82898DBC;
	sub_82DF3A08(ctx, base);
	// 82898DBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82898DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898DC4: 4BF5697D  bl 0x827ef740
	ctx.lr = 0x82898DC8;
	sub_827EF740(ctx, base);
	// 82898DC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898DCC: 4855A65D  bl 0x82df3428
	ctx.lr = 0x82898DD0;
	sub_82DF3428(ctx, base);
	// 82898DD0: 4800004C  b 0x82898e1c
	pc = 0x82898E1C; continue 'dispatch;
	// 82898DD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82898DD8: 997E0061  stb r11, 0x61(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82898DDC: 48000040  b 0x82898e1c
	pc = 0x82898E1C; continue 'dispatch;
	// 82898DE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82898DE4: 485C0985  bl 0x82e59768
	ctx.lr = 0x82898DE8;
	sub_82E59768(ctx, base);
	// 82898DE8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82898DEC: C1BE0064  lfs f13, 0x64(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82898DF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82898DF4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82898DF8: D1BE0064  stfs f13, 0x64(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82898DFC: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82898E00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82898E04: 40990018  ble cr6, 0x82898e1c
	if !ctx.cr[6].gt {
	pc = 0x82898E1C; continue 'dispatch;
	}
	// 82898E08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82898E0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82898E10: 995E0061  stb r10, 0x61(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(97 as u32), ctx.r[10].u8 ) };
	// 82898E14: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82898E18: D01E0064  stfs f0, 0x64(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82898E1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82898E20: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82898E24: 4890F390  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82898E28 size=72
    let mut pc: u32 = 0x82898E28;
    'dispatch: loop {
        match pc {
            0x82898E28 => {
    //   block [0x82898E28..0x82898E70)
	// 82898E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898E30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898E34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898E3C: 485C3AED  bl 0x82e5c928
	ctx.lr = 0x82898E40;
	sub_82E5C928(ctx, base);
	// 82898E40: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82898E44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82898E48: 394A8D80  addi r10, r10, -0x7280
	ctx.r[10].s64 = ctx.r[10].s64 + -29312;
	// 82898E4C: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82898E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898E54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82898E58: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82898E5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82898E60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82898E64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82898E68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82898E6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898E70 size=92
    let mut pc: u32 = 0x82898E70;
    'dispatch: loop {
        match pc {
            0x82898E70 => {
    //   block [0x82898E70..0x82898ECC)
	// 82898E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898E74: 4890F2F9  bl 0x831a816c
	ctx.lr = 0x82898E78;
	sub_831A8130(ctx, base);
	// 82898E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898E7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82898E80: 488BB781  bl 0x83154600
	ctx.lr = 0x82898E84;
	sub_83154600(ctx, base);
	// 82898E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898E88: 48006F09  bl 0x8289fd90
	ctx.lr = 0x82898E8C;
	sub_8289FD90(ctx, base);
	// 82898E8C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82898E90: 41820014  beq 0x82898ea4
	if ctx.cr[0].eq {
	pc = 0x82898EA4; continue 'dispatch;
	}
	// 82898E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898E98: 4BF54981  bl 0x827ed818
	ctx.lr = 0x82898E9C;
	sub_827ED818(ctx, base);
	// 82898E9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82898EA0: 4BF533D9  bl 0x827ec278
	ctx.lr = 0x82898EA4;
	sub_827EC278(ctx, base);
	// 82898EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898EA8: 4BF54971  bl 0x827ed818
	ctx.lr = 0x82898EAC;
	sub_827ED818(ctx, base);
	// 82898EAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82898EB0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82898EB4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82898EB8: 48075EC1  bl 0x8290ed78
	ctx.lr = 0x82898EBC;
	sub_8290ED78(ctx, base);
	// 82898EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82898EC0: 997D0060  stb r11, 0x60(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82898EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82898EC8: 4890F2F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82898ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82898ED0 size=328
    let mut pc: u32 = 0x82898ED0;
    'dispatch: loop {
        match pc {
            0x82898ED0 => {
    //   block [0x82898ED0..0x82899018)
	// 82898ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82898ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82898ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82898EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82898EE0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82898EE4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82898EE8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82898EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82898EF0: 488BB711  bl 0x83154600
	ctx.lr = 0x82898EF4;
	sub_83154600(ctx, base);
	// 82898EF4: 48006E9D  bl 0x8289fd90
	ctx.lr = 0x82898EF8;
	sub_8289FD90(ctx, base);
	// 82898EF8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82898EFC: 4182001C  beq 0x82898f18
	if ctx.cr[0].eq {
	pc = 0x82898F18; continue 'dispatch;
	}
	// 82898F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898F04: 488BB6FD  bl 0x83154600
	ctx.lr = 0x82898F08;
	sub_83154600(ctx, base);
	// 82898F08: 4BF54911  bl 0x827ed818
	ctx.lr = 0x82898F0C;
	sub_827ED818(ctx, base);
	// 82898F0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82898F10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82898F14: 4BF53355  bl 0x827ec268
	ctx.lr = 0x82898F18;
	sub_827EC268(ctx, base);
	// 82898F18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82898F1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82898F20: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 82898F24: 4855AAE5  bl 0x82df3a08
	ctx.lr = 0x82898F28;
	sub_82DF3A08(ctx, base);
	// 82898F28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898F2C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82898F30: 388B8DAC  addi r4, r11, -0x7254
	ctx.r[4].s64 = ctx.r[11].s64 + -29268;
	// 82898F34: 4855AAD5  bl 0x82df3a08
	ctx.lr = 0x82898F38;
	sub_82DF3A08(ctx, base);
	// 82898F38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82898F3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82898F40: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82898F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898F48: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82898F4C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82898F50: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82898F54: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82898F58: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82898F5C: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82898F60: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82898F64: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82898F68: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82898F6C: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82898F70: D3C10088  stfs f30, 0x88(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82898F74: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82898F78: 488BB689  bl 0x83154600
	ctx.lr = 0x82898F7C;
	sub_83154600(ctx, base);
	// 82898F7C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82898F80: 4BF54899  bl 0x827ed818
	ctx.lr = 0x82898F84;
	sub_827ED818(ctx, base);
	// 82898F84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82898F88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82898F8C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82898F90: 4BF53679  bl 0x827ec608
	ctx.lr = 0x82898F94;
	sub_827EC608(ctx, base);
	// 82898F94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82898F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898F9C: 388B8DA4  addi r4, r11, -0x725c
	ctx.r[4].s64 = ctx.r[11].s64 + -29276;
	// 82898FA0: 4855AA69  bl 0x82df3a08
	ctx.lr = 0x82898FA4;
	sub_82DF3A08(ctx, base);
	// 82898FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898FA8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82898FAC: 488BB655  bl 0x83154600
	ctx.lr = 0x82898FB0;
	sub_83154600(ctx, base);
	// 82898FB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82898FB4: 48006D55  bl 0x8289fd08
	ctx.lr = 0x82898FB8;
	sub_8289FD08(ctx, base);
	// 82898FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82898FBC: 4855A46D  bl 0x82df3428
	ctx.lr = 0x82898FC0;
	sub_82DF3428(ctx, base);
	// 82898FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898FC4: 488BB63D  bl 0x83154600
	ctx.lr = 0x82898FC8;
	sub_83154600(ctx, base);
	// 82898FC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82898FCC: 48006D6D  bl 0x8289fd38
	ctx.lr = 0x82898FD0;
	sub_8289FD38(ctx, base);
	// 82898FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82898FD4: 488BB62D  bl 0x83154600
	ctx.lr = 0x82898FD8;
	sub_83154600(ctx, base);
	// 82898FD8: 4BF54841  bl 0x827ed818
	ctx.lr = 0x82898FDC;
	sub_827ED818(ctx, base);
	// 82898FDC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82898FE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82898FE4: 48075D95  bl 0x8290ed78
	ctx.lr = 0x82898FE8;
	sub_8290ED78(ctx, base);
	// 82898FE8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82898FEC: 4855A43D  bl 0x82df3428
	ctx.lr = 0x82898FF0;
	sub_82DF3428(ctx, base);
	// 82898FF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82898FF4: 4855A435  bl 0x82df3428
	ctx.lr = 0x82898FF8;
	sub_82DF3428(ctx, base);
	// 82898FF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82898FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899004: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82899008: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8289900C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899018 size=160
    let mut pc: u32 = 0x82899018;
    'dispatch: loop {
        match pc {
            0x82899018 => {
    //   block [0x82899018..0x828990B8)
	// 82899018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289901C: 4890F151  bl 0x831a816c
	ctx.lr = 0x82899020;
	sub_831A8130(ctx, base);
	// 82899020: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899024: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82899028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289902C: 3BCB0380  addi r30, r11, 0x380
	ctx.r[30].s64 = ctx.r[11].s64 + 896;
	// 82899030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899034: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82899038: 4855A9D1  bl 0x82df3a08
	ctx.lr = 0x8289903C;
	sub_82DF3A08(ctx, base);
	// 8289903C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899040: 488BB5C1  bl 0x83154600
	ctx.lr = 0x82899044;
	sub_83154600(ctx, base);
	// 82899044: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899048: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8289904C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82899050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899054: 4E800421  bctrl
	ctx.lr = 0x82899058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899058: 4BF51251  bl 0x827ea2a8
	ctx.lr = 0x8289905C;
	sub_827EA2A8(ctx, base);
	// 8289905C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82899060: 4855A241  bl 0x82df32a0
	ctx.lr = 0x82899064;
	sub_82DF32A0(ctx, base);
	// 82899064: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82899068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289906C: 4855A3BD  bl 0x82df3428
	ctx.lr = 0x82899070;
	sub_82DF3428(ctx, base);
	// 82899070: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82899074: 4182002C  beq 0x828990a0
	if ctx.cr[0].eq {
	pc = 0x828990A0; continue 'dispatch;
	}
	// 82899078: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289907C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899080: 4855A989  bl 0x82df3a08
	ctx.lr = 0x82899084;
	sub_82DF3A08(ctx, base);
	// 82899084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899088: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8289908C: 488BB575  bl 0x83154600
	ctx.lr = 0x82899090;
	sub_83154600(ctx, base);
	// 82899090: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82899094: 48006C75  bl 0x8289fd08
	ctx.lr = 0x82899098;
	sub_8289FD08(ctx, base);
	// 82899098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289909C: 4855A38D  bl 0x82df3428
	ctx.lr = 0x828990A0;
	sub_82DF3428(ctx, base);
	// 828990A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828990A4: 488BB55D  bl 0x83154600
	ctx.lr = 0x828990A8;
	sub_83154600(ctx, base);
	// 828990A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828990AC: 48006C8D  bl 0x8289fd38
	ctx.lr = 0x828990B0;
	sub_8289FD38(ctx, base);
	// 828990B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828990B4: 4890F108  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828990B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828990B8 size=356
    let mut pc: u32 = 0x828990B8;
    'dispatch: loop {
        match pc {
            0x828990B8 => {
    //   block [0x828990B8..0x8289921C)
	// 828990B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828990BC: 4890F0B1  bl 0x831a816c
	ctx.lr = 0x828990C0;
	sub_831A8130(ctx, base);
	// 828990C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828990C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828990C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828990CC: 488BB535  bl 0x83154600
	ctx.lr = 0x828990D0;
	sub_83154600(ctx, base);
	// 828990D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828990D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828990D8: 485C0691  bl 0x82e59768
	ctx.lr = 0x828990DC;
	sub_82E59768(ctx, base);
	// 828990DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828990E0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828990E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828990E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828990EC: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828990F0: C00A8954  lfs f0, -0x76ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828990F4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828990F8: 48006D91  bl 0x8289fe88
	ctx.lr = 0x828990FC;
	sub_8289FE88(ctx, base);
	// 828990FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899100: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82899104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899108: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8289910C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899110: 4E800421  bctrl
	ctx.lr = 0x82899114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899114: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82899118: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289911C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82899120: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82899124: 485E41A5  bl 0x82e7d2c8
	ctx.lr = 0x82899128;
	sub_82E7D2C8(ctx, base);
	// 82899128: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899220 size=96
    let mut pc: u32 = 0x82899220;
    'dispatch: loop {
        match pc {
            0x82899220 => {
    //   block [0x82899220..0x82899280)
	// 82899220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289922C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899230: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82899234: 488BB3CD  bl 0x83154600
	ctx.lr = 0x82899238;
	sub_83154600(ctx, base);
	// 82899238: 4BF545E1  bl 0x827ed818
	ctx.lr = 0x8289923C;
	sub_827ED818(ctx, base);
	// 8289923C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82899240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899244: 4BC76285  bl 0x8250f4c8
	ctx.lr = 0x82899248;
	sub_8250F4C8(ctx, base);
	// 82899248: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289924C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899250: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82899254: 409A0008  bne cr6, 0x8289925c
	if !ctx.cr[6].eq {
	pc = 0x8289925C; continue 'dispatch;
	}
	// 82899258: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289925C: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82899260: 4BF36BE1  bl 0x827cfe40
	ctx.lr = 0x82899264;
	sub_827CFE40(ctx, base);
	// 82899264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899268: 48558A29  bl 0x82df1c90
	ctx.lr = 0x8289926C;
	sub_82DF1C90(ctx, base);
	// 8289926C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289927C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82899280 size=308
    let mut pc: u32 = 0x82899280;
    'dispatch: loop {
        match pc {
            0x82899280 => {
    //   block [0x82899280..0x828993B4)
	// 82899280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289928C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899290: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82899294: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899298: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289929C: 488BB365  bl 0x83154600
	ctx.lr = 0x828992A0;
	sub_83154600(ctx, base);
	// 828992A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828992A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828992A8: 485C04C1  bl 0x82e59768
	ctx.lr = 0x828992AC;
	sub_82E59768(ctx, base);
	// 828992AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828992B0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828992B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828992B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828992BC: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828992C0: C00A8954  lfs f0, -0x76ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828992C4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828992C8: 48006BC1  bl 0x8289fe88
	ctx.lr = 0x828992CC;
	sub_8289FE88(ctx, base);
	// 828992CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828992D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828992D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828992D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828992DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828992E0: 4E800421  bctrl
	ctx.lr = 0x828992E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828992E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828992E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828992EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828992F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828992F4: 485E3FD5  bl 0x82e7d2c8
	ctx.lr = 0x828992F8;
	sub_82E7D2C8(ctx, base);
	// 828992F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828993B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828993B8 size=116
    let mut pc: u32 = 0x828993B8;
    'dispatch: loop {
        match pc {
            0x828993B8 => {
    //   block [0x828993B8..0x8289942C)
	// 828993B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828993BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828993C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828993C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828993C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828993CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828993D0: 488BB231  bl 0x83154600
	ctx.lr = 0x828993D4;
	sub_83154600(ctx, base);
	// 828993D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828993D8: 4BF54441  bl 0x827ed818
	ctx.lr = 0x828993DC;
	sub_827ED818(ctx, base);
	// 828993DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828993E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828993E4: 388BE814  addi r4, r11, -0x17ec
	ctx.r[4].s64 = ctx.r[11].s64 + -6124;
	// 828993E8: 4855A621  bl 0x82df3a08
	ctx.lr = 0x828993EC;
	sub_82DF3A08(ctx, base);
	// 828993EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828993F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828993F4: 48006915  bl 0x8289fd08
	ctx.lr = 0x828993F8;
	sub_8289FD08(ctx, base);
	// 828993F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828993FC: 4855A02D  bl 0x82df3428
	ctx.lr = 0x82899400;
	sub_82DF3428(ctx, base);
	// 82899400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82899404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899408: 48006931  bl 0x8289fd38
	ctx.lr = 0x8289940C;
	sub_8289FD38(ctx, base);
	// 8289940C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899410: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82899414: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289941C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899420: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899430 size=196
    let mut pc: u32 = 0x82899430;
    'dispatch: loop {
        match pc {
            0x82899430 => {
    //   block [0x82899430..0x828994F4)
	// 82899430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289943C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289944C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899450: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899454: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899458: 4BA274E1  bl 0x822c0938
	ctx.lr = 0x8289945C;
	sub_822C0938(ctx, base);
	// 8289945C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899460: 41820028  beq 0x82899488
	if ctx.cr[0].eq {
	pc = 0x82899488; continue 'dispatch;
	}
	// 82899464: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899468: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289946C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899470: 392B8BDC  addi r9, r11, -0x7424
	ctx.r[9].s64 = ctx.r[11].s64 + -29732;
	// 82899474: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899478: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289947C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899480: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899484: 48000008  b 0x8289948c
	pc = 0x8289948C; continue 'dispatch;
	// 82899488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289948C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899494: 409A0044  bne cr6, 0x828994d8
	if !ctx.cr[6].eq {
	pc = 0x828994D8; continue 'dispatch;
	}
	// 82899498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289949C: 419A001C  beq cr6, 0x828994b8
	if ctx.cr[6].eq {
	pc = 0x828994B8; continue 'dispatch;
	}
	// 828994A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828994A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828994A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828994AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828994B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828994B4: 4E800421  bctrl
	ctx.lr = 0x828994B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828994B8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828994BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828994C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828994C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828994C8: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 828994CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828994D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828994D4: 4BA26B2D  bl 0x822c0000
	ctx.lr = 0x828994D8;
	sub_822C0000(ctx, base);
	// 828994D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828994DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828994E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828994E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828994E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828994EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828994F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828994F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828994F8 size=196
    let mut pc: u32 = 0x828994F8;
    'dispatch: loop {
        match pc {
            0x828994F8 => {
    //   block [0x828994F8..0x828995BC)
	// 828994F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828994FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289950C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899514: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899518: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289951C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899520: 4BA27419  bl 0x822c0938
	ctx.lr = 0x82899524;
	sub_822C0938(ctx, base);
	// 82899524: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899528: 41820028  beq 0x82899550
	if ctx.cr[0].eq {
	pc = 0x82899550; continue 'dispatch;
	}
	// 8289952C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899530: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899534: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899538: 392B8BF0  addi r9, r11, -0x7410
	ctx.r[9].s64 = ctx.r[11].s64 + -29712;
	// 8289953C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899540: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899544: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899548: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289954C: 48000008  b 0x82899554
	pc = 0x82899554; continue 'dispatch;
	// 82899550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899554: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289955C: 409A0044  bne cr6, 0x828995a0
	if !ctx.cr[6].eq {
	pc = 0x828995A0; continue 'dispatch;
	}
	// 82899560: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899564: 419A001C  beq cr6, 0x82899580
	if ctx.cr[6].eq {
	pc = 0x82899580; continue 'dispatch;
	}
	// 82899568: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289956C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899574: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899578: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289957C: 4E800421  bctrl
	ctx.lr = 0x82899580;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899580: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899584: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289958C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899590: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899594: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899598: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289959C: 4BA26A65  bl 0x822c0000
	ctx.lr = 0x828995A0;
	sub_822C0000(ctx, base);
	// 828995A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828995A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828995A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828995AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828995B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828995B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828995B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828995C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828995C0 size=196
    let mut pc: u32 = 0x828995C0;
    'dispatch: loop {
        match pc {
            0x828995C0 => {
    //   block [0x828995C0..0x82899684)
	// 828995C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828995C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828995C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828995CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828995D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828995D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828995D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828995DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828995E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828995E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828995E8: 4BA27351  bl 0x822c0938
	ctx.lr = 0x828995EC;
	sub_822C0938(ctx, base);
	// 828995EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828995F0: 41820028  beq 0x82899618
	if ctx.cr[0].eq {
	pc = 0x82899618; continue 'dispatch;
	}
	// 828995F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828995F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828995FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899600: 392B8C04  addi r9, r11, -0x73fc
	ctx.r[9].s64 = ctx.r[11].s64 + -29692;
	// 82899604: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899608: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289960C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899610: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899614: 48000008  b 0x8289961c
	pc = 0x8289961C; continue 'dispatch;
	// 82899618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289961C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899624: 409A0044  bne cr6, 0x82899668
	if !ctx.cr[6].eq {
	pc = 0x82899668; continue 'dispatch;
	}
	// 82899628: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289962C: 419A001C  beq cr6, 0x82899648
	if ctx.cr[6].eq {
	pc = 0x82899648; continue 'dispatch;
	}
	// 82899630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899634: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289963C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899644: 4E800421  bctrl
	ctx.lr = 0x82899648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899648: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289964C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899654: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899658: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289965C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899660: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899664: 4BA2699D  bl 0x822c0000
	ctx.lr = 0x82899668;
	sub_822C0000(ctx, base);
	// 82899668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289966C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899678: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289967C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899688 size=196
    let mut pc: u32 = 0x82899688;
    'dispatch: loop {
        match pc {
            0x82899688 => {
    //   block [0x82899688..0x8289974C)
	// 82899688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289968C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289969C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828996A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828996A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828996A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828996AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828996B0: 4BA27289  bl 0x822c0938
	ctx.lr = 0x828996B4;
	sub_822C0938(ctx, base);
	// 828996B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828996B8: 41820028  beq 0x828996e0
	if ctx.cr[0].eq {
	pc = 0x828996E0; continue 'dispatch;
	}
	// 828996BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828996C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828996C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828996C8: 392B8C18  addi r9, r11, -0x73e8
	ctx.r[9].s64 = ctx.r[11].s64 + -29672;
	// 828996CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828996D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828996D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828996D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828996DC: 48000008  b 0x828996e4
	pc = 0x828996E4; continue 'dispatch;
	// 828996E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828996E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828996E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828996EC: 409A0044  bne cr6, 0x82899730
	if !ctx.cr[6].eq {
	pc = 0x82899730; continue 'dispatch;
	}
	// 828996F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828996F4: 419A001C  beq cr6, 0x82899710
	if ctx.cr[6].eq {
	pc = 0x82899710; continue 'dispatch;
	}
	// 828996F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828996FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899704: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289970C: 4E800421  bctrl
	ctx.lr = 0x82899710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899710: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899714: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289971C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899720: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899724: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899728: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289972C: 4BA268D5  bl 0x822c0000
	ctx.lr = 0x82899730;
	sub_822C0000(ctx, base);
	// 82899730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289973C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899750 size=172
    let mut pc: u32 = 0x82899750;
    'dispatch: loop {
        match pc {
            0x82899750 => {
    //   block [0x82899750..0x828997FC)
	// 82899750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289975C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289976C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899774: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899778: 4BA271C1  bl 0x822c0938
	ctx.lr = 0x8289977C;
	sub_822C0938(ctx, base);
	// 8289977C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899780: 41820028  beq 0x828997a8
	if ctx.cr[0].eq {
	pc = 0x828997A8; continue 'dispatch;
	}
	// 82899784: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899788: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289978C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899790: 392B8C2C  addi r9, r11, -0x73d4
	ctx.r[9].s64 = ctx.r[11].s64 + -29652;
	// 82899794: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289979C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828997A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828997A4: 48000008  b 0x828997ac
	pc = 0x828997AC; continue 'dispatch;
	// 828997A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828997AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828997B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828997B4: 409A002C  bne cr6, 0x828997e0
	if !ctx.cr[6].eq {
	pc = 0x828997E0; continue 'dispatch;
	}
	// 828997B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828997BC: 4BA26AAD  bl 0x822c0268
	ctx.lr = 0x828997C0;
	sub_822C0268(ctx, base);
	// 828997C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828997C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828997C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828997CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828997D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828997D4: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 828997D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828997DC: 4BA26825  bl 0x822c0000
	ctx.lr = 0x828997E0;
	sub_822C0000(ctx, base);
	// 828997E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828997E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828997E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828997EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828997F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828997F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828997F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899800 size=196
    let mut pc: u32 = 0x82899800;
    'dispatch: loop {
        match pc {
            0x82899800 => {
    //   block [0x82899800..0x828998C4)
	// 82899800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289980C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289981C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899820: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899824: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899828: 4BA27111  bl 0x822c0938
	ctx.lr = 0x8289982C;
	sub_822C0938(ctx, base);
	// 8289982C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899830: 41820028  beq 0x82899858
	if ctx.cr[0].eq {
	pc = 0x82899858; continue 'dispatch;
	}
	// 82899834: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899838: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289983C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899840: 392B8C40  addi r9, r11, -0x73c0
	ctx.r[9].s64 = ctx.r[11].s64 + -29632;
	// 82899844: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899848: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289984C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899850: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899854: 48000008  b 0x8289985c
	pc = 0x8289985C; continue 'dispatch;
	// 82899858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289985C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899864: 409A0044  bne cr6, 0x828998a8
	if !ctx.cr[6].eq {
	pc = 0x828998A8; continue 'dispatch;
	}
	// 82899868: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289986C: 419A001C  beq cr6, 0x82899888
	if ctx.cr[6].eq {
	pc = 0x82899888; continue 'dispatch;
	}
	// 82899870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899874: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289987C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899884: 4E800421  bctrl
	ctx.lr = 0x82899888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899888: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289988C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899894: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899898: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289989C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828998A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828998A4: 4BA2675D  bl 0x822c0000
	ctx.lr = 0x828998A8;
	sub_822C0000(ctx, base);
	// 828998A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828998AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828998B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828998B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828998B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828998BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828998C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828998C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828998C8 size=196
    let mut pc: u32 = 0x828998C8;
    'dispatch: loop {
        match pc {
            0x828998C8 => {
    //   block [0x828998C8..0x8289998C)
	// 828998C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828998CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828998D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828998D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828998D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828998DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828998E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828998E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828998E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828998EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828998F0: 4BA27049  bl 0x822c0938
	ctx.lr = 0x828998F4;
	sub_822C0938(ctx, base);
	// 828998F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828998F8: 41820028  beq 0x82899920
	if ctx.cr[0].eq {
	pc = 0x82899920; continue 'dispatch;
	}
	// 828998FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899900: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899904: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899908: 392B8C54  addi r9, r11, -0x73ac
	ctx.r[9].s64 = ctx.r[11].s64 + -29612;
	// 8289990C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899914: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899918: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289991C: 48000008  b 0x82899924
	pc = 0x82899924; continue 'dispatch;
	// 82899920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899924: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289992C: 409A0044  bne cr6, 0x82899970
	if !ctx.cr[6].eq {
	pc = 0x82899970; continue 'dispatch;
	}
	// 82899930: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899934: 419A001C  beq cr6, 0x82899950
	if ctx.cr[6].eq {
	pc = 0x82899950; continue 'dispatch;
	}
	// 82899938: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289993C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899944: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289994C: 4E800421  bctrl
	ctx.lr = 0x82899950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899950: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899954: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289995C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899960: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899964: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899968: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289996C: 4BA26695  bl 0x822c0000
	ctx.lr = 0x82899970;
	sub_822C0000(ctx, base);
	// 82899970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289997C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899990 size=196
    let mut pc: u32 = 0x82899990;
    'dispatch: loop {
        match pc {
            0x82899990 => {
    //   block [0x82899990..0x82899A54)
	// 82899990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289999C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828999A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828999A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828999A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828999AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828999B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828999B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828999B8: 4BA26F81  bl 0x822c0938
	ctx.lr = 0x828999BC;
	sub_822C0938(ctx, base);
	// 828999BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828999C0: 41820028  beq 0x828999e8
	if ctx.cr[0].eq {
	pc = 0x828999E8; continue 'dispatch;
	}
	// 828999C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828999C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828999CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828999D0: 392B8C68  addi r9, r11, -0x7398
	ctx.r[9].s64 = ctx.r[11].s64 + -29592;
	// 828999D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828999D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828999DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828999E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828999E4: 48000008  b 0x828999ec
	pc = 0x828999EC; continue 'dispatch;
	// 828999E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828999EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828999F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828999F4: 409A0044  bne cr6, 0x82899a38
	if !ctx.cr[6].eq {
	pc = 0x82899A38; continue 'dispatch;
	}
	// 828999F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828999FC: 419A001C  beq cr6, 0x82899a18
	if ctx.cr[6].eq {
	pc = 0x82899A18; continue 'dispatch;
	}
	// 82899A00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899A04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899A0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899A10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899A14: 4E800421  bctrl
	ctx.lr = 0x82899A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899A18: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899A1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899A24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899A28: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899A2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899A30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899A34: 4BA265CD  bl 0x822c0000
	ctx.lr = 0x82899A38;
	sub_822C0000(ctx, base);
	// 82899A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899A3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899A48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899A4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899A58 size=196
    let mut pc: u32 = 0x82899A58;
    'dispatch: loop {
        match pc {
            0x82899A58 => {
    //   block [0x82899A58..0x82899B1C)
	// 82899A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899A60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899A64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899A68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899A6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899A70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899A74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899A78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899A7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899A80: 4BA26EB9  bl 0x822c0938
	ctx.lr = 0x82899A84;
	sub_822C0938(ctx, base);
	// 82899A84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899A88: 41820028  beq 0x82899ab0
	if ctx.cr[0].eq {
	pc = 0x82899AB0; continue 'dispatch;
	}
	// 82899A8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899A90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899A94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899A98: 392B8C7C  addi r9, r11, -0x7384
	ctx.r[9].s64 = ctx.r[11].s64 + -29572;
	// 82899A9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899AA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899AA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899AAC: 48000008  b 0x82899ab4
	pc = 0x82899AB4; continue 'dispatch;
	// 82899AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899AB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899ABC: 409A0044  bne cr6, 0x82899b00
	if !ctx.cr[6].eq {
	pc = 0x82899B00; continue 'dispatch;
	}
	// 82899AC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899AC4: 419A001C  beq cr6, 0x82899ae0
	if ctx.cr[6].eq {
	pc = 0x82899AE0; continue 'dispatch;
	}
	// 82899AC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899ACC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899AD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899AD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899ADC: 4E800421  bctrl
	ctx.lr = 0x82899AE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899AE0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899AE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899AEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899AF0: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899AF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899AF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899AFC: 4BA26505  bl 0x822c0000
	ctx.lr = 0x82899B00;
	sub_822C0000(ctx, base);
	// 82899B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899B20 size=196
    let mut pc: u32 = 0x82899B20;
    'dispatch: loop {
        match pc {
            0x82899B20 => {
    //   block [0x82899B20..0x82899BE4)
	// 82899B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899B28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899B2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899B30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899B34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899B38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899B3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899B40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899B44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899B48: 4BA26DF1  bl 0x822c0938
	ctx.lr = 0x82899B4C;
	sub_822C0938(ctx, base);
	// 82899B4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899B50: 41820028  beq 0x82899b78
	if ctx.cr[0].eq {
	pc = 0x82899B78; continue 'dispatch;
	}
	// 82899B54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899B58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899B5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899B60: 392B8C90  addi r9, r11, -0x7370
	ctx.r[9].s64 = ctx.r[11].s64 + -29552;
	// 82899B64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899B68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899B6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899B70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899B74: 48000008  b 0x82899b7c
	pc = 0x82899B7C; continue 'dispatch;
	// 82899B78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899B7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899B84: 409A0044  bne cr6, 0x82899bc8
	if !ctx.cr[6].eq {
	pc = 0x82899BC8; continue 'dispatch;
	}
	// 82899B88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899B8C: 419A001C  beq cr6, 0x82899ba8
	if ctx.cr[6].eq {
	pc = 0x82899BA8; continue 'dispatch;
	}
	// 82899B90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899B94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899B9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899BA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899BA4: 4E800421  bctrl
	ctx.lr = 0x82899BA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899BA8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899BAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899BB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899BB8: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899BBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899BC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899BC4: 4BA2643D  bl 0x822c0000
	ctx.lr = 0x82899BC8;
	sub_822C0000(ctx, base);
	// 82899BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899BCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899BD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899BD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899BD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899BDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899BE8 size=196
    let mut pc: u32 = 0x82899BE8;
    'dispatch: loop {
        match pc {
            0x82899BE8 => {
    //   block [0x82899BE8..0x82899CAC)
	// 82899BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899BF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899BF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899BF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899BFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899C04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899C08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899C0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899C10: 4BA26D29  bl 0x822c0938
	ctx.lr = 0x82899C14;
	sub_822C0938(ctx, base);
	// 82899C14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899C18: 41820028  beq 0x82899c40
	if ctx.cr[0].eq {
	pc = 0x82899C40; continue 'dispatch;
	}
	// 82899C1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899C20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899C24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899C28: 392B8CA4  addi r9, r11, -0x735c
	ctx.r[9].s64 = ctx.r[11].s64 + -29532;
	// 82899C2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899C30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899C34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899C38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899C3C: 48000008  b 0x82899c44
	pc = 0x82899C44; continue 'dispatch;
	// 82899C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899C44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899C4C: 409A0044  bne cr6, 0x82899c90
	if !ctx.cr[6].eq {
	pc = 0x82899C90; continue 'dispatch;
	}
	// 82899C50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899C54: 419A001C  beq cr6, 0x82899c70
	if ctx.cr[6].eq {
	pc = 0x82899C70; continue 'dispatch;
	}
	// 82899C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899C5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899C64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899C68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899C6C: 4E800421  bctrl
	ctx.lr = 0x82899C70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899C70: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899C74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899C7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899C80: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899C84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899C88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899C8C: 4BA26375  bl 0x822c0000
	ctx.lr = 0x82899C90;
	sub_822C0000(ctx, base);
	// 82899C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899C94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899CA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899CB0 size=196
    let mut pc: u32 = 0x82899CB0;
    'dispatch: loop {
        match pc {
            0x82899CB0 => {
    //   block [0x82899CB0..0x82899D74)
	// 82899CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899CB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899CBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899CC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899CC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899CC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899CCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899CD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899CD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899CD8: 4BA26C61  bl 0x822c0938
	ctx.lr = 0x82899CDC;
	sub_822C0938(ctx, base);
	// 82899CDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899CE0: 41820028  beq 0x82899d08
	if ctx.cr[0].eq {
	pc = 0x82899D08; continue 'dispatch;
	}
	// 82899CE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899CE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899CEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899CF0: 392B8CB8  addi r9, r11, -0x7348
	ctx.r[9].s64 = ctx.r[11].s64 + -29512;
	// 82899CF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899CF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899CFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899D00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899D04: 48000008  b 0x82899d0c
	pc = 0x82899D0C; continue 'dispatch;
	// 82899D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899D0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899D14: 409A0044  bne cr6, 0x82899d58
	if !ctx.cr[6].eq {
	pc = 0x82899D58; continue 'dispatch;
	}
	// 82899D18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899D1C: 419A001C  beq cr6, 0x82899d38
	if ctx.cr[6].eq {
	pc = 0x82899D38; continue 'dispatch;
	}
	// 82899D20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899D24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899D2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899D30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899D34: 4E800421  bctrl
	ctx.lr = 0x82899D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899D38: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899D3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899D44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899D48: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899D4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899D50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899D54: 4BA262AD  bl 0x822c0000
	ctx.lr = 0x82899D58;
	sub_822C0000(ctx, base);
	// 82899D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899D5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899D60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899D64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899D68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899D6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899D70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899D78 size=196
    let mut pc: u32 = 0x82899D78;
    'dispatch: loop {
        match pc {
            0x82899D78 => {
    //   block [0x82899D78..0x82899E3C)
	// 82899D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899D8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899D90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899D94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899D98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899D9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899DA0: 4BA26B99  bl 0x822c0938
	ctx.lr = 0x82899DA4;
	sub_822C0938(ctx, base);
	// 82899DA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899DA8: 41820028  beq 0x82899dd0
	if ctx.cr[0].eq {
	pc = 0x82899DD0; continue 'dispatch;
	}
	// 82899DAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899DB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899DB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899DB8: 392B8CCC  addi r9, r11, -0x7334
	ctx.r[9].s64 = ctx.r[11].s64 + -29492;
	// 82899DBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899DC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899DC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899DC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899DCC: 48000008  b 0x82899dd4
	pc = 0x82899DD4; continue 'dispatch;
	// 82899DD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899DD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899DDC: 409A0044  bne cr6, 0x82899e20
	if !ctx.cr[6].eq {
	pc = 0x82899E20; continue 'dispatch;
	}
	// 82899DE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899DE4: 419A001C  beq cr6, 0x82899e00
	if ctx.cr[6].eq {
	pc = 0x82899E00; continue 'dispatch;
	}
	// 82899DE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899DEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899DF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899DF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899DFC: 4E800421  bctrl
	ctx.lr = 0x82899E00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899E00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899E04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899E0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899E10: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899E14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899E18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899E1C: 4BA261E5  bl 0x822c0000
	ctx.lr = 0x82899E20;
	sub_822C0000(ctx, base);
	// 82899E20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899E24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899E28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899E2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899E30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899E34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899E40 size=196
    let mut pc: u32 = 0x82899E40;
    'dispatch: loop {
        match pc {
            0x82899E40 => {
    //   block [0x82899E40..0x82899F04)
	// 82899E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899E48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899E4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899E50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899E54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899E5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899E60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899E64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899E68: 4BA26AD1  bl 0x822c0938
	ctx.lr = 0x82899E6C;
	sub_822C0938(ctx, base);
	// 82899E6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899E70: 41820028  beq 0x82899e98
	if ctx.cr[0].eq {
	pc = 0x82899E98; continue 'dispatch;
	}
	// 82899E74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899E78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899E7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899E80: 392B8CE0  addi r9, r11, -0x7320
	ctx.r[9].s64 = ctx.r[11].s64 + -29472;
	// 82899E84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899E88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899E8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899E90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899E94: 48000008  b 0x82899e9c
	pc = 0x82899E9C; continue 'dispatch;
	// 82899E98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899E9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899EA4: 409A0044  bne cr6, 0x82899ee8
	if !ctx.cr[6].eq {
	pc = 0x82899EE8; continue 'dispatch;
	}
	// 82899EA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899EAC: 419A001C  beq cr6, 0x82899ec8
	if ctx.cr[6].eq {
	pc = 0x82899EC8; continue 'dispatch;
	}
	// 82899EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899EB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899EBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899EC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899EC4: 4E800421  bctrl
	ctx.lr = 0x82899EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899EC8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899ECC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899ED4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899ED8: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899EDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899EE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899EE4: 4BA2611D  bl 0x822c0000
	ctx.lr = 0x82899EE8;
	sub_822C0000(ctx, base);
	// 82899EE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899EEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899EF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899EFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899F08 size=196
    let mut pc: u32 = 0x82899F08;
    'dispatch: loop {
        match pc {
            0x82899F08 => {
    //   block [0x82899F08..0x82899FCC)
	// 82899F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899F18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899F1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899F20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899F24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899F28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899F2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899F30: 4BA26A09  bl 0x822c0938
	ctx.lr = 0x82899F34;
	sub_822C0938(ctx, base);
	// 82899F34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82899F38: 41820028  beq 0x82899f60
	if ctx.cr[0].eq {
	pc = 0x82899F60; continue 'dispatch;
	}
	// 82899F3C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82899F40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82899F44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82899F48: 392B8CF4  addi r9, r11, -0x730c
	ctx.r[9].s64 = ctx.r[11].s64 + -29452;
	// 82899F4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82899F50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82899F54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82899F58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82899F5C: 48000008  b 0x82899f64
	pc = 0x82899F64; continue 'dispatch;
	// 82899F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899F64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82899F6C: 409A0044  bne cr6, 0x82899fb0
	if !ctx.cr[6].eq {
	pc = 0x82899FB0; continue 'dispatch;
	}
	// 82899F70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82899F74: 419A001C  beq cr6, 0x82899f90
	if ctx.cr[6].eq {
	pc = 0x82899F90; continue 'dispatch;
	}
	// 82899F78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82899F7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82899F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82899F84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82899F88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82899F8C: 4E800421  bctrl
	ctx.lr = 0x82899F90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82899F90: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82899F94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82899F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82899F9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82899FA0: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 82899FA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82899FA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82899FAC: 4BA26055  bl 0x822c0000
	ctx.lr = 0x82899FB0;
	sub_822C0000(ctx, base);
	// 82899FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82899FB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82899FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82899FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82899FC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82899FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82899FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82899FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82899FD0 size=196
    let mut pc: u32 = 0x82899FD0;
    'dispatch: loop {
        match pc {
            0x82899FD0 => {
    //   block [0x82899FD0..0x8289A094)
	// 82899FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82899FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82899FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82899FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82899FE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82899FE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82899FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82899FEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82899FF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82899FF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82899FF8: 4BA26941  bl 0x822c0938
	ctx.lr = 0x82899FFC;
	sub_822C0938(ctx, base);
	// 82899FFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A000: 41820028  beq 0x8289a028
	if ctx.cr[0].eq {
	pc = 0x8289A028; continue 'dispatch;
	}
	// 8289A004: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A008: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A00C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A010: 392B8D08  addi r9, r11, -0x72f8
	ctx.r[9].s64 = ctx.r[11].s64 + -29432;
	// 8289A014: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A018: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A01C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A020: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A024: 48000008  b 0x8289a02c
	pc = 0x8289A02C; continue 'dispatch;
	// 8289A028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A02C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A034: 409A0044  bne cr6, 0x8289a078
	if !ctx.cr[6].eq {
	pc = 0x8289A078; continue 'dispatch;
	}
	// 8289A038: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A03C: 419A001C  beq cr6, 0x8289a058
	if ctx.cr[6].eq {
	pc = 0x8289A058; continue 'dispatch;
	}
	// 8289A040: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A044: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A04C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A054: 4E800421  bctrl
	ctx.lr = 0x8289A058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A058: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A05C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A064: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A068: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A06C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A070: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A074: 4BA25F8D  bl 0x822c0000
	ctx.lr = 0x8289A078;
	sub_822C0000(ctx, base);
	// 8289A078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A07C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A08C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A098 size=196
    let mut pc: u32 = 0x8289A098;
    'dispatch: loop {
        match pc {
            0x8289A098 => {
    //   block [0x8289A098..0x8289A15C)
	// 8289A098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289A0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A0A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A0B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A0B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289A0B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289A0BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A0C0: 4BA26879  bl 0x822c0938
	ctx.lr = 0x8289A0C4;
	sub_822C0938(ctx, base);
	// 8289A0C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A0C8: 41820028  beq 0x8289a0f0
	if ctx.cr[0].eq {
	pc = 0x8289A0F0; continue 'dispatch;
	}
	// 8289A0CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A0D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A0D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A0D8: 392B8D1C  addi r9, r11, -0x72e4
	ctx.r[9].s64 = ctx.r[11].s64 + -29412;
	// 8289A0DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A0E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A0E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A0E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A0EC: 48000008  b 0x8289a0f4
	pc = 0x8289A0F4; continue 'dispatch;
	// 8289A0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A0F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A0FC: 409A0044  bne cr6, 0x8289a140
	if !ctx.cr[6].eq {
	pc = 0x8289A140; continue 'dispatch;
	}
	// 8289A100: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A104: 419A001C  beq cr6, 0x8289a120
	if ctx.cr[6].eq {
	pc = 0x8289A120; continue 'dispatch;
	}
	// 8289A108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A10C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A114: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A11C: 4E800421  bctrl
	ctx.lr = 0x8289A120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A120: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A12C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A130: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A134: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A138: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A13C: 4BA25EC5  bl 0x822c0000
	ctx.lr = 0x8289A140;
	sub_822C0000(ctx, base);
	// 8289A140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A14C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A150: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A160 size=196
    let mut pc: u32 = 0x8289A160;
    'dispatch: loop {
        match pc {
            0x8289A160 => {
    //   block [0x8289A160..0x8289A224)
	// 8289A160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289A16C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A17C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289A180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289A184: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A188: 4BA267B1  bl 0x822c0938
	ctx.lr = 0x8289A18C;
	sub_822C0938(ctx, base);
	// 8289A18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A190: 41820028  beq 0x8289a1b8
	if ctx.cr[0].eq {
	pc = 0x8289A1B8; continue 'dispatch;
	}
	// 8289A194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A198: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A19C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A1A0: 392B8D30  addi r9, r11, -0x72d0
	ctx.r[9].s64 = ctx.r[11].s64 + -29392;
	// 8289A1A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A1A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A1AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A1B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A1B4: 48000008  b 0x8289a1bc
	pc = 0x8289A1BC; continue 'dispatch;
	// 8289A1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A1BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A1C4: 409A0044  bne cr6, 0x8289a208
	if !ctx.cr[6].eq {
	pc = 0x8289A208; continue 'dispatch;
	}
	// 8289A1C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A1CC: 419A001C  beq cr6, 0x8289a1e8
	if ctx.cr[6].eq {
	pc = 0x8289A1E8; continue 'dispatch;
	}
	// 8289A1D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A1DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A1E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A1E4: 4E800421  bctrl
	ctx.lr = 0x8289A1E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A1E8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A1EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A1F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A1F8: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A1FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A200: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A204: 4BA25DFD  bl 0x822c0000
	ctx.lr = 0x8289A208;
	sub_822C0000(ctx, base);
	// 8289A208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A20C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A210: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A214: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A218: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A21C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A228 size=196
    let mut pc: u32 = 0x8289A228;
    'dispatch: loop {
        match pc {
            0x8289A228 => {
    //   block [0x8289A228..0x8289A2EC)
	// 8289A228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289A234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A23C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A244: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289A248: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289A24C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A250: 4BA266E9  bl 0x822c0938
	ctx.lr = 0x8289A254;
	sub_822C0938(ctx, base);
	// 8289A254: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A258: 41820028  beq 0x8289a280
	if ctx.cr[0].eq {
	pc = 0x8289A280; continue 'dispatch;
	}
	// 8289A25C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A260: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A264: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A268: 392B8D44  addi r9, r11, -0x72bc
	ctx.r[9].s64 = ctx.r[11].s64 + -29372;
	// 8289A26C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A274: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A278: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A27C: 48000008  b 0x8289a284
	pc = 0x8289A284; continue 'dispatch;
	// 8289A280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A28C: 409A0044  bne cr6, 0x8289a2d0
	if !ctx.cr[6].eq {
	pc = 0x8289A2D0; continue 'dispatch;
	}
	// 8289A290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A294: 419A001C  beq cr6, 0x8289a2b0
	if ctx.cr[6].eq {
	pc = 0x8289A2B0; continue 'dispatch;
	}
	// 8289A298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A29C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A2A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A2AC: 4E800421  bctrl
	ctx.lr = 0x8289A2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A2B0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A2B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A2BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A2C0: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A2C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A2C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A2CC: 4BA25D35  bl 0x822c0000
	ctx.lr = 0x8289A2D0;
	sub_822C0000(ctx, base);
	// 8289A2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A2D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A2E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A2E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A2E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A2F0 size=196
    let mut pc: u32 = 0x8289A2F0;
    'dispatch: loop {
        match pc {
            0x8289A2F0 => {
    //   block [0x8289A2F0..0x8289A3B4)
	// 8289A2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A2F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289A2FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A304: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A308: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A30C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289A310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289A314: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A318: 4BA26621  bl 0x822c0938
	ctx.lr = 0x8289A31C;
	sub_822C0938(ctx, base);
	// 8289A31C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A320: 41820028  beq 0x8289a348
	if ctx.cr[0].eq {
	pc = 0x8289A348; continue 'dispatch;
	}
	// 8289A324: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A328: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A32C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A330: 392B8D58  addi r9, r11, -0x72a8
	ctx.r[9].s64 = ctx.r[11].s64 + -29352;
	// 8289A334: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A33C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A340: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A344: 48000008  b 0x8289a34c
	pc = 0x8289A34C; continue 'dispatch;
	// 8289A348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A34C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A354: 409A0044  bne cr6, 0x8289a398
	if !ctx.cr[6].eq {
	pc = 0x8289A398; continue 'dispatch;
	}
	// 8289A358: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A35C: 419A001C  beq cr6, 0x8289a378
	if ctx.cr[6].eq {
	pc = 0x8289A378; continue 'dispatch;
	}
	// 8289A360: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A364: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A36C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A374: 4E800421  bctrl
	ctx.lr = 0x8289A378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A378: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A37C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A384: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A388: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A38C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A390: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A394: 4BA25C6D  bl 0x822c0000
	ctx.lr = 0x8289A398;
	sub_822C0000(ctx, base);
	// 8289A398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A39C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A3A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A3A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A3A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A3AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A3B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A3B8 size=196
    let mut pc: u32 = 0x8289A3B8;
    'dispatch: loop {
        match pc {
            0x8289A3B8 => {
    //   block [0x8289A3B8..0x8289A47C)
	// 8289A3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A3C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289A3C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A3C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A3CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A3D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A3D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289A3D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289A3DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A3E0: 4BA26559  bl 0x822c0938
	ctx.lr = 0x8289A3E4;
	sub_822C0938(ctx, base);
	// 8289A3E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A3E8: 41820028  beq 0x8289a410
	if ctx.cr[0].eq {
	pc = 0x8289A410; continue 'dispatch;
	}
	// 8289A3EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A3F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8289A3F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8289A3F8: 392B8D6C  addi r9, r11, -0x7294
	ctx.r[9].s64 = ctx.r[11].s64 + -29332;
	// 8289A3FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289A400: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289A404: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8289A408: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8289A40C: 48000008  b 0x8289a414
	pc = 0x8289A414; continue 'dispatch;
	// 8289A410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289A414: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289A418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289A41C: 409A0044  bne cr6, 0x8289a460
	if !ctx.cr[6].eq {
	pc = 0x8289A460; continue 'dispatch;
	}
	// 8289A420: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8289A424: 419A001C  beq cr6, 0x8289a440
	if ctx.cr[6].eq {
	pc = 0x8289A440; continue 'dispatch;
	}
	// 8289A428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A42C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289A430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A43C: 4E800421  bctrl
	ctx.lr = 0x8289A440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A440: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289A444: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A44C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8289A450: 816BF0A8  lwz r11, -0xf58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3928 as u32) ) } as u64;
	// 8289A454: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8289A458: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8289A45C: 4BA25BA5  bl 0x822c0000
	ctx.lr = 0x8289A460;
	sub_822C0000(ctx, base);
	// 8289A460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289A464: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289A468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A46C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A470: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289A474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A480 size=52
    let mut pc: u32 = 0x8289A480;
    'dispatch: loop {
        match pc {
            0x8289A480 => {
    //   block [0x8289A480..0x8289A4B4)
	// 8289A480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289A488: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289A48C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A490: 808400EC  lwz r4, 0xec(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(236 as u32) ) } as u64;
	// 8289A494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289A498: 4857AB99  bl 0x82e15030
	ctx.lr = 0x8289A49C;
	sub_82E15030(ctx, base);
	// 8289A49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A4A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289A4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289A4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289A4AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289A4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289A4B8 size=240
    let mut pc: u32 = 0x8289A4B8;
    'dispatch: loop {
        match pc {
            0x8289A4B8 => {
    //   block [0x8289A4B8..0x8289A5A8)
	// 8289A4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A4BC: 4890DCB1  bl 0x831a816c
	ctx.lr = 0x8289A4C0;
	sub_831A8130(ctx, base);
	// 8289A4C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A4C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289A4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289A4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A4D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289A4D4: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 8289A4D8: 48559531  bl 0x82df3a08
	ctx.lr = 0x8289A4DC;
	sub_82DF3A08(ctx, base);
	// 8289A4DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A4E0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8289A4E4: 4BF5291D  bl 0x827ece00
	ctx.lr = 0x8289A4E8;
	sub_827ECE00(ctx, base);
	// 8289A4E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289A4EC: 48558DB5  bl 0x82df32a0
	ctx.lr = 0x8289A4F0;
	sub_82DF32A0(ctx, base);
	// 8289A4F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289A4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A4F8: 48558F31  bl 0x82df3428
	ctx.lr = 0x8289A4FC;
	sub_82DF3428(ctx, base);
	// 8289A4FC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289A500: 418200A0  beq 0x8289a5a0
	if ctx.cr[0].eq {
	pc = 0x8289A5A0; continue 'dispatch;
	}
	// 8289A504: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289A508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A50C: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 8289A510: 485594F9  bl 0x82df3a08
	ctx.lr = 0x8289A514;
	sub_82DF3A08(ctx, base);
	// 8289A514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A518: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8289A51C: 4BF51CBD  bl 0x827ec1d8
	ctx.lr = 0x8289A520;
	sub_827EC1D8(ctx, base);
	// 8289A520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A524: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289A528: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289A52C: 4857AB05  bl 0x82e15030
	ctx.lr = 0x8289A530;
	sub_82E15030(ctx, base);
	// 8289A530: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289A534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289A538: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A53C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 8289A540: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289A544: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8289A548: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8289A54C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8289A550: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8289A554: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8289A558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A55C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8289A560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A564: 4E800421  bctrl
	ctx.lr = 0x8289A568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A568: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A56C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289A570: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289A574: 485E1755  bl 0x82e7bcc8
	ctx.lr = 0x8289A578;
	sub_82E7BCC8(ctx, base);
	// 8289A578: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8289A57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289A580: 419A0008  beq cr6, 0x8289a588
	if ctx.cr[6].eq {
	pc = 0x8289A588; continue 'dispatch;
	}
	// 8289A584: 4BA2630D  bl 0x822c0890
	ctx.lr = 0x8289A588;
	sub_822C0890(ctx, base);
	// 8289A588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A58C: 48558E9D  bl 0x82df3428
	ctx.lr = 0x8289A590;
	sub_82DF3428(ctx, base);
	// 8289A590: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8289A594: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8289A598: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289A5A8 size=176
    let mut pc: u32 = 0x8289A5A8;
    'dispatch: loop {
        match pc {
            0x8289A5A8 => {
    //   block [0x8289A5A8..0x8289A658)
	// 8289A5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A5AC: 4890DBB9  bl 0x831a8164
	ctx.lr = 0x8289A5B0;
	sub_831A8130(ctx, base);
	// 8289A5B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A5B4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289A5B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289A5BC: 3B8BB210  addi r28, r11, -0x4df0
	ctx.r[28].s64 = ctx.r[11].s64 + -19952;
	// 8289A5C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289A5C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8289A5C8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 8289A5CC: 3B6B0F7C  addi r27, r11, 0xf7c
	ctx.r[27].s64 = ctx.r[11].s64 + 3964;
	// 8289A5D0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289A5D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8289A5D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289A5DC: 4890E4FD  bl 0x831a8ad8
	ctx.lr = 0x8289A5E0;
	sub_831A8AD8(ctx, base);
	// 8289A5E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8289A5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A5E8: 48559421  bl 0x82df3a08
	ctx.lr = 0x8289A5EC;
	sub_82DF3A08(ctx, base);
	// 8289A5EC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A5F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289A5F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289A5F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A5FC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8289A600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A604: 4E800421  bctrl
	ctx.lr = 0x8289A608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A60C: 48558E1D  bl 0x82df3428
	ctx.lr = 0x8289A610;
	sub_82DF3428(ctx, base);
	// 8289A610: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8289A614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A618: 48006E89  bl 0x828a14a0
	ctx.lr = 0x8289A61C;
	sub_828A14A0(ctx, base);
	// 8289A61C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8289A620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289A624: 419A0008  beq cr6, 0x8289a62c
	if ctx.cr[6].eq {
	pc = 0x8289A62C; continue 'dispatch;
	}
	// 8289A628: 4BA26269  bl 0x822c0890
	ctx.lr = 0x8289A62C;
	sub_822C0890(ctx, base);
	// 8289A62C: 3BFF023C  addi r31, r31, 0x23c
	ctx.r[31].s64 = ctx.r[31].s64 + 572;
	// 8289A630: 397C1658  addi r11, r28, 0x1658
	ctx.r[11].s64 = ctx.r[28].s64 + 5720;
	// 8289A634: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8289A638: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8289A63C: 4198FF94  blt cr6, 0x8289a5d0
	if ctx.cr[6].lt {
	pc = 0x8289A5D0; continue 'dispatch;
	}
	// 8289A640: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289A648: 419A0008  beq cr6, 0x8289a650
	if ctx.cr[6].eq {
	pc = 0x8289A650; continue 'dispatch;
	}
	// 8289A64C: 4BA26245  bl 0x822c0890
	ctx.lr = 0x8289A650;
	sub_822C0890(ctx, base);
	// 8289A650: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8289A654: 4890DB60  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289A658 size=328
    let mut pc: u32 = 0x8289A658;
    'dispatch: loop {
        match pc {
            0x8289A658 => {
    //   block [0x8289A658..0x8289A7A0)
	// 8289A658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A65C: 4890DB09  bl 0x831a8164
	ctx.lr = 0x8289A660;
	sub_831A8130(ctx, base);
	// 8289A660: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289A664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289A668: 488B9F99  bl 0x83154600
	ctx.lr = 0x8289A66C;
	sub_83154600(ctx, base);
	// 8289A66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289A670: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A674: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289A678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A67C: 4E800421  bctrl
	ctx.lr = 0x8289A680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A680: 4BF4FC91  bl 0x827ea310
	ctx.lr = 0x8289A684;
	sub_827EA310(ctx, base);
	// 8289A684: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289A688: 41820028  beq 0x8289a6b0
	if ctx.cr[0].eq {
	pc = 0x8289A6B0; continue 'dispatch;
	}
	// 8289A68C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289A690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A694: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8289A698: 48559371  bl 0x82df3a08
	ctx.lr = 0x8289A69C;
	sub_82DF3A08(ctx, base);
	// 8289A69C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289A6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A6A4: 4BF5509D  bl 0x827ef740
	ctx.lr = 0x8289A6A8;
	sub_827EF740(ctx, base);
	// 8289A6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A6AC: 48558D7D  bl 0x82df3428
	ctx.lr = 0x8289A6B0;
	sub_82DF3428(ctx, base);
	// 8289A6B0: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289A6B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289A6B8: 408200E0  bne 0x8289a798
	if !ctx.cr[0].eq {
	pc = 0x8289A798; continue 'dispatch;
	}
	// 8289A6BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A6C4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289A6C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A6CC: 4E800421  bctrl
	ctx.lr = 0x8289A6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A6D0: 4BF4FC39  bl 0x827ea308
	ctx.lr = 0x8289A6D4;
	sub_827EA308(ctx, base);
	// 8289A6D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289A6D8: C00B0A98  lfs f0, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289A6DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289A6E0: 409900B8  ble cr6, 0x8289a798
	if !ctx.cr[6].gt {
	pc = 0x8289A798; continue 'dispatch;
	}
	// 8289A6E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289A6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A6EC: 388B8DEC  addi r4, r11, -0x7214
	ctx.r[4].s64 = ctx.r[11].s64 + -29204;
	// 8289A6F0: 48559319  bl 0x82df3a08
	ctx.lr = 0x8289A6F4;
	sub_82DF3A08(ctx, base);
	// 8289A6F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A6F8: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8289A6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A700: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8289A704: 839E0060  lwz r28, 0x60(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289A708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A70C: 4E800421  bctrl
	ctx.lr = 0x8289A710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A710: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289A718: 485E1781  bl 0x82e7be98
	ctx.lr = 0x8289A71C;
	sub_82E7BE98(ctx, base);
	// 8289A71C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289A720: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8289A724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289A72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289A730: 4E800421  bctrl
	ctx.lr = 0x8289A734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289A734: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A738: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8289A73C: 485E189D  bl 0x82e7bfd8
	ctx.lr = 0x8289A740;
	sub_82E7BFD8(ctx, base);
	// 8289A740: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A744: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8289A748: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8289A74C: 4BA2A1B5  bl 0x822c4900
	ctx.lr = 0x8289A750;
	sub_822C4900(ctx, base);
	// 8289A750: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8289A754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289A758: 4BF530C1  bl 0x827ed818
	ctx.lr = 0x8289A75C;
	sub_827ED818(ctx, base);
	// 8289A75C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A760: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289A764: 4BC74D65  bl 0x8250f4c8
	ctx.lr = 0x8289A768;
	sub_8250F4C8(ctx, base);
	// 8289A768: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289A76C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289A770: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289A774: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8289A778: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8289A77C: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 8289A780: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289A784: 4BF349CD  bl 0x827cf150
	ctx.lr = 0x8289A788;
	sub_827CF150(ctx, base);
	// 8289A788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289A78C: 48558C9D  bl 0x82df3428
	ctx.lr = 0x8289A790;
	sub_82DF3428(ctx, base);
	// 8289A790: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289A794: 997E006C  stb r11, 0x6c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8289A798: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 8289A79C: 4890DA18  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289A7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289A7A0 size=864
    let mut pc: u32 = 0x8289A7A0;
    'dispatch: loop {
        match pc {
            0x8289A7A0 => {
    //   block [0x8289A7A0..0x8289AB00)
	// 8289A7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289A7A4: 4890D9C1  bl 0x831a8164
	ctx.lr = 0x8289A7A8;
	sub_831A8130(ctx, base);
	// 8289A7A8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8289A7AC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8289A7B0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289AB00 size=284
    let mut pc: u32 = 0x8289AB00;
    'dispatch: loop {
        match pc {
            0x8289AB00 => {
    //   block [0x8289AB00..0x8289AC1C)
	// 8289AB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289AB08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289AB0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289AB10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AB14: 488B9AED  bl 0x83154600
	ctx.lr = 0x8289AB18;
	sub_83154600(ctx, base);
	// 8289AB18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289AB1C: 480051F5  bl 0x8289fd10
	ctx.lr = 0x8289AB20;
	sub_8289FD10(ctx, base);
	// 8289AB20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289AB24: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289AB28: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289AB2C: 41990024  bgt cr6, 0x8289ab50
	if ctx.cr[6].gt {
	pc = 0x8289AB50; continue 'dispatch;
	}
	// 8289AB30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289AB34: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8289AB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AB3C: 48558ECD  bl 0x82df3a08
	ctx.lr = 0x8289AB40;
	sub_82DF3A08(ctx, base);
	// 8289AB40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289AB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AB48: 4BF54BF9  bl 0x827ef740
	ctx.lr = 0x8289AB4C;
	sub_827EF740(ctx, base);
	// 8289AB4C: 480000B0  b 0x8289abfc
	pc = 0x8289ABFC; continue 'dispatch;
	// 8289AB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AB54: 4BF52CC5  bl 0x827ed818
	ctx.lr = 0x8289AB58;
	sub_827ED818(ctx, base);
	// 8289AB58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289AB5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AB60: 4BC74969  bl 0x8250f4c8
	ctx.lr = 0x8289AB64;
	sub_8250F4C8(ctx, base);
	// 8289AB64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289AB6C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8289AB70: 409A0008  bne cr6, 0x8289ab78
	if !ctx.cr[6].eq {
	pc = 0x8289AB78; continue 'dispatch;
	}
	// 8289AB74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289AB78: 4BC6E011  bl 0x82508b88
	ctx.lr = 0x8289AB7C;
	sub_82508B88(ctx, base);
	// 8289AB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AB80: 48005201  bl 0x8289fd80
	ctx.lr = 0x8289AB84;
	sub_8289FD80(ctx, base);
	// 8289AB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289AB88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AB8C: 48557105  bl 0x82df1c90
	ctx.lr = 0x8289AB90;
	sub_82DF1C90(ctx, base);
	// 8289AB90: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289AB94: 41820010  beq 0x8289aba4
	if ctx.cr[0].eq {
	pc = 0x8289ABA4; continue 'dispatch;
	}
	// 8289AB98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289AB9C: 808BFE4C  lwz r4, -0x1b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-436 as u32) ) } as u64;
	// 8289ABA0: 4BFFFF98  b 0x8289ab38
	pc = 0x8289AB38; continue 'dispatch;
	// 8289ABA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289ABA8: 4BFE0CE9  bl 0x8287b890
	ctx.lr = 0x8289ABAC;
	sub_8287B890(ctx, base);
	// 8289ABAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289ABB0: C00BD5B8  lfs f0, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289ABB4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289ABB8: 40980028  bge cr6, 0x8289abe0
	if !ctx.cr[6].lt {
	pc = 0x8289ABE0; continue 'dispatch;
	}
	// 8289ABBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289ABC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289ABC4: 38AB8E50  addi r5, r11, -0x71b0
	ctx.r[5].s64 = ctx.r[11].s64 + -29104;
	// 8289ABC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289ABCC: 4BF550FD  bl 0x827efcc8
	ctx.lr = 0x8289ABD0;
	sub_827EFCC8(ctx, base);
	// 8289ABD0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289ABD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289ABD8: 419A0008  beq cr6, 0x8289abe0
	if ctx.cr[6].eq {
	pc = 0x8289ABE0; continue 'dispatch;
	}
	// 8289ABDC: 4BA25CB5  bl 0x822c0890
	ctx.lr = 0x8289ABE0;
	sub_822C0890(ctx, base);
	// 8289ABE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289ABE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289ABE8: 388B8E40  addi r4, r11, -0x71c0
	ctx.r[4].s64 = ctx.r[11].s64 + -29120;
	// 8289ABEC: 48558E1D  bl 0x82df3a08
	ctx.lr = 0x8289ABF0;
	sub_82DF3A08(ctx, base);
	// 8289ABF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289ABF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289ABF8: 48005111  bl 0x8289fd08
	ctx.lr = 0x8289ABFC;
	sub_8289FD08(ctx, base);
	// 8289ABFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AC00: 48558829  bl 0x82df3428
	ctx.lr = 0x8289AC04;
	sub_82DF3428(ctx, base);
	// 8289AC04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289AC08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289AC0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289AC10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289AC14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289AC18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289AC20 size=284
    let mut pc: u32 = 0x8289AC20;
    'dispatch: loop {
        match pc {
            0x8289AC20 => {
    //   block [0x8289AC20..0x8289AD3C)
	// 8289AC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289AC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289AC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289AC30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AC34: 488B99CD  bl 0x83154600
	ctx.lr = 0x8289AC38;
	sub_83154600(ctx, base);
	// 8289AC38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289AC3C: 480050D5  bl 0x8289fd10
	ctx.lr = 0x8289AC40;
	sub_8289FD10(ctx, base);
	// 8289AC40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289AC44: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289AC48: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289AC4C: 41990024  bgt cr6, 0x8289ac70
	if ctx.cr[6].gt {
	pc = 0x8289AC70; continue 'dispatch;
	}
	// 8289AC50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289AC54: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8289AC58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AC5C: 48558DAD  bl 0x82df3a08
	ctx.lr = 0x8289AC60;
	sub_82DF3A08(ctx, base);
	// 8289AC60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289AC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AC68: 4BF54AD9  bl 0x827ef740
	ctx.lr = 0x8289AC6C;
	sub_827EF740(ctx, base);
	// 8289AC6C: 480000B0  b 0x8289ad1c
	pc = 0x8289AD1C; continue 'dispatch;
	// 8289AC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AC74: 4BF52BA5  bl 0x827ed818
	ctx.lr = 0x8289AC78;
	sub_827ED818(ctx, base);
	// 8289AC78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289AC7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AC80: 4BC74849  bl 0x8250f4c8
	ctx.lr = 0x8289AC84;
	sub_8250F4C8(ctx, base);
	// 8289AC84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289AC8C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8289AC90: 409A0008  bne cr6, 0x8289ac98
	if !ctx.cr[6].eq {
	pc = 0x8289AC98; continue 'dispatch;
	}
	// 8289AC94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289AC98: 4BC6DEF1  bl 0x82508b88
	ctx.lr = 0x8289AC9C;
	sub_82508B88(ctx, base);
	// 8289AC9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289ACA0: 480050E1  bl 0x8289fd80
	ctx.lr = 0x8289ACA4;
	sub_8289FD80(ctx, base);
	// 8289ACA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289ACA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289ACAC: 48556FE5  bl 0x82df1c90
	ctx.lr = 0x8289ACB0;
	sub_82DF1C90(ctx, base);
	// 8289ACB0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289ACB4: 41820010  beq 0x8289acc4
	if ctx.cr[0].eq {
	pc = 0x8289ACC4; continue 'dispatch;
	}
	// 8289ACB8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289ACBC: 808BFE4C  lwz r4, -0x1b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-436 as u32) ) } as u64;
	// 8289ACC0: 4BFFFF98  b 0x8289ac58
	pc = 0x8289AC58; continue 'dispatch;
	// 8289ACC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289ACC8: 4BFE0BC9  bl 0x8287b890
	ctx.lr = 0x8289ACCC;
	sub_8287B890(ctx, base);
	// 8289ACCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289ACD0: C00BD5B8  lfs f0, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289ACD4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289ACD8: 40980028  bge cr6, 0x8289ad00
	if !ctx.cr[6].lt {
	pc = 0x8289AD00; continue 'dispatch;
	}
	// 8289ACDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289ACE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289ACE4: 38AB8E70  addi r5, r11, -0x7190
	ctx.r[5].s64 = ctx.r[11].s64 + -29072;
	// 8289ACE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289ACEC: 4BF54FDD  bl 0x827efcc8
	ctx.lr = 0x8289ACF0;
	sub_827EFCC8(ctx, base);
	// 8289ACF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289ACF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289ACF8: 419A0008  beq cr6, 0x8289ad00
	if ctx.cr[6].eq {
	pc = 0x8289AD00; continue 'dispatch;
	}
	// 8289ACFC: 4BA25B95  bl 0x822c0890
	ctx.lr = 0x8289AD00;
	sub_822C0890(ctx, base);
	// 8289AD00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289AD04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AD08: 388B8E64  addi r4, r11, -0x719c
	ctx.r[4].s64 = ctx.r[11].s64 + -29084;
	// 8289AD0C: 48558CFD  bl 0x82df3a08
	ctx.lr = 0x8289AD10;
	sub_82DF3A08(ctx, base);
	// 8289AD10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289AD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AD18: 48004FF1  bl 0x8289fd08
	ctx.lr = 0x8289AD1C;
	sub_8289FD08(ctx, base);
	// 8289AD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AD20: 48558709  bl 0x82df3428
	ctx.lr = 0x8289AD24;
	sub_82DF3428(ctx, base);
	// 8289AD24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289AD28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289AD2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289AD30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289AD34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289AD38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289AD40 size=72
    let mut pc: u32 = 0x8289AD40;
    'dispatch: loop {
        match pc {
            0x8289AD40 => {
    //   block [0x8289AD40..0x8289AD88)
	// 8289AD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289AD48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AD4C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8289AD50: 419A001C  beq cr6, 0x8289ad6c
	if ctx.cr[6].eq {
	pc = 0x8289AD6C; continue 'dispatch;
	}
	// 8289AD54: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8289AD58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8289AD5C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8289AD60: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289AD64: 4BFFD9D5  bl 0x82898738
	ctx.lr = 0x8289AD68;
	sub_82898738(ctx, base);
	// 8289AD68: 48000010  b 0x8289ad78
	pc = 0x8289AD78; continue 'dispatch;
	// 8289AD6C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289AD70: 396BFAA0  addi r11, r11, -0x560
	ctx.r[11].s64 = ctx.r[11].s64 + -1376;
	// 8289AD74: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289AD78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289AD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289AD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289AD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289AD88 size=72
    let mut pc: u32 = 0x8289AD88;
    'dispatch: loop {
        match pc {
            0x8289AD88 => {
    //   block [0x8289AD88..0x8289ADD0)
	// 8289AD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AD8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289AD90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AD94: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8289AD98: 419A001C  beq cr6, 0x8289adb4
	if ctx.cr[6].eq {
	pc = 0x8289ADB4; continue 'dispatch;
	}
	// 8289AD9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8289ADA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8289ADA4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8289ADA8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289ADAC: 4BFFDA15  bl 0x828987c0
	ctx.lr = 0x8289ADB0;
	sub_828987C0(ctx, base);
	// 8289ADB0: 48000010  b 0x8289adc0
	pc = 0x8289ADC0; continue 'dispatch;
	// 8289ADB4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289ADB8: 396BFB50  addi r11, r11, -0x4b0
	ctx.r[11].s64 = ctx.r[11].s64 + -1200;
	// 8289ADBC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289ADC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289ADC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289ADC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289ADCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289ADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289ADD0 size=368
    let mut pc: u32 = 0x8289ADD0;
    'dispatch: loop {
        match pc {
            0x8289ADD0 => {
    //   block [0x8289ADD0..0x8289AF40)
	// 8289ADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289ADD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289ADD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289ADDC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289ADE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289ADE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289ADE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289ADEC: 388B8EFC  addi r4, r11, -0x7104
	ctx.r[4].s64 = ctx.r[11].s64 + -28932;
	// 8289ADF0: 48558C19  bl 0x82df3a08
	ctx.lr = 0x8289ADF4;
	sub_82DF3A08(ctx, base);
	// 8289ADF4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289ADF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289ADFC: 388B32AC  addi r4, r11, 0x32ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12972;
	// 8289AE00: 48558C09  bl 0x82df3a08
	ctx.lr = 0x8289AE04;
	sub_82DF3A08(ctx, base);
	// 8289AE04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289AE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AE0C: 388B32A0  addi r4, r11, 0x32a0
	ctx.r[4].s64 = ctx.r[11].s64 + 12960;
	// 8289AE10: 48558BF9  bl 0x82df3a08
	ctx.lr = 0x8289AE14;
	sub_82DF3A08(ctx, base);
	// 8289AE14: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 8289AE18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289AE1C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AE20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289AE24: 4BD2DD75  bl 0x825c8b98
	ctx.lr = 0x8289AE28;
	sub_825C8B98(ctx, base);
	// 8289AE28: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289AE2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8289AE30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289AE34: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AE38: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8289AE3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289AE40: 4E800421  bctrl
	ctx.lr = 0x8289AE44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289AE44: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289AE48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AE4C: 419A0008  beq cr6, 0x8289ae54
	if ctx.cr[6].eq {
	pc = 0x8289AE54; continue 'dispatch;
	}
	// 8289AE50: 4BA25A41  bl 0x822c0890
	ctx.lr = 0x8289AE54;
	sub_822C0890(ctx, base);
	// 8289AE54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289AE58: 485585D1  bl 0x82df3428
	ctx.lr = 0x8289AE5C;
	sub_82DF3428(ctx, base);
	// 8289AE5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289AE60: 485585C9  bl 0x82df3428
	ctx.lr = 0x8289AE64;
	sub_82DF3428(ctx, base);
	// 8289AE64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AE68: 485585C1  bl 0x82df3428
	ctx.lr = 0x8289AE6C;
	sub_82DF3428(ctx, base);
	// 8289AE6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289AE70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289AE74: 388B3290  addi r4, r11, 0x3290
	ctx.r[4].s64 = ctx.r[11].s64 + 12944;
	// 8289AE78: 48558B91  bl 0x82df3a08
	ctx.lr = 0x8289AE7C;
	sub_82DF3A08(ctx, base);
	// 8289AE7C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8289AE80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AE84: 388B89A8  addi r4, r11, -0x7658
	ctx.r[4].s64 = ctx.r[11].s64 + -30296;
	// 8289AE88: 48558B81  bl 0x82df3a08
	ctx.lr = 0x8289AE8C;
	sub_82DF3A08(ctx, base);
	// 8289AE8C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289AE90: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8289AE94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8289AE98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8289AE9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AEA0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8289AEA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289AEA8: 4E800421  bctrl
	ctx.lr = 0x8289AEAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289AEAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AEB0: 48558579  bl 0x82df3428
	ctx.lr = 0x8289AEB4;
	sub_82DF3428(ctx, base);
	// 8289AEB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289AEB8: 48558571  bl 0x82df3428
	ctx.lr = 0x8289AEBC;
	sub_82DF3428(ctx, base);
	// 8289AEBC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289AEC0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289AEC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289AEC8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289AECC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8289AED0: 419A0024  beq cr6, 0x8289aef4
	if ctx.cr[6].eq {
	pc = 0x8289AEF4; continue 'dispatch;
	}
	// 8289AED4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289AED8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289AEDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289AEE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289AEE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289AEE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289AEEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289AEF0: 4082FFE8  bne 0x8289aed8
	if !ctx.cr[0].eq {
	pc = 0x8289AED8; continue 'dispatch;
	}
	// 8289AEF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289AEF8: 4BFFF6B1  bl 0x8289a5a8
	ctx.lr = 0x8289AEFC;
	sub_8289A5A8(ctx, base);
	// 8289AEFC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8289AF00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AF04: 419A0008  beq cr6, 0x8289af0c
	if ctx.cr[6].eq {
	pc = 0x8289AF0C; continue 'dispatch;
	}
	// 8289AF08: 4BA25989  bl 0x822c0890
	ctx.lr = 0x8289AF0C;
	sub_822C0890(ctx, base);
	// 8289AF0C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289AF10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AF14: 419A0008  beq cr6, 0x8289af1c
	if ctx.cr[6].eq {
	pc = 0x8289AF1C; continue 'dispatch;
	}
	// 8289AF18: 4BA25979  bl 0x822c0890
	ctx.lr = 0x8289AF1C;
	sub_822C0890(ctx, base);
	// 8289AF1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289AF20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AF24: 419A0008  beq cr6, 0x8289af2c
	if ctx.cr[6].eq {
	pc = 0x8289AF2C; continue 'dispatch;
	}
	// 8289AF28: 4BA25969  bl 0x822c0890
	ctx.lr = 0x8289AF2C;
	sub_822C0890(ctx, base);
	// 8289AF2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8289AF30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289AF34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289AF38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289AF3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289AF40 size=144
    let mut pc: u32 = 0x8289AF40;
    'dispatch: loop {
        match pc {
            0x8289AF40 => {
    //   block [0x8289AF40..0x8289AFD0)
	// 8289AF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AF44: 4890D225  bl 0x831a8168
	ctx.lr = 0x8289AF48;
	sub_831A8130(ctx, base);
	// 8289AF48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AF4C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8289AF50: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 8289AF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289AF58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8289AF5C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8289AF60: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AF64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AF68: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8289AF6C: 419A0008  beq cr6, 0x8289af74
	if ctx.cr[6].eq {
	pc = 0x8289AF74; continue 'dispatch;
	}
	// 8289AF70: 4BA4D2D9  bl 0x822e8248
	ctx.lr = 0x8289AF74;
	sub_822E8248(ctx, base);
	// 8289AF74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289AF78: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8289AF7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289AF80: 4857A0B1  bl 0x82e15030
	ctx.lr = 0x8289AF84;
	sub_82E15030(ctx, base);
	// 8289AF84: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8289AF88: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8289AF8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289AF90: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 8289AF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AF98: 4BC78161  bl 0x825130f8
	ctx.lr = 0x8289AF9C;
	sub_825130F8(ctx, base);
	// 8289AF9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289AFA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289AFA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289AFA8: 419A000C  beq cr6, 0x8289afb4
	if ctx.cr[6].eq {
	pc = 0x8289AFB4; continue 'dispatch;
	}
	// 8289AFAC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8289AFB0: 4BA4D2B9  bl 0x822e8268
	ctx.lr = 0x8289AFB4;
	sub_822E8268(ctx, base);
	// 8289AFB4: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289AFB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289AFBC: 419A0008  beq cr6, 0x8289afc4
	if ctx.cr[6].eq {
	pc = 0x8289AFC4; continue 'dispatch;
	}
	// 8289AFC0: 4BA4D2A9  bl 0x822e8268
	ctx.lr = 0x8289AFC4;
	sub_822E8268(ctx, base);
	// 8289AFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289AFC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8289AFCC: 4890D1EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289AFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289AFD0 size=80
    let mut pc: u32 = 0x8289AFD0;
    'dispatch: loop {
        match pc {
            0x8289AFD0 => {
    //   block [0x8289AFD0..0x8289B020)
	// 8289AFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289AFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289AFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289AFDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289AFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289AFE4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8289AFE8: 419A0014  beq cr6, 0x8289affc
	if ctx.cr[6].eq {
	pc = 0x8289AFFC; continue 'dispatch;
	}
	// 8289AFEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289AFF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289AFF4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8289AFF8: 48000014  b 0x8289b00c
	pc = 0x8289B00C; continue 'dispatch;
	// 8289AFFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B000: 38AB8F04  addi r5, r11, -0x70fc
	ctx.r[5].s64 = ctx.r[11].s64 + -28924;
	// 8289B004: 4BC77175  bl 0x82512178
	ctx.lr = 0x8289B008;
	sub_82512178(ctx, base);
	// 8289B008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B00C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289B010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289B014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289B018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289B01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289B020 size=1316
    let mut pc: u32 = 0x8289B020;
    'dispatch: loop {
        match pc {
            0x8289B020 => {
    //   block [0x8289B020..0x8289B544)
	// 8289B020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B024: 4890D13D  bl 0x831a8160
	ctx.lr = 0x8289B028;
	sub_831A8130(ctx, base);
	// 8289B028: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 8289B02C: 4890DA41  bl 0x831a8a6c
	ctx.lr = 0x8289B030;
	sub_831A8A40(ctx, base);
	// 8289B030: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B034: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B038: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289B03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B040: 388B8F7C  addi r4, r11, -0x7084
	ctx.r[4].s64 = ctx.r[11].s64 + -28804;
	// 8289B044: 485589C5  bl 0x82df3a08
	ctx.lr = 0x8289B048;
	sub_82DF3A08(ctx, base);
	// 8289B048: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289B04C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289B050: 809D00EC  lwz r4, 0xec(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(236 as u32) ) } as u64;
	// 8289B054: 48579FDD  bl 0x82e15030
	ctx.lr = 0x8289B058;
	sub_82E15030(ctx, base);
	// 8289B058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B05C: 485583CD  bl 0x82df3428
	ctx.lr = 0x8289B060;
	sub_82DF3428(ctx, base);
	// 8289B060: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289B064: 485776AD  bl 0x82e12710
	ctx.lr = 0x8289B068;
	sub_82E12710(ctx, base);
	// 8289B068: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289B06C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289B070: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289B074: 3BE100E0  addi r31, r1, 0xe0
	ctx.r[31].s64 = ctx.r[1].s64 + 224;
	// 8289B078: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289B07C: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289B080: D3E100E0  stfs f31, 0xe0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8289B084: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8289B088: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8289B08C: D3C100EC  stfs f30, 0xec(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8289B090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289B094: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8289B098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289B09C: 4E800421  bctrl
	ctx.lr = 0x8289B0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289B0A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289B0A4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8289B0A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289B0AC: 485E0C1D  bl 0x82e7bcc8
	ctx.lr = 0x8289B0B0;
	sub_82E7BCC8(ctx, base);
	// 8289B0B0: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 8289B0B4: 394003D0  li r10, 0x3d0
	ctx.r[10].s64 = 976;
	// 8289B0B8: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 8289B0BC: 39010150  addi r8, r1, 0x150
	ctx.r[8].s64 = ctx.r[1].s64 + 336;
	// 8289B0C0: 39292770  addi r9, r9, 0x2770
	ctx.r[9].s64 = ctx.r[9].s64 + 10096;
	// 8289B0C4: 13A058C7  vcmpequd (lvx128) v29, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8289B0C8: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 8289B0CC: 13DD50C7  vcmpequd (lvx128) v30, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8289B0D0: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289B548 size=388
    let mut pc: u32 = 0x8289B548;
    'dispatch: loop {
        match pc {
            0x8289B548 => {
    //   block [0x8289B548..0x8289B6CC)
	// 8289B548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B54C: 4890CC1D  bl 0x831a8168
	ctx.lr = 0x8289B550;
	sub_831A8130(ctx, base);
	// 8289B550: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B554: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289B558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289B55C: 3B9E00FC  addi r28, r30, 0xfc
	ctx.r[28].s64 = ctx.r[30].s64 + 252;
	// 8289B560: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289B564: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289B568: 485BEFB9  bl 0x82e5a520
	ctx.lr = 0x8289B56C;
	sub_82E5A520(ctx, base);
	// 8289B56C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289B570: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8289B574: 419A0024  beq cr6, 0x8289b598
	if ctx.cr[6].eq {
	pc = 0x8289B598; continue 'dispatch;
	}
	// 8289B578: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8289B57C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289B580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289B584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289B588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289B58C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289B590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289B594: 4082FFE8  bne 0x8289b57c
	if !ctx.cr[0].eq {
	pc = 0x8289B57C; continue 'dispatch;
	}
	// 8289B598: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8289B59C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289B5A0: 419A0008  beq cr6, 0x8289b5a8
	if ctx.cr[6].eq {
	pc = 0x8289B5A8; continue 'dispatch;
	}
	// 8289B5A4: 4BA252ED  bl 0x822c0890
	ctx.lr = 0x8289B5A8;
	sub_822C0890(ctx, base);
	// 8289B5A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B5AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B5B0: 388B8FAC  addi r4, r11, -0x7054
	ctx.r[4].s64 = ctx.r[11].s64 + -28756;
	// 8289B5B4: 48558455  bl 0x82df3a08
	ctx.lr = 0x8289B5B8;
	sub_82DF3A08(ctx, base);
	// 8289B5B8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8289B5BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289B5C0: 3B8B7688  addi r28, r11, 0x7688
	ctx.r[28].s64 = ctx.r[11].s64 + 30344;
	// 8289B5C4: 485BF10D  bl 0x82e5a6d0
	ctx.lr = 0x8289B5C8;
	sub_82E5A6D0(ctx, base);
	// 8289B5C8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 8289B5CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8289B5D0: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 8289B5D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B5D8: 485586C9  bl 0x82df3ca0
	ctx.lr = 0x8289B5DC;
	sub_82DF3CA0(ctx, base);
	// 8289B5DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289B5E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289B5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B5E8: 48558711  bl 0x82df3cf8
	ctx.lr = 0x8289B5EC;
	sub_82DF3CF8(ctx, base);
	// 8289B5EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289B5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B5F4: 485582BD  bl 0x82df38b0
	ctx.lr = 0x8289B5F8;
	sub_82DF38B0(ctx, base);
	// 8289B5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B5FC: 48557E2D  bl 0x82df3428
	ctx.lr = 0x8289B600;
	sub_82DF3428(ctx, base);
	// 8289B600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B604: 48557E25  bl 0x82df3428
	ctx.lr = 0x8289B608;
	sub_82DF3428(ctx, base);
	// 8289B608: 807E0400  lwz r3, 0x400(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289B60C: 4BF4EC9D  bl 0x827ea2a8
	ctx.lr = 0x8289B610;
	sub_827EA2A8(ctx, base);
	// 8289B610: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B614: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8289B618: 388B8FA0  addi r4, r11, -0x7060
	ctx.r[4].s64 = ctx.r[11].s64 + -28768;
	// 8289B61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B620: 48558681  bl 0x82df3ca0
	ctx.lr = 0x8289B624;
	sub_82DF3CA0(ctx, base);
	// 8289B624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289B628: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B62C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289B630: 485586C9  bl 0x82df3cf8
	ctx.lr = 0x8289B634;
	sub_82DF3CF8(ctx, base);
	// 8289B634: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289B638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B63C: 48558275  bl 0x82df38b0
	ctx.lr = 0x8289B640;
	sub_82DF38B0(ctx, base);
	// 8289B640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B644: 48557DE5  bl 0x82df3428
	ctx.lr = 0x8289B648;
	sub_82DF3428(ctx, base);
	// 8289B648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B64C: 48557DDD  bl 0x82df3428
	ctx.lr = 0x8289B650;
	sub_82DF3428(ctx, base);
	// 8289B650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B654: 4817802D  bl 0x82a13680
	ctx.lr = 0x8289B658;
	sub_82A13680(ctx, base);
	// 8289B658: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289B65C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289B660: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289B664: 388A8F80  addi r4, r10, -0x7080
	ctx.r[4].s64 = ctx.r[10].s64 + -28800;
	// 8289B668: C06B0008  lfs f3, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8289B66C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8289B670: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289B674: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 8289B678: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 8289B67C: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 8289B680: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 8289B684: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 8289B688: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 8289B68C: 4890D44D  bl 0x831a8ad8
	ctx.lr = 0x8289B690;
	sub_831A8AD8(ctx, base);
	// 8289B690: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8289B694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B698: 48558371  bl 0x82df3a08
	ctx.lr = 0x8289B69C;
	sub_82DF3A08(ctx, base);
	// 8289B69C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289B6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B6A4: 4855820D  bl 0x82df38b0
	ctx.lr = 0x8289B6A8;
	sub_82DF38B0(ctx, base);
	// 8289B6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289B6AC: 48557D7D  bl 0x82df3428
	ctx.lr = 0x8289B6B0;
	sub_82DF3428(ctx, base);
	// 8289B6B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8289B6B4: 419A000C  beq cr6, 0x8289b6c0
	if ctx.cr[6].eq {
	pc = 0x8289B6C0; continue 'dispatch;
	}
	// 8289B6B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289B6BC: 4BA251D5  bl 0x822c0890
	ctx.lr = 0x8289B6C0;
	sub_822C0890(ctx, base);
	// 8289B6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B6C4: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 8289B6C8: 4890CAF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B6D0 size=112
    let mut pc: u32 = 0x8289B6D0;
    'dispatch: loop {
        match pc {
            0x8289B6D0 => {
    //   block [0x8289B6D0..0x8289B740)
	// 8289B6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289B6D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289B6DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289B6E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B6E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289B6E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289B6EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8289B6F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B6F4: 4BAB6EBD  bl 0x823525b0
	ctx.lr = 0x8289B6F8;
	sub_823525B0(ctx, base);
	// 8289B6F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8289B6FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289B700: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B704: 4BA248FD  bl 0x822c0000
	ctx.lr = 0x8289B708;
	sub_822C0000(ctx, base);
	// 8289B708: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289B70C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8289B710: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B714: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289B718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289B71C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289B720: 419A0008  beq cr6, 0x8289b728
	if ctx.cr[6].eq {
	pc = 0x8289B728; continue 'dispatch;
	}
	// 8289B724: 4BA2516D  bl 0x822c0890
	ctx.lr = 0x8289B728;
	sub_822C0890(ctx, base);
	// 8289B728: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289B730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289B734: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289B738: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289B73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B740 size=112
    let mut pc: u32 = 0x8289B740;
    'dispatch: loop {
        match pc {
            0x8289B740 => {
    //   block [0x8289B740..0x8289B7B0)
	// 8289B740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289B748: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289B74C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289B750: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B754: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289B758: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289B75C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8289B760: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B764: 4BFFDD95  bl 0x828994f8
	ctx.lr = 0x8289B768;
	sub_828994F8(ctx, base);
	// 8289B768: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8289B76C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289B770: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B774: 4BA2488D  bl 0x822c0000
	ctx.lr = 0x8289B778;
	sub_822C0000(ctx, base);
	// 8289B778: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289B77C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8289B780: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B784: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289B788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289B78C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289B790: 419A0008  beq cr6, 0x8289b798
	if ctx.cr[6].eq {
	pc = 0x8289B798; continue 'dispatch;
	}
	// 8289B794: 4BA250FD  bl 0x822c0890
	ctx.lr = 0x8289B798;
	sub_822C0890(ctx, base);
	// 8289B798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289B7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289B7A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289B7A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289B7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B7B0 size=124
    let mut pc: u32 = 0x8289B7B0;
    'dispatch: loop {
        match pc {
            0x8289B7B0 => {
    //   block [0x8289B7B0..0x8289B82C)
	// 8289B7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B7B4: 4890C9B9  bl 0x831a816c
	ctx.lr = 0x8289B7B8;
	sub_831A8130(ctx, base);
	// 8289B7B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B7BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289B7C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289B7C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289B7C8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8289B7CC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8289B7D0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8289B7D4: 48556C15  bl 0x82df23e8
	ctx.lr = 0x8289B7D8;
	sub_82DF23E8(ctx, base);
	// 8289B7D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289B7DC: 4182001C  beq 0x8289b7f8
	if ctx.cr[0].eq {
	pc = 0x8289B7F8; continue 'dispatch;
	}
	// 8289B7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B7E4: 485BDEBD  bl 0x82e596a0
	ctx.lr = 0x8289B7E8;
	sub_82E596A0(ctx, base);
	// 8289B7E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B7EC: 396B8AA8  addi r11, r11, -0x7558
	ctx.r[11].s64 = ctx.r[11].s64 + -30040;
	// 8289B7F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B7F4: 48000008  b 0x8289b7fc
	pc = 0x8289B7FC; continue 'dispatch;
	// 8289B7F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289B7FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289B800: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289B804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B80C: 4BFFDDB5  bl 0x828995c0
	ctx.lr = 0x8289B810;
	sub_828995C0(ctx, base);
	// 8289B810: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289B814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B81C: 4BA247E5  bl 0x822c0000
	ctx.lr = 0x8289B820;
	sub_822C0000(ctx, base);
	// 8289B820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289B824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B828: 4890C994  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B830 size=124
    let mut pc: u32 = 0x8289B830;
    'dispatch: loop {
        match pc {
            0x8289B830 => {
    //   block [0x8289B830..0x8289B8AC)
	// 8289B830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B834: 4890C939  bl 0x831a816c
	ctx.lr = 0x8289B838;
	sub_831A8130(ctx, base);
	// 8289B838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B83C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289B840: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289B844: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289B848: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8289B84C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8289B850: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8289B854: 48556B95  bl 0x82df23e8
	ctx.lr = 0x8289B858;
	sub_82DF23E8(ctx, base);
	// 8289B858: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289B85C: 4182001C  beq 0x8289b878
	if ctx.cr[0].eq {
	pc = 0x8289B878; continue 'dispatch;
	}
	// 8289B860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B864: 485BDE3D  bl 0x82e596a0
	ctx.lr = 0x8289B868;
	sub_82E596A0(ctx, base);
	// 8289B868: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B86C: 396B8AB0  addi r11, r11, -0x7550
	ctx.r[11].s64 = ctx.r[11].s64 + -30032;
	// 8289B870: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B874: 48000008  b 0x8289b87c
	pc = 0x8289B87C; continue 'dispatch;
	// 8289B878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289B87C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289B880: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289B884: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B88C: 4BFFDDFD  bl 0x82899688
	ctx.lr = 0x8289B890;
	sub_82899688(ctx, base);
	// 8289B890: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289B894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B89C: 4BA24765  bl 0x822c0000
	ctx.lr = 0x8289B8A0;
	sub_822C0000(ctx, base);
	// 8289B8A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289B8A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B8A8: 4890C914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B8B0 size=112
    let mut pc: u32 = 0x8289B8B0;
    'dispatch: loop {
        match pc {
            0x8289B8B0 => {
    //   block [0x8289B8B0..0x8289B920)
	// 8289B8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289B8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289B8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289B8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B8C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289B8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289B8CC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8289B8D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B8D4: 4BFFDE7D  bl 0x82899750
	ctx.lr = 0x8289B8D8;
	sub_82899750(ctx, base);
	// 8289B8D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8289B8DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289B8E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289B8E4: 4BA2471D  bl 0x822c0000
	ctx.lr = 0x8289B8E8;
	sub_822C0000(ctx, base);
	// 8289B8E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289B8EC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8289B8F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B8F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289B8F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289B8FC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8289B900: 419A0008  beq cr6, 0x8289b908
	if ctx.cr[6].eq {
	pc = 0x8289B908; continue 'dispatch;
	}
	// 8289B904: 4BA24F8D  bl 0x822c0890
	ctx.lr = 0x8289B908;
	sub_822C0890(ctx, base);
	// 8289B908: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B90C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289B910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289B914: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289B918: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289B91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B920 size=120
    let mut pc: u32 = 0x8289B920;
    'dispatch: loop {
        match pc {
            0x8289B920 => {
    //   block [0x8289B920..0x8289B998)
	// 8289B920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B924: 4890C849  bl 0x831a816c
	ctx.lr = 0x8289B928;
	sub_831A8130(ctx, base);
	// 8289B928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B92C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289B930: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289B934: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289B938: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289B93C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8289B940: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8289B944: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8289B948: 48556AA1  bl 0x82df23e8
	ctx.lr = 0x8289B94C;
	sub_82DF23E8(ctx, base);
	// 8289B94C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289B950: 41820014  beq 0x8289b964
	if ctx.cr[0].eq {
	pc = 0x8289B964; continue 'dispatch;
	}
	// 8289B954: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289B958: 480055A1  bl 0x828a0ef8
	ctx.lr = 0x8289B95C;
	sub_828A0EF8(ctx, base);
	// 8289B95C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289B960: 48000008  b 0x8289b968
	pc = 0x8289B968; continue 'dispatch;
	// 8289B964: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289B968: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289B96C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289B970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B978: 4BFFDE89  bl 0x82899800
	ctx.lr = 0x8289B97C;
	sub_82899800(ctx, base);
	// 8289B97C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289B980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B988: 4BA24679  bl 0x822c0000
	ctx.lr = 0x8289B98C;
	sub_822C0000(ctx, base);
	// 8289B98C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289B990: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289B994: 4890C828  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289B998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289B998 size=124
    let mut pc: u32 = 0x8289B998;
    'dispatch: loop {
        match pc {
            0x8289B998 => {
    //   block [0x8289B998..0x8289BA14)
	// 8289B998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289B99C: 4890C7D1  bl 0x831a816c
	ctx.lr = 0x8289B9A0;
	sub_831A8130(ctx, base);
	// 8289B9A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289B9A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289B9A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289B9AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289B9B0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8289B9B4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8289B9B8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8289B9BC: 48556A2D  bl 0x82df23e8
	ctx.lr = 0x8289B9C0;
	sub_82DF23E8(ctx, base);
	// 8289B9C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289B9C4: 4182001C  beq 0x8289b9e0
	if ctx.cr[0].eq {
	pc = 0x8289B9E0; continue 'dispatch;
	}
	// 8289B9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289B9CC: 485BDCB5  bl 0x82e59680
	ctx.lr = 0x8289B9D0;
	sub_82E59680(ctx, base);
	// 8289B9D0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289B9D4: 396B8AB8  addi r11, r11, -0x7548
	ctx.r[11].s64 = ctx.r[11].s64 + -30024;
	// 8289B9D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289B9DC: 48000008  b 0x8289b9e4
	pc = 0x8289B9E4; continue 'dispatch;
	// 8289B9E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289B9E4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289B9E8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289B9EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289B9F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289B9F4: 4BFFDED5  bl 0x828998c8
	ctx.lr = 0x8289B9F8;
	sub_828998C8(ctx, base);
	// 8289B9F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289B9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BA04: 4BA245FD  bl 0x822c0000
	ctx.lr = 0x8289BA08;
	sub_822C0000(ctx, base);
	// 8289BA08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BA0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BA10: 4890C7AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BA18 size=124
    let mut pc: u32 = 0x8289BA18;
    'dispatch: loop {
        match pc {
            0x8289BA18 => {
    //   block [0x8289BA18..0x8289BA94)
	// 8289BA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BA1C: 4890C751  bl 0x831a816c
	ctx.lr = 0x8289BA20;
	sub_831A8130(ctx, base);
	// 8289BA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BA24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BA28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BA2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BA30: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BA34: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BA38: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8289BA3C: 485569AD  bl 0x82df23e8
	ctx.lr = 0x8289BA40;
	sub_82DF23E8(ctx, base);
	// 8289BA40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BA44: 4182001C  beq 0x8289ba60
	if ctx.cr[0].eq {
	pc = 0x8289BA60; continue 'dispatch;
	}
	// 8289BA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BA4C: 485C0EDD  bl 0x82e5c928
	ctx.lr = 0x8289BA50;
	sub_82E5C928(ctx, base);
	// 8289BA50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BA54: 396B8AC0  addi r11, r11, -0x7540
	ctx.r[11].s64 = ctx.r[11].s64 + -30016;
	// 8289BA58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BA5C: 48000008  b 0x8289ba64
	pc = 0x8289BA64; continue 'dispatch;
	// 8289BA60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BA64: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BA68: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BA6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BA74: 4BFFDF1D  bl 0x82899990
	ctx.lr = 0x8289BA78;
	sub_82899990(ctx, base);
	// 8289BA78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BA7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BA80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BA84: 4BA2457D  bl 0x822c0000
	ctx.lr = 0x8289BA88;
	sub_822C0000(ctx, base);
	// 8289BA88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BA8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BA90: 4890C72C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BA98 size=112
    let mut pc: u32 = 0x8289BA98;
    'dispatch: loop {
        match pc {
            0x8289BA98 => {
    //   block [0x8289BA98..0x8289BB08)
	// 8289BA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BA9C: 4890C6D1  bl 0x831a816c
	ctx.lr = 0x8289BAA0;
	sub_831A8130(ctx, base);
	// 8289BAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BAA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BAA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BAAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BAB0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BAB4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BAB8: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8289BABC: 4855692D  bl 0x82df23e8
	ctx.lr = 0x8289BAC0;
	sub_82DF23E8(ctx, base);
	// 8289BAC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289BAC4: 41820010  beq 0x8289bad4
	if ctx.cr[0].eq {
	pc = 0x8289BAD4; continue 'dispatch;
	}
	// 8289BAC8: 4BFFD361  bl 0x82898e28
	ctx.lr = 0x8289BACC;
	sub_82898E28(ctx, base);
	// 8289BACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289BAD0: 48000008  b 0x8289bad8
	pc = 0x8289BAD8; continue 'dispatch;
	// 8289BAD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BAD8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BADC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BAE8: 4BFFDF71  bl 0x82899a58
	ctx.lr = 0x8289BAEC;
	sub_82899A58(ctx, base);
	// 8289BAEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BAF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BAF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BAF8: 4BA24509  bl 0x822c0000
	ctx.lr = 0x8289BAFC;
	sub_822C0000(ctx, base);
	// 8289BAFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BB00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BB04: 4890C6B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BB08 size=124
    let mut pc: u32 = 0x8289BB08;
    'dispatch: loop {
        match pc {
            0x8289BB08 => {
    //   block [0x8289BB08..0x8289BB84)
	// 8289BB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BB0C: 4890C661  bl 0x831a816c
	ctx.lr = 0x8289BB10;
	sub_831A8130(ctx, base);
	// 8289BB10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BB14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BB18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BB1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BB20: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BB24: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BB28: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289BB2C: 485568BD  bl 0x82df23e8
	ctx.lr = 0x8289BB30;
	sub_82DF23E8(ctx, base);
	// 8289BB30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BB34: 4182001C  beq 0x8289bb50
	if ctx.cr[0].eq {
	pc = 0x8289BB50; continue 'dispatch;
	}
	// 8289BB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BB3C: 485C0DED  bl 0x82e5c928
	ctx.lr = 0x8289BB40;
	sub_82E5C928(ctx, base);
	// 8289BB40: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BB44: 396B8AE8  addi r11, r11, -0x7518
	ctx.r[11].s64 = ctx.r[11].s64 + -29976;
	// 8289BB48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BB4C: 48000008  b 0x8289bb54
	pc = 0x8289BB54; continue 'dispatch;
	// 8289BB50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BB54: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BB58: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BB64: 4BFFDFBD  bl 0x82899b20
	ctx.lr = 0x8289BB68;
	sub_82899B20(ctx, base);
	// 8289BB68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BB74: 4BA2448D  bl 0x822c0000
	ctx.lr = 0x8289BB78;
	sub_822C0000(ctx, base);
	// 8289BB78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BB7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BB80: 4890C63C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BB88 size=136
    let mut pc: u32 = 0x8289BB88;
    'dispatch: loop {
        match pc {
            0x8289BB88 => {
    //   block [0x8289BB88..0x8289BC10)
	// 8289BB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BB8C: 4890C5E1  bl 0x831a816c
	ctx.lr = 0x8289BB90;
	sub_831A8130(ctx, base);
	// 8289BB90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BB94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BB98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BB9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BBA0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BBA4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BBA8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 8289BBAC: 4855683D  bl 0x82df23e8
	ctx.lr = 0x8289BBB0;
	sub_82DF23E8(ctx, base);
	// 8289BBB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BBB4: 41820028  beq 0x8289bbdc
	if ctx.cr[0].eq {
	pc = 0x8289BBDC; continue 'dispatch;
	}
	// 8289BBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BBBC: 485C0D6D  bl 0x82e5c928
	ctx.lr = 0x8289BBC0;
	sub_82E5C928(ctx, base);
	// 8289BBC0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289BBC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289BBC8: 394A8E88  addi r10, r10, -0x7178
	ctx.r[10].s64 = ctx.r[10].s64 + -29048;
	// 8289BBCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8289BBD0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289BBD4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289BBD8: 48000008  b 0x8289bbe0
	pc = 0x8289BBE0; continue 'dispatch;
	// 8289BBDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BBE0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BBE4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BBE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BBEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BBF0: 4BFFDFF9  bl 0x82899be8
	ctx.lr = 0x8289BBF4;
	sub_82899BE8(ctx, base);
	// 8289BBF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BBF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BBFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BC00: 4BA24401  bl 0x822c0000
	ctx.lr = 0x8289BC04;
	sub_822C0000(ctx, base);
	// 8289BC04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BC08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BC0C: 4890C5B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BC10 size=136
    let mut pc: u32 = 0x8289BC10;
    'dispatch: loop {
        match pc {
            0x8289BC10 => {
    //   block [0x8289BC10..0x8289BC98)
	// 8289BC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BC14: 4890C559  bl 0x831a816c
	ctx.lr = 0x8289BC18;
	sub_831A8130(ctx, base);
	// 8289BC18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BC1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BC20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BC24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BC28: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BC2C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BC30: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8289BC34: 485567B5  bl 0x82df23e8
	ctx.lr = 0x8289BC38;
	sub_82DF23E8(ctx, base);
	// 8289BC38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BC3C: 41820028  beq 0x8289bc64
	if ctx.cr[0].eq {
	pc = 0x8289BC64; continue 'dispatch;
	}
	// 8289BC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BC44: 485C0CE5  bl 0x82e5c928
	ctx.lr = 0x8289BC48;
	sub_82E5C928(ctx, base);
	// 8289BC48: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289BC4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289BC50: 394A8EB0  addi r10, r10, -0x7150
	ctx.r[10].s64 = ctx.r[10].s64 + -29008;
	// 8289BC54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8289BC58: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289BC5C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289BC60: 48000008  b 0x8289bc68
	pc = 0x8289BC68; continue 'dispatch;
	// 8289BC64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BC68: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BC6C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BC78: 4BFFE039  bl 0x82899cb0
	ctx.lr = 0x8289BC7C;
	sub_82899CB0(ctx, base);
	// 8289BC7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BC80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BC84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BC88: 4BA24379  bl 0x822c0000
	ctx.lr = 0x8289BC8C;
	sub_822C0000(ctx, base);
	// 8289BC8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BC90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BC94: 4890C528  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BC98 size=136
    let mut pc: u32 = 0x8289BC98;
    'dispatch: loop {
        match pc {
            0x8289BC98 => {
    //   block [0x8289BC98..0x8289BD20)
	// 8289BC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BC9C: 4890C4D1  bl 0x831a816c
	ctx.lr = 0x8289BCA0;
	sub_831A8130(ctx, base);
	// 8289BCA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BCA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BCA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BCAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BCB0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BCB4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BCB8: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8289BCBC: 4855672D  bl 0x82df23e8
	ctx.lr = 0x8289BCC0;
	sub_82DF23E8(ctx, base);
	// 8289BCC0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BCC4: 41820028  beq 0x8289bcec
	if ctx.cr[0].eq {
	pc = 0x8289BCEC; continue 'dispatch;
	}
	// 8289BCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BCCC: 485C0C5D  bl 0x82e5c928
	ctx.lr = 0x8289BCD0;
	sub_82E5C928(ctx, base);
	// 8289BCD0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289BCD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289BCD8: 394A8ED8  addi r10, r10, -0x7128
	ctx.r[10].s64 = ctx.r[10].s64 + -28968;
	// 8289BCDC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8289BCE0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289BCE4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289BCE8: 48000008  b 0x8289bcf0
	pc = 0x8289BCF0; continue 'dispatch;
	// 8289BCEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BCF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BCF4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BCFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BD00: 4BFFE079  bl 0x82899d78
	ctx.lr = 0x8289BD04;
	sub_82899D78(ctx, base);
	// 8289BD04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BD08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BD0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BD10: 4BA242F1  bl 0x822c0000
	ctx.lr = 0x8289BD14;
	sub_822C0000(ctx, base);
	// 8289BD14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BD18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BD1C: 4890C4A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BD20 size=124
    let mut pc: u32 = 0x8289BD20;
    'dispatch: loop {
        match pc {
            0x8289BD20 => {
    //   block [0x8289BD20..0x8289BD9C)
	// 8289BD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BD24: 4890C449  bl 0x831a816c
	ctx.lr = 0x8289BD28;
	sub_831A8130(ctx, base);
	// 8289BD28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BD2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BD30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BD34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BD38: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BD3C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BD40: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289BD44: 485566A5  bl 0x82df23e8
	ctx.lr = 0x8289BD48;
	sub_82DF23E8(ctx, base);
	// 8289BD48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BD4C: 4182001C  beq 0x8289bd68
	if ctx.cr[0].eq {
	pc = 0x8289BD68; continue 'dispatch;
	}
	// 8289BD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BD54: 485C0BD5  bl 0x82e5c928
	ctx.lr = 0x8289BD58;
	sub_82E5C928(ctx, base);
	// 8289BD58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BD5C: 396B8B10  addi r11, r11, -0x74f0
	ctx.r[11].s64 = ctx.r[11].s64 + -29936;
	// 8289BD60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BD64: 48000008  b 0x8289bd6c
	pc = 0x8289BD6C; continue 'dispatch;
	// 8289BD68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BD6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BD70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BD74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BD78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BD7C: 4BFFE0C5  bl 0x82899e40
	ctx.lr = 0x8289BD80;
	sub_82899E40(ctx, base);
	// 8289BD80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BD84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BD88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BD8C: 4BA24275  bl 0x822c0000
	ctx.lr = 0x8289BD90;
	sub_822C0000(ctx, base);
	// 8289BD90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BD94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BD98: 4890C424  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BDA0 size=124
    let mut pc: u32 = 0x8289BDA0;
    'dispatch: loop {
        match pc {
            0x8289BDA0 => {
    //   block [0x8289BDA0..0x8289BE1C)
	// 8289BDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BDA4: 4890C3C9  bl 0x831a816c
	ctx.lr = 0x8289BDA8;
	sub_831A8130(ctx, base);
	// 8289BDA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BDAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BDB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BDB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BDB8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BDBC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BDC0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289BDC4: 48556625  bl 0x82df23e8
	ctx.lr = 0x8289BDC8;
	sub_82DF23E8(ctx, base);
	// 8289BDC8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BDCC: 4182001C  beq 0x8289bde8
	if ctx.cr[0].eq {
	pc = 0x8289BDE8; continue 'dispatch;
	}
	// 8289BDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BDD4: 485C0B55  bl 0x82e5c928
	ctx.lr = 0x8289BDD8;
	sub_82E5C928(ctx, base);
	// 8289BDD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BDDC: 396B8B38  addi r11, r11, -0x74c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29896;
	// 8289BDE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BDE4: 48000008  b 0x8289bdec
	pc = 0x8289BDEC; continue 'dispatch;
	// 8289BDE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BDEC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BDF0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BDF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BDF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BDFC: 4BFFE10D  bl 0x82899f08
	ctx.lr = 0x8289BE00;
	sub_82899F08(ctx, base);
	// 8289BE00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BE04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BE0C: 4BA241F5  bl 0x822c0000
	ctx.lr = 0x8289BE10;
	sub_822C0000(ctx, base);
	// 8289BE10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BE14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BE18: 4890C3A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BE20 size=124
    let mut pc: u32 = 0x8289BE20;
    'dispatch: loop {
        match pc {
            0x8289BE20 => {
    //   block [0x8289BE20..0x8289BE9C)
	// 8289BE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BE24: 4890C349  bl 0x831a816c
	ctx.lr = 0x8289BE28;
	sub_831A8130(ctx, base);
	// 8289BE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BE2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BE30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BE34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BE38: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BE3C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BE40: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289BE44: 485565A5  bl 0x82df23e8
	ctx.lr = 0x8289BE48;
	sub_82DF23E8(ctx, base);
	// 8289BE48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BE4C: 4182001C  beq 0x8289be68
	if ctx.cr[0].eq {
	pc = 0x8289BE68; continue 'dispatch;
	}
	// 8289BE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BE54: 485C0AD5  bl 0x82e5c928
	ctx.lr = 0x8289BE58;
	sub_82E5C928(ctx, base);
	// 8289BE58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BE5C: 396B8B60  addi r11, r11, -0x74a0
	ctx.r[11].s64 = ctx.r[11].s64 + -29856;
	// 8289BE60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BE64: 48000008  b 0x8289be6c
	pc = 0x8289BE6C; continue 'dispatch;
	// 8289BE68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BE6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BE70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BE74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BE7C: 4BFFE155  bl 0x82899fd0
	ctx.lr = 0x8289BE80;
	sub_82899FD0(ctx, base);
	// 8289BE80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BE88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BE8C: 4BA24175  bl 0x822c0000
	ctx.lr = 0x8289BE90;
	sub_822C0000(ctx, base);
	// 8289BE90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BE94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BE98: 4890C324  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BEA0 size=112
    let mut pc: u32 = 0x8289BEA0;
    'dispatch: loop {
        match pc {
            0x8289BEA0 => {
    //   block [0x8289BEA0..0x8289BF10)
	// 8289BEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BEA4: 4890C2C9  bl 0x831a816c
	ctx.lr = 0x8289BEA8;
	sub_831A8130(ctx, base);
	// 8289BEA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BEAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BEB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BEB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BEB8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BEBC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BEC0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 8289BEC4: 48556525  bl 0x82df23e8
	ctx.lr = 0x8289BEC8;
	sub_82DF23E8(ctx, base);
	// 8289BEC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289BECC: 41820010  beq 0x8289bedc
	if ctx.cr[0].eq {
	pc = 0x8289BEDC; continue 'dispatch;
	}
	// 8289BED0: 4808D999  bl 0x82929868
	ctx.lr = 0x8289BED4;
	sub_82929868(ctx, base);
	// 8289BED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289BED8: 48000008  b 0x8289bee0
	pc = 0x8289BEE0; continue 'dispatch;
	// 8289BEDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BEE0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BEE4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BEE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BEEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BEF0: 4BFFE1A9  bl 0x8289a098
	ctx.lr = 0x8289BEF4;
	sub_8289A098(ctx, base);
	// 8289BEF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BEF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BEFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BF00: 4BA24101  bl 0x822c0000
	ctx.lr = 0x8289BF04;
	sub_822C0000(ctx, base);
	// 8289BF04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BF08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BF0C: 4890C2B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BF10 size=112
    let mut pc: u32 = 0x8289BF10;
    'dispatch: loop {
        match pc {
            0x8289BF10 => {
    //   block [0x8289BF10..0x8289BF80)
	// 8289BF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BF14: 4890C259  bl 0x831a816c
	ctx.lr = 0x8289BF18;
	sub_831A8130(ctx, base);
	// 8289BF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BF1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BF20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BF24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BF28: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BF2C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BF30: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8289BF34: 485564B5  bl 0x82df23e8
	ctx.lr = 0x8289BF38;
	sub_82DF23E8(ctx, base);
	// 8289BF38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289BF3C: 41820010  beq 0x8289bf4c
	if ctx.cr[0].eq {
	pc = 0x8289BF4C; continue 'dispatch;
	}
	// 8289BF40: 48098549  bl 0x82934488
	ctx.lr = 0x8289BF44;
	sub_82934488(ctx, base);
	// 8289BF44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289BF48: 48000008  b 0x8289bf50
	pc = 0x8289BF50; continue 'dispatch;
	// 8289BF4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BF50: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BF54: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BF58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BF60: 4BFFE201  bl 0x8289a160
	ctx.lr = 0x8289BF64;
	sub_8289A160(ctx, base);
	// 8289BF64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BF68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BF70: 4BA24091  bl 0x822c0000
	ctx.lr = 0x8289BF74;
	sub_822C0000(ctx, base);
	// 8289BF74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BF78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BF7C: 4890C240  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289BF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289BF80 size=124
    let mut pc: u32 = 0x8289BF80;
    'dispatch: loop {
        match pc {
            0x8289BF80 => {
    //   block [0x8289BF80..0x8289BFFC)
	// 8289BF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289BF84: 4890C1E9  bl 0x831a816c
	ctx.lr = 0x8289BF88;
	sub_831A8130(ctx, base);
	// 8289BF88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289BF8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289BF90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289BF94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289BF98: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289BF9C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289BFA0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8289BFA4: 48556445  bl 0x82df23e8
	ctx.lr = 0x8289BFA8;
	sub_82DF23E8(ctx, base);
	// 8289BFA8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289BFAC: 4182001C  beq 0x8289bfc8
	if ctx.cr[0].eq {
	pc = 0x8289BFC8; continue 'dispatch;
	}
	// 8289BFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289BFB4: 485C0975  bl 0x82e5c928
	ctx.lr = 0x8289BFB8;
	sub_82E5C928(ctx, base);
	// 8289BFB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289BFBC: 396B8B88  addi r11, r11, -0x7478
	ctx.r[11].s64 = ctx.r[11].s64 + -29816;
	// 8289BFC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289BFC4: 48000008  b 0x8289bfcc
	pc = 0x8289BFCC; continue 'dispatch;
	// 8289BFC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289BFCC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289BFD0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289BFD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BFD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BFDC: 4BFFE24D  bl 0x8289a228
	ctx.lr = 0x8289BFE0;
	sub_8289A228(ctx, base);
	// 8289BFE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289BFE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289BFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289BFEC: 4BA24015  bl 0x822c0000
	ctx.lr = 0x8289BFF0;
	sub_822C0000(ctx, base);
	// 8289BFF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289BFF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289BFF8: 4890C1C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289C000 size=124
    let mut pc: u32 = 0x8289C000;
    'dispatch: loop {
        match pc {
            0x8289C000 => {
    //   block [0x8289C000..0x8289C07C)
	// 8289C000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C004: 4890C169  bl 0x831a816c
	ctx.lr = 0x8289C008;
	sub_831A8130(ctx, base);
	// 8289C008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C00C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289C010: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289C014: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289C018: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289C01C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289C020: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289C024: 485563C5  bl 0x82df23e8
	ctx.lr = 0x8289C028;
	sub_82DF23E8(ctx, base);
	// 8289C028: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289C02C: 4182001C  beq 0x8289c048
	if ctx.cr[0].eq {
	pc = 0x8289C048; continue 'dispatch;
	}
	// 8289C030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C034: 485C08F5  bl 0x82e5c928
	ctx.lr = 0x8289C038;
	sub_82E5C928(ctx, base);
	// 8289C038: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C03C: 396B8DC4  addi r11, r11, -0x723c
	ctx.r[11].s64 = ctx.r[11].s64 + -29244;
	// 8289C040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289C044: 48000008  b 0x8289c04c
	pc = 0x8289C04C; continue 'dispatch;
	// 8289C048: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289C04C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289C050: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289C054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C05C: 4BFFE295  bl 0x8289a2f0
	ctx.lr = 0x8289C060;
	sub_8289A2F0(ctx, base);
	// 8289C060: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289C064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C06C: 4BA23F95  bl 0x822c0000
	ctx.lr = 0x8289C070;
	sub_822C0000(ctx, base);
	// 8289C070: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289C074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289C078: 4890C144  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289C080 size=124
    let mut pc: u32 = 0x8289C080;
    'dispatch: loop {
        match pc {
            0x8289C080 => {
    //   block [0x8289C080..0x8289C0FC)
	// 8289C080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C084: 4890C0E9  bl 0x831a816c
	ctx.lr = 0x8289C088;
	sub_831A8130(ctx, base);
	// 8289C088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C08C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289C090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289C094: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289C098: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8289C09C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 8289C0A0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8289C0A4: 48556345  bl 0x82df23e8
	ctx.lr = 0x8289C0A8;
	sub_82DF23E8(ctx, base);
	// 8289C0A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289C0AC: 4182001C  beq 0x8289c0c8
	if ctx.cr[0].eq {
	pc = 0x8289C0C8; continue 'dispatch;
	}
	// 8289C0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C0B4: 485C0875  bl 0x82e5c928
	ctx.lr = 0x8289C0B8;
	sub_82E5C928(ctx, base);
	// 8289C0B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C0BC: 396B8BB0  addi r11, r11, -0x7450
	ctx.r[11].s64 = ctx.r[11].s64 + -29776;
	// 8289C0C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289C0C4: 48000008  b 0x8289c0cc
	pc = 0x8289C0CC; continue 'dispatch;
	// 8289C0C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289C0CC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289C0D0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8289C0D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C0D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C0DC: 4BFFE2DD  bl 0x8289a3b8
	ctx.lr = 0x8289C0E0;
	sub_8289A3B8(ctx, base);
	// 8289C0E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289C0E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C0E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C0EC: 4BA23F15  bl 0x822c0000
	ctx.lr = 0x8289C0F0;
	sub_822C0000(ctx, base);
	// 8289C0F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289C0F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289C0F8: 4890C0C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C100 size=580
    let mut pc: u32 = 0x8289C100;
    'dispatch: loop {
        match pc {
            0x8289C100 => {
    //   block [0x8289C100..0x8289C344)
	// 8289C100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C104: 4890C061  bl 0x831a8164
	ctx.lr = 0x8289C108;
	sub_831A8130(ctx, base);
	// 8289C108: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8289C10C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C114: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8289C118: 3D208337  lis r9, -0x7cc9
	ctx.r[9].s64 = -2093547520;
	// 8289C11C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8289C120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C124: 815F0448  lwz r10, 0x448(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1096 as u32) ) } as u64;
	// 8289C128: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8289C12C: 3969B210  addi r11, r9, -0x4df0
	ctx.r[11].s64 = ctx.r[9].s64 + -19952;
	// 8289C130: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 8289C134: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8289C138: 485578D1  bl 0x82df3a08
	ctx.lr = 0x8289C13C;
	sub_82DF3A08(ctx, base);
	// 8289C13C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289C140: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 8289C144: 485571C5  bl 0x82df3308
	ctx.lr = 0x8289C148;
	sub_82DF3308(ctx, base);
	// 8289C148: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289C14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C150: 485572D9  bl 0x82df3428
	ctx.lr = 0x8289C154;
	sub_82DF3428(ctx, base);
	// 8289C154: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C158: 418201E0  beq 0x8289c338
	if ctx.cr[0].eq {
	pc = 0x8289C338; continue 'dispatch;
	}
	// 8289C15C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289C160: 807F0428  lwz r3, 0x428(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1064 as u32) ) } as u64;
	// 8289C164: 48086815  bl 0x82922978
	ctx.lr = 0x8289C168;
	sub_82922978(ctx, base);
	// 8289C168: 3BDF03D0  addi r30, r31, 0x3d0
	ctx.r[30].s64 = ctx.r[31].s64 + 976;
	// 8289C16C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289C170: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8289C174: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289C178: 4BA81059  bl 0x8231d1d0
	ctx.lr = 0x8289C17C;
	sub_8231D1D0(ctx, base);
	// 8289C17C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C180: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289C184: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289C188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289C18C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8289C190: 419A0024  beq cr6, 0x8289c1b4
	if ctx.cr[6].eq {
	pc = 0x8289C1B4; continue 'dispatch;
	}
	// 8289C194: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289C198: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289C19C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289C1A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289C1A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289C1A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289C1AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289C1B0: 4082FFE8  bne 0x8289c198
	if !ctx.cr[0].eq {
	pc = 0x8289C198; continue 'dispatch;
	}
	// 8289C1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C1B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8289C1BC: 4BC7330D  bl 0x8250f4c8
	ctx.lr = 0x8289C1C0;
	sub_8250F4C8(ctx, base);
	// 8289C1C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289C1C8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8289C1CC: 409A0008  bne cr6, 0x8289c1d4
	if !ctx.cr[6].eq {
	pc = 0x8289C1D4; continue 'dispatch;
	}
	// 8289C1D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289C1D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289C1D8: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 8289C1DC: 4BC6C83D  bl 0x82508a18
	ctx.lr = 0x8289C1E0;
	sub_82508A18(ctx, base);
	// 8289C1E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C1E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289C1E8: 388B8F18  addi r4, r11, -0x70e8
	ctx.r[4].s64 = ctx.r[11].s64 + -28904;
	// 8289C1EC: 38A001D7  li r5, 0x1d7
	ctx.r[5].s64 = 471;
	// 8289C1F0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8289C1F4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8289C1F8: 485BADF1  bl 0x82e56fe8
	ctx.lr = 0x8289C1FC;
	sub_82E56FE8(ctx, base);
	// 8289C1FC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8289C200: 48555A91  bl 0x82df1c90
	ctx.lr = 0x8289C204;
	sub_82DF1C90(ctx, base);
	// 8289C204: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8289C208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289C20C: 419A0008  beq cr6, 0x8289c214
	if ctx.cr[6].eq {
	pc = 0x8289C214; continue 'dispatch;
	}
	// 8289C210: 4BA24681  bl 0x822c0890
	ctx.lr = 0x8289C214;
	sub_822C0890(ctx, base);
	// 8289C214: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289C218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289C21C: 419A0008  beq cr6, 0x8289c224
	if ctx.cr[6].eq {
	pc = 0x8289C224; continue 'dispatch;
	}
	// 8289C220: 4BA24671  bl 0x822c0890
	ctx.lr = 0x8289C224;
	sub_822C0890(ctx, base);
	// 8289C224: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289C228: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289C22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C230: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289C234: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289C238: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8289C23C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8289C240: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8289C244: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8289C248: 48177441  bl 0x82a13688
	ctx.lr = 0x8289C24C;
	sub_82A13688(ctx, base);
	// 8289C24C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289C250: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8289C254: 485DFC45  bl 0x82e7be98
	ctx.lr = 0x8289C258;
	sub_82E7BE98(ctx, base);
	// 8289C258: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289C25C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8289C260: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289C264: 485DFA65  bl 0x82e7bcc8
	ctx.lr = 0x8289C268;
	sub_82E7BCC8(ctx, base);
	// 8289C268: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8289C26C: 394003C0  li r10, 0x3c0
	ctx.r[10].s64 = 960;
	// 8289C270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C274: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C348 size=200
    let mut pc: u32 = 0x8289C348;
    'dispatch: loop {
        match pc {
            0x8289C348 => {
    //   block [0x8289C348..0x8289C410)
	// 8289C348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C34C: 4890BE11  bl 0x831a815c
	ctx.lr = 0x8289C350;
	sub_831A8130(ctx, base);
	// 8289C350: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C354: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C358: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8289C35C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8289C360: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8289C364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C368: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8289C36C: 486043C5  bl 0x82ea0730
	ctx.lr = 0x8289C370;
	sub_82EA0730(ctx, base);
	// 8289C370: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8289C374: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289C378: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8289C37C: C1BF0370  lfs f13, 0x370(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8289C380: C00A895C  lfs f0, -0x76a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30372 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289C384: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8289C388: 4867DE69  bl 0x82f1a1f0
	ctx.lr = 0x8289C38C;
	sub_82F1A1F0(ctx, base);
	// 8289C38C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 8289C390: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289C394: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8289C398: 3BABB1E8  addi r29, r11, -0x4e18
	ctx.r[29].s64 = ctx.r[11].s64 + -19992;
	// 8289C39C: 3BDF037C  addi r30, r31, 0x37c
	ctx.r[30].s64 = ctx.r[31].s64 + 892;
	// 8289C3A0: 836A6804  lwz r27, 0x6804(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26628 as u32) ) } as u64;
	// 8289C3A4: 3B80000A  li r28, 0xa
	ctx.r[28].s64 = 10;
	// 8289C3A8: 3F208337  lis r25, -0x7cc9
	ctx.r[25].s64 = -2093547520;
	// 8289C3AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289C3B4: 409A0034  bne cr6, 0x8289c3e8
	if !ctx.cr[6].eq {
	pc = 0x8289C3E8; continue 'dispatch;
	}
	// 8289C3B8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8289C3BC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8289C3C0: 419A000C  beq cr6, 0x8289c3cc
	if ctx.cr[6].eq {
	pc = 0x8289C3CC; continue 'dispatch;
	}
	// 8289C3C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8289C3C8: 4BA4BE81  bl 0x822e8248
	ctx.lr = 0x8289C3CC;
	sub_822E8248(ctx, base);
	// 8289C3CC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8289C3D0: 8099B1E4  lwz r4, -0x4e1c(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-19996 as u32) ) } as u64;
	// 8289C3D4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8289C3D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289C3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C3E0: 4BFFEB61  bl 0x8289af40
	ctx.lr = 0x8289C3E4;
	sub_8289AF40(ctx, base);
	// 8289C3E4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8289C3E8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8289C3EC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8289C3F0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8289C3F4: 4082FFB8  bne 0x8289c3ac
	if !ctx.cr[0].eq {
	pc = 0x8289C3AC; continue 'dispatch;
	}
	// 8289C3F8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8289C3FC: 419A000C  beq cr6, 0x8289c408
	if ctx.cr[6].eq {
	pc = 0x8289C408; continue 'dispatch;
	}
	// 8289C400: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8289C404: 4BA4BE65  bl 0x822e8268
	ctx.lr = 0x8289C408;
	sub_822E8268(ctx, base);
	// 8289C408: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289C40C: 4890BDA0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C410 size=196
    let mut pc: u32 = 0x8289C410;
    'dispatch: loop {
        match pc {
            0x8289C410 => {
    //   block [0x8289C410..0x8289C4D4)
	// 8289C410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C414: 4890BD49  bl 0x831a815c
	ctx.lr = 0x8289C418;
	sub_831A8130(ctx, base);
	// 8289C418: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C41C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C420: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8289C424: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8289C428: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8289C42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C430: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8289C434: 486042FD  bl 0x82ea0730
	ctx.lr = 0x8289C438;
	sub_82EA0730(ctx, base);
	// 8289C438: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8289C43C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289C440: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8289C444: C1BF0370  lfs f13, 0x370(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8289C448: C00A8958  lfs f0, -0x76a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289C44C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8289C450: 4867DDA1  bl 0x82f1a1f0
	ctx.lr = 0x8289C454;
	sub_82F1A1F0(ctx, base);
	// 8289C454: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289C458: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8289C45C: 3BABB1D4  addi r29, r11, -0x4e2c
	ctx.r[29].s64 = ctx.r[11].s64 + -20012;
	// 8289C460: 3BDF03A8  addi r30, r31, 0x3a8
	ctx.r[30].s64 = ctx.r[31].s64 + 936;
	// 8289C464: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 8289C468: 3F608337  lis r27, -0x7cc9
	ctx.r[27].s64 = -2093547520;
	// 8289C46C: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 8289C470: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289C478: 409A0034  bne cr6, 0x8289c4ac
	if !ctx.cr[6].eq {
	pc = 0x8289C4AC; continue 'dispatch;
	}
	// 8289C47C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 8289C480: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8289C484: 419A000C  beq cr6, 0x8289c490
	if ctx.cr[6].eq {
	pc = 0x8289C490; continue 'dispatch;
	}
	// 8289C488: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8289C48C: 4BA4BDBD  bl 0x822e8248
	ctx.lr = 0x8289C490;
	sub_822E8248(ctx, base);
	// 8289C490: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8289C494: 80DA6818  lwz r6, 0x6818(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26648 as u32) ) } as u64;
	// 8289C498: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289C49C: 809BB1CC  lwz r4, -0x4e34(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20020 as u32) ) } as u64;
	// 8289C4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C4A4: 4BFFEA9D  bl 0x8289af40
	ctx.lr = 0x8289C4A8;
	sub_8289AF40(ctx, base);
	// 8289C4A8: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8289C4AC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8289C4B0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8289C4B4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8289C4B8: 4082FFB8  bne 0x8289c470
	if !ctx.cr[0].eq {
	pc = 0x8289C470; continue 'dispatch;
	}
	// 8289C4BC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8289C4C0: 419A000C  beq cr6, 0x8289c4cc
	if ctx.cr[6].eq {
	pc = 0x8289C4CC; continue 'dispatch;
	}
	// 8289C4C4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8289C4C8: 4BA4BDA1  bl 0x822e8268
	ctx.lr = 0x8289C4CC;
	sub_822E8268(ctx, base);
	// 8289C4CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289C4D0: 4890BCDC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C4D8 size=768
    let mut pc: u32 = 0x8289C4D8;
    'dispatch: loop {
        match pc {
            0x8289C4D8 => {
    //   block [0x8289C4D8..0x8289C7D8)
	// 8289C4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C4DC: 4890BC81  bl 0x831a815c
	ctx.lr = 0x8289C4E0;
	sub_831A8130(ctx, base);
	// 8289C4E0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8289C4E4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C4E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289C4EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8289C4F0: 897E03A4  lbz r11, 0x3a4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(932 as u32) ) } as u64;
	// 8289C4F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289C4F8: 418202D4  beq 0x8289c7cc
	if ctx.cr[0].eq {
	pc = 0x8289C7CC; continue 'dispatch;
	}
	// 8289C4FC: 3F20832D  lis r25, -0x7cd3
	ctx.r[25].s64 = -2094202880;
	// 8289C500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C504: 80990B2C  lwz r4, 0xb2c(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8289C508: 48557501  bl 0x82df3a08
	ctx.lr = 0x8289C50C;
	sub_82DF3A08(ctx, base);
	// 8289C50C: 3B7E00FC  addi r27, r30, 0xfc
	ctx.r[27].s64 = ctx.r[30].s64 + 252;
	// 8289C510: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8289C514: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8289C518: 485BE1B9  bl 0x82e5a6d0
	ctx.lr = 0x8289C51C;
	sub_82E5A6D0(ctx, base);
	// 8289C51C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289C520: 48556D81  bl 0x82df32a0
	ctx.lr = 0x8289C524;
	sub_82DF32A0(ctx, base);
	// 8289C524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C52C: 48556EFD  bl 0x82df3428
	ctx.lr = 0x8289C530;
	sub_82DF3428(ctx, base);
	// 8289C530: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C534: 41820298  beq 0x8289c7cc
	if ctx.cr[0].eq {
	pc = 0x8289C7CC; continue 'dispatch;
	}
	// 8289C538: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8289C53C: 485BE195  bl 0x82e5a6d0
	ctx.lr = 0x8289C540;
	sub_82E5A6D0(ctx, base);
	// 8289C540: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289C544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C548: 485576B9  bl 0x82df3c00
	ctx.lr = 0x8289C54C;
	sub_82DF3C00(ctx, base);
	// 8289C54C: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 8289C550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289C554: 809A0B24  lwz r4, 0xb24(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8289C558: 485574B1  bl 0x82df3a08
	ctx.lr = 0x8289C55C;
	sub_82DF3A08(ctx, base);
	// 8289C55C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8289C560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C564: 48556DA5  bl 0x82df3308
	ctx.lr = 0x8289C568;
	sub_82DF3308(ctx, base);
	// 8289C568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C56C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289C570: 48556EB9  bl 0x82df3428
	ctx.lr = 0x8289C574;
	sub_82DF3428(ctx, base);
	// 8289C574: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C578: 3FA0832C  lis r29, -0x7cd4
	ctx.r[29].s64 = -2094268416;
	// 8289C57C: 41820010  beq 0x8289c58c
	if ctx.cr[0].eq {
	pc = 0x8289C58C; continue 'dispatch;
	}
	// 8289C580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C584: 809DFE50  lwz r4, -0x1b0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-432 as u32) ) } as u64;
	// 8289C588: 485572F1  bl 0x82df3878
	ctx.lr = 0x8289C58C;
	sub_82DF3878(ctx, base);
	// 8289C58C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289C590: 807E0428  lwz r3, 0x428(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1064 as u32) ) } as u64;
	// 8289C594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289C598: 48085AF9  bl 0x82922090
	ctx.lr = 0x8289C59C;
	sub_82922090(ctx, base);
	// 8289C59C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8289C5A0: 41820224  beq 0x8289c7c4
	if ctx.cr[0].eq {
	pc = 0x8289C7C4; continue 'dispatch;
	}
	// 8289C5A4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8289C5A8: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8289C5AC: 814A85E8  lwz r10, -0x7a18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31256 as u32) ) } as u64;
	// 8289C5B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8289C5B4: 419A0014  beq cr6, 0x8289c5c8
	if ctx.cr[6].eq {
	pc = 0x8289C5C8; continue 'dispatch;
	}
	// 8289C5B8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8289C5BC: 814A85E4  lwz r10, -0x7a1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31260 as u32) ) } as u64;
	// 8289C5C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8289C5C4: 409A0014  bne cr6, 0x8289c5d8
	if !ctx.cr[6].eq {
	pc = 0x8289C5D8; continue 'dispatch;
	}
	// 8289C5C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289C5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C5D0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289C5D4: 4BC75695  bl 0x82511c68
	ctx.lr = 0x8289C5D8;
	sub_82511C68(ctx, base);
	// 8289C5D8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 8289C5DC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8289C5E0: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 8289C5E4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C5E8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C5EC: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8289C5F0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8289C5F4: 41820014  beq 0x8289c608
	if ctx.cr[0].eq {
	pc = 0x8289C608; continue 'dispatch;
	}
	// 8289C5F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8289C5FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289C600: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8289C604: 419AFFE0  beq cr6, 0x8289c5e4
	if ctx.cr[6].eq {
	pc = 0x8289C5E4; continue 'dispatch;
	}
	// 8289C608: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C60C: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8289C610: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289C614: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289C618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C61C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289C620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289C624: 40820054  bne 0x8289c678
	if !ctx.cr[0].eq {
	pc = 0x8289C678; continue 'dispatch;
	}
	// 8289C628: 4E800421  bctrl
	ctx.lr = 0x8289C62C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289C62C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C630: 4806C829  bl 0x82908e58
	ctx.lr = 0x8289C634;
	sub_82908E58(ctx, base);
	// 8289C634: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289C638: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 8289C63C: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289C640: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8289C644: 419900D8  bgt cr6, 0x8289c71c
	if ctx.cr[6].gt {
	pc = 0x8289C71C; continue 'dispatch;
	}
	// 8289C648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289C64C: 80990B2C  lwz r4, 0xb2c(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8289C650: 485573B9  bl 0x82df3a08
	ctx.lr = 0x8289C654;
	sub_82DF3A08(ctx, base);
	// 8289C654: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8289C658: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289C65C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289C660: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289C664: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289C668: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8289C66C: 485C22F5  bl 0x82e5e960
	ctx.lr = 0x8289C670;
	sub_82E5E960(ctx, base);
	// 8289C670: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289C674: 4800009C  b 0x8289c710
	pc = 0x8289C710; continue 'dispatch;
	// 8289C678: 4E800421  bctrl
	ctx.lr = 0x8289C67C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289C67C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C680: 4BF4FAE1  bl 0x827ec160
	ctx.lr = 0x8289C684;
	sub_827EC160(ctx, base);
	// 8289C684: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289C688: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289C68C: 4807A70D  bl 0x82916d98
	ctx.lr = 0x8289C690;
	sub_82916D98(ctx, base);
	// 8289C690: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 8289C694: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8289C698: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 8289C69C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8289C6A0: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 8289C6A4: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C7D8 size=544
    let mut pc: u32 = 0x8289C7D8;
    'dispatch: loop {
        match pc {
            0x8289C7D8 => {
    //   block [0x8289C7D8..0x8289C9F8)
	// 8289C7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C7DC: 4890B985  bl 0x831a8160
	ctx.lr = 0x8289C7E0;
	sub_831A8130(ctx, base);
	// 8289C7E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289C7E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289C7E8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8289C7EC: 4806DA55  bl 0x8290a240
	ctx.lr = 0x8289C7F0;
	sub_8290A240(ctx, base);
	// 8289C7F0: 897F03B8  lbz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 8289C7F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289C7F8: 418201F8  beq 0x8289c9f0
	if ctx.cr[0].eq {
	pc = 0x8289C9F0; continue 'dispatch;
	}
	// 8289C7FC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289C800: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8289C804: 816BB1CC  lwz r11, -0x4e34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20020 as u32) ) } as u64;
	// 8289C808: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8289C80C: 409A01E4  bne cr6, 0x8289c9f0
	if !ctx.cr[6].eq {
	pc = 0x8289C9F0; continue 'dispatch;
	}
	// 8289C810: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C814: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8289C818: 388B8FDC  addi r4, r11, -0x7024
	ctx.r[4].s64 = ctx.r[11].s64 + -28708;
	// 8289C81C: 485571ED  bl 0x82df3a08
	ctx.lr = 0x8289C820;
	sub_82DF3A08(ctx, base);
	// 8289C820: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C824: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289C828: 388B8FCC  addi r4, r11, -0x7034
	ctx.r[4].s64 = ctx.r[11].s64 + -28724;
	// 8289C82C: 485571DD  bl 0x82df3a08
	ctx.lr = 0x8289C830;
	sub_82DF3A08(ctx, base);
	// 8289C830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C834: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289C838: 388B8FBC  addi r4, r11, -0x7044
	ctx.r[4].s64 = ctx.r[11].s64 + -28740;
	// 8289C83C: 485571CD  bl 0x82df3a08
	ctx.lr = 0x8289C840;
	sub_82DF3A08(ctx, base);
	// 8289C840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C844: 4BF4F91D  bl 0x827ec160
	ctx.lr = 0x8289C848;
	sub_827EC160(ctx, base);
	// 8289C848: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289C84C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289C850: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289C854: 4807A545  bl 0x82916d98
	ctx.lr = 0x8289C858;
	sub_82916D98(ctx, base);
	// 8289C858: 807F0400  lwz r3, 0x400(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289C85C: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 8289C860: 4BF4DA49  bl 0x827ea2a8
	ctx.lr = 0x8289C864;
	sub_827EA2A8(ctx, base);
	// 8289C864: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289C868: 48556AA1  bl 0x82df3308
	ctx.lr = 0x8289C86C;
	sub_82DF3308(ctx, base);
	// 8289C86C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C870: 41820010  beq 0x8289c880
	if ctx.cr[0].eq {
	pc = 0x8289C880; continue 'dispatch;
	}
	// 8289C874: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C878: 388B8A74  addi r4, r11, -0x758c
	ctx.r[4].s64 = ctx.r[11].s64 + -30092;
	// 8289C87C: 48000050  b 0x8289c8cc
	pc = 0x8289C8CC; continue 'dispatch;
	// 8289C880: 807F0400  lwz r3, 0x400(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289C884: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 8289C888: 4BF4DA21  bl 0x827ea2a8
	ctx.lr = 0x8289C88C;
	sub_827EA2A8(ctx, base);
	// 8289C88C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289C890: 48556A79  bl 0x82df3308
	ctx.lr = 0x8289C894;
	sub_82DF3308(ctx, base);
	// 8289C894: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C898: 41820010  beq 0x8289c8a8
	if ctx.cr[0].eq {
	pc = 0x8289C8A8; continue 'dispatch;
	}
	// 8289C89C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C8A0: 388B8A58  addi r4, r11, -0x75a8
	ctx.r[4].s64 = ctx.r[11].s64 + -30120;
	// 8289C8A4: 48000028  b 0x8289c8cc
	pc = 0x8289C8CC; continue 'dispatch;
	// 8289C8A8: 807F0400  lwz r3, 0x400(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289C8AC: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 8289C8B0: 4BF4D9F9  bl 0x827ea2a8
	ctx.lr = 0x8289C8B4;
	sub_827EA2A8(ctx, base);
	// 8289C8B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289C8B8: 48556A51  bl 0x82df3308
	ctx.lr = 0x8289C8BC;
	sub_82DF3308(ctx, base);
	// 8289C8BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289C8C0: 41820034  beq 0x8289c8f4
	if ctx.cr[0].eq {
	pc = 0x8289C8F4; continue 'dispatch;
	}
	// 8289C8C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289C8C8: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 8289C8CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C8D0: 48557139  bl 0x82df3a08
	ctx.lr = 0x8289C8D4;
	sub_82DF3A08(ctx, base);
	// 8289C8D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C8D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289C8DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289C8E0: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 8289C8E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289C8E8: 4E800421  bctrl
	ctx.lr = 0x8289C8EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289C8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289C8F0: 48556B39  bl 0x82df3428
	ctx.lr = 0x8289C8F4;
	sub_82DF3428(ctx, base);
	// 8289C8F4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289C8F8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8289C8FC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8289C900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289C904: 3B6A6910  addi r27, r10, 0x6910
	ctx.r[27].s64 = ctx.r[10].s64 + 26896;
	// 8289C908: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8289C90C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8289C910: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 8289C914: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 8289C918: 48176D69  bl 0x82a13680
	ctx.lr = 0x8289C91C;
	sub_82A13680(ctx, base);
	// 8289C91C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8289C920: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8289C924: 388B85F8  addi r4, r11, -0x7a08
	ctx.r[4].s64 = ctx.r[11].s64 + -31240;
	// 8289C928: 38DE00F8  addi r6, r30, 0xf8
	ctx.r[6].s64 = ctx.r[30].s64 + 248;
	// 8289C92C: 38BD00F4  addi r5, r29, 0xf4
	ctx.r[5].s64 = ctx.r[29].s64 + 244;
	// 8289C930: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289C934: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 8289C938: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8289C93C: 48005F55  bl 0x828a2890
	ctx.lr = 0x8289C940;
	sub_828A2890(ctx, base);
	// 8289C940: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289C944: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289C948: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289C94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289C950: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289C954: 419A0024  beq cr6, 0x8289c978
	if ctx.cr[6].eq {
	pc = 0x8289C978; continue 'dispatch;
	}
	// 8289C958: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289C95C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289C960: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289C964: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289C968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289C96C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289C970: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289C974: 4082FFE8  bne 0x8289c95c
	if !ctx.cr[0].eq {
	pc = 0x8289C95C; continue 'dispatch;
	}
	// 8289C978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289C97C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 8289C980: 4876B7A9  bl 0x83008128
	ctx.lr = 0x8289C984;
	sub_83008128(ctx, base);
	// 8289C984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289C988: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289C98C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289C990: 388A8F18  addi r4, r10, -0x70e8
	ctx.r[4].s64 = ctx.r[10].s64 + -28904;
	// 8289C994: 38A0038B  li r5, 0x38b
	ctx.r[5].s64 = 907;
	// 8289C998: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8289C99C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289C9A0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8289C9A4: 485BC09D  bl 0x82e58a40
	ctx.lr = 0x8289C9A8;
	sub_82E58A40(ctx, base);
	// 8289C9A8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289C9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289C9B0: 419A0008  beq cr6, 0x8289c9b8
	if ctx.cr[6].eq {
	pc = 0x8289C9B8; continue 'dispatch;
	}
	// 8289C9B4: 4BA23EDD  bl 0x822c0890
	ctx.lr = 0x8289C9B8;
	sub_822C0890(ctx, base);
	// 8289C9B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289C9BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289C9C0: 419A0008  beq cr6, 0x8289c9c8
	if ctx.cr[6].eq {
	pc = 0x8289C9C8; continue 'dispatch;
	}
	// 8289C9C4: 4BA23ECD  bl 0x822c0890
	ctx.lr = 0x8289C9C8;
	sub_822C0890(ctx, base);
	// 8289C9C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289C9CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289C9D0: 419A0008  beq cr6, 0x8289c9d8
	if ctx.cr[6].eq {
	pc = 0x8289C9D8; continue 'dispatch;
	}
	// 8289C9D4: 4BA23EBD  bl 0x822c0890
	ctx.lr = 0x8289C9D8;
	sub_822C0890(ctx, base);
	// 8289C9D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289C9DC: 48556A4D  bl 0x82df3428
	ctx.lr = 0x8289C9E0;
	sub_82DF3428(ctx, base);
	// 8289C9E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289C9E4: 48556A45  bl 0x82df3428
	ctx.lr = 0x8289C9E8;
	sub_82DF3428(ctx, base);
	// 8289C9E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8289C9EC: 48556A3D  bl 0x82df3428
	ctx.lr = 0x8289C9F0;
	sub_82DF3428(ctx, base);
	// 8289C9F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8289C9F4: 4890B7BC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289C9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289C9F8 size=324
    let mut pc: u32 = 0x8289C9F8;
    'dispatch: loop {
        match pc {
            0x8289C9F8 => {
    //   block [0x8289C9F8..0x8289CB3C)
	// 8289C9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289C9FC: 4890B76D  bl 0x831a8168
	ctx.lr = 0x8289CA00;
	sub_831A8130(ctx, base);
	// 8289CA00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CA04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289CA08: 488B7BF9  bl 0x83154600
	ctx.lr = 0x8289CA0C;
	sub_83154600(ctx, base);
	// 8289CA0C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289CA10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289CA18: 409A0088  bne cr6, 0x8289caa0
	if !ctx.cr[6].eq {
	pc = 0x8289CAA0; continue 'dispatch;
	}
	// 8289CA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CA20: 485BCD41  bl 0x82e59760
	ctx.lr = 0x8289CA24;
	sub_82E59760(ctx, base);
	// 8289CA24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289CA28: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289CA2C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289CA30: 40990104  ble cr6, 0x8289cb34
	if !ctx.cr[6].gt {
	pc = 0x8289CB34; continue 'dispatch;
	}
	// 8289CA34: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8289CA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CA3C: 388BF9A0  addi r4, r11, -0x660
	ctx.r[4].s64 = ctx.r[11].s64 + -1632;
	// 8289CA40: 48556FC9  bl 0x82df3a08
	ctx.lr = 0x8289CA44;
	sub_82DF3A08(ctx, base);
	// 8289CA44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CA4C: 480032BD  bl 0x8289fd08
	ctx.lr = 0x8289CA50;
	sub_8289FD08(ctx, base);
	// 8289CA50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CA54: 485569D5  bl 0x82df3428
	ctx.lr = 0x8289CA58;
	sub_82DF3428(ctx, base);
	// 8289CA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CA5C: 4BF50DBD  bl 0x827ed818
	ctx.lr = 0x8289CA60;
	sub_827ED818(ctx, base);
	// 8289CA60: 4BF4F821  bl 0x827ec280
	ctx.lr = 0x8289CA64;
	sub_827EC280(ctx, base);
	// 8289CA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289CA68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289CA6C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289CA70: 48003419  bl 0x8289fe88
	ctx.lr = 0x8289CA74;
	sub_8289FE88(ctx, base);
	// 8289CA74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CA78: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8289CA7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CA80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289CA84: 4E800421  bctrl
	ctx.lr = 0x8289CA88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289CA88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289CA8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CA90: 480032A9  bl 0x8289fd38
	ctx.lr = 0x8289CA94;
	sub_8289FD38(ctx, base);
	// 8289CA94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289CA98: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289CA9C: 48000098  b 0x8289cb34
	pc = 0x8289CB34; continue 'dispatch;
	// 8289CAA0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8289CAA4: 409A0090  bne cr6, 0x8289cb34
	if !ctx.cr[6].eq {
	pc = 0x8289CB34; continue 'dispatch;
	}
	// 8289CAA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CAAC: 488B7B55  bl 0x83154600
	ctx.lr = 0x8289CAB0;
	sub_83154600(ctx, base);
	// 8289CAB0: 4BF50D69  bl 0x827ed818
	ctx.lr = 0x8289CAB4;
	sub_827ED818(ctx, base);
	// 8289CAB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289CAB8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8289CABC: 897D0360  lbz r11, 0x360(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 8289CAC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CAC4: 40820014  bne 0x8289cad8
	if !ctx.cr[0].eq {
	pc = 0x8289CAD8; continue 'dispatch;
	}
	// 8289CAC8: 4BFFF881  bl 0x8289c348
	ctx.lr = 0x8289CACC;
	sub_8289C348(ctx, base);
	// 8289CACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289CAD0: 4BFFF941  bl 0x8289c410
	ctx.lr = 0x8289CAD4;
	sub_8289C410(ctx, base);
	// 8289CAD4: 9B9D0360  stb r28, 0x360(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(864 as u32), ctx.r[28].u8 ) };
	// 8289CAD8: 897E0060  lbz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289CADC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CAE0: 40820010  bne 0x8289caf0
	if !ctx.cr[0].eq {
	pc = 0x8289CAF0; continue 'dispatch;
	}
	// 8289CAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CAE8: 48003249  bl 0x8289fd30
	ctx.lr = 0x8289CAEC;
	sub_8289FD30(ctx, base);
	// 8289CAEC: 9B9E0060  stb r28, 0x60(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 8289CAF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289CAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CAF8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289CAFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289CB00: 4E800421  bctrl
	ctx.lr = 0x8289CB04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289CB04: 4BF4D80D  bl 0x827ea310
	ctx.lr = 0x8289CB08;
	sub_827EA310(ctx, base);
	// 8289CB08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289CB0C: 41820028  beq 0x8289cb34
	if ctx.cr[0].eq {
	pc = 0x8289CB34; continue 'dispatch;
	}
	// 8289CB10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289CB14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CB18: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8289CB1C: 48556EED  bl 0x82df3a08
	ctx.lr = 0x8289CB20;
	sub_82DF3A08(ctx, base);
	// 8289CB20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CB24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CB28: 4BF52C19  bl 0x827ef740
	ctx.lr = 0x8289CB2C;
	sub_827EF740(ctx, base);
	// 8289CB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CB30: 485568F9  bl 0x82df3428
	ctx.lr = 0x8289CB34;
	sub_82DF3428(ctx, base);
	// 8289CB34: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289CB38: 4890B680  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289CB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289CB40 size=280
    let mut pc: u32 = 0x8289CB40;
    'dispatch: loop {
        match pc {
            0x8289CB40 => {
    //   block [0x8289CB40..0x8289CC58)
	// 8289CB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289CB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289CB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289CB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289CB50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CB54: 488B7AAD  bl 0x83154600
	ctx.lr = 0x8289CB58;
	sub_83154600(ctx, base);
	// 8289CB58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CB5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289CB60: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289CB64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289CB68: 4E800421  bctrl
	ctx.lr = 0x8289CB6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289CB6C: 4BF4D7A5  bl 0x827ea310
	ctx.lr = 0x8289CB70;
	sub_827EA310(ctx, base);
	// 8289CB70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289CB74: 418200CC  beq 0x8289cc40
	if ctx.cr[0].eq {
	pc = 0x8289CC40; continue 'dispatch;
	}
	// 8289CB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CB7C: 480031D5  bl 0x8289fd50
	ctx.lr = 0x8289CB80;
	sub_8289FD50(ctx, base);
	// 8289CB80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CB84: 41820098  beq 0x8289cc1c
	if ctx.cr[0].eq {
	pc = 0x8289CC1C; continue 'dispatch;
	}
	// 8289CB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289CB8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CB90: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8289CB94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289CB98: 4BFFED89  bl 0x8289b920
	ctx.lr = 0x8289CB9C;
	sub_8289B920(ctx, base);
	// 8289CB9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289CBA0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289CBA4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289CBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289CBAC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8289CBB0: 419A0024  beq cr6, 0x8289cbd4
	if ctx.cr[6].eq {
	pc = 0x8289CBD4; continue 'dispatch;
	}
	// 8289CBB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289CBB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289CBBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289CBC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289CBC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289CBC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289CBCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289CBD0: 4082FFE8  bne 0x8289cbb8
	if !ctx.cr[0].eq {
	pc = 0x8289CBB8; continue 'dispatch;
	}
	// 8289CBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CBD8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8289CBDC: 48003175  bl 0x8289fd50
	ctx.lr = 0x8289CBE0;
	sub_8289FD50(ctx, base);
	// 8289CBE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289CBE4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289CBE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289CBEC: 388A8F18  addi r4, r10, -0x70e8
	ctx.r[4].s64 = ctx.r[10].s64 + -28904;
	// 8289CBF0: 38A005DA  li r5, 0x5da
	ctx.r[5].s64 = 1498;
	// 8289CBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CBF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289CBFC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8289CC00: 4BF52F59  bl 0x827efb58
	ctx.lr = 0x8289CC04;
	sub_827EFB58(ctx, base);
	// 8289CC04: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289CC08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289CC0C: 419A0008  beq cr6, 0x8289cc14
	if ctx.cr[6].eq {
	pc = 0x8289CC14; continue 'dispatch;
	}
	// 8289CC10: 4BA23C81  bl 0x822c0890
	ctx.lr = 0x8289CC14;
	sub_822C0890(ctx, base);
	// 8289CC14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CC18: 48003141  bl 0x8289fd58
	ctx.lr = 0x8289CC1C;
	sub_8289FD58(ctx, base);
	// 8289CC1C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289CC20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CC24: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 8289CC28: 48556DE1  bl 0x82df3a08
	ctx.lr = 0x8289CC2C;
	sub_82DF3A08(ctx, base);
	// 8289CC2C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8289CC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CC34: 4BF52B0D  bl 0x827ef740
	ctx.lr = 0x8289CC38;
	sub_827EF740(ctx, base);
	// 8289CC38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CC3C: 485567ED  bl 0x82df3428
	ctx.lr = 0x8289CC40;
	sub_82DF3428(ctx, base);
	// 8289CC40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289CC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289CC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289CC4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289CC50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289CC54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289CC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289CC58 size=204
    let mut pc: u32 = 0x8289CC58;
    'dispatch: loop {
        match pc {
            0x8289CC58 => {
    //   block [0x8289CC58..0x8289CD24)
	// 8289CC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289CC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289CC60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289CC64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289CC68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CC6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CC70: 488B7991  bl 0x83154600
	ctx.lr = 0x8289CC74;
	sub_83154600(ctx, base);
	// 8289CC74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CC78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289CC7C: 388B8FDC  addi r4, r11, -0x7024
	ctx.r[4].s64 = ctx.r[11].s64 + -28708;
	// 8289CC80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CC84: 48556D85  bl 0x82df3a08
	ctx.lr = 0x8289CC88;
	sub_82DF3A08(ctx, base);
	// 8289CC88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CC90: 48003079  bl 0x8289fd08
	ctx.lr = 0x8289CC94;
	sub_8289FD08(ctx, base);
	// 8289CC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CC98: 48556791  bl 0x82df3428
	ctx.lr = 0x8289CC9C;
	sub_82DF3428(ctx, base);
	// 8289CC9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289CCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CCA4: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 8289CCA8: 4BF50B71  bl 0x827ed818
	ctx.lr = 0x8289CCAC;
	sub_827ED818(ctx, base);
	// 8289CCAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CCB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CCB4: 4BC72815  bl 0x8250f4c8
	ctx.lr = 0x8289CCB8;
	sub_8250F4C8(ctx, base);
	// 8289CCB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CCBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289CCC0: 388B8F18  addi r4, r11, -0x70e8
	ctx.r[4].s64 = ctx.r[11].s64 + -28904;
	// 8289CCC4: 38A0063D  li r5, 0x63d
	ctx.r[5].s64 = 1597;
	// 8289CCC8: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 8289CCCC: 4855571D  bl 0x82df23e8
	ctx.lr = 0x8289CCD0;
	sub_82DF23E8(ctx, base);
	// 8289CCD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CCD4: 41820024  beq 0x8289ccf8
	if ctx.cr[0].eq {
	pc = 0x8289CCF8; continue 'dispatch;
	}
	// 8289CCD8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8289CCDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289CCE0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289CCE4: 409A0008  bne cr6, 0x8289ccec
	if !ctx.cr[6].eq {
	pc = 0x8289CCEC; continue 'dispatch;
	}
	// 8289CCE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CCEC: 4BF33865  bl 0x827d0550
	ctx.lr = 0x8289CCF0;
	sub_827D0550(ctx, base);
	// 8289CCF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CCF4: 48000008  b 0x8289ccfc
	pc = 0x8289CCFC; continue 'dispatch;
	// 8289CCF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CCFC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 8289CD00: 4BDD4E31  bl 0x82671b30
	ctx.lr = 0x8289CD04;
	sub_82671B30(ctx, base);
	// 8289CD04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CD08: 48554F89  bl 0x82df1c90
	ctx.lr = 0x8289CD0C;
	sub_82DF1C90(ctx, base);
	// 8289CD0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289CD10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289CD14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289CD18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289CD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289CD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289CD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289CD28 size=316
    let mut pc: u32 = 0x8289CD28;
    'dispatch: loop {
        match pc {
            0x8289CD28 => {
    //   block [0x8289CD28..0x8289CE64)
	// 8289CD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289CD2C: 4890B43D  bl 0x831a8168
	ctx.lr = 0x8289CD30;
	sub_831A8130(ctx, base);
	// 8289CD30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CD38: 488B78C9  bl 0x83154600
	ctx.lr = 0x8289CD3C;
	sub_83154600(ctx, base);
	// 8289CD3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289CD40: 4BF50AD9  bl 0x827ed818
	ctx.lr = 0x8289CD44;
	sub_827ED818(ctx, base);
	// 8289CD44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CD48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CD4C: 4BC7277D  bl 0x8250f4c8
	ctx.lr = 0x8289CD50;
	sub_8250F4C8(ctx, base);
	// 8289CD50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CD54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289CD58: 388B8F18  addi r4, r11, -0x70e8
	ctx.r[4].s64 = ctx.r[11].s64 + -28904;
	// 8289CD5C: 38A0066E  li r5, 0x66e
	ctx.r[5].s64 = 1646;
	// 8289CD60: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 8289CD64: 48555685  bl 0x82df23e8
	ctx.lr = 0x8289CD68;
	sub_82DF23E8(ctx, base);
	// 8289CD68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CD6C: 41820024  beq 0x8289cd90
	if ctx.cr[0].eq {
	pc = 0x8289CD90; continue 'dispatch;
	}
	// 8289CD70: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8289CD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289CD78: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289CD7C: 409A0008  bne cr6, 0x8289cd84
	if !ctx.cr[6].eq {
	pc = 0x8289CD84; continue 'dispatch;
	}
	// 8289CD80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CD84: 4BF337CD  bl 0x827d0550
	ctx.lr = 0x8289CD88;
	sub_827D0550(ctx, base);
	// 8289CD88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CD8C: 48000008  b 0x8289cd94
	pc = 0x8289CD94; continue 'dispatch;
	// 8289CD90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CD94: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 8289CD98: 4BDD4D99  bl 0x82671b30
	ctx.lr = 0x8289CD9C;
	sub_82671B30(ctx, base);
	// 8289CD9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289CDA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CDA4: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 8289CDA8: 48556C61  bl 0x82df3a08
	ctx.lr = 0x8289CDAC;
	sub_82DF3A08(ctx, base);
	// 8289CDAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CDB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289CDB4: 388B8FEC  addi r4, r11, -0x7014
	ctx.r[4].s64 = ctx.r[11].s64 + -28692;
	// 8289CDB8: 83FF0060  lwz r31, 0x60(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289CDBC: 48556C4D  bl 0x82df3a08
	ctx.lr = 0x8289CDC0;
	sub_82DF3A08(ctx, base);
	// 8289CDC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289CDC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289CDC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289CDCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289CDD0: 480032C9  bl 0x828a0098
	ctx.lr = 0x8289CDD4;
	sub_828A0098(ctx, base);
	// 8289CDD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8289CDD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CDDC: 4BF50A3D  bl 0x827ed818
	ctx.lr = 0x8289CDE0;
	sub_827ED818(ctx, base);
	// 8289CDE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CDE4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289CDE8: 4BC726E1  bl 0x8250f4c8
	ctx.lr = 0x8289CDEC;
	sub_8250F4C8(ctx, base);
	// 8289CDEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289CDF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CDF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289CDFC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8289CE00: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 8289CE04: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289CE08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8289CE0C: 4BF3352D  bl 0x827d0338
	ctx.lr = 0x8289CE10;
	sub_827D0338(ctx, base);
	// 8289CE10: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289CE14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289CE18: 419A0008  beq cr6, 0x8289ce20
	if ctx.cr[6].eq {
	pc = 0x8289CE20; continue 'dispatch;
	}
	// 8289CE1C: 4BA23A75  bl 0x822c0890
	ctx.lr = 0x8289CE20;
	sub_822C0890(ctx, base);
	// 8289CE20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289CE24: 48556605  bl 0x82df3428
	ctx.lr = 0x8289CE28;
	sub_82DF3428(ctx, base);
	// 8289CE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CE2C: 485565FD  bl 0x82df3428
	ctx.lr = 0x8289CE30;
	sub_82DF3428(ctx, base);
	// 8289CE30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CE34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CE38: 388B8FCC  addi r4, r11, -0x7034
	ctx.r[4].s64 = ctx.r[11].s64 + -28724;
	// 8289CE3C: 48556BCD  bl 0x82df3a08
	ctx.lr = 0x8289CE40;
	sub_82DF3A08(ctx, base);
	// 8289CE40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CE44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CE48: 48002EC1  bl 0x8289fd08
	ctx.lr = 0x8289CE4C;
	sub_8289FD08(ctx, base);
	// 8289CE4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CE50: 485565D9  bl 0x82df3428
	ctx.lr = 0x8289CE54;
	sub_82DF3428(ctx, base);
	// 8289CE54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CE58: 48554E39  bl 0x82df1c90
	ctx.lr = 0x8289CE5C;
	sub_82DF1C90(ctx, base);
	// 8289CE5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289CE60: 4890B358  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289CE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289CE68 size=320
    let mut pc: u32 = 0x8289CE68;
    'dispatch: loop {
        match pc {
            0x8289CE68 => {
    //   block [0x8289CE68..0x8289CFA8)
	// 8289CE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289CE6C: 4890B2FD  bl 0x831a8168
	ctx.lr = 0x8289CE70;
	sub_831A8130(ctx, base);
	// 8289CE70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CE74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289CE78: 488B7789  bl 0x83154600
	ctx.lr = 0x8289CE7C;
	sub_83154600(ctx, base);
	// 8289CE7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CE84: 388B8FBC  addi r4, r11, -0x7044
	ctx.r[4].s64 = ctx.r[11].s64 + -28740;
	// 8289CE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CE8C: 48556B7D  bl 0x82df3a08
	ctx.lr = 0x8289CE90;
	sub_82DF3A08(ctx, base);
	// 8289CE90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CE94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289CE98: 48002E71  bl 0x8289fd08
	ctx.lr = 0x8289CE9C;
	sub_8289FD08(ctx, base);
	// 8289CE9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CEA0: 48556589  bl 0x82df3428
	ctx.lr = 0x8289CEA4;
	sub_82DF3428(ctx, base);
	// 8289CEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CEA8: 4BF50971  bl 0x827ed818
	ctx.lr = 0x8289CEAC;
	sub_827ED818(ctx, base);
	// 8289CEAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CEB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CEB4: 4BC72615  bl 0x8250f4c8
	ctx.lr = 0x8289CEB8;
	sub_8250F4C8(ctx, base);
	// 8289CEB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CEBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289CEC0: 388B8F18  addi r4, r11, -0x70e8
	ctx.r[4].s64 = ctx.r[11].s64 + -28904;
	// 8289CEC4: 38A00695  li r5, 0x695
	ctx.r[5].s64 = 1685;
	// 8289CEC8: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 8289CECC: 4855551D  bl 0x82df23e8
	ctx.lr = 0x8289CED0;
	sub_82DF23E8(ctx, base);
	// 8289CED0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CED4: 41820024  beq 0x8289cef8
	if ctx.cr[0].eq {
	pc = 0x8289CEF8; continue 'dispatch;
	}
	// 8289CED8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8289CEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289CEE0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289CEE4: 409A0008  bne cr6, 0x8289ceec
	if !ctx.cr[6].eq {
	pc = 0x8289CEEC; continue 'dispatch;
	}
	// 8289CEE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CEEC: 4BF33665  bl 0x827d0550
	ctx.lr = 0x8289CEF0;
	sub_827D0550(ctx, base);
	// 8289CEF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CEF4: 48000008  b 0x8289cefc
	pc = 0x8289CEFC; continue 'dispatch;
	// 8289CEF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289CEFC: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 8289CF00: 4BDD4C31  bl 0x82671b30
	ctx.lr = 0x8289CF04;
	sub_82671B30(ctx, base);
	// 8289CF04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289CF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CF0C: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 8289CF10: 48556AF9  bl 0x82df3a08
	ctx.lr = 0x8289CF14;
	sub_82DF3A08(ctx, base);
	// 8289CF14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289CF18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289CF1C: 388B8FEC  addi r4, r11, -0x7014
	ctx.r[4].s64 = ctx.r[11].s64 + -28692;
	// 8289CF20: 83DE0060  lwz r30, 0x60(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289CF24: 48556AE5  bl 0x82df3a08
	ctx.lr = 0x8289CF28;
	sub_82DF3A08(ctx, base);
	// 8289CF28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289CF2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289CF30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289CF34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289CF38: 48003161  bl 0x828a0098
	ctx.lr = 0x8289CF3C;
	sub_828A0098(ctx, base);
	// 8289CF3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8289CF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289CF44: 4BF508D5  bl 0x827ed818
	ctx.lr = 0x8289CF48;
	sub_827ED818(ctx, base);
	// 8289CF48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CF4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289CF50: 4BC72579  bl 0x8250f4c8
	ctx.lr = 0x8289CF54;
	sub_8250F4C8(ctx, base);
	// 8289CF54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289CF58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289CF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289CF60: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289CF64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8289CF68: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 8289CF6C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289CF70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8289CF74: 4BF333C5  bl 0x827d0338
	ctx.lr = 0x8289CF78;
	sub_827D0338(ctx, base);
	// 8289CF78: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289CF7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289CF80: 419A0008  beq cr6, 0x8289cf88
	if ctx.cr[6].eq {
	pc = 0x8289CF88; continue 'dispatch;
	}
	// 8289CF84: 4BA2390D  bl 0x822c0890
	ctx.lr = 0x8289CF88;
	sub_822C0890(ctx, base);
	// 8289CF88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8289CF8C: 4855649D  bl 0x82df3428
	ctx.lr = 0x8289CF90;
	sub_82DF3428(ctx, base);
	// 8289CF90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289CF94: 48556495  bl 0x82df3428
	ctx.lr = 0x8289CF98;
	sub_82DF3428(ctx, base);
	// 8289CF98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8289CF9C: 48554CF5  bl 0x82df1c90
	ctx.lr = 0x8289CFA0;
	sub_82DF1C90(ctx, base);
	// 8289CFA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289CFA4: 4890B214  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289CFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289CFA8 size=724
    let mut pc: u32 = 0x8289CFA8;
    'dispatch: loop {
        match pc {
            0x8289CFA8 => {
    //   block [0x8289CFA8..0x8289D27C)
	// 8289CFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289CFAC: 4890B1B5  bl 0x831a8160
	ctx.lr = 0x8289CFB0;
	sub_831A8130(ctx, base);
	// 8289CFB0: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8289CFB4: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8289CFB8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289CFBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289CFC0: 488B7641  bl 0x83154600
	ctx.lr = 0x8289CFC4;
	sub_83154600(ctx, base);
	// 8289CFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289CFC8: 4BF50851  bl 0x827ed818
	ctx.lr = 0x8289CFCC;
	sub_827ED818(ctx, base);
	// 8289CFCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289CFD0: 891F0060  lbz r8, 0x60(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289CFD4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8289CFD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289CFDC: 3B600007  li r27, 7
	ctx.r[27].s64 = 7;
	// 8289CFE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289CFE4: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289CFE8: 3B8B3568  addi r28, r11, 0x3568
	ctx.r[28].s64 = ctx.r[11].s64 + 13672;
	// 8289CFEC: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289CFF0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289CFF4: 4082009C  bne 0x8289d090
	if !ctx.cr[0].eq {
	pc = 0x8289D090; continue 'dispatch;
	}
	// 8289CFF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289CFFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D000: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289D004: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289D008: 4E800421  bctrl
	ctx.lr = 0x8289D00C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289D00C: 4BF4D2FD  bl 0x827ea308
	ctx.lr = 0x8289D010;
	sub_827EA308(ctx, base);
	// 8289D010: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289D014: C00BF904  lfs f0, -0x6fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289D018: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8289D01C: 40990074  ble cr6, 0x8289d090
	if !ctx.cr[6].gt {
	pc = 0x8289D090; continue 'dispatch;
	}
	// 8289D020: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289D024: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289D028: 485569E1  bl 0x82df3a08
	ctx.lr = 0x8289D02C;
	sub_82DF3A08(ctx, base);
	// 8289D02C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289D030: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8289D034: 388B9004  addi r4, r11, -0x6ffc
	ctx.r[4].s64 = ctx.r[11].s64 + -28668;
	// 8289D038: 485569D1  bl 0x82df3a08
	ctx.lr = 0x8289D03C;
	sub_82DF3A08(ctx, base);
	// 8289D03C: D3E1008C  stfs f31, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8289D040: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8289D044: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 8289D048: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8289D04C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8289D050: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8289D054: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8289D058: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8289D05C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289D060: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8289D064: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8289D068: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8289D06C: D3C100A8  stfs f30, 0xa8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8289D070: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8289D074: 4BF4F595  bl 0x827ec608
	ctx.lr = 0x8289D078;
	sub_827EC608(ctx, base);
	// 8289D078: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289D07C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8289D080: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 8289D084: 485563A5  bl 0x82df3428
	ctx.lr = 0x8289D088;
	sub_82DF3428(ctx, base);
	// 8289D088: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289D08C: 4855639D  bl 0x82df3428
	ctx.lr = 0x8289D090;
	sub_82DF3428(ctx, base);
	// 8289D090: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D098: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289D09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289D0A0: 4E800421  bctrl
	ctx.lr = 0x8289D0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289D0A4: 4BF4D26D  bl 0x827ea310
	ctx.lr = 0x8289D0A8;
	sub_827EA310(ctx, base);
	// 8289D0A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289D0AC: 418201C0  beq 0x8289d26c
	if ctx.cr[0].eq {
	pc = 0x8289D26C; continue 'dispatch;
	}
	// 8289D0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D0B4: 48002C9D  bl 0x8289fd50
	ctx.lr = 0x8289D0B8;
	sub_8289FD50(ctx, base);
	// 8289D0B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289D0BC: 41820110  beq 0x8289d1cc
	if ctx.cr[0].eq {
	pc = 0x8289D1CC; continue 'dispatch;
	}
	// 8289D0C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D0C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289D0C8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8289D0CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D0D0: 4BFFE851  bl 0x8289b920
	ctx.lr = 0x8289D0D4;
	sub_8289B920(ctx, base);
	// 8289D0D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D0D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289D0DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289D0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D0E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8289D0E8: 419A0024  beq cr6, 0x8289d10c
	if ctx.cr[6].eq {
	pc = 0x8289D10C; continue 'dispatch;
	}
	// 8289D0EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289D0F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289D0F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D0F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289D0FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289D100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289D104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D108: 4082FFE8  bne 0x8289d0f0
	if !ctx.cr[0].eq {
	pc = 0x8289D0F0; continue 'dispatch;
	}
	// 8289D10C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D110: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 8289D114: 48002C3D  bl 0x8289fd50
	ctx.lr = 0x8289D118;
	sub_8289FD50(ctx, base);
	// 8289D118: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289D11C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289D120: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289D124: 3BEB8F18  addi r31, r11, -0x70e8
	ctx.r[31].s64 = ctx.r[11].s64 + -28904;
	// 8289D128: 38A0076A  li r5, 0x76a
	ctx.r[5].s64 = 1898;
	// 8289D12C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289D130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D134: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 8289D138: 4BF52A21  bl 0x827efb58
	ctx.lr = 0x8289D13C;
	sub_827EFB58(ctx, base);
	// 8289D13C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289D140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D144: 419A0008  beq cr6, 0x8289d14c
	if ctx.cr[6].eq {
	pc = 0x8289D14C; continue 'dispatch;
	}
	// 8289D148: 4BA23749  bl 0x822c0890
	ctx.lr = 0x8289D14C;
	sub_822C0890(ctx, base);
	// 8289D14C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8289D150: 4BFFE849  bl 0x8289b998
	ctx.lr = 0x8289D154;
	sub_8289B998(ctx, base);
	// 8289D154: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D158: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289D15C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289D160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D164: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8289D168: 419A0024  beq cr6, 0x8289d18c
	if ctx.cr[6].eq {
	pc = 0x8289D18C; continue 'dispatch;
	}
	// 8289D16C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289D170: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289D174: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D178: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289D17C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289D180: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289D184: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D188: 4082FFE8  bne 0x8289d170
	if !ctx.cr[0].eq {
	pc = 0x8289D170; continue 'dispatch;
	}
	// 8289D18C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D190: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 8289D194: 48002BCD  bl 0x8289fd60
	ctx.lr = 0x8289D198;
	sub_8289FD60(ctx, base);
	// 8289D198: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289D19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289D1A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289D1A4: 38A0076B  li r5, 0x76b
	ctx.r[5].s64 = 1899;
	// 8289D1A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D1AC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 8289D1B0: 4BF529A9  bl 0x827efb58
	ctx.lr = 0x8289D1B4;
	sub_827EFB58(ctx, base);
	// 8289D1B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8289D1B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D1BC: 419A0008  beq cr6, 0x8289d1c4
	if ctx.cr[6].eq {
	pc = 0x8289D1C4; continue 'dispatch;
	}
	// 8289D1C0: 4BA236D1  bl 0x822c0890
	ctx.lr = 0x8289D1C4;
	sub_822C0890(ctx, base);
	// 8289D1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D1C8: 48002B91  bl 0x8289fd58
	ctx.lr = 0x8289D1CC;
	sub_8289FD58(ctx, base);
	// 8289D1CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289D1D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289D1D4: 48556835  bl 0x82df3a08
	ctx.lr = 0x8289D1D8;
	sub_82DF3A08(ctx, base);
	// 8289D1D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289D1DC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8289D1E0: 388B8DAC  addi r4, r11, -0x7254
	ctx.r[4].s64 = ctx.r[11].s64 + -29268;
	// 8289D1E4: 48556825  bl 0x82df3a08
	ctx.lr = 0x8289D1E8;
	sub_82DF3A08(ctx, base);
	// 8289D1E8: D3E1008C  stfs f31, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8289D1EC: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8289D1F0: 93610088  stw r27, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 8289D1F4: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8289D1F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8289D1FC: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8289D200: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8289D204: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8289D208: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289D20C: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8289D210: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8289D214: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8289D218: D3C100A8  stfs f30, 0xa8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8289D21C: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8289D220: 4BF4F3E9  bl 0x827ec608
	ctx.lr = 0x8289D224;
	sub_827EC608(ctx, base);
	// 8289D224: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289D228: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289D22C: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 8289D230: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289D234: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D238: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8289D23C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289D240: 4E800421  bctrl
	ctx.lr = 0x8289D244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289D244: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289D248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D24C: 419A0008  beq cr6, 0x8289d254
	if ctx.cr[6].eq {
	pc = 0x8289D254; continue 'dispatch;
	}
	// 8289D250: 4BA23641  bl 0x822c0890
	ctx.lr = 0x8289D254;
	sub_822C0890(ctx, base);
	// 8289D254: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 8289D258: 485561D1  bl 0x82df3428
	ctx.lr = 0x8289D25C;
	sub_82DF3428(ctx, base);
	// 8289D25C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289D260: 485561C9  bl 0x82df3428
	ctx.lr = 0x8289D264;
	sub_82DF3428(ctx, base);
	// 8289D264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D268: 48002AB1  bl 0x8289fd18
	ctx.lr = 0x8289D26C;
	sub_8289FD18(ctx, base);
	// 8289D26C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8289D270: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8289D274: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8289D278: 4890AF38  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289D280 size=600
    let mut pc: u32 = 0x8289D280;
    'dispatch: loop {
        match pc {
            0x8289D280 => {
    //   block [0x8289D280..0x8289D4D8)
	// 8289D280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D284: 4890AEE5  bl 0x831a8168
	ctx.lr = 0x8289D288;
	sub_831A8130(ctx, base);
	// 8289D288: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D28C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8289D290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8289D294: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289D298: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8289D29C: 4BC7222D  bl 0x8250f4c8
	ctx.lr = 0x8289D2A0;
	sub_8250F4C8(ctx, base);
	// 8289D2A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D2A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D2A8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289D2AC: 409A0008  bne cr6, 0x8289d2b4
	if !ctx.cr[6].eq {
	pc = 0x8289D2B4; continue 'dispatch;
	}
	// 8289D2B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289D2B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289D2B8: 4BC6D311  bl 0x8250a5c8
	ctx.lr = 0x8289D2BC;
	sub_8250A5C8(ctx, base);
	// 8289D2BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D2C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D2C4: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 8289D2C8: 409A0008  bne cr6, 0x8289d2d0
	if !ctx.cr[6].eq {
	pc = 0x8289D2D0; continue 'dispatch;
	}
	// 8289D2CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289D2D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289D2D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8289D2D8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8289D2DC: 4BF0F175  bl 0x827ac450
	ctx.lr = 0x8289D2E0;
	sub_827AC450(ctx, base);
	// 8289D2E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289D2E4: 485549AD  bl 0x82df1c90
	ctx.lr = 0x8289D2E8;
	sub_82DF1C90(ctx, base);
	// 8289D2E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8289D2EC: 485549A5  bl 0x82df1c90
	ctx.lr = 0x8289D2F0;
	sub_82DF1C90(ctx, base);
	// 8289D2F0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8289D2F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D2F8: 419A009C  beq cr6, 0x8289d394
	if ctx.cr[6].eq {
	pc = 0x8289D394; continue 'dispatch;
	}
	// 8289D2FC: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 8289D300: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8289D304: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8289D308: 4182008C  beq 0x8289d394
	if ctx.cr[0].eq {
	pc = 0x8289D394; continue 'dispatch;
	}
	// 8289D30C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D310: 3BFC0418  addi r31, r28, 0x418
	ctx.r[31].s64 = ctx.r[28].s64 + 1048;
	// 8289D314: 917C0374  stw r11, 0x374(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(884 as u32), ctx.r[11].u32 ) };
	// 8289D318: 815C0418  lwz r10, 0x418(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1048 as u32) ) } as u64;
	// 8289D31C: 817C041C  lwz r11, 0x41c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1052 as u32) ) } as u64;
	// 8289D320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D324: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8289D328: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8289D32C: 419A0024  beq cr6, 0x8289d350
	if ctx.cr[6].eq {
	pc = 0x8289D350; continue 'dispatch;
	}
	// 8289D330: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289D334: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289D338: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D33C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289D340: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289D344: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289D348: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D34C: 4082FFE8  bne 0x8289d334
	if !ctx.cr[0].eq {
	pc = 0x8289D334; continue 'dispatch;
	}
	// 8289D350: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289D354: 80DC0374  lwz r6, 0x374(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(884 as u32) ) } as u64;
	// 8289D358: 3BDC0028  addi r30, r28, 0x28
	ctx.r[30].s64 = ctx.r[28].s64 + 40;
	// 8289D35C: 3BAB8F18  addi r29, r11, -0x70e8
	ctx.r[29].s64 = ctx.r[11].s64 + -28904;
	// 8289D360: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8289D364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289D368: 38A0040E  li r5, 0x40e
	ctx.r[5].s64 = 1038;
	// 8289D36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D370: 485B9C79  bl 0x82e56fe8
	ctx.lr = 0x8289D374;
	sub_82E56FE8(ctx, base);
	// 8289D374: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8289D378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D37C: 419A0008  beq cr6, 0x8289d384
	if ctx.cr[6].eq {
	pc = 0x8289D384; continue 'dispatch;
	}
	// 8289D380: 4BA23511  bl 0x822c0890
	ctx.lr = 0x8289D384;
	sub_822C0890(ctx, base);
	// 8289D384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D388: 896B0018  lbz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8289D38C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289D390: 4182001C  beq 0x8289d3ac
	if ctx.cr[0].eq {
	pc = 0x8289D3AC; continue 'dispatch;
	}
	// 8289D394: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289D398: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8289D39C: 4BBCCC65  bl 0x8246a000
	ctx.lr = 0x8289D3A0;
	sub_8246A000(ctx, base);
	// 8289D3A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D3A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8289D3A8: 4890AE10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 8289D3AC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8289D3B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289D3B4: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 8289D3B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8289D3BC: 4BFFE565  bl 0x8289b920
	ctx.lr = 0x8289D3C0;
	sub_8289B920(ctx, base);
	// 8289D3C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D3C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D3C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289D3CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D3D0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289D3D4: 419A0024  beq cr6, 0x8289d3f8
	if ctx.cr[6].eq {
	pc = 0x8289D3F8; continue 'dispatch;
	}
	// 8289D3D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289D3DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289D3E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D3E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289D3E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289D3EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289D3F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289D3F4: 4082FFE8  bne 0x8289d3dc
	if !ctx.cr[0].eq {
	pc = 0x8289D3DC; continue 'dispatch;
	}
	// 8289D3F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289D3FC: 80DC0374  lwz r6, 0x374(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(884 as u32) ) } as u64;
	// 8289D400: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8289D404: 38A00415  li r5, 0x415
	ctx.r[5].s64 = 1045;
	// 8289D408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D40C: 485B9BDD  bl 0x82e56fe8
	ctx.lr = 0x8289D410;
	sub_82E56FE8(ctx, base);
	// 8289D410: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289D414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D418: 419A0008  beq cr6, 0x8289d420
	if ctx.cr[6].eq {
	pc = 0x8289D420; continue 'dispatch;
	}
	// 8289D41C: 4BA23475  bl 0x822c0890
	ctx.lr = 0x8289D420;
	sub_822C0890(ctx, base);
	// 8289D420: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8289D424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289D428: 419A0008  beq cr6, 0x8289d430
	if ctx.cr[6].eq {
	pc = 0x8289D430; continue 'dispatch;
	}
	// 8289D42C: 4BA23465  bl 0x822c0890
	ctx.lr = 0x8289D430;
	sub_822C0890(ctx, base);
	// 8289D430: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8289D434: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8289D438: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8289D43C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8289D440: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8289D444: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8289D448: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8289D44C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289D4D8 size=216
    let mut pc: u32 = 0x8289D4D8;
    'dispatch: loop {
        match pc {
            0x8289D4D8 => {
    //   block [0x8289D4D8..0x8289D5B0)
	// 8289D4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D4DC: 4890AC91  bl 0x831a816c
	ctx.lr = 0x8289D4E0;
	sub_831A8130(ctx, base);
	// 8289D4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D4E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D4E8: 817F043C  lwz r11, 0x43c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) } as u64;
	// 8289D4EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D4F0: 419A0014  beq cr6, 0x8289d504
	if ctx.cr[6].eq {
	pc = 0x8289D504; continue 'dispatch;
	}
	// 8289D4F4: 815F0440  lwz r10, 0x440(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) } as u64;
	// 8289D4F8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8289D4FC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289D500: 4082000C  bne 0x8289d50c
	if !ctx.cr[0].eq {
	pc = 0x8289D50C; continue 'dispatch;
	}
	// 8289D504: 809F0430  lwz r4, 0x430(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1072 as u32) ) } as u64;
	// 8289D508: 48000098  b 0x8289d5a0
	pc = 0x8289D5A0; continue 'dispatch;
	// 8289D50C: 817F043C  lwz r11, 0x43c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) } as u64;
	// 8289D510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289D514: 409A000C  bne cr6, 0x8289d520
	if !ctx.cr[6].eq {
	pc = 0x8289D520; continue 'dispatch;
	}
	// 8289D518: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8289D51C: 48000010  b 0x8289d52c
	pc = 0x8289D52C; continue 'dispatch;
	// 8289D520: 815F0440  lwz r10, 0x440(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) } as u64;
	// 8289D524: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8289D528: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 8289D52C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289D530: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289D534: 3BDD0001  addi r30, r29, 1
	ctx.r[30].s64 = ctx.r[29].s64 + 1;
	// 8289D538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D53C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289D540: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 8289D544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289D548: 4E800421  bctrl
	ctx.lr = 0x8289D54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289D54C: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 8289D550: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289D554: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8289D558: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8289D55C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8289D560: 0CDE0000  twi 6, r30, 0
	// 8289D564: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8289D568: C00A8954  lfs f0, -0x76ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289D56C: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 8289D570: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8289D574: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8289D578: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 8289D57C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8289D580: 7D4BF396  divwu r10, r11, r30
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[30].u32;
	// 8289D584: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s64 = (ctx.r[10].s32 as i64) * (ctx.r[30].s32 as i64);
	// 8289D588: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8289D58C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8289D590: 4098FF74  bge cr6, 0x8289d504
	if !ctx.cr[6].lt {
	pc = 0x8289D504; continue 'dispatch;
	}
	// 8289D594: 815F043C  lwz r10, 0x43c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) } as u64;
	// 8289D598: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8289D59C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8289D5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D5A4: 4BFFFCDD  bl 0x8289d280
	ctx.lr = 0x8289D5A8;
	sub_8289D280(ctx, base);
	// 8289D5A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289D5AC: 4890AC10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D5B0 size=92
    let mut pc: u32 = 0x8289D5B0;
    'dispatch: loop {
        match pc {
            0x8289D5B0 => {
    //   block [0x8289D5B0..0x8289D60C)
	// 8289D5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D5B4: 4890ABB9  bl 0x831a816c
	ctx.lr = 0x8289D5B8;
	sub_831A8130(ctx, base);
	// 8289D5B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D5BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D5C0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D5C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D5CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D5D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D5D4: 388ABA18  addi r4, r10, -0x45e8
	ctx.r[4].s64 = ctx.r[10].s64 + -17896;
	// 8289D5D8: 4BAC2499  bl 0x8235fa70
	ctx.lr = 0x8289D5DC;
	sub_8235FA70(ctx, base);
	// 8289D5DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D5E4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D5E8: 48556619  bl 0x82df3c00
	ctx.lr = 0x8289D5EC;
	sub_82DF3C00(ctx, base);
	// 8289D5EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D5F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D5F8: 485BEB61  bl 0x82e5c158
	ctx.lr = 0x8289D5FC;
	sub_82E5C158(ctx, base);
	// 8289D5FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D600: 48555E29  bl 0x82df3428
	ctx.lr = 0x8289D604;
	sub_82DF3428(ctx, base);
	// 8289D604: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D608: 4890ABB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D610 size=92
    let mut pc: u32 = 0x8289D610;
    'dispatch: loop {
        match pc {
            0x8289D610 => {
    //   block [0x8289D610..0x8289D66C)
	// 8289D610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D614: 4890AB59  bl 0x831a816c
	ctx.lr = 0x8289D618;
	sub_831A8130(ctx, base);
	// 8289D618: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D620: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D62C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D634: 388ABA98  addi r4, r10, -0x4568
	ctx.r[4].s64 = ctx.r[10].s64 + -17768;
	// 8289D638: 4BAC2439  bl 0x8235fa70
	ctx.lr = 0x8289D63C;
	sub_8235FA70(ctx, base);
	// 8289D63C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D644: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D648: 485565B9  bl 0x82df3c00
	ctx.lr = 0x8289D64C;
	sub_82DF3C00(ctx, base);
	// 8289D64C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D654: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D658: 485BEB01  bl 0x82e5c158
	ctx.lr = 0x8289D65C;
	sub_82E5C158(ctx, base);
	// 8289D65C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D660: 48555DC9  bl 0x82df3428
	ctx.lr = 0x8289D664;
	sub_82DF3428(ctx, base);
	// 8289D664: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D668: 4890AB54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D670 size=92
    let mut pc: u32 = 0x8289D670;
    'dispatch: loop {
        match pc {
            0x8289D670 => {
    //   block [0x8289D670..0x8289D6CC)
	// 8289D670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D674: 4890AAF9  bl 0x831a816c
	ctx.lr = 0x8289D678;
	sub_831A8130(ctx, base);
	// 8289D678: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D67C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D680: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D684: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D68C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D690: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D694: 388ABB08  addi r4, r10, -0x44f8
	ctx.r[4].s64 = ctx.r[10].s64 + -17656;
	// 8289D698: 4BAC23D9  bl 0x8235fa70
	ctx.lr = 0x8289D69C;
	sub_8235FA70(ctx, base);
	// 8289D69C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D6A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D6A8: 48556559  bl 0x82df3c00
	ctx.lr = 0x8289D6AC;
	sub_82DF3C00(ctx, base);
	// 8289D6AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D6B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D6B8: 485BEAA1  bl 0x82e5c158
	ctx.lr = 0x8289D6BC;
	sub_82E5C158(ctx, base);
	// 8289D6BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D6C0: 48555D69  bl 0x82df3428
	ctx.lr = 0x8289D6C4;
	sub_82DF3428(ctx, base);
	// 8289D6C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D6C8: 4890AAF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D6D0 size=92
    let mut pc: u32 = 0x8289D6D0;
    'dispatch: loop {
        match pc {
            0x8289D6D0 => {
    //   block [0x8289D6D0..0x8289D72C)
	// 8289D6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D6D4: 4890AA99  bl 0x831a816c
	ctx.lr = 0x8289D6D8;
	sub_831A8130(ctx, base);
	// 8289D6D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D6DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D6E0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D6E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D6E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D6EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D6F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D6F4: 388ABB88  addi r4, r10, -0x4478
	ctx.r[4].s64 = ctx.r[10].s64 + -17528;
	// 8289D6F8: 4BAC2379  bl 0x8235fa70
	ctx.lr = 0x8289D6FC;
	sub_8235FA70(ctx, base);
	// 8289D6FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D704: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D708: 485564F9  bl 0x82df3c00
	ctx.lr = 0x8289D70C;
	sub_82DF3C00(ctx, base);
	// 8289D70C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D714: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D718: 485BEA41  bl 0x82e5c158
	ctx.lr = 0x8289D71C;
	sub_82E5C158(ctx, base);
	// 8289D71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D720: 48555D09  bl 0x82df3428
	ctx.lr = 0x8289D724;
	sub_82DF3428(ctx, base);
	// 8289D724: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D728: 4890AA94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D730 size=92
    let mut pc: u32 = 0x8289D730;
    'dispatch: loop {
        match pc {
            0x8289D730 => {
    //   block [0x8289D730..0x8289D78C)
	// 8289D730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D734: 4890AA39  bl 0x831a816c
	ctx.lr = 0x8289D738;
	sub_831A8130(ctx, base);
	// 8289D738: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D73C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D740: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D744: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D74C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D754: 388ABC10  addi r4, r10, -0x43f0
	ctx.r[4].s64 = ctx.r[10].s64 + -17392;
	// 8289D758: 4BAC2319  bl 0x8235fa70
	ctx.lr = 0x8289D75C;
	sub_8235FA70(ctx, base);
	// 8289D75C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D764: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D768: 48556499  bl 0x82df3c00
	ctx.lr = 0x8289D76C;
	sub_82DF3C00(ctx, base);
	// 8289D76C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D774: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D778: 485BE9E1  bl 0x82e5c158
	ctx.lr = 0x8289D77C;
	sub_82E5C158(ctx, base);
	// 8289D77C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D780: 48555CA9  bl 0x82df3428
	ctx.lr = 0x8289D784;
	sub_82DF3428(ctx, base);
	// 8289D784: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D788: 4890AA34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D790 size=92
    let mut pc: u32 = 0x8289D790;
    'dispatch: loop {
        match pc {
            0x8289D790 => {
    //   block [0x8289D790..0x8289D7EC)
	// 8289D790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D794: 4890A9D9  bl 0x831a816c
	ctx.lr = 0x8289D798;
	sub_831A8130(ctx, base);
	// 8289D798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D79C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D7A0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D7A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D7A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D7AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D7B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D7B4: 388ABC98  addi r4, r10, -0x4368
	ctx.r[4].s64 = ctx.r[10].s64 + -17256;
	// 8289D7B8: 4BAC22B9  bl 0x8235fa70
	ctx.lr = 0x8289D7BC;
	sub_8235FA70(ctx, base);
	// 8289D7BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D7C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D7C4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D7C8: 48556439  bl 0x82df3c00
	ctx.lr = 0x8289D7CC;
	sub_82DF3C00(ctx, base);
	// 8289D7CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D7D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D7D8: 485BE981  bl 0x82e5c158
	ctx.lr = 0x8289D7DC;
	sub_82E5C158(ctx, base);
	// 8289D7DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D7E0: 48555C49  bl 0x82df3428
	ctx.lr = 0x8289D7E4;
	sub_82DF3428(ctx, base);
	// 8289D7E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D7E8: 4890A9D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D7F0 size=92
    let mut pc: u32 = 0x8289D7F0;
    'dispatch: loop {
        match pc {
            0x8289D7F0 => {
    //   block [0x8289D7F0..0x8289D84C)
	// 8289D7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D7F4: 4890A979  bl 0x831a816c
	ctx.lr = 0x8289D7F8;
	sub_831A8130(ctx, base);
	// 8289D7F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D7FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D800: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D804: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D80C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D810: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D814: 388ABD20  addi r4, r10, -0x42e0
	ctx.r[4].s64 = ctx.r[10].s64 + -17120;
	// 8289D818: 4BAC2259  bl 0x8235fa70
	ctx.lr = 0x8289D81C;
	sub_8235FA70(ctx, base);
	// 8289D81C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D824: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D828: 485563D9  bl 0x82df3c00
	ctx.lr = 0x8289D82C;
	sub_82DF3C00(ctx, base);
	// 8289D82C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D834: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D838: 485BE921  bl 0x82e5c158
	ctx.lr = 0x8289D83C;
	sub_82E5C158(ctx, base);
	// 8289D83C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D840: 48555BE9  bl 0x82df3428
	ctx.lr = 0x8289D844;
	sub_82DF3428(ctx, base);
	// 8289D844: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D848: 4890A974  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D850 size=92
    let mut pc: u32 = 0x8289D850;
    'dispatch: loop {
        match pc {
            0x8289D850 => {
    //   block [0x8289D850..0x8289D8AC)
	// 8289D850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D854: 4890A919  bl 0x831a816c
	ctx.lr = 0x8289D858;
	sub_831A8130(ctx, base);
	// 8289D858: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D85C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D860: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D864: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D868: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D86C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D870: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D874: 388ABDA0  addi r4, r10, -0x4260
	ctx.r[4].s64 = ctx.r[10].s64 + -16992;
	// 8289D878: 4BAC21F9  bl 0x8235fa70
	ctx.lr = 0x8289D87C;
	sub_8235FA70(ctx, base);
	// 8289D87C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D884: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D888: 48556379  bl 0x82df3c00
	ctx.lr = 0x8289D88C;
	sub_82DF3C00(ctx, base);
	// 8289D88C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D894: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D898: 485BE8C1  bl 0x82e5c158
	ctx.lr = 0x8289D89C;
	sub_82E5C158(ctx, base);
	// 8289D89C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D8A0: 48555B89  bl 0x82df3428
	ctx.lr = 0x8289D8A4;
	sub_82DF3428(ctx, base);
	// 8289D8A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D8A8: 4890A914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D8B0 size=92
    let mut pc: u32 = 0x8289D8B0;
    'dispatch: loop {
        match pc {
            0x8289D8B0 => {
    //   block [0x8289D8B0..0x8289D90C)
	// 8289D8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D8B4: 4890A8B9  bl 0x831a816c
	ctx.lr = 0x8289D8B8;
	sub_831A8130(ctx, base);
	// 8289D8B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D8BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D8C0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D8C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D8CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D8D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D8D4: 388ABE20  addi r4, r10, -0x41e0
	ctx.r[4].s64 = ctx.r[10].s64 + -16864;
	// 8289D8D8: 4BAC2199  bl 0x8235fa70
	ctx.lr = 0x8289D8DC;
	sub_8235FA70(ctx, base);
	// 8289D8DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D8E4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D8E8: 48556319  bl 0x82df3c00
	ctx.lr = 0x8289D8EC;
	sub_82DF3C00(ctx, base);
	// 8289D8EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D8F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D8F8: 485BE861  bl 0x82e5c158
	ctx.lr = 0x8289D8FC;
	sub_82E5C158(ctx, base);
	// 8289D8FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D900: 48555B29  bl 0x82df3428
	ctx.lr = 0x8289D904;
	sub_82DF3428(ctx, base);
	// 8289D904: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D908: 4890A8B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D910 size=92
    let mut pc: u32 = 0x8289D910;
    'dispatch: loop {
        match pc {
            0x8289D910 => {
    //   block [0x8289D910..0x8289D96C)
	// 8289D910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D914: 4890A859  bl 0x831a816c
	ctx.lr = 0x8289D918;
	sub_831A8130(ctx, base);
	// 8289D918: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D91C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D920: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D924: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D92C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D930: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D934: 388ABEA0  addi r4, r10, -0x4160
	ctx.r[4].s64 = ctx.r[10].s64 + -16736;
	// 8289D938: 4BAC2139  bl 0x8235fa70
	ctx.lr = 0x8289D93C;
	sub_8235FA70(ctx, base);
	// 8289D93C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D944: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D948: 485562B9  bl 0x82df3c00
	ctx.lr = 0x8289D94C;
	sub_82DF3C00(ctx, base);
	// 8289D94C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D954: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D958: 485BE801  bl 0x82e5c158
	ctx.lr = 0x8289D95C;
	sub_82E5C158(ctx, base);
	// 8289D95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D960: 48555AC9  bl 0x82df3428
	ctx.lr = 0x8289D964;
	sub_82DF3428(ctx, base);
	// 8289D964: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D968: 4890A854  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D970 size=92
    let mut pc: u32 = 0x8289D970;
    'dispatch: loop {
        match pc {
            0x8289D970 => {
    //   block [0x8289D970..0x8289D9CC)
	// 8289D970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D974: 4890A7F9  bl 0x831a816c
	ctx.lr = 0x8289D978;
	sub_831A8130(ctx, base);
	// 8289D978: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D97C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D980: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D984: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D98C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D990: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D994: 388ABF10  addi r4, r10, -0x40f0
	ctx.r[4].s64 = ctx.r[10].s64 + -16624;
	// 8289D998: 4BAC20D9  bl 0x8235fa70
	ctx.lr = 0x8289D99C;
	sub_8235FA70(ctx, base);
	// 8289D99C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289D9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289D9A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289D9A8: 48556259  bl 0x82df3c00
	ctx.lr = 0x8289D9AC;
	sub_82DF3C00(ctx, base);
	// 8289D9AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289D9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289D9B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289D9B8: 485BE7A1  bl 0x82e5c158
	ctx.lr = 0x8289D9BC;
	sub_82E5C158(ctx, base);
	// 8289D9BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289D9C0: 48555A69  bl 0x82df3428
	ctx.lr = 0x8289D9C4;
	sub_82DF3428(ctx, base);
	// 8289D9C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289D9C8: 4890A7F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289D9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289D9D0 size=92
    let mut pc: u32 = 0x8289D9D0;
    'dispatch: loop {
        match pc {
            0x8289D9D0 => {
    //   block [0x8289D9D0..0x8289DA2C)
	// 8289D9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289D9D4: 4890A799  bl 0x831a816c
	ctx.lr = 0x8289D9D8;
	sub_831A8130(ctx, base);
	// 8289D9D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289D9DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289D9E0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289D9E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289D9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289D9EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289D9F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289D9F4: 388ABF80  addi r4, r10, -0x4080
	ctx.r[4].s64 = ctx.r[10].s64 + -16512;
	// 8289D9F8: 4BAC2079  bl 0x8235fa70
	ctx.lr = 0x8289D9FC;
	sub_8235FA70(ctx, base);
	// 8289D9FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289DA00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289DA04: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289DA08: 485561F9  bl 0x82df3c00
	ctx.lr = 0x8289DA0C;
	sub_82DF3C00(ctx, base);
	// 8289DA0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289DA14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289DA18: 485BE741  bl 0x82e5c158
	ctx.lr = 0x8289DA1C;
	sub_82E5C158(ctx, base);
	// 8289DA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DA20: 48555A09  bl 0x82df3428
	ctx.lr = 0x8289DA24;
	sub_82DF3428(ctx, base);
	// 8289DA24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289DA28: 4890A794  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289DA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289DA30 size=92
    let mut pc: u32 = 0x8289DA30;
    'dispatch: loop {
        match pc {
            0x8289DA30 => {
    //   block [0x8289DA30..0x8289DA8C)
	// 8289DA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289DA34: 4890A739  bl 0x831a816c
	ctx.lr = 0x8289DA38;
	sub_831A8130(ctx, base);
	// 8289DA38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289DA3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289DA40: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289DA44: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289DA48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289DA4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289DA50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289DA54: 388AC000  addi r4, r10, -0x4000
	ctx.r[4].s64 = ctx.r[10].s64 + -16384;
	// 8289DA58: 4BAC2019  bl 0x8235fa70
	ctx.lr = 0x8289DA5C;
	sub_8235FA70(ctx, base);
	// 8289DA5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289DA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289DA64: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289DA68: 48556199  bl 0x82df3c00
	ctx.lr = 0x8289DA6C;
	sub_82DF3C00(ctx, base);
	// 8289DA6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289DA74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289DA78: 485BE6E1  bl 0x82e5c158
	ctx.lr = 0x8289DA7C;
	sub_82E5C158(ctx, base);
	// 8289DA7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DA80: 485559A9  bl 0x82df3428
	ctx.lr = 0x8289DA84;
	sub_82DF3428(ctx, base);
	// 8289DA84: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289DA88: 4890A734  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289DA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289DA90 size=92
    let mut pc: u32 = 0x8289DA90;
    'dispatch: loop {
        match pc {
            0x8289DA90 => {
    //   block [0x8289DA90..0x8289DAEC)
	// 8289DA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289DA94: 4890A6D9  bl 0x831a816c
	ctx.lr = 0x8289DA98;
	sub_831A8130(ctx, base);
	// 8289DA98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289DA9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289DAA0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 8289DAA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8289DAA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289DAAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289DAB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289DAB4: 388AC080  addi r4, r10, -0x3f80
	ctx.r[4].s64 = ctx.r[10].s64 + -16256;
	// 8289DAB8: 4BAC1FB9  bl 0x8235fa70
	ctx.lr = 0x8289DABC;
	sub_8235FA70(ctx, base);
	// 8289DABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289DAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289DAC4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 8289DAC8: 48556139  bl 0x82df3c00
	ctx.lr = 0x8289DACC;
	sub_82DF3C00(ctx, base);
	// 8289DACC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289DAD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289DAD8: 485BE681  bl 0x82e5c158
	ctx.lr = 0x8289DADC;
	sub_82E5C158(ctx, base);
	// 8289DADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DAE0: 48555949  bl 0x82df3428
	ctx.lr = 0x8289DAE4;
	sub_82DF3428(ctx, base);
	// 8289DAE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8289DAE8: 4890A6D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289DAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289DAF0 size=128
    let mut pc: u32 = 0x8289DAF0;
    'dispatch: loop {
        match pc {
            0x8289DAF0 => {
    //   block [0x8289DAF0..0x8289DB70)
	// 8289DAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289DAF4: 4890A679  bl 0x831a816c
	ctx.lr = 0x8289DAF8;
	sub_831A8130(ctx, base);
	// 8289DAF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289DAFC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 8289DB00: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289DB04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289DB08: 3BEBB1B0  addi r31, r11, -0x4e50
	ctx.r[31].s64 = ctx.r[11].s64 + -20048;
	// 8289DB0C: 816AB1B8  lwz r11, -0x4e48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20040 as u32) ) } as u64;
	// 8289DB10: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8289DB14: 40820024  bne 0x8289db38
	if !ctx.cr[0].eq {
	pc = 0x8289DB38; continue 'dispatch;
	}
	// 8289DB18: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 8289DB1C: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 8289DB20: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8289DB24: 39299108  addi r9, r9, -0x6ef8
	ctx.r[9].s64 = ctx.r[9].s64 + -28408;
	// 8289DB28: 3908AD40  addi r8, r8, -0x52c0
	ctx.r[8].s64 = ctx.r[8].s64 + -21184;
	// 8289DB2C: 916AB1B8  stw r11, -0x4e48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20040 as u32), ctx.r[11].u32 ) };
	// 8289DB30: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8289DB34: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8289DB38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8289DB3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8289DB40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289DB44: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8289DB48: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8289DB4C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289DB50: 4BDB6A71  bl 0x826545c0
	ctx.lr = 0x8289DB54;
	sub_826545C0(ctx, base);
	// 8289DB54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289DB58: 4182000C  beq 0x8289db64
	if ctx.cr[0].eq {
	pc = 0x8289DB64; continue 'dispatch;
	}
	// 8289DB5C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289DB60: 48000008  b 0x8289db68
	pc = 0x8289DB68; continue 'dispatch;
	// 8289DB64: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8289DB68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289DB6C: 4890A650  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289DB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289DB70 size=128
    let mut pc: u32 = 0x8289DB70;
    'dispatch: loop {
        match pc {
            0x8289DB70 => {
    //   block [0x8289DB70..0x8289DBF0)
	// 8289DB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289DB74: 4890A5F9  bl 0x831a816c
	ctx.lr = 0x8289DB78;
	sub_831A8130(ctx, base);
	// 8289DB78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289DB7C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 8289DB80: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289DB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289DB88: 3BEBB1BC  addi r31, r11, -0x4e44
	ctx.r[31].s64 = ctx.r[11].s64 + -20036;
	// 8289DB8C: 816AB1C4  lwz r11, -0x4e3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20028 as u32) ) } as u64;
	// 8289DB90: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8289DB94: 40820024  bne 0x8289dbb8
	if !ctx.cr[0].eq {
	pc = 0x8289DBB8; continue 'dispatch;
	}
	// 8289DB98: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 8289DB9C: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 8289DBA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8289DBA4: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 8289DBA8: 3908AD88  addi r8, r8, -0x5278
	ctx.r[8].s64 = ctx.r[8].s64 + -21112;
	// 8289DBAC: 916AB1C4  stw r11, -0x4e3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20028 as u32), ctx.r[11].u32 ) };
	// 8289DBB0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8289DBB4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8289DBB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8289DBBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8289DBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289DBC4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8289DBC8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8289DBCC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289DBD0: 4BDB69F1  bl 0x826545c0
	ctx.lr = 0x8289DBD4;
	sub_826545C0(ctx, base);
	// 8289DBD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289DBD8: 4182000C  beq 0x8289dbe4
	if ctx.cr[0].eq {
	pc = 0x8289DBE4; continue 'dispatch;
	}
	// 8289DBDC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8289DBE0: 48000008  b 0x8289dbe8
	pc = 0x8289DBE8; continue 'dispatch;
	// 8289DBE4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8289DBE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8289DBEC: 4890A5D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289DBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289DBF0 size=5728
    let mut pc: u32 = 0x8289DBF0;
    'dispatch: loop {
        match pc {
            0x8289DBF0 => {
    //   block [0x8289DBF0..0x8289F250)
	// 8289DBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289DBF4: 4890A53D  bl 0x831a8130
	ctx.lr = 0x8289DBF8;
	sub_831A8130(ctx, base);
	// 8289DBF8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8289DBFC: 4890AE79  bl 0x831a8a74
	ctx.lr = 0x8289DC00;
	sub_831A8A40(ctx, base);
	// 8289DC00: 9421F9B0  stwu r1, -0x650(r1)
	ea = ctx.r[1].u32.wrapping_add(-1616 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289DC04: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8289DC08: 9081066C  stw r4, 0x66c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1644 as u32), ctx.r[4].u32 ) };
	// 8289DC0C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8289DC10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8289DC14: 93C10674  stw r30, 0x674(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1652 as u32), ctx.r[30].u32 ) };
	// 8289DC18: 93A1067C  stw r29, 0x67c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1660 as u32), ctx.r[29].u32 ) };
	// 8289DC1C: 48073175  bl 0x82910d90
	ctx.lr = 0x8289DC20;
	sub_82910D90(ctx, base);
	// 8289DC20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8289DC24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289DC28: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8289DC2C: 48555DDD  bl 0x82df3a08
	ctx.lr = 0x8289DC30;
	sub_82DF3A08(ctx, base);
	// 8289DC30: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8289DC34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289DC38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DC3C: 4BC6AB45  bl 0x82508780
	ctx.lr = 0x8289DC40;
	sub_82508780(ctx, base);
	// 8289DC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289DC44: 485557E5  bl 0x82df3428
	ctx.lr = 0x8289DC48;
	sub_82DF3428(ctx, base);
	// 8289DC48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289DC4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8289DC50: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 8289DC54: 409A0008  bne cr6, 0x8289dc5c
	if !ctx.cr[6].eq {
	pc = 0x8289DC5C; continue 'dispatch;
	}
	// 8289DC58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289DC5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DC60: 4BC6AB41  bl 0x825087a0
	ctx.lr = 0x8289DC64;
	sub_825087A0(ctx, base);
	// 8289DC64: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289DC68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289DC6C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289DC70: 394BB210  addi r10, r11, -0x4df0
	ctx.r[10].s64 = ctx.r[11].s64 + -19952;
	// 8289DC74: 914100C8  stw r10, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 8289DC78: 817C0448  lwz r11, 0x448(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1096 as u32) ) } as u64;
	// 8289DC7C: 1D6B023C  mulli r11, r11, 0x23c
	ctx.r[11].s64 = ctx.r[11].s64 * 572;
	// 8289DC80: 7DEB5214  add r15, r11, r10
	ctx.r[15].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8289DC84: 4858CE65  bl 0x82e2aae8
	ctx.lr = 0x8289DC88;
	sub_82E2AAE8(ctx, base);
	// 8289DC88: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289DC8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289DC90: 38ABB1C8  addi r5, r11, -0x4e38
	ctx.r[5].s64 = ctx.r[11].s64 + -20024;
	// 8289DC94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8289DC98: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8289DC9C: 485911D5  bl 0x82e2ee70
	ctx.lr = 0x8289DCA0;
	sub_82E2EE70(ctx, base);
	// 8289DCA0: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 8289DCA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289DCA8: 409A0028  bne cr6, 0x8289dcd0
	if !ctx.cr[6].eq {
	pc = 0x8289DCD0; continue 'dispatch;
	}
	// 8289DCAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289DCB0: 4BC72921  bl 0x825105d0
	ctx.lr = 0x8289DCB4;
	sub_825105D0(ctx, base);
	// 8289DCB4: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 8289DCB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289DCBC: 419A0008  beq cr6, 0x8289dcc4
	if ctx.cr[6].eq {
	pc = 0x8289DCC4; continue 'dispatch;
	}
	// 8289DCC0: 4BA22BD1  bl 0x822c0890
	ctx.lr = 0x8289DCC4;
	sub_822C0890(ctx, base);
	// 8289DCC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289DCC8: 4858CE39  bl 0x82e2ab00
	ctx.lr = 0x8289DCCC;
	sub_82E2AB00(ctx, base);
	// 8289DCCC: 48001574  b 0x8289f240
	pc = 0x8289F240; continue 'dispatch;
	// 8289DCD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DCD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289DCD8: 3BAB8F18  addi r29, r11, -0x70e8
	ctx.r[29].s64 = ctx.r[11].s64 + -28904;
	// 8289DCDC: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 8289DCE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289DCE4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8289DCE8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8289DCEC: 485546FD  bl 0x82df23e8
	ctx.lr = 0x8289DCF0;
	sub_82DF23E8(ctx, base);
	// 8289DCF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289DCF4: 41820014  beq 0x8289dd08
	if ctx.cr[0].eq {
	pc = 0x8289DD08; continue 'dispatch;
	}
	// 8289DCF8: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 8289DCFC: 48578B95  bl 0x82e16890
	ctx.lr = 0x8289DD00;
	sub_82E16890(ctx, base);
	// 8289DD00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DD04: 48000008  b 0x8289dd0c
	pc = 0x8289DD0C; continue 'dispatch;
	// 8289DD08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289DD0C: 387C00EC  addi r3, r28, 0xec
	ctx.r[3].s64 = ctx.r[28].s64 + 236;
	// 8289DD10: 4BABF661  bl 0x8235d370
	ctx.lr = 0x8289DD14;
	sub_8235D370(ctx, base);
	// 8289DD14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289DD18: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8289DD1C: 83DC00EC  lwz r30, 0xec(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 8289DD20: 4820DFC9  bl 0x82aabce8
	ctx.lr = 0x8289DD24;
	sub_82AABCE8(ctx, base);
	// 8289DD24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DD28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DD2C: 48577385  bl 0x82e150b0
	ctx.lr = 0x8289DD30;
	sub_82E150B0(ctx, base);
	// 8289DD30: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 8289DD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289DD38: 419A0008  beq cr6, 0x8289dd40
	if ctx.cr[6].eq {
	pc = 0x8289DD40; continue 'dispatch;
	}
	// 8289DD3C: 4BA22B55  bl 0x822c0890
	ctx.lr = 0x8289DD40;
	sub_822C0890(ctx, base);
	// 8289DD40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289DD44: 4858CDBD  bl 0x82e2ab00
	ctx.lr = 0x8289DD48;
	sub_82E2AB00(ctx, base);
	// 8289DD48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289DD4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289DD50: 38A000CF  li r5, 0xcf
	ctx.r[5].s64 = 207;
	// 8289DD54: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8289DD58: 4BA22681  bl 0x822c03d8
	ctx.lr = 0x8289DD5C;
	sub_822C03D8(ctx, base);
	// 8289DD5C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8289DD60: 41820020  beq 0x8289dd80
	if ctx.cr[0].eq {
	pc = 0x8289DD80; continue 'dispatch;
	}
	// 8289DD64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DD68: 4BF4CF49  bl 0x827eacb0
	ctx.lr = 0x8289DD6C;
	sub_827EACB0(ctx, base);
	// 8289DD6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289DD70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289DD74: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 8289DD78: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289DD7C: 48000008  b 0x8289dd84
	pc = 0x8289DD84; continue 'dispatch;
	// 8289DD80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289DD84: 3BDC0400  addi r30, r28, 0x400
	ctx.r[30].s64 = ctx.r[28].s64 + 1024;
	// 8289DD88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289DD8C: 4BFCA4F5  bl 0x82868280
	ctx.lr = 0x8289DD90;
	sub_82868280(ctx, base);
	// 8289DD90: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289DD94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289DD98: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 8289DD9C: 837C0400  lwz r27, 0x400(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289DDA0: C3FC0370  lfs f31, 0x370(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289DDA4: 83ABF0AC  lwz r29, -0xf54(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3924 as u32) ) } as u64;
	// 8289DDA8: 4BC71721  bl 0x8250f4c8
	ctx.lr = 0x8289DDAC;
	sub_8250F4C8(ctx, base);
	// 8289DDAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289DDB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289DDB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8289DDB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8289DDBC: 4BF4CBAD  bl 0x827ea968
	ctx.lr = 0x8289DDC0;
	sub_827EA968(ctx, base);
	// 8289DDC0: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 8289DDC4: 48553ECD  bl 0x82df1c90
	ctx.lr = 0x8289DDC8;
	sub_82DF1C90(ctx, base);
	// 8289DDC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289DDCC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8289DDD0: 9BE1024C  stb r31, 0x24c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[31].u8 ) };
	// 8289DDD4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8289DDD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8289DDDC: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 8289DDE0: 3A6BF9A0  addi r19, r11, -0x660
	ctx.r[19].s64 = ctx.r[11].s64 + -1632;
	// 8289DDE4: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289DDE8: 39679158  addi r11, r7, -0x6ea8
	ctx.r[11].s64 = ctx.r[7].s64 + -28328;
	// 8289DDEC: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8289DDF0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8289DDF4: C3A89534  lfs f29, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8289DDF8: D3C10238  stfs f30, 0x238(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8289DDFC: 92610230  stw r19, 0x230(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(560 as u32), ctx.r[19].u32 ) };
	// 8289DE00: D3E10240  stfs f31, 0x240(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 8289DE04: 91610234  stw r11, 0x234(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 8289DE08: D3A10244  stfs f29, 0x244(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 8289DE0C: 93A1023C  stw r29, 0x23c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(572 as u32), ctx.r[29].u32 ) };
	// 8289DE10: D3A10248  stfs f29, 0x248(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(584 as u32), tmp.u32 ) };
	// 8289DE14: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 8289DE18: 48560AB1  bl 0x82dfe8c8
	ctx.lr = 0x8289DE1C;
	sub_82DFE8C8(ctx, base);
	// 8289DE1C: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 8289DE20: 48560AA9  bl 0x82dfe8c8
	ctx.lr = 0x8289DE24;
	sub_82DFE8C8(ctx, base);
	// 8289DE24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DE28: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DE2C: D3C10268  stfs f30, 0x268(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), tmp.u32 ) };
	// 8289DE30: 3B0B8DA4  addi r24, r11, -0x725c
	ctx.r[24].s64 = ctx.r[11].s64 + -29276;
	// 8289DE34: D3E10270  stfs f31, 0x270(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 8289DE38: 396A914C  addi r11, r10, -0x6eb4
	ctx.r[11].s64 = ctx.r[10].s64 + -28340;
	// 8289DE3C: D3A10274  stfs f29, 0x274(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), tmp.u32 ) };
	// 8289DE40: D3A10278  stfs f29, 0x278(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 8289DE44: 93010260  stw r24, 0x260(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), ctx.r[24].u32 ) };
	// 8289DE48: 91610264  stw r11, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 8289DE4C: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 8289DE50: 93A1026C  stw r29, 0x26c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[29].u32 ) };
	// 8289DE54: 9BE1027C  stb r31, 0x27c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(636 as u32), ctx.r[31].u8 ) };
	// 8289DE58: 48560A71  bl 0x82dfe8c8
	ctx.lr = 0x8289DE5C;
	sub_82DFE8C8(ctx, base);
	// 8289DE5C: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 8289DE60: 48560A69  bl 0x82dfe8c8
	ctx.lr = 0x8289DE64;
	sub_82DFE8C8(ctx, base);
	// 8289DE64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8289DE68: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DE6C: D3C10298  stfs f30, 0x298(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(664 as u32), tmp.u32 ) };
	// 8289DE70: 3AEB0380  addi r23, r11, 0x380
	ctx.r[23].s64 = ctx.r[11].s64 + 896;
	// 8289DE74: D3E102A0  stfs f31, 0x2a0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), tmp.u32 ) };
	// 8289DE78: 3B6A9140  addi r27, r10, -0x6ec0
	ctx.r[27].s64 = ctx.r[10].s64 + -28352;
	// 8289DE7C: D3A102A4  stfs f29, 0x2a4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), tmp.u32 ) };
	// 8289DE80: D3A102A8  stfs f29, 0x2a8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 8289DE84: 92E10290  stw r23, 0x290(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(656 as u32), ctx.r[23].u32 ) };
	// 8289DE88: 93610294  stw r27, 0x294(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), ctx.r[27].u32 ) };
	// 8289DE8C: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 8289DE90: 93E1029C  stw r31, 0x29c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(668 as u32), ctx.r[31].u32 ) };
	// 8289DE94: 9BE102AC  stb r31, 0x2ac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(684 as u32), ctx.r[31].u8 ) };
	// 8289DE98: 48560A31  bl 0x82dfe8c8
	ctx.lr = 0x8289DE9C;
	sub_82DFE8C8(ctx, base);
	// 8289DE9C: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 8289DEA0: 48560A29  bl 0x82dfe8c8
	ctx.lr = 0x8289DEA4;
	sub_82DFE8C8(ctx, base);
	// 8289DEA4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289DEA8: D3C102C8  stfs f30, 0x2c8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(712 as u32), tmp.u32 ) };
	// 8289DEAC: 93E102CC  stw r31, 0x2cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(716 as u32), ctx.r[31].u32 ) };
	// 8289DEB0: D3E102D0  stfs f31, 0x2d0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), tmp.u32 ) };
	// 8289DEB4: 936102C4  stw r27, 0x2c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(708 as u32), ctx.r[27].u32 ) };
	// 8289DEB8: D3A102D4  stfs f29, 0x2d4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(724 as u32), tmp.u32 ) };
	// 8289DEBC: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 8289DEC0: D3A102D8  stfs f29, 0x2d8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(728 as u32), tmp.u32 ) };
	// 8289DEC4: 816BF3F8  lwz r11, -0xc08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 8289DEC8: 9BE102DC  stb r31, 0x2dc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(732 as u32), ctx.r[31].u8 ) };
	// 8289DECC: 916102C0  stw r11, 0x2c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(704 as u32), ctx.r[11].u32 ) };
	// 8289DED0: 485609F9  bl 0x82dfe8c8
	ctx.lr = 0x8289DED4;
	sub_82DFE8C8(ctx, base);
	// 8289DED4: 386102E8  addi r3, r1, 0x2e8
	ctx.r[3].s64 = ctx.r[1].s64 + 744;
	// 8289DED8: 485609F1  bl 0x82dfe8c8
	ctx.lr = 0x8289DEDC;
	sub_82DFE8C8(ctx, base);
	// 8289DEDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DEE0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DEE4: D3C102F8  stfs f30, 0x2f8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(760 as u32), tmp.u32 ) };
	// 8289DEE8: 3B6B8FDC  addi r27, r11, -0x7024
	ctx.r[27].s64 = ctx.r[11].s64 + -28708;
	// 8289DEEC: D3E10300  stfs f31, 0x300(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(768 as u32), tmp.u32 ) };
	// 8289DEF0: 396A9130  addi r11, r10, -0x6ed0
	ctx.r[11].s64 = ctx.r[10].s64 + -28368;
	// 8289DEF4: D3A10304  stfs f29, 0x304(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(772 as u32), tmp.u32 ) };
	// 8289DEF8: D3A10308  stfs f29, 0x308(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(776 as u32), tmp.u32 ) };
	// 8289DEFC: 936102F0  stw r27, 0x2f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(752 as u32), ctx.r[27].u32 ) };
	// 8289DF00: 916102F4  stw r11, 0x2f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 8289DF04: 38610310  addi r3, r1, 0x310
	ctx.r[3].s64 = ctx.r[1].s64 + 784;
	// 8289DF08: 93A102FC  stw r29, 0x2fc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(764 as u32), ctx.r[29].u32 ) };
	// 8289DF0C: 9BE1030C  stb r31, 0x30c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(780 as u32), ctx.r[31].u8 ) };
	// 8289DF10: 485609B9  bl 0x82dfe8c8
	ctx.lr = 0x8289DF14;
	sub_82DFE8C8(ctx, base);
	// 8289DF14: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 8289DF18: 485609B1  bl 0x82dfe8c8
	ctx.lr = 0x8289DF1C;
	sub_82DFE8C8(ctx, base);
	// 8289DF1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DF20: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DF24: D3C10328  stfs f30, 0x328(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(808 as u32), tmp.u32 ) };
	// 8289DF28: 3B4B8FCC  addi r26, r11, -0x7034
	ctx.r[26].s64 = ctx.r[11].s64 + -28724;
	// 8289DF2C: D3E10330  stfs f31, 0x330(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(816 as u32), tmp.u32 ) };
	// 8289DF30: 396A9120  addi r11, r10, -0x6ee0
	ctx.r[11].s64 = ctx.r[10].s64 + -28384;
	// 8289DF34: D3A10334  stfs f29, 0x334(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), tmp.u32 ) };
	// 8289DF38: D3A10338  stfs f29, 0x338(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(824 as u32), tmp.u32 ) };
	// 8289DF3C: 93410320  stw r26, 0x320(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(800 as u32), ctx.r[26].u32 ) };
	// 8289DF40: 91610324  stw r11, 0x324(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(804 as u32), ctx.r[11].u32 ) };
	// 8289DF44: 38610340  addi r3, r1, 0x340
	ctx.r[3].s64 = ctx.r[1].s64 + 832;
	// 8289DF48: 93A1032C  stw r29, 0x32c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(812 as u32), ctx.r[29].u32 ) };
	// 8289DF4C: 9BE1033C  stb r31, 0x33c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(828 as u32), ctx.r[31].u8 ) };
	// 8289DF50: 48560979  bl 0x82dfe8c8
	ctx.lr = 0x8289DF54;
	sub_82DFE8C8(ctx, base);
	// 8289DF54: 38610348  addi r3, r1, 0x348
	ctx.r[3].s64 = ctx.r[1].s64 + 840;
	// 8289DF58: 48560971  bl 0x82dfe8c8
	ctx.lr = 0x8289DF5C;
	sub_82DFE8C8(ctx, base);
	// 8289DF5C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DF60: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DF64: D3C10358  stfs f30, 0x358(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(856 as u32), tmp.u32 ) };
	// 8289DF68: 3B2B8FBC  addi r25, r11, -0x7044
	ctx.r[25].s64 = ctx.r[11].s64 + -28740;
	// 8289DF6C: D3E10360  stfs f31, 0x360(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(864 as u32), tmp.u32 ) };
	// 8289DF70: 396A9110  addi r11, r10, -0x6ef0
	ctx.r[11].s64 = ctx.r[10].s64 + -28400;
	// 8289DF74: D3A10364  stfs f29, 0x364(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), tmp.u32 ) };
	// 8289DF78: D3A10368  stfs f29, 0x368(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), tmp.u32 ) };
	// 8289DF7C: 93210350  stw r25, 0x350(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(848 as u32), ctx.r[25].u32 ) };
	// 8289DF80: 91610354  stw r11, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[11].u32 ) };
	// 8289DF84: 38610370  addi r3, r1, 0x370
	ctx.r[3].s64 = ctx.r[1].s64 + 880;
	// 8289DF88: 93A1035C  stw r29, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[29].u32 ) };
	// 8289DF8C: 9BE1036C  stb r31, 0x36c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(876 as u32), ctx.r[31].u8 ) };
	// 8289DF90: 48560939  bl 0x82dfe8c8
	ctx.lr = 0x8289DF94;
	sub_82DFE8C8(ctx, base);
	// 8289DF94: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 8289DF98: 48560931  bl 0x82dfe8c8
	ctx.lr = 0x8289DF9C;
	sub_82DFE8C8(ctx, base);
	// 8289DF9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DFA0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DFA4: D3C10388  stfs f30, 0x388(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(904 as u32), tmp.u32 ) };
	// 8289DFA8: 3ACB9108  addi r22, r11, -0x6ef8
	ctx.r[22].s64 = ctx.r[11].s64 + -28408;
	// 8289DFAC: D3E10390  stfs f31, 0x390(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), tmp.u32 ) };
	// 8289DFB0: 396A90F4  addi r11, r10, -0x6f0c
	ctx.r[11].s64 = ctx.r[10].s64 + -28428;
	// 8289DFB4: D3A10394  stfs f29, 0x394(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 8289DFB8: D3A10398  stfs f29, 0x398(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 8289DFBC: 92C10380  stw r22, 0x380(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(896 as u32), ctx.r[22].u32 ) };
	// 8289DFC0: 91610384  stw r11, 0x384(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 8289DFC4: 386103A0  addi r3, r1, 0x3a0
	ctx.r[3].s64 = ctx.r[1].s64 + 928;
	// 8289DFC8: 93A1038C  stw r29, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[29].u32 ) };
	// 8289DFCC: 9BE1039C  stb r31, 0x39c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[31].u8 ) };
	// 8289DFD0: 485608F9  bl 0x82dfe8c8
	ctx.lr = 0x8289DFD4;
	sub_82DFE8C8(ctx, base);
	// 8289DFD4: 386103A8  addi r3, r1, 0x3a8
	ctx.r[3].s64 = ctx.r[1].s64 + 936;
	// 8289DFD8: 485608F1  bl 0x82dfe8c8
	ctx.lr = 0x8289DFDC;
	sub_82DFE8C8(ctx, base);
	// 8289DFDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289DFE0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289DFE4: D3C103B8  stfs f30, 0x3b8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(952 as u32), tmp.u32 ) };
	// 8289DFE8: 3AAB90E8  addi r21, r11, -0x6f18
	ctx.r[21].s64 = ctx.r[11].s64 + -28440;
	// 8289DFEC: D3E103C0  stfs f31, 0x3c0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(960 as u32), tmp.u32 ) };
	// 8289DFF0: 396A90D4  addi r11, r10, -0x6f2c
	ctx.r[11].s64 = ctx.r[10].s64 + -28460;
	// 8289DFF4: D3A103C4  stfs f29, 0x3c4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(964 as u32), tmp.u32 ) };
	// 8289DFF8: D3A103C8  stfs f29, 0x3c8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(968 as u32), tmp.u32 ) };
	// 8289DFFC: 92A103B0  stw r21, 0x3b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(944 as u32), ctx.r[21].u32 ) };
	// 8289E000: 916103B4  stw r11, 0x3b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(948 as u32), ctx.r[11].u32 ) };
	// 8289E004: 386103D0  addi r3, r1, 0x3d0
	ctx.r[3].s64 = ctx.r[1].s64 + 976;
	// 8289E008: 93A103BC  stw r29, 0x3bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(956 as u32), ctx.r[29].u32 ) };
	// 8289E00C: 9BE103CC  stb r31, 0x3cc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(972 as u32), ctx.r[31].u8 ) };
	// 8289E010: 485608B9  bl 0x82dfe8c8
	ctx.lr = 0x8289E014;
	sub_82DFE8C8(ctx, base);
	// 8289E014: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 8289E018: 485608B1  bl 0x82dfe8c8
	ctx.lr = 0x8289E01C;
	sub_82DFE8C8(ctx, base);
	// 8289E01C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E020: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E024: D3C103E8  stfs f30, 0x3e8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1000 as u32), tmp.u32 ) };
	// 8289E028: 3A8B90C8  addi r20, r11, -0x6f38
	ctx.r[20].s64 = ctx.r[11].s64 + -28472;
	// 8289E02C: D3E103F0  stfs f31, 0x3f0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1008 as u32), tmp.u32 ) };
	// 8289E030: 396A90B4  addi r11, r10, -0x6f4c
	ctx.r[11].s64 = ctx.r[10].s64 + -28492;
	// 8289E034: D3A103F4  stfs f29, 0x3f4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1012 as u32), tmp.u32 ) };
	// 8289E038: D3A103F8  stfs f29, 0x3f8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1016 as u32), tmp.u32 ) };
	// 8289E03C: 928103E0  stw r20, 0x3e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(992 as u32), ctx.r[20].u32 ) };
	// 8289E040: 916103E4  stw r11, 0x3e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(996 as u32), ctx.r[11].u32 ) };
	// 8289E044: 38610400  addi r3, r1, 0x400
	ctx.r[3].s64 = ctx.r[1].s64 + 1024;
	// 8289E048: 93A103EC  stw r29, 0x3ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1004 as u32), ctx.r[29].u32 ) };
	// 8289E04C: 9BE103FC  stb r31, 0x3fc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1020 as u32), ctx.r[31].u8 ) };
	// 8289E050: 48560879  bl 0x82dfe8c8
	ctx.lr = 0x8289E054;
	sub_82DFE8C8(ctx, base);
	// 8289E054: 38610408  addi r3, r1, 0x408
	ctx.r[3].s64 = ctx.r[1].s64 + 1032;
	// 8289E058: 48560871  bl 0x82dfe8c8
	ctx.lr = 0x8289E05C;
	sub_82DFE8C8(ctx, base);
	// 8289E05C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E060: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E064: D3C10418  stfs f30, 0x418(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1048 as u32), tmp.u32 ) };
	// 8289E068: 3A4B8E40  addi r18, r11, -0x71c0
	ctx.r[18].s64 = ctx.r[11].s64 + -29120;
	// 8289E06C: D3E10420  stfs f31, 0x420(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 8289E070: 39CA90A8  addi r14, r10, -0x6f58
	ctx.r[14].s64 = ctx.r[10].s64 + -28504;
	// 8289E074: D3A10424  stfs f29, 0x424(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 8289E078: D3A10428  stfs f29, 0x428(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 8289E07C: 92410410  stw r18, 0x410(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1040 as u32), ctx.r[18].u32 ) };
	// 8289E080: 91C10414  stw r14, 0x414(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1044 as u32), ctx.r[14].u32 ) };
	// 8289E084: 38610430  addi r3, r1, 0x430
	ctx.r[3].s64 = ctx.r[1].s64 + 1072;
	// 8289E088: 93A1041C  stw r29, 0x41c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1052 as u32), ctx.r[29].u32 ) };
	// 8289E08C: 9BE1042C  stb r31, 0x42c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1068 as u32), ctx.r[31].u8 ) };
	// 8289E090: 48560839  bl 0x82dfe8c8
	ctx.lr = 0x8289E094;
	sub_82DFE8C8(ctx, base);
	// 8289E094: 38610438  addi r3, r1, 0x438
	ctx.r[3].s64 = ctx.r[1].s64 + 1080;
	// 8289E098: 48560831  bl 0x82dfe8c8
	ctx.lr = 0x8289E09C;
	sub_82DFE8C8(ctx, base);
	// 8289E09C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E0A0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E0A4: D3C10448  stfs f30, 0x448(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1096 as u32), tmp.u32 ) };
	// 8289E0A8: 3A2B8E64  addi r17, r11, -0x719c
	ctx.r[17].s64 = ctx.r[11].s64 + -29084;
	// 8289E0AC: D3E10450  stfs f31, 0x450(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1104 as u32), tmp.u32 ) };
	// 8289E0B0: 396A9098  addi r11, r10, -0x6f68
	ctx.r[11].s64 = ctx.r[10].s64 + -28520;
	// 8289E0B4: D3A10454  stfs f29, 0x454(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1108 as u32), tmp.u32 ) };
	// 8289E0B8: D3A10458  stfs f29, 0x458(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 8289E0BC: 92210440  stw r17, 0x440(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1088 as u32), ctx.r[17].u32 ) };
	// 8289E0C0: 91610444  stw r11, 0x444(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1092 as u32), ctx.r[11].u32 ) };
	// 8289E0C4: 38610460  addi r3, r1, 0x460
	ctx.r[3].s64 = ctx.r[1].s64 + 1120;
	// 8289E0C8: 93A1044C  stw r29, 0x44c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1100 as u32), ctx.r[29].u32 ) };
	// 8289E0CC: 9BE1045C  stb r31, 0x45c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[31].u8 ) };
	// 8289E0D0: 485607F9  bl 0x82dfe8c8
	ctx.lr = 0x8289E0D4;
	sub_82DFE8C8(ctx, base);
	// 8289E0D4: 38610468  addi r3, r1, 0x468
	ctx.r[3].s64 = ctx.r[1].s64 + 1128;
	// 8289E0D8: 485607F1  bl 0x82dfe8c8
	ctx.lr = 0x8289E0DC;
	sub_82DFE8C8(ctx, base);
	// 8289E0DC: 3E00832D  lis r16, -0x7cd3
	ctx.r[16].s64 = -2094202880;
	// 8289E0E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E0E4: D3C10478  stfs f30, 0x478(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1144 as u32), tmp.u32 ) };
	// 8289E0E8: D3E10480  stfs f31, 0x480(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1152 as u32), tmp.u32 ) };
	// 8289E0EC: 93E1047C  stw r31, 0x47c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1148 as u32), ctx.r[31].u32 ) };
	// 8289E0F0: 394B9084  addi r10, r11, -0x6f7c
	ctx.r[10].s64 = ctx.r[11].s64 + -28540;
	// 8289E0F4: D3A10484  stfs f29, 0x484(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1156 as u32), tmp.u32 ) };
	// 8289E0F8: D3A10488  stfs f29, 0x488(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), tmp.u32 ) };
	// 8289E0FC: 9BE1048C  stb r31, 0x48c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1164 as u32), ctx.r[31].u8 ) };
	// 8289E100: 91410474  stw r10, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[10].u32 ) };
	// 8289E104: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 8289E108: 8170F468  lwz r11, -0xb98(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 8289E10C: 91610470  stw r11, 0x470(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1136 as u32), ctx.r[11].u32 ) };
	// 8289E110: 485607B9  bl 0x82dfe8c8
	ctx.lr = 0x8289E114;
	sub_82DFE8C8(ctx, base);
	// 8289E114: 38610498  addi r3, r1, 0x498
	ctx.r[3].s64 = ctx.r[1].s64 + 1176;
	// 8289E118: 485607B1  bl 0x82dfe8c8
	ctx.lr = 0x8289E11C;
	sub_82DFE8C8(ctx, base);
	// 8289E11C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289E120: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E124: D3C104A8  stfs f30, 0x4a8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1192 as u32), tmp.u32 ) };
	// 8289E128: 396BE814  addi r11, r11, -0x17ec
	ctx.r[11].s64 = ctx.r[11].s64 + -6124;
	// 8289E12C: D3E104B0  stfs f31, 0x4b0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1200 as u32), tmp.u32 ) };
	// 8289E130: 394A9078  addi r10, r10, -0x6f88
	ctx.r[10].s64 = ctx.r[10].s64 + -28552;
	// 8289E134: D3A104B4  stfs f29, 0x4b4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1204 as u32), tmp.u32 ) };
	// 8289E138: D3A104B8  stfs f29, 0x4b8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1208 as u32), tmp.u32 ) };
	// 8289E13C: 916104A0  stw r11, 0x4a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1184 as u32), ctx.r[11].u32 ) };
	// 8289E140: 914104A4  stw r10, 0x4a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1188 as u32), ctx.r[10].u32 ) };
	// 8289E144: 386104C0  addi r3, r1, 0x4c0
	ctx.r[3].s64 = ctx.r[1].s64 + 1216;
	// 8289E148: 93A104AC  stw r29, 0x4ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1196 as u32), ctx.r[29].u32 ) };
	// 8289E14C: 9BE104BC  stb r31, 0x4bc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1212 as u32), ctx.r[31].u8 ) };
	// 8289E150: 48560779  bl 0x82dfe8c8
	ctx.lr = 0x8289E154;
	sub_82DFE8C8(ctx, base);
	// 8289E154: 386104C8  addi r3, r1, 0x4c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1224;
	// 8289E158: 48560771  bl 0x82dfe8c8
	ctx.lr = 0x8289E15C;
	sub_82DFE8C8(ctx, base);
	// 8289E15C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289E160: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E164: D3C104D8  stfs f30, 0x4d8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1240 as u32), tmp.u32 ) };
	// 8289E168: D3E104E0  stfs f31, 0x4e0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1248 as u32), tmp.u32 ) };
	// 8289E16C: 93A104DC  stw r29, 0x4dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1244 as u32), ctx.r[29].u32 ) };
	// 8289E170: 394A9068  addi r10, r10, -0x6f98
	ctx.r[10].s64 = ctx.r[10].s64 + -28568;
	// 8289E174: D3A104E4  stfs f29, 0x4e4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1252 as u32), tmp.u32 ) };
	// 8289E178: D3A104E8  stfs f29, 0x4e8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1256 as u32), tmp.u32 ) };
	// 8289E17C: 9BE104EC  stb r31, 0x4ec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1260 as u32), ctx.r[31].u8 ) };
	// 8289E180: 914104D4  stw r10, 0x4d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1236 as u32), ctx.r[10].u32 ) };
	// 8289E184: 386104F0  addi r3, r1, 0x4f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1264;
	// 8289E188: 816BF474  lwz r11, -0xb8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2956 as u32) ) } as u64;
	// 8289E18C: 916104D0  stw r11, 0x4d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1232 as u32), ctx.r[11].u32 ) };
	// 8289E190: 48560739  bl 0x82dfe8c8
	ctx.lr = 0x8289E194;
	sub_82DFE8C8(ctx, base);
	// 8289E194: 386104F8  addi r3, r1, 0x4f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1272;
	// 8289E198: 48560731  bl 0x82dfe8c8
	ctx.lr = 0x8289E19C;
	sub_82DFE8C8(ctx, base);
	// 8289E19C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289E1A0: D3C10508  stfs f30, 0x508(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1288 as u32), tmp.u32 ) };
	// 8289E1A4: 93A1050C  stw r29, 0x50c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1292 as u32), ctx.r[29].u32 ) };
	// 8289E1A8: D3E10510  stfs f31, 0x510(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1296 as u32), tmp.u32 ) };
	// 8289E1AC: 91C10504  stw r14, 0x504(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1284 as u32), ctx.r[14].u32 ) };
	// 8289E1B0: D3A10514  stfs f29, 0x514(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1300 as u32), tmp.u32 ) };
	// 8289E1B4: 9BE1051C  stb r31, 0x51c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1308 as u32), ctx.r[31].u8 ) };
	// 8289E1B8: D3A10518  stfs f29, 0x518(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1304 as u32), tmp.u32 ) };
	// 8289E1BC: 38610520  addi r3, r1, 0x520
	ctx.r[3].s64 = ctx.r[1].s64 + 1312;
	// 8289E1C0: 816BF46C  lwz r11, -0xb94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2964 as u32) ) } as u64;
	// 8289E1C4: 91610500  stw r11, 0x500(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1280 as u32), ctx.r[11].u32 ) };
	// 8289E1C8: 48560701  bl 0x82dfe8c8
	ctx.lr = 0x8289E1CC;
	sub_82DFE8C8(ctx, base);
	// 8289E1CC: 38610528  addi r3, r1, 0x528
	ctx.r[3].s64 = ctx.r[1].s64 + 1320;
	// 8289E1D0: 485606F9  bl 0x82dfe8c8
	ctx.lr = 0x8289E1D4;
	sub_82DFE8C8(ctx, base);
	// 8289E1D4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289E1D8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E1DC: D3C10538  stfs f30, 0x538(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1336 as u32), tmp.u32 ) };
	// 8289E1E0: D3E10540  stfs f31, 0x540(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1344 as u32), tmp.u32 ) };
	// 8289E1E4: 93E1053C  stw r31, 0x53c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1340 as u32), ctx.r[31].u32 ) };
	// 8289E1E8: 394A905C  addi r10, r10, -0x6fa4
	ctx.r[10].s64 = ctx.r[10].s64 + -28580;
	// 8289E1EC: D3A10544  stfs f29, 0x544(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1348 as u32), tmp.u32 ) };
	// 8289E1F0: D3A10548  stfs f29, 0x548(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1352 as u32), tmp.u32 ) };
	// 8289E1F4: 9BE1054C  stb r31, 0x54c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1356 as u32), ctx.r[31].u8 ) };
	// 8289E1F8: 91410534  stw r10, 0x534(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1332 as u32), ctx.r[10].u32 ) };
	// 8289E1FC: 38610550  addi r3, r1, 0x550
	ctx.r[3].s64 = ctx.r[1].s64 + 1360;
	// 8289E200: 816BF470  lwz r11, -0xb90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 8289E204: 91610530  stw r11, 0x530(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1328 as u32), ctx.r[11].u32 ) };
	// 8289E208: 485606C1  bl 0x82dfe8c8
	ctx.lr = 0x8289E20C;
	sub_82DFE8C8(ctx, base);
	// 8289E20C: 38610558  addi r3, r1, 0x558
	ctx.r[3].s64 = ctx.r[1].s64 + 1368;
	// 8289E210: 485606B9  bl 0x82dfe8c8
	ctx.lr = 0x8289E214;
	sub_82DFE8C8(ctx, base);
	// 8289E214: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289E218: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289E21C: D3C10568  stfs f30, 0x568(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1384 as u32), tmp.u32 ) };
	// 8289E220: D3E10570  stfs f31, 0x570(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1392 as u32), tmp.u32 ) };
	// 8289E224: 93A1056C  stw r29, 0x56c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1388 as u32), ctx.r[29].u32 ) };
	// 8289E228: 394A9050  addi r10, r10, -0x6fb0
	ctx.r[10].s64 = ctx.r[10].s64 + -28592;
	// 8289E22C: D3A10574  stfs f29, 0x574(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1396 as u32), tmp.u32 ) };
	// 8289E230: D3A10578  stfs f29, 0x578(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1400 as u32), tmp.u32 ) };
	// 8289E234: 9BE1057C  stb r31, 0x57c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1404 as u32), ctx.r[31].u8 ) };
	// 8289E238: 91410564  stw r10, 0x564(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1380 as u32), ctx.r[10].u32 ) };
	// 8289E23C: 38610580  addi r3, r1, 0x580
	ctx.r[3].s64 = ctx.r[1].s64 + 1408;
	// 8289E240: 816BF484  lwz r11, -0xb7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2940 as u32) ) } as u64;
	// 8289E244: 91610560  stw r11, 0x560(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1376 as u32), ctx.r[11].u32 ) };
	// 8289E248: 48560681  bl 0x82dfe8c8
	ctx.lr = 0x8289E24C;
	sub_82DFE8C8(ctx, base);
	// 8289E24C: 38610588  addi r3, r1, 0x588
	ctx.r[3].s64 = ctx.r[1].s64 + 1416;
	// 8289E250: 48560679  bl 0x82dfe8c8
	ctx.lr = 0x8289E254;
	sub_82DFE8C8(ctx, base);
	// 8289E254: 38A00012  li r5, 0x12
	ctx.r[5].s64 = 18;
	// 8289E258: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 8289E25C: 807C0400  lwz r3, 0x400(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1024 as u32) ) } as u64;
	// 8289E260: 4BF4C461  bl 0x827ea6c0
	ctx.lr = 0x8289E264;
	sub_827EA6C0(ctx, base);
	// 8289E264: 81C10050  lwz r14, 0x50(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289E268: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E26C: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289E270: 38A000EA  li r5, 0xea
	ctx.r[5].s64 = 234;
	// 8289E274: 38600198  li r3, 0x198
	ctx.r[3].s64 = 408;
	// 8289E278: 48554171  bl 0x82df23e8
	ctx.lr = 0x8289E27C;
	sub_82DF23E8(ctx, base);
	// 8289E27C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289E280: 41820010  beq 0x8289e290
	if ctx.cr[0].eq {
	pc = 0x8289E290; continue 'dispatch;
	}
	// 8289E284: 4BA60DF5  bl 0x822ff078
	ctx.lr = 0x8289E288;
	sub_822FF078(ctx, base);
	// 8289E288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289E28C: 48000008  b 0x8289e294
	pc = 0x8289E294; continue 'dispatch;
	// 8289E290: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289E294: 3BBC0408  addi r29, r28, 0x408
	ctx.r[29].s64 = ctx.r[28].s64 + 1032;
	// 8289E298: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289E29C: 4BFFD435  bl 0x8289b6d0
	ctx.lr = 0x8289E2A0;
	sub_8289B6D0(ctx, base);
	// 8289E2A0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8289E2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2A8: 48555761  bl 0x82df3a08
	ctx.lr = 0x8289E2AC;
	sub_82DF3A08(ctx, base);
	// 8289E2AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E2B0: 807C0408  lwz r3, 0x408(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8289E2B4: 4BA60D0D  bl 0x822fefc0
	ctx.lr = 0x8289E2B8;
	sub_822FEFC0(ctx, base);
	// 8289E2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2BC: 4855516D  bl 0x82df3428
	ctx.lr = 0x8289E2C0;
	sub_82DF3428(ctx, base);
	// 8289E2C0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8289E2C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2C8: 48555741  bl 0x82df3a08
	ctx.lr = 0x8289E2CC;
	sub_82DF3A08(ctx, base);
	// 8289E2CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E2D0: 807C0408  lwz r3, 0x408(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8289E2D4: 4BA60CED  bl 0x822fefc0
	ctx.lr = 0x8289E2D8;
	sub_822FEFC0(ctx, base);
	// 8289E2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2DC: 4855514D  bl 0x82df3428
	ctx.lr = 0x8289E2E0;
	sub_82DF3428(ctx, base);
	// 8289E2E0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8289E2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2E8: 48555721  bl 0x82df3a08
	ctx.lr = 0x8289E2EC;
	sub_82DF3A08(ctx, base);
	// 8289E2EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E2F0: 807C0408  lwz r3, 0x408(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8289E2F4: 4BA60CCD  bl 0x822fefc0
	ctx.lr = 0x8289E2F8;
	sub_822FEFC0(ctx, base);
	// 8289E2F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E2FC: 4855512D  bl 0x82df3428
	ctx.lr = 0x8289E300;
	sub_82DF3428(ctx, base);
	// 8289E300: 817C040C  lwz r11, 0x40c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1036 as u32) ) } as u64;
	// 8289E304: 815C0408  lwz r10, 0x408(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8289E308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289E30C: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8289E310: 914100C0  stw r10, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 8289E314: 419A0024  beq cr6, 0x8289e338
	if ctx.cr[6].eq {
	pc = 0x8289E338; continue 'dispatch;
	}
	// 8289E318: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289E31C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289E320: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289E324: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289E328: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289E32C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289E330: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289E334: 4082FFE8  bne 0x8289e31c
	if !ctx.cr[0].eq {
	pc = 0x8289E31C; continue 'dispatch;
	}
	// 8289E338: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E33C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E340: 3ACB8E08  addi r22, r11, -0x71f8
	ctx.r[22].s64 = ctx.r[11].s64 + -29176;
	// 8289E344: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8289E348: 485556C1  bl 0x82df3a08
	ctx.lr = 0x8289E34C;
	sub_82DF3A08(ctx, base);
	// 8289E34C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 8289E350: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E354: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E358: 4BF4BE29  bl 0x827ea180
	ctx.lr = 0x8289E35C;
	sub_827EA180(ctx, base);
	// 8289E35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E360: 485550C9  bl 0x82df3428
	ctx.lr = 0x8289E364;
	sub_82DF3428(ctx, base);
	// 8289E364: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 8289E368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289E36C: 419A0008  beq cr6, 0x8289e374
	if ctx.cr[6].eq {
	pc = 0x8289E374; continue 'dispatch;
	}
	// 8289E370: 4BA22521  bl 0x822c0890
	ctx.lr = 0x8289E374;
	sub_822C0890(ctx, base);
	// 8289E374: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 8289E378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E37C: 4855568D  bl 0x82df3a08
	ctx.lr = 0x8289E380;
	sub_82DF3A08(ctx, base);
	// 8289E380: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E384: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E388: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E38C: 3AAB895C  addi r21, r11, -0x76a4
	ctx.r[21].s64 = ctx.r[11].s64 + -30372;
	// 8289E390: C3AB895C  lfs f29, -0x76a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30372 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8289E394: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E398: 4BF4BFA1  bl 0x827ea338
	ctx.lr = 0x8289E39C;
	sub_827EA338(ctx, base);
	// 8289E39C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3A0: 48555089  bl 0x82df3428
	ctx.lr = 0x8289E3A4;
	sub_82DF3428(ctx, base);
	// 8289E3A4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8289E3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3AC: 4855565D  bl 0x82df3a08
	ctx.lr = 0x8289E3B0;
	sub_82DF3A08(ctx, base);
	// 8289E3B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E3B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E3B8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E3BC: 4BF4BF7D  bl 0x827ea338
	ctx.lr = 0x8289E3C0;
	sub_827EA338(ctx, base);
	// 8289E3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3C4: 48555065  bl 0x82df3428
	ctx.lr = 0x8289E3C8;
	sub_82DF3428(ctx, base);
	// 8289E3C8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8289E3CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3D0: 48555639  bl 0x82df3a08
	ctx.lr = 0x8289E3D4;
	sub_82DF3A08(ctx, base);
	// 8289E3D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E3D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E3DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289E3E0: 4BF4BF59  bl 0x827ea338
	ctx.lr = 0x8289E3E4;
	sub_827EA338(ctx, base);
	// 8289E3E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3E8: 48555041  bl 0x82df3428
	ctx.lr = 0x8289E3EC;
	sub_82DF3428(ctx, base);
	// 8289E3EC: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 8289E3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E3F4: 48555615  bl 0x82df3a08
	ctx.lr = 0x8289E3F8;
	sub_82DF3A08(ctx, base);
	// 8289E3F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289E3FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E400: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E404: C3AB6150  lfs f29, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8289E408: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E40C: 4BF4BF2D  bl 0x827ea338
	ctx.lr = 0x8289E410;
	sub_827EA338(ctx, base);
	// 8289E410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E414: 48555015  bl 0x82df3428
	ctx.lr = 0x8289E418;
	sub_82DF3428(ctx, base);
	// 8289E418: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E420: 485555E9  bl 0x82df3a08
	ctx.lr = 0x8289E424;
	sub_82DF3A08(ctx, base);
	// 8289E424: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E428: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E42C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E430: 4BF4BF09  bl 0x827ea338
	ctx.lr = 0x8289E434;
	sub_827EA338(ctx, base);
	// 8289E434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E438: 48554FF1  bl 0x82df3428
	ctx.lr = 0x8289E43C;
	sub_82DF3428(ctx, base);
	// 8289E43C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8289E440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E444: 485555C5  bl 0x82df3a08
	ctx.lr = 0x8289E448;
	sub_82DF3A08(ctx, base);
	// 8289E448: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E44C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E450: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E454: 4BF4BEE5  bl 0x827ea338
	ctx.lr = 0x8289E458;
	sub_827EA338(ctx, base);
	// 8289E458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E45C: 48554FCD  bl 0x82df3428
	ctx.lr = 0x8289E460;
	sub_82DF3428(ctx, base);
	// 8289E460: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8289E464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E468: 485555A1  bl 0x82df3a08
	ctx.lr = 0x8289E46C;
	sub_82DF3A08(ctx, base);
	// 8289E46C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E470: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E474: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E478: 4BF4BEC1  bl 0x827ea338
	ctx.lr = 0x8289E47C;
	sub_827EA338(ctx, base);
	// 8289E47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E480: 48554FA9  bl 0x82df3428
	ctx.lr = 0x8289E484;
	sub_82DF3428(ctx, base);
	// 8289E484: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8289E488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E48C: 4855557D  bl 0x82df3a08
	ctx.lr = 0x8289E490;
	sub_82DF3A08(ctx, base);
	// 8289E490: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E494: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E498: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E49C: 4BF4BE9D  bl 0x827ea338
	ctx.lr = 0x8289E4A0;
	sub_827EA338(ctx, base);
	// 8289E4A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4A4: 48554F85  bl 0x82df3428
	ctx.lr = 0x8289E4A8;
	sub_82DF3428(ctx, base);
	// 8289E4A8: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 8289E4AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4B0: 48555559  bl 0x82df3a08
	ctx.lr = 0x8289E4B4;
	sub_82DF3A08(ctx, base);
	// 8289E4B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E4B8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E4BC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E4C0: 4BF4BE79  bl 0x827ea338
	ctx.lr = 0x8289E4C4;
	sub_827EA338(ctx, base);
	// 8289E4C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4C8: 48554F61  bl 0x82df3428
	ctx.lr = 0x8289E4CC;
	sub_82DF3428(ctx, base);
	// 8289E4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4D0: 8090F468  lwz r4, -0xb98(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 8289E4D4: 48555535  bl 0x82df3a08
	ctx.lr = 0x8289E4D8;
	sub_82DF3A08(ctx, base);
	// 8289E4D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E4DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E4E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E4E4: C02B9F78  lfs f1, -0x6088(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E4E8: 4BF4BE51  bl 0x827ea338
	ctx.lr = 0x8289E4EC;
	sub_827EA338(ctx, base);
	// 8289E4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4F0: 48554F39  bl 0x82df3428
	ctx.lr = 0x8289E4F4;
	sub_82DF3428(ctx, base);
	// 8289E4F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E4FC: 4855550D  bl 0x82df3a08
	ctx.lr = 0x8289E500;
	sub_82DF3A08(ctx, base);
	// 8289E500: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E504: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289E508: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E50C: 386F0130  addi r3, r15, 0x130
	ctx.r[3].s64 = ctx.r[15].s64 + 304;
	// 8289E510: 480B9649  bl 0x82957b58
	ctx.lr = 0x8289E514;
	sub_82957B58(ctx, base);
	// 8289E514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E518: 48554F11  bl 0x82df3428
	ctx.lr = 0x8289E51C;
	sub_82DF3428(ctx, base);
	// 8289E51C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8289E520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E524: 485554E5  bl 0x82df3a08
	ctx.lr = 0x8289E528;
	sub_82DF3A08(ctx, base);
	// 8289E528: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E52C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289E530: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E534: 386F01F0  addi r3, r15, 0x1f0
	ctx.r[3].s64 = ctx.r[15].s64 + 496;
	// 8289E538: 480B9621  bl 0x82957b58
	ctx.lr = 0x8289E53C;
	sub_82957B58(ctx, base);
	// 8289E53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E540: 48554EE9  bl 0x82df3428
	ctx.lr = 0x8289E544;
	sub_82DF3428(ctx, base);
	// 8289E544: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8289E548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E54C: 485554BD  bl 0x82df3a08
	ctx.lr = 0x8289E550;
	sub_82DF3A08(ctx, base);
	// 8289E550: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E554: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289E558: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E55C: 386F01B0  addi r3, r15, 0x1b0
	ctx.r[3].s64 = ctx.r[15].s64 + 432;
	// 8289E560: 480B95F9  bl 0x82957b58
	ctx.lr = 0x8289E564;
	sub_82957B58(ctx, base);
	// 8289E564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E568: 48554EC1  bl 0x82df3428
	ctx.lr = 0x8289E56C;
	sub_82DF3428(ctx, base);
	// 8289E56C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8289E570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E574: 48555495  bl 0x82df3a08
	ctx.lr = 0x8289E578;
	sub_82DF3A08(ctx, base);
	// 8289E578: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E57C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8289E580: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E584: 386F0170  addi r3, r15, 0x170
	ctx.r[3].s64 = ctx.r[15].s64 + 368;
	// 8289E588: 480B95D1  bl 0x82957b58
	ctx.lr = 0x8289E58C;
	sub_82957B58(ctx, base);
	// 8289E58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E590: 48554E99  bl 0x82df3428
	ctx.lr = 0x8289E594;
	sub_82DF3428(ctx, base);
	// 8289E594: 809C00EC  lwz r4, 0xec(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 8289E598: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E59C: 3ADC00EC  addi r22, r28, 0xec
	ctx.r[22].s64 = ctx.r[28].s64 + 236;
	// 8289E5A0: 4BF4C129  bl 0x827ea6c8
	ctx.lr = 0x8289E5A4;
	sub_827EA6C8(ctx, base);
	// 8289E5A4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E5A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E5AC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E5B0: 396B8BD8  addi r11, r11, -0x7428
	ctx.r[11].s64 = ctx.r[11].s64 + -29736;
	// 8289E5B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E5B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E5BC: 4855544D  bl 0x82df3a08
	ctx.lr = 0x8289E5C0;
	sub_82DF3A08(ctx, base);
	// 8289E5C0: C0150004  lfs f0, 4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289E5C4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8289E5C8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289E5CC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289E5D0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8289E5D4: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8289E5D8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E5DC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8289E5E0: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8289E5E4: 4BFFF50D  bl 0x8289daf0
	ctx.lr = 0x8289E5E8;
	sub_8289DAF0(ctx, base);
	// 8289E5E8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8289E5EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E5F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E5F4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8289E5F8: 4BF4C1B9  bl 0x827ea7b0
	ctx.lr = 0x8289E5FC;
	sub_827EA7B0(ctx, base);
	// 8289E5FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E600: 48554E29  bl 0x82df3428
	ctx.lr = 0x8289E604;
	sub_82DF3428(ctx, base);
	// 8289E604: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E608: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E60C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E610: 396B8538  addi r11, r11, -0x7ac8
	ctx.r[11].s64 = ctx.r[11].s64 + -31432;
	// 8289E614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E618: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E61C: 485553ED  bl 0x82df3a08
	ctx.lr = 0x8289E620;
	sub_82DF3A08(ctx, base);
	// 8289E620: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E624: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E628: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E62C: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E630: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E634: 4BFFF53D  bl 0x8289db70
	ctx.lr = 0x8289E638;
	sub_8289DB70(ctx, base);
	// 8289E638: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E63C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E640: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E644: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E648: C02BDF2C  lfs f1, -0x20d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8404 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E64C: 4BF4C165  bl 0x827ea7b0
	ctx.lr = 0x8289E650;
	sub_827EA7B0(ctx, base);
	// 8289E650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E654: 48554DD5  bl 0x82df3428
	ctx.lr = 0x8289E658;
	sub_82DF3428(ctx, base);
	// 8289E658: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E65C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E660: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E664: 396B8BD8  addi r11, r11, -0x7428
	ctx.r[11].s64 = ctx.r[11].s64 + -29736;
	// 8289E668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E66C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E670: 48555399  bl 0x82df3a08
	ctx.lr = 0x8289E674;
	sub_82DF3A08(ctx, base);
	// 8289E674: D3C10060  stfs f30, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8289E678: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289E67C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E680: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8289E684: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8289E688: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E68C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8289E690: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E694: 4BFFF45D  bl 0x8289daf0
	ctx.lr = 0x8289E698;
	sub_8289DAF0(ctx, base);
	// 8289E698: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E69C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E6A0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E6A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E6A8: C02B1678  lfs f1, 0x1678(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5752 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E6AC: 4BF4C105  bl 0x827ea7b0
	ctx.lr = 0x8289E6B0;
	sub_827EA7B0(ctx, base);
	// 8289E6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E6B4: 48554D75  bl 0x82df3428
	ctx.lr = 0x8289E6B8;
	sub_82DF3428(ctx, base);
	// 8289E6B8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E6BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E6C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E6C4: 396B8528  addi r11, r11, -0x7ad8
	ctx.r[11].s64 = ctx.r[11].s64 + -31448;
	// 8289E6C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E6CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E6D0: 48555339  bl 0x82df3a08
	ctx.lr = 0x8289E6D4;
	sub_82DF3A08(ctx, base);
	// 8289E6D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E6D8: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E6DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E6E0: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E6E4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E6E8: 4BFFF489  bl 0x8289db70
	ctx.lr = 0x8289E6EC;
	sub_8289DB70(ctx, base);
	// 8289E6EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E6F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E6F4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E6F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E6FC: C02B959C  lfs f1, -0x6a64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E700: 4BF4C0B1  bl 0x827ea7b0
	ctx.lr = 0x8289E704;
	sub_827EA7B0(ctx, base);
	// 8289E704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E708: 48554D21  bl 0x82df3428
	ctx.lr = 0x8289E70C;
	sub_82DF3428(ctx, base);
	// 8289E70C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E710: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289E714: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E718: 396B8550  addi r11, r11, -0x7ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -31408;
	// 8289E71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E720: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E724: 485552E5  bl 0x82df3a08
	ctx.lr = 0x8289E728;
	sub_82DF3A08(ctx, base);
	// 8289E728: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E72C: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E730: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E734: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E738: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E73C: 4BFFF435  bl 0x8289db70
	ctx.lr = 0x8289E740;
	sub_8289DB70(ctx, base);
	// 8289E740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E744: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E748: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E74C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E750: C02B968C  lfs f1, -0x6974(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26996 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E754: 4BF4C05D  bl 0x827ea7b0
	ctx.lr = 0x8289E758;
	sub_827EA7B0(ctx, base);
	// 8289E758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E75C: 48554CCD  bl 0x82df3428
	ctx.lr = 0x8289E760;
	sub_82DF3428(ctx, base);
	// 8289E760: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E764: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8289E768: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E76C: 396B8538  addi r11, r11, -0x7ac8
	ctx.r[11].s64 = ctx.r[11].s64 + -31432;
	// 8289E770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E774: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E778: 48555291  bl 0x82df3a08
	ctx.lr = 0x8289E77C;
	sub_82DF3A08(ctx, base);
	// 8289E77C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E780: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E784: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E788: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E78C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E790: 4BFFF3E1  bl 0x8289db70
	ctx.lr = 0x8289E794;
	sub_8289DB70(ctx, base);
	// 8289E794: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E798: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E79C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E7A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E7A4: C3AB957C  lfs f29, -0x6a84(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27268 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8289E7A8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E7AC: 4BF4C005  bl 0x827ea7b0
	ctx.lr = 0x8289E7B0;
	sub_827EA7B0(ctx, base);
	// 8289E7B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E7B4: 48554C75  bl 0x82df3428
	ctx.lr = 0x8289E7B8;
	sub_82DF3428(ctx, base);
	// 8289E7B8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E7BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8289E7C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E7C4: 396B8550  addi r11, r11, -0x7ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -31408;
	// 8289E7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E7CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E7D0: 48555239  bl 0x82df3a08
	ctx.lr = 0x8289E7D4;
	sub_82DF3A08(ctx, base);
	// 8289E7D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E7D8: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E7DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E7E0: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E7E4: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E7E8: 4BFFF389  bl 0x8289db70
	ctx.lr = 0x8289E7EC;
	sub_8289DB70(ctx, base);
	// 8289E7EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E7F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E7F4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E7F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E7FC: C02B9598  lfs f1, -0x6a68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27240 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E800: 4BF4BFB1  bl 0x827ea7b0
	ctx.lr = 0x8289E804;
	sub_827EA7B0(ctx, base);
	// 8289E804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E808: 48554C21  bl 0x82df3428
	ctx.lr = 0x8289E80C;
	sub_82DF3428(ctx, base);
	// 8289E80C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E810: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8289E814: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E818: 396B8538  addi r11, r11, -0x7ac8
	ctx.r[11].s64 = ctx.r[11].s64 + -31432;
	// 8289E81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E820: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E824: 485551E5  bl 0x82df3a08
	ctx.lr = 0x8289E828;
	sub_82DF3A08(ctx, base);
	// 8289E828: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E82C: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E830: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E834: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E838: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E83C: 4BFFF335  bl 0x8289db70
	ctx.lr = 0x8289E840;
	sub_8289DB70(ctx, base);
	// 8289E840: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E844: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E84C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8289E850: 4BF4BF61  bl 0x827ea7b0
	ctx.lr = 0x8289E854;
	sub_827EA7B0(ctx, base);
	// 8289E854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E858: 48554BD1  bl 0x82df3428
	ctx.lr = 0x8289E85C;
	sub_82DF3428(ctx, base);
	// 8289E85C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E860: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8289E864: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E868: 396B8550  addi r11, r11, -0x7ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -31408;
	// 8289E86C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E870: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E874: 48555195  bl 0x82df3a08
	ctx.lr = 0x8289E878;
	sub_82DF3A08(ctx, base);
	// 8289E878: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E87C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E880: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E884: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E888: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E88C: 4BFFF2E5  bl 0x8289db70
	ctx.lr = 0x8289E890;
	sub_8289DB70(ctx, base);
	// 8289E890: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289E894: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E898: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E89C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E8A0: C36B08AC  lfs f27, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8289E8A4: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 8289E8A8: 4BF4BF09  bl 0x827ea7b0
	ctx.lr = 0x8289E8AC;
	sub_827EA7B0(ctx, base);
	// 8289E8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E8B0: 48554B79  bl 0x82df3428
	ctx.lr = 0x8289E8B4;
	sub_82DF3428(ctx, base);
	// 8289E8B4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E8B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E8BC: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E8C0: 396BB020  addi r11, r11, -0x4fe0
	ctx.r[11].s64 = ctx.r[11].s64 + -20448;
	// 8289E8C4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E8C8: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E8CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E8D0: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E8D4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E8D8: 4BFFF299  bl 0x8289db70
	ctx.lr = 0x8289E8DC;
	sub_8289DB70(ctx, base);
	// 8289E8DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289E8E0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E8E4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8289E8E8: C02B0940  lfs f1, 0x940(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2368 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289E8EC: 4BA5E74D  bl 0x822fd038
	ctx.lr = 0x8289E8F0;
	sub_822FD038(ctx, base);
	// 8289E8F0: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E8F4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E8F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8289E8FC: 396B8550  addi r11, r11, -0x7ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -31408;
	// 8289E900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E904: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E908: 48555101  bl 0x82df3a08
	ctx.lr = 0x8289E90C;
	sub_82DF3A08(ctx, base);
	// 8289E90C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E910: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 8289E914: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E918: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8289E91C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E920: 4BFFF251  bl 0x8289db70
	ctx.lr = 0x8289E924;
	sub_8289DB70(ctx, base);
	// 8289E924: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E928: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E92C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E930: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289E934: 4BF4BE7D  bl 0x827ea7b0
	ctx.lr = 0x8289E938;
	sub_827EA7B0(ctx, base);
	// 8289E938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E93C: 48554AED  bl 0x82df3428
	ctx.lr = 0x8289E940;
	sub_82DF3428(ctx, base);
	// 8289E940: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 8289E944: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8289E948: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8289E94C: 396B8BD8  addi r11, r11, -0x7428
	ctx.r[11].s64 = ctx.r[11].s64 + -29736;
	// 8289E950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E954: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8289E958: 485550B1  bl 0x82df3a08
	ctx.lr = 0x8289E95C;
	sub_82DF3A08(ctx, base);
	// 8289E95C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289E960: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289E964: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 8289E968: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8289E96C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289E970: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289E974: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8289E978: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8289E97C: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 8289E980: E8A10090  ld r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8289E984: 4BFFF16D  bl 0x8289daf0
	ctx.lr = 0x8289E988;
	sub_8289DAF0(ctx, base);
	// 8289E988: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8289E98C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289E990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289E994: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8289E998: 4BF4BE19  bl 0x827ea7b0
	ctx.lr = 0x8289E99C;
	sub_827EA7B0(ctx, base);
	// 8289E99C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289E9A0: 48554A89  bl 0x82df3428
	ctx.lr = 0x8289E9A4;
	sub_82DF3428(ctx, base);
	// 8289E9A4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289E9A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289E9AC: 38A0012A  li r5, 0x12a
	ctx.r[5].s64 = 298;
	// 8289E9B0: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 8289E9B4: 4BA21A25  bl 0x822c03d8
	ctx.lr = 0x8289E9B8;
	sub_822C03D8(ctx, base);
	// 8289E9B8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8289E9BC: 41820024  beq 0x8289e9e0
	if ctx.cr[0].eq {
	pc = 0x8289E9E0; continue 'dispatch;
	}
	// 8289E9C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289E9C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289E9C8: 48078511  bl 0x82916ed8
	ctx.lr = 0x8289E9CC;
	sub_82916ED8(ctx, base);
	// 8289E9CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289E9D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289E9D4: 396B8974  addi r11, r11, -0x768c
	ctx.r[11].s64 = ctx.r[11].s64 + -30348;
	// 8289E9D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289E9DC: 48000008  b 0x8289e9e4
	pc = 0x8289E9E4; continue 'dispatch;
	// 8289E9E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289E9E4: 3BBC00E4  addi r29, r28, 0xe4
	ctx.r[29].s64 = ctx.r[28].s64 + 228;
	// 8289E9E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289E9EC: 4BFFCD55  bl 0x8289b740
	ctx.lr = 0x8289E9F0;
	sub_8289B740(ctx, base);
	// 8289E9F0: 817C00FC  lwz r11, 0xfc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(252 as u32) ) } as u64;
	// 8289E9F4: 3BDC00FC  addi r30, r28, 0xfc
	ctx.r[30].s64 = ctx.r[28].s64 + 252;
	// 8289E9F8: 809C00E4  lwz r4, 0xe4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 8289E9FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8289EA04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289EA08: 4E800421  bctrl
	ctx.lr = 0x8289EA0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289EA0C: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 8289EA10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EA14: 809B0AF8  lwz r4, 0xaf8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2808 as u32) ) } as u64;
	// 8289EA18: 48554FF1  bl 0x82df3a08
	ctx.lr = 0x8289EA1C;
	sub_82DF3A08(ctx, base);
	// 8289EA1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EA20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA24: 4BFFEB8D  bl 0x8289d5b0
	ctx.lr = 0x8289EA28;
	sub_8289D5B0(ctx, base);
	// 8289EA28: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EA2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EA30: 808BFE48  lwz r4, -0x1b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-440 as u32) ) } as u64;
	// 8289EA34: 48554FD5  bl 0x82df3a08
	ctx.lr = 0x8289EA38;
	sub_82DF3A08(ctx, base);
	// 8289EA38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA40: 4BFFEBD1  bl 0x8289d610
	ctx.lr = 0x8289EA44;
	sub_8289D610(ctx, base);
	// 8289EA44: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EA48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EA4C: 808BFE4C  lwz r4, -0x1b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-436 as u32) ) } as u64;
	// 8289EA50: 48554FB9  bl 0x82df3a08
	ctx.lr = 0x8289EA54;
	sub_82DF3A08(ctx, base);
	// 8289EA54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA5C: 4BFFEC15  bl 0x8289d670
	ctx.lr = 0x8289EA60;
	sub_8289D670(ctx, base);
	// 8289EA60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EA64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EA68: 808BFE54  lwz r4, -0x1ac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-428 as u32) ) } as u64;
	// 8289EA6C: 48554F9D  bl 0x82df3a08
	ctx.lr = 0x8289EA70;
	sub_82DF3A08(ctx, base);
	// 8289EA70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA78: 4BFFEC59  bl 0x8289d6d0
	ctx.lr = 0x8289EA7C;
	sub_8289D6D0(ctx, base);
	// 8289EA7C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EA80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EA84: 808BFE58  lwz r4, -0x1a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-424 as u32) ) } as u64;
	// 8289EA88: 48554F81  bl 0x82df3a08
	ctx.lr = 0x8289EA8C;
	sub_82DF3A08(ctx, base);
	// 8289EA8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EA90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EA94: 4BFFEC9D  bl 0x8289d730
	ctx.lr = 0x8289EA98;
	sub_8289D730(ctx, base);
	// 8289EA98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EA9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EAA0: 808BFE5C  lwz r4, -0x1a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-420 as u32) ) } as u64;
	// 8289EAA4: 48554F65  bl 0x82df3a08
	ctx.lr = 0x8289EAA8;
	sub_82DF3A08(ctx, base);
	// 8289EAA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EAB0: 4BFFECE1  bl 0x8289d790
	ctx.lr = 0x8289EAB4;
	sub_8289D790(ctx, base);
	// 8289EAB4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 8289EAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EABC: 808BFE60  lwz r4, -0x1a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-416 as u32) ) } as u64;
	// 8289EAC0: 48554F49  bl 0x82df3a08
	ctx.lr = 0x8289EAC4;
	sub_82DF3A08(ctx, base);
	// 8289EAC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EAC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EACC: 4BFFED25  bl 0x8289d7f0
	ctx.lr = 0x8289EAD0;
	sub_8289D7F0(ctx, base);
	// 8289EAD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EAD8: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 8289EADC: 48554F2D  bl 0x82df3a08
	ctx.lr = 0x8289EAE0;
	sub_82DF3A08(ctx, base);
	// 8289EAE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EAE8: 4BFFED69  bl 0x8289d850
	ctx.lr = 0x8289EAEC;
	sub_8289D850(ctx, base);
	// 8289EAEC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EAF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EAF4: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 8289EAF8: 48554F11  bl 0x82df3a08
	ctx.lr = 0x8289EAFC;
	sub_82DF3A08(ctx, base);
	// 8289EAFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EB04: 4BFFEDAD  bl 0x8289d8b0
	ctx.lr = 0x8289EB08;
	sub_8289D8B0(ctx, base);
	// 8289EB08: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289EB0C: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 8289EB10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289EB14: 388B5028  addi r4, r11, 0x5028
	ctx.r[4].s64 = ctx.r[11].s64 + 20520;
	// 8289EB18: 4BFCA591  bl 0x828690a8
	ctx.lr = 0x8289EB1C;
	sub_828690A8(ctx, base);
	// 8289EB1C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EB20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EB24: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 8289EB28: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 8289EB2C: 48554EDD  bl 0x82df3a08
	ctx.lr = 0x8289EB30;
	sub_82DF3A08(ctx, base);
	// 8289EB30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EB34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EB38: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8289EB3C: 485BD61D  bl 0x82e5c158
	ctx.lr = 0x8289EB40;
	sub_82E5C158(ctx, base);
	// 8289EB40: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EB44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EB48: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 8289EB4C: 48554EBD  bl 0x82df3a08
	ctx.lr = 0x8289EB50;
	sub_82DF3A08(ctx, base);
	// 8289EB50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EB58: 4BFFEDB9  bl 0x8289d910
	ctx.lr = 0x8289EB5C;
	sub_8289D910(ctx, base);
	// 8289EB5C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EB60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EB64: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 8289EB68: 48554EA1  bl 0x82df3a08
	ctx.lr = 0x8289EB6C;
	sub_82DF3A08(ctx, base);
	// 8289EB6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EB74: 4BFFEDFD  bl 0x8289d970
	ctx.lr = 0x8289EB78;
	sub_8289D970(ctx, base);
	// 8289EB78: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EB7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EB80: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8289EB84: 48554E85  bl 0x82df3a08
	ctx.lr = 0x8289EB88;
	sub_82DF3A08(ctx, base);
	// 8289EB88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EB90: 4BFFEE41  bl 0x8289d9d0
	ctx.lr = 0x8289EB94;
	sub_8289D9D0(ctx, base);
	// 8289EB94: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289EB98: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8289EB9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289EBA0: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 8289EBA4: 4BFCA505  bl 0x828690a8
	ctx.lr = 0x8289EBA8;
	sub_828690A8(ctx, base);
	// 8289EBA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EBAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EBB0: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 8289EBB4: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 8289EBB8: 48554E51  bl 0x82df3a08
	ctx.lr = 0x8289EBBC;
	sub_82DF3A08(ctx, base);
	// 8289EBBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EBC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EBC4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8289EBC8: 485BD591  bl 0x82e5c158
	ctx.lr = 0x8289EBCC;
	sub_82E5C158(ctx, base);
	// 8289EBCC: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289EBD0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8289EBD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289EBD8: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 8289EBDC: 4BFCA4CD  bl 0x828690a8
	ctx.lr = 0x8289EBE0;
	sub_828690A8(ctx, base);
	// 8289EBE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EBE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EBE8: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 8289EBEC: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 8289EBF0: 48554E19  bl 0x82df3a08
	ctx.lr = 0x8289EBF4;
	sub_82DF3A08(ctx, base);
	// 8289EBF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EBF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EBFC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8289EC00: 485BD559  bl 0x82e5c158
	ctx.lr = 0x8289EC04;
	sub_82E5C158(ctx, base);
	// 8289EC04: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289EC08: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8289EC0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289EC10: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 8289EC14: 4BFCA495  bl 0x828690a8
	ctx.lr = 0x8289EC18;
	sub_828690A8(ctx, base);
	// 8289EC18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EC1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EC20: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 8289EC24: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 8289EC28: 48554DE1  bl 0x82df3a08
	ctx.lr = 0x8289EC2C;
	sub_82DF3A08(ctx, base);
	// 8289EC2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EC30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EC34: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8289EC38: 485BD521  bl 0x82e5c158
	ctx.lr = 0x8289EC3C;
	sub_82E5C158(ctx, base);
	// 8289EC3C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8289EC40: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8289EC44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8289EC48: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 8289EC4C: 4BFCA45D  bl 0x828690a8
	ctx.lr = 0x8289EC50;
	sub_828690A8(ctx, base);
	// 8289EC50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EC54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EC58: 3B410070  addi r26, r1, 0x70
	ctx.r[26].s64 = ctx.r[1].s64 + 112;
	// 8289EC5C: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 8289EC60: 48554DA9  bl 0x82df3a08
	ctx.lr = 0x8289EC64;
	sub_82DF3A08(ctx, base);
	// 8289EC64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EC68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EC6C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8289EC70: 485BD4E9  bl 0x82e5c158
	ctx.lr = 0x8289EC74;
	sub_82E5C158(ctx, base);
	// 8289EC74: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289EC78: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8289EC7C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8289EC80: 3B4B0B24  addi r26, r11, 0xb24
	ctx.r[26].s64 = ctx.r[11].s64 + 2852;
	// 8289EC84: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8289EC88: 419A001C  beq cr6, 0x8289eca4
	if ctx.cr[6].eq {
	pc = 0x8289ECA4; continue 'dispatch;
	}
	// 8289EC8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289EC90: 48554D79  bl 0x82df3a08
	ctx.lr = 0x8289EC94;
	sub_82DF3A08(ctx, base);
	// 8289EC94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EC98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289EC9C: 4BFFEDF5  bl 0x8289da90
	ctx.lr = 0x8289ECA0;
	sub_8289DA90(ctx, base);
	// 8289ECA0: 48000018  b 0x8289ecb8
	pc = 0x8289ECB8; continue 'dispatch;
	// 8289ECA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8289ECA8: 48554D61  bl 0x82df3a08
	ctx.lr = 0x8289ECAC;
	sub_82DF3A08(ctx, base);
	// 8289ECAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289ECB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289ECB4: 4BFFED7D  bl 0x8289da30
	ctx.lr = 0x8289ECB8;
	sub_8289DA30(ctx, base);
	// 8289ECB8: 896F0061  lbz r11, 0x61(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(97 as u32) ) } as u64;
	// 8289ECBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289ECC0: 41820058  beq 0x8289ed18
	if ctx.cr[0].eq {
	pc = 0x8289ED18; continue 'dispatch;
	}
	// 8289ECC4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289ECC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289ECCC: 419A001C  beq cr6, 0x8289ece8
	if ctx.cr[6].eq {
	pc = 0x8289ECE8; continue 'dispatch;
	}
	// 8289ECD0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8289ECD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8289ECD8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8289ECDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289ECE0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8289ECE4: 4BC71E75  bl 0x82510b58
	ctx.lr = 0x8289ECE8;
	sub_82510B58(ctx, base);
	// 8289ECE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289ECEC: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289ECF0: 48554D19  bl 0x82df3a08
	ctx.lr = 0x8289ECF4;
	sub_82DF3A08(ctx, base);
	// 8289ECF4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8289ECF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289ECFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289ED00: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 8289ED04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289ED08: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8289ED0C: 485BFC55  bl 0x82e5e960
	ctx.lr = 0x8289ED10;
	sub_82E5E960(ctx, base);
	// 8289ED10: 8061020C  lwz r3, 0x20c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 8289ED14: 48000030  b 0x8289ed44
	pc = 0x8289ED44; continue 'dispatch;
	// 8289ED18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289ED1C: 809B0AF8  lwz r4, 0xaf8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2808 as u32) ) } as u64;
	// 8289ED20: 48554CE9  bl 0x82df3a08
	ctx.lr = 0x8289ED24;
	sub_82DF3A08(ctx, base);
	// 8289ED24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8289ED28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289ED2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289ED30: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 8289ED34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289ED38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8289ED3C: 485BFC25  bl 0x82e5e960
	ctx.lr = 0x8289ED40;
	sub_82E5E960(ctx, base);
	// 8289ED40: 8061021C  lwz r3, 0x21c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 8289ED44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289ED48: 419A0008  beq cr6, 0x8289ed50
	if ctx.cr[6].eq {
	pc = 0x8289ED50; continue 'dispatch;
	}
	// 8289ED4C: 4BA21B45  bl 0x822c0890
	ctx.lr = 0x8289ED50;
	sub_822C0890(ctx, base);
	// 8289ED50: 817C0164  lwz r11, 0x164(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 8289ED54: 387C0164  addi r3, r28, 0x164
	ctx.r[3].s64 = ctx.r[28].s64 + 356;
	// 8289ED58: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289ED5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8289ED60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289ED64: 4E800421  bctrl
	ctx.lr = 0x8289ED68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8289ED68: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 8289ED6C: 4800355D  bl 0x828a22c8
	ctx.lr = 0x8289ED70;
	sub_828A22C8(ctx, base);
	// 8289ED70: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 8289ED74: 4BFFCA3D  bl 0x8289b7b0
	ctx.lr = 0x8289ED78;
	sub_8289B7B0(ctx, base);
	// 8289ED78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289ED7C: 395C0418  addi r10, r28, 0x418
	ctx.r[10].s64 = ctx.r[28].s64 + 1048;
	// 8289ED80: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8289ED84: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8289ED88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289ED8C: 917C0418  stw r11, 0x418(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 8289ED90: 4BA256D1  bl 0x822c4460
	ctx.lr = 0x8289ED94;
	sub_822C4460(ctx, base);
	// 8289ED94: 80610224  lwz r3, 0x224(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 8289ED98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289ED9C: 419A0008  beq cr6, 0x8289eda4
	if ctx.cr[6].eq {
	pc = 0x8289EDA4; continue 'dispatch;
	}
	// 8289EDA0: 4BA21AF1  bl 0x822c0890
	ctx.lr = 0x8289EDA4;
	sub_822C0890(ctx, base);
	// 8289EDA4: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 8289EDA8: 4BFFCA89  bl 0x8289b830
	ctx.lr = 0x8289EDAC;
	sub_8289B830(ctx, base);
	// 8289EDAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289EDB0: 395C0420  addi r10, r28, 0x420
	ctx.r[10].s64 = ctx.r[28].s64 + 1056;
	// 8289EDB4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8289EDB8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8289EDBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289EDC0: 917C0420  stw r11, 0x420(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1056 as u32), ctx.r[11].u32 ) };
	// 8289EDC4: 4BA2569D  bl 0x822c4460
	ctx.lr = 0x8289EDC8;
	sub_822C4460(ctx, base);
	// 8289EDC8: 80610214  lwz r3, 0x214(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(532 as u32) ) } as u64;
	// 8289EDCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289EDD0: 419A0008  beq cr6, 0x8289edd8
	if ctx.cr[6].eq {
	pc = 0x8289EDD8; continue 'dispatch;
	}
	// 8289EDD4: 4BA21ABD  bl 0x822c0890
	ctx.lr = 0x8289EDD8;
	sub_822C0890(ctx, base);
	// 8289EDD8: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289EDDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289EDE0: 38A00166  li r5, 0x166
	ctx.r[5].s64 = 358;
	// 8289EDE4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 8289EDE8: 4BA215F1  bl 0x822c03d8
	ctx.lr = 0x8289EDEC;
	sub_822C03D8(ctx, base);
	// 8289EDEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289EDF0: 41820014  beq 0x8289ee04
	if ctx.cr[0].eq {
	pc = 0x8289EE04; continue 'dispatch;
	}
	// 8289EDF4: 8081066C  lwz r4, 0x66c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1644 as u32) ) } as u64;
	// 8289EDF8: 4BBF22F9  bl 0x824910f0
	ctx.lr = 0x8289EDFC;
	sub_824910F0(ctx, base);
	// 8289EDFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289EE00: 48000008  b 0x8289ee08
	pc = 0x8289EE08; continue 'dispatch;
	// 8289EE04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289EE08: 387C0364  addi r3, r28, 0x364
	ctx.r[3].s64 = ctx.r[28].s64 + 868;
	// 8289EE0C: 4BA6B8D5  bl 0x8230a6e0
	ctx.lr = 0x8289EE10;
	sub_8230A6E0(ctx, base);
	// 8289EE10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289EE14: 80810674  lwz r4, 0x674(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1652 as u32) ) } as u64;
	// 8289EE18: 4806F1E9  bl 0x8290e000
	ctx.lr = 0x8289EE1C;
	sub_8290E000(ctx, base);
	// 8289EE1C: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289EE20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289EE24: 38A00170  li r5, 0x170
	ctx.r[5].s64 = 368;
	// 8289EE28: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8289EE2C: 4BA215AD  bl 0x822c03d8
	ctx.lr = 0x8289EE30;
	sub_822C03D8(ctx, base);
	// 8289EE30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289EE34: 41820014  beq 0x8289ee48
	if ctx.cr[0].eq {
	pc = 0x8289EE48; continue 'dispatch;
	}
	// 8289EE38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8289EE3C: 480A4D5D  bl 0x82943b98
	ctx.lr = 0x8289EE40;
	sub_82943B98(ctx, base);
	// 8289EE40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289EE44: 48000008  b 0x8289ee4c
	pc = 0x8289EE4C; continue 'dispatch;
	// 8289EE48: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 8289EE4C: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 8289EE50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289EE54: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 8289EE58: 4BFC7B31  bl 0x82866988
	ctx.lr = 0x8289EE5C;
	sub_82866988(ctx, base);
	// 8289EE5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8289EE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8289EE64: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 8289EE68: 4BA21199  bl 0x822c0000
	ctx.lr = 0x8289EE6C;
	sub_822C0000(ctx, base);
	// 8289EE6C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8289EE70: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 8289EE74: 4BFC955D  bl 0x828683d0
	ctx.lr = 0x8289EE78;
	sub_828683D0(ctx, base);
	// 8289EE78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289EE7C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 8289EE80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289EE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289EE88: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 8289EE8C: 419A0024  beq cr6, 0x8289eeb0
	if ctx.cr[6].eq {
	pc = 0x8289EEB0; continue 'dispatch;
	}
	// 8289EE90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289EE94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289EE98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289EE9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289EEA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289EEA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289EEA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289EEAC: 4082FFE8  bne 0x8289ee94
	if !ctx.cr[0].eq {
	pc = 0x8289EE94; continue 'dispatch;
	}
	// 8289EEB0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8289EEB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8289EEB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289EEBC: 4806C62D  bl 0x8290b4e8
	ctx.lr = 0x8289EEC0;
	sub_8290B4E8(ctx, base);
	// 8289EEC0: 80610204  lwz r3, 0x204(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(516 as u32) ) } as u64;
	// 8289EEC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289EEC8: 419A0008  beq cr6, 0x8289eed0
	if ctx.cr[6].eq {
	pc = 0x8289EED0; continue 'dispatch;
	}
	// 8289EECC: 4BA219C5  bl 0x822c0890
	ctx.lr = 0x8289EED0;
	sub_822C0890(ctx, base);
	// 8289EED0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 8289EED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289EED8: 419A0008  beq cr6, 0x8289eee0
	if ctx.cr[6].eq {
	pc = 0x8289EEE0; continue 'dispatch;
	}
	// 8289EEDC: 4BA219B5  bl 0x822c0890
	ctx.lr = 0x8289EEE0;
	sub_822C0890(ctx, base);
	// 8289EEE0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8289EEE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289EEE8: 4BC70489  bl 0x8250f370
	ctx.lr = 0x8289EEEC;
	sub_8250F370(ctx, base);
	// 8289EEEC: 815C0448  lwz r10, 0x448(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1096 as u32) ) } as u64;
	// 8289EEF0: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 8289EEF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289EEF8: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 8289EEFC: 396B0068  addi r11, r11, 0x68
	ctx.r[11].s64 = ctx.r[11].s64 + 104;
	// 8289EF00: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289EF04: 4806F54D  bl 0x8290e450
	ctx.lr = 0x8289EF08;
	sub_8290E450(ctx, base);
	// 8289EF08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289EF0C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8289EF10: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 8289EF14: 48554AF5  bl 0x82df3a08
	ctx.lr = 0x8289EF18;
	sub_82DF3A08(ctx, base);
	// 8289EF18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289EF1C: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 8289EF20: 388B903C  addi r4, r11, -0x6fc4
	ctx.r[4].s64 = ctx.r[11].s64 + -28612;
	// 8289EF24: 48554AE5  bl 0x82df3a08
	ctx.lr = 0x8289EF28;
	sub_82DF3A08(ctx, base);
	// 8289EF28: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 8289EF2C: D3E100DC  stfs f31, 0xdc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8289EF30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289EF34: D3E100E0  stfs f31, 0xe0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8289EF38: 93C100D8  stw r30, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 8289EF3C: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8289EF40: 388B9034  addi r4, r11, -0x6fcc
	ctx.r[4].s64 = ctx.r[11].s64 + -28620;
	// 8289EF44: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8289EF48: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8289EF4C: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8289EF50: D3E100F0  stfs f31, 0xf0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8289EF54: D3C100F4  stfs f30, 0xf4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8289EF58: D3C100F8  stfs f30, 0xf8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8289EF5C: D3C100FC  stfs f30, 0xfc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8289EF60: 48554AA9  bl 0x82df3a08
	ctx.lr = 0x8289EF64;
	sub_82DF3A08(ctx, base);
	// 8289EF64: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8289EF68: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 8289EF6C: 3BAB1360  addi r29, r11, 0x1360
	ctx.r[29].s64 = ctx.r[11].s64 + 4960;
	// 8289EF70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289EF74: 48554A95  bl 0x82df3a08
	ctx.lr = 0x8289EF78;
	sub_82DF3A08(ctx, base);
	// 8289EF78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8289EF7C: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 8289EF80: D3E1010C  stfs f31, 0x10c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 8289EF84: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8289EF88: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 8289EF8C: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 8289EF90: 93C10108  stw r30, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 8289EF94: D3E10120  stfs f31, 0x120(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 8289EF98: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 8289EF9C: C38B964C  lfs f28, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8289EFA0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 8289EFA4: C3AADAA0  lfs f29, -0x2560(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9568 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8289EFA8: 3B688A10  addi r27, r8, -0x75f0
	ctx.r[27].s64 = ctx.r[8].s64 + -30192;
	// 8289EFAC: C0099030  lfs f0, -0x6fd0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289EFB0: D3810114  stfs f28, 0x114(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 8289EFB4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289EFB8: D3A1011C  stfs f29, 0x11c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 8289EFBC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 8289EFC0: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 8289EFC4: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 8289EFC8: 48554A41  bl 0x82df3a08
	ctx.lr = 0x8289EFCC;
	sub_82DF3A08(ctx, base);
	// 8289EFCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289EFD0: 38610134  addi r3, r1, 0x134
	ctx.r[3].s64 = ctx.r[1].s64 + 308;
	// 8289EFD4: 48554A35  bl 0x82df3a08
	ctx.lr = 0x8289EFD8;
	sub_82DF3A08(ctx, base);
	// 8289EFD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289EFDC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289EFE0: D3E10140  stfs f31, 0x140(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 8289EFE4: D3E10144  stfs f31, 0x144(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 8289EFE8: 93C10138  stw r30, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 8289EFEC: D3E10148  stfs f31, 0x148(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 8289EFF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289EFF4: D3A1014C  stfs f29, 0x14c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 8289EFF8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 8289EFFC: C00B902C  lfs f0, -0x6fd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F000: C3CA9028  lfs f30, -0x6fd8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28632 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289F004: D001013C  stfs f0, 0x13c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 8289F008: D3E10150  stfs f31, 0x150(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 8289F00C: D3C10154  stfs f30, 0x154(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 8289F010: D3C10158  stfs f30, 0x158(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 8289F014: D3C1015C  stfs f30, 0x15c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 8289F018: 485549F1  bl 0x82df3a08
	ctx.lr = 0x8289F01C;
	sub_82DF3A08(ctx, base);
	// 8289F01C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F020: 38610164  addi r3, r1, 0x164
	ctx.r[3].s64 = ctx.r[1].s64 + 356;
	// 8289F024: 485549E5  bl 0x82df3a08
	ctx.lr = 0x8289F028;
	sub_82DF3A08(ctx, base);
	// 8289F028: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289F02C: D3E1016C  stfs f31, 0x16c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 8289F030: 93C10168  stw r30, 0x168(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 8289F034: D3E10170  stfs f31, 0x170(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 8289F038: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8289F03C: D3810174  stfs f28, 0x174(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 8289F040: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 8289F044: D3E10178  stfs f31, 0x178(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 8289F048: 388A1280  addi r4, r10, 0x1280
	ctx.r[4].s64 = ctx.r[10].s64 + 4736;
	// 8289F04C: C00B9024  lfs f0, -0x6fdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F050: D3A1017C  stfs f29, 0x17c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8289F054: D3E10180  stfs f31, 0x180(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 8289F058: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 8289F05C: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8289F060: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 8289F064: 485549A5  bl 0x82df3a08
	ctx.lr = 0x8289F068;
	sub_82DF3A08(ctx, base);
	// 8289F068: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F06C: 38610194  addi r3, r1, 0x194
	ctx.r[3].s64 = ctx.r[1].s64 + 404;
	// 8289F070: 48554999  bl 0x82df3a08
	ctx.lr = 0x8289F074;
	sub_82DF3A08(ctx, base);
	// 8289F074: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289F078: D3E1019C  stfs f31, 0x19c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 8289F07C: 93C10198  stw r30, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 8289F080: D3E101A0  stfs f31, 0x1a0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 8289F084: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8289F088: D38101A4  stfs f28, 0x1a4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 8289F08C: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 8289F090: D3E101A8  stfs f31, 0x1a8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 8289F094: 388A7868  addi r4, r10, 0x7868
	ctx.r[4].s64 = ctx.r[10].s64 + 30824;
	// 8289F098: C00B9020  lfs f0, -0x6fe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F09C: D3A101AC  stfs f29, 0x1ac(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 8289F0A0: D3E101B0  stfs f31, 0x1b0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 8289F0A4: D00101B4  stfs f0, 0x1b4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 8289F0A8: D00101B8  stfs f0, 0x1b8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 8289F0AC: D00101BC  stfs f0, 0x1bc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 8289F0B0: 48554959  bl 0x82df3a08
	ctx.lr = 0x8289F0B4;
	sub_82DF3A08(ctx, base);
	// 8289F0B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F0B8: 386101C4  addi r3, r1, 0x1c4
	ctx.r[3].s64 = ctx.r[1].s64 + 452;
	// 8289F0BC: 4855494D  bl 0x82df3a08
	ctx.lr = 0x8289F0C0;
	sub_82DF3A08(ctx, base);
	// 8289F0C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289F0C4: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289F0C8: D3E101D0  stfs f31, 0x1d0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 8289F0CC: D38101D4  stfs f28, 0x1d4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 8289F0D0: 93C101C8  stw r30, 0x1c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[30].u32 ) };
	// 8289F0D4: D3E101D8  stfs f31, 0x1d8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 8289F0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F0DC: D3A101DC  stfs f29, 0x1dc(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 8289F0E0: C00A901C  lfs f0, -0x6fe4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F0E4: D00101CC  stfs f0, 0x1cc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 8289F0E8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 8289F0EC: D3E101E0  stfs f31, 0x1e0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 8289F0F0: D3C101E4  stfs f30, 0x1e4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 8289F0F4: D3C101E8  stfs f30, 0x1e8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 8289F0F8: D3C101EC  stfs f30, 0x1ec(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 8289F0FC: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F100: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 8289F104: 419A0024  beq cr6, 0x8289f128
	if ctx.cr[6].eq {
	pc = 0x8289F128; continue 'dispatch;
	}
	// 8289F108: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F10C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F114: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F118: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F11C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F120: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F124: 4082FFE8  bne 0x8289f10c
	if !ctx.cr[0].eq {
	pc = 0x8289F10C; continue 'dispatch;
	}
	// 8289F128: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8289F12C: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 8289F130: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 8289F134: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8289F138: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F13C: 4BF4D705  bl 0x827ec840
	ctx.lr = 0x8289F140;
	sub_827EC840(ctx, base);
	// 8289F140: 907C0378  stw r3, 0x378(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(888 as u32), ctx.r[3].u32 ) };
	// 8289F144: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289F148: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F14C: 4BF4D125  bl 0x827ec270
	ctx.lr = 0x8289F150;
	sub_827EC270(ctx, base);
	// 8289F150: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8289F154: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F158: 809C0378  lwz r4, 0x378(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(888 as u32) ) } as u64;
	// 8289F15C: 4BF4D10D  bl 0x827ec268
	ctx.lr = 0x8289F160;
	sub_827EC268(ctx, base);
	// 8289F160: 3BC101F0  addi r30, r1, 0x1f0
	ctx.r[30].s64 = ctx.r[1].s64 + 496;
	// 8289F164: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 8289F168: 3BDEFFD0  addi r30, r30, -0x30
	ctx.r[30].s64 = ctx.r[30].s64 + -48;
	// 8289F16C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8289F170: 485542B9  bl 0x82df3428
	ctx.lr = 0x8289F174;
	sub_82DF3428(ctx, base);
	// 8289F174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289F178: 485542B1  bl 0x82df3428
	ctx.lr = 0x8289F17C;
	sub_82DF3428(ctx, base);
	// 8289F17C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8289F180: 4080FFE8  bge 0x8289f168
	if !ctx.cr[0].lt {
	pc = 0x8289F168; continue 'dispatch;
	}
	// 8289F184: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289F188: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F18C: 38A001A2  li r5, 0x1a2
	ctx.r[5].s64 = 418;
	// 8289F190: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8289F194: 4BA21245  bl 0x822c03d8
	ctx.lr = 0x8289F198;
	sub_822C03D8(ctx, base);
	// 8289F198: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8289F19C: 4182002C  beq 0x8289f1c8
	if ctx.cr[0].eq {
	pc = 0x8289F1C8; continue 'dispatch;
	}
	// 8289F1A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F1A4: 4BF4CFBD  bl 0x827ec160
	ctx.lr = 0x8289F1A8;
	sub_827EC160(ctx, base);
	// 8289F1A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289F1AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8289F1B0: 8081067C  lwz r4, 0x67c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1660 as u32) ) } as u64;
	// 8289F1B4: 38AB8A8C  addi r5, r11, -0x7574
	ctx.r[5].s64 = ctx.r[11].s64 + -30068;
	// 8289F1B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8289F1BC: 48083605  bl 0x829227c0
	ctx.lr = 0x8289F1C0;
	sub_829227C0(ctx, base);
	// 8289F1C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289F1C4: 48000008  b 0x8289f1cc
	pc = 0x8289F1CC; continue 'dispatch;
	// 8289F1C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289F1CC: 387C0428  addi r3, r28, 0x428
	ctx.r[3].s64 = ctx.r[28].s64 + 1064;
	// 8289F1D0: 4BFC9DE9  bl 0x82868fb8
	ctx.lr = 0x8289F1D4;
	sub_82868FB8(ctx, base);
	// 8289F1D4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 8289F1D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F1DC: 38A001A7  li r5, 0x1a7
	ctx.r[5].s64 = 423;
	// 8289F1E0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8289F1E4: 4BA211F5  bl 0x822c03d8
	ctx.lr = 0x8289F1E8;
	sub_822C03D8(ctx, base);
	// 8289F1E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8289F1EC: 41820018  beq 0x8289f204
	if ctx.cr[0].eq {
	pc = 0x8289F204; continue 'dispatch;
	}
	// 8289F1F0: C02F0234  lfs f1, 0x234(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(564 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289F1F4: 808F0230  lwz r4, 0x230(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(560 as u32) ) } as u64;
	// 8289F1F8: 4BFF8EF1  bl 0x828980e8
	ctx.lr = 0x8289F1FC;
	sub_828980E8(ctx, base);
	// 8289F1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289F200: 48000008  b 0x8289f208
	pc = 0x8289F208; continue 'dispatch;
	// 8289F204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8289F208: 387C0410  addi r3, r28, 0x410
	ctx.r[3].s64 = ctx.r[28].s64 + 1040;
	// 8289F20C: 4BFFC6A5  bl 0x8289b8b0
	ctx.lr = 0x8289F210;
	sub_8289B8B0(ctx, base);
	// 8289F210: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8289F214: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8289F218: FC60D890  fmr f3, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[27].f64;
	// 8289F21C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8289F220: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8289F224: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8289F228: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F22C: C04BBC10  lfs f2, -0x43f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8289F230: C02A6218  lfs f1, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289F234: 4806B0ED  bl 0x8290a320
	ctx.lr = 0x8289F238;
	sub_8290A320(ctx, base);
	// 8289F238: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8289F23C: 4BC7385D  bl 0x82512a98
	ctx.lr = 0x8289F240;
	sub_82512A98(ctx, base);
	// 8289F240: 38210650  addi r1, r1, 0x650
	ctx.r[1].s64 = ctx.r[1].s64 + 1616;
	// 8289F244: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 8289F248: 48909879  bl 0x831a8ac0
	ctx.lr = 0x8289F24C;
	sub_831A8A8C(ctx, base);
	// 8289F24C: 48908F34  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289F250 size=984
    let mut pc: u32 = 0x8289F250;
    'dispatch: loop {
        match pc {
            0x8289F250 => {
    //   block [0x8289F250..0x8289F628)
	// 8289F250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289F254: 48908F0D  bl 0x831a8160
	ctx.lr = 0x8289F258;
	sub_831A8130(ctx, base);
	// 8289F258: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8289F25C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8289F260: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289F264: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289F268: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8289F26C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8289F270: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F274: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8289F278: 4BC70251  bl 0x8250f4c8
	ctx.lr = 0x8289F27C;
	sub_8250F4C8(ctx, base);
	// 8289F27C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F284: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289F288: 409A0008  bne cr6, 0x8289f290
	if !ctx.cr[6].eq {
	pc = 0x8289F290; continue 'dispatch;
	}
	// 8289F28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F290: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8289F294: 4BC6B335  bl 0x8250a5c8
	ctx.lr = 0x8289F298;
	sub_8250A5C8(ctx, base);
	// 8289F298: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F2A0: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 8289F2A4: 409A0008  bne cr6, 0x8289f2ac
	if !ctx.cr[6].eq {
	pc = 0x8289F2AC; continue 'dispatch;
	}
	// 8289F2A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F2AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F2B0: 80BD0430  lwz r5, 0x430(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1072 as u32) ) } as u64;
	// 8289F2B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F2B8: 4BF0D199  bl 0x827ac450
	ctx.lr = 0x8289F2BC;
	sub_827AC450(ctx, base);
	// 8289F2BC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8289F2C0: 485529D1  bl 0x82df1c90
	ctx.lr = 0x8289F2C4;
	sub_82DF1C90(ctx, base);
	// 8289F2C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8289F2C8: 485529C9  bl 0x82df1c90
	ctx.lr = 0x8289F2CC;
	sub_82DF1C90(ctx, base);
	// 8289F2CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289F2D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289F2D4: 3B6B8F18  addi r27, r11, -0x70e8
	ctx.r[27].s64 = ctx.r[11].s64 + -28904;
	// 8289F2D8: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289F2DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F2E4: 419A00B4  beq cr6, 0x8289f398
	if ctx.cr[6].eq {
	pc = 0x8289F398; continue 'dispatch;
	}
	// 8289F2E8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289F2EC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8289F2F0: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8289F2F4: 418200A4  beq 0x8289f398
	if ctx.cr[0].eq {
	pc = 0x8289F398; continue 'dispatch;
	}
	// 8289F2F8: 815D0424  lwz r10, 0x424(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1060 as u32) ) } as u64;
	// 8289F2FC: 3BFD0420  addi r31, r29, 0x420
	ctx.r[31].s64 = ctx.r[29].s64 + 1056;
	// 8289F300: 813D0420  lwz r9, 0x420(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1056 as u32) ) } as u64;
	// 8289F304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8289F308: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8289F30C: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 8289F310: 419A0028  beq cr6, 0x8289f338
	if ctx.cr[6].eq {
	pc = 0x8289F338; continue 'dispatch;
	}
	// 8289F314: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 8289F318: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F31C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F320: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F324: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F328: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F32C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F330: 4082FFE8  bne 0x8289f318
	if !ctx.cr[0].eq {
	pc = 0x8289F318; continue 'dispatch;
	}
	// 8289F334: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F338: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F33C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F340: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8289F344: 38A0042D  li r5, 0x42d
	ctx.r[5].s64 = 1069;
	// 8289F348: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8289F34C: 485B7C9D  bl 0x82e56fe8
	ctx.lr = 0x8289F350;
	sub_82E56FE8(ctx, base);
	// 8289F350: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8289F354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F358: 419A0008  beq cr6, 0x8289f360
	if ctx.cr[6].eq {
	pc = 0x8289F360; continue 'dispatch;
	}
	// 8289F35C: 4BA21535  bl 0x822c0890
	ctx.lr = 0x8289F360;
	sub_822C0890(ctx, base);
	// 8289F360: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F364: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F368: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8289F36C: 4099002C  ble cr6, 0x8289f398
	if !ctx.cr[6].gt {
	pc = 0x8289F398; continue 'dispatch;
	}
	// 8289F370: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8289F374: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F378: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 8289F37C: 41980008  blt cr6, 0x8289f384
	if ctx.cr[6].lt {
	pc = 0x8289F384; continue 'dispatch;
	}
	// 8289F380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289F384: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F388: 41820010  beq 0x8289f398
	if ctx.cr[0].eq {
	pc = 0x8289F398; continue 'dispatch;
	}
	// 8289F38C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F390: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8289F394: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F398: 839D0440  lwz r28, 0x440(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1088 as u32) ) } as u64;
	// 8289F39C: 83DD043C  lwz r30, 0x43c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1084 as u32) ) } as u64;
	// 8289F3A0: 48000134  b 0x8289f4d4
	pc = 0x8289F4D4; continue 'dispatch;
	// 8289F3A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F3A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8289F3AC: 4BC7011D  bl 0x8250f4c8
	ctx.lr = 0x8289F3B0;
	sub_8250F4C8(ctx, base);
	// 8289F3B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F3B8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289F3BC: 409A0008  bne cr6, 0x8289f3c4
	if !ctx.cr[6].eq {
	pc = 0x8289F3C4; continue 'dispatch;
	}
	// 8289F3C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F3C4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8289F3C8: 4BC6B201  bl 0x8250a5c8
	ctx.lr = 0x8289F3CC;
	sub_8250A5C8(ctx, base);
	// 8289F3CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F3D4: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 8289F3D8: 409A0008  bne cr6, 0x8289f3e0
	if !ctx.cr[6].eq {
	pc = 0x8289F3E0; continue 'dispatch;
	}
	// 8289F3DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F3E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F3E4: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F3E8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8289F3EC: 4BF0D065  bl 0x827ac450
	ctx.lr = 0x8289F3F0;
	sub_827AC450(ctx, base);
	// 8289F3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289F3F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F3F8: 4BA6B6D9  bl 0x8230aad0
	ctx.lr = 0x8289F3FC;
	sub_8230AAD0(ctx, base);
	// 8289F3FC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8289F400: 4BBCAC01  bl 0x8246a000
	ctx.lr = 0x8289F404;
	sub_8246A000(ctx, base);
	// 8289F404: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8289F408: 48552889  bl 0x82df1c90
	ctx.lr = 0x8289F40C;
	sub_82DF1C90(ctx, base);
	// 8289F40C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8289F410: 48552881  bl 0x82df1c90
	ctx.lr = 0x8289F414;
	sub_82DF1C90(ctx, base);
	// 8289F414: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8289F41C: 419A00B4  beq cr6, 0x8289f4d0
	if ctx.cr[6].eq {
	pc = 0x8289F4D0; continue 'dispatch;
	}
	// 8289F420: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289F424: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8289F428: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F42C: 418200A4  beq 0x8289f4d0
	if ctx.cr[0].eq {
	pc = 0x8289F4D0; continue 'dispatch;
	}
	// 8289F430: 817D0424  lwz r11, 0x424(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1060 as u32) ) } as u64;
	// 8289F434: 3BFD0420  addi r31, r29, 0x420
	ctx.r[31].s64 = ctx.r[29].s64 + 1056;
	// 8289F438: 813D0420  lwz r9, 0x420(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1056 as u32) ) } as u64;
	// 8289F43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F440: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8289F444: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 8289F448: 419A0028  beq cr6, 0x8289f470
	if ctx.cr[6].eq {
	pc = 0x8289F470; continue 'dispatch;
	}
	// 8289F44C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F450: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F454: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F458: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F45C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F460: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F464: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F468: 4082FFE8  bne 0x8289f450
	if !ctx.cr[0].eq {
	pc = 0x8289F450; continue 'dispatch;
	}
	// 8289F46C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F470: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F474: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F478: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8289F47C: 38A0043D  li r5, 0x43d
	ctx.r[5].s64 = 1085;
	// 8289F480: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8289F484: 485B7B65  bl 0x82e56fe8
	ctx.lr = 0x8289F488;
	sub_82E56FE8(ctx, base);
	// 8289F488: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289F48C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F490: 419A0008  beq cr6, 0x8289f498
	if ctx.cr[6].eq {
	pc = 0x8289F498; continue 'dispatch;
	}
	// 8289F494: 4BA213FD  bl 0x822c0890
	ctx.lr = 0x8289F498;
	sub_822C0890(ctx, base);
	// 8289F498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F49C: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F4A0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8289F4A4: 4099002C  ble cr6, 0x8289f4d0
	if !ctx.cr[6].gt {
	pc = 0x8289F4D0; continue 'dispatch;
	}
	// 8289F4A8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8289F4AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F4B0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 8289F4B4: 41980008  blt cr6, 0x8289f4bc
	if ctx.cr[6].lt {
	pc = 0x8289F4BC; continue 'dispatch;
	}
	// 8289F4B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289F4BC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F4C0: 41820010  beq 0x8289f4d0
	if ctx.cr[0].eq {
	pc = 0x8289F4D0; continue 'dispatch;
	}
	// 8289F4C4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F4C8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8289F4CC: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F4D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8289F4D4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8289F4D8: 409AFECC  bne cr6, 0x8289f3a4
	if !ctx.cr[6].eq {
	pc = 0x8289F3A4; continue 'dispatch;
	}
	// 8289F4DC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8289F4E0: 409A0024  bne cr6, 0x8289f504
	if !ctx.cr[6].eq {
	pc = 0x8289F504; continue 'dispatch;
	}
	// 8289F4E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289F4E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F4EC: 4BBCAB15  bl 0x8246a000
	ctx.lr = 0x8289F4F0;
	sub_8246A000(ctx, base);
	// 8289F4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F4F4: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 8289F4F8: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8289F4FC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8289F500: 48908CB0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 8289F504: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 8289F508: 935D0374  stw r26, 0x374(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(884 as u32), ctx.r[26].u32 ) };
	// 8289F50C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 8289F510: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8289F514: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8289F518: 4BA7DCB9  bl 0x8231d1d0
	ctx.lr = 0x8289F51C;
	sub_8231D1D0(ctx, base);
	// 8289F51C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F520: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8289F524: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289F528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F52C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8289F530: 419A0024  beq cr6, 0x8289f554
	if ctx.cr[6].eq {
	pc = 0x8289F554; continue 'dispatch;
	}
	// 8289F534: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F538: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F53C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F540: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F544: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F548: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F54C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F550: 4082FFE8  bne 0x8289f538
	if !ctx.cr[0].eq {
	pc = 0x8289F538; continue 'dispatch;
	}
	// 8289F554: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 8289F558: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F55C: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 8289F560: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8289F564: 38A00450  li r5, 0x450
	ctx.r[5].s64 = 1104;
	// 8289F568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F56C: 485B7A7D  bl 0x82e56fe8
	ctx.lr = 0x8289F570;
	sub_82E56FE8(ctx, base);
	// 8289F570: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8289F574: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F578: 419A0008  beq cr6, 0x8289f580
	if ctx.cr[6].eq {
	pc = 0x8289F580; continue 'dispatch;
	}
	// 8289F57C: 4BA21315  bl 0x822c0890
	ctx.lr = 0x8289F580;
	sub_822C0890(ctx, base);
	// 8289F580: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 8289F584: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F588: 419A0008  beq cr6, 0x8289f590
	if ctx.cr[6].eq {
	pc = 0x8289F590; continue 'dispatch;
	}
	// 8289F58C: 4BA21305  bl 0x822c0890
	ctx.lr = 0x8289F590;
	sub_822C0890(ctx, base);
	// 8289F590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289F598: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8289F59C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8289F5A0: 4BFFC381  bl 0x8289b920
	ctx.lr = 0x8289F5A4;
	sub_8289B920(ctx, base);
	// 8289F5A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F5A8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8289F5AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289F5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F5B4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8289F5B8: 419A0024  beq cr6, 0x8289f5dc
	if ctx.cr[6].eq {
	pc = 0x8289F5DC; continue 'dispatch;
	}
	// 8289F5BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F5C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F5C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F5C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F5CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F5D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F5D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F5D8: 4082FFE8  bne 0x8289f5c0
	if !ctx.cr[0].eq {
	pc = 0x8289F5C0; continue 'dispatch;
	}
	// 8289F5DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F5E0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8289F5E4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8289F5E8: 38A00451  li r5, 0x451
	ctx.r[5].s64 = 1105;
	// 8289F5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F5F0: 485B79F9  bl 0x82e56fe8
	ctx.lr = 0x8289F5F4;
	sub_82E56FE8(ctx, base);
	// 8289F5F4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8289F5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F5FC: 419A0008  beq cr6, 0x8289f604
	if ctx.cr[6].eq {
	pc = 0x8289F604; continue 'dispatch;
	}
	// 8289F600: 4BA21291  bl 0x822c0890
	ctx.lr = 0x8289F604;
	sub_822C0890(ctx, base);
	// 8289F604: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8289F608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F60C: 419A0008  beq cr6, 0x8289f614
	if ctx.cr[6].eq {
	pc = 0x8289F614; continue 'dispatch;
	}
	// 8289F610: 4BA21281  bl 0x822c0890
	ctx.lr = 0x8289F614;
	sub_822C0890(ctx, base);
	// 8289F614: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8289F618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289F61C: 48222975  bl 0x82ac1f90
	ctx.lr = 0x8289F620;
	sub_82AC1F90(ctx, base);
	// 8289F620: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8289F624: 4BFFFEC4  b 0x8289f4e8
	pc = 0x8289F4E8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289F628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289F628 size=984
    let mut pc: u32 = 0x8289F628;
    'dispatch: loop {
        match pc {
            0x8289F628 => {
    //   block [0x8289F628..0x8289FA00)
	// 8289F628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289F62C: 48908B35  bl 0x831a8160
	ctx.lr = 0x8289F630;
	sub_831A8130(ctx, base);
	// 8289F630: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8289F634: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8289F638: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289F63C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8289F640: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8289F644: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8289F648: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F64C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8289F650: 4BC6FE79  bl 0x8250f4c8
	ctx.lr = 0x8289F654;
	sub_8250F4C8(ctx, base);
	// 8289F654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F65C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289F660: 409A0008  bne cr6, 0x8289f668
	if !ctx.cr[6].eq {
	pc = 0x8289F668; continue 'dispatch;
	}
	// 8289F664: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F668: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8289F66C: 4BC6AF5D  bl 0x8250a5c8
	ctx.lr = 0x8289F670;
	sub_8250A5C8(ctx, base);
	// 8289F670: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F678: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 8289F67C: 409A0008  bne cr6, 0x8289f684
	if !ctx.cr[6].eq {
	pc = 0x8289F684; continue 'dispatch;
	}
	// 8289F680: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F684: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F688: 80BD0430  lwz r5, 0x430(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1072 as u32) ) } as u64;
	// 8289F68C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F690: 4BF0CDC1  bl 0x827ac450
	ctx.lr = 0x8289F694;
	sub_827AC450(ctx, base);
	// 8289F694: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8289F698: 485525F9  bl 0x82df1c90
	ctx.lr = 0x8289F69C;
	sub_82DF1C90(ctx, base);
	// 8289F69C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8289F6A0: 485525F1  bl 0x82df1c90
	ctx.lr = 0x8289F6A4;
	sub_82DF1C90(ctx, base);
	// 8289F6A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289F6A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8289F6AC: 3B6B8F18  addi r27, r11, -0x70e8
	ctx.r[27].s64 = ctx.r[11].s64 + -28904;
	// 8289F6B0: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8289F6B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F6BC: 419A00B4  beq cr6, 0x8289f770
	if ctx.cr[6].eq {
	pc = 0x8289F770; continue 'dispatch;
	}
	// 8289F6C0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289F6C4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8289F6C8: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8289F6CC: 418200A4  beq 0x8289f770
	if ctx.cr[0].eq {
	pc = 0x8289F770; continue 'dispatch;
	}
	// 8289F6D0: 815D0424  lwz r10, 0x424(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1060 as u32) ) } as u64;
	// 8289F6D4: 3BFD0420  addi r31, r29, 0x420
	ctx.r[31].s64 = ctx.r[29].s64 + 1056;
	// 8289F6D8: 813D0420  lwz r9, 0x420(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1056 as u32) ) } as u64;
	// 8289F6DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8289F6E0: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8289F6E4: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 8289F6E8: 419A0028  beq cr6, 0x8289f710
	if ctx.cr[6].eq {
	pc = 0x8289F710; continue 'dispatch;
	}
	// 8289F6EC: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 8289F6F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F6F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F6F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F6FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F708: 4082FFE8  bne 0x8289f6f0
	if !ctx.cr[0].eq {
	pc = 0x8289F6F0; continue 'dispatch;
	}
	// 8289F70C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F710: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F714: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F718: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8289F71C: 38A0042D  li r5, 0x42d
	ctx.r[5].s64 = 1069;
	// 8289F720: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8289F724: 485B78C5  bl 0x82e56fe8
	ctx.lr = 0x8289F728;
	sub_82E56FE8(ctx, base);
	// 8289F728: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8289F72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F730: 419A0008  beq cr6, 0x8289f738
	if ctx.cr[6].eq {
	pc = 0x8289F738; continue 'dispatch;
	}
	// 8289F734: 4BA2115D  bl 0x822c0890
	ctx.lr = 0x8289F738;
	sub_822C0890(ctx, base);
	// 8289F738: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F73C: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F740: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8289F744: 4099002C  ble cr6, 0x8289f770
	if !ctx.cr[6].gt {
	pc = 0x8289F770; continue 'dispatch;
	}
	// 8289F748: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8289F74C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F750: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 8289F754: 41990008  bgt cr6, 0x8289f75c
	if ctx.cr[6].gt {
	pc = 0x8289F75C; continue 'dispatch;
	}
	// 8289F758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289F75C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F760: 41820010  beq 0x8289f770
	if ctx.cr[0].eq {
	pc = 0x8289F770; continue 'dispatch;
	}
	// 8289F764: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F768: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8289F76C: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F770: 839D0440  lwz r28, 0x440(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1088 as u32) ) } as u64;
	// 8289F774: 83DD043C  lwz r30, 0x43c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1084 as u32) ) } as u64;
	// 8289F778: 48000134  b 0x8289f8ac
	pc = 0x8289F8AC; continue 'dispatch;
	// 8289F77C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8289F780: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8289F784: 4BC6FD45  bl 0x8250f4c8
	ctx.lr = 0x8289F788;
	sub_8250F4C8(ctx, base);
	// 8289F788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F78C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F790: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8289F794: 409A0008  bne cr6, 0x8289f79c
	if !ctx.cr[6].eq {
	pc = 0x8289F79C; continue 'dispatch;
	}
	// 8289F798: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F79C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8289F7A0: 4BC6AE29  bl 0x8250a5c8
	ctx.lr = 0x8289F7A4;
	sub_8250A5C8(ctx, base);
	// 8289F7A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F7AC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 8289F7B0: 409A0008  bne cr6, 0x8289f7b8
	if !ctx.cr[6].eq {
	pc = 0x8289F7B8; continue 'dispatch;
	}
	// 8289F7B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8289F7B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8289F7BC: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F7C0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8289F7C4: 4BF0CC8D  bl 0x827ac450
	ctx.lr = 0x8289F7C8;
	sub_827AC450(ctx, base);
	// 8289F7C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8289F7CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F7D0: 4BA6B301  bl 0x8230aad0
	ctx.lr = 0x8289F7D4;
	sub_8230AAD0(ctx, base);
	// 8289F7D4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8289F7D8: 4BBCA829  bl 0x8246a000
	ctx.lr = 0x8289F7DC;
	sub_8246A000(ctx, base);
	// 8289F7DC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8289F7E0: 485524B1  bl 0x82df1c90
	ctx.lr = 0x8289F7E4;
	sub_82DF1C90(ctx, base);
	// 8289F7E4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8289F7E8: 485524A9  bl 0x82df1c90
	ctx.lr = 0x8289F7EC;
	sub_82DF1C90(ctx, base);
	// 8289F7EC: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F7F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8289F7F4: 419A00B4  beq cr6, 0x8289f8a8
	if ctx.cr[6].eq {
	pc = 0x8289F8A8; continue 'dispatch;
	}
	// 8289F7F8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8289F7FC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8289F800: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F804: 418200A4  beq 0x8289f8a8
	if ctx.cr[0].eq {
	pc = 0x8289F8A8; continue 'dispatch;
	}
	// 8289F808: 817D0424  lwz r11, 0x424(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1060 as u32) ) } as u64;
	// 8289F80C: 3BFD0420  addi r31, r29, 0x420
	ctx.r[31].s64 = ctx.r[29].s64 + 1056;
	// 8289F810: 813D0420  lwz r9, 0x420(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1056 as u32) ) } as u64;
	// 8289F814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F818: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8289F81C: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 8289F820: 419A0028  beq cr6, 0x8289f848
	if ctx.cr[6].eq {
	pc = 0x8289F848; continue 'dispatch;
	}
	// 8289F824: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F828: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F82C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F830: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F834: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F838: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F83C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F840: 4082FFE8  bne 0x8289f828
	if !ctx.cr[0].eq {
	pc = 0x8289F828; continue 'dispatch;
	}
	// 8289F844: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F848: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F84C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F850: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8289F854: 38A0043D  li r5, 0x43d
	ctx.r[5].s64 = 1085;
	// 8289F858: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8289F85C: 485B778D  bl 0x82e56fe8
	ctx.lr = 0x8289F860;
	sub_82E56FE8(ctx, base);
	// 8289F860: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8289F864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F868: 419A0008  beq cr6, 0x8289f870
	if ctx.cr[6].eq {
	pc = 0x8289F870; continue 'dispatch;
	}
	// 8289F86C: 4BA21025  bl 0x822c0890
	ctx.lr = 0x8289F870;
	sub_822C0890(ctx, base);
	// 8289F870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F874: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289F878: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8289F87C: 4099002C  ble cr6, 0x8289f8a8
	if !ctx.cr[6].gt {
	pc = 0x8289F8A8; continue 'dispatch;
	}
	// 8289F880: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8289F884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F888: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 8289F88C: 41990008  bgt cr6, 0x8289f894
	if ctx.cr[6].gt {
	pc = 0x8289F894; continue 'dispatch;
	}
	// 8289F890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8289F894: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289F898: 41820010  beq 0x8289f8a8
	if ctx.cr[0].eq {
	pc = 0x8289F8A8; continue 'dispatch;
	}
	// 8289F89C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8289F8A0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 8289F8A4: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F8A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8289F8AC: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8289F8B0: 409AFECC  bne cr6, 0x8289f77c
	if !ctx.cr[6].eq {
	pc = 0x8289F77C; continue 'dispatch;
	}
	// 8289F8B4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8289F8B8: 409A0024  bne cr6, 0x8289f8dc
	if !ctx.cr[6].eq {
	pc = 0x8289F8DC; continue 'dispatch;
	}
	// 8289F8BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8289F8C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8289F8C4: 4BBCA73D  bl 0x8246a000
	ctx.lr = 0x8289F8C8;
	sub_8246A000(ctx, base);
	// 8289F8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F8CC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 8289F8D0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8289F8D4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8289F8D8: 489088D8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 8289F8DC: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 8289F8E0: 935D0374  stw r26, 0x374(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(884 as u32), ctx.r[26].u32 ) };
	// 8289F8E4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 8289F8E8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 8289F8EC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8289F8F0: 4BA7D8E1  bl 0x8231d1d0
	ctx.lr = 0x8289F8F4;
	sub_8231D1D0(ctx, base);
	// 8289F8F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F8F8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8289F8FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289F900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F904: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8289F908: 419A0024  beq cr6, 0x8289f92c
	if ctx.cr[6].eq {
	pc = 0x8289F92C; continue 'dispatch;
	}
	// 8289F90C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F910: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F914: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F918: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F91C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F920: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F924: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F928: 4082FFE8  bne 0x8289f910
	if !ctx.cr[0].eq {
	pc = 0x8289F910; continue 'dispatch;
	}
	// 8289F92C: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 8289F930: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F934: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 8289F938: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8289F93C: 38A00450  li r5, 0x450
	ctx.r[5].s64 = 1104;
	// 8289F940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F944: 485B76A5  bl 0x82e56fe8
	ctx.lr = 0x8289F948;
	sub_82E56FE8(ctx, base);
	// 8289F948: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8289F94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F950: 419A0008  beq cr6, 0x8289f958
	if ctx.cr[6].eq {
	pc = 0x8289F958; continue 'dispatch;
	}
	// 8289F954: 4BA20F3D  bl 0x822c0890
	ctx.lr = 0x8289F958;
	sub_822C0890(ctx, base);
	// 8289F958: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 8289F95C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F960: 419A0008  beq cr6, 0x8289f968
	if ctx.cr[6].eq {
	pc = 0x8289F968; continue 'dispatch;
	}
	// 8289F964: 4BA20F2D  bl 0x822c0890
	ctx.lr = 0x8289F968;
	sub_822C0890(ctx, base);
	// 8289F968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8289F96C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8289F970: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8289F974: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8289F978: 4BFFBFA9  bl 0x8289b920
	ctx.lr = 0x8289F97C;
	sub_8289B920(ctx, base);
	// 8289F97C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289F980: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8289F984: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289F988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8289F98C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8289F990: 419A0024  beq cr6, 0x8289f9b4
	if ctx.cr[6].eq {
	pc = 0x8289F9B4; continue 'dispatch;
	}
	// 8289F994: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8289F998: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8289F99C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F9A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8289F9A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8289F9A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8289F9AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8289F9B0: 4082FFE8  bne 0x8289f998
	if !ctx.cr[0].eq {
	pc = 0x8289F998; continue 'dispatch;
	}
	// 8289F9B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8289F9B8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8289F9BC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8289F9C0: 38A00451  li r5, 0x451
	ctx.r[5].s64 = 1105;
	// 8289F9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289F9C8: 485B7621  bl 0x82e56fe8
	ctx.lr = 0x8289F9CC;
	sub_82E56FE8(ctx, base);
	// 8289F9CC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8289F9D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F9D4: 419A0008  beq cr6, 0x8289f9dc
	if ctx.cr[6].eq {
	pc = 0x8289F9DC; continue 'dispatch;
	}
	// 8289F9D8: 4BA20EB9  bl 0x822c0890
	ctx.lr = 0x8289F9DC;
	sub_822C0890(ctx, base);
	// 8289F9DC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8289F9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289F9E4: 419A0008  beq cr6, 0x8289f9ec
	if ctx.cr[6].eq {
	pc = 0x8289F9EC; continue 'dispatch;
	}
	// 8289F9E8: 4BA20EA9  bl 0x822c0890
	ctx.lr = 0x8289F9EC;
	sub_822C0890(ctx, base);
	// 8289F9EC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8289F9F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8289F9F4: 4822259D  bl 0x82ac1f90
	ctx.lr = 0x8289F9F8;
	sub_82AC1F90(ctx, base);
	// 8289F9F8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 8289F9FC: 4BFFFEC4  b 0x8289f8c0
	pc = 0x8289F8C0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289FA00 size=288
    let mut pc: u32 = 0x8289FA00;
    'dispatch: loop {
        match pc {
            0x8289FA00 => {
    //   block [0x8289FA00..0x8289FB20)
	// 8289FA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FA04: 48908761  bl 0x831a8164
	ctx.lr = 0x8289FA08;
	sub_831A8130(ctx, base);
	// 8289FA08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FA0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8289FA10: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8289FA14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8289FA18: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 8289FA1C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 8289FA20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FA24: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8289FA28: 480710F1  bl 0x82910b18
	ctx.lr = 0x8289FA2C;
	sub_82910B18(ctx, base);
	// 8289FA2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8289FA30: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8289FA34: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8289FA38: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 8289FA3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8289FA40: 396B919C  addi r11, r11, -0x6e64
	ctx.r[11].s64 = ctx.r[11].s64 + -28260;
	// 8289FA44: 394A9184  addi r10, r10, -0x6e7c
	ctx.r[10].s64 = ctx.r[10].s64 + -28284;
	// 8289FA48: 9BDF0360  stb r30, 0x360(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[30].u8 ) };
	// 8289FA4C: 39299168  addi r9, r9, -0x6e98
	ctx.r[9].s64 = ctx.r[9].s64 + -28312;
	// 8289FA50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8289FA54: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8289FA58: C0088950  lfs f0, -0x76b0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8289FA5C: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8289FA60: 394003F0  li r10, 0x3f0
	ctx.r[10].s64 = 1008;
	// 8289FA64: 93DF0364  stw r30, 0x364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(868 as u32), ctx.r[30].u32 ) };
	// 8289FA68: 397F0430  addi r11, r31, 0x430
	ctx.r[11].s64 = ctx.r[31].s64 + 1072;
	// 8289FA6C: 93DF0368  stw r30, 0x368(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[30].u32 ) };
	// 8289FA70: D01F0370  stfs f0, 0x370(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), tmp.u32 ) };
	// 8289FA74: 9BDF036C  stb r30, 0x36c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), ctx.r[30].u8 ) };
	// 8289FA78: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 8289FA7C: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 8289FA80: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 8289FA84: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 8289FA88: 9BDF03A4  stb r30, 0x3a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[30].u8 ) };
	// 8289FA8C: 9BDF03B8  stb r30, 0x3b8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[30].u8 ) };
	// 8289FA90: 9BDF03E0  stb r30, 0x3e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[30].u8 ) };
	// 8289FA94: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FB20 size=12
    let mut pc: u32 = 0x8289FB20;
    'dispatch: loop {
        match pc {
            0x8289FB20 => {
    //   block [0x8289FB20..0x8289FB2C)
	// 8289FB20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8289FB24: 386300D4  addi r3, r3, 0xd4
	ctx.r[3].s64 = ctx.r[3].s64 + 212;
	// 8289FB28: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FB2C size=8
    let mut pc: u32 = 0x8289FB2C;
    'dispatch: loop {
        match pc {
            0x8289FB2C => {
    //   block [0x8289FB2C..0x8289FB34)
	// 8289FB2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289FB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FB38 size=8
    let mut pc: u32 = 0x8289FB38;
    'dispatch: loop {
        match pc {
            0x8289FB38 => {
    //   block [0x8289FB38..0x8289FB40)
	// 8289FB38: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 8289FB3C: 480000E4  b 0x8289fc20
	sub_8289FC20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FB40 size=8
    let mut pc: u32 = 0x8289FB40;
    'dispatch: loop {
        match pc {
            0x8289FB40 => {
    //   block [0x8289FB40..0x8289FB48)
	// 8289FB40: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8289FB44: 480000DC  b 0x8289fc20
	sub_8289FC20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289FB48 size=48
    let mut pc: u32 = 0x8289FB48;
    'dispatch: loop {
        match pc {
            0x8289FB48 => {
    //   block [0x8289FB48..0x8289FB78)
	// 8289FB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FB4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FB50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FB54: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8289FB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FB5C: 419A0008  beq cr6, 0x8289fb64
	if ctx.cr[6].eq {
	pc = 0x8289FB64; continue 'dispatch;
	}
	// 8289FB60: 4BA20D31  bl 0x822c0890
	ctx.lr = 0x8289FB64;
	sub_822C0890(ctx, base);
	// 8289FB64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289FB68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289FB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289FB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289FB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289FB78 size=168
    let mut pc: u32 = 0x8289FB78;
    'dispatch: loop {
        match pc {
            0x8289FB78 => {
    //   block [0x8289FB78..0x8289FC20)
	// 8289FB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FB80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289FB84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FB88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FB8C: 387F0438  addi r3, r31, 0x438
	ctx.r[3].s64 = ctx.r[31].s64 + 1080;
	// 8289FB90: 4BBCA471  bl 0x8246a000
	ctx.lr = 0x8289FB94;
	sub_8246A000(ctx, base);
	// 8289FB94: 807F042C  lwz r3, 0x42c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1068 as u32) ) } as u64;
	// 8289FB98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FB9C: 419A0008  beq cr6, 0x8289fba4
	if ctx.cr[6].eq {
	pc = 0x8289FBA4; continue 'dispatch;
	}
	// 8289FBA0: 4BA20CF1  bl 0x822c0890
	ctx.lr = 0x8289FBA4;
	sub_822C0890(ctx, base);
	// 8289FBA4: 807F0424  lwz r3, 0x424(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 8289FBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBAC: 419A0008  beq cr6, 0x8289fbb4
	if ctx.cr[6].eq {
	pc = 0x8289FBB4; continue 'dispatch;
	}
	// 8289FBB0: 4BA20CE1  bl 0x822c0890
	ctx.lr = 0x8289FBB4;
	sub_822C0890(ctx, base);
	// 8289FBB4: 807F041C  lwz r3, 0x41c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1052 as u32) ) } as u64;
	// 8289FBB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBBC: 419A0008  beq cr6, 0x8289fbc4
	if ctx.cr[6].eq {
	pc = 0x8289FBC4; continue 'dispatch;
	}
	// 8289FBC0: 4BA20CD1  bl 0x822c0890
	ctx.lr = 0x8289FBC4;
	sub_822C0890(ctx, base);
	// 8289FBC4: 807F0414  lwz r3, 0x414(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 8289FBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBCC: 419A0008  beq cr6, 0x8289fbd4
	if ctx.cr[6].eq {
	pc = 0x8289FBD4; continue 'dispatch;
	}
	// 8289FBD0: 4BA20CC1  bl 0x822c0890
	ctx.lr = 0x8289FBD4;
	sub_822C0890(ctx, base);
	// 8289FBD4: 807F040C  lwz r3, 0x40c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) } as u64;
	// 8289FBD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBDC: 419A0008  beq cr6, 0x8289fbe4
	if ctx.cr[6].eq {
	pc = 0x8289FBE4; continue 'dispatch;
	}
	// 8289FBE0: 4BA20CB1  bl 0x822c0890
	ctx.lr = 0x8289FBE4;
	sub_822C0890(ctx, base);
	// 8289FBE4: 807F0404  lwz r3, 0x404(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) } as u64;
	// 8289FBE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBEC: 419A0008  beq cr6, 0x8289fbf4
	if ctx.cr[6].eq {
	pc = 0x8289FBF4; continue 'dispatch;
	}
	// 8289FBF0: 4BA20CA1  bl 0x822c0890
	ctx.lr = 0x8289FBF4;
	sub_822C0890(ctx, base);
	// 8289FBF4: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 8289FBF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8289FBFC: 419A0008  beq cr6, 0x8289fc04
	if ctx.cr[6].eq {
	pc = 0x8289FC04; continue 'dispatch;
	}
	// 8289FC00: 4BA20C91  bl 0x822c0890
	ctx.lr = 0x8289FC04;
	sub_822C0890(ctx, base);
	// 8289FC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289FC08: 48071089  bl 0x82910c90
	ctx.lr = 0x8289FC0C;
	sub_82910C90(ctx, base);
	// 8289FC0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289FC10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289FC14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289FC18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289FC1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289FC20 size=76
    let mut pc: u32 = 0x8289FC20;
    'dispatch: loop {
        match pc {
            0x8289FC20 => {
    //   block [0x8289FC20..0x8289FC6C)
	// 8289FC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289FC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289FC30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FC34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FC38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289FC3C: 4BFFFF3D  bl 0x8289fb78
	ctx.lr = 0x8289FC40;
	sub_8289FB78(ctx, base);
	// 8289FC40: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8289FC44: 4182000C  beq 0x8289fc50
	if ctx.cr[0].eq {
	pc = 0x8289FC50; continue 'dispatch;
	}
	// 8289FC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289FC4C: 4855278D  bl 0x82df23d8
	ctx.lr = 0x8289FC50;
	sub_82DF23D8(ctx, base);
	// 8289FC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289FC54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289FC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289FC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289FC60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8289FC64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8289FC68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289FC70 size=124
    let mut pc: u32 = 0x8289FC70;
    'dispatch: loop {
        match pc {
            0x8289FC70 => {
    //   block [0x8289FC70..0x8289FCEC)
	// 8289FC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FC74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FC78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FC7C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 8289FC80: 81430448  lwz r10, 0x448(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1096 as u32) ) } as u64;
	// 8289FC84: 396BB210  addi r11, r11, -0x4df0
	ctx.r[11].s64 = ctx.r[11].s64 + -19952;
	// 8289FC88: 1D4A023C  mulli r10, r10, 0x23c
	ctx.r[10].s64 = ctx.r[10].s64 * 572;
	// 8289FC8C: 396B0054  addi r11, r11, 0x54
	ctx.r[11].s64 = ctx.r[11].s64 + 84;
	// 8289FC90: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8289FC94: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8289FC98: 41980040  blt cr6, 0x8289fcd8
	if ctx.cr[6].lt {
	pc = 0x8289FCD8; continue 'dispatch;
	}
	// 8289FC9C: 419A0028  beq cr6, 0x8289fcc4
	if ctx.cr[6].eq {
	pc = 0x8289FCC4; continue 'dispatch;
	}
	// 8289FCA0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8289FCA4: 4198000C  blt cr6, 0x8289fcb0
	if ctx.cr[6].lt {
	pc = 0x8289FCB0; continue 'dispatch;
	}
	// 8289FCA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289FCAC: 48000030  b 0x8289fcdc
	pc = 0x8289FCDC; continue 'dispatch;
	// 8289FCB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8289FCB4: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289FCB8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289FCBC: 4BFFF96D  bl 0x8289f628
	ctx.lr = 0x8289FCC0;
	sub_8289F628(ctx, base);
	// 8289FCC0: 4800001C  b 0x8289fcdc
	pc = 0x8289FCDC; continue 'dispatch;
	// 8289FCC4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8289FCC8: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8289FCCC: C02BC350  lfs f1, -0x3cb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8289FCD0: 4BFFF581  bl 0x8289f250
	ctx.lr = 0x8289FCD4;
	sub_8289F250(ctx, base);
	// 8289FCD4: 48000008  b 0x8289fcdc
	pc = 0x8289FCDC; continue 'dispatch;
	// 8289FCD8: 4BFFD801  bl 0x8289d4d8
	ctx.lr = 0x8289FCDC;
	sub_8289D4D8(ctx, base);
	// 8289FCDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8289FCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289FCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289FCE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FCF0 size=8
    let mut pc: u32 = 0x8289FCF0;
    'dispatch: loop {
        match pc {
            0x8289FCF0 => {
    //   block [0x8289FCF0..0x8289FCF8)
	// 8289FCF0: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FCF4: 48173994  b 0x82a13688
	sub_82A13688(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FCF8 size=8
    let mut pc: u32 = 0x8289FCF8;
    'dispatch: loop {
        match pc {
            0x8289FCF8 => {
    //   block [0x8289FCF8..0x8289FD00)
	// 8289FCF8: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FCFC: 4820B7DC  b 0x82aab4d8
	sub_82AAB4D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD00 size=8
    let mut pc: u32 = 0x8289FD00;
    'dispatch: loop {
        match pc {
            0x8289FD00 => {
    //   block [0x8289FD00..0x8289FD08)
	// 8289FD00: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD04: 4BFF848C  b 0x82898190
	sub_82898190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD08 size=8
    let mut pc: u32 = 0x8289FD08;
    'dispatch: loop {
        match pc {
            0x8289FD08 => {
    //   block [0x8289FD08..0x8289FD10)
	// 8289FD08: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD0C: 4BFF8E1C  b 0x82898b28
	sub_82898B28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD10 size=8
    let mut pc: u32 = 0x8289FD10;
    'dispatch: loop {
        match pc {
            0x8289FD10 => {
    //   block [0x8289FD10..0x8289FD18)
	// 8289FD10: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD14: 4BFF8444  b 0x82898158
	sub_82898158(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD18 size=20
    let mut pc: u32 = 0x8289FD18;
    'dispatch: loop {
        match pc {
            0x8289FD18 => {
    //   block [0x8289FD18..0x8289FD2C)
	// 8289FD18: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8289FD20: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 8289FD24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8289FD28: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD30 size=8
    let mut pc: u32 = 0x8289FD30;
    'dispatch: loop {
        match pc {
            0x8289FD30 => {
    //   block [0x8289FD30..0x8289FD38)
	// 8289FD30: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD34: 4BFF8DFC  b 0x82898b30
	sub_82898B30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD38 size=8
    let mut pc: u32 = 0x8289FD38;
    'dispatch: loop {
        match pc {
            0x8289FD38 => {
    //   block [0x8289FD38..0x8289FD40)
	// 8289FD38: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD3C: 4BFF844C  b 0x82898188
	sub_82898188(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD40 size=8
    let mut pc: u32 = 0x8289FD40;
    'dispatch: loop {
        match pc {
            0x8289FD40 => {
    //   block [0x8289FD40..0x8289FD48)
	// 8289FD40: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD44: 4BFF8E14  b 0x82898b58
	sub_82898B58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD48 size=8
    let mut pc: u32 = 0x8289FD48;
    'dispatch: loop {
        match pc {
            0x8289FD48 => {
    //   block [0x8289FD48..0x8289FD50)
	// 8289FD48: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD4C: 4BFFFF24  b 0x8289fc70
	sub_8289FC70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD50 size=8
    let mut pc: u32 = 0x8289FD50;
    'dispatch: loop {
        match pc {
            0x8289FD50 => {
    //   block [0x8289FD50..0x8289FD58)
	// 8289FD50: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD54: 4BFD41FC  b 0x82873f50
	sub_82873F50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD58 size=8
    let mut pc: u32 = 0x8289FD58;
    'dispatch: loop {
        match pc {
            0x8289FD58 => {
    //   block [0x8289FD58..0x8289FD60)
	// 8289FD58: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD5C: 4BFF8414  b 0x82898170
	sub_82898170(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD60 size=8
    let mut pc: u32 = 0x8289FD60;
    'dispatch: loop {
        match pc {
            0x8289FD60 => {
    //   block [0x8289FD60..0x8289FD68)
	// 8289FD60: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD64: 4BFF8404  b 0x82898168
	sub_82898168(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD68 size=8
    let mut pc: u32 = 0x8289FD68;
    'dispatch: loop {
        match pc {
            0x8289FD68 => {
    //   block [0x8289FD68..0x8289FD70)
	// 8289FD68: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD6C: 4BFF8D14  b 0x82898a80
	sub_82898A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD70 size=8
    let mut pc: u32 = 0x8289FD70;
    'dispatch: loop {
        match pc {
            0x8289FD70 => {
    //   block [0x8289FD70..0x8289FD78)
	// 8289FD70: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD74: 4BFF8D2C  b 0x82898aa0
	sub_82898AA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD78 size=8
    let mut pc: u32 = 0x8289FD78;
    'dispatch: loop {
        match pc {
            0x8289FD78 => {
    //   block [0x8289FD78..0x8289FD80)
	// 8289FD78: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD7C: 4BFF8D44  b 0x82898ac0
	sub_82898AC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD80 size=8
    let mut pc: u32 = 0x8289FD80;
    'dispatch: loop {
        match pc {
            0x8289FD80 => {
    //   block [0x8289FD80..0x8289FD88)
	// 8289FD80: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD84: 4BFF8E04  b 0x82898b88
	sub_82898B88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD88 size=8
    let mut pc: u32 = 0x8289FD88;
    'dispatch: loop {
        match pc {
            0x8289FD88 => {
    //   block [0x8289FD88..0x8289FD90)
	// 8289FD88: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD8C: 4BFF8E54  b 0x82898be0
	sub_82898BE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8289FD90 size=8
    let mut pc: u32 = 0x8289FD90;
    'dispatch: loop {
        match pc {
            0x8289FD90 => {
    //   block [0x8289FD90..0x8289FD98)
	// 8289FD90: 80630070  lwz r3, 0x70(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FD94: 4BFF8404  b 0x82898198
	sub_82898198(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8289FD98 size=52
    let mut pc: u32 = 0x8289FD98;
    'dispatch: loop {
        match pc {
            0x8289FD98 => {
    //   block [0x8289FD98..0x8289FDCC)
	// 8289FD98: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 8289FD9C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8289FDA0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8289FDA4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8289FDA8: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8289FDAC: 13C85C07  vcmpneb. (lvlx128) v30, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8289FDB0: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8289FDB4: 138A5C07  vcmpneb. (lvlx128) v28, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289FDD0 size=184
    let mut pc: u32 = 0x8289FDD0;
    'dispatch: loop {
        match pc {
            0x8289FDD0 => {
    //   block [0x8289FDD0..0x8289FE88)
	// 8289FDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289FDDC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FDE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FDE4: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FDE8: 4BFF83A9  bl 0x82898190
	ctx.lr = 0x8289FDEC;
	sub_82898190(ctx, base);
	// 8289FDEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289FDF0: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FDF4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8289FDF8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8289FE88 size=224
    let mut pc: u32 = 0x8289FE88;
    'dispatch: loop {
        match pc {
            0x8289FE88 => {
    //   block [0x8289FE88..0x8289FF68)
	// 8289FE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FE90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289FE94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289FE98: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8289FE9C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FEA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8289FEA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FEA8: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FEAC: 4BFF82E5  bl 0x82898190
	ctx.lr = 0x8289FEB0;
	sub_82898190(ctx, base);
	// 8289FEB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8289FEB4: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FEB8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8289FEBC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8289FF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8289FF68 size=180
    let mut pc: u32 = 0x8289FF68;
    'dispatch: loop {
        match pc {
            0x8289FF68 => {
    //   block [0x8289FF68..0x828A001C)
	// 8289FF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8289FF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8289FF70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8289FF74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8289FF78: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8289FF7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8289FF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8289FF84: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FF88: 4BFF8AE1  bl 0x82898a68
	ctx.lr = 0x8289FF8C;
	sub_82898A68(ctx, base);
	// 8289FF8C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FF90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8289FF94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8289FF98: 4BFF8BC9  bl 0x82898b60
	ctx.lr = 0x8289FF9C;
	sub_82898B60(ctx, base);
	// 8289FF9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8289FFA0: 40820038  bne 0x8289ffd8
	if !ctx.cr[0].eq {
	pc = 0x8289FFD8; continue 'dispatch;
	}
	// 8289FFA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8289FFA8: 409A0060  bne cr6, 0x828a0008
	if !ctx.cr[6].eq {
	pc = 0x828A0008; continue 'dispatch;
	}
	// 8289FFAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289FFB0: 83FF0070  lwz r31, 0x70(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FFB4: 4BFFFE1D  bl 0x8289fdd0
	ctx.lr = 0x8289FFB8;
	sub_8289FDD0(ctx, base);
	// 8289FFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8289FFBC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8289FFC0: 4BFF8A69  bl 0x82898a28
	ctx.lr = 0x8289FFC4;
	sub_82898A28(ctx, base);
	// 8289FFC4: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 8289FFC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8289FFCC: 41980020  blt cr6, 0x8289ffec
	if ctx.cr[6].lt {
	pc = 0x8289FFEC; continue 'dispatch;
	}
	// 8289FFD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8289FFD4: 48000018  b 0x8289ffec
	pc = 0x8289FFEC; continue 'dispatch;
	// 8289FFD8: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8289FFDC: 4BFF8B85  bl 0x82898b60
	ctx.lr = 0x8289FFE0;
	sub_82898B60(ctx, base);
	// 8289FFE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8289FFE4: 4181FFC0  bgt 0x8289ffa4
	if ctx.cr[0].gt {
	pc = 0x8289FFA4; continue 'dispatch;
	}
	// 8289FFE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8289FFEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8289FFF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8289FFF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8289FFF8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8289FFFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A0000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0004: 4E800020  blr
	return;
	// 828A0008: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 828A000C: 409AFFDC  bne cr6, 0x8289ffe8
	if !ctx.cr[6].eq {
	pc = 0x8289FFE8; continue 'dispatch;
	}
	// 828A0010: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 828A0014: 4BFF814D  bl 0x82898160
	ctx.lr = 0x828A0018;
	sub_82898160(ctx, base);
	// 828A0018: 4BFFFFD4  b 0x8289ffec
	pc = 0x8289FFEC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A0020 size=116
    let mut pc: u32 = 0x828A0020;
    'dispatch: loop {
        match pc {
            0x828A0020 => {
    //   block [0x828A0020..0x828A0094)
	// 828A0020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A002C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0030: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828A0034: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A003C: 83DF0070  lwz r30, 0x70(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 828A0040: 4BFFFD91  bl 0x8289fdd0
	ctx.lr = 0x828A0044;
	sub_8289FDD0(ctx, base);
	// 828A0044: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0048: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828A004C: 4BFF89FD  bl 0x82898a48
	ctx.lr = 0x828A0050;
	sub_82898A48(ctx, base);
	// 828A0050: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 828A0054: 41990020  bgt cr6, 0x828a0074
	if ctx.cr[6].gt {
	pc = 0x828A0074; continue 'dispatch;
	}
	// 828A0058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A005C: 4BFFFD75  bl 0x8289fdd0
	ctx.lr = 0x828A0060;
	sub_8289FDD0(ctx, base);
	// 828A0060: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A0064: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A0068: C00B093C  lfs f0, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A006C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A0070: 40990008  ble cr6, 0x828a0078
	if !ctx.cr[6].gt {
	pc = 0x828A0078; continue 'dispatch;
	}
	// 828A0074: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828A0078: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A007C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0084: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828A0088: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A008C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0098 size=52
    let mut pc: u32 = 0x828A0098;
    'dispatch: loop {
        match pc {
            0x828A0098 => {
    //   block [0x828A0098..0x828A00CC)
	// 828A0098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A009C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A00A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A00A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A00A8: 80840070  lwz r4, 0x70(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) } as u64;
	// 828A00AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A00B0: 4BFFA3D1  bl 0x8289a480
	ctx.lr = 0x828A00B4;
	sub_8289A480(ctx, base);
	// 828A00B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A00B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A00BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A00C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A00C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A00C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A00D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A00D0 size=12
    let mut pc: u32 = 0x828A00D0;
    'dispatch: loop {
        match pc {
            0x828A00D0 => {
    //   block [0x828A00D0..0x828A00DC)
	// 828A00D0: 896300E8  lbz r11, 0xe8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 828A00D4: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 828A00D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A00E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A00E0 size=12
    let mut pc: u32 = 0x828A00E0;
    'dispatch: loop {
        match pc {
            0x828A00E0 => {
    //   block [0x828A00E0..0x828A00EC)
	// 828A00E0: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A00E4: 996300E8  stb r11, 0xe8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 828A00E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A00F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A00F0 size=20
    let mut pc: u32 = 0x828A00F0;
    'dispatch: loop {
        match pc {
            0x828A00F0 => {
    //   block [0x828A00F0..0x828A0104)
	// 828A00F0: 81630114  lwz r11, 0x114(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A00F4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 828A00F8: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A00FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0100: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0104(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A0104 size=32
    let mut pc: u32 = 0x828A0104;
    'dispatch: loop {
        match pc {
            0x828A0104 => {
    //   block [0x828A0104..0x828A0124)
	// 828A0104: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A0108: 80C3010C  lwz r6, 0x10c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 828A010C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A0110: 38A000D8  li r5, 0xd8
	ctx.r[5].s64 = 216;
	// 828A0114: 388A9390  addi r4, r10, -0x6c70
	ctx.r[4].s64 = ctx.r[10].s64 + -27760;
	// 828A0118: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828A011C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A0120: 485B8B80  b 0x82e58ca0
	sub_82E58CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0124(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A0124 size=4
    let mut pc: u32 = 0x828A0124;
    'dispatch: loop {
        match pc {
            0x828A0124 => {
    //   block [0x828A0124..0x828A0128)
	// 828A0124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A0128 size=212
    let mut pc: u32 = 0x828A0128;
    'dispatch: loop {
        match pc {
            0x828A0128 => {
    //   block [0x828A0128..0x828A01FC)
	// 828A0128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A012C: 48908041  bl 0x831a816c
	ctx.lr = 0x828A0130;
	sub_831A8130(ctx, base);
	// 828A0130: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0134: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A0138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A013C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0140: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A0144: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828A0148: 485538C1  bl 0x82df3a08
	ctx.lr = 0x828A014C;
	sub_82DF3A08(ctx, base);
	// 828A014C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0150: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 828A0154: 485531B5  bl 0x82df3308
	ctx.lr = 0x828A0158;
	sub_82DF3308(ctx, base);
	// 828A0158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A015C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0160: 485532C9  bl 0x82df3428
	ctx.lr = 0x828A0164;
	sub_82DF3428(ctx, base);
	// 828A0164: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0168: 4182008C  beq 0x828a01f4
	if ctx.cr[0].eq {
	pc = 0x828A01F4; continue 'dispatch;
	}
	// 828A016C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A0170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A0174: 4BC6F355  bl 0x8250f4c8
	ctx.lr = 0x828A0178;
	sub_8250F4C8(ctx, base);
	// 828A0178: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A017C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0180: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828A0184: 409A0008  bne cr6, 0x828a018c
	if !ctx.cr[6].eq {
	pc = 0x828A018C; continue 'dispatch;
	}
	// 828A0188: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A018C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A0190: 4BC68821  bl 0x825089b0
	ctx.lr = 0x828A0194;
	sub_825089B0(ctx, base);
	// 828A0194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A019C: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 828A01A0: 409A0008  bne cr6, 0x828a01a8
	if !ctx.cr[6].eq {
	pc = 0x828A01A8; continue 'dispatch;
	}
	// 828A01A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A01A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828A01AC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828A01B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A01B4: 3BCB9FBC  addi r30, r11, -0x6044
	ctx.r[30].s64 = ctx.r[11].s64 + -24644;
	// 828A01B8: 3BAA6880  addi r29, r10, 0x6880
	ctx.r[29].s64 = ctx.r[10].s64 + 26752;
	// 828A01BC: 4BC7192D  bl 0x82511ae8
	ctx.lr = 0x828A01C0;
	sub_82511AE8(ctx, base);
	// 828A01C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A01C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828A01C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A01CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A01D0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828A01D4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828A01D8: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A01DC: C04AD5B8  lfs f2, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828A01E0: 4BA27BB9  bl 0x822c7d98
	ctx.lr = 0x828A01E4;
	sub_822C7D98(ctx, base);
	// 828A01E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A01E8: 48551AA9  bl 0x82df1c90
	ctx.lr = 0x828A01EC;
	sub_82DF1C90(ctx, base);
	// 828A01EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A01F0: 48551AA1  bl 0x82df1c90
	ctx.lr = 0x828A01F4;
	sub_82DF1C90(ctx, base);
	// 828A01F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A01F8: 48907FC4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0200 size=196
    let mut pc: u32 = 0x828A0200;
    'dispatch: loop {
        match pc {
            0x828A0200 => {
    //   block [0x828A0200..0x828A02C4)
	// 828A0200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A020C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A0218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A021C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A0220: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A0224: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A0228: 4BA20711  bl 0x822c0938
	ctx.lr = 0x828A022C;
	sub_822C0938(ctx, base);
	// 828A022C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0230: 41820028  beq 0x828a0258
	if ctx.cr[0].eq {
	pc = 0x828A0258; continue 'dispatch;
	}
	// 828A0234: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0238: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A023C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A0240: 392B93FC  addi r9, r11, -0x6c04
	ctx.r[9].s64 = ctx.r[11].s64 + -27652;
	// 828A0244: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A0248: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A024C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A0250: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A0254: 48000008  b 0x828a025c
	pc = 0x828A025C; continue 'dispatch;
	// 828A0258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A025C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A0260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0264: 409A0044  bne cr6, 0x828a02a8
	if !ctx.cr[6].eq {
	pc = 0x828A02A8; continue 'dispatch;
	}
	// 828A0268: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A026C: 419A001C  beq cr6, 0x828a0288
	if ctx.cr[6].eq {
	pc = 0x828A0288; continue 'dispatch;
	}
	// 828A0270: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0274: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A0278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A027C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A0284: 4E800421  bctrl
	ctx.lr = 0x828A0288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A0288: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A028C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A0290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0294: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A0298: 816BFD34  lwz r11, -0x2cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-716 as u32) ) } as u64;
	// 828A029C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A02A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A02A4: 4BA1FD5D  bl 0x822c0000
	ctx.lr = 0x828A02A8;
	sub_822C0000(ctx, base);
	// 828A02A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A02AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A02B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A02B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A02B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A02BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A02C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A02C8 size=196
    let mut pc: u32 = 0x828A02C8;
    'dispatch: loop {
        match pc {
            0x828A02C8 => {
    //   block [0x828A02C8..0x828A038C)
	// 828A02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A02CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A02D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A02D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A02D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A02DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A02E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A02E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A02E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A02EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A02F0: 4BA20649  bl 0x822c0938
	ctx.lr = 0x828A02F4;
	sub_822C0938(ctx, base);
	// 828A02F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A02F8: 41820028  beq 0x828a0320
	if ctx.cr[0].eq {
	pc = 0x828A0320; continue 'dispatch;
	}
	// 828A02FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0300: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A0304: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A0308: 392B9410  addi r9, r11, -0x6bf0
	ctx.r[9].s64 = ctx.r[11].s64 + -27632;
	// 828A030C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A0310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A0314: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A0318: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A031C: 48000008  b 0x828a0324
	pc = 0x828A0324; continue 'dispatch;
	// 828A0320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A0324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A0328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A032C: 409A0044  bne cr6, 0x828a0370
	if !ctx.cr[6].eq {
	pc = 0x828A0370; continue 'dispatch;
	}
	// 828A0330: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A0334: 419A001C  beq cr6, 0x828a0350
	if ctx.cr[6].eq {
	pc = 0x828A0350; continue 'dispatch;
	}
	// 828A0338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A033C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A0340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0344: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A034C: 4E800421  bctrl
	ctx.lr = 0x828A0350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A0350: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A0354: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A0358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A035C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A0360: 816BFD34  lwz r11, -0x2cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-716 as u32) ) } as u64;
	// 828A0364: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A0368: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A036C: 4BA1FC95  bl 0x822c0000
	ctx.lr = 0x828A0370;
	sub_822C0000(ctx, base);
	// 828A0370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A0378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A037C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A0384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0390 size=320
    let mut pc: u32 = 0x828A0390;
    'dispatch: loop {
        match pc {
            0x828A0390 => {
    //   block [0x828A0390..0x828A04D0)
	// 828A0390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0394: 48907DD1  bl 0x831a8164
	ctx.lr = 0x828A0398;
	sub_831A8130(ctx, base);
	// 828A0398: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A039C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A03A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A03A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A03A8: 388B9390  addi r4, r11, -0x6c70
	ctx.r[4].s64 = ctx.r[11].s64 + -27760;
	// 828A03AC: 38A00106  li r5, 0x106
	ctx.r[5].s64 = 262;
	// 828A03B0: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 828A03B4: 48552035  bl 0x82df23e8
	ctx.lr = 0x828A03B8;
	sub_82DF23E8(ctx, base);
	// 828A03B8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A03BC: 41820034  beq 0x828a03f0
	if ctx.cr[0].eq {
	pc = 0x828A03F0; continue 'dispatch;
	}
	// 828A03C0: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A03C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A03C8: 3BBF00EC  addi r29, r31, 0xec
	ctx.r[29].s64 = ctx.r[31].s64 + 236;
	// 828A03CC: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A03D0: 4BC71719  bl 0x82511ae8
	ctx.lr = 0x828A03D4;
	sub_82511AE8(ctx, base);
	// 828A03D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A03D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A03DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A03E0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828A03E4: 4BFFF61D  bl 0x8289fa00
	ctx.lr = 0x828A03E8;
	sub_8289FA00(ctx, base);
	// 828A03E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A03EC: 48000008  b 0x828a03f4
	pc = 0x828A03F4; continue 'dispatch;
	// 828A03F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A03F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A03F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A03FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A0400: 4BFFFEC9  bl 0x828a02c8
	ctx.lr = 0x828A0404;
	sub_828A02C8(ctx, base);
	// 828A0404: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A0408: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A040C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A0410: 4BA1FBF1  bl 0x822c0000
	ctx.lr = 0x828A0414;
	sub_822C0000(ctx, base);
	// 828A0414: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A0418: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A041C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0420: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A0424: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828A0428: 419A0024  beq cr6, 0x828a044c
	if ctx.cr[6].eq {
	pc = 0x828A044C; continue 'dispatch;
	}
	// 828A042C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828A0430: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A0434: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0438: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A043C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A0440: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A0444: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0448: 4082FFE8  bne 0x828a0430
	if !ctx.cr[0].eq {
	pc = 0x828A0430; continue 'dispatch;
	}
	// 828A044C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0450: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A0454: 4BC6F075  bl 0x8250f4c8
	ctx.lr = 0x828A0458;
	sub_8250F4C8(ctx, base);
	// 828A0458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A045C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0460: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828A0464: 409A0008  bne cr6, 0x828a046c
	if !ctx.cr[6].eq {
	pc = 0x828A046C; continue 'dispatch;
	}
	// 828A0468: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A046C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A0474: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828A0478: 4BC6F0A1  bl 0x8250f518
	ctx.lr = 0x828A047C;
	sub_8250F518(ctx, base);
	// 828A047C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0484: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A0488: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828A048C: 4BC6D07D  bl 0x8250d508
	ctx.lr = 0x828A0490;
	sub_8250D508(ctx, base);
	// 828A0490: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A0494: 485517FD  bl 0x82df1c90
	ctx.lr = 0x828A0498;
	sub_82DF1C90(ctx, base);
	// 828A0498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A049C: 485517F5  bl 0x82df1c90
	ctx.lr = 0x828A04A0;
	sub_82DF1C90(ctx, base);
	// 828A04A0: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 828A04A4: 48768B15  bl 0x83008fb8
	ctx.lr = 0x828A04A8;
	sub_83008FB8(ctx, base);
	// 828A04A8: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 828A04AC: 907F010C  stw r3, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[3].u32 ) };
	// 828A04B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A04B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828A04B8: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 828A04BC: 419A000C  beq cr6, 0x828a04c8
	if ctx.cr[6].eq {
	pc = 0x828A04C8; continue 'dispatch;
	}
	// 828A04C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A04C4: 4BA203CD  bl 0x822c0890
	ctx.lr = 0x828A04C8;
	sub_822C0890(ctx, base);
	// 828A04C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A04CC: 48907CE8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A04D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A04D0 size=264
    let mut pc: u32 = 0x828A04D0;
    'dispatch: loop {
        match pc {
            0x828A04D0 => {
    //   block [0x828A04D0..0x828A05D8)
	// 828A04D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A04D4: 48907C99  bl 0x831a816c
	ctx.lr = 0x828A04D8;
	sub_831A8130(ctx, base);
	// 828A04D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A04DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A04E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A04E4: 4BC714F5  bl 0x825119d8
	ctx.lr = 0x828A04E8;
	sub_825119D8(ctx, base);
	// 828A04E8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A04EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A04F0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828A04F4: 48553515  bl 0x82df3a08
	ctx.lr = 0x828A04F8;
	sub_82DF3A08(ctx, base);
	// 828A04F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A04FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A0500: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0504: 4BC6827D  bl 0x82508780
	ctx.lr = 0x828A0508;
	sub_82508780(ctx, base);
	// 828A0508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A050C: 48552F1D  bl 0x82df3428
	ctx.lr = 0x828A0510;
	sub_82DF3428(ctx, base);
	// 828A0510: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A0514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0518: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828A051C: 485534ED  bl 0x82df3a08
	ctx.lr = 0x828A0520;
	sub_82DF3A08(ctx, base);
	// 828A0520: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A0524: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A052C: 4BC68255  bl 0x82508780
	ctx.lr = 0x828A0530;
	sub_82508780(ctx, base);
	// 828A0530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0534: 48552EF5  bl 0x82df3428
	ctx.lr = 0x828A0538;
	sub_82DF3428(ctx, base);
	// 828A0538: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A053C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828A0540: 409A0008  bne cr6, 0x828a0548
	if !ctx.cr[6].eq {
	pc = 0x828A0548; continue 'dispatch;
	}
	// 828A0544: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A0548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A054C: 4BC68255  bl 0x825087a0
	ctx.lr = 0x828A0550;
	sub_825087A0(ctx, base);
	// 828A0550: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A0554: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A0558: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A055C: 41820074  beq 0x828a05d0
	if ctx.cr[0].eq {
	pc = 0x828A05D0; continue 'dispatch;
	}
	// 828A0560: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A0564: 915F0118  stw r10, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[10].u32 ) };
	// 828A0568: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 828A056C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0570: 419A0010  beq cr6, 0x828a0580
	if ctx.cr[6].eq {
	pc = 0x828A0580; continue 'dispatch;
	}
	// 828A0574: 813F00FC  lwz r9, 0xfc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 828A0578: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 828A057C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 828A0580: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A0584: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 828A0588: 41980008  blt cr6, 0x828a0590
	if ctx.cr[6].lt {
	pc = 0x828A0590; continue 'dispatch;
	}
	// 828A058C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828A0590: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0594: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A0598: 41980008  blt cr6, 0x828a05a0
	if ctx.cr[6].lt {
	pc = 0x828A05A0; continue 'dispatch;
	}
	// 828A059C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828A05A0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A05A4: 4099002C  ble cr6, 0x828a05d0
	if !ctx.cr[6].gt {
	pc = 0x828A05D0; continue 'dispatch;
	}
	// 828A05A8: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 828A05AC: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 828A05B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A05B4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828A05B8: 48768A01  bl 0x83008fb8
	ctx.lr = 0x828A05BC;
	sub_83008FB8(ctx, base);
	// 828A05BC: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 828A05C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A05C4: 4BFFFDCD  bl 0x828a0390
	ctx.lr = 0x828A05C8;
	sub_828A0390(ctx, base);
	// 828A05C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A05CC: 4082FFE0  bne 0x828a05ac
	if !ctx.cr[0].eq {
	pc = 0x828A05AC; continue 'dispatch;
	}
	// 828A05D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A05D4: 48907BE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A05D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A05D8 size=212
    let mut pc: u32 = 0x828A05D8;
    'dispatch: loop {
        match pc {
            0x828A05D8 => {
    //   block [0x828A05D8..0x828A06AC)
	// 828A05D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A05DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A05E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A05E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A05E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A05EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A05F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A05F4: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A05F8: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A05FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0600: 41820088  beq 0x828a0688
	if ctx.cr[0].eq {
	pc = 0x828A0688; continue 'dispatch;
	}
	// 828A0604: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A0608: 4BB33301  bl 0x823d3908
	ctx.lr = 0x828A060C;
	sub_823D3908(ctx, base);
	// 828A060C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0610: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A0614: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A0618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A061C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A0620: 419A0024  beq cr6, 0x828a0644
	if ctx.cr[6].eq {
	pc = 0x828A0644; continue 'dispatch;
	}
	// 828A0624: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A0628: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A062C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0630: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A0634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A0638: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A063C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0640: 4082FFE8  bne 0x828a0628
	if !ctx.cr[0].eq {
	pc = 0x828A0628; continue 'dispatch;
	}
	// 828A0644: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A0648: 80DF010C  lwz r6, 0x10c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 828A064C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A0650: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828A0654: 388A9390  addi r4, r10, -0x6c70
	ctx.r[4].s64 = ctx.r[10].s64 + -27760;
	// 828A0658: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 828A065C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828A0660: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A0664: 485B83DD  bl 0x82e58a40
	ctx.lr = 0x828A0668;
	sub_82E58A40(ctx, base);
	// 828A0668: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A066C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0670: 419A0008  beq cr6, 0x828a0678
	if ctx.cr[6].eq {
	pc = 0x828A0678; continue 'dispatch;
	}
	// 828A0674: 4BA2021D  bl 0x822c0890
	ctx.lr = 0x828A0678;
	sub_822C0890(ctx, base);
	// 828A0678: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A067C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0680: 419A0008  beq cr6, 0x828a0688
	if ctx.cr[6].eq {
	pc = 0x828A0688; continue 'dispatch;
	}
	// 828A0684: 4BA2020D  bl 0x822c0890
	ctx.lr = 0x828A0688;
	sub_822C0890(ctx, base);
	// 828A0688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A068C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0690: 4BC719D9  bl 0x82512068
	ctx.lr = 0x828A0694;
	sub_82512068(ctx, base);
	// 828A0694: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A0698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A069C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A06A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A06A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A06A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A06B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A06B0 size=256
    let mut pc: u32 = 0x828A06B0;
    'dispatch: loop {
        match pc {
            0x828A06B0 => {
    //   block [0x828A06B0..0x828A07B0)
	// 828A06B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A06B4: 48907AB5  bl 0x831a8168
	ctx.lr = 0x828A06B8;
	sub_831A8130(ctx, base);
	// 828A06B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A06BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A06C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A06C4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A06C8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A06CC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828A06D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A06D4: 419A00D4  beq cr6, 0x828a07a8
	if ctx.cr[6].eq {
	pc = 0x828A07A8; continue 'dispatch;
	}
	// 828A06D8: 48000C51  bl 0x828a1328
	ctx.lr = 0x828A06DC;
	sub_828A1328(ctx, base);
	// 828A06DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A06E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A06E4: 388B9390  addi r4, r11, -0x6c70
	ctx.r[4].s64 = ctx.r[11].s64 + -27760;
	// 828A06E8: 38A00095  li r5, 0x95
	ctx.r[5].s64 = 149;
	// 828A06EC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828A06F0: 4BA1FCE9  bl 0x822c03d8
	ctx.lr = 0x828A06F4;
	sub_822C03D8(ctx, base);
	// 828A06F4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A06F8: 41820030  beq 0x828a0728
	if ctx.cr[0].eq {
	pc = 0x828A0728; continue 'dispatch;
	}
	// 828A06FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0704: 388B9420  addi r4, r11, -0x6be0
	ctx.r[4].s64 = ctx.r[11].s64 + -27616;
	// 828A0708: 48553301  bl 0x82df3a08
	ctx.lr = 0x828A070C;
	sub_82DF3A08(ctx, base);
	// 828A070C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828A0710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0718: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828A071C: 4BD07D3D  bl 0x825a8458
	ctx.lr = 0x828A0720;
	sub_825A8458(ctx, base);
	// 828A0720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0724: 48000008  b 0x828a072c
	pc = 0x828A072C; continue 'dispatch;
	// 828A0728: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A072C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 828A0730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0734: 4BE859D5  bl 0x82726108
	ctx.lr = 0x828A0738;
	sub_82726108(ctx, base);
	// 828A0738: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A073C: 4182000C  beq 0x828a0748
	if ctx.cr[0].eq {
	pc = 0x828A0748; continue 'dispatch;
	}
	// 828A0740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0744: 48552CE5  bl 0x82df3428
	ctx.lr = 0x828A0748;
	sub_82DF3428(ctx, base);
	// 828A0748: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828A074C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A0750: 388B1BC4  addi r4, r11, 0x1bc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7108;
	// 828A0754: 485532B5  bl 0x82df3a08
	ctx.lr = 0x828A0758;
	sub_82DF3A08(ctx, base);
	// 828A0758: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A075C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0764: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A0768: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A076C: 419A0024  beq cr6, 0x828a0790
	if ctx.cr[6].eq {
	pc = 0x828A0790; continue 'dispatch;
	}
	// 828A0770: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A0774: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A0778: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A077C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A0780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A0784: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A0788: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A078C: 4082FFE8  bne 0x828a0774
	if !ctx.cr[0].eq {
	pc = 0x828A0774; continue 'dispatch;
	}
	// 828A0790: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A0794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0798: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A079C: 4BD01975  bl 0x825a2110
	ctx.lr = 0x828A07A0;
	sub_825A2110(ctx, base);
	// 828A07A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A07A4: 48552C85  bl 0x82df3428
	ctx.lr = 0x828A07A8;
	sub_82DF3428(ctx, base);
	// 828A07A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A07AC: 48907A0C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A07B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A07B0 size=332
    let mut pc: u32 = 0x828A07B0;
    'dispatch: loop {
        match pc {
            0x828A07B0 => {
    //   block [0x828A07B0..0x828A08FC)
	// 828A07B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A07B4: 489079B9  bl 0x831a816c
	ctx.lr = 0x828A07B8;
	sub_831A8130(ctx, base);
	// 828A07B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A07BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A07C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A07C4: 897F00E8  lbz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 828A07C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A07CC: 41820010  beq 0x828a07dc
	if ctx.cr[0].eq {
	pc = 0x828A07DC; continue 'dispatch;
	}
	// 828A07D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A07D4: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A07D8: 48000118  b 0x828a08f0
	pc = 0x828A08F0; continue 'dispatch;
	// 828A07DC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828A07E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A07E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A07E8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A07EC: 4BA7C9E5  bl 0x8231d1d0
	ctx.lr = 0x828A07F0;
	sub_8231D1D0(ctx, base);
	// 828A07F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A07F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A07F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A07FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A0800: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A0804: 419A0024  beq cr6, 0x828a0828
	if ctx.cr[6].eq {
	pc = 0x828A0828; continue 'dispatch;
	}
	// 828A0808: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A080C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A0810: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0814: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A0818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A081C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A0820: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0824: 4082FFE8  bne 0x828a080c
	if !ctx.cr[0].eq {
	pc = 0x828A080C; continue 'dispatch;
	}
	// 828A0828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A082C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A0830: 4BC6EC99  bl 0x8250f4c8
	ctx.lr = 0x828A0834;
	sub_8250F4C8(ctx, base);
	// 828A0834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A0838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A083C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828A0840: 409A0008  bne cr6, 0x828a0848
	if !ctx.cr[6].eq {
	pc = 0x828A0848; continue 'dispatch;
	}
	// 828A0844: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A0848: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A084C: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 828A0850: 4BC681C9  bl 0x82508a18
	ctx.lr = 0x828A0854;
	sub_82508A18(ctx, base);
	// 828A0854: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0858: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828A085C: 388B9390  addi r4, r11, -0x6c70
	ctx.r[4].s64 = ctx.r[11].s64 + -27760;
	// 828A0860: 38A000E8  li r5, 0xe8
	ctx.r[5].s64 = 232;
	// 828A0864: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828A0868: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828A086C: 485B677D  bl 0x82e56fe8
	ctx.lr = 0x828A0870;
	sub_82E56FE8(ctx, base);
	// 828A0870: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A0874: 4855141D  bl 0x82df1c90
	ctx.lr = 0x828A0878;
	sub_82DF1C90(ctx, base);
	// 828A0878: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A087C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0880: 419A0008  beq cr6, 0x828a0888
	if ctx.cr[6].eq {
	pc = 0x828A0888; continue 'dispatch;
	}
	// 828A0884: 4BA2000D  bl 0x822c0890
	ctx.lr = 0x828A0888;
	sub_822C0890(ctx, base);
	// 828A0888: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A088C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0890: 419A0008  beq cr6, 0x828a0898
	if ctx.cr[6].eq {
	pc = 0x828A0898; continue 'dispatch;
	}
	// 828A0894: 4BA1FFFD  bl 0x822c0890
	ctx.lr = 0x828A0898;
	sub_822C0890(ctx, base);
	// 828A0898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A089C: 4BC7124D  bl 0x82511ae8
	ctx.lr = 0x828A08A0;
	sub_82511AE8(ctx, base);
	// 828A08A0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828A08A4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0900 size=84
    let mut pc: u32 = 0x828A0900;
    'dispatch: loop {
        match pc {
            0x828A0900 => {
    //   block [0x828A0900..0x828A0954)
	// 828A0900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A090C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0914: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 828A0918: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A091C: 40990014  ble cr6, 0x828a0930
	if !ctx.cr[6].gt {
	pc = 0x828A0930; continue 'dispatch;
	}
	// 828A0920: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 828A0924: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828A0928: 4BFFFA69  bl 0x828a0390
	ctx.lr = 0x828A092C;
	sub_828A0390(ctx, base);
	// 828A092C: 48000014  b 0x828a0940
	pc = 0x828A0940; continue 'dispatch;
	// 828A0930: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828A0934: 4BC6F11D  bl 0x8250fa50
	ctx.lr = 0x828A0938;
	sub_8250FA50(ctx, base);
	// 828A0938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A093C: 4BC6FC95  bl 0x825105d0
	ctx.lr = 0x828A0940;
	sub_825105D0(ctx, base);
	// 828A0940: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A0944: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0948: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A094C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0958 size=152
    let mut pc: u32 = 0x828A0958;
    'dispatch: loop {
        match pc {
            0x828A0958 => {
    //   block [0x828A0958..0x828A09F0)
	// 828A0958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A095C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0960: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A0964: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A096C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0970: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0974: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A0978: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A097C: 396B949C  addi r11, r11, -0x6b64
	ctx.r[11].s64 = ctx.r[11].s64 + -27492;
	// 828A0980: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A0984: 394A9488  addi r10, r10, -0x6b78
	ctx.r[10].s64 = ctx.r[10].s64 + -27512;
	// 828A0988: 3929943C  addi r9, r9, -0x6bc4
	ctx.r[9].s64 = ctx.r[9].s64 + -27588;
	// 828A098C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A0990: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 828A0994: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828A0998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A099C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 828A09A0: 419A0010  beq cr6, 0x828a09b0
	if ctx.cr[6].eq {
	pc = 0x828A09B0; continue 'dispatch;
	}
	// 828A09A4: 4BA1F8C5  bl 0x822c0268
	ctx.lr = 0x828A09A8;
	sub_822C0268(ctx, base);
	// 828A09A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A09AC: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 828A09B0: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 828A09B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A09B8: 419A0008  beq cr6, 0x828a09c0
	if ctx.cr[6].eq {
	pc = 0x828A09C0; continue 'dispatch;
	}
	// 828A09BC: 4BA1FED5  bl 0x822c0890
	ctx.lr = 0x828A09C0;
	sub_822C0890(ctx, base);
	// 828A09C0: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 828A09C4: 4BBC963D  bl 0x8246a000
	ctx.lr = 0x828A09C8;
	sub_8246A000(ctx, base);
	// 828A09C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A09CC: 4BF06C8D  bl 0x827a7658
	ctx.lr = 0x828A09D0;
	sub_827A7658(ctx, base);
	// 828A09D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A09D4: 4BAAE97D  bl 0x8234f350
	ctx.lr = 0x828A09D8;
	sub_8234F350(ctx, base);
	// 828A09D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A09DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A09E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A09E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A09E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A09EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A09F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A09F0 size=8
    let mut pc: u32 = 0x828A09F0;
    'dispatch: loop {
        match pc {
            0x828A09F0 => {
    //   block [0x828A09F0..0x828A09F8)
	// 828A09F0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828A09F4: 4800000C  b 0x828a0a00
	sub_828A0A00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A09F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A09F8 size=8
    let mut pc: u32 = 0x828A09F8;
    'dispatch: loop {
        match pc {
            0x828A09F8 => {
    //   block [0x828A09F8..0x828A0A00)
	// 828A09F8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 828A09FC: 48000004  b 0x828a0a00
	sub_828A0A00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0A00 size=76
    let mut pc: u32 = 0x828A0A00;
    'dispatch: loop {
        match pc {
            0x828A0A00 => {
    //   block [0x828A0A00..0x828A0A4C)
	// 828A0A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A0A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0A18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A0A1C: 4BFFFF3D  bl 0x828a0958
	ctx.lr = 0x828A0A20;
	sub_828A0958(ctx, base);
	// 828A0A20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0A24: 4182000C  beq 0x828a0a30
	if ctx.cr[0].eq {
	pc = 0x828A0A30; continue 'dispatch;
	}
	// 828A0A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0A2C: 485519AD  bl 0x82df23d8
	ctx.lr = 0x828A0A30;
	sub_82DF23D8(ctx, base);
	// 828A0A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A0A38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0A3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0A40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A0A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0A50 size=96
    let mut pc: u32 = 0x828A0A50;
    'dispatch: loop {
        match pc {
            0x828A0A50 => {
    //   block [0x828A0A50..0x828A0AB0)
	// 828A0A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0A5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0A60: 81630114  lwz r11, 0x114(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 828A0A64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A0A68: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A0A6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0A70: 4182002C  beq 0x828a0a9c
	if ctx.cr[0].eq {
	pc = 0x828A0A9C; continue 'dispatch;
	}
	// 828A0A74: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 828A0A78: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A0A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0A80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A0A84: 4BC14755  bl 0x824b51d8
	ctx.lr = 0x828A0A88;
	sub_824B51D8(ctx, base);
	// 828A0A88: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 828A0A8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A0A90: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A0A94: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A0A98: 4BC14741  bl 0x824b51d8
	ctx.lr = 0x828A0A9C;
	sub_824B51D8(ctx, base);
	// 828A0A9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A0AA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0AA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0AA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0AB0 size=444
    let mut pc: u32 = 0x828A0AB0;
    'dispatch: loop {
        match pc {
            0x828A0AB0 => {
    //   block [0x828A0AB0..0x828A0C6C)
	// 828A0AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0AB4: 489076B5  bl 0x831a8168
	ctx.lr = 0x828A0AB8;
	sub_831A8130(ctx, base);
	// 828A0AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0ABC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828A0AC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A0AC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A0AC8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A0ACC: 41820038  beq 0x828a0b04
	if ctx.cr[0].eq {
	pc = 0x828A0B04; continue 'dispatch;
	}
	// 828A0AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0AD4: 48908EB5  bl 0x831a9988
	ctx.lr = 0x828A0AD8;
	sub_831A9988(ctx, base);
	// 828A0AD8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828A0ADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0AE0: 386B5C00  addi r3, r11, 0x5c00
	ctx.r[3].s64 = ctx.r[11].s64 + 23552;
	// 828A0AE4: 48907615  bl 0x831a80f8
	ctx.lr = 0x828A0AE8;
	sub_831A80F8(ctx, base);
	// 828A0AE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0AEC: 41820018  beq 0x828a0b04
	if ctx.cr[0].eq {
	pc = 0x828A0B04; continue 'dispatch;
	}
	// 828A0AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0AF4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0AF8: 4BD7AC01  bl 0x8261b6f8
	ctx.lr = 0x828A0AFC;
	sub_8261B6F8(ctx, base);
	// 828A0AFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828A0B00: 48000164  b 0x828a0c64
	pc = 0x828A0C64; continue 'dispatch;
	// 828A0B04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0B08: 409A0074  bne cr6, 0x828a0b7c
	if !ctx.cr[6].eq {
	pc = 0x828A0B7C; continue 'dispatch;
	}
	// 828A0B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0B10: 48908E79  bl 0x831a9988
	ctx.lr = 0x828A0B14;
	sub_831A9988(ctx, base);
	// 828A0B14: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A0B18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0B1C: 386BF158  addi r3, r11, -0xea8
	ctx.r[3].s64 = ctx.r[11].s64 + -3752;
	// 828A0B20: 489075D9  bl 0x831a80f8
	ctx.lr = 0x828A0B24;
	sub_831A80F8(ctx, base);
	// 828A0B24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0B28: 41820014  beq 0x828a0b3c
	if ctx.cr[0].eq {
	pc = 0x828A0B3C; continue 'dispatch;
	}
	// 828A0B2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0B30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0B34: 4BFFF59D  bl 0x828a00d0
	ctx.lr = 0x828A0B38;
	sub_828A00D0(ctx, base);
	// 828A0B38: 4BFFFFC4  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0B3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0B40: 409A003C  bne cr6, 0x828a0b7c
	if !ctx.cr[6].eq {
	pc = 0x828A0B7C; continue 'dispatch;
	}
	// 828A0B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0B48: 48908E41  bl 0x831a9988
	ctx.lr = 0x828A0B4C;
	sub_831A9988(ctx, base);
	// 828A0B4C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A0B50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0B54: 386BFE10  addi r3, r11, -0x1f0
	ctx.r[3].s64 = ctx.r[11].s64 + -496;
	// 828A0B58: 489075A1  bl 0x831a80f8
	ctx.lr = 0x828A0B5C;
	sub_831A80F8(ctx, base);
	// 828A0B5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0B60: 41820014  beq 0x828a0b74
	if ctx.cr[0].eq {
	pc = 0x828A0B74; continue 'dispatch;
	}
	// 828A0B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0B68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0B6C: 4BFFF575  bl 0x828a00e0
	ctx.lr = 0x828A0B70;
	sub_828A00E0(ctx, base);
	// 828A0B70: 4BFFFF8C  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0B74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0B78: 419A00AC  beq cr6, 0x828a0c24
	if ctx.cr[6].eq {
	pc = 0x828A0C24; continue 'dispatch;
	}
	// 828A0B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0B80: 48908E09  bl 0x831a9988
	ctx.lr = 0x828A0B84;
	sub_831A9988(ctx, base);
	// 828A0B84: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A0B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0B8C: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828A0B90: 48907569  bl 0x831a80f8
	ctx.lr = 0x828A0B94;
	sub_831A80F8(ctx, base);
	// 828A0B94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0B98: 41820014  beq 0x828a0bac
	if ctx.cr[0].eq {
	pc = 0x828A0BAC; continue 'dispatch;
	}
	// 828A0B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0BA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0BA4: 4BFFFEAD  bl 0x828a0a50
	ctx.lr = 0x828A0BA8;
	sub_828A0A50(ctx, base);
	// 828A0BA8: 4BFFFF54  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0BAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0BB0: 419A0074  beq cr6, 0x828a0c24
	if ctx.cr[6].eq {
	pc = 0x828A0C24; continue 'dispatch;
	}
	// 828A0BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0BB8: 48908DD1  bl 0x831a9988
	ctx.lr = 0x828A0BBC;
	sub_831A9988(ctx, base);
	// 828A0BBC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A0BC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0BC4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828A0BC8: 48907531  bl 0x831a80f8
	ctx.lr = 0x828A0BCC;
	sub_831A80F8(ctx, base);
	// 828A0BCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0BD0: 41820014  beq 0x828a0be4
	if ctx.cr[0].eq {
	pc = 0x828A0BE4; continue 'dispatch;
	}
	// 828A0BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0BD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0BDC: 4BFFF515  bl 0x828a00f0
	ctx.lr = 0x828A0BE0;
	sub_828A00F0(ctx, base);
	// 828A0BE0: 4BFFFF1C  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0BE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0BE8: 419A003C  beq cr6, 0x828a0c24
	if ctx.cr[6].eq {
	pc = 0x828A0C24; continue 'dispatch;
	}
	// 828A0BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0BF0: 48908D99  bl 0x831a9988
	ctx.lr = 0x828A0BF4;
	sub_831A9988(ctx, base);
	// 828A0BF4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A0BF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0BFC: 386BF184  addi r3, r11, -0xe7c
	ctx.r[3].s64 = ctx.r[11].s64 + -3708;
	// 828A0C00: 489074F9  bl 0x831a80f8
	ctx.lr = 0x828A0C04;
	sub_831A80F8(ctx, base);
	// 828A0C04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0C08: 41820014  beq 0x828a0c1c
	if ctx.cr[0].eq {
	pc = 0x828A0C1C; continue 'dispatch;
	}
	// 828A0C0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0C10: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0C14: 4BFFFB9D  bl 0x828a07b0
	ctx.lr = 0x828A0C18;
	sub_828A07B0(ctx, base);
	// 828A0C18: 4BFFFEE4  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0C1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0C20: 409A0034  bne cr6, 0x828a0c54
	if !ctx.cr[6].eq {
	pc = 0x828A0C54; continue 'dispatch;
	}
	// 828A0C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0C28: 48908D61  bl 0x831a9988
	ctx.lr = 0x828A0C2C;
	sub_831A9988(ctx, base);
	// 828A0C2C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A0C30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A0C34: 386BF1BC  addi r3, r11, -0xe44
	ctx.r[3].s64 = ctx.r[11].s64 + -3652;
	// 828A0C38: 489074C1  bl 0x831a80f8
	ctx.lr = 0x828A0C3C;
	sub_831A80F8(ctx, base);
	// 828A0C3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A0C40: 41820014  beq 0x828a0c54
	if ctx.cr[0].eq {
	pc = 0x828A0C54; continue 'dispatch;
	}
	// 828A0C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0C48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A0C4C: 4BFFFCB5  bl 0x828a0900
	ctx.lr = 0x828A0C50;
	sub_828A0900(ctx, base);
	// 828A0C50: 4BFFFEAC  b 0x828a0afc
	pc = 0x828A0AFC; continue 'dispatch;
	// 828A0C54: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A0C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0C5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0C60: 4BC719B9  bl 0x82512618
	ctx.lr = 0x828A0C64;
	sub_82512618(ctx, base);
	// 828A0C64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A0C68: 48907550  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0C70 size=208
    let mut pc: u32 = 0x828A0C70;
    'dispatch: loop {
        match pc {
            0x828A0C70 => {
    //   block [0x828A0C70..0x828A0D40)
	// 828A0C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A0C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0C80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0C84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0C88: 4BC716A9  bl 0x82512330
	ctx.lr = 0x828A0C8C;
	sub_82512330(ctx, base);
	// 828A0C8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A0C90: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A0C94: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828A0C98: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828A0C9C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A0CA0: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 828A0CA4: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 828A0CA8: 39699488  addi r11, r9, -0x6b78
	ctx.r[11].s64 = ctx.r[9].s64 + -27512;
	// 828A0CAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A0CB0: 394A949C  addi r10, r10, -0x6b64
	ctx.r[10].s64 = ctx.r[10].s64 + -27492;
	// 828A0CB4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828A0CB8: 3928943C  addi r9, r8, -0x6bc4
	ctx.r[9].s64 = ctx.r[8].s64 + -27588;
	// 828A0CBC: 9BDF00E8  stb r30, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u8 ) };
	// 828A0CC0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A0CC4: 397F00EC  addi r11, r31, 0xec
	ctx.r[11].s64 = ctx.r[31].s64 + 236;
	// 828A0CC8: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 828A0CCC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0CD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A0CD4: 388B9390  addi r4, r11, -0x6c70
	ctx.r[4].s64 = ctx.r[11].s64 + -27760;
	// 828A0CD8: 38A00046  li r5, 0x46
	ctx.r[5].s64 = 70;
	// 828A0CDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A0CE0: 8147853C  lwz r10, -0x7ac4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 828A0CE4: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 828A0CE8: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 828A0CEC: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 828A0CF0: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 828A0CF4: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 828A0CF8: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 828A0CFC: 8167853C  lwz r11, -0x7ac4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 828A0D00: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 828A0D04: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 828A0D08: 4BA1F6D1  bl 0x822c03d8
	ctx.lr = 0x828A0D0C;
	sub_822C03D8(ctx, base);
	// 828A0D0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0D10: 4182000C  beq 0x828a0d1c
	if ctx.cr[0].eq {
	pc = 0x828A0D1C; continue 'dispatch;
	}
	// 828A0D14: 48000235  bl 0x828a0f48
	ctx.lr = 0x828A0D18;
	sub_828A0F48(ctx, base);
	// 828A0D18: 48000008  b 0x828a0d20
	pc = 0x828A0D20; continue 'dispatch;
	// 828A0D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0D20: 907F0114  stw r3, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[3].u32 ) };
	// 828A0D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0D28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A0D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0D34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A0D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A0D40 size=440
    let mut pc: u32 = 0x828A0D40;
    'dispatch: loop {
        match pc {
            0x828A0D40 => {
    //   block [0x828A0D40..0x828A0EF8)
	// 828A0D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0D44: 48907425  bl 0x831a8168
	ctx.lr = 0x828A0D48;
	sub_831A8130(ctx, base);
	// 828A0D48: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0D4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0D50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A0D54: 3BCB9390  addi r30, r11, -0x6c70
	ctx.r[30].s64 = ctx.r[11].s64 + -27760;
	// 828A0D58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A0D5C: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 828A0D60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A0D64: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 828A0D68: 48551681  bl 0x82df23e8
	ctx.lr = 0x828A0D6C;
	sub_82DF23E8(ctx, base);
	// 828A0D6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0D70: 41820010  beq 0x828a0d80
	if ctx.cr[0].eq {
	pc = 0x828A0D80; continue 'dispatch;
	}
	// 828A0D74: 4BFFFEFD  bl 0x828a0c70
	ctx.lr = 0x828A0D78;
	sub_828A0C70(ctx, base);
	// 828A0D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0D7C: 48000008  b 0x828a0d84
	pc = 0x828A0D84; continue 'dispatch;
	// 828A0D80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A0D84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A0D88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0D8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A0D90: 4BFFF471  bl 0x828a0200
	ctx.lr = 0x828A0D94;
	sub_828A0200(ctx, base);
	// 828A0D94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A0D98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0D9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A0DA0: 4BA1F261  bl 0x822c0000
	ctx.lr = 0x828A0DA4;
	sub_822C0000(ctx, base);
	// 828A0DA4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A0DA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828A0DAC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 828A0DB0: 409A0008  bne cr6, 0x828a0db8
	if !ctx.cr[6].eq {
	pc = 0x828A0DB8; continue 'dispatch;
	}
	// 828A0DB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A0DB8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A0DBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A0DC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0DC4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A0DC8: 419A0024  beq cr6, 0x828a0dec
	if ctx.cr[6].eq {
	pc = 0x828A0DEC; continue 'dispatch;
	}
	// 828A0DCC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828A0DD0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828A0DD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0DD8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828A0DDC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828A0DE0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A0DE4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0DE8: 4082FFE8  bne 0x828a0dd0
	if !ctx.cr[0].eq {
	pc = 0x828A0DD0; continue 'dispatch;
	}
	// 828A0DEC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A0DF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0DF4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828A0DF8: 419A0024  beq cr6, 0x828a0e1c
	if ctx.cr[6].eq {
	pc = 0x828A0E1C; continue 'dispatch;
	}
	// 828A0DFC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828A0E00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A0E04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0E08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A0E0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A0E10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A0E14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A0E18: 4082FFE8  bne 0x828a0e00
	if !ctx.cr[0].eq {
	pc = 0x828A0E00; continue 'dispatch;
	}
	// 828A0E1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A0E20: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828A0E24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828A0E28: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 828A0E2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A0E30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A0E34: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A0E38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A0E3C: 4BEF80F5  bl 0x82798f30
	ctx.lr = 0x828A0E40;
	sub_82798F30(ctx, base);
	// 828A0E40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A0E44: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828A0E48: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A0E4C: C1610094  lfs f11, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828A0E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A0E54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A0E58: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 828A0E5C: C00B9D1C  lfs f0, -0x62e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A0E60: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A0E64: C1AA9688  lfs f13, -0x6978(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A0E68: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 828A0E6C: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 828A0E70: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828A0E74: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828A0E78: 4BA1F561  bl 0x822c03d8
	ctx.lr = 0x828A0E7C;
	sub_822C03D8(ctx, base);
	// 828A0E7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A0E80: 41820014  beq 0x828a0e94
	if ctx.cr[0].eq {
	pc = 0x828A0E94; continue 'dispatch;
	}
	// 828A0E84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A0E88: 4BEFA7E1  bl 0x8279b668
	ctx.lr = 0x828A0E8C;
	sub_8279B668(ctx, base);
	// 828A0E8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0E90: 48000008  b 0x828a0e98
	pc = 0x828A0E98; continue 'dispatch;
	// 828A0E94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A0E98: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A0E9C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828A0EA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0EA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0EA8: 4BCF6DA9  bl 0x82597c50
	ctx.lr = 0x828A0EAC;
	sub_82597C50(ctx, base);
	// 828A0EAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A0EB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A0EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A0EB8: 4BA1F149  bl 0x822c0000
	ctx.lr = 0x828A0EBC;
	sub_822C0000(ctx, base);
	// 828A0EBC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A0EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0EC4: 419A0008  beq cr6, 0x828a0ecc
	if ctx.cr[6].eq {
	pc = 0x828A0ECC; continue 'dispatch;
	}
	// 828A0EC8: 4BA1F9C9  bl 0x822c0890
	ctx.lr = 0x828A0ECC;
	sub_822C0890(ctx, base);
	// 828A0ECC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A0ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A0ED4: 419A0008  beq cr6, 0x828a0edc
	if ctx.cr[6].eq {
	pc = 0x828A0EDC; continue 'dispatch;
	}
	// 828A0ED8: 4BA1F9B9  bl 0x822c0890
	ctx.lr = 0x828A0EDC;
	sub_822C0890(ctx, base);
	// 828A0EDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A0EE0: 419A000C  beq cr6, 0x828a0eec
	if ctx.cr[6].eq {
	pc = 0x828A0EEC; continue 'dispatch;
	}
	// 828A0EE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A0EE8: 4BA1F9A9  bl 0x822c0890
	ctx.lr = 0x828A0EEC;
	sub_822C0890(ctx, base);
	// 828A0EEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A0EF0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A0EF4: 489072C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A0EF8 size=76
    let mut pc: u32 = 0x828A0EF8;
    'dispatch: loop {
        match pc {
            0x828A0EF8 => {
    //   block [0x828A0EF8..0x828A0F44)
	// 828A0EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A0F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A0F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A0F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0F10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A0F14: 485B876D  bl 0x82e59680
	ctx.lr = 0x828A0F18;
	sub_82E59680(ctx, base);
	// 828A0F18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A0F1C: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 828A0F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A0F24: 396B94DC  addi r11, r11, -0x6b24
	ctx.r[11].s64 = ctx.r[11].s64 + -27428;
	// 828A0F28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A0F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A0F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A0F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A0F38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A0F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A0F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A0F48 size=28
    let mut pc: u32 = 0x828A0F48;
    'dispatch: loop {
        match pc {
            0x828A0F48 => {
    //   block [0x828A0F48..0x828A0F64)
	// 828A0F48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A0F4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A0F50: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828A0F54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A0F58: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 828A0F5C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828A0F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A0F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A0F68 size=360
    let mut pc: u32 = 0x828A0F68;
    'dispatch: loop {
        match pc {
            0x828A0F68 => {
    //   block [0x828A0F68..0x828A10D0)
	// 828A0F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A0F6C: 48907201  bl 0x831a816c
	ctx.lr = 0x828A0F70;
	sub_831A8130(ctx, base);
	// 828A0F70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A0F74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A0F78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A0F7C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828A0F80: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 828A0F84: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 828A0F88: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828A0F8C: C00BDD6C  lfs f0, -0x2294(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A0F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A0F94: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A0F98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A0F9C: C189A1C4  lfs f12, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A0FA0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828A0FA4: C168D7BC  lfs f11, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828A0FA8: C1476218  lfs f10, 0x6218(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25112 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828A0FAC: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 828A0FB0: C12695F4  lfs f9, -0x6a0c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828A0FB4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828A0FB8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828A0FBC: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828A0FC0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828A0FC4: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828A0FC8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 828A0FCC: D17F0048  stfs f11, 0x48(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828A0FD0: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A0FD4: D15F0058  stfs f10, 0x58(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828A0FD8: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828A0FDC: D13F005C  stfs f9, 0x5c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828A0FE0: 9BBF0060  stb r29, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 828A0FE4: 9BDF0061  stb r30, 0x61(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 828A0FE8: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 828A0FEC: 480B8F25  bl 0x82959f10
	ctx.lr = 0x828A0FF0;
	sub_82959F10(ctx, base);
	// 828A0FF0: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 828A0FF4: 480BA405  bl 0x8295b3f8
	ctx.lr = 0x828A0FF8;
	sub_8295B3F8(ctx, base);
	// 828A0FF8: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 828A0FFC: 480B6BFD  bl 0x82957bf8
	ctx.lr = 0x828A1000;
	sub_82957BF8(ctx, base);
	// 828A1000: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 828A1004: 480B6BF5  bl 0x82957bf8
	ctx.lr = 0x828A1008;
	sub_82957BF8(ctx, base);
	// 828A1008: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 828A100C: 480B6BED  bl 0x82957bf8
	ctx.lr = 0x828A1010;
	sub_82957BF8(ctx, base);
	// 828A1010: 387F011C  addi r3, r31, 0x11c
	ctx.r[3].s64 = ctx.r[31].s64 + 284;
	// 828A1014: 480B6BE5  bl 0x82957bf8
	ctx.lr = 0x828A1018;
	sub_82957BF8(ctx, base);
	// 828A1018: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 828A101C: 480B56BD  bl 0x829566d8
	ctx.lr = 0x828A1020;
	sub_829566D8(ctx, base);
	// 828A1020: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 828A1024: 480B56B5  bl 0x829566d8
	ctx.lr = 0x828A1028;
	sub_829566D8(ctx, base);
	// 828A1028: 387F01B0  addi r3, r31, 0x1b0
	ctx.r[3].s64 = ctx.r[31].s64 + 432;
	// 828A102C: 480B56AD  bl 0x829566d8
	ctx.lr = 0x828A1030;
	sub_829566D8(ctx, base);
	// 828A1030: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 828A1034: 480B56A5  bl 0x829566d8
	ctx.lr = 0x828A1038;
	sub_829566D8(ctx, base);
	// 828A1038: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 828A103C: 39000096  li r8, 0x96
	ctx.r[8].s64 = 150;
	// 828A1040: 9BDF0238  stb r30, 0x238(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u8 ) };
	// 828A1044: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 828A1048: 9BBF00B0  stb r29, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[29].u8 ) };
	// 828A104C: 911F00EC  stw r8, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[8].u32 ) };
	// 828A1050: 3CC08209  lis r6, -0x7df7
	ctx.r[6].s64 = -2113339392;
	// 828A1054: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828A1058: 90FF00F0  stw r7, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[7].u32 ) };
	// 828A105C: C00969B8  lfs f0, 0x69b8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A1060: 39200046  li r9, 0x46
	ctx.r[9].s64 = 70;
	// 828A1064: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 828A1068: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828A106C: 913F010C  stw r9, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[9].u32 ) };
	// 828A1070: 39400032  li r10, 0x32
	ctx.r[10].s64 = 50;
	// 828A1074: 38A0008C  li r5, 0x8c
	ctx.r[5].s64 = 140;
	// 828A1078: 9BBF00C0  stb r29, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[29].u8 ) };
	// 828A107C: 38E68A1C  addi r7, r6, -0x75e4
	ctx.r[7].s64 = ctx.r[6].s64 + -30180;
	// 828A1080: 9BBF00D0  stb r29, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u8 ) };
	// 828A1084: 39289368  addi r9, r8, -0x6c98
	ctx.r[9].s64 = ctx.r[8].s64 + -27800;
	// 828A1088: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828A108C: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 828A1090: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 828A1094: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 828A1098: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 828A109C: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 828A10A0: 90BF0110  stw r5, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[5].u32 ) };
	// 828A10A4: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 828A10A8: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 828A10AC: 90FF00E0  stw r7, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[7].u32 ) };
	// 828A10B0: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 828A10B4: 915F011C  stw r10, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[10].u32 ) };
	// 828A10B8: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 828A10BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A10C0: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 828A10C4: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 828A10C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A10CC: 489070F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A10D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A10D0 size=24
    let mut pc: u32 = 0x828A10D0;
    'dispatch: loop {
        match pc {
            0x828A10D0 => {
    //   block [0x828A10D0..0x828A10E8)
	// 828A10D0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A10D4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828A10D8: 40980010  bge cr6, 0x828a10e8
	if !ctx.cr[6].lt {
		sub_828A10E8(ctx, base);
		return;
	}
	// 828A10DC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A10E0: 806BFE54  lwz r3, -0x1ac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-428 as u32) ) } as u64;
	// 828A10E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A10E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A10E8 size=28
    let mut pc: u32 = 0x828A10E8;
    'dispatch: loop {
        match pc {
            0x828A10E8 => {
    //   block [0x828A10E8..0x828A1104)
	// 828A10E8: EC010028  fsubs f0, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828A10EC: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A10F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828A10F4: 40980010  bge cr6, 0x828a1104
	if !ctx.cr[6].lt {
		sub_828A1104(ctx, base);
		return;
	}
	// 828A10F8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A10FC: 806BFE5C  lwz r3, -0x1a4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-420 as u32) ) } as u64;
	// 828A1100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1104(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A1104 size=28
    let mut pc: u32 = 0x828A1104;
    'dispatch: loop {
        match pc {
            0x828A1104 => {
    //   block [0x828A1104..0x828A1120)
	// 828A1104: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828A1108: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A110C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828A1110: 40980010  bge cr6, 0x828a1120
	if !ctx.cr[6].lt {
		sub_828A1120(ctx, base);
		return;
	}
	// 828A1114: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A1118: 806BFE58  lwz r3, -0x1a8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-424 as u32) ) } as u64;
	// 828A111C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A1120 size=44
    let mut pc: u32 = 0x828A1120;
    'dispatch: loop {
        match pc {
            0x828A1120 => {
    //   block [0x828A1120..0x828A114C)
	// 828A1120: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828A1124: C1A40014  lfs f13, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A1128: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828A112C: 4198003C  blt cr6, 0x828a1168
	if ctx.cr[6].lt {
		sub_828A1168(ctx, base);
		return;
	}
	// 828A1130: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828A1134: C1A40010  lfs f13, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A1138: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828A113C: 40980010  bge cr6, 0x828a114c
	if !ctx.cr[6].lt {
		sub_828A114C(ctx, base);
		return;
	}
	// 828A1140: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A1144: 806BFE50  lwz r3, -0x1b0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-432 as u32) ) } as u64;
	// 828A1148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A114C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A114C size=28
    let mut pc: u32 = 0x828A114C;
    'dispatch: loop {
        match pc {
            0x828A114C => {
    //   block [0x828A114C..0x828A1168)
	// 828A114C: EC006828  fsubs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828A1150: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A1154: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828A1158: 40980010  bge cr6, 0x828a1168
	if !ctx.cr[6].lt {
		sub_828A1168(ctx, base);
		return;
	}
	// 828A115C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A1160: 806BFE60  lwz r3, -0x1a0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-416 as u32) ) } as u64;
	// 828A1164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A1168 size=12
    let mut pc: u32 = 0x828A1168;
    'dispatch: loop {
        match pc {
            0x828A1168 => {
    //   block [0x828A1168..0x828A1174)
	// 828A1168: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A116C: 806BFE4C  lwz r3, -0x1b4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-436 as u32) ) } as u64;
	// 828A1170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A1178 size=144
    let mut pc: u32 = 0x828A1178;
    'dispatch: loop {
        match pc {
            0x828A1178 => {
    //   block [0x828A1178..0x828A1208)
	// 828A1178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A117C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A1180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A1184: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828A1188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A118C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A1190: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A1194: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A1198: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 828A119C: C1AB9F7C  lfs f13, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A11A0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 828A11A4: 4198004C  blt cr6, 0x828a11f0
	if ctx.cr[6].lt {
	pc = 0x828A11F0; continue 'dispatch;
	}
	// 828A11A8: EDA00824  fdivs f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 828A11AC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A11B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A11B4: C00B6218  lfs f0, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A11B8: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828A11BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A11C0: 4890AE81  bl 0x831ac040
	ctx.lr = 0x828A11C4;
	sub_831AC040(ctx, base);
	// 828A11C4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828A11C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A11CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A11D0: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A11D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828A11D8: 4199000C  bgt cr6, 0x828a11e4
	if ctx.cr[6].gt {
	pc = 0x828A11E4; continue 'dispatch;
	}
	// 828A11DC: 4890AB2D  bl 0x831abd08
	ctx.lr = 0x828A11E0;
	sub_831ABD08(ctx, base);
	// 828A11E0: 48000008  b 0x828a11e8
	pc = 0x828A11E8; continue 'dispatch;
	// 828A11E4: 4890A8B5  bl 0x831aba98
	ctx.lr = 0x828A11E8;
	sub_831ABA98(ctx, base);
	// 828A11E8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828A11EC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828A11F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A11F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A11F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A11FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A1200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A1204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A1208 size=20
    let mut pc: u32 = 0x828A1208;
    'dispatch: loop {
        match pc {
            0x828A1208 => {
    //   block [0x828A1208..0x828A121C)
	// 828A1208: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A120C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A1210: 409A000C  bne cr6, 0x828a121c
	if !ctx.cr[6].eq {
		sub_828A121C(ctx, base);
		return;
	}
	// 828A1214: 38830014  addi r4, r3, 0x14
	ctx.r[4].s64 = ctx.r[3].s64 + 20;
	// 828A1218: 4BFFFEB8  b 0x828a10d0
	sub_828A10D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A121C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A121C size=8
    let mut pc: u32 = 0x828A121C;
    'dispatch: loop {
        match pc {
            0x828A121C => {
    //   block [0x828A121C..0x828A1224)
	// 828A121C: 3883002C  addi r4, r3, 0x2c
	ctx.r[4].s64 = ctx.r[3].s64 + 44;
	// 828A1220: 4BFFFEB0  b 0x828a10d0
	sub_828A10D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A1228 size=96
    let mut pc: u32 = 0x828A1228;
    'dispatch: loop {
        match pc {
            0x828A1228 => {
    //   block [0x828A1228..0x828A1288)
	// 828A1228: C1A40010  lfs f13, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A122C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 828A1230: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A1234: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828A1238: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A123C: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828A1240: C1440004  lfs f10, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828A1244: C1240000  lfs f9, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828A1248: C1ABDFB0  lfs f13, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A124C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A1250: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 828A1254: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 828A1258: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 828A125C: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 828A1260: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 828A1264: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 828A1268: 41980008  blt cr6, 0x828a1270
	if ctx.cr[6].lt {
	pc = 0x828A1270; continue 'dispatch;
	}
	// 828A126C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A1270: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A1274: 4182000C  beq 0x828a1280
	if ctx.cr[0].eq {
	pc = 0x828A1280; continue 'dispatch;
	}
	// 828A1278: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A127C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A1280: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 828A1284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A1288 size=156
    let mut pc: u32 = 0x828A1288;
    'dispatch: loop {
        match pc {
            0x828A1288 => {
    //   block [0x828A1288..0x828A1324)
	// 828A1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A128C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A1290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A1294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A1298: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828A129C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A12A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A12A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A12A8: 4BFFFF81  bl 0x828a1228
	ctx.lr = 0x828A12AC;
	sub_828A1228(ctx, base);
	// 828A12AC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 828A12B0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828A12B4: 4BFFFEC5  bl 0x828a1178
	ctx.lr = 0x828A12B8;
	sub_828A1178(ctx, base);
	// 828A12B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A12BC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828A12C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A12C4: 4BFFFEB5  bl 0x828a1178
	ctx.lr = 0x828A12C8;
	sub_828A1178(ctx, base);
	// 828A12C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A12CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A12D0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A12D4: 4BFFFEA5  bl 0x828a1178
	ctx.lr = 0x828A12D8;
	sub_828A1178(ctx, base);
	// 828A12D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A12DC: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828A12E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A12E4: 4BFFFE95  bl 0x828a1178
	ctx.lr = 0x828A12E8;
	sub_828A1178(ctx, base);
	// 828A12E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A12EC: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 828A12F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A12F4: 4BFFFE85  bl 0x828a1178
	ctx.lr = 0x828A12F8;
	sub_828A1178(ctx, base);
	// 828A12F8: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 828A12FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1300: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A1304: 4BFFFE75  bl 0x828a1178
	ctx.lr = 0x828A1308;
	sub_828A1178(ctx, base);
	// 828A1308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A130C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A1310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A1314: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828A1318: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A131C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A1320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A1328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A1328 size=372
    let mut pc: u32 = 0x828A1328;
    'dispatch: loop {
        match pc {
            0x828A1328 => {
    //   block [0x828A1328..0x828A149C)
	// 828A1328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A132C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A1330: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A1334: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A1338: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A133C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A1340: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A1344: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A1348: 419A013C  beq cr6, 0x828a1484
	if ctx.cr[6].eq {
	pc = 0x828A1484; continue 'dispatch;
	}
	// 828A134C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A1350: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A1354: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828A1358: 485526B1  bl 0x82df3a08
	ctx.lr = 0x828A135C;
	sub_82DF3A08(ctx, base);
	// 828A135C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828A1360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1364: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828A1368: 485526A1  bl 0x82df3a08
	ctx.lr = 0x828A136C;
	sub_82DF3A08(ctx, base);
	// 828A136C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828A1370: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 828A1374: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1378: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A137C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A1380: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A1384: 4BD02095  bl 0x825a3418
	ctx.lr = 0x828A1388;
	sub_825A3418(ctx, base);
	// 828A1388: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A138C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A1390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A1394: 4BD00B45  bl 0x825a1ed8
	ctx.lr = 0x828A1398;
	sub_825A1ED8(ctx, base);
	// 828A1398: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828A139C: 4855208D  bl 0x82df3428
	ctx.lr = 0x828A13A0;
	sub_82DF3428(ctx, base);
	// 828A13A0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828A13A4: 4BA27915  bl 0x822c8cb8
	ctx.lr = 0x828A13A8;
	sub_822C8CB8(ctx, base);
	// 828A13A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A13AC: 4855207D  bl 0x82df3428
	ctx.lr = 0x828A13B0;
	sub_82DF3428(ctx, base);
	// 828A13B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A13B4: 48552075  bl 0x82df3428
	ctx.lr = 0x828A13B8;
	sub_82DF3428(ctx, base);
	// 828A13B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A13BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A13C0: 388B950C  addi r4, r11, -0x6af4
	ctx.r[4].s64 = ctx.r[11].s64 + -27380;
	// 828A13C4: 48552645  bl 0x82df3a08
	ctx.lr = 0x828A13C8;
	sub_82DF3A08(ctx, base);
	// 828A13C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A13CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A13D0: 388B9500  addi r4, r11, -0x6b00
	ctx.r[4].s64 = ctx.r[11].s64 + -27392;
	// 828A13D4: 48552635  bl 0x82df3a08
	ctx.lr = 0x828A13D8;
	sub_82DF3A08(ctx, base);
	// 828A13D8: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828A13DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A13E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A13E4: 4BD01C6D  bl 0x825a3050
	ctx.lr = 0x828A13E8;
	sub_825A3050(ctx, base);
	// 828A13E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A13EC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A13F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A13F4: 4BD00D95  bl 0x825a2188
	ctx.lr = 0x828A13F8;
	sub_825A2188(ctx, base);
	// 828A13F8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A13FC: 4855202D  bl 0x82df3428
	ctx.lr = 0x828A1400;
	sub_82DF3428(ctx, base);
	// 828A1400: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1404: 4BA278B5  bl 0x822c8cb8
	ctx.lr = 0x828A1408;
	sub_822C8CB8(ctx, base);
	// 828A1408: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A140C: 4855201D  bl 0x82df3428
	ctx.lr = 0x828A1410;
	sub_82DF3428(ctx, base);
	// 828A1410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1414: 48552015  bl 0x82df3428
	ctx.lr = 0x828A1418;
	sub_82DF3428(ctx, base);
	// 828A1418: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A141C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1420: 388B94EC  addi r4, r11, -0x6b14
	ctx.r[4].s64 = ctx.r[11].s64 + -27412;
	// 828A1424: 485525E5  bl 0x82df3a08
	ctx.lr = 0x828A1428;
	sub_82DF3A08(ctx, base);
	// 828A1428: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A142C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A1430: 388B94E0  addi r4, r11, -0x6b20
	ctx.r[4].s64 = ctx.r[11].s64 + -27424;
	// 828A1434: 485525D5  bl 0x82df3a08
	ctx.lr = 0x828A1438;
	sub_82DF3A08(ctx, base);
	// 828A1438: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828A143C: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 828A1440: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1444: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 828A1448: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A144C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828A1450: 4BD01FC9  bl 0x825a3418
	ctx.lr = 0x828A1454;
	sub_825A3418(ctx, base);
	// 828A1454: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1458: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A145C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A1460: 4BD00801  bl 0x825a1c60
	ctx.lr = 0x828A1464;
	sub_825A1C60(ctx, base);
	// 828A1464: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828A1468: 48551FC1  bl 0x82df3428
	ctx.lr = 0x828A146C;
	sub_82DF3428(ctx, base);
	// 828A146C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828A1470: 4BA27849  bl 0x822c8cb8
	ctx.lr = 0x828A1474;
	sub_822C8CB8(ctx, base);
	// 828A1474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A1478: 48551FB1  bl 0x82df3428
	ctx.lr = 0x828A147C;
	sub_82DF3428(ctx, base);
	// 828A147C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1480: 48551FA9  bl 0x82df3428
	ctx.lr = 0x828A1484;
	sub_82DF3428(ctx, base);
	// 828A1484: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828A1488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A148C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A1490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A1494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A1498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A14A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A14A0 size=3624
    let mut pc: u32 = 0x828A14A0;
    'dispatch: loop {
        match pc {
            0x828A14A0 => {
    //   block [0x828A14A0..0x828A22C8)
	// 828A14A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A14A4: 48906CB9  bl 0x831a815c
	ctx.lr = 0x828A14A8;
	sub_831A8130(ctx, base);
	// 828A14A8: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 828A14AC: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828A14B0: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828A14B4: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A14B8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828A14BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A14C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A14C4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A14C8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A14CC: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828A14D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A14D4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A14D8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A14DC: 419A0024  beq cr6, 0x828a1500
	if ctx.cr[6].eq {
	pc = 0x828A1500; continue 'dispatch;
	}
	// 828A14E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A14E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A14E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A14EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A14F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A14F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A14F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A14FC: 4082FFE8  bne 0x828a14e4
	if !ctx.cr[0].eq {
	pc = 0x828A14E4; continue 'dispatch;
	}
	// 828A1500: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1504: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 828A1508: 480B9611  bl 0x8295ab18
	ctx.lr = 0x828A150C;
	sub_8295AB18(ctx, base);
	// 828A150C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1510: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1514: 388B9810  addi r4, r11, -0x67f0
	ctx.r[4].s64 = ctx.r[11].s64 + -26608;
	// 828A1518: 485524F1  bl 0x82df3a08
	ctx.lr = 0x828A151C;
	sub_82DF3A08(ctx, base);
	// 828A151C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1520: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1524: 388B8A74  addi r4, r11, -0x758c
	ctx.r[4].s64 = ctx.r[11].s64 + -30092;
	// 828A1528: 485524E1  bl 0x82df3a08
	ctx.lr = 0x828A152C;
	sub_82DF3A08(ctx, base);
	// 828A152C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A1530: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A1534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A1538: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A153C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A1540: 419A0024  beq cr6, 0x828a1564
	if ctx.cr[6].eq {
	pc = 0x828A1564; continue 'dispatch;
	}
	// 828A1544: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A1548: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A154C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1550: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A1554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A1558: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A155C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1560: 4082FFE8  bne 0x828a1548
	if !ctx.cr[0].eq {
	pc = 0x828A1548; continue 'dispatch;
	}
	// 828A1564: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A1568: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828A156C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1570: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 828A1574: 480B669D  bl 0x82957c10
	ctx.lr = 0x828A1578;
	sub_82957C10(ctx, base);
	// 828A1578: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A157C: 48551EAD  bl 0x82df3428
	ctx.lr = 0x828A1580;
	sub_82DF3428(ctx, base);
	// 828A1580: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1584: 48551EA5  bl 0x82df3428
	ctx.lr = 0x828A1588;
	sub_82DF3428(ctx, base);
	// 828A1588: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A158C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1590: 388B9800  addi r4, r11, -0x6800
	ctx.r[4].s64 = ctx.r[11].s64 + -26624;
	// 828A1594: 48552475  bl 0x82df3a08
	ctx.lr = 0x828A1598;
	sub_82DF3A08(ctx, base);
	// 828A1598: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A159C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A15A0: 388B8A58  addi r4, r11, -0x75a8
	ctx.r[4].s64 = ctx.r[11].s64 + -30120;
	// 828A15A4: 48552465  bl 0x82df3a08
	ctx.lr = 0x828A15A8;
	sub_82DF3A08(ctx, base);
	// 828A15A8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A15AC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A15B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A15B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A15B8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A15BC: 419A0024  beq cr6, 0x828a15e0
	if ctx.cr[6].eq {
	pc = 0x828A15E0; continue 'dispatch;
	}
	// 828A15C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A15C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A15C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A15CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A15D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A15D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A15D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A15DC: 4082FFE8  bne 0x828a15c4
	if !ctx.cr[0].eq {
	pc = 0x828A15C4; continue 'dispatch;
	}
	// 828A15E0: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 828A15E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A15E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A15EC: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 828A15F0: 480B6621  bl 0x82957c10
	ctx.lr = 0x828A15F4;
	sub_82957C10(ctx, base);
	// 828A15F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A15F8: 48551E31  bl 0x82df3428
	ctx.lr = 0x828A15FC;
	sub_82DF3428(ctx, base);
	// 828A15FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1600: 48551E29  bl 0x82df3428
	ctx.lr = 0x828A1604;
	sub_82DF3428(ctx, base);
	// 828A1604: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1608: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A160C: 388B97F0  addi r4, r11, -0x6810
	ctx.r[4].s64 = ctx.r[11].s64 + -26640;
	// 828A1610: 485523F9  bl 0x82df3a08
	ctx.lr = 0x828A1614;
	sub_82DF3A08(ctx, base);
	// 828A1614: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1618: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A161C: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 828A1620: 485523E9  bl 0x82df3a08
	ctx.lr = 0x828A1624;
	sub_82DF3A08(ctx, base);
	// 828A1624: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A1628: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A162C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A1630: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A1634: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A1638: 419A0024  beq cr6, 0x828a165c
	if ctx.cr[6].eq {
	pc = 0x828A165C; continue 'dispatch;
	}
	// 828A163C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A1640: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A1644: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1648: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A164C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A1650: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A1654: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1658: 4082FFE8  bne 0x828a1640
	if !ctx.cr[0].eq {
	pc = 0x828A1640; continue 'dispatch;
	}
	// 828A165C: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 828A1660: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A1664: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1668: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 828A166C: 480B65A5  bl 0x82957c10
	ctx.lr = 0x828A1670;
	sub_82957C10(ctx, base);
	// 828A1670: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1674: 48551DB5  bl 0x82df3428
	ctx.lr = 0x828A1678;
	sub_82DF3428(ctx, base);
	// 828A1678: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A167C: 48551DAD  bl 0x82df3428
	ctx.lr = 0x828A1680;
	sub_82DF3428(ctx, base);
	// 828A1680: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1684: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1688: 388B97E0  addi r4, r11, -0x6820
	ctx.r[4].s64 = ctx.r[11].s64 + -26656;
	// 828A168C: 4855237D  bl 0x82df3a08
	ctx.lr = 0x828A1690;
	sub_82DF3A08(ctx, base);
	// 828A1690: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1698: 388B8A28  addi r4, r11, -0x75d8
	ctx.r[4].s64 = ctx.r[11].s64 + -30168;
	// 828A169C: 4855236D  bl 0x82df3a08
	ctx.lr = 0x828A16A0;
	sub_82DF3A08(ctx, base);
	// 828A16A0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A16A4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A16A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A16AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A16B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828A16B4: 419A0024  beq cr6, 0x828a16d8
	if ctx.cr[6].eq {
	pc = 0x828A16D8; continue 'dispatch;
	}
	// 828A16B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A16BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A16C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A16C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A16C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A16CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A16D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A16D4: 4082FFE8  bne 0x828a16bc
	if !ctx.cr[0].eq {
	pc = 0x828A16BC; continue 'dispatch;
	}
	// 828A16D8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 828A16DC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A16E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A16E4: 387F011C  addi r3, r31, 0x11c
	ctx.r[3].s64 = ctx.r[31].s64 + 284;
	// 828A16E8: 480B6529  bl 0x82957c10
	ctx.lr = 0x828A16EC;
	sub_82957C10(ctx, base);
	// 828A16EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A16F0: 48551D39  bl 0x82df3428
	ctx.lr = 0x828A16F4;
	sub_82DF3428(ctx, base);
	// 828A16F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A16F8: 48551D31  bl 0x82df3428
	ctx.lr = 0x828A16FC;
	sub_82DF3428(ctx, base);
	// 828A16FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1700: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1704: 388B97C8  addi r4, r11, -0x6838
	ctx.r[4].s64 = ctx.r[11].s64 + -26680;
	// 828A1708: 48552301  bl 0x82df3a08
	ctx.lr = 0x828A170C;
	sub_82DF3A08(ctx, base);
	// 828A170C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A1710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1714: 388B6DD8  addi r4, r11, 0x6dd8
	ctx.r[4].s64 = ctx.r[11].s64 + 28120;
	// 828A1718: 485522F1  bl 0x82df3a08
	ctx.lr = 0x828A171C;
	sub_82DF3A08(ctx, base);
	// 828A171C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 828A1720: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A1724: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A1728: 4BD28DD9  bl 0x825ca500
	ctx.lr = 0x828A172C;
	sub_825CA500(ctx, base);
	// 828A172C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828A1730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1734: 48551CF5  bl 0x82df3428
	ctx.lr = 0x828A1738;
	sub_82DF3428(ctx, base);
	// 828A1738: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A173C: 48551CED  bl 0x82df3428
	ctx.lr = 0x828A1740;
	sub_82DF3428(ctx, base);
	// 828A1740: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1744: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1748: 3B2B9758  addi r25, r11, -0x68a8
	ctx.r[25].s64 = ctx.r[11].s64 + -26792;
	// 828A174C: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 828A1750: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A1754: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A1758: 4BA1EC81  bl 0x822c03d8
	ctx.lr = 0x828A175C;
	sub_822C03D8(ctx, base);
	// 828A175C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A1760: 41820034  beq 0x828a1794
	if ctx.cr[0].eq {
	pc = 0x828A1794; continue 'dispatch;
	}
	// 828A1764: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A176C: 388B974C  addi r4, r11, -0x68b4
	ctx.r[4].s64 = ctx.r[11].s64 + -26804;
	// 828A1770: 48552299  bl 0x82df3a08
	ctx.lr = 0x828A1774;
	sub_82DF3A08(ctx, base);
	// 828A1774: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1778: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 828A177C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A1780: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1784: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828A1788: 4BD0AC89  bl 0x825ac410
	ctx.lr = 0x828A178C;
	sub_825AC410(ctx, base);
	// 828A178C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A1790: 48000008  b 0x828a1798
	pc = 0x828A1798; continue 'dispatch;
	// 828A1794: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A1798: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828A179C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A17A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828A17A4: 4BC51C15  bl 0x824f33b8
	ctx.lr = 0x828A17A8;
	sub_824F33B8(ctx, base);
	// 828A17A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A17AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A17B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828A17B4: 4BA1E84D  bl 0x822c0000
	ctx.lr = 0x828A17B8;
	sub_822C0000(ctx, base);
	// 828A17B8: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A17BC: 41820010  beq 0x828a17cc
	if ctx.cr[0].eq {
	pc = 0x828A17CC; continue 'dispatch;
	}
	// 828A17C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A17C4: 579C003C  rlwinm r28, r28, 0, 0, 0x1e
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 828A17C8: 48551C61  bl 0x82df3428
	ctx.lr = 0x828A17CC;
	sub_82DF3428(ctx, base);
	// 828A17CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A17D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A17D4: 388B9744  addi r4, r11, -0x68bc
	ctx.r[4].s64 = ctx.r[11].s64 + -26812;
	// 828A17D8: 48552231  bl 0x82df3a08
	ctx.lr = 0x828A17DC;
	sub_82DF3A08(ctx, base);
	// 828A17DC: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A17E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A17E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A17E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A17EC: 4BD0A5D5  bl 0x825abdc0
	ctx.lr = 0x828A17F0;
	sub_825ABDC0(ctx, base);
	// 828A17F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A17F4: 48551C35  bl 0x82df3428
	ctx.lr = 0x828A17F8;
	sub_82DF3428(ctx, base);
	// 828A17F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A17FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1800: 388B973C  addi r4, r11, -0x68c4
	ctx.r[4].s64 = ctx.r[11].s64 + -26820;
	// 828A1804: 48552205  bl 0x82df3a08
	ctx.lr = 0x828A1808;
	sub_82DF3A08(ctx, base);
	// 828A1808: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A180C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A1810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1814: 4BD0A5AD  bl 0x825abdc0
	ctx.lr = 0x828A1818;
	sub_825ABDC0(ctx, base);
	// 828A1818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A181C: 48551C0D  bl 0x82df3428
	ctx.lr = 0x828A1820;
	sub_82DF3428(ctx, base);
	// 828A1820: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1828: 388B9730  addi r4, r11, -0x68d0
	ctx.r[4].s64 = ctx.r[11].s64 + -26832;
	// 828A182C: 485521DD  bl 0x82df3a08
	ctx.lr = 0x828A1830;
	sub_82DF3A08(ctx, base);
	// 828A1830: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A1834: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828A1838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A183C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A1840: 419A0024  beq cr6, 0x828a1864
	if ctx.cr[6].eq {
	pc = 0x828A1864; continue 'dispatch;
	}
	// 828A1844: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A1848: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A184C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1850: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A1854: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A1858: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A185C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1860: 4082FFE8  bne 0x828a1848
	if !ctx.cr[0].eq {
	pc = 0x828A1848; continue 'dispatch;
	}
	// 828A1864: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828A1868: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A186C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A1870: 4BD008A1  bl 0x825a2110
	ctx.lr = 0x828A1874;
	sub_825A2110(ctx, base);
	// 828A1874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1878: 48551BB1  bl 0x82df3428
	ctx.lr = 0x828A187C;
	sub_82DF3428(ctx, base);
	// 828A187C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A1880: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1884: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 828A1888: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A188C: 4BA1EB4D  bl 0x822c03d8
	ctx.lr = 0x828A1890;
	sub_822C03D8(ctx, base);
	// 828A1890: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A1894: 41820034  beq 0x828a18c8
	if ctx.cr[0].eq {
	pc = 0x828A18C8; continue 'dispatch;
	}
	// 828A1898: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A189C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A18A0: 388B9724  addi r4, r11, -0x68dc
	ctx.r[4].s64 = ctx.r[11].s64 + -26844;
	// 828A18A4: 48552165  bl 0x82df3a08
	ctx.lr = 0x828A18A8;
	sub_82DF3A08(ctx, base);
	// 828A18A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A18AC: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828A18B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A18B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A18B8: 639C0002  ori r28, r28, 2
	ctx.r[28].u64 = ctx.r[28].u64 | 2;
	// 828A18BC: 4BD0AB55  bl 0x825ac410
	ctx.lr = 0x828A18C0;
	sub_825AC410(ctx, base);
	// 828A18C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A18C4: 48000008  b 0x828a18cc
	pc = 0x828A18CC; continue 'dispatch;
	// 828A18C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A18CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A18D0: 4BD10B29  bl 0x825b23f8
	ctx.lr = 0x828A18D4;
	sub_825B23F8(ctx, base);
	// 828A18D4: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A18D8: 41820010  beq 0x828a18e8
	if ctx.cr[0].eq {
	pc = 0x828A18E8; continue 'dispatch;
	}
	// 828A18DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A18E0: 579C07FA  rlwinm r28, r28, 0, 0x1f, 0x1d
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 828A18E4: 48551B45  bl 0x82df3428
	ctx.lr = 0x828A18E8;
	sub_82DF3428(ctx, base);
	// 828A18E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A18EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A18F0: 388B971C  addi r4, r11, -0x68e4
	ctx.r[4].s64 = ctx.r[11].s64 + -26852;
	// 828A18F4: 48552115  bl 0x82df3a08
	ctx.lr = 0x828A18F8;
	sub_82DF3A08(ctx, base);
	// 828A18F8: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A18FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A1900: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A1904: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1908: 4BD0A4B9  bl 0x825abdc0
	ctx.lr = 0x828A190C;
	sub_825ABDC0(ctx, base);
	// 828A190C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1910: 48551B19  bl 0x82df3428
	ctx.lr = 0x828A1914;
	sub_82DF3428(ctx, base);
	// 828A1914: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A191C: 388B9714  addi r4, r11, -0x68ec
	ctx.r[4].s64 = ctx.r[11].s64 + -26860;
	// 828A1920: 485520E9  bl 0x82df3a08
	ctx.lr = 0x828A1924;
	sub_82DF3A08(ctx, base);
	// 828A1924: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A1928: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A192C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1930: 4BD0A491  bl 0x825abdc0
	ctx.lr = 0x828A1934;
	sub_825ABDC0(ctx, base);
	// 828A1934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1938: 48551AF1  bl 0x82df3428
	ctx.lr = 0x828A193C;
	sub_82DF3428(ctx, base);
	// 828A193C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1944: 388B970C  addi r4, r11, -0x68f4
	ctx.r[4].s64 = ctx.r[11].s64 + -26868;
	// 828A1948: 485520C1  bl 0x82df3a08
	ctx.lr = 0x828A194C;
	sub_82DF3A08(ctx, base);
	// 828A194C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A1950: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828A1954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1958: 4BD0A469  bl 0x825abdc0
	ctx.lr = 0x828A195C;
	sub_825ABDC0(ctx, base);
	// 828A195C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1960: 48551AC9  bl 0x82df3428
	ctx.lr = 0x828A1964;
	sub_82DF3428(ctx, base);
	// 828A1964: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828A1968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A196C: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828A1970: 48552099  bl 0x82df3a08
	ctx.lr = 0x828A1974;
	sub_82DF3A08(ctx, base);
	// 828A1974: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A1978: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828A197C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828A1980: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828A1984: 419A0024  beq cr6, 0x828a19a8
	if ctx.cr[6].eq {
	pc = 0x828A19A8; continue 'dispatch;
	}
	// 828A1988: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828A198C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A1990: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1994: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A1998: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A199C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A19A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A19A4: 4082FFE8  bne 0x828a198c
	if !ctx.cr[0].eq {
	pc = 0x828A198C; continue 'dispatch;
	}
	// 828A19A8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828A19AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A19B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828A19B4: 4BD0075D  bl 0x825a2110
	ctx.lr = 0x828A19B8;
	sub_825A2110(ctx, base);
	// 828A19B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A19BC: 48551A6D  bl 0x82df3428
	ctx.lr = 0x828A19C0;
	sub_82DF3428(ctx, base);
	// 828A19C0: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A19C4: 4BD2830D  bl 0x825c9cd0
	ctx.lr = 0x828A19C8;
	sub_825C9CD0(ctx, base);
	// 828A19C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828A19CC: 419A000C  beq cr6, 0x828a19d8
	if ctx.cr[6].eq {
	pc = 0x828A19D8; continue 'dispatch;
	}
	// 828A19D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A19D4: 4BA1EEBD  bl 0x822c0890
	ctx.lr = 0x828A19D8;
	sub_822C0890(ctx, base);
	// 828A19D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A19DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A19E0: 388B9700  addi r4, r11, -0x6900
	ctx.r[4].s64 = ctx.r[11].s64 + -26880;
	// 828A19E4: 48552025  bl 0x82df3a08
	ctx.lr = 0x828A19E8;
	sub_82DF3A08(ctx, base);
	// 828A19E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A19EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A19F0: 388B184C  addi r4, r11, 0x184c
	ctx.r[4].s64 = ctx.r[11].s64 + 6220;
	// 828A19F4: 48552015  bl 0x82df3a08
	ctx.lr = 0x828A19F8;
	sub_82DF3A08(ctx, base);
	// 828A19F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A19FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A1A00: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A1A04: 4BD28AFD  bl 0x825ca500
	ctx.lr = 0x828A1A08;
	sub_825CA500(ctx, base);
	// 828A1A08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A1A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1A10: 48551A19  bl 0x82df3428
	ctx.lr = 0x828A1A14;
	sub_82DF3428(ctx, base);
	// 828A1A14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1A18: 48551A11  bl 0x82df3428
	ctx.lr = 0x828A1A1C;
	sub_82DF3428(ctx, base);
	// 828A1A1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1A20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1A24: 388B96F0  addi r4, r11, -0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + -26896;
	// 828A1A28: 48551FE1  bl 0x82df3a08
	ctx.lr = 0x828A1A2C;
	sub_82DF3A08(ctx, base);
	// 828A1A2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1A30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1A34: 388B96DC  addi r4, r11, -0x6924
	ctx.r[4].s64 = ctx.r[11].s64 + -26916;
	// 828A1A38: 48551FD1  bl 0x82df3a08
	ctx.lr = 0x828A1A3C;
	sub_82DF3A08(ctx, base);
	// 828A1A3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A1A40: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828A1A44: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828A1A48: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828A1A4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1A50: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A1A54: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 828A1A58: C3AA6218  lfs f29, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828A1A5C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828A1A60: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828A1A64: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828A1A68: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A1A6C: 4BD0183D  bl 0x825a32a8
	ctx.lr = 0x828A1A70;
	sub_825A32A8(ctx, base);
	// 828A1A70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1A78: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1A7C: 4BCFFCF5  bl 0x825a1770
	ctx.lr = 0x828A1A80;
	sub_825A1770(ctx, base);
	// 828A1A80: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 828A1A84: 485519A5  bl 0x82df3428
	ctx.lr = 0x828A1A88;
	sub_82DF3428(ctx, base);
	// 828A1A88: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 828A1A8C: 4BA2722D  bl 0x822c8cb8
	ctx.lr = 0x828A1A90;
	sub_822C8CB8(ctx, base);
	// 828A1A90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1A94: 48551995  bl 0x82df3428
	ctx.lr = 0x828A1A98;
	sub_82DF3428(ctx, base);
	// 828A1A98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1A9C: 4855198D  bl 0x82df3428
	ctx.lr = 0x828A1AA0;
	sub_82DF3428(ctx, base);
	// 828A1AA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1AA4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1AA8: 388B96CC  addi r4, r11, -0x6934
	ctx.r[4].s64 = ctx.r[11].s64 + -26932;
	// 828A1AAC: 48551F5D  bl 0x82df3a08
	ctx.lr = 0x828A1AB0;
	sub_82DF3A08(ctx, base);
	// 828A1AB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1AB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1AB8: 388B96B8  addi r4, r11, -0x6948
	ctx.r[4].s64 = ctx.r[11].s64 + -26952;
	// 828A1ABC: 48551F4D  bl 0x82df3a08
	ctx.lr = 0x828A1AC0;
	sub_82DF3A08(ctx, base);
	// 828A1AC0: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828A1AC4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1AC8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828A1ACC: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 828A1AD0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828A1AD4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A1AD8: 4BD017D1  bl 0x825a32a8
	ctx.lr = 0x828A1ADC;
	sub_825A32A8(ctx, base);
	// 828A1ADC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1AE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1AE8: 4BCFFC89  bl 0x825a1770
	ctx.lr = 0x828A1AEC;
	sub_825A1770(ctx, base);
	// 828A1AEC: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 828A1AF0: 48551939  bl 0x82df3428
	ctx.lr = 0x828A1AF4;
	sub_82DF3428(ctx, base);
	// 828A1AF4: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 828A1AF8: 4BA271C1  bl 0x822c8cb8
	ctx.lr = 0x828A1AFC;
	sub_822C8CB8(ctx, base);
	// 828A1AFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1B00: 48551929  bl 0x82df3428
	ctx.lr = 0x828A1B04;
	sub_82DF3428(ctx, base);
	// 828A1B04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1B08: 48551921  bl 0x82df3428
	ctx.lr = 0x828A1B0C;
	sub_82DF3428(ctx, base);
	// 828A1B0C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A1B10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1B14: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 828A1B18: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A1B1C: 4BA1E8BD  bl 0x822c03d8
	ctx.lr = 0x828A1B20;
	sub_822C03D8(ctx, base);
	// 828A1B20: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A1B24: 41820034  beq 0x828a1b58
	if ctx.cr[0].eq {
	pc = 0x828A1B58; continue 'dispatch;
	}
	// 828A1B28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1B2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1B30: 388B96A8  addi r4, r11, -0x6958
	ctx.r[4].s64 = ctx.r[11].s64 + -26968;
	// 828A1B34: 48551ED5  bl 0x82df3a08
	ctx.lr = 0x828A1B38;
	sub_82DF3A08(ctx, base);
	// 828A1B38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1B3C: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828A1B40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1B44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1B48: 639C0004  ori r28, r28, 4
	ctx.r[28].u64 = ctx.r[28].u64 | 4;
	// 828A1B4C: 4BD0A8C5  bl 0x825ac410
	ctx.lr = 0x828A1B50;
	sub_825AC410(ctx, base);
	// 828A1B50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A1B54: 48000008  b 0x828a1b5c
	pc = 0x828A1B5C; continue 'dispatch;
	// 828A1B58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A1B5C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828A1B60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A1B64: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828A1B68: 4BC51851  bl 0x824f33b8
	ctx.lr = 0x828A1B6C;
	sub_824F33B8(ctx, base);
	// 828A1B6C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A1B70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A1B74: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 828A1B78: 4BA1E489  bl 0x822c0000
	ctx.lr = 0x828A1B7C;
	sub_822C0000(ctx, base);
	// 828A1B7C: 578B077B  rlwinm. r11, r28, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A1B80: 41820010  beq 0x828a1b90
	if ctx.cr[0].eq {
	pc = 0x828A1B90; continue 'dispatch;
	}
	// 828A1B84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1B88: 579C07B8  rlwinm r28, r28, 0, 0x1e, 0x1c
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 828A1B8C: 4855189D  bl 0x82df3428
	ctx.lr = 0x828A1B90;
	sub_82DF3428(ctx, base);
	// 828A1B90: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1B94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1B98: 388B96A0  addi r4, r11, -0x6960
	ctx.r[4].s64 = ctx.r[11].s64 + -26976;
	// 828A1B9C: 48551E6D  bl 0x82df3a08
	ctx.lr = 0x828A1BA0;
	sub_82DF3A08(ctx, base);
	// 828A1BA0: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A1BA4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A1BA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A1BAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1BB0: 4BD0A211  bl 0x825abdc0
	ctx.lr = 0x828A1BB4;
	sub_825ABDC0(ctx, base);
	// 828A1BB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1BB8: 48551871  bl 0x82df3428
	ctx.lr = 0x828A1BBC;
	sub_82DF3428(ctx, base);
	// 828A1BBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1BC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1BC4: 388B9694  addi r4, r11, -0x696c
	ctx.r[4].s64 = ctx.r[11].s64 + -26988;
	// 828A1BC8: 48551E41  bl 0x82df3a08
	ctx.lr = 0x828A1BCC;
	sub_82DF3A08(ctx, base);
	// 828A1BCC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A1BD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A1BD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1BD8: 4BD0A1E9  bl 0x825abdc0
	ctx.lr = 0x828A1BDC;
	sub_825ABDC0(ctx, base);
	// 828A1BDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1BE0: 48551849  bl 0x82df3428
	ctx.lr = 0x828A1BE4;
	sub_82DF3428(ctx, base);
	// 828A1BE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1BE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1BEC: 388B9688  addi r4, r11, -0x6978
	ctx.r[4].s64 = ctx.r[11].s64 + -27000;
	// 828A1BF0: 48551E19  bl 0x82df3a08
	ctx.lr = 0x828A1BF4;
	sub_82DF3A08(ctx, base);
	// 828A1BF4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A1BF8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828A1BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A1C00: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A1C04: 419A0024  beq cr6, 0x828a1c28
	if ctx.cr[6].eq {
	pc = 0x828A1C28; continue 'dispatch;
	}
	// 828A1C08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A1C0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A1C10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1C14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A1C18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A1C1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A1C20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1C24: 4082FFE8  bne 0x828a1c0c
	if !ctx.cr[0].eq {
	pc = 0x828A1C0C; continue 'dispatch;
	}
	// 828A1C28: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828A1C2C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1C34: 4BD004DD  bl 0x825a2110
	ctx.lr = 0x828A1C38;
	sub_825A2110(ctx, base);
	// 828A1C38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1C3C: 485517ED  bl 0x82df3428
	ctx.lr = 0x828A1C40;
	sub_82DF3428(ctx, base);
	// 828A1C40: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A1C44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1C48: 38A0008B  li r5, 0x8b
	ctx.r[5].s64 = 139;
	// 828A1C4C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A1C50: 4BA1E789  bl 0x822c03d8
	ctx.lr = 0x828A1C54;
	sub_822C03D8(ctx, base);
	// 828A1C54: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A1C58: 41820034  beq 0x828a1c8c
	if ctx.cr[0].eq {
	pc = 0x828A1C8C; continue 'dispatch;
	}
	// 828A1C5C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 828A1C60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1C64: 388BB558  addi r4, r11, -0x4aa8
	ctx.r[4].s64 = ctx.r[11].s64 + -19112;
	// 828A1C68: 48551DA1  bl 0x82df3a08
	ctx.lr = 0x828A1C6C;
	sub_82DF3A08(ctx, base);
	// 828A1C6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1C70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A1C74: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1C78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1C7C: 639C0008  ori r28, r28, 8
	ctx.r[28].u64 = ctx.r[28].u64 | 8;
	// 828A1C80: 4BD0A791  bl 0x825ac410
	ctx.lr = 0x828A1C84;
	sub_825AC410(ctx, base);
	// 828A1C84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A1C88: 48000008  b 0x828a1c90
	pc = 0x828A1C90; continue 'dispatch;
	// 828A1C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A1C90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1C94: 4BD10765  bl 0x825b23f8
	ctx.lr = 0x828A1C98;
	sub_825B23F8(ctx, base);
	// 828A1C98: 578B0739  rlwinm. r11, r28, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A1C9C: 4182000C  beq 0x828a1ca8
	if ctx.cr[0].eq {
	pc = 0x828A1CA8; continue 'dispatch;
	}
	// 828A1CA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1CA4: 48551785  bl 0x82df3428
	ctx.lr = 0x828A1CA8;
	sub_82DF3428(ctx, base);
	// 828A1CA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1CAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1CB0: 388B967C  addi r4, r11, -0x6984
	ctx.r[4].s64 = ctx.r[11].s64 + -27012;
	// 828A1CB4: 48551D55  bl 0x82df3a08
	ctx.lr = 0x828A1CB8;
	sub_82DF3A08(ctx, base);
	// 828A1CB8: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A1CBC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A1CC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A1CC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A1CC8: 4BD0A0F9  bl 0x825abdc0
	ctx.lr = 0x828A1CCC;
	sub_825ABDC0(ctx, base);
	// 828A1CCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1CD0: 48551759  bl 0x82df3428
	ctx.lr = 0x828A1CD4;
	sub_82DF3428(ctx, base);
	// 828A1CD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1CDC: 388B9670  addi r4, r11, -0x6990
	ctx.r[4].s64 = ctx.r[11].s64 + -27024;
	// 828A1CE0: 48551D29  bl 0x82df3a08
	ctx.lr = 0x828A1CE4;
	sub_82DF3A08(ctx, base);
	// 828A1CE4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A1CE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A1CEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A1CF0: 4BD0A0D1  bl 0x825abdc0
	ctx.lr = 0x828A1CF4;
	sub_825ABDC0(ctx, base);
	// 828A1CF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1CF8: 48551731  bl 0x82df3428
	ctx.lr = 0x828A1CFC;
	sub_82DF3428(ctx, base);
	// 828A1CFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1D00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1D04: 388B9660  addi r4, r11, -0x69a0
	ctx.r[4].s64 = ctx.r[11].s64 + -27040;
	// 828A1D08: 48551D01  bl 0x82df3a08
	ctx.lr = 0x828A1D0C;
	sub_82DF3A08(ctx, base);
	// 828A1D0C: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A1D10: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 828A1D14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A1D18: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 828A1D1C: 419A0024  beq cr6, 0x828a1d40
	if ctx.cr[6].eq {
	pc = 0x828A1D40; continue 'dispatch;
	}
	// 828A1D20: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828A1D24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A1D28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1D2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A1D30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A1D34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A1D38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A1D3C: 4082FFE8  bne 0x828a1d24
	if !ctx.cr[0].eq {
	pc = 0x828A1D24; continue 'dispatch;
	}
	// 828A1D40: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828A1D44: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1D4C: 4BD003C5  bl 0x825a2110
	ctx.lr = 0x828A1D50;
	sub_825A2110(ctx, base);
	// 828A1D50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1D54: 485516D5  bl 0x82df3428
	ctx.lr = 0x828A1D58;
	sub_82DF3428(ctx, base);
	// 828A1D58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1D5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1D60: 388B9648  addi r4, r11, -0x69b8
	ctx.r[4].s64 = ctx.r[11].s64 + -27064;
	// 828A1D64: 48551CA5  bl 0x82df3a08
	ctx.lr = 0x828A1D68;
	sub_82DF3A08(ctx, base);
	// 828A1D68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1D70: 388B9638  addi r4, r11, -0x69c8
	ctx.r[4].s64 = ctx.r[11].s64 + -27080;
	// 828A1D74: 48551C95  bl 0x82df3a08
	ctx.lr = 0x828A1D78;
	sub_82DF3A08(ctx, base);
	// 828A1D78: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 828A1D7C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1D80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A1D84: 4BD012CD  bl 0x825a3050
	ctx.lr = 0x828A1D88;
	sub_825A3050(ctx, base);
	// 828A1D88: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1D8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1D90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1D94: 4BD003F5  bl 0x825a2188
	ctx.lr = 0x828A1D98;
	sub_825A2188(ctx, base);
	// 828A1D98: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828A1D9C: 4855168D  bl 0x82df3428
	ctx.lr = 0x828A1DA0;
	sub_82DF3428(ctx, base);
	// 828A1DA0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A1DA4: 4BA26F15  bl 0x822c8cb8
	ctx.lr = 0x828A1DA8;
	sub_822C8CB8(ctx, base);
	// 828A1DA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1DAC: 4855167D  bl 0x82df3428
	ctx.lr = 0x828A1DB0;
	sub_82DF3428(ctx, base);
	// 828A1DB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1DB4: 48551675  bl 0x82df3428
	ctx.lr = 0x828A1DB8;
	sub_82DF3428(ctx, base);
	// 828A1DB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1DBC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1DC0: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 828A1DC4: 48551C45  bl 0x82df3a08
	ctx.lr = 0x828A1DC8;
	sub_82DF3A08(ctx, base);
	// 828A1DC8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1DCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1DD0: 388B9610  addi r4, r11, -0x69f0
	ctx.r[4].s64 = ctx.r[11].s64 + -27120;
	// 828A1DD4: 48551C35  bl 0x82df3a08
	ctx.lr = 0x828A1DD8;
	sub_82DF3A08(ctx, base);
	// 828A1DD8: 38BF0061  addi r5, r31, 0x61
	ctx.r[5].s64 = ctx.r[31].s64 + 97;
	// 828A1DDC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1DE0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828A1DE4: 4BD0126D  bl 0x825a3050
	ctx.lr = 0x828A1DE8;
	sub_825A3050(ctx, base);
	// 828A1DE8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1DEC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1DF4: 4BD00395  bl 0x825a2188
	ctx.lr = 0x828A1DF8;
	sub_825A2188(ctx, base);
	// 828A1DF8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828A1DFC: 4855162D  bl 0x82df3428
	ctx.lr = 0x828A1E00;
	sub_82DF3428(ctx, base);
	// 828A1E00: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828A1E04: 4BA26EB5  bl 0x822c8cb8
	ctx.lr = 0x828A1E08;
	sub_822C8CB8(ctx, base);
	// 828A1E08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1E0C: 4855161D  bl 0x82df3428
	ctx.lr = 0x828A1E10;
	sub_82DF3428(ctx, base);
	// 828A1E10: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1E14: 48551615  bl 0x82df3428
	ctx.lr = 0x828A1E18;
	sub_82DF3428(ctx, base);
	// 828A1E18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1E1C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1E20: 388B95F8  addi r4, r11, -0x6a08
	ctx.r[4].s64 = ctx.r[11].s64 + -27144;
	// 828A1E24: 48551BE5  bl 0x82df3a08
	ctx.lr = 0x828A1E28;
	sub_82DF3A08(ctx, base);
	// 828A1E28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1E2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1E30: 388B95E8  addi r4, r11, -0x6a18
	ctx.r[4].s64 = ctx.r[11].s64 + -27160;
	// 828A1E34: 48551BD5  bl 0x82df3a08
	ctx.lr = 0x828A1E38;
	sub_82DF3A08(ctx, base);
	// 828A1E38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828A1E3C: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 828A1E40: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828A1E44: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1E48: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A1E4C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828A1E50: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828A1E54: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828A1E58: 4BD01451  bl 0x825a32a8
	ctx.lr = 0x828A1E5C;
	sub_825A32A8(ctx, base);
	// 828A1E5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1E60: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1E68: 4BCFF909  bl 0x825a1770
	ctx.lr = 0x828A1E6C;
	sub_825A1770(ctx, base);
	// 828A1E6C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828A1E70: 485515B9  bl 0x82df3428
	ctx.lr = 0x828A1E74;
	sub_82DF3428(ctx, base);
	// 828A1E74: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828A1E78: 4BA26E41  bl 0x822c8cb8
	ctx.lr = 0x828A1E7C;
	sub_822C8CB8(ctx, base);
	// 828A1E7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1E80: 485515A9  bl 0x82df3428
	ctx.lr = 0x828A1E84;
	sub_82DF3428(ctx, base);
	// 828A1E84: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1E88: 485515A1  bl 0x82df3428
	ctx.lr = 0x828A1E8C;
	sub_82DF3428(ctx, base);
	// 828A1E8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1E90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1E94: 388B95D0  addi r4, r11, -0x6a30
	ctx.r[4].s64 = ctx.r[11].s64 + -27184;
	// 828A1E98: 48551B71  bl 0x82df3a08
	ctx.lr = 0x828A1E9C;
	sub_82DF3A08(ctx, base);
	// 828A1E9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1EA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1EA4: 388B95C0  addi r4, r11, -0x6a40
	ctx.r[4].s64 = ctx.r[11].s64 + -27200;
	// 828A1EA8: 48551B61  bl 0x82df3a08
	ctx.lr = 0x828A1EAC;
	sub_82DF3A08(ctx, base);
	// 828A1EAC: 38BF005C  addi r5, r31, 0x5c
	ctx.r[5].s64 = ctx.r[31].s64 + 92;
	// 828A1EB0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1EB4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828A1EB8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828A1EBC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828A1EC0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A1EC4: 4BD013E5  bl 0x825a32a8
	ctx.lr = 0x828A1EC8;
	sub_825A32A8(ctx, base);
	// 828A1EC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1ECC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1ED4: 4BCFF89D  bl 0x825a1770
	ctx.lr = 0x828A1ED8;
	sub_825A1770(ctx, base);
	// 828A1ED8: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 828A1EDC: 4855154D  bl 0x82df3428
	ctx.lr = 0x828A1EE0;
	sub_82DF3428(ctx, base);
	// 828A1EE0: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 828A1EE4: 4BA26DD5  bl 0x822c8cb8
	ctx.lr = 0x828A1EE8;
	sub_822C8CB8(ctx, base);
	// 828A1EE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1EEC: 4855153D  bl 0x82df3428
	ctx.lr = 0x828A1EF0;
	sub_82DF3428(ctx, base);
	// 828A1EF0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1EF4: 48551535  bl 0x82df3428
	ctx.lr = 0x828A1EF8;
	sub_82DF3428(ctx, base);
	// 828A1EF8: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A1EFC: 4BD27DD5  bl 0x825c9cd0
	ctx.lr = 0x828A1F00;
	sub_825C9CD0(ctx, base);
	// 828A1F00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A1F04: 419A000C  beq cr6, 0x828a1f10
	if ctx.cr[6].eq {
	pc = 0x828A1F10; continue 'dispatch;
	}
	// 828A1F08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A1F0C: 4BA1E985  bl 0x822c0890
	ctx.lr = 0x828A1F10;
	sub_822C0890(ctx, base);
	// 828A1F10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1F18: 388B95A8  addi r4, r11, -0x6a58
	ctx.r[4].s64 = ctx.r[11].s64 + -27224;
	// 828A1F1C: 48551AED  bl 0x82df3a08
	ctx.lr = 0x828A1F20;
	sub_82DF3A08(ctx, base);
	// 828A1F20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1F24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1F28: 388B9594  addi r4, r11, -0x6a6c
	ctx.r[4].s64 = ctx.r[11].s64 + -27244;
	// 828A1F2C: 48551ADD  bl 0x82df3a08
	ctx.lr = 0x828A1F30;
	sub_82DF3A08(ctx, base);
	// 828A1F30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A1F34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A1F38: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A1F3C: 4BD285C5  bl 0x825ca500
	ctx.lr = 0x828A1F40;
	sub_825CA500(ctx, base);
	// 828A1F40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A1F44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A1F48: 485514E1  bl 0x82df3428
	ctx.lr = 0x828A1F4C;
	sub_82DF3428(ctx, base);
	// 828A1F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A1F50: 485514D9  bl 0x82df3428
	ctx.lr = 0x828A1F54;
	sub_82DF3428(ctx, base);
	// 828A1F54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1F58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1F5C: 388B9584  addi r4, r11, -0x6a7c
	ctx.r[4].s64 = ctx.r[11].s64 + -27260;
	// 828A1F60: 48551AA9  bl 0x82df3a08
	ctx.lr = 0x828A1F64;
	sub_82DF3A08(ctx, base);
	// 828A1F64: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A1F68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1F6C: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 828A1F70: 48551A99  bl 0x82df3a08
	ctx.lr = 0x828A1F74;
	sub_82DF3A08(ctx, base);
	// 828A1F74: 38BF0234  addi r5, r31, 0x234
	ctx.r[5].s64 = ctx.r[31].s64 + 564;
	// 828A1F78: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1F7C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828A1F80: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 828A1F84: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828A1F88: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A1F8C: 4BD0131D  bl 0x825a32a8
	ctx.lr = 0x828A1F90;
	sub_825A32A8(ctx, base);
	// 828A1F90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A1F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A1F98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A1F9C: 4BCFF7D5  bl 0x825a1770
	ctx.lr = 0x828A1FA0;
	sub_825A1770(ctx, base);
	// 828A1FA0: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 828A1FA4: 48551485  bl 0x82df3428
	ctx.lr = 0x828A1FA8;
	sub_82DF3428(ctx, base);
	// 828A1FA8: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 828A1FAC: 4BA26D0D  bl 0x822c8cb8
	ctx.lr = 0x828A1FB0;
	sub_822C8CB8(ctx, base);
	// 828A1FB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1FB4: 48551475  bl 0x82df3428
	ctx.lr = 0x828A1FB8;
	sub_82DF3428(ctx, base);
	// 828A1FB8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1FBC: 4855146D  bl 0x82df3428
	ctx.lr = 0x828A1FC0;
	sub_82DF3428(ctx, base);
	// 828A1FC0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A1FC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A1FC8: 388B9560  addi r4, r11, -0x6aa0
	ctx.r[4].s64 = ctx.r[11].s64 + -27296;
	// 828A1FCC: 48551A3D  bl 0x82df3a08
	ctx.lr = 0x828A1FD0;
	sub_82DF3A08(ctx, base);
	// 828A1FD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A1FD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A1FD8: 388B7C1C  addi r4, r11, 0x7c1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31772;
	// 828A1FDC: 48551A2D  bl 0x82df3a08
	ctx.lr = 0x828A1FE0;
	sub_82DF3A08(ctx, base);
	// 828A1FE0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828A1FE4: 38E02710  li r7, 0x2710
	ctx.r[7].s64 = 10000;
	// 828A1FE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A1FEC: 38BF0230  addi r5, r31, 0x230
	ctx.r[5].s64 = ctx.r[31].s64 + 560;
	// 828A1FF0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828A1FF4: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 828A1FF8: 4BD01421  bl 0x825a3418
	ctx.lr = 0x828A1FFC;
	sub_825A3418(ctx, base);
	// 828A1FFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A2000: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A2004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2008: 4BCFFC59  bl 0x825a1c60
	ctx.lr = 0x828A200C;
	sub_825A1C60(ctx, base);
	// 828A200C: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 828A2010: 48551419  bl 0x82df3428
	ctx.lr = 0x828A2014;
	sub_82DF3428(ctx, base);
	// 828A2014: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828A2018: 4BA26CA1  bl 0x822c8cb8
	ctx.lr = 0x828A201C;
	sub_822C8CB8(ctx, base);
	// 828A201C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A2020: 48551409  bl 0x82df3428
	ctx.lr = 0x828A2024;
	sub_82DF3428(ctx, base);
	// 828A2024: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A2028: 48551401  bl 0x82df3428
	ctx.lr = 0x828A202C;
	sub_82DF3428(ctx, base);
	// 828A202C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2030: 4BD27CA1  bl 0x825c9cd0
	ctx.lr = 0x828A2034;
	sub_825C9CD0(ctx, base);
	// 828A2034: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828A2038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A203C: 388B6980  addi r4, r11, 0x6980
	ctx.r[4].s64 = ctx.r[11].s64 + 27008;
	// 828A2040: 485519C9  bl 0x82df3a08
	ctx.lr = 0x828A2044;
	sub_82DF3A08(ctx, base);
	// 828A2044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2048: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A204C: 388BF098  addi r4, r11, -0xf68
	ctx.r[4].s64 = ctx.r[11].s64 + -3944;
	// 828A2050: 485519B9  bl 0x82df3a08
	ctx.lr = 0x828A2054;
	sub_82DF3A08(ctx, base);
	// 828A2054: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2058: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A205C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A2060: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A2064: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2068: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828A206C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2070: 4E800421  bctrl
	ctx.lr = 0x828A2074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2074: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2078: 485513B1  bl 0x82df3428
	ctx.lr = 0x828A207C;
	sub_82DF3428(ctx, base);
	// 828A207C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2080: 485513A9  bl 0x82df3428
	ctx.lr = 0x828A2084;
	sub_82DF3428(ctx, base);
	// 828A2084: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A208C: 388B9558  addi r4, r11, -0x6aa8
	ctx.r[4].s64 = ctx.r[11].s64 + -27304;
	// 828A2090: 48551979  bl 0x82df3a08
	ctx.lr = 0x828A2094;
	sub_82DF3A08(ctx, base);
	// 828A2094: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A209C: 388B9550  addi r4, r11, -0x6ab0
	ctx.r[4].s64 = ctx.r[11].s64 + -27312;
	// 828A20A0: 48551969  bl 0x82df3a08
	ctx.lr = 0x828A20A4;
	sub_82DF3A08(ctx, base);
	// 828A20A4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A20A8: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A20AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A20B0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A20B4: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828A20B8: 419A0024  beq cr6, 0x828a20dc
	if ctx.cr[6].eq {
	pc = 0x828A20DC; continue 'dispatch;
	}
	// 828A20BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A20C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A20C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A20C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A20CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A20D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A20D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A20D8: 4082FFE8  bne 0x828a20c0
	if !ctx.cr[0].eq {
	pc = 0x828A20C0; continue 'dispatch;
	}
	// 828A20DC: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 828A20E0: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 828A20E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A20E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A20EC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A20F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A20F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A20F8: 4E800421  bctrl
	ctx.lr = 0x828A20FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A20FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2100: 48551329  bl 0x82df3428
	ctx.lr = 0x828A2104;
	sub_82DF3428(ctx, base);
	// 828A2104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2108: 48551321  bl 0x82df3428
	ctx.lr = 0x828A210C;
	sub_82DF3428(ctx, base);
	// 828A210C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2114: 388B9544  addi r4, r11, -0x6abc
	ctx.r[4].s64 = ctx.r[11].s64 + -27324;
	// 828A2118: 485518F1  bl 0x82df3a08
	ctx.lr = 0x828A211C;
	sub_82DF3A08(ctx, base);
	// 828A211C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2120: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2124: 388B953C  addi r4, r11, -0x6ac4
	ctx.r[4].s64 = ctx.r[11].s64 + -27332;
	// 828A2128: 485518E1  bl 0x82df3a08
	ctx.lr = 0x828A212C;
	sub_82DF3A08(ctx, base);
	// 828A212C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A2130: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A2134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2138: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A213C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828A2140: 419A0024  beq cr6, 0x828a2164
	if ctx.cr[6].eq {
	pc = 0x828A2164; continue 'dispatch;
	}
	// 828A2144: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A2148: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A214C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2150: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A2154: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A2158: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A215C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2160: 4082FFE8  bne 0x828a2148
	if !ctx.cr[0].eq {
	pc = 0x828A2148; continue 'dispatch;
	}
	// 828A2164: 817F01F0  lwz r11, 0x1f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 828A2168: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 828A216C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A2170: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A2174: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A2178: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A217C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2180: 4E800421  bctrl
	ctx.lr = 0x828A2184;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2184: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2188: 485512A1  bl 0x82df3428
	ctx.lr = 0x828A218C;
	sub_82DF3428(ctx, base);
	// 828A218C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2190: 48551299  bl 0x82df3428
	ctx.lr = 0x828A2194;
	sub_82DF3428(ctx, base);
	// 828A2194: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A219C: 388B9530  addi r4, r11, -0x6ad0
	ctx.r[4].s64 = ctx.r[11].s64 + -27344;
	// 828A21A0: 48551869  bl 0x82df3a08
	ctx.lr = 0x828A21A4;
	sub_82DF3A08(ctx, base);
	// 828A21A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A21A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A21AC: 388BCCEC  addi r4, r11, -0x3314
	ctx.r[4].s64 = ctx.r[11].s64 + -13076;
	// 828A21B0: 48551859  bl 0x82df3a08
	ctx.lr = 0x828A21B4;
	sub_82DF3A08(ctx, base);
	// 828A21B4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A21B8: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A21BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A21C0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A21C4: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828A21C8: 419A0024  beq cr6, 0x828a21ec
	if ctx.cr[6].eq {
	pc = 0x828A21EC; continue 'dispatch;
	}
	// 828A21CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A21D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A21D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A21D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A21DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A21E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A21E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A21E8: 4082FFE8  bne 0x828a21d0
	if !ctx.cr[0].eq {
	pc = 0x828A21D0; continue 'dispatch;
	}
	// 828A21EC: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 828A21F0: 387F01B0  addi r3, r31, 0x1b0
	ctx.r[3].s64 = ctx.r[31].s64 + 432;
	// 828A21F4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A21F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A21FC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A2200: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2204: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2208: 4E800421  bctrl
	ctx.lr = 0x828A220C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A220C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2210: 48551219  bl 0x82df3428
	ctx.lr = 0x828A2214;
	sub_82DF3428(ctx, base);
	// 828A2214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2218: 48551211  bl 0x82df3428
	ctx.lr = 0x828A221C;
	sub_82DF3428(ctx, base);
	// 828A221C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2224: 388B9528  addi r4, r11, -0x6ad8
	ctx.r[4].s64 = ctx.r[11].s64 + -27352;
	// 828A2228: 485517E1  bl 0x82df3a08
	ctx.lr = 0x828A222C;
	sub_82DF3A08(ctx, base);
	// 828A222C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2230: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2234: 388B9520  addi r4, r11, -0x6ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -27360;
	// 828A2238: 485517D1  bl 0x82df3a08
	ctx.lr = 0x828A223C;
	sub_82DF3A08(ctx, base);
	// 828A223C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A2240: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828A2244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2248: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828A224C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828A2250: 419A0024  beq cr6, 0x828a2274
	if ctx.cr[6].eq {
	pc = 0x828A2274; continue 'dispatch;
	}
	// 828A2254: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A2258: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A225C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2260: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A2264: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A2268: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A226C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A2270: 4082FFE8  bne 0x828a2258
	if !ctx.cr[0].eq {
	pc = 0x828A2258; continue 'dispatch;
	}
	// 828A2274: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 828A2278: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 828A227C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828A2280: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A2284: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828A2288: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A228C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2290: 4E800421  bctrl
	ctx.lr = 0x828A2294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2294: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2298: 48551191  bl 0x82df3428
	ctx.lr = 0x828A229C;
	sub_82DF3428(ctx, base);
	// 828A229C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A22A0: 48551189  bl 0x82df3428
	ctx.lr = 0x828A22A4;
	sub_82DF3428(ctx, base);
	// 828A22A4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A22A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A22AC: 419A0008  beq cr6, 0x828a22b4
	if ctx.cr[6].eq {
	pc = 0x828A22B4; continue 'dispatch;
	}
	// 828A22B0: 4BA1E5E1  bl 0x822c0890
	ctx.lr = 0x828A22B4;
	sub_822C0890(ctx, base);
	// 828A22B4: 382102C0  addi r1, r1, 0x2c0
	ctx.r[1].s64 = ctx.r[1].s64 + 704;
	// 828A22B8: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828A22BC: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828A22C0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828A22C4: 48905EE8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A22C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A22C8 size=372
    let mut pc: u32 = 0x828A22C8;
    'dispatch: loop {
        match pc {
            0x828A22C8 => {
    //   block [0x828A22C8..0x828A243C)
	// 828A22C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A22CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A22D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A22D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A22D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A22DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A22E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A22E4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A22E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A22EC: 409A005C  bne cr6, 0x828a2348
	if !ctx.cr[6].eq {
	pc = 0x828A2348; continue 'dispatch;
	}
	// 828A22F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A22F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828A22F8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828A22FC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828A2300: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828A2304: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 828A2308: C1AB093C  lfs f13, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A230C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828A2310: C16A959C  lfs f11, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828A2314: C18989AC  lfs f12, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A2318: C148967C  lfs f10, -0x6984(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828A231C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A2320: C1279C28  lfs f9, -0x63d8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828A2324: C106D7BC  lfs f8, -0x2844(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828A2328: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828A232C: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828A2330: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828A2334: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828A2338: D15F0038  stfs f10, 0x38(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828A233C: D13F003C  stfs f9, 0x3c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828A2340: D11F0040  stfs f8, 0x40(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828A2344: 480000A4  b 0x828a23e8
	pc = 0x828A23E8; continue 'dispatch;
	// 828A2348: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828A234C: 409A0060  bne cr6, 0x828a23ac
	if !ctx.cr[6].eq {
	pc = 0x828A23AC; continue 'dispatch;
	}
	// 828A2350: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2354: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828A2358: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828A235C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828A2360: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828A2364: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828A2368: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828A236C: C18B9688  lfs f12, -0x6978(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27000 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A2370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A2374: C16A9D1C  lfs f11, -0x62e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828A2378: C1A989AC  lfs f13, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A237C: C1489C28  lfs f10, -0x63d8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828A2380: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A2384: C127959C  lfs f9, -0x6a64(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828A2388: C106967C  lfs f8, -0x6984(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828A238C: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828A2390: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828A2394: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828A2398: D15F0024  stfs f10, 0x24(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828A239C: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828A23A0: D13F0038  stfs f9, 0x38(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828A23A4: D11F0040  stfs f8, 0x40(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828A23A8: 48000044  b 0x828a23ec
	pc = 0x828A23EC; continue 'dispatch;
	// 828A23AC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 828A23B0: 409A004C  bne cr6, 0x828a23fc
	if !ctx.cr[6].eq {
	pc = 0x828A23FC; continue 'dispatch;
	}
	// 828A23B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A23B8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828A23BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A23C0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828A23C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828A23C8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828A23CC: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828A23D0: 913F0054  stw r9, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828A23D4: C1ABD86C  lfs f13, -0x2794(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A23D8: C18A093C  lfs f12, 0x93c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828A23DC: D19F0028  stfs f12, 0x28(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828A23E0: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828A23E4: D19F0040  stfs f12, 0x40(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828A23E8: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828A23EC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828A23F0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828A23F4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828A23F8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828A23FC: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A2400: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A2404: 4082000C  bne 0x828a2410
	if !ctx.cr[0].eq {
	pc = 0x828A2410; continue 'dispatch;
	}
	// 828A2408: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828A240C: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828A2410: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 828A2414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2418: 4BFFEE71  bl 0x828a1288
	ctx.lr = 0x828A241C;
	sub_828A1288(ctx, base);
	// 828A241C: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 828A2420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2424: 4BFFEE65  bl 0x828a1288
	ctx.lr = 0x828A2428;
	sub_828A1288(ctx, base);
	// 828A2428: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A242C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2434: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2440 size=140
    let mut pc: u32 = 0x828A2440;
    'dispatch: loop {
        match pc {
            0x828A2440 => {
    //   block [0x828A2440..0x828A24CC)
	// 828A2440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2444: 48905D29  bl 0x831a816c
	ctx.lr = 0x828A2448;
	sub_831A8130(ctx, base);
	// 828A2448: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828A244C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828A2450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2458: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828A245C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 828A2460: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 828A2464: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 828A2468: 4BC6FDF9  bl 0x82512260
	ctx.lr = 0x828A246C;
	sub_82512260(ctx, base);
	// 828A246C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2470: D3FF00E4  stfs f31, 0xe4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828A2474: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A2478: D3DF00E8  stfs f30, 0xe8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 828A247C: 392B987C  addi r9, r11, -0x6784
	ctx.r[9].s64 = ctx.r[11].s64 + -26500;
	// 828A2480: 394A9864  addi r10, r10, -0x679c
	ctx.r[10].s64 = ctx.r[10].s64 + -26524;
	// 828A2484: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A2488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A248C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828A2490: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828A2494: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 828A2498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A249C: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 828A24A0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 828A24A4: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 828A24A8: C0090140  lfs f0, 0x140(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A24AC: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 828A24B0: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 828A24B4: 93BF0114  stw r29, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[29].u32 ) };
	// 828A24B8: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 828A24BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A24C0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828A24C4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828A24C8: 48905CF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A24D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A24D0 size=8
    let mut pc: u32 = 0x828A24D0;
    'dispatch: loop {
        match pc {
            0x828A24D0 => {
    //   block [0x828A24D0..0x828A24D8)
	// 828A24D0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828A24D4: 480001FC  b 0x828a26d0
	sub_828A26D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A24D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A24D8 size=80
    let mut pc: u32 = 0x828A24D8;
    'dispatch: loop {
        match pc {
            0x828A24D8 => {
    //   block [0x828A24D8..0x828A2528)
	// 828A24D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A24DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A24E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A24E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A24E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A24EC: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 828A24F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A24F4: 419A0008  beq cr6, 0x828a24fc
	if ctx.cr[6].eq {
	pc = 0x828A24FC; continue 'dispatch;
	}
	// 828A24F8: 4BA1E399  bl 0x822c0890
	ctx.lr = 0x828A24FC;
	sub_822C0890(ctx, base);
	// 828A24FC: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 828A2500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2504: 419A0008  beq cr6, 0x828a250c
	if ctx.cr[6].eq {
	pc = 0x828A250C; continue 'dispatch;
	}
	// 828A2508: 4BA1E389  bl 0x822c0890
	ctx.lr = 0x828A250C;
	sub_822C0890(ctx, base);
	// 828A250C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2510: 4BAACE41  bl 0x8234f350
	ctx.lr = 0x828A2514;
	sub_8234F350(ctx, base);
	// 828A2514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A2518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A251C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2528 size=420
    let mut pc: u32 = 0x828A2528;
    'dispatch: loop {
        match pc {
            0x828A2528 => {
    //   block [0x828A2528..0x828A26CC)
	// 828A2528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A252C: 48905C39  bl 0x831a8164
	ctx.lr = 0x828A2530;
	sub_831A8130(ctx, base);
	// 828A2530: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2534: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2538: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A253C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A2540: 38AA98E8  addi r5, r10, -0x6718
	ctx.r[5].s64 = ctx.r[10].s64 + -26392;
	// 828A2544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A2548: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A254C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A2550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2554: 4E800421  bctrl
	ctx.lr = 0x828A2558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2558: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A255C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2560: 419A0008  beq cr6, 0x828a2568
	if ctx.cr[6].eq {
	pc = 0x828A2568; continue 'dispatch;
	}
	// 828A2564: 4BA1E32D  bl 0x822c0890
	ctx.lr = 0x828A2568;
	sub_822C0890(ctx, base);
	// 828A2568: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A256C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A2570: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A2574: 38AA98D4  addi r5, r10, -0x672c
	ctx.r[5].s64 = ctx.r[10].s64 + -26412;
	// 828A2578: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A257C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A2580: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A2584: 4E800421  bctrl
	ctx.lr = 0x828A2588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A2588: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A258C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2590: 419A0008  beq cr6, 0x828a2598
	if ctx.cr[6].eq {
	pc = 0x828A2598; continue 'dispatch;
	}
	// 828A2594: 4BA1E2FD  bl 0x822c0890
	ctx.lr = 0x828A2598;
	sub_822C0890(ctx, base);
	// 828A2598: 817D0108  lwz r11, 0x108(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(264 as u32) ) } as u64;
	// 828A259C: 3BDD0108  addi r30, r29, 0x108
	ctx.r[30].s64 = ctx.r[29].s64 + 264;
	// 828A25A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A25A4: 419A0118  beq cr6, 0x828a26bc
	if ctx.cr[6].eq {
	pc = 0x828A26BC; continue 'dispatch;
	}
	// 828A25A8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A25AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A25B0: 388B98BC  addi r4, r11, -0x6744
	ctx.r[4].s64 = ctx.r[11].s64 + -26436;
	// 828A25B4: 48551455  bl 0x82df3a08
	ctx.lr = 0x828A25B8;
	sub_82DF3A08(ctx, base);
	// 828A25B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A25BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A25C0: 4BC6CF09  bl 0x8250f4c8
	ctx.lr = 0x828A25C4;
	sub_8250F4C8(ctx, base);
	// 828A25C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A25C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828A25CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A25D0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828A25D4: 409A0008  bne cr6, 0x828a25dc
	if !ctx.cr[6].eq {
	pc = 0x828A25DC; continue 'dispatch;
	}
	// 828A25D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A25DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A25E0: 4BC68371  bl 0x8250a950
	ctx.lr = 0x828A25E4;
	sub_8250A950(ctx, base);
	// 828A25E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A25E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A25EC: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 828A25F0: 409A0008  bne cr6, 0x828a25f8
	if !ctx.cr[6].eq {
	pc = 0x828A25F8; continue 'dispatch;
	}
	// 828A25F4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828A25F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A25FC: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828A2600: 4BC6F4E9  bl 0x82511ae8
	ctx.lr = 0x828A2604;
	sub_82511AE8(ctx, base);
	// 828A2604: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2608: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A260C: 485D99CD  bl 0x82e7bfd8
	ctx.lr = 0x828A2610;
	sub_82E7BFD8(ctx, base);
	// 828A2610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A2614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A261C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A2620: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 828A2624: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2628: 4BF32529  bl 0x827d4b50
	ctx.lr = 0x828A262C;
	sub_827D4B50(ctx, base);
	// 828A262C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A2630: 4854F661  bl 0x82df1c90
	ctx.lr = 0x828A2634;
	sub_82DF1C90(ctx, base);
	// 828A2634: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A2638: 4854F659  bl 0x82df1c90
	ctx.lr = 0x828A263C;
	sub_82DF1C90(ctx, base);
	// 828A263C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2640: 48550DE9  bl 0x82df3428
	ctx.lr = 0x828A2644;
	sub_82DF3428(ctx, base);
	// 828A2644: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A2648: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A264C: 485DF0F5  bl 0x82e81740
	ctx.lr = 0x828A2650;
	sub_82E81740(ctx, base);
	// 828A2650: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A2654: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A2658: 4BC6CE71  bl 0x8250f4c8
	ctx.lr = 0x828A265C;
	sub_8250F4C8(ctx, base);
	// 828A265C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2664: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828A2668: 409A0008  bne cr6, 0x828a2670
	if !ctx.cr[6].eq {
	pc = 0x828A2670; continue 'dispatch;
	}
	// 828A266C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A2670: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A2674: 4BC682DD  bl 0x8250a950
	ctx.lr = 0x828A2678;
	sub_8250A950(ctx, base);
	// 828A2678: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A267C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2680: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 828A2684: 409A0008  bne cr6, 0x828a268c
	if !ctx.cr[6].eq {
	pc = 0x828A268C; continue 'dispatch;
	}
	// 828A2688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A268C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2690: 4BF312E1  bl 0x827d3970
	ctx.lr = 0x828A2694;
	sub_827D3970(ctx, base);
	// 828A2694: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A2698: 4854F5F9  bl 0x82df1c90
	ctx.lr = 0x828A269C;
	sub_82DF1C90(ctx, base);
	// 828A269C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A26A0: 4854F5F1  bl 0x82df1c90
	ctx.lr = 0x828A26A4;
	sub_82DF1C90(ctx, base);
	// 828A26A4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828A26A8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A26AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A26B0: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828A26B4: 419A0008  beq cr6, 0x828a26bc
	if ctx.cr[6].eq {
	pc = 0x828A26BC; continue 'dispatch;
	}
	// 828A26B8: 4BA1E1D9  bl 0x822c0890
	ctx.lr = 0x828A26BC;
	sub_822C0890(ctx, base);
	// 828A26BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A26C0: 4BC6DF11  bl 0x825105d0
	ctx.lr = 0x828A26C4;
	sub_825105D0(ctx, base);
	// 828A26C4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 828A26C8: 48905AEC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A26D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A26D0 size=76
    let mut pc: u32 = 0x828A26D0;
    'dispatch: loop {
        match pc {
            0x828A26D0 => {
    //   block [0x828A26D0..0x828A271C)
	// 828A26D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A26D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A26D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A26DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A26E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A26E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A26E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A26EC: 4BFFFDED  bl 0x828a24d8
	ctx.lr = 0x828A26F0;
	sub_828A24D8(ctx, base);
	// 828A26F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A26F4: 4182000C  beq 0x828a2700
	if ctx.cr[0].eq {
	pc = 0x828A2700; continue 'dispatch;
	}
	// 828A26F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A26FC: 4854FCDD  bl 0x82df23d8
	ctx.lr = 0x828A2700;
	sub_82DF23D8(ctx, base);
	// 828A2700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A2708: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A270C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2710: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A2714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A2720 size=368
    let mut pc: u32 = 0x828A2720;
    'dispatch: loop {
        match pc {
            0x828A2720 => {
    //   block [0x828A2720..0x828A2890)
	// 828A2720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A272C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2730: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828A2734: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2890 size=160
    let mut pc: u32 = 0x828A2890;
    'dispatch: loop {
        match pc {
            0x828A2890 => {
    //   block [0x828A2890..0x828A2930)
	// 828A2890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2894: 489058C9  bl 0x831a815c
	ctx.lr = 0x828A2898;
	sub_831A8130(ctx, base);
	// 828A2898: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A289C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A28A0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A28A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A28A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A28AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828A28B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A28B4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A28B8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A28BC: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828A28C0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828A28C4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 828A28C8: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 828A28CC: 4854FB1D  bl 0x82df23e8
	ctx.lr = 0x828A28D0;
	sub_82DF23E8(ctx, base);
	// 828A28D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A28D4: 41820028  beq 0x828a28fc
	if ctx.cr[0].eq {
	pc = 0x828A28FC; continue 'dispatch;
	}
	// 828A28D8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 828A28DC: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A28E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828A28E4: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A28E8: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A28EC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A28F0: 482AFB41  bl 0x82b52430
	ctx.lr = 0x828A28F4;
	sub_82B52430(ctx, base);
	// 828A28F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A28F8: 48000008  b 0x828a2900
	pc = 0x828A2900; continue 'dispatch;
	// 828A28FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A2900: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A2904: 3BD90004  addi r30, r25, 4
	ctx.r[30].s64 = ctx.r[25].s64 + 4;
	// 828A2908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A290C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2910: 4BAB6B91  bl 0x823594a0
	ctx.lr = 0x828A2914;
	sub_823594A0(ctx, base);
	// 828A2914: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A2918: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A291C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2920: 4BA1D6E1  bl 0x822c0000
	ctx.lr = 0x828A2924;
	sub_822C0000(ctx, base);
	// 828A2924: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A2928: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A292C: 48905880  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2930 size=232
    let mut pc: u32 = 0x828A2930;
    'dispatch: loop {
        match pc {
            0x828A2930 => {
    //   block [0x828A2930..0x828A2A18)
	// 828A2930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2934: 48905835  bl 0x831a8168
	ctx.lr = 0x828A2938;
	sub_831A8130(ctx, base);
	// 828A2938: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A293C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828A2940: 39400011  li r10, 0x11
	ctx.r[10].s64 = 17;
	// 828A2944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2948: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A294C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A2950: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 828A2954: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828A2958: 4BC6F191  bl 0x82511ae8
	ctx.lr = 0x828A295C;
	sub_82511AE8(ctx, base);
	// 828A295C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828A2960: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828A2964: 388B85F4  addi r4, r11, -0x7a0c
	ctx.r[4].s64 = ctx.r[11].s64 + -31244;
	// 828A2968: 38DF0114  addi r6, r31, 0x114
	ctx.r[6].s64 = ctx.r[31].s64 + 276;
	// 828A296C: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 828A2970: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A2974: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 828A2978: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828A297C: 4BFFFF15  bl 0x828a2890
	ctx.lr = 0x828A2980;
	sub_828A2890(ctx, base);
	// 828A2980: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2984: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A2988: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A298C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2990: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A2994: 419A0024  beq cr6, 0x828a29b8
	if ctx.cr[6].eq {
	pc = 0x828A29B8; continue 'dispatch;
	}
	// 828A2998: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A299C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A29A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A29A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A29A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A29AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A29B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A29B4: 4082FFE8  bne 0x828a299c
	if !ctx.cr[0].eq {
	pc = 0x828A299C; continue 'dispatch;
	}
	// 828A29B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A29BC: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828A29C0: 48765769  bl 0x83008128
	ctx.lr = 0x828A29C4;
	sub_83008128(ctx, base);
	// 828A29C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A29C8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A29CC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828A29D0: 388A98F8  addi r4, r10, -0x6708
	ctx.r[4].s64 = ctx.r[10].s64 + -26376;
	// 828A29D4: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 828A29D8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828A29DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A29E0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828A29E4: 485B605D  bl 0x82e58a40
	ctx.lr = 0x828A29E8;
	sub_82E58A40(ctx, base);
	// 828A29E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A29EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A29F0: 419A0008  beq cr6, 0x828a29f8
	if ctx.cr[6].eq {
	pc = 0x828A29F8; continue 'dispatch;
	}
	// 828A29F4: 4BA1DE9D  bl 0x822c0890
	ctx.lr = 0x828A29F8;
	sub_822C0890(ctx, base);
	// 828A29F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A29FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2A00: 419A0008  beq cr6, 0x828a2a08
	if ctx.cr[6].eq {
	pc = 0x828A2A08; continue 'dispatch;
	}
	// 828A2A04: 4BA1DE8D  bl 0x822c0890
	ctx.lr = 0x828A2A08;
	sub_822C0890(ctx, base);
	// 828A2A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2A0C: 4BFFFB1D  bl 0x828a2528
	ctx.lr = 0x828A2A10;
	sub_828A2528(ctx, base);
	// 828A2A10: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A2A14: 489057A4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2A18 size=712
    let mut pc: u32 = 0x828A2A18;
    'dispatch: loop {
        match pc {
            0x828A2A18 => {
    //   block [0x828A2A18..0x828A2CE0)
	// 828A2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2A1C: 48905751  bl 0x831a816c
	ctx.lr = 0x828A2A20;
	sub_831A8130(ctx, base);
	// 828A2A20: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2A28: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828A2A2C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A2A30: 4BC6EFA9  bl 0x825119d8
	ctx.lr = 0x828A2A34;
	sub_825119D8(ctx, base);
	// 828A2A34: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A2A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2A3C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828A2A40: 48550FC9  bl 0x82df3a08
	ctx.lr = 0x828A2A44;
	sub_82DF3A08(ctx, base);
	// 828A2A44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A2A48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2A50: 4BC65D31  bl 0x82508780
	ctx.lr = 0x828A2A54;
	sub_82508780(ctx, base);
	// 828A2A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2A58: 485509D1  bl 0x82df3428
	ctx.lr = 0x828A2A5C;
	sub_82DF3428(ctx, base);
	// 828A2A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A2A60: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 828A2A64: 409A0008  bne cr6, 0x828a2a6c
	if !ctx.cr[6].eq {
	pc = 0x828A2A6C; continue 'dispatch;
	}
	// 828A2A68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A2A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2A70: 4BC65D31  bl 0x825087a0
	ctx.lr = 0x828A2A74;
	sub_825087A0(ctx, base);
	// 828A2A74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A2A78: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828A2A7C: 4BC6F69D  bl 0x82512118
	ctx.lr = 0x828A2A80;
	sub_82512118(ctx, base);
	// 828A2A80: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2A84: 4856FC8D  bl 0x82e12710
	ctx.lr = 0x828A2A88;
	sub_82E12710(ctx, base);
	// 828A2A88: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828A2A8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2A90: 419A0008  beq cr6, 0x828a2a98
	if ctx.cr[6].eq {
	pc = 0x828A2A98; continue 'dispatch;
	}
	// 828A2A94: 4BA1DDFD  bl 0x822c0890
	ctx.lr = 0x828A2A98;
	sub_822C0890(ctx, base);
	// 828A2A98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2A9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A2AA0: 388B98F8  addi r4, r11, -0x6708
	ctx.r[4].s64 = ctx.r[11].s64 + -26376;
	// 828A2AA4: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 828A2AA8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828A2AAC: 4BA1D92D  bl 0x822c03d8
	ctx.lr = 0x828A2AB0;
	sub_822C03D8(ctx, base);
	// 828A2AB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A2AB4: 41820014  beq 0x828a2ac8
	if ctx.cr[0].eq {
	pc = 0x828A2AC8; continue 'dispatch;
	}
	// 828A2AB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A2ABC: 4BBEE635  bl 0x824910f0
	ctx.lr = 0x828A2AC0;
	sub_824910F0(ctx, base);
	// 828A2AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2AC4: 48000008  b 0x828a2acc
	pc = 0x828A2ACC; continue 'dispatch;
	// 828A2AC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A2ACC: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 828A2AD0: 4BA67C11  bl 0x8230a6e0
	ctx.lr = 0x828A2AD4;
	sub_8230A6E0(ctx, base);
	// 828A2AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2AD8: 4BC6FFC1  bl 0x82512a98
	ctx.lr = 0x828A2ADC;
	sub_82512A98(ctx, base);
	// 828A2ADC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2AE0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828A2AE4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828A2AE8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828A2AEC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828A2AF0: 485FDC41  bl 0x82ea0730
	ctx.lr = 0x828A2AF4;
	sub_82EA0730(ctx, base);
	// 828A2AF4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828A2AF8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A2AFC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828A2B00: C02A985C  lfs f1, -0x67a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26532 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2B04: 486776ED  bl 0x82f1a1f0
	ctx.lr = 0x828A2B08;
	sub_82F1A1F0(ctx, base);
	// 828A2B08: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828A2B0C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 828A2B10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A2B14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2B18: 80AB6750  lwz r5, 0x6750(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 828A2B1C: 808A6784  lwz r4, 0x6784(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26500 as u32) ) } as u64;
	// 828A2B20: 4BA54C81  bl 0x822f77a0
	ctx.lr = 0x828A2B24;
	sub_822F77A0(ctx, base);
	// 828A2B24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828A2B28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2B2C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A2B30: 808B6790  lwz r4, 0x6790(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26512 as u32) ) } as u64;
	// 828A2B34: 4BA423FD  bl 0x822e4f30
	ctx.lr = 0x828A2B38;
	sub_822E4F30(ctx, base);
	// 828A2B38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A2B3C: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828A2B40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A2B44: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828A2B48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A2B4C: 4BBE973D  bl 0x8248c288
	ctx.lr = 0x828A2B50;
	sub_8248C288(ctx, base);
	// 828A2B50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A2B54: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828A2B58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828A2B5C: 419A000C  beq cr6, 0x828a2b68
	if ctx.cr[6].eq {
	pc = 0x828A2B68; continue 'dispatch;
	}
	// 828A2B60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2B64: 4BA456E5  bl 0x822e8248
	ctx.lr = 0x828A2B68;
	sub_822E8248(ctx, base);
	// 828A2B68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2B70: 388B9820  addi r4, r11, -0x67e0
	ctx.r[4].s64 = ctx.r[11].s64 + -26592;
	// 828A2B74: 485569BD  bl 0x82df9530
	ctx.lr = 0x828A2B78;
	sub_82DF9530(ctx, base);
	// 828A2B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A2B7C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A2B80: 4BC6F599  bl 0x82512118
	ctx.lr = 0x828A2B84;
	sub_82512118(ctx, base);
	// 828A2B84: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828A2B88: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828A2B8C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A2B90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2B98: 4BC70561  bl 0x825130f8
	ctx.lr = 0x828A2B9C;
	sub_825130F8(ctx, base);
	// 828A2B9C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A2BA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2BA4: 419A0008  beq cr6, 0x828a2bac
	if ctx.cr[6].eq {
	pc = 0x828A2BAC; continue 'dispatch;
	}
	// 828A2BA8: 4BA456C1  bl 0x822e8268
	ctx.lr = 0x828A2BAC;
	sub_822E8268(ctx, base);
	// 828A2BAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828A2BB0: 419A000C  beq cr6, 0x828a2bbc
	if ctx.cr[6].eq {
	pc = 0x828A2BBC; continue 'dispatch;
	}
	// 828A2BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A2BB8: 4BA456B1  bl 0x822e8268
	ctx.lr = 0x828A2BBC;
	sub_822E8268(ctx, base);
	// 828A2BBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2BC4: 388B9964  addi r4, r11, -0x669c
	ctx.r[4].s64 = ctx.r[11].s64 + -26268;
	// 828A2BC8: 48550E41  bl 0x82df3a08
	ctx.lr = 0x828A2BCC;
	sub_82DF3A08(ctx, base);
	// 828A2BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A2BD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A2BD4: 4BC6C8F5  bl 0x8250f4c8
	ctx.lr = 0x828A2BD8;
	sub_8250F4C8(ctx, base);
	// 828A2BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2BE0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828A2BE4: 409A0008  bne cr6, 0x828a2bec
	if !ctx.cr[6].eq {
	pc = 0x828A2BEC; continue 'dispatch;
	}
	// 828A2BE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A2BEC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A2BF0: 4BC67D61  bl 0x8250a950
	ctx.lr = 0x828A2BF4;
	sub_8250A950(ctx, base);
	// 828A2BF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A2BFC: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 828A2C00: 409A0008  bne cr6, 0x828a2c08
	if !ctx.cr[6].eq {
	pc = 0x828A2C08; continue 'dispatch;
	}
	// 828A2C04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A2C08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A2C0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A2C10: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828A2C14: 4BC6F505  bl 0x82512118
	ctx.lr = 0x828A2C18;
	sub_82512118(ctx, base);
	// 828A2C18: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A2C1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2C20: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A2C24: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828A2C28: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828A2C2C: 4BF32085  bl 0x827d4cb0
	ctx.lr = 0x828A2C30;
	sub_827D4CB0(ctx, base);
	// 828A2C30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A2C34: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 828A2C38: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828A2C3C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 828A2C40: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A2C44: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 828A2C48: 4BA21819  bl 0x822c4460
	ctx.lr = 0x828A2C4C;
	sub_822C4460(ctx, base);
	// 828A2C4C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A2C50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2C54: 419A0008  beq cr6, 0x828a2c5c
	if ctx.cr[6].eq {
	pc = 0x828A2C5C; continue 'dispatch;
	}
	// 828A2C58: 4BA1DC39  bl 0x822c0890
	ctx.lr = 0x828A2C5C;
	sub_822C0890(ctx, base);
	// 828A2C5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A2C60: 4854F031  bl 0x82df1c90
	ctx.lr = 0x828A2C64;
	sub_82DF1C90(ctx, base);
	// 828A2C64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A2C68: 4854F029  bl 0x82df1c90
	ctx.lr = 0x828A2C6C;
	sub_82DF1C90(ctx, base);
	// 828A2C6C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828A2C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A2C74: 419A0008  beq cr6, 0x828a2c7c
	if ctx.cr[6].eq {
	pc = 0x828A2C7C; continue 'dispatch;
	}
	// 828A2C78: 4BA1DC19  bl 0x822c0890
	ctx.lr = 0x828A2C7C;
	sub_822C0890(ctx, base);
	// 828A2C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2C80: 485507A9  bl 0x82df3428
	ctx.lr = 0x828A2C84;
	sub_82DF3428(ctx, base);
	// 828A2C84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A2C88: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A2C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2C90: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A2C94: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A2C98: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828A2C9C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828A2CA0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828A2CA4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828A2CA8: 4BC6EEB1  bl 0x82511b58
	ctx.lr = 0x828A2CAC;
	sub_82511B58(ctx, base);
	// 828A2CAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2CB0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828A2CB4: 485D91E5  bl 0x82e7be98
	ctx.lr = 0x828A2CB8;
	sub_82E7BE98(ctx, base);
	// 828A2CB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A2CBC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828A2CC0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A2CC4: 485D9005  bl 0x82e7bcc8
	ctx.lr = 0x828A2CC8;
	sub_82E7BCC8(ctx, base);
	// 828A2CC8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 828A2CCC: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 828A2CD0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A2CE0 size=136
    let mut pc: u32 = 0x828A2CE0;
    'dispatch: loop {
        match pc {
            0x828A2CE0 => {
    //   block [0x828A2CE0..0x828A2D68)
	// 828A2CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A2CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2CF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2CFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A2D00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D04: 388B99A4  addi r4, r11, -0x665c
	ctx.r[4].s64 = ctx.r[11].s64 + -26204;
	// 828A2D08: 48550D01  bl 0x82df3a08
	ctx.lr = 0x828A2D0C;
	sub_82DF3A08(ctx, base);
	// 828A2D0C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828A2D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2D18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A2D1C: 4806B135  bl 0x8290de50
	ctx.lr = 0x828A2D20;
	sub_8290DE50(ctx, base);
	// 828A2D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D24: 48550705  bl 0x82df3428
	ctx.lr = 0x828A2D28;
	sub_82DF3428(ctx, base);
	// 828A2D28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D30: 388B998C  addi r4, r11, -0x6674
	ctx.r[4].s64 = ctx.r[11].s64 + -26228;
	// 828A2D34: 48550CD5  bl 0x82df3a08
	ctx.lr = 0x828A2D38;
	sub_82DF3A08(ctx, base);
	// 828A2D38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A2D3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A2D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2D44: 4806B1E5  bl 0x8290df28
	ctx.lr = 0x828A2D48;
	sub_8290DF28(ctx, base);
	// 828A2D48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D4C: 485506DD  bl 0x82df3428
	ctx.lr = 0x828A2D50;
	sub_82DF3428(ctx, base);
	// 828A2D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A2D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A2D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2D68 size=232
    let mut pc: u32 = 0x828A2D68;
    'dispatch: loop {
        match pc {
            0x828A2D68 => {
    //   block [0x828A2D68..0x828A2E50)
	// 828A2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2D74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2D78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A2D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2D84: 388BA148  addi r4, r11, -0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -24248;
	// 828A2D88: 48550C81  bl 0x82df3a08
	ctx.lr = 0x828A2D8C;
	sub_82DF3A08(ctx, base);
	// 828A2D8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A2D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2D94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2D9C: C02BD7BC  lfs f1, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2DA0: 480698E1  bl 0x8290c680
	ctx.lr = 0x828A2DA4;
	sub_8290C680(ctx, base);
	// 828A2DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2DA8: 48550681  bl 0x82df3428
	ctx.lr = 0x828A2DAC;
	sub_82DF3428(ctx, base);
	// 828A2DAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2DB4: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828A2DB8: 48550C51  bl 0x82df3a08
	ctx.lr = 0x828A2DBC;
	sub_82DF3A08(ctx, base);
	// 828A2DBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2DC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2DC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2DCC: C02B9648  lfs f1, -0x69b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2DD0: 480698B1  bl 0x8290c680
	ctx.lr = 0x828A2DD4;
	sub_8290C680(ctx, base);
	// 828A2DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2DD8: 48550651  bl 0x82df3428
	ctx.lr = 0x828A2DDC;
	sub_82DF3428(ctx, base);
	// 828A2DDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2DE4: 388B99BC  addi r4, r11, -0x6644
	ctx.r[4].s64 = ctx.r[11].s64 + -26180;
	// 828A2DE8: 48550C21  bl 0x82df3a08
	ctx.lr = 0x828A2DEC;
	sub_82DF3A08(ctx, base);
	// 828A2DEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2DF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2DF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2DFC: C02B0824  lfs f1, 0x824(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2084 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2E00: 48069881  bl 0x8290c680
	ctx.lr = 0x828A2E04;
	sub_8290C680(ctx, base);
	// 828A2E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E08: 48550621  bl 0x82df3428
	ctx.lr = 0x828A2E0C;
	sub_82DF3428(ctx, base);
	// 828A2E0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E14: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828A2E18: 48550BF1  bl 0x82df3a08
	ctx.lr = 0x828A2E1C;
	sub_82DF3A08(ctx, base);
	// 828A2E1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2E20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2E24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2E2C: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2E30: 48069851  bl 0x8290c680
	ctx.lr = 0x828A2E34;
	sub_8290C680(ctx, base);
	// 828A2E34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E38: 485505F1  bl 0x82df3428
	ctx.lr = 0x828A2E3C;
	sub_82DF3428(ctx, base);
	// 828A2E3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A2E40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2E44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2E50 size=232
    let mut pc: u32 = 0x828A2E50;
    'dispatch: loop {
        match pc {
            0x828A2E50 => {
    //   block [0x828A2E50..0x828A2F38)
	// 828A2E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2E5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2E60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A2E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E6C: 388BA148  addi r4, r11, -0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -24248;
	// 828A2E70: 48550B99  bl 0x82df3a08
	ctx.lr = 0x828A2E74;
	sub_82DF3A08(ctx, base);
	// 828A2E74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A2E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2E7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2E80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2E84: C02BD7BC  lfs f1, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2E88: 48069899  bl 0x8290c720
	ctx.lr = 0x828A2E8C;
	sub_8290C720(ctx, base);
	// 828A2E8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E90: 48550599  bl 0x82df3428
	ctx.lr = 0x828A2E94;
	sub_82DF3428(ctx, base);
	// 828A2E94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2E9C: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828A2EA0: 48550B69  bl 0x82df3a08
	ctx.lr = 0x828A2EA4;
	sub_82DF3A08(ctx, base);
	// 828A2EA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2EAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2EB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2EB4: C02B9648  lfs f1, -0x69b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2EB8: 48069869  bl 0x8290c720
	ctx.lr = 0x828A2EBC;
	sub_8290C720(ctx, base);
	// 828A2EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2EC0: 48550569  bl 0x82df3428
	ctx.lr = 0x828A2EC4;
	sub_82DF3428(ctx, base);
	// 828A2EC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2ECC: 388B99BC  addi r4, r11, -0x6644
	ctx.r[4].s64 = ctx.r[11].s64 + -26180;
	// 828A2ED0: 48550B39  bl 0x82df3a08
	ctx.lr = 0x828A2ED4;
	sub_82DF3A08(ctx, base);
	// 828A2ED4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2EDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2EE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2EE4: C02B0824  lfs f1, 0x824(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2084 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2EE8: 48069839  bl 0x8290c720
	ctx.lr = 0x828A2EEC;
	sub_8290C720(ctx, base);
	// 828A2EEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2EF0: 48550539  bl 0x82df3428
	ctx.lr = 0x828A2EF4;
	sub_82DF3428(ctx, base);
	// 828A2EF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2EFC: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828A2F00: 48550B09  bl 0x82df3a08
	ctx.lr = 0x828A2F04;
	sub_82DF3A08(ctx, base);
	// 828A2F04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2F08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A2F0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2F14: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2F18: 48069809  bl 0x8290c720
	ctx.lr = 0x828A2F1C;
	sub_8290C720(ctx, base);
	// 828A2F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2F20: 48550509  bl 0x82df3428
	ctx.lr = 0x828A2F24;
	sub_82DF3428(ctx, base);
	// 828A2F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A2F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A2F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A2F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A2F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A2F38 size=232
    let mut pc: u32 = 0x828A2F38;
    'dispatch: loop {
        match pc {
            0x828A2F38 => {
    //   block [0x828A2F38..0x828A3020)
	// 828A2F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A2F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A2F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A2F44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A2F48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A2F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A2F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2F54: 388BA148  addi r4, r11, -0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -24248;
	// 828A2F58: 48550AB1  bl 0x82df3a08
	ctx.lr = 0x828A2F5C;
	sub_82DF3A08(ctx, base);
	// 828A2F5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A2F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2F64: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A2F68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2F6C: C02BD7BC  lfs f1, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2F70: 48069711  bl 0x8290c680
	ctx.lr = 0x828A2F74;
	sub_8290C680(ctx, base);
	// 828A2F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2F78: 485504B1  bl 0x82df3428
	ctx.lr = 0x828A2F7C;
	sub_82DF3428(ctx, base);
	// 828A2F7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2F84: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828A2F88: 48550A81  bl 0x82df3a08
	ctx.lr = 0x828A2F8C;
	sub_82DF3A08(ctx, base);
	// 828A2F8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2F94: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A2F98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2F9C: C02B9648  lfs f1, -0x69b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2FA0: 480696E1  bl 0x8290c680
	ctx.lr = 0x828A2FA4;
	sub_8290C680(ctx, base);
	// 828A2FA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2FA8: 48550481  bl 0x82df3428
	ctx.lr = 0x828A2FAC;
	sub_82DF3428(ctx, base);
	// 828A2FAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A2FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2FB4: 388B99BC  addi r4, r11, -0x6644
	ctx.r[4].s64 = ctx.r[11].s64 + -26180;
	// 828A2FB8: 48550A51  bl 0x82df3a08
	ctx.lr = 0x828A2FBC;
	sub_82DF3A08(ctx, base);
	// 828A2FBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2FC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A2FC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2FCC: C02B0824  lfs f1, 0x824(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2084 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A2FD0: 480696B1  bl 0x8290c680
	ctx.lr = 0x828A2FD4;
	sub_8290C680(ctx, base);
	// 828A2FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2FD8: 48550451  bl 0x82df3428
	ctx.lr = 0x828A2FDC;
	sub_82DF3428(ctx, base);
	// 828A2FDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A2FE4: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828A2FE8: 48550A21  bl 0x82df3a08
	ctx.lr = 0x828A2FEC;
	sub_82DF3A08(ctx, base);
	// 828A2FEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A2FF0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A2FF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A2FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A2FFC: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A3000: 48069681  bl 0x8290c680
	ctx.lr = 0x828A3004;
	sub_8290C680(ctx, base);
	// 828A3004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3008: 48550421  bl 0x82df3428
	ctx.lr = 0x828A300C;
	sub_82DF3428(ctx, base);
	// 828A300C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A301C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A3020 size=232
    let mut pc: u32 = 0x828A3020;
    'dispatch: loop {
        match pc {
            0x828A3020 => {
    //   block [0x828A3020..0x828A3108)
	// 828A3020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A302C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3030: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A3034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A303C: 388BA148  addi r4, r11, -0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + -24248;
	// 828A3040: 485509C9  bl 0x82df3a08
	ctx.lr = 0x828A3044;
	sub_82DF3A08(ctx, base);
	// 828A3044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A3048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A304C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A3050: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3054: C02BD7BC  lfs f1, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A3058: 480696C9  bl 0x8290c720
	ctx.lr = 0x828A305C;
	sub_8290C720(ctx, base);
	// 828A305C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3060: 485503C9  bl 0x82df3428
	ctx.lr = 0x828A3064;
	sub_82DF3428(ctx, base);
	// 828A3064: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A3068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A306C: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828A3070: 48550999  bl 0x82df3a08
	ctx.lr = 0x828A3074;
	sub_82DF3A08(ctx, base);
	// 828A3074: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A3078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A307C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A3080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3084: C02B9648  lfs f1, -0x69b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A3088: 48069699  bl 0x8290c720
	ctx.lr = 0x828A308C;
	sub_8290C720(ctx, base);
	// 828A308C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3090: 48550399  bl 0x82df3428
	ctx.lr = 0x828A3094;
	sub_82DF3428(ctx, base);
	// 828A3094: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A309C: 388B99BC  addi r4, r11, -0x6644
	ctx.r[4].s64 = ctx.r[11].s64 + -26180;
	// 828A30A0: 48550969  bl 0x82df3a08
	ctx.lr = 0x828A30A4;
	sub_82DF3A08(ctx, base);
	// 828A30A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A30A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A30AC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A30B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A30B4: C02B0824  lfs f1, 0x824(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2084 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A30B8: 48069669  bl 0x8290c720
	ctx.lr = 0x828A30BC;
	sub_8290C720(ctx, base);
	// 828A30BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A30C0: 48550369  bl 0x82df3428
	ctx.lr = 0x828A30C4;
	sub_82DF3428(ctx, base);
	// 828A30C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A30C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A30CC: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828A30D0: 48550939  bl 0x82df3a08
	ctx.lr = 0x828A30D4;
	sub_82DF3A08(ctx, base);
	// 828A30D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A30D8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828A30DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A30E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A30E4: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A30E8: 48069639  bl 0x8290c720
	ctx.lr = 0x828A30EC;
	sub_8290C720(ctx, base);
	// 828A30EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A30F0: 48550339  bl 0x82df3428
	ctx.lr = 0x828A30F4;
	sub_82DF3428(ctx, base);
	// 828A30F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A30F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A30FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3108 size=28
    let mut pc: u32 = 0x828A3108;
    'dispatch: loop {
        match pc {
            0x828A3108 => {
    //   block [0x828A3108..0x828A3124)
	// 828A3108: 814303CC  lwz r10, 0x3cc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A310C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A3110: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A3114: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3118: 1D4A03B4  mulli r10, r10, 0x3b4
	ctx.r[10].s64 = ctx.r[10].s64 * 948;
	// 828A311C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A3120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3128 size=12
    let mut pc: u32 = 0x828A3128;
    'dispatch: loop {
        match pc {
            0x828A3128 => {
    //   block [0x828A3128..0x828A3134)
	// 828A3128: 808303C0  lwz r4, 0x3c0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(960 as u32) ) } as u64;
	// 828A312C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A3130: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3134(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3134 size=8
    let mut pc: u32 = 0x828A3134;
    'dispatch: loop {
        match pc {
            0x828A3134 => {
    //   block [0x828A3134..0x828A313C)
	// 828A3134: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828A3138: 4BF49140  b 0x827ec278
	sub_827EC278(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A313C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A313C size=4
    let mut pc: u32 = 0x828A313C;
    'dispatch: loop {
        match pc {
            0x828A313C => {
    //   block [0x828A313C..0x828A3140)
	// 828A313C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3140 size=12
    let mut pc: u32 = 0x828A3140;
    'dispatch: loop {
        match pc {
            0x828A3140 => {
    //   block [0x828A3140..0x828A314C)
	// 828A3140: 808303C0  lwz r4, 0x3c0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(960 as u32) ) } as u64;
	// 828A3144: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828A3148: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A314C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A314C size=12
    let mut pc: u32 = 0x828A314C;
    'dispatch: loop {
        match pc {
            0x828A314C => {
    //   block [0x828A314C..0x828A3158)
	// 828A314C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A3150: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828A3154: 4BF49114  b 0x827ec268
	sub_827EC268(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3158 size=4
    let mut pc: u32 = 0x828A3158;
    'dispatch: loop {
        match pc {
            0x828A3158 => {
    //   block [0x828A3158..0x828A315C)
	// 828A3158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828A3160 size=8
    let mut pc: u32 = 0x828A3160;
    'dispatch: loop {
        match pc {
            0x828A3160 => {
    //   block [0x828A3160..0x828A3168)
	// 828A3160: C02303BC  lfs f1, 0x3bc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(956 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A3164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3168 size=376
    let mut pc: u32 = 0x828A3168;
    'dispatch: loop {
        match pc {
            0x828A3168 => {
    //   block [0x828A3168..0x828A32E0)
	// 828A3168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A316C: 48905001  bl 0x831a816c
	ctx.lr = 0x828A3170;
	sub_831A8130(ctx, base);
	// 828A3170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3174: 814303BC  lwz r10, 0x3bc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(956 as u32) ) } as u64;
	// 828A3178: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A317C: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A3180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3184: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A3188: 38899A38  addi r4, r9, -0x65c8
	ctx.r[4].s64 = ctx.r[9].s64 + -26056;
	// 828A318C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3194: 1D4A03B4  mulli r10, r10, 0x3b4
	ctx.r[10].s64 = ctx.r[10].s64 * 948;
	// 828A3198: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A319C: 4855086D  bl 0x82df3a08
	ctx.lr = 0x828A31A0;
	sub_82DF3A08(ctx, base);
	// 828A31A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A31A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A31A8: 48550161  bl 0x82df3308
	ctx.lr = 0x828A31AC;
	sub_82DF3308(ctx, base);
	// 828A31AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A31B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A31B4: 48550275  bl 0x82df3428
	ctx.lr = 0x828A31B8;
	sub_82DF3428(ctx, base);
	// 828A31B8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A31BC: 40820118  bne 0x828a32d4
	if !ctx.cr[0].eq {
	pc = 0x828A32D4; continue 'dispatch;
	}
	// 828A31C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A31C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A31C8: 388B9A1C  addi r4, r11, -0x65e4
	ctx.r[4].s64 = ctx.r[11].s64 + -26084;
	// 828A31CC: 4855083D  bl 0x82df3a08
	ctx.lr = 0x828A31D0;
	sub_82DF3A08(ctx, base);
	// 828A31D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A31D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A31D8: 48550131  bl 0x82df3308
	ctx.lr = 0x828A31DC;
	sub_82DF3308(ctx, base);
	// 828A31DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A31E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A31E4: 48550245  bl 0x82df3428
	ctx.lr = 0x828A31E8;
	sub_82DF3428(ctx, base);
	// 828A31E8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A31EC: 4182000C  beq 0x828a31f8
	if ctx.cr[0].eq {
	pc = 0x828A31F8; continue 'dispatch;
	}
	// 828A31F0: 387E0248  addi r3, r30, 0x248
	ctx.r[3].s64 = ctx.r[30].s64 + 584;
	// 828A31F4: 480000E4  b 0x828a32d8
	pc = 0x828A32D8; continue 'dispatch;
	// 828A31F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A31FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3200: 388B99FC  addi r4, r11, -0x6604
	ctx.r[4].s64 = ctx.r[11].s64 + -26116;
	// 828A3204: 48550805  bl 0x82df3a08
	ctx.lr = 0x828A3208;
	sub_82DF3A08(ctx, base);
	// 828A3208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A320C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3210: 485500F9  bl 0x82df3308
	ctx.lr = 0x828A3214;
	sub_82DF3308(ctx, base);
	// 828A3214: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A321C: 4855020D  bl 0x82df3428
	ctx.lr = 0x828A3220;
	sub_82DF3428(ctx, base);
	// 828A3220: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3224: 4182000C  beq 0x828a3230
	if ctx.cr[0].eq {
	pc = 0x828A3230; continue 'dispatch;
	}
	// 828A3228: 387E0258  addi r3, r30, 0x258
	ctx.r[3].s64 = ctx.r[30].s64 + 600;
	// 828A322C: 480000AC  b 0x828a32d8
	pc = 0x828A32D8; continue 'dispatch;
	// 828A3230: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3238: 388B99D8  addi r4, r11, -0x6628
	ctx.r[4].s64 = ctx.r[11].s64 + -26152;
	// 828A323C: 485507CD  bl 0x82df3a08
	ctx.lr = 0x828A3240;
	sub_82DF3A08(ctx, base);
	// 828A3240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A3244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3248: 485500C1  bl 0x82df3308
	ctx.lr = 0x828A324C;
	sub_82DF3308(ctx, base);
	// 828A324C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3254: 485501D5  bl 0x82df3428
	ctx.lr = 0x828A3258;
	sub_82DF3428(ctx, base);
	// 828A3258: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A325C: 4182000C  beq 0x828a3268
	if ctx.cr[0].eq {
	pc = 0x828A3268; continue 'dispatch;
	}
	// 828A3260: 387E0268  addi r3, r30, 0x268
	ctx.r[3].s64 = ctx.r[30].s64 + 616;
	// 828A3264: 48000074  b 0x828a32d8
	pc = 0x828A32D8; continue 'dispatch;
	// 828A3268: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A326C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3270: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 828A3274: 48550795  bl 0x82df3a08
	ctx.lr = 0x828A3278;
	sub_82DF3A08(ctx, base);
	// 828A3278: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A327C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3280: 48550089  bl 0x82df3308
	ctx.lr = 0x828A3284;
	sub_82DF3308(ctx, base);
	// 828A3284: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A3288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A328C: 4855019D  bl 0x82df3428
	ctx.lr = 0x828A3290;
	sub_82DF3428(ctx, base);
	// 828A3290: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3294: 4182000C  beq 0x828a32a0
	if ctx.cr[0].eq {
	pc = 0x828A32A0; continue 'dispatch;
	}
	// 828A3298: 387E0278  addi r3, r30, 0x278
	ctx.r[3].s64 = ctx.r[30].s64 + 632;
	// 828A329C: 4800003C  b 0x828a32d8
	pc = 0x828A32D8; continue 'dispatch;
	// 828A32A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A32A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A32A8: 388B99C4  addi r4, r11, -0x663c
	ctx.r[4].s64 = ctx.r[11].s64 + -26172;
	// 828A32AC: 4855075D  bl 0x82df3a08
	ctx.lr = 0x828A32B0;
	sub_82DF3A08(ctx, base);
	// 828A32B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A32B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A32B8: 48550051  bl 0x82df3308
	ctx.lr = 0x828A32BC;
	sub_82DF3308(ctx, base);
	// 828A32BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A32C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A32C4: 48550165  bl 0x82df3428
	ctx.lr = 0x828A32C8;
	sub_82DF3428(ctx, base);
	// 828A32C8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A32CC: 387E0288  addi r3, r30, 0x288
	ctx.r[3].s64 = ctx.r[30].s64 + 648;
	// 828A32D0: 40820008  bne 0x828a32d8
	if !ctx.cr[0].eq {
	pc = 0x828A32D8; continue 'dispatch;
	}
	// 828A32D4: 387E0238  addi r3, r30, 0x238
	ctx.r[3].s64 = ctx.r[30].s64 + 568;
	// 828A32D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A32DC: 48904EE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A32E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A32E0 size=32
    let mut pc: u32 = 0x828A32E0;
    'dispatch: loop {
        match pc {
            0x828A32E0 => {
    //   block [0x828A32E0..0x828A3300)
	// 828A32E0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A32E4: 812303BC  lwz r9, 0x3bc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(956 as u32) ) } as u64;
	// 828A32E8: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A32EC: 394B0398  addi r10, r11, 0x398
	ctx.r[10].s64 = ctx.r[11].s64 + 920;
	// 828A32F0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A32F4: 1D6B03B4  mulli r11, r11, 0x3b4
	ctx.r[11].s64 = ctx.r[11].s64 * 948;
	// 828A32F8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A32FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3300 size=32
    let mut pc: u32 = 0x828A3300;
    'dispatch: loop {
        match pc {
            0x828A3300 => {
    //   block [0x828A3300..0x828A3320)
	// 828A3300: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A3304: 812303BC  lwz r9, 0x3bc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(956 as u32) ) } as u64;
	// 828A3308: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A330C: 394B03A4  addi r10, r11, 0x3a4
	ctx.r[10].s64 = ctx.r[11].s64 + 932;
	// 828A3310: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3314: 1D6B03B4  mulli r11, r11, 0x3b4
	ctx.r[11].s64 = ctx.r[11].s64 * 948;
	// 828A3318: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A331C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3320 size=136
    let mut pc: u32 = 0x828A3320;
    'dispatch: loop {
        match pc {
            0x828A3320 => {
    //   block [0x828A3320..0x828A33A8)
	// 828A3320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A332C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A333C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828A3340: 409A0020  bne cr6, 0x828a3360
	if !ctx.cr[6].eq {
	pc = 0x828A3360; continue 'dispatch;
	}
	// 828A3344: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3348: 419A0048  beq cr6, 0x828a3390
	if ctx.cr[6].eq {
	pc = 0x828A3390; continue 'dispatch;
	}
	// 828A334C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828A3350: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828A3354: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828A3358: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828A335C: 48000034  b 0x828a3390
	pc = 0x828A3390; continue 'dispatch;
	// 828A3360: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828A3364: 419A002C  beq cr6, 0x828a3390
	if ctx.cr[6].eq {
	pc = 0x828A3390; continue 'dispatch;
	}
	// 828A3368: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A336C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3370: 388B0818  addi r4, r11, 0x818
	ctx.r[4].s64 = ctx.r[11].s64 + 2072;
	// 828A3374: 48904D85  bl 0x831a80f8
	ctx.lr = 0x828A3378;
	sub_831A80F8(ctx, base);
	// 828A3378: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A337C: 4182000C  beq 0x828a3388
	if ctx.cr[0].eq {
	pc = 0x828A3388; continue 'dispatch;
	}
	// 828A3380: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828A3384: 4800000C  b 0x828a3390
	pc = 0x828A3390; continue 'dispatch;
	// 828A3388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A338C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A339C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A33A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A33A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A33A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A33A8 size=136
    let mut pc: u32 = 0x828A33A8;
    'dispatch: loop {
        match pc {
            0x828A33A8 => {
    //   block [0x828A33A8..0x828A3430)
	// 828A33A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A33AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A33B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A33B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A33B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A33BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A33C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A33C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828A33C8: 409A0020  bne cr6, 0x828a33e8
	if !ctx.cr[6].eq {
	pc = 0x828A33E8; continue 'dispatch;
	}
	// 828A33CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A33D0: 419A0048  beq cr6, 0x828a3418
	if ctx.cr[6].eq {
	pc = 0x828A3418; continue 'dispatch;
	}
	// 828A33D4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828A33D8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828A33DC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828A33E0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828A33E4: 48000034  b 0x828a3418
	pc = 0x828A3418; continue 'dispatch;
	// 828A33E8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828A33EC: 419A002C  beq cr6, 0x828a3418
	if ctx.cr[6].eq {
	pc = 0x828A3418; continue 'dispatch;
	}
	// 828A33F0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A33F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A33F8: 388B08B8  addi r4, r11, 0x8b8
	ctx.r[4].s64 = ctx.r[11].s64 + 2232;
	// 828A33FC: 48904CFD  bl 0x831a80f8
	ctx.lr = 0x828A3400;
	sub_831A80F8(ctx, base);
	// 828A3400: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A3404: 4182000C  beq 0x828a3410
	if ctx.cr[0].eq {
	pc = 0x828A3410; continue 'dispatch;
	}
	// 828A3408: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828A340C: 4800000C  b 0x828a3418
	pc = 0x828A3418; continue 'dispatch;
	// 828A3410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3414: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3418: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A341C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3424: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A342C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3430 size=136
    let mut pc: u32 = 0x828A3430;
    'dispatch: loop {
        match pc {
            0x828A3430 => {
    //   block [0x828A3430..0x828A34B8)
	// 828A3430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A343C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3448: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A344C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828A3450: 409A0020  bne cr6, 0x828a3470
	if !ctx.cr[6].eq {
	pc = 0x828A3470; continue 'dispatch;
	}
	// 828A3454: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3458: 419A0048  beq cr6, 0x828a34a0
	if ctx.cr[6].eq {
	pc = 0x828A34A0; continue 'dispatch;
	}
	// 828A345C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828A3460: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828A3464: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828A3468: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828A346C: 48000034  b 0x828a34a0
	pc = 0x828A34A0; continue 'dispatch;
	// 828A3470: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828A3474: 419A002C  beq cr6, 0x828a34a0
	if ctx.cr[6].eq {
	pc = 0x828A34A0; continue 'dispatch;
	}
	// 828A3478: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A347C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3480: 388B0960  addi r4, r11, 0x960
	ctx.r[4].s64 = ctx.r[11].s64 + 2400;
	// 828A3484: 48904C75  bl 0x831a80f8
	ctx.lr = 0x828A3488;
	sub_831A80F8(ctx, base);
	// 828A3488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A348C: 4182000C  beq 0x828a3498
	if ctx.cr[0].eq {
	pc = 0x828A3498; continue 'dispatch;
	}
	// 828A3490: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828A3494: 4800000C  b 0x828a34a0
	pc = 0x828A34A0; continue 'dispatch;
	// 828A3498: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A349C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A34A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A34A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A34A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A34AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A34B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A34B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A34B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A34B8 size=88
    let mut pc: u32 = 0x828A34B8;
    'dispatch: loop {
        match pc {
            0x828A34B8 => {
    //   block [0x828A34B8..0x828A3510)
	// 828A34B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A34BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A34C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A34C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A34C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A34CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A34D0: 3BFE0304  addi r31, r30, 0x304
	ctx.r[31].s64 = ctx.r[30].s64 + 772;
	// 828A34D4: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828A34D8: 4854FF51  bl 0x82df3428
	ctx.lr = 0x828A34DC;
	sub_82DF3428(ctx, base);
	// 828A34DC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 828A34E0: 4854FF49  bl 0x82df3428
	ctx.lr = 0x828A34E4;
	sub_82DF3428(ctx, base);
	// 828A34E4: 3BFE02D4  addi r31, r30, 0x2d4
	ctx.r[31].s64 = ctx.r[30].s64 + 724;
	// 828A34E8: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 828A34EC: 4854FF3D  bl 0x82df3428
	ctx.lr = 0x828A34F0;
	sub_82DF3428(ctx, base);
	// 828A34F0: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828A34F4: 4854FF35  bl 0x82df3428
	ctx.lr = 0x828A34F8;
	sub_82DF3428(ctx, base);
	// 828A34F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A34FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3504: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A350C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3510 size=8
    let mut pc: u32 = 0x828A3510;
    'dispatch: loop {
        match pc {
            0x828A3510 => {
    //   block [0x828A3510..0x828A3518)
	// 828A3510: 8063038C  lwz r3, 0x38c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(908 as u32) ) } as u64;
	// 828A3514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A3518 size=32
    let mut pc: u32 = 0x828A3518;
    'dispatch: loop {
        match pc {
            0x828A3518 => {
    //   block [0x828A3518..0x828A3538)
	// 828A3518: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A351C: 812303BC  lwz r9, 0x3bc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(956 as u32) ) } as u64;
	// 828A3520: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A3524: 394B0320  addi r10, r11, 0x320
	ctx.r[10].s64 = ctx.r[11].s64 + 800;
	// 828A3528: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A352C: 1D6B03B4  mulli r11, r11, 0x3b4
	ctx.r[11].s64 = ctx.r[11].s64 * 948;
	// 828A3530: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828A3534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A3538 size=184
    let mut pc: u32 = 0x828A3538;
    'dispatch: loop {
        match pc {
            0x828A3538 => {
    //   block [0x828A3538..0x828A35F0)
	// 828A3538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A353C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3548: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A354C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A3550: 817F03C4  lwz r11, 0x3c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828A3554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3558: 419A0044  beq cr6, 0x828a359c
	if ctx.cr[6].eq {
	pc = 0x828A359C; continue 'dispatch;
	}
	// 828A355C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828A3560: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3564: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A3568: 4BC6BF61  bl 0x8250f4c8
	ctx.lr = 0x828A356C;
	sub_8250F4C8(ctx, base);
	// 828A356C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3574: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828A3578: 409A0008  bne cr6, 0x828a3580
	if !ctx.cr[6].eq {
	pc = 0x828A3580; continue 'dispatch;
	}
	// 828A357C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A3580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3584: 80BF03C4  lwz r5, 0x3c4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(964 as u32) ) } as u64;
	// 828A3588: 4BF48D09  bl 0x827ec290
	ctx.lr = 0x828A358C;
	sub_827EC290(ctx, base);
	// 828A358C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A3590: 4854E701  bl 0x82df1c90
	ctx.lr = 0x828A3594;
	sub_82DF1C90(ctx, base);
	// 828A3594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3598: 917F03C4  stw r11, 0x3c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[11].u32 ) };
	// 828A359C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A35A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A35A4: 388B9C70  addi r4, r11, -0x6390
	ctx.r[4].s64 = ctx.r[11].s64 + -25488;
	// 828A35A8: 48550461  bl 0x82df3a08
	ctx.lr = 0x828A35AC;
	sub_82DF3A08(ctx, base);
	// 828A35AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A35B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828A35B4: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828A35B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A35BC: 389F03B4  addi r4, r31, 0x3b4
	ctx.r[4].s64 = ctx.r[31].s64 + 948;
	// 828A35C0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828A35C4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A35C8: 4BF48C41  bl 0x827ec208
	ctx.lr = 0x828A35CC;
	sub_827EC208(ctx, base);
	// 828A35CC: 907F03C4  stw r3, 0x3c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[3].u32 ) };
	// 828A35D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A35D4: 4854FE55  bl 0x82df3428
	ctx.lr = 0x828A35D8;
	sub_82DF3428(ctx, base);
	// 828A35D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A35DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A35E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A35E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A35E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A35EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A35F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A35F0 size=196
    let mut pc: u32 = 0x828A35F0;
    'dispatch: loop {
        match pc {
            0x828A35F0 => {
    //   block [0x828A35F0..0x828A36B4)
	// 828A35F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A35F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A35F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A35FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3604: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A360C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3610: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3614: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3618: 4BA1D321  bl 0x822c0938
	ctx.lr = 0x828A361C;
	sub_822C0938(ctx, base);
	// 828A361C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3620: 41820028  beq 0x828a3648
	if ctx.cr[0].eq {
	pc = 0x828A3648; continue 'dispatch;
	}
	// 828A3624: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3628: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A362C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3630: 392B9A58  addi r9, r11, -0x65a8
	ctx.r[9].s64 = ctx.r[11].s64 + -26024;
	// 828A3634: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3638: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A363C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3640: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3644: 48000008  b 0x828a364c
	pc = 0x828A364C; continue 'dispatch;
	// 828A3648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A364C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3654: 409A0044  bne cr6, 0x828a3698
	if !ctx.cr[6].eq {
	pc = 0x828A3698; continue 'dispatch;
	}
	// 828A3658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A365C: 419A001C  beq cr6, 0x828a3678
	if ctx.cr[6].eq {
	pc = 0x828A3678; continue 'dispatch;
	}
	// 828A3660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A366C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3674: 4E800421  bctrl
	ctx.lr = 0x828A3678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3678: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A367C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3684: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3688: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A368C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3690: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3694: 4BA1C96D  bl 0x822c0000
	ctx.lr = 0x828A3698;
	sub_822C0000(ctx, base);
	// 828A3698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A369C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A36A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A36A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A36A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A36AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A36B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A36B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A36B8 size=196
    let mut pc: u32 = 0x828A36B8;
    'dispatch: loop {
        match pc {
            0x828A36B8 => {
    //   block [0x828A36B8..0x828A377C)
	// 828A36B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A36BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A36C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A36C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A36C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A36CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A36D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A36D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A36D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A36DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A36E0: 4BA1D259  bl 0x822c0938
	ctx.lr = 0x828A36E4;
	sub_822C0938(ctx, base);
	// 828A36E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A36E8: 41820028  beq 0x828a3710
	if ctx.cr[0].eq {
	pc = 0x828A3710; continue 'dispatch;
	}
	// 828A36EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A36F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A36F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A36F8: 392B9A6C  addi r9, r11, -0x6594
	ctx.r[9].s64 = ctx.r[11].s64 + -26004;
	// 828A36FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3700: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3704: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3708: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A370C: 48000008  b 0x828a3714
	pc = 0x828A3714; continue 'dispatch;
	// 828A3710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3714: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A371C: 409A0044  bne cr6, 0x828a3760
	if !ctx.cr[6].eq {
	pc = 0x828A3760; continue 'dispatch;
	}
	// 828A3720: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3724: 419A001C  beq cr6, 0x828a3740
	if ctx.cr[6].eq {
	pc = 0x828A3740; continue 'dispatch;
	}
	// 828A3728: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A372C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3734: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A373C: 4E800421  bctrl
	ctx.lr = 0x828A3740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3740: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A374C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3750: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3754: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3758: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A375C: 4BA1C8A5  bl 0x822c0000
	ctx.lr = 0x828A3760;
	sub_822C0000(ctx, base);
	// 828A3760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3764: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3768: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A376C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3770: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3780 size=196
    let mut pc: u32 = 0x828A3780;
    'dispatch: loop {
        match pc {
            0x828A3780 => {
    //   block [0x828A3780..0x828A3844)
	// 828A3780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A378C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A379C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A37A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A37A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A37A8: 4BA1D191  bl 0x822c0938
	ctx.lr = 0x828A37AC;
	sub_822C0938(ctx, base);
	// 828A37AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A37B0: 41820028  beq 0x828a37d8
	if ctx.cr[0].eq {
	pc = 0x828A37D8; continue 'dispatch;
	}
	// 828A37B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A37B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A37BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A37C0: 392B9AA8  addi r9, r11, -0x6558
	ctx.r[9].s64 = ctx.r[11].s64 + -25944;
	// 828A37C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A37C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A37CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A37D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A37D4: 48000008  b 0x828a37dc
	pc = 0x828A37DC; continue 'dispatch;
	// 828A37D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A37DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A37E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A37E4: 409A0044  bne cr6, 0x828a3828
	if !ctx.cr[6].eq {
	pc = 0x828A3828; continue 'dispatch;
	}
	// 828A37E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A37EC: 419A001C  beq cr6, 0x828a3808
	if ctx.cr[6].eq {
	pc = 0x828A3808; continue 'dispatch;
	}
	// 828A37F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A37F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A37F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A37FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3804: 4E800421  bctrl
	ctx.lr = 0x828A3808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3808: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A380C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3814: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3818: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A381C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3820: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3824: 4BA1C7DD  bl 0x822c0000
	ctx.lr = 0x828A3828;
	sub_822C0000(ctx, base);
	// 828A3828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A382C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3838: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A383C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3848 size=196
    let mut pc: u32 = 0x828A3848;
    'dispatch: loop {
        match pc {
            0x828A3848 => {
    //   block [0x828A3848..0x828A390C)
	// 828A3848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A384C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A385C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3860: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3864: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A386C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3870: 4BA1D0C9  bl 0x822c0938
	ctx.lr = 0x828A3874;
	sub_822C0938(ctx, base);
	// 828A3874: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3878: 41820028  beq 0x828a38a0
	if ctx.cr[0].eq {
	pc = 0x828A38A0; continue 'dispatch;
	}
	// 828A387C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3880: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3884: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3888: 392B9ABC  addi r9, r11, -0x6544
	ctx.r[9].s64 = ctx.r[11].s64 + -25924;
	// 828A388C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3890: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3894: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3898: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A389C: 48000008  b 0x828a38a4
	pc = 0x828A38A4; continue 'dispatch;
	// 828A38A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A38A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A38A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A38AC: 409A0044  bne cr6, 0x828a38f0
	if !ctx.cr[6].eq {
	pc = 0x828A38F0; continue 'dispatch;
	}
	// 828A38B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A38B4: 419A001C  beq cr6, 0x828a38d0
	if ctx.cr[6].eq {
	pc = 0x828A38D0; continue 'dispatch;
	}
	// 828A38B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A38BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A38C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A38C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A38C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A38CC: 4E800421  bctrl
	ctx.lr = 0x828A38D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A38D0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A38D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A38D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A38DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A38E0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A38E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A38E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A38EC: 4BA1C715  bl 0x822c0000
	ctx.lr = 0x828A38F0;
	sub_822C0000(ctx, base);
	// 828A38F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A38F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A38F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A38FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3910 size=196
    let mut pc: u32 = 0x828A3910;
    'dispatch: loop {
        match pc {
            0x828A3910 => {
    //   block [0x828A3910..0x828A39D4)
	// 828A3910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A391C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A392C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3930: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3934: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3938: 4BA1D001  bl 0x822c0938
	ctx.lr = 0x828A393C;
	sub_822C0938(ctx, base);
	// 828A393C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3940: 41820028  beq 0x828a3968
	if ctx.cr[0].eq {
	pc = 0x828A3968; continue 'dispatch;
	}
	// 828A3944: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3948: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A394C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3950: 392B9AD0  addi r9, r11, -0x6530
	ctx.r[9].s64 = ctx.r[11].s64 + -25904;
	// 828A3954: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3958: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A395C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3960: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3964: 48000008  b 0x828a396c
	pc = 0x828A396C; continue 'dispatch;
	// 828A3968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A396C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3974: 409A0044  bne cr6, 0x828a39b8
	if !ctx.cr[6].eq {
	pc = 0x828A39B8; continue 'dispatch;
	}
	// 828A3978: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A397C: 419A001C  beq cr6, 0x828a3998
	if ctx.cr[6].eq {
	pc = 0x828A3998; continue 'dispatch;
	}
	// 828A3980: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3984: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A398C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3994: 4E800421  bctrl
	ctx.lr = 0x828A3998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3998: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A399C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A39A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A39A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A39A8: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A39AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A39B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A39B4: 4BA1C64D  bl 0x822c0000
	ctx.lr = 0x828A39B8;
	sub_822C0000(ctx, base);
	// 828A39B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A39BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A39C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A39C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A39C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A39CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A39D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A39D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A39D8 size=196
    let mut pc: u32 = 0x828A39D8;
    'dispatch: loop {
        match pc {
            0x828A39D8 => {
    //   block [0x828A39D8..0x828A3A9C)
	// 828A39D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A39DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A39E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A39E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A39E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A39EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A39F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A39F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A39F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A39FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3A00: 4BA1CF39  bl 0x822c0938
	ctx.lr = 0x828A3A04;
	sub_822C0938(ctx, base);
	// 828A3A04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3A08: 41820028  beq 0x828a3a30
	if ctx.cr[0].eq {
	pc = 0x828A3A30; continue 'dispatch;
	}
	// 828A3A0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3A10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3A14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3A18: 392B9AE4  addi r9, r11, -0x651c
	ctx.r[9].s64 = ctx.r[11].s64 + -25884;
	// 828A3A1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3A20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3A24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3A28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3A2C: 48000008  b 0x828a3a34
	pc = 0x828A3A34; continue 'dispatch;
	// 828A3A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3A34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3A3C: 409A0044  bne cr6, 0x828a3a80
	if !ctx.cr[6].eq {
	pc = 0x828A3A80; continue 'dispatch;
	}
	// 828A3A40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3A44: 419A001C  beq cr6, 0x828a3a60
	if ctx.cr[6].eq {
	pc = 0x828A3A60; continue 'dispatch;
	}
	// 828A3A48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3A4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3A54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3A5C: 4E800421  bctrl
	ctx.lr = 0x828A3A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3A60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3A6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3A70: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3A74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3A78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3A7C: 4BA1C585  bl 0x822c0000
	ctx.lr = 0x828A3A80;
	sub_822C0000(ctx, base);
	// 828A3A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3A90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3AA0 size=196
    let mut pc: u32 = 0x828A3AA0;
    'dispatch: loop {
        match pc {
            0x828A3AA0 => {
    //   block [0x828A3AA0..0x828A3B64)
	// 828A3AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3ABC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3AC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3AC8: 4BA1CE71  bl 0x822c0938
	ctx.lr = 0x828A3ACC;
	sub_822C0938(ctx, base);
	// 828A3ACC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3AD0: 41820028  beq 0x828a3af8
	if ctx.cr[0].eq {
	pc = 0x828A3AF8; continue 'dispatch;
	}
	// 828A3AD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3AD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3AE0: 392B9AF8  addi r9, r11, -0x6508
	ctx.r[9].s64 = ctx.r[11].s64 + -25864;
	// 828A3AE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3AE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3AEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3AF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3AF4: 48000008  b 0x828a3afc
	pc = 0x828A3AFC; continue 'dispatch;
	// 828A3AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3AFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3B04: 409A0044  bne cr6, 0x828a3b48
	if !ctx.cr[6].eq {
	pc = 0x828A3B48; continue 'dispatch;
	}
	// 828A3B08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3B0C: 419A001C  beq cr6, 0x828a3b28
	if ctx.cr[6].eq {
	pc = 0x828A3B28; continue 'dispatch;
	}
	// 828A3B10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3B14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3B1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3B24: 4E800421  bctrl
	ctx.lr = 0x828A3B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3B28: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3B2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3B34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3B38: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3B3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3B40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3B44: 4BA1C4BD  bl 0x822c0000
	ctx.lr = 0x828A3B48;
	sub_822C0000(ctx, base);
	// 828A3B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3B68 size=196
    let mut pc: u32 = 0x828A3B68;
    'dispatch: loop {
        match pc {
            0x828A3B68 => {
    //   block [0x828A3B68..0x828A3C2C)
	// 828A3B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3B7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3B84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3B88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3B8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3B90: 4BA1CDA9  bl 0x822c0938
	ctx.lr = 0x828A3B94;
	sub_822C0938(ctx, base);
	// 828A3B94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3B98: 41820028  beq 0x828a3bc0
	if ctx.cr[0].eq {
	pc = 0x828A3BC0; continue 'dispatch;
	}
	// 828A3B9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3BA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3BA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3BA8: 392B9B0C  addi r9, r11, -0x64f4
	ctx.r[9].s64 = ctx.r[11].s64 + -25844;
	// 828A3BAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3BB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3BB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3BB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3BBC: 48000008  b 0x828a3bc4
	pc = 0x828A3BC4; continue 'dispatch;
	// 828A3BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3BC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3BCC: 409A0044  bne cr6, 0x828a3c10
	if !ctx.cr[6].eq {
	pc = 0x828A3C10; continue 'dispatch;
	}
	// 828A3BD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3BD4: 419A001C  beq cr6, 0x828a3bf0
	if ctx.cr[6].eq {
	pc = 0x828A3BF0; continue 'dispatch;
	}
	// 828A3BD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3BDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3BE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3BE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3BEC: 4E800421  bctrl
	ctx.lr = 0x828A3BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3BF0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3BF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3BF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3BFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3C00: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3C04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3C08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3C0C: 4BA1C3F5  bl 0x822c0000
	ctx.lr = 0x828A3C10;
	sub_822C0000(ctx, base);
	// 828A3C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3C20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3C24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


