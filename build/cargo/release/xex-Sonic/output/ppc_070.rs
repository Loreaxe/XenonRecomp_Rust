pub fn sub_826E2F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E2F30 size=12
    let mut pc: u32 = 0x826E2F30;
    'dispatch: loop {
        match pc {
            0x826E2F30 => {
    //   block [0x826E2F30..0x826E2F3C)
	// 826E2F30: 80630114  lwz r3, 0x114(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 826E2F34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E2F38: 4BFA6930  b 0x82689868
	sub_82689868(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E2F3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E2F3C size=4
    let mut pc: u32 = 0x826E2F3C;
    'dispatch: loop {
        match pc {
            0x826E2F3C => {
    //   block [0x826E2F3C..0x826E2F40)
	// 826E2F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E2F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E2F40 size=112
    let mut pc: u32 = 0x826E2F40;
    'dispatch: loop {
        match pc {
            0x826E2F40 => {
    //   block [0x826E2F40..0x826E2FB0)
	// 826E2F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E2F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E2F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E2F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E2F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E2F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E2F58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E2F5C: 4BFE7615  bl 0x826ca570
	ctx.lr = 0x826E2F60;
	sub_826CA570(ctx, base);
	// 826E2F60: 987E0018  stb r3, 0x18(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u8 ) };
	// 826E2F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E2F68: 4BE2EB81  bl 0x82511ae8
	ctx.lr = 0x826E2F6C;
	sub_82511AE8(ctx, base);
	// 826E2F6C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E2F70: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826E2F74: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E2F78: 392BDEAC  addi r9, r11, -0x2154
	ctx.r[9].s64 = ctx.r[11].s64 + -8532;
	// 826E2F7C: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E2FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E2FB0 size=108
    let mut pc: u32 = 0x826E2FB0;
    'dispatch: loop {
        match pc {
            0x826E2FB0 => {
    //   block [0x826E2FB0..0x826E301C)
	// 826E2FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E2FB4: 48AC51B9  bl 0x831a816c
	ctx.lr = 0x826E2FB8;
	sub_831A8130(ctx, base);
	// 826E2FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E2FBC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826E2FC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826E2FC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E2FC8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E2FCC: 41820038  beq 0x826e3004
	if ctx.cr[0].eq {
	pc = 0x826E3004; continue 'dispatch;
	}
	// 826E2FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E2FD4: 48AC69B5  bl 0x831a9988
	ctx.lr = 0x826E2FD8;
	sub_831A9988(ctx, base);
	// 826E2FD8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E2FDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E2FE0: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 826E2FE4: 48AC5115  bl 0x831a80f8
	ctx.lr = 0x826E2FE8;
	sub_831A80F8(ctx, base);
	// 826E2FE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E2FEC: 41820018  beq 0x826e3004
	if ctx.cr[0].eq {
	pc = 0x826E3004; continue 'dispatch;
	}
	// 826E2FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E2FF4: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 826E2FF8: 4BFFFF49  bl 0x826e2f40
	ctx.lr = 0x826E2FFC;
	sub_826E2F40(ctx, base);
	// 826E2FFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E3000: 48000014  b 0x826e3014
	pc = 0x826E3014; continue 'dispatch;
	// 826E3004: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E3008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E300C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E3010: 4BFE7CE9  bl 0x826cacf8
	ctx.lr = 0x826E3014;
	sub_826CACF8(ctx, base);
	// 826E3014: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E3018: 48AC51A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E3020 size=196
    let mut pc: u32 = 0x826E3020;
    'dispatch: loop {
        match pc {
            0x826E3020 => {
    //   block [0x826E3020..0x826E30E4)
	// 826E3020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E302C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E3030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E3038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E303C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E3040: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E3044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E3048: 4BBDD8F1  bl 0x822c0938
	ctx.lr = 0x826E304C;
	sub_822C0938(ctx, base);
	// 826E304C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E3050: 41820028  beq 0x826e3078
	if ctx.cr[0].eq {
	pc = 0x826E3078; continue 'dispatch;
	}
	// 826E3054: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3058: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E305C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E3060: 392BAAA8  addi r9, r11, -0x5558
	ctx.r[9].s64 = ctx.r[11].s64 + -21848;
	// 826E3064: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E3068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E306C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E3070: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E3074: 48000008  b 0x826e307c
	pc = 0x826E307C; continue 'dispatch;
	// 826E3078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E307C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E3080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E3084: 409A0044  bne cr6, 0x826e30c8
	if !ctx.cr[6].eq {
	pc = 0x826E30C8; continue 'dispatch;
	}
	// 826E3088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E308C: 419A001C  beq cr6, 0x826e30a8
	if ctx.cr[6].eq {
	pc = 0x826E30A8; continue 'dispatch;
	}
	// 826E3090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3094: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E3098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E309C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E30A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E30A4: 4E800421  bctrl
	ctx.lr = 0x826E30A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E30A8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E30AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E30B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E30B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E30B8: 816BDEB0  lwz r11, -0x2150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8528 as u32) ) } as u64;
	// 826E30BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E30C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E30C4: 4BBDCF3D  bl 0x822c0000
	ctx.lr = 0x826E30C8;
	sub_822C0000(ctx, base);
	// 826E30C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E30CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E30D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E30D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E30D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E30DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E30E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E30E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E30E8 size=132
    let mut pc: u32 = 0x826E30E8;
    'dispatch: loop {
        match pc {
            0x826E30E8 => {
    //   block [0x826E30E8..0x826E316C)
	// 826E30E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E30EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E30F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E30F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E30F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E30FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E3100: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826E3104: 4BFA6765  bl 0x82689868
	ctx.lr = 0x826E3108;
	sub_82689868(ctx, base);
	// 826E3108: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826E310C: 397F011C  addi r11, r31, 0x11c
	ctx.r[11].s64 = ctx.r[31].s64 + 284;
	// 826E3110: 915F011C  stw r10, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[10].u32 ) };
	// 826E3114: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 826E3118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E311C: 915F0120  stw r10, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 826E3120: 419A0008  beq cr6, 0x826e3128
	if ctx.cr[6].eq {
	pc = 0x826E3128; continue 'dispatch;
	}
	// 826E3124: 4BBDD76D  bl 0x822c0890
	ctx.lr = 0x826E3128;
	sub_822C0890(ctx, base);
	// 826E3128: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E312C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E3130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3134: 38AAAAB8  addi r5, r10, -0x5548
	ctx.r[5].s64 = ctx.r[10].s64 + -21832;
	// 826E3138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E313C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E3140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E3144: 4E800421  bctrl
	ctx.lr = 0x826E3148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E3148: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E314C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3150: 419A0008  beq cr6, 0x826e3158
	if ctx.cr[6].eq {
	pc = 0x826E3158; continue 'dispatch;
	}
	// 826E3154: 4BBDD73D  bl 0x822c0890
	ctx.lr = 0x826E3158;
	sub_822C0890(ctx, base);
	// 826E3158: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E315C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E3160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E3164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E3168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E3170 size=172
    let mut pc: u32 = 0x826E3170;
    'dispatch: loop {
        match pc {
            0x826E3170 => {
    //   block [0x826E3170..0x826E321C)
	// 826E3170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E317C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3184: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826E3188: 4BFA6771  bl 0x826898f8
	ctx.lr = 0x826E318C;
	sub_826898F8(ctx, base);
	// 826E318C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3194: 38ABAAEC  addi r5, r11, -0x5514
	ctx.r[5].s64 = ctx.r[11].s64 + -21780;
	// 826E3198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E319C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E31A0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E31A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E31A8: 4E800421  bctrl
	ctx.lr = 0x826E31AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E31AC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E31B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E31B4: 419A0008  beq cr6, 0x826e31bc
	if ctx.cr[6].eq {
	pc = 0x826E31BC; continue 'dispatch;
	}
	// 826E31B8: 4BBDD6D9  bl 0x822c0890
	ctx.lr = 0x826E31BC;
	sub_822C0890(ctx, base);
	// 826E31BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E31C0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E31C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E31C8: 38AAAAD4  addi r5, r10, -0x552c
	ctx.r[5].s64 = ctx.r[10].s64 + -21804;
	// 826E31CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E31D0: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826E31D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E31D8: 4E800421  bctrl
	ctx.lr = 0x826E31DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E31DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E31E0: 395F011C  addi r10, r31, 0x11c
	ctx.r[10].s64 = ctx.r[31].s64 + 284;
	// 826E31E4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E31E8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826E31EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E31F0: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 826E31F4: 4BBE126D  bl 0x822c4460
	ctx.lr = 0x826E31F8;
	sub_822C4460(ctx, base);
	// 826E31F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E31FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3200: 419A0008  beq cr6, 0x826e3208
	if ctx.cr[6].eq {
	pc = 0x826E3208; continue 'dispatch;
	}
	// 826E3204: 4BBDD68D  bl 0x822c0890
	ctx.lr = 0x826E3208;
	sub_822C0890(ctx, base);
	// 826E3208: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E320C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E3210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E3214: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E3218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E3220 size=328
    let mut pc: u32 = 0x826E3220;
    'dispatch: loop {
        match pc {
            0x826E3220 => {
    //   block [0x826E3220..0x826E3368)
	// 826E3220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E322C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E3230: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826E3234: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826E3238: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826E323C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E3248: 419A00FC  beq cr6, 0x826e3344
	if ctx.cr[6].eq {
	pc = 0x826E3344; continue 'dispatch;
	}
	// 826E324C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E3250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3254: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826E3258: 487107B1  bl 0x82df3a08
	ctx.lr = 0x826E325C;
	sub_82DF3A08(ctx, base);
	// 826E325C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E3260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E3264: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826E3268: 487107A1  bl 0x82df3a08
	ctx.lr = 0x826E326C;
	sub_82DF3A08(ctx, base);
	// 826E326C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E3270: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E3274: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826E3278: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826E327C: 3BCBDEAC  addi r30, r11, -0x2154
	ctx.r[30].s64 = ctx.r[11].s64 + -8532;
	// 826E3280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E3284: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E3288: 38BEFFFC  addi r5, r30, -4
	ctx.r[5].s64 = ctx.r[30].s64 + -4;
	// 826E328C: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E3290: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E3294: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826E3298: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E329C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E32A0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E32A4: 4BEC0005  bl 0x825a32a8
	ctx.lr = 0x826E32A8;
	sub_825A32A8(ctx, base);
	// 826E32A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E32AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E32B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E32B4: 4BEBE4BD  bl 0x825a1770
	ctx.lr = 0x826E32B8;
	sub_825A1770(ctx, base);
	// 826E32B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E32BC: 4871016D  bl 0x82df3428
	ctx.lr = 0x826E32C0;
	sub_82DF3428(ctx, base);
	// 826E32C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E32C4: 4BBE59F5  bl 0x822c8cb8
	ctx.lr = 0x826E32C8;
	sub_822C8CB8(ctx, base);
	// 826E32C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E32CC: 4871015D  bl 0x82df3428
	ctx.lr = 0x826E32D0;
	sub_82DF3428(ctx, base);
	// 826E32D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E32D4: 48710155  bl 0x82df3428
	ctx.lr = 0x826E32D8;
	sub_82DF3428(ctx, base);
	// 826E32D8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E32DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E32E0: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 826E32E4: 48710725  bl 0x82df3a08
	ctx.lr = 0x826E32E8;
	sub_82DF3A08(ctx, base);
	// 826E32E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E32EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E32F0: 388BAB0C  addi r4, r11, -0x54f4
	ctx.r[4].s64 = ctx.r[11].s64 + -21748;
	// 826E32F4: 48710715  bl 0x82df3a08
	ctx.lr = 0x826E32F8;
	sub_82DF3A08(ctx, base);
	// 826E32F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E32FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E3300: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E3304: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826E3308: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E330C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E3310: 4BEBFF99  bl 0x825a32a8
	ctx.lr = 0x826E3314;
	sub_825A32A8(ctx, base);
	// 826E3314: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E3318: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E331C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E3320: 4BEBE451  bl 0x825a1770
	ctx.lr = 0x826E3324;
	sub_825A1770(ctx, base);
	// 826E3324: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826E3328: 48710101  bl 0x82df3428
	ctx.lr = 0x826E332C;
	sub_82DF3428(ctx, base);
	// 826E332C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E3330: 4BBE5989  bl 0x822c8cb8
	ctx.lr = 0x826E3334;
	sub_822C8CB8(ctx, base);
	// 826E3334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3338: 487100F1  bl 0x82df3428
	ctx.lr = 0x826E333C;
	sub_82DF3428(ctx, base);
	// 826E333C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E3340: 487100E9  bl 0x82df3428
	ctx.lr = 0x826E3344;
	sub_82DF3428(ctx, base);
	// 826E3344: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826E3348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E334C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E3350: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826E3354: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826E3358: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826E335C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E3360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E3364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E3368 size=148
    let mut pc: u32 = 0x826E3368;
    'dispatch: loop {
        match pc {
            0x826E3368 => {
    //   block [0x826E3368..0x826E33FC)
	// 826E3368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E336C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3370: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E3374: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E337C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3380: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E3384: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E3388: 396BAB94  addi r11, r11, -0x546c
	ctx.r[11].s64 = ctx.r[11].s64 + -21612;
	// 826E338C: 394AAB80  addi r10, r10, -0x5480
	ctx.r[10].s64 = ctx.r[10].s64 + -21632;
	// 826E3390: 3929AB34  addi r9, r9, -0x54cc
	ctx.r[9].s64 = ctx.r[9].s64 + -21708;
	// 826E3394: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E3398: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E339C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E33A0: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 826E33A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E33A8: 419A0008  beq cr6, 0x826e33b0
	if ctx.cr[6].eq {
	pc = 0x826E33B0; continue 'dispatch;
	}
	// 826E33AC: 4BBDD4E5  bl 0x822c0890
	ctx.lr = 0x826E33B0;
	sub_822C0890(ctx, base);
	// 826E33B0: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826E33B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E33B8: 419A0008  beq cr6, 0x826e33c0
	if ctx.cr[6].eq {
	pc = 0x826E33C0; continue 'dispatch;
	}
	// 826E33BC: 4BBDD4D5  bl 0x822c0890
	ctx.lr = 0x826E33C0;
	sub_822C0890(ctx, base);
	// 826E33C0: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826E33C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E33C8: 419A0008  beq cr6, 0x826e33d0
	if ctx.cr[6].eq {
	pc = 0x826E33D0; continue 'dispatch;
	}
	// 826E33CC: 4BBDD4C5  bl 0x822c0890
	ctx.lr = 0x826E33D0;
	sub_822C0890(ctx, base);
	// 826E33D0: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826E33D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E33D8: 419A0008  beq cr6, 0x826e33e0
	if ctx.cr[6].eq {
	pc = 0x826E33E0; continue 'dispatch;
	}
	// 826E33DC: 4BBDD4B5  bl 0x822c0890
	ctx.lr = 0x826E33E0;
	sub_822C0890(ctx, base);
	// 826E33E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E33E4: 4BF36A1D  bl 0x82619e00
	ctx.lr = 0x826E33E8;
	sub_82619E00(ctx, base);
	// 826E33E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E33EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E33F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E33F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E33F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3400 size=8
    let mut pc: u32 = 0x826E3400;
    'dispatch: loop {
        match pc {
            0x826E3400 => {
    //   block [0x826E3400..0x826E3408)
	// 826E3400: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E3404: 48000094  b 0x826e3498
	sub_826E3498(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3408 size=8
    let mut pc: u32 = 0x826E3408;
    'dispatch: loop {
        match pc {
            0x826E3408 => {
    //   block [0x826E3408..0x826E3410)
	// 826E3408: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E340C: 4800008C  b 0x826e3498
	sub_826E3498(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E3410 size=136
    let mut pc: u32 = 0x826E3410;
    'dispatch: loop {
        match pc {
            0x826E3410 => {
    //   block [0x826E3410..0x826E3498)
	// 826E3410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E341C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E3420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3428: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E342C: 4BFE7225  bl 0x826ca650
	ctx.lr = 0x826E3430;
	sub_826CA650(ctx, base);
	// 826E3430: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3434: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 826E3438: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E343C: 396BAB94  addi r11, r11, -0x546c
	ctx.r[11].s64 = ctx.r[11].s64 + -21612;
	// 826E3440: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E3444: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E3448: 394AAB80  addi r10, r10, -0x5480
	ctx.r[10].s64 = ctx.r[10].s64 + -21632;
	// 826E344C: 3929AB34  addi r9, r9, -0x54cc
	ctx.r[9].s64 = ctx.r[9].s64 + -21708;
	// 826E3450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E3454: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E3458: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E345C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E3460: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826E3464: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826E3468: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826E346C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826E3470: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826E3474: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826E3478: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 826E347C: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826E3480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E3484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E3488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E348C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E3490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E3494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E3498 size=76
    let mut pc: u32 = 0x826E3498;
    'dispatch: loop {
        match pc {
            0x826E3498 => {
    //   block [0x826E3498..0x826E34E4)
	// 826E3498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E349C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E34A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E34A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E34A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E34AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E34B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E34B4: 4BFFFEB5  bl 0x826e3368
	ctx.lr = 0x826E34B8;
	sub_826E3368(ctx, base);
	// 826E34B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E34BC: 4182000C  beq 0x826e34c8
	if ctx.cr[0].eq {
	pc = 0x826E34C8; continue 'dispatch;
	}
	// 826E34C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E34C4: 4870EF15  bl 0x82df23d8
	ctx.lr = 0x826E34C8;
	sub_82DF23D8(ctx, base);
	// 826E34C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E34CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E34D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E34D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E34D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E34DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E34E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E34E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E34E8 size=428
    let mut pc: u32 = 0x826E34E8;
    'dispatch: loop {
        match pc {
            0x826E34E8 => {
    //   block [0x826E34E8..0x826E3694)
	// 826E34E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E34EC: 48AC4C79  bl 0x831a8164
	ctx.lr = 0x826E34F0;
	sub_831A8130(ctx, base);
	// 826E34F0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E34F4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E34F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E34FC: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 826E3500: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E3504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E3508: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 826E350C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E3510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E3514: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 826E3518: 4870EED1  bl 0x82df23e8
	ctx.lr = 0x826E351C;
	sub_82DF23E8(ctx, base);
	// 826E351C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E3520: 41820014  beq 0x826e3534
	if ctx.cr[0].eq {
	pc = 0x826E3534; continue 'dispatch;
	}
	// 826E3524: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E3528: 4BFFFEE9  bl 0x826e3410
	ctx.lr = 0x826E352C;
	sub_826E3410(ctx, base);
	// 826E352C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3530: 48000008  b 0x826e3538
	pc = 0x826E3538; continue 'dispatch;
	// 826E3534: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E3538: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E353C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E3544: 4BFFFADD  bl 0x826e3020
	ctx.lr = 0x826E3548;
	sub_826E3020(ctx, base);
	// 826E3548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E354C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3550: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E3554: 4BBDCAAD  bl 0x822c0000
	ctx.lr = 0x826E3558;
	sub_822C0000(ctx, base);
	// 826E3558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E355C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E3560: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 826E3564: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E3568: 4BBDCE71  bl 0x822c03d8
	ctx.lr = 0x826E356C;
	sub_822C03D8(ctx, base);
	// 826E356C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E3570: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E3574: 418200B4  beq 0x826e3628
	if ctx.cr[0].eq {
	pc = 0x826E3628; continue 'dispatch;
	}
	// 826E3578: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E357C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E3580: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E3584: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E3588: 409A0008  bne cr6, 0x826e3590
	if !ctx.cr[6].eq {
	pc = 0x826E3590; continue 'dispatch;
	}
	// 826E358C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E3590: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E3594: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E3598: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E359C: 419A0024  beq cr6, 0x826e35c0
	if ctx.cr[6].eq {
	pc = 0x826E35C0; continue 'dispatch;
	}
	// 826E35A0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E35A4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E35A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E35AC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E35B0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E35B4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E35B8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E35BC: 4082FFE8  bne 0x826e35a4
	if !ctx.cr[0].eq {
	pc = 0x826E35A4; continue 'dispatch;
	}
	// 826E35C0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E35C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E35C8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E35CC: 419A0024  beq cr6, 0x826e35f0
	if ctx.cr[6].eq {
	pc = 0x826E35F0; continue 'dispatch;
	}
	// 826E35D0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E35D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E35D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E35DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E35E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E35E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E35E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E35EC: 4082FFE8  bne 0x826e35d4
	if !ctx.cr[0].eq {
	pc = 0x826E35D4; continue 'dispatch;
	}
	// 826E35F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E35F4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E35F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E35FC: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E3600: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E3604: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E3608: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E360C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E3610: 480B5921  bl 0x82798f30
	ctx.lr = 0x826E3614;
	sub_82798F30(ctx, base);
	// 826E3614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E361C: 480B804D  bl 0x8279b668
	ctx.lr = 0x826E3620;
	sub_8279B668(ctx, base);
	// 826E3620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3624: 48000008  b 0x826e362c
	pc = 0x826E362C; continue 'dispatch;
	// 826E3628: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E362C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E3630: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E3634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E363C: 4BEB4615  bl 0x82597c50
	ctx.lr = 0x826E3640;
	sub_82597C50(ctx, base);
	// 826E3640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E3644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E364C: 4BBDC9B5  bl 0x822c0000
	ctx.lr = 0x826E3650;
	sub_822C0000(ctx, base);
	// 826E3650: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E3654: 41820024  beq 0x826e3678
	if ctx.cr[0].eq {
	pc = 0x826E3678; continue 'dispatch;
	}
	// 826E3658: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E365C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3660: 419A0008  beq cr6, 0x826e3668
	if ctx.cr[6].eq {
	pc = 0x826E3668; continue 'dispatch;
	}
	// 826E3664: 4BBDD22D  bl 0x822c0890
	ctx.lr = 0x826E3668;
	sub_822C0890(ctx, base);
	// 826E3668: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E366C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3670: 419A0008  beq cr6, 0x826e3678
	if ctx.cr[6].eq {
	pc = 0x826E3678; continue 'dispatch;
	}
	// 826E3674: 4BBDD21D  bl 0x822c0890
	ctx.lr = 0x826E3678;
	sub_822C0890(ctx, base);
	// 826E3678: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E367C: 419A000C  beq cr6, 0x826e3688
	if ctx.cr[6].eq {
	pc = 0x826E3688; continue 'dispatch;
	}
	// 826E3680: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E3684: 4BBDD20D  bl 0x822c0890
	ctx.lr = 0x826E3688;
	sub_822C0890(ctx, base);
	// 826E3688: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E368C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E3690: 48AC4B24  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E3698 size=428
    let mut pc: u32 = 0x826E3698;
    'dispatch: loop {
        match pc {
            0x826E3698 => {
    //   block [0x826E3698..0x826E3844)
	// 826E3698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E369C: 48AC4AC9  bl 0x831a8164
	ctx.lr = 0x826E36A0;
	sub_831A8130(ctx, base);
	// 826E36A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E36A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E36A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E36AC: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 826E36B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E36B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E36B8: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 826E36BC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E36C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E36C4: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 826E36C8: 4870ED21  bl 0x82df23e8
	ctx.lr = 0x826E36CC;
	sub_82DF23E8(ctx, base);
	// 826E36CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E36D0: 41820014  beq 0x826e36e4
	if ctx.cr[0].eq {
	pc = 0x826E36E4; continue 'dispatch;
	}
	// 826E36D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E36D8: 4BFFFD39  bl 0x826e3410
	ctx.lr = 0x826E36DC;
	sub_826E3410(ctx, base);
	// 826E36DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E36E0: 48000008  b 0x826e36e8
	pc = 0x826E36E8; continue 'dispatch;
	// 826E36E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E36E8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E36EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E36F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E36F4: 4BFFF92D  bl 0x826e3020
	ctx.lr = 0x826E36F8;
	sub_826E3020(ctx, base);
	// 826E36F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E36FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3700: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E3704: 4BBDC8FD  bl 0x822c0000
	ctx.lr = 0x826E3708;
	sub_822C0000(ctx, base);
	// 826E3708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E370C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E3710: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 826E3714: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E3718: 4BBDCCC1  bl 0x822c03d8
	ctx.lr = 0x826E371C;
	sub_822C03D8(ctx, base);
	// 826E371C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E3720: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E3724: 418200B4  beq 0x826e37d8
	if ctx.cr[0].eq {
	pc = 0x826E37D8; continue 'dispatch;
	}
	// 826E3728: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E372C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E3730: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E3734: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E3738: 409A0008  bne cr6, 0x826e3740
	if !ctx.cr[6].eq {
	pc = 0x826E3740; continue 'dispatch;
	}
	// 826E373C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E3740: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E3744: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E3748: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E374C: 419A0024  beq cr6, 0x826e3770
	if ctx.cr[6].eq {
	pc = 0x826E3770; continue 'dispatch;
	}
	// 826E3750: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E3754: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E3758: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E375C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E3760: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E3764: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E3768: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E376C: 4082FFE8  bne 0x826e3754
	if !ctx.cr[0].eq {
	pc = 0x826E3754; continue 'dispatch;
	}
	// 826E3770: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E3774: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E3778: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E377C: 419A0024  beq cr6, 0x826e37a0
	if ctx.cr[6].eq {
	pc = 0x826E37A0; continue 'dispatch;
	}
	// 826E3780: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E3784: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E3788: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E378C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E3790: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E3794: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E3798: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E379C: 4082FFE8  bne 0x826e3784
	if !ctx.cr[0].eq {
	pc = 0x826E3784; continue 'dispatch;
	}
	// 826E37A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E37A4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E37A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E37AC: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E37B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E37B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E37B8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E37BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E37C0: 480B5771  bl 0x82798f30
	ctx.lr = 0x826E37C4;
	sub_82798F30(ctx, base);
	// 826E37C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E37C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E37CC: 480B7E9D  bl 0x8279b668
	ctx.lr = 0x826E37D0;
	sub_8279B668(ctx, base);
	// 826E37D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E37D4: 48000008  b 0x826e37dc
	pc = 0x826E37DC; continue 'dispatch;
	// 826E37D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E37DC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E37E0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E37E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E37E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E37EC: 4BEB4465  bl 0x82597c50
	ctx.lr = 0x826E37F0;
	sub_82597C50(ctx, base);
	// 826E37F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E37F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E37F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E37FC: 4BBDC805  bl 0x822c0000
	ctx.lr = 0x826E3800;
	sub_822C0000(ctx, base);
	// 826E3800: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E3804: 41820024  beq 0x826e3828
	if ctx.cr[0].eq {
	pc = 0x826E3828; continue 'dispatch;
	}
	// 826E3808: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E380C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3810: 419A0008  beq cr6, 0x826e3818
	if ctx.cr[6].eq {
	pc = 0x826E3818; continue 'dispatch;
	}
	// 826E3814: 4BBDD07D  bl 0x822c0890
	ctx.lr = 0x826E3818;
	sub_822C0890(ctx, base);
	// 826E3818: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E381C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3820: 419A0008  beq cr6, 0x826e3828
	if ctx.cr[6].eq {
	pc = 0x826E3828; continue 'dispatch;
	}
	// 826E3824: 4BBDD06D  bl 0x822c0890
	ctx.lr = 0x826E3828;
	sub_822C0890(ctx, base);
	// 826E3828: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E382C: 419A000C  beq cr6, 0x826e3838
	if ctx.cr[6].eq {
	pc = 0x826E3838; continue 'dispatch;
	}
	// 826E3830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E3834: 4BBDD05D  bl 0x822c0890
	ctx.lr = 0x826E3838;
	sub_822C0890(ctx, base);
	// 826E3838: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E383C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E3840: 48AC4974  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E3848 size=428
    let mut pc: u32 = 0x826E3848;
    'dispatch: loop {
        match pc {
            0x826E3848 => {
    //   block [0x826E3848..0x826E39F4)
	// 826E3848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E384C: 48AC4919  bl 0x831a8164
	ctx.lr = 0x826E3850;
	sub_831A8130(ctx, base);
	// 826E3850: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3854: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3858: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E385C: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 826E3860: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E3864: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E3868: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826E386C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E3870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E3874: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 826E3878: 4870EB71  bl 0x82df23e8
	ctx.lr = 0x826E387C;
	sub_82DF23E8(ctx, base);
	// 826E387C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E3880: 41820014  beq 0x826e3894
	if ctx.cr[0].eq {
	pc = 0x826E3894; continue 'dispatch;
	}
	// 826E3884: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826E3888: 4BFFFB89  bl 0x826e3410
	ctx.lr = 0x826E388C;
	sub_826E3410(ctx, base);
	// 826E388C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3890: 48000008  b 0x826e3898
	pc = 0x826E3898; continue 'dispatch;
	// 826E3894: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E3898: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E389C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E38A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E38A4: 4BFFF77D  bl 0x826e3020
	ctx.lr = 0x826E38A8;
	sub_826E3020(ctx, base);
	// 826E38A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E38AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E38B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E38B4: 4BBDC74D  bl 0x822c0000
	ctx.lr = 0x826E38B8;
	sub_822C0000(ctx, base);
	// 826E38B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E38BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E38C0: 38A00074  li r5, 0x74
	ctx.r[5].s64 = 116;
	// 826E38C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E38C8: 4BBDCB11  bl 0x822c03d8
	ctx.lr = 0x826E38CC;
	sub_822C03D8(ctx, base);
	// 826E38CC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E38D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E38D4: 418200B4  beq 0x826e3988
	if ctx.cr[0].eq {
	pc = 0x826E3988; continue 'dispatch;
	}
	// 826E38D8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E38DC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E38E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E38E4: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E38E8: 409A0008  bne cr6, 0x826e38f0
	if !ctx.cr[6].eq {
	pc = 0x826E38F0; continue 'dispatch;
	}
	// 826E38EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E38F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E38F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E38F8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E38FC: 419A0024  beq cr6, 0x826e3920
	if ctx.cr[6].eq {
	pc = 0x826E3920; continue 'dispatch;
	}
	// 826E3900: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E3904: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E3908: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E390C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E3910: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E3914: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E3918: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E391C: 4082FFE8  bne 0x826e3904
	if !ctx.cr[0].eq {
	pc = 0x826E3904; continue 'dispatch;
	}
	// 826E3920: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E3924: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E3928: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E392C: 419A0024  beq cr6, 0x826e3950
	if ctx.cr[6].eq {
	pc = 0x826E3950; continue 'dispatch;
	}
	// 826E3930: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E3934: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E3938: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E393C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E3940: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E3944: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E3948: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E394C: 4082FFE8  bne 0x826e3934
	if !ctx.cr[0].eq {
	pc = 0x826E3934; continue 'dispatch;
	}
	// 826E3950: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E3954: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E3958: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E395C: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E3960: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E3964: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E3968: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E396C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E3970: 480B55C1  bl 0x82798f30
	ctx.lr = 0x826E3974;
	sub_82798F30(ctx, base);
	// 826E3974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E3978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E397C: 480B7CED  bl 0x8279b668
	ctx.lr = 0x826E3980;
	sub_8279B668(ctx, base);
	// 826E3980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3984: 48000008  b 0x826e398c
	pc = 0x826E398C; continue 'dispatch;
	// 826E3988: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E398C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E3990: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E3994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E399C: 4BEB42B5  bl 0x82597c50
	ctx.lr = 0x826E39A0;
	sub_82597C50(ctx, base);
	// 826E39A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E39A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E39A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E39AC: 4BBDC655  bl 0x822c0000
	ctx.lr = 0x826E39B0;
	sub_822C0000(ctx, base);
	// 826E39B0: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E39B4: 41820024  beq 0x826e39d8
	if ctx.cr[0].eq {
	pc = 0x826E39D8; continue 'dispatch;
	}
	// 826E39B8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E39BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E39C0: 419A0008  beq cr6, 0x826e39c8
	if ctx.cr[6].eq {
	pc = 0x826E39C8; continue 'dispatch;
	}
	// 826E39C4: 4BBDCECD  bl 0x822c0890
	ctx.lr = 0x826E39C8;
	sub_822C0890(ctx, base);
	// 826E39C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E39CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E39D0: 419A0008  beq cr6, 0x826e39d8
	if ctx.cr[6].eq {
	pc = 0x826E39D8; continue 'dispatch;
	}
	// 826E39D4: 4BBDCEBD  bl 0x822c0890
	ctx.lr = 0x826E39D8;
	sub_822C0890(ctx, base);
	// 826E39D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E39DC: 419A000C  beq cr6, 0x826e39e8
	if ctx.cr[6].eq {
	pc = 0x826E39E8; continue 'dispatch;
	}
	// 826E39E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E39E4: 4BBDCEAD  bl 0x822c0890
	ctx.lr = 0x826E39E8;
	sub_822C0890(ctx, base);
	// 826E39E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E39EC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E39F0: 48AC47C4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E39F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E39F8 size=1344
    let mut pc: u32 = 0x826E39F8;
    'dispatch: loop {
        match pc {
            0x826E39F8 => {
    //   block [0x826E39F8..0x826E3F38)
	// 826E39F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E39FC: 48AC4761  bl 0x831a815c
	ctx.lr = 0x826E3A00;
	sub_831A8130(ctx, base);
	// 826E3A00: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 826E3A04: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826E3A08: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3A10: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 826E3A14: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826E3A18: 4BFE70C9  bl 0x826caae0
	ctx.lr = 0x826E3A1C;
	sub_826CAAE0(ctx, base);
	// 826E3A1C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E3A20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3A24: 3BABDE6C  addi r29, r11, -0x2194
	ctx.r[29].s64 = ctx.r[11].s64 + -8596;
	// 826E3A28: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3A2C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826E3A30: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826E3A34: 4870FFD5  bl 0x82df3a08
	ctx.lr = 0x826E3A38;
	sub_82DF3A08(ctx, base);
	// 826E3A38: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826E3A3C: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3A40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3A44: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826E3A48: 4BFE73D9  bl 0x826cae20
	ctx.lr = 0x826E3A4C;
	sub_826CAE20(ctx, base);
	// 826E3A4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E3A50: 3BDF0104  addi r30, r31, 0x104
	ctx.r[30].s64 = ctx.r[31].s64 + 260;
	// 826E3A54: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E3A58: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826E3A5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3A60: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826E3A64: 4BBE09FD  bl 0x822c4460
	ctx.lr = 0x826E3A68;
	sub_822C4460(ctx, base);
	// 826E3A68: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 826E3A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3A70: 419A0008  beq cr6, 0x826e3a78
	if ctx.cr[6].eq {
	pc = 0x826E3A78; continue 'dispatch;
	}
	// 826E3A74: 4BBDCE1D  bl 0x822c0890
	ctx.lr = 0x826E3A78;
	sub_822C0890(ctx, base);
	// 826E3A78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3A7C: 4870F9AD  bl 0x82df3428
	ctx.lr = 0x826E3A80;
	sub_82DF3428(ctx, base);
	// 826E3A80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3A88: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3A8C: 4BE2E68D  bl 0x82512118
	ctx.lr = 0x826E3A90;
	sub_82512118(ctx, base);
	// 826E3A90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E3A94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E3A98: 48731619  bl 0x82e150b0
	ctx.lr = 0x826E3A9C;
	sub_82E150B0(ctx, base);
	// 826E3A9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E3AA0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E3AA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E3AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E3AAC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826E3AB0: 4BE2D0A9  bl 0x82510b58
	ctx.lr = 0x826E3AB4;
	sub_82510B58(ctx, base);
	// 826E3AB4: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3AB8: 397D0018  addi r11, r29, 0x18
	ctx.r[11].s64 = ctx.r[29].s64 + 24;
	// 826E3ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3AC0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826E3AC4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E3AC8: 4870FF41  bl 0x82df3a08
	ctx.lr = 0x826E3ACC;
	sub_82DF3A08(ctx, base);
	// 826E3ACC: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3AD0: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 826E3AD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3AD8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826E3ADC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E3AE0: 4870FF29  bl 0x82df3a08
	ctx.lr = 0x826E3AE4;
	sub_82DF3A08(ctx, base);
	// 826E3AE4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826E3AE8: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3AEC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826E3AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3AF4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826E3AF8: 4BFE72A9  bl 0x826cada0
	ctx.lr = 0x826E3AFC;
	sub_826CADA0(ctx, base);
	// 826E3AFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E3B00: 3BDF010C  addi r30, r31, 0x10c
	ctx.r[30].s64 = ctx.r[31].s64 + 268;
	// 826E3B04: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E3B08: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826E3B0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3B10: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826E3B14: 4BBE094D  bl 0x822c4460
	ctx.lr = 0x826E3B18;
	sub_822C4460(ctx, base);
	// 826E3B18: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 826E3B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3B20: 419A0008  beq cr6, 0x826e3b28
	if ctx.cr[6].eq {
	pc = 0x826E3B28; continue 'dispatch;
	}
	// 826E3B24: 4BBDCD6D  bl 0x822c0890
	ctx.lr = 0x826E3B28;
	sub_822C0890(ctx, base);
	// 826E3B28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3B2C: 4870F8FD  bl 0x82df3428
	ctx.lr = 0x826E3B30;
	sub_82DF3428(ctx, base);
	// 826E3B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3B34: 4870F8F5  bl 0x82df3428
	ctx.lr = 0x826E3B38;
	sub_82DF3428(ctx, base);
	// 826E3B38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3B3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3B40: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3B44: 4BE2E5D5  bl 0x82512118
	ctx.lr = 0x826E3B48;
	sub_82512118(ctx, base);
	// 826E3B48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E3B4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E3B50: 4BC0A411  bl 0x822edf60
	ctx.lr = 0x826E3B54;
	sub_822EDF60(ctx, base);
	// 826E3B54: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826E3B58: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3B5C: 809B674C  lwz r4, 0x674c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E3B60: 4BDAB841  bl 0x8248f3a0
	ctx.lr = 0x826E3B64;
	sub_8248F3A0(ctx, base);
	// 826E3B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E3B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E3B6C: 4BE2D1D5  bl 0x82510d40
	ctx.lr = 0x826E3B70;
	sub_82510D40(ctx, base);
	// 826E3B70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826E3B74: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3B78: 397D0030  addi r11, r29, 0x30
	ctx.r[11].s64 = ctx.r[29].s64 + 48;
	// 826E3B7C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 826E3B80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3B84: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 826E3B88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826E3B8C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E3B90: 4870FE79  bl 0x82df3a08
	ctx.lr = 0x826E3B94;
	sub_82DF3A08(ctx, base);
	// 826E3B94: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3B98: 397D0024  addi r11, r29, 0x24
	ctx.r[11].s64 = ctx.r[29].s64 + 36;
	// 826E3B9C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826E3BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3BA4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E3BA8: 4870FE61  bl 0x82df3a08
	ctx.lr = 0x826E3BAC;
	sub_82DF3A08(ctx, base);
	// 826E3BAC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826E3BB0: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3BB4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E3BB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3BBC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826E3BC0: 4BFE71E1  bl 0x826cada0
	ctx.lr = 0x826E3BC4;
	sub_826CADA0(ctx, base);
	// 826E3BC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E3BC8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826E3BCC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E3BD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3BD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826E3BD8: 4BBE0889  bl 0x822c4460
	ctx.lr = 0x826E3BDC;
	sub_822C4460(ctx, base);
	// 826E3BDC: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 826E3BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3BE4: 419A0008  beq cr6, 0x826e3bec
	if ctx.cr[6].eq {
	pc = 0x826E3BEC; continue 'dispatch;
	}
	// 826E3BE8: 4BBDCCA9  bl 0x822c0890
	ctx.lr = 0x826E3BEC;
	sub_822C0890(ctx, base);
	// 826E3BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3BF0: 4870F839  bl 0x82df3428
	ctx.lr = 0x826E3BF4;
	sub_82DF3428(ctx, base);
	// 826E3BF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E3BF8: 4870F831  bl 0x82df3428
	ctx.lr = 0x826E3BFC;
	sub_82DF3428(ctx, base);
	// 826E3BFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E3C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E3C04: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826E3C08: 4BE2E511  bl 0x82512118
	ctx.lr = 0x826E3C0C;
	sub_82512118(ctx, base);
	// 826E3C0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E3C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E3C14: 4BC0A34D  bl 0x822edf60
	ctx.lr = 0x826E3C18;
	sub_822EDF60(ctx, base);
	// 826E3C18: 809B674C  lwz r4, 0x674c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E3C1C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826E3C20: 4BDAB781  bl 0x8248f3a0
	ctx.lr = 0x826E3C24;
	sub_8248F3A0(ctx, base);
	// 826E3C24: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E3C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E3C2C: 4BE2D115  bl 0x82510d40
	ctx.lr = 0x826E3C30;
	sub_82510D40(ctx, base);
	// 826E3C30: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E3C34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3C38: 419A0008  beq cr6, 0x826e3c40
	if ctx.cr[6].eq {
	pc = 0x826E3C40; continue 'dispatch;
	}
	// 826E3C3C: 4BBDCC55  bl 0x822c0890
	ctx.lr = 0x826E3C40;
	sub_822C0890(ctx, base);
	// 826E3C40: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E3C44: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826E3C48: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826E3C4C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826E3C50: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E3C54: 487BCADD  bl 0x82ea0730
	ctx.lr = 0x826E3C58;
	sub_82EA0730(ctx, base);
	// 826E3C58: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826E3C5C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E3C60: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 826E3C64: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 826E3C68: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E3C6C: 3B8BAA98  addi r28, r11, -0x5568
	ctx.r[28].s64 = ctx.r[11].s64 + -21864;
	// 826E3C70: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826E3C74: 7D4AE2AA  lwax r10, r10, r28
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as i32) as i64;
	// 826E3C78: C029F614  lfs f1, -0x9ec(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E3C7C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 826E3C80: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826E3C84: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826E3C88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E3C8C: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826E3C90: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E3C94: C3CB9450  lfs f30, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E3C98: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 826E3C9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E3CA0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 826E3CA4: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 826E3CA8: C00A0140  lfs f0, 0x140(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E3CAC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 826E3CB0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826E3CB4: C1A97BC8  lfs f13, 0x7bc8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31688 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E3CB8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E3CBC: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826E3CC0: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 826E3CC4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826E3CC8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826E3CCC: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F38 size=4
    let mut pc: u32 = 0x826E3F38;
    'dispatch: loop {
        match pc {
            0x826E3F38 => {
    //   block [0x826E3F38..0x826E3F3C)
	// 826E3F38: 4BFC3D78  b 0x826a7cb0
	sub_826A7CB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F40 size=20
    let mut pc: u32 = 0x826E3F40;
    'dispatch: loop {
        match pc {
            0x826E3F40 => {
    //   block [0x826E3F40..0x826E3F54)
	// 826E3F40: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E3F44: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826E3F48: 419A0014  beq cr6, 0x826e3f5c
	if ctx.cr[6].eq {
		sub_826E3F5C(ctx, base);
		return;
	}
	// 826E3F4C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826E3F50: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F54 size=8
    let mut pc: u32 = 0x826E3F54;
    'dispatch: loop {
        match pc {
            0x826E3F54 => {
    //   block [0x826E3F54..0x826E3F5C)
	// 826E3F54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E3F58: 48000008  b 0x826e3f60
	sub_826E3F5C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F5C size=12
    let mut pc: u32 = 0x826E3F5C;
    'dispatch: loop {
        match pc {
            0x826E3F5C => {
    //   block [0x826E3F5C..0x826E3F68)
	// 826E3F5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E3F60: 99630211  stb r11, 0x211(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(529 as u32), ctx.r[11].u8 ) };
	// 826E3F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F68 size=12
    let mut pc: u32 = 0x826E3F68;
    'dispatch: loop {
        match pc {
            0x826E3F68 => {
    //   block [0x826E3F68..0x826E3F74)
	// 826E3F68: 806301D0  lwz r3, 0x1d0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(464 as u32) ) } as u64;
	// 826E3F6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E3F70: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E3F74 size=8
    let mut pc: u32 = 0x826E3F74;
    'dispatch: loop {
        match pc {
            0x826E3F74 => {
    //   block [0x826E3F74..0x826E3F7C)
	// 826E3F74: 4BFA59E4  b 0x82689958
	sub_82689958(ctx, base);
	return;
	// 826E3F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E3F80 size=120
    let mut pc: u32 = 0x826E3F80;
    'dispatch: loop {
        match pc {
            0x826E3F80 => {
    //   block [0x826E3F80..0x826E3FF8)
	// 826E3F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E3F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E3F8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E3F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E3F94: 897F0211  lbz r11, 0x211(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(529 as u32) ) } as u64;
	// 826E3F98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E3F9C: 4082000C  bne 0x826e3fa8
	if !ctx.cr[0].eq {
	pc = 0x826E3FA8; continue 'dispatch;
	}
	// 826E3FA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E3FA4: 48000040  b 0x826e3fe4
	pc = 0x826E3FE4; continue 'dispatch;
	// 826E3FA8: C01F0218  lfs f0, 0x218(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E3FAC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826E3FB0: C1BF0214  lfs f13, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E3FB4: EC40682A  fadds f2, f0, f13
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826E3FB8: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E3FBC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826E3FC0: 4099FFE0  ble cr6, 0x826e3fa0
	if !ctx.cr[6].gt {
	pc = 0x826E3FA0; continue 'dispatch;
	}
	// 826E3FC4: 48AC684D  bl 0x831aa810
	ctx.lr = 0x826E3FC8;
	sub_831AA810(ctx, base);
	// 826E3FC8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826E3FCC: C1BF0214  lfs f13, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E3FD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E3FD4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826E3FD8: 41980008  blt cr6, 0x826e3fe0
	if ctx.cr[6].lt {
	pc = 0x826E3FE0; continue 'dispatch;
	}
	// 826E3FDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E3FE0: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826E3FE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E3FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E3FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E3FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E3FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E3FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E3FF8 size=96
    let mut pc: u32 = 0x826E3FF8;
    'dispatch: loop {
        match pc {
            0x826E3FF8 => {
    //   block [0x826E3FF8..0x826E4058)
	// 826E3FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E3FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4004: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4008: 89630210  lbz r11, 0x210(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(528 as u32) ) } as u64;
	// 826E400C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E4010: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 826E4014: 4BE2DAD5  bl 0x82511ae8
	ctx.lr = 0x826E4018;
	sub_82511AE8(ctx, base);
	// 826E4018: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 826E401C: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826E4020: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E4024: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 826E4028: 390ADF6C  addi r8, r10, -0x2094
	ctx.r[8].s64 = ctx.r[10].s64 + -8340;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4058 size=196
    let mut pc: u32 = 0x826E4058;
    'dispatch: loop {
        match pc {
            0x826E4058 => {
    //   block [0x826E4058..0x826E411C)
	// 826E4058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E405C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E4064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E406C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E4070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4074: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E4078: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E407C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4080: 4BBDC8B9  bl 0x822c0938
	ctx.lr = 0x826E4084;
	sub_822C0938(ctx, base);
	// 826E4084: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E4088: 41820028  beq 0x826e40b0
	if ctx.cr[0].eq {
	pc = 0x826E40B0; continue 'dispatch;
	}
	// 826E408C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4090: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E4094: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E4098: 392BAC6C  addi r9, r11, -0x5394
	ctx.r[9].s64 = ctx.r[11].s64 + -21396;
	// 826E409C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E40A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E40A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E40A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E40AC: 48000008  b 0x826e40b4
	pc = 0x826E40B4; continue 'dispatch;
	// 826E40B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E40B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E40B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E40BC: 409A0044  bne cr6, 0x826e4100
	if !ctx.cr[6].eq {
	pc = 0x826E4100; continue 'dispatch;
	}
	// 826E40C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E40C4: 419A001C  beq cr6, 0x826e40e0
	if ctx.cr[6].eq {
	pc = 0x826E40E0; continue 'dispatch;
	}
	// 826E40C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E40CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E40D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E40D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E40D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E40DC: 4E800421  bctrl
	ctx.lr = 0x826E40E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E40E0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E40E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E40E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E40EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E40F0: 816BDF78  lwz r11, -0x2088(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8328 as u32) ) } as u64;
	// 826E40F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E40F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E40FC: 4BBDBF05  bl 0x822c0000
	ctx.lr = 0x826E4100;
	sub_822C0000(ctx, base);
	// 826E4100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E4104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E4108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E410C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4110: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E4114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E4118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4120 size=116
    let mut pc: u32 = 0x826E4120;
    'dispatch: loop {
        match pc {
            0x826E4120 => {
    //   block [0x826E4120..0x826E4194)
	// 826E4120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E412C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E4134: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4138: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E413C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E4140: 396BACE4  addi r11, r11, -0x531c
	ctx.r[11].s64 = ctx.r[11].s64 + -21276;
	// 826E4144: 394AACD0  addi r10, r10, -0x5330
	ctx.r[10].s64 = ctx.r[10].s64 + -21296;
	// 826E4148: 3929AC84  addi r9, r9, -0x537c
	ctx.r[9].s64 = ctx.r[9].s64 + -21372;
	// 826E414C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4150: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E4154: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E4158: 807F01DC  lwz r3, 0x1dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 826E415C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4160: 419A0008  beq cr6, 0x826e4168
	if ctx.cr[6].eq {
	pc = 0x826E4168; continue 'dispatch;
	}
	// 826E4164: 4BBDC72D  bl 0x822c0890
	ctx.lr = 0x826E4168;
	sub_822C0890(ctx, base);
	// 826E4168: 807F01D4  lwz r3, 0x1d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 826E416C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4170: 419A0008  beq cr6, 0x826e4178
	if ctx.cr[6].eq {
	pc = 0x826E4178; continue 'dispatch;
	}
	// 826E4174: 4BBDC71D  bl 0x822c0890
	ctx.lr = 0x826E4178;
	sub_822C0890(ctx, base);
	// 826E4178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E417C: 4BFC460D  bl 0x826a8788
	ctx.lr = 0x826E4180;
	sub_826A8788(ctx, base);
	// 826E4180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E4184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E418C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E4190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4198 size=8
    let mut pc: u32 = 0x826E4198;
    'dispatch: loop {
        match pc {
            0x826E4198 => {
    //   block [0x826E4198..0x826E41A0)
	// 826E4198: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E419C: 480000C4  b 0x826e4260
	sub_826E4260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E41A0 size=8
    let mut pc: u32 = 0x826E41A0;
    'dispatch: loop {
        match pc {
            0x826E41A0 => {
    //   block [0x826E41A0..0x826E41A8)
	// 826E41A0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E41A4: 480000BC  b 0x826e4260
	sub_826E4260(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E41A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E41A8 size=184
    let mut pc: u32 = 0x826E41A8;
    'dispatch: loop {
        match pc {
            0x826E41A8 => {
    //   block [0x826E41A8..0x826E4260)
	// 826E41A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E41AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E41B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E41B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E41B8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826E41BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E41C0: 4BFC46D9  bl 0x826a8898
	ctx.lr = 0x826E41C4;
	sub_826A8898(ctx, base);
	// 826E41C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E41C8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E41CC: 396BACE4  addi r11, r11, -0x531c
	ctx.r[11].s64 = ctx.r[11].s64 + -21276;
	// 826E41D0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E41D4: 3929AC84  addi r9, r9, -0x537c
	ctx.r[9].s64 = ctx.r[9].s64 + -21372;
	// 826E41D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E41DC: 394AACD0  addi r10, r10, -0x5330
	ctx.r[10].s64 = ctx.r[10].s64 + -21296;
	// 826E41E0: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 826E41E4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E41E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E41EC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E41F0: 39286910  addi r9, r8, 0x6910
	ctx.r[9].s64 = ctx.r[8].s64 + 26896;
	// 826E41F4: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 826E41F8: 394001F0  li r10, 0x1f0
	ctx.r[10].s64 = 496;
	// 826E41FC: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 826E4200: 39000200  li r8, 0x200
	ctx.r[8].s64 = 512;
	// 826E4204: 917F01D8  stw r11, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 826E4208: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826E420C: 917F01DC  stw r11, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[11].u32 ) };
	// 826E4210: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 826E4214: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 826E4218: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4260 size=76
    let mut pc: u32 = 0x826E4260;
    'dispatch: loop {
        match pc {
            0x826E4260 => {
    //   block [0x826E4260..0x826E42AC)
	// 826E4260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E426C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E4278: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E427C: 4BFFFEA5  bl 0x826e4120
	ctx.lr = 0x826E4280;
	sub_826E4120(ctx, base);
	// 826E4280: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E4284: 4182000C  beq 0x826e4290
	if ctx.cr[0].eq {
	pc = 0x826E4290; continue 'dispatch;
	}
	// 826E4288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E428C: 4870E14D  bl 0x82df23d8
	ctx.lr = 0x826E4290;
	sub_82DF23D8(ctx, base);
	// 826E4290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E4294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E4298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E429C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E42A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E42A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E42A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E42B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E42B0 size=260
    let mut pc: u32 = 0x826E42B0;
    'dispatch: loop {
        match pc {
            0x826E42B0 => {
    //   block [0x826E42B0..0x826E43B4)
	// 826E42B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E42B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E42B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E42BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E42C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E42C4: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E42C8: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 826E42CC: 4182007C  beq 0x826e4348
	if ctx.cr[0].eq {
	pc = 0x826E4348; continue 'dispatch;
	}
	// 826E42D0: 4BFA5629  bl 0x826898f8
	ctx.lr = 0x826E42D4;
	sub_826898F8(ctx, base);
	// 826E42D4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E42D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E42DC: 38ABAAEC  addi r5, r11, -0x5514
	ctx.r[5].s64 = ctx.r[11].s64 + -21780;
	// 826E42E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E42E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E42E8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E42EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E42F0: 4E800421  bctrl
	ctx.lr = 0x826E42F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E42F4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E42F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E42FC: 419A0008  beq cr6, 0x826e4304
	if ctx.cr[6].eq {
	pc = 0x826E4304; continue 'dispatch;
	}
	// 826E4300: 4BBDC591  bl 0x822c0890
	ctx.lr = 0x826E4304;
	sub_822C0890(ctx, base);
	// 826E4304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4308: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E430C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E4310: 38AAAAD4  addi r5, r10, -0x552c
	ctx.r[5].s64 = ctx.r[10].s64 + -21804;
	// 826E4314: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E4318: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826E431C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E4320: 4E800421  bctrl
	ctx.lr = 0x826E4324;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E4324: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E4328: 395F01D8  addi r10, r31, 0x1d8
	ctx.r[10].s64 = ctx.r[31].s64 + 472;
	// 826E432C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E4330: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826E4334: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4338: 917F01D8  stw r11, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 826E433C: 4BBE0125  bl 0x822c4460
	ctx.lr = 0x826E4340;
	sub_822C4460(ctx, base);
	// 826E4340: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E4344: 48000050  b 0x826e4394
	pc = 0x826E4394; continue 'dispatch;
	// 826E4348: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E434C: 4BFA551D  bl 0x82689868
	ctx.lr = 0x826E4350;
	sub_82689868(ctx, base);
	// 826E4350: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826E4354: 397F01D8  addi r11, r31, 0x1d8
	ctx.r[11].s64 = ctx.r[31].s64 + 472;
	// 826E4358: 915F01D8  stw r10, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[10].u32 ) };
	// 826E435C: 807F01DC  lwz r3, 0x1dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 826E4360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4364: 915F01DC  stw r10, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[10].u32 ) };
	// 826E4368: 419A0008  beq cr6, 0x826e4370
	if ctx.cr[6].eq {
	pc = 0x826E4370; continue 'dispatch;
	}
	// 826E436C: 4BBDC525  bl 0x822c0890
	ctx.lr = 0x826E4370;
	sub_822C0890(ctx, base);
	// 826E4370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4374: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E4378: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E437C: 38AAAAB8  addi r5, r10, -0x5548
	ctx.r[5].s64 = ctx.r[10].s64 + -21832;
	// 826E4380: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E4384: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E4388: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E438C: 4E800421  bctrl
	ctx.lr = 0x826E4390;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E4390: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E4394: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4398: 419A0008  beq cr6, 0x826e43a0
	if ctx.cr[6].eq {
	pc = 0x826E43A0; continue 'dispatch;
	}
	// 826E439C: 4BBDC4F5  bl 0x822c0890
	ctx.lr = 0x826E43A0;
	sub_822C0890(ctx, base);
	// 826E43A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E43A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E43A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E43AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E43B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E43B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E43B8 size=328
    let mut pc: u32 = 0x826E43B8;
    'dispatch: loop {
        match pc {
            0x826E43B8 => {
    //   block [0x826E43B8..0x826E4500)
	// 826E43B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E43BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E43C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E43C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E43C8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826E43CC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826E43D0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826E43D4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E43D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E43DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E43E0: 419A00FC  beq cr6, 0x826e44dc
	if ctx.cr[6].eq {
	pc = 0x826E44DC; continue 'dispatch;
	}
	// 826E43E4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E43E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E43EC: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826E43F0: 4870F619  bl 0x82df3a08
	ctx.lr = 0x826E43F4;
	sub_82DF3A08(ctx, base);
	// 826E43F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E43F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E43FC: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826E4400: 4870F609  bl 0x82df3a08
	ctx.lr = 0x826E4404;
	sub_82DF3A08(ctx, base);
	// 826E4404: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E4408: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E440C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826E4410: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826E4414: 3BCBDF6C  addi r30, r11, -0x2094
	ctx.r[30].s64 = ctx.r[11].s64 + -8340;
	// 826E4418: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E441C: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E4420: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E4424: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E4428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E442C: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826E4430: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E4434: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E4438: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E443C: 4BEBEE6D  bl 0x825a32a8
	ctx.lr = 0x826E4440;
	sub_825A32A8(ctx, base);
	// 826E4440: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E4444: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E4448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E444C: 4BEBD325  bl 0x825a1770
	ctx.lr = 0x826E4450;
	sub_825A1770(ctx, base);
	// 826E4450: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E4454: 4870EFD5  bl 0x82df3428
	ctx.lr = 0x826E4458;
	sub_82DF3428(ctx, base);
	// 826E4458: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E445C: 4BBE485D  bl 0x822c8cb8
	ctx.lr = 0x826E4460;
	sub_822C8CB8(ctx, base);
	// 826E4460: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4464: 4870EFC5  bl 0x82df3428
	ctx.lr = 0x826E4468;
	sub_82DF3428(ctx, base);
	// 826E4468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E446C: 4870EFBD  bl 0x82df3428
	ctx.lr = 0x826E4470;
	sub_82DF3428(ctx, base);
	// 826E4470: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4478: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 826E447C: 4870F58D  bl 0x82df3a08
	ctx.lr = 0x826E4480;
	sub_82DF3A08(ctx, base);
	// 826E4480: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4484: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4488: 388BAB0C  addi r4, r11, -0x54f4
	ctx.r[4].s64 = ctx.r[11].s64 + -21748;
	// 826E448C: 4870F57D  bl 0x82df3a08
	ctx.lr = 0x826E4490;
	sub_82DF3A08(ctx, base);
	// 826E4490: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 826E4494: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E4498: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E449C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826E44A0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E44A4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E44A8: 4BEBEE01  bl 0x825a32a8
	ctx.lr = 0x826E44AC;
	sub_825A32A8(ctx, base);
	// 826E44AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E44B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E44B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E44B8: 4BEBD2B9  bl 0x825a1770
	ctx.lr = 0x826E44BC;
	sub_825A1770(ctx, base);
	// 826E44BC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826E44C0: 4870EF69  bl 0x82df3428
	ctx.lr = 0x826E44C4;
	sub_82DF3428(ctx, base);
	// 826E44C4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E44C8: 4BBE47F1  bl 0x822c8cb8
	ctx.lr = 0x826E44CC;
	sub_822C8CB8(ctx, base);
	// 826E44CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E44D0: 4870EF59  bl 0x82df3428
	ctx.lr = 0x826E44D4;
	sub_82DF3428(ctx, base);
	// 826E44D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E44D8: 4870EF51  bl 0x82df3428
	ctx.lr = 0x826E44DC;
	sub_82DF3428(ctx, base);
	// 826E44DC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826E44E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E44E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E44E8: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826E44EC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826E44F0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826E44F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E44F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E44FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E4500 size=416
    let mut pc: u32 = 0x826E4500;
    'dispatch: loop {
        match pc {
            0x826E4500 => {
    //   block [0x826E4500..0x826E46A0)
	// 826E4500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E450C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4510: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826E4514: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826E4518: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826E451C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E4524: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E4528: 4BFC5181  bl 0x826a96a8
	ctx.lr = 0x826E452C;
	sub_826A96A8(ctx, base);
	// 826E452C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E4530: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4534: 388BD300  addi r4, r11, -0x2d00
	ctx.r[4].s64 = ctx.r[11].s64 + -11520;
	// 826E4538: 4870F4D1  bl 0x82df3a08
	ctx.lr = 0x826E453C;
	sub_82DF3A08(ctx, base);
	// 826E453C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E4540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4544: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 826E4548: 4870F4C1  bl 0x82df3a08
	ctx.lr = 0x826E454C;
	sub_82DF3A08(ctx, base);
	// 826E454C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E4550: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826E4554: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E4558: 38BF0130  addi r5, r31, 0x130
	ctx.r[5].s64 = ctx.r[31].s64 + 304;
	// 826E455C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E4560: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E4564: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826E4568: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E456C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E4570: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826E4574: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E4578: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E457C: 4BEBED2D  bl 0x825a32a8
	ctx.lr = 0x826E4580;
	sub_825A32A8(ctx, base);
	// 826E4580: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E4584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E4588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E458C: 4BEBD1E5  bl 0x825a1770
	ctx.lr = 0x826E4590;
	sub_825A1770(ctx, base);
	// 826E4590: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826E4594: 4870EE95  bl 0x82df3428
	ctx.lr = 0x826E4598;
	sub_82DF3428(ctx, base);
	// 826E4598: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826E459C: 4BBE471D  bl 0x822c8cb8
	ctx.lr = 0x826E45A0;
	sub_822C8CB8(ctx, base);
	// 826E45A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E45A4: 4870EE85  bl 0x82df3428
	ctx.lr = 0x826E45A8;
	sub_82DF3428(ctx, base);
	// 826E45A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E45AC: 4870EE7D  bl 0x82df3428
	ctx.lr = 0x826E45B0;
	sub_82DF3428(ctx, base);
	// 826E45B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E45B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E45B8: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 826E45BC: 4870F44D  bl 0x82df3a08
	ctx.lr = 0x826E45C0;
	sub_82DF3A08(ctx, base);
	// 826E45C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E45C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E45C8: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 826E45CC: 4870F43D  bl 0x82df3a08
	ctx.lr = 0x826E45D0;
	sub_82DF3A08(ctx, base);
	// 826E45D0: 38BF0134  addi r5, r31, 0x134
	ctx.r[5].s64 = ctx.r[31].s64 + 308;
	// 826E45D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E45D8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E45DC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826E45E0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E45E4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E45E8: 4BEBECC1  bl 0x825a32a8
	ctx.lr = 0x826E45EC;
	sub_825A32A8(ctx, base);
	// 826E45EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E45F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E45F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E45F8: 4BEBD179  bl 0x825a1770
	ctx.lr = 0x826E45FC;
	sub_825A1770(ctx, base);
	// 826E45FC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826E4600: 4870EE29  bl 0x82df3428
	ctx.lr = 0x826E4604;
	sub_82DF3428(ctx, base);
	// 826E4604: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826E4608: 4BBE46B1  bl 0x822c8cb8
	ctx.lr = 0x826E460C;
	sub_822C8CB8(ctx, base);
	// 826E460C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4610: 4870EE19  bl 0x82df3428
	ctx.lr = 0x826E4614;
	sub_82DF3428(ctx, base);
	// 826E4614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4618: 4870EE11  bl 0x82df3428
	ctx.lr = 0x826E461C;
	sub_82DF3428(ctx, base);
	// 826E461C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4624: 388B8674  addi r4, r11, -0x798c
	ctx.r[4].s64 = ctx.r[11].s64 + -31116;
	// 826E4628: 4870F3E1  bl 0x82df3a08
	ctx.lr = 0x826E462C;
	sub_82DF3A08(ctx, base);
	// 826E462C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4630: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4634: 388BAD24  addi r4, r11, -0x52dc
	ctx.r[4].s64 = ctx.r[11].s64 + -21212;
	// 826E4638: 4870F3D1  bl 0x82df3a08
	ctx.lr = 0x826E463C;
	sub_82DF3A08(ctx, base);
	// 826E463C: 38BF0138  addi r5, r31, 0x138
	ctx.r[5].s64 = ctx.r[31].s64 + 312;
	// 826E4640: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E4644: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E4648: 4BEBEA09  bl 0x825a3050
	ctx.lr = 0x826E464C;
	sub_825A3050(ctx, base);
	// 826E464C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E4650: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E4654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E4658: 4BEBDB31  bl 0x825a2188
	ctx.lr = 0x826E465C;
	sub_825A2188(ctx, base);
	// 826E465C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826E4660: 4870EDC9  bl 0x82df3428
	ctx.lr = 0x826E4664;
	sub_82DF3428(ctx, base);
	// 826E4664: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E4668: 4BBE4651  bl 0x822c8cb8
	ctx.lr = 0x826E466C;
	sub_822C8CB8(ctx, base);
	// 826E466C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E4670: 4870EDB9  bl 0x82df3428
	ctx.lr = 0x826E4674;
	sub_82DF3428(ctx, base);
	// 826E4674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4678: 4870EDB1  bl 0x82df3428
	ctx.lr = 0x826E467C;
	sub_82DF3428(ctx, base);
	// 826E467C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826E4680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4688: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826E468C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826E4690: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826E4694: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E4698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E469C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E46A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E46A0 size=232
    let mut pc: u32 = 0x826E46A0;
    'dispatch: loop {
        match pc {
            0x826E46A0 => {
    //   block [0x826E46A0..0x826E4788)
	// 826E46A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E46A4: 48AC3AC9  bl 0x831a816c
	ctx.lr = 0x826E46A8;
	sub_831A8130(ctx, base);
	// 826E46A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E46AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E46B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E46B4: 4BFC3D4D  bl 0x826a8400
	ctx.lr = 0x826E46B8;
	sub_826A8400(ctx, base);
	// 826E46B8: 807F01A4  lwz r3, 0x1a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826E46BC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826E46C0: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826E46C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E46C8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826E46CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E46D0: 4E800421  bctrl
	ctx.lr = 0x826E46D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E46D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E46D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E46DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826E46E0: 487975E9  bl 0x82e7bcc8
	ctx.lr = 0x826E46E4;
	sub_82E7BCC8(ctx, base);
	// 826E46E4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826E46E8: 397F01F0  addi r11, r31, 0x1f0
	ctx.r[11].s64 = ctx.r[31].s64 + 496;
	// 826E46EC: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E46F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E46F4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826E46F8: 38E00200  li r7, 0x200
	ctx.r[7].s64 = 512;
	// 826E46FC: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E4700: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E4704: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E4708: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E4788 size=424
    let mut pc: u32 = 0x826E4788;
    'dispatch: loop {
        match pc {
            0x826E4788 => {
    //   block [0x826E4788..0x826E4930)
	// 826E4788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E478C: 48AC39D9  bl 0x831a8164
	ctx.lr = 0x826E4790;
	sub_831A8130(ctx, base);
	// 826E4790: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4794: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E479C: 3BCBAD40  addi r30, r11, -0x52c0
	ctx.r[30].s64 = ctx.r[11].s64 + -21184;
	// 826E47A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E47A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E47A8: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 826E47AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E47B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E47B4: 38600220  li r3, 0x220
	ctx.r[3].s64 = 544;
	// 826E47B8: 4870DC31  bl 0x82df23e8
	ctx.lr = 0x826E47BC;
	sub_82DF23E8(ctx, base);
	// 826E47BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E47C0: 41820010  beq 0x826e47d0
	if ctx.cr[0].eq {
	pc = 0x826E47D0; continue 'dispatch;
	}
	// 826E47C4: 4BFFF9E5  bl 0x826e41a8
	ctx.lr = 0x826E47C8;
	sub_826E41A8(ctx, base);
	// 826E47C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E47CC: 48000008  b 0x826e47d4
	pc = 0x826E47D4; continue 'dispatch;
	// 826E47D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E47D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E47D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E47DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E47E0: 4BFFF879  bl 0x826e4058
	ctx.lr = 0x826E47E4;
	sub_826E4058(ctx, base);
	// 826E47E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E47E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E47EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E47F0: 4BBDB811  bl 0x822c0000
	ctx.lr = 0x826E47F4;
	sub_822C0000(ctx, base);
	// 826E47F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E47F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E47FC: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 826E4800: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E4804: 4BBDBBD5  bl 0x822c03d8
	ctx.lr = 0x826E4808;
	sub_822C03D8(ctx, base);
	// 826E4808: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E480C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E4810: 418200B4  beq 0x826e48c4
	if ctx.cr[0].eq {
	pc = 0x826E48C4; continue 'dispatch;
	}
	// 826E4814: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E4818: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E481C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E4820: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E4824: 409A0008  bne cr6, 0x826e482c
	if !ctx.cr[6].eq {
	pc = 0x826E482C; continue 'dispatch;
	}
	// 826E4828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E482C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E4830: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E4834: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E4838: 419A0024  beq cr6, 0x826e485c
	if ctx.cr[6].eq {
	pc = 0x826E485C; continue 'dispatch;
	}
	// 826E483C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E4840: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E4844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E4848: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E484C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E4850: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E4854: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E4858: 4082FFE8  bne 0x826e4840
	if !ctx.cr[0].eq {
	pc = 0x826E4840; continue 'dispatch;
	}
	// 826E485C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E4860: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E4864: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E4868: 419A0024  beq cr6, 0x826e488c
	if ctx.cr[6].eq {
	pc = 0x826E488C; continue 'dispatch;
	}
	// 826E486C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E4870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E4874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E4878: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E487C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E4880: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E4884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E4888: 4082FFE8  bne 0x826e4870
	if !ctx.cr[0].eq {
	pc = 0x826E4870; continue 'dispatch;
	}
	// 826E488C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E4890: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E4894: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E4898: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E489C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E48A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E48A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E48A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E48AC: 480B4685  bl 0x82798f30
	ctx.lr = 0x826E48B0;
	sub_82798F30(ctx, base);
	// 826E48B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E48B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E48B8: 480B6DB1  bl 0x8279b668
	ctx.lr = 0x826E48BC;
	sub_8279B668(ctx, base);
	// 826E48BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E48C0: 48000008  b 0x826e48c8
	pc = 0x826E48C8; continue 'dispatch;
	// 826E48C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E48C8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E48CC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E48D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E48D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E48D8: 4BEB3379  bl 0x82597c50
	ctx.lr = 0x826E48DC;
	sub_82597C50(ctx, base);
	// 826E48DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E48E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E48E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E48E8: 4BBDB719  bl 0x822c0000
	ctx.lr = 0x826E48EC;
	sub_822C0000(ctx, base);
	// 826E48EC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E48F0: 41820024  beq 0x826e4914
	if ctx.cr[0].eq {
	pc = 0x826E4914; continue 'dispatch;
	}
	// 826E48F4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E48F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E48FC: 419A0008  beq cr6, 0x826e4904
	if ctx.cr[6].eq {
	pc = 0x826E4904; continue 'dispatch;
	}
	// 826E4900: 4BBDBF91  bl 0x822c0890
	ctx.lr = 0x826E4904;
	sub_822C0890(ctx, base);
	// 826E4904: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E4908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E490C: 419A0008  beq cr6, 0x826e4914
	if ctx.cr[6].eq {
	pc = 0x826E4914; continue 'dispatch;
	}
	// 826E4910: 4BBDBF81  bl 0x822c0890
	ctx.lr = 0x826E4914;
	sub_822C0890(ctx, base);
	// 826E4914: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E4918: 419A000C  beq cr6, 0x826e4924
	if ctx.cr[6].eq {
	pc = 0x826E4924; continue 'dispatch;
	}
	// 826E491C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E4920: 4BBDBF71  bl 0x822c0890
	ctx.lr = 0x826E4924;
	sub_822C0890(ctx, base);
	// 826E4924: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E4928: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E492C: 48AC3888  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4930 size=96
    let mut pc: u32 = 0x826E4930;
    'dispatch: loop {
        match pc {
            0x826E4930 => {
    //   block [0x826E4930..0x826E4990)
	// 826E4930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E493C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4944: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E494C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E4950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4954: 388BAD94  addi r4, r11, -0x526c
	ctx.r[4].s64 = ctx.r[11].s64 + -21100;
	// 826E4958: 4870F0B1  bl 0x82df3a08
	ctx.lr = 0x826E495C;
	sub_82DF3A08(ctx, base);
	// 826E495C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E4960: 38BF0211  addi r5, r31, 0x211
	ctx.r[5].s64 = ctx.r[31].s64 + 529;
	// 826E4964: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4968: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E496C: 4BF1371D  bl 0x825f8088
	ctx.lr = 0x826E4970;
	sub_825F8088(ctx, base);
	// 826E4970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4974: 4870EAB5  bl 0x82df3428
	ctx.lr = 0x826E4978;
	sub_82DF3428(ctx, base);
	// 826E4978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E497C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4984: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E4988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E498C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E4990 size=796
    let mut pc: u32 = 0x826E4990;
    'dispatch: loop {
        match pc {
            0x826E4990 => {
    //   block [0x826E4990..0x826E4CAC)
	// 826E4990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4994: 48AC37D1  bl 0x831a8164
	ctx.lr = 0x826E4998;
	sub_831A8130(ctx, base);
	// 826E4998: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 826E499C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826E49A0: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E49A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E49A8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 826E49AC: 4BFC4B3D  bl 0x826a94e8
	ctx.lr = 0x826E49B0;
	sub_826A94E8(ctx, base);
	// 826E49B0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E49B4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826E49B8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826E49BC: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826E49C0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E49C4: 487BBD6D  bl 0x82ea0730
	ctx.lr = 0x826E49C8;
	sub_82EA0730(ctx, base);
	// 826E49C8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826E49CC: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 826E49D0: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 826E49D4: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 826E49D8: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 826E49DC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E49E0: C01E01C0  lfs f0, 0x1c0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E49E4: C04BF614  lfs f2, -0x9ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826E49E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E49EC: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 826E49F0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826E49F4: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826E49F8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E49FC: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826E4A00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E4A04: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826E4A08: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826E4A0C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826E4A10: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826E4A14: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E4A18: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4CB0 size=220
    let mut pc: u32 = 0x826E4CB0;
    'dispatch: loop {
        match pc {
            0x826E4CB0 => {
    //   block [0x826E4CB0..0x826E4D8C)
	// 826E4CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4CB4: 48AC34B5  bl 0x831a8168
	ctx.lr = 0x826E4CB8;
	sub_831A8130(ctx, base);
	// 826E4CB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4CBC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826E4CC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E4CC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E4CC8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826E4CCC: 41820038  beq 0x826e4d04
	if ctx.cr[0].eq {
	pc = 0x826E4D04; continue 'dispatch;
	}
	// 826E4CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E4CD4: 48AC4CB5  bl 0x831a9988
	ctx.lr = 0x826E4CD8;
	sub_831A9988(ctx, base);
	// 826E4CD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E4CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E4CE0: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826E4CE4: 48AC3415  bl 0x831a80f8
	ctx.lr = 0x826E4CE8;
	sub_831A80F8(ctx, base);
	// 826E4CE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E4CEC: 41820018  beq 0x826e4d04
	if ctx.cr[0].eq {
	pc = 0x826E4D04; continue 'dispatch;
	}
	// 826E4CF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E4CF4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E4CF8: 48001189  bl 0x826e5e80
	ctx.lr = 0x826E4CFC;
	sub_826E5E80(ctx, base);
	// 826E4CFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E4D00: 48000084  b 0x826e4d84
	pc = 0x826E4D84; continue 'dispatch;
	// 826E4D04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E4D08: 419A006C  beq cr6, 0x826e4d74
	if ctx.cr[6].eq {
	pc = 0x826E4D74; continue 'dispatch;
	}
	// 826E4D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E4D10: 48AC4C79  bl 0x831a9988
	ctx.lr = 0x826E4D14;
	sub_831A9988(ctx, base);
	// 826E4D14: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E4D18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E4D1C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826E4D20: 48AC33D9  bl 0x831a80f8
	ctx.lr = 0x826E4D24;
	sub_831A80F8(ctx, base);
	// 826E4D24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E4D28: 41820014  beq 0x826e4d3c
	if ctx.cr[0].eq {
	pc = 0x826E4D3C; continue 'dispatch;
	}
	// 826E4D2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E4D30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E4D34: 4BFFF20D  bl 0x826e3f40
	ctx.lr = 0x826E4D38;
	sub_826E3F40(ctx, base);
	// 826E4D38: 4BFFFFC4  b 0x826e4cfc
	pc = 0x826E4CFC; continue 'dispatch;
	// 826E4D3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E4D40: 419A0034  beq cr6, 0x826e4d74
	if ctx.cr[6].eq {
	pc = 0x826E4D74; continue 'dispatch;
	}
	// 826E4D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E4D48: 48AC4C41  bl 0x831a9988
	ctx.lr = 0x826E4D4C;
	sub_831A9988(ctx, base);
	// 826E4D4C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E4D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E4D54: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 826E4D58: 48AC33A1  bl 0x831a80f8
	ctx.lr = 0x826E4D5C;
	sub_831A80F8(ctx, base);
	// 826E4D5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E4D60: 41820014  beq 0x826e4d74
	if ctx.cr[0].eq {
	pc = 0x826E4D74; continue 'dispatch;
	}
	// 826E4D64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E4D68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E4D6C: 4BFFF28D  bl 0x826e3ff8
	ctx.lr = 0x826E4D70;
	sub_826E3FF8(ctx, base);
	// 826E4D70: 4BFFFF8C  b 0x826e4cfc
	pc = 0x826E4CFC; continue 'dispatch;
	// 826E4D74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826E4D78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E4D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E4D80: 4BFC3709  bl 0x826a8488
	ctx.lr = 0x826E4D84;
	sub_826A8488(ctx, base);
	// 826E4D84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E4D88: 48AC3430  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4D90 size=4
    let mut pc: u32 = 0x826E4D90;
    'dispatch: loop {
        match pc {
            0x826E4D90 => {
    //   block [0x826E4D90..0x826E4D94)
	// 826E4D90: 4BFC2F18  b 0x826a7ca8
	sub_826A7CA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4D98 size=4
    let mut pc: u32 = 0x826E4D98;
    'dispatch: loop {
        match pc {
            0x826E4D98 => {
    //   block [0x826E4D98..0x826E4D9C)
	// 826E4D98: 4BFC0100  b 0x826a4e98
	sub_826A4E98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4DA0 size=20
    let mut pc: u32 = 0x826E4DA0;
    'dispatch: loop {
        match pc {
            0x826E4DA0 => {
    //   block [0x826E4DA0..0x826E4DB4)
	// 826E4DA0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E4DA4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826E4DA8: 419A0014  beq cr6, 0x826e4dbc
	if ctx.cr[6].eq {
		sub_826E4DBC(ctx, base);
		return;
	}
	// 826E4DAC: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826E4DB0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4DB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4DB4 size=8
    let mut pc: u32 = 0x826E4DB4;
    'dispatch: loop {
        match pc {
            0x826E4DB4 => {
    //   block [0x826E4DB4..0x826E4DBC)
	// 826E4DB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4DB8: 48000008  b 0x826e4dc0
	sub_826E4DBC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4DBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4DBC size=12
    let mut pc: u32 = 0x826E4DBC;
    'dispatch: loop {
        match pc {
            0x826E4DBC => {
    //   block [0x826E4DBC..0x826E4DC8)
	// 826E4DBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E4DC0: 99630241  stb r11, 0x241(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(577 as u32), ctx.r[11].u8 ) };
	// 826E4DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4DC8 size=136
    let mut pc: u32 = 0x826E4DC8;
    'dispatch: loop {
        match pc {
            0x826E4DC8 => {
    //   block [0x826E4DC8..0x826E4E50)
	// 826E4DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4DD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E4DD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4DD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4DDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E4DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E4DE4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 826E4DE8: 409A0020  bne cr6, 0x826e4e08
	if !ctx.cr[6].eq {
	pc = 0x826E4E08; continue 'dispatch;
	}
	// 826E4DEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E4DF0: 419A0048  beq cr6, 0x826e4e38
	if ctx.cr[6].eq {
	pc = 0x826E4E38; continue 'dispatch;
	}
	// 826E4DF4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826E4DF8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 826E4DFC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 826E4E00: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 826E4E04: 48000034  b 0x826e4e38
	pc = 0x826E4E38; continue 'dispatch;
	// 826E4E08: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 826E4E0C: 419A002C  beq cr6, 0x826e4e38
	if ctx.cr[6].eq {
	pc = 0x826E4E38; continue 'dispatch;
	}
	// 826E4E10: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E4E14: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4E18: 388BE050  addi r4, r11, -0x1fb0
	ctx.r[4].s64 = ctx.r[11].s64 + -8112;
	// 826E4E1C: 48AC32DD  bl 0x831a80f8
	ctx.lr = 0x826E4E20;
	sub_831A80F8(ctx, base);
	// 826E4E20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E4E24: 4182000C  beq 0x826e4e30
	if ctx.cr[0].eq {
	pc = 0x826E4E30; continue 'dispatch;
	}
	// 826E4E28: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826E4E2C: 4800000C  b 0x826e4e38
	pc = 0x826E4E38; continue 'dispatch;
	// 826E4E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4E34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E4E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E4E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E4E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4E50 size=12
    let mut pc: u32 = 0x826E4E50;
    'dispatch: loop {
        match pc {
            0x826E4E50 => {
    //   block [0x826E4E50..0x826E4E5C)
	// 826E4E50: 806301F0  lwz r3, 0x1f0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(496 as u32) ) } as u64;
	// 826E4E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4E58: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4E5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E4E5C size=8
    let mut pc: u32 = 0x826E4E5C;
    'dispatch: loop {
        match pc {
            0x826E4E5C => {
    //   block [0x826E4E5C..0x826E4E64)
	// 826E4E5C: 4BFA4AFC  b 0x82689958
	sub_82689958(ctx, base);
	return;
	// 826E4E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E4E68 size=120
    let mut pc: u32 = 0x826E4E68;
    'dispatch: loop {
        match pc {
            0x826E4E68 => {
    //   block [0x826E4E68..0x826E4EE0)
	// 826E4E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4E70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4E74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E4E7C: 897F0241  lbz r11, 0x241(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(577 as u32) ) } as u64;
	// 826E4E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E4E84: 4082000C  bne 0x826e4e90
	if !ctx.cr[0].eq {
	pc = 0x826E4E90; continue 'dispatch;
	}
	// 826E4E88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E4E8C: 48000040  b 0x826e4ecc
	pc = 0x826E4ECC; continue 'dispatch;
	// 826E4E90: C01F0248  lfs f0, 0x248(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E4E94: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826E4E98: C1BF0244  lfs f13, 0x244(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E4E9C: EC40682A  fadds f2, f0, f13
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826E4EA0: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E4EA4: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826E4EA8: 4099FFE0  ble cr6, 0x826e4e88
	if !ctx.cr[6].gt {
	pc = 0x826E4E88; continue 'dispatch;
	}
	// 826E4EAC: 48AC5965  bl 0x831aa810
	ctx.lr = 0x826E4EB0;
	sub_831AA810(ctx, base);
	// 826E4EB0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826E4EB4: C1BF0244  lfs f13, 0x244(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E4EB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E4EBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826E4EC0: 41980008  blt cr6, 0x826e4ec8
	if ctx.cr[6].lt {
	pc = 0x826E4EC8; continue 'dispatch;
	}
	// 826E4EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4EC8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826E4ECC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E4ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4ED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E4EDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4EE0 size=196
    let mut pc: u32 = 0x826E4EE0;
    'dispatch: loop {
        match pc {
            0x826E4EE0 => {
    //   block [0x826E4EE0..0x826E4FA4)
	// 826E4EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E4EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E4EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4EFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E4F00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E4F04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4F08: 4BBDBA31  bl 0x822c0938
	ctx.lr = 0x826E4F0C;
	sub_822C0938(ctx, base);
	// 826E4F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E4F10: 41820028  beq 0x826e4f38
	if ctx.cr[0].eq {
	pc = 0x826E4F38; continue 'dispatch;
	}
	// 826E4F14: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4F18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E4F1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E4F20: 392BADB4  addi r9, r11, -0x524c
	ctx.r[9].s64 = ctx.r[11].s64 + -21068;
	// 826E4F24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E4F28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E4F2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E4F30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E4F34: 48000008  b 0x826e4f3c
	pc = 0x826E4F3C; continue 'dispatch;
	// 826E4F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E4F3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E4F44: 409A0044  bne cr6, 0x826e4f88
	if !ctx.cr[6].eq {
	pc = 0x826E4F88; continue 'dispatch;
	}
	// 826E4F48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E4F4C: 419A001C  beq cr6, 0x826e4f68
	if ctx.cr[6].eq {
	pc = 0x826E4F68; continue 'dispatch;
	}
	// 826E4F50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4F54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E4F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E4F5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E4F60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E4F64: 4E800421  bctrl
	ctx.lr = 0x826E4F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E4F68: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E4F6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E4F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E4F74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E4F78: 816BDFF8  lwz r11, -0x2008(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8200 as u32) ) } as u64;
	// 826E4F7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E4F80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E4F84: 4BBDB07D  bl 0x822c0000
	ctx.lr = 0x826E4F88;
	sub_822C0000(ctx, base);
	// 826E4F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E4F8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E4F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E4F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E4F98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E4F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E4FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E4FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E4FA8 size=116
    let mut pc: u32 = 0x826E4FA8;
    'dispatch: loop {
        match pc {
            0x826E4FA8 => {
    //   block [0x826E4FA8..0x826E501C)
	// 826E4FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E4FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E4FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E4FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E4FB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E4FBC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E4FC0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E4FC4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E4FC8: 396BAE2C  addi r11, r11, -0x51d4
	ctx.r[11].s64 = ctx.r[11].s64 + -20948;
	// 826E4FCC: 394AAE18  addi r10, r10, -0x51e8
	ctx.r[10].s64 = ctx.r[10].s64 + -20968;
	// 826E4FD0: 3929ADCC  addi r9, r9, -0x5234
	ctx.r[9].s64 = ctx.r[9].s64 + -21044;
	// 826E4FD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E4FD8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E4FDC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E4FE0: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 826E4FE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4FE8: 419A0008  beq cr6, 0x826e4ff0
	if ctx.cr[6].eq {
	pc = 0x826E4FF0; continue 'dispatch;
	}
	// 826E4FEC: 4BBDB8A5  bl 0x822c0890
	ctx.lr = 0x826E4FF0;
	sub_822C0890(ctx, base);
	// 826E4FF0: 807F01F4  lwz r3, 0x1f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 826E4FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E4FF8: 419A0008  beq cr6, 0x826e5000
	if ctx.cr[6].eq {
	pc = 0x826E5000; continue 'dispatch;
	}
	// 826E4FFC: 4BBDB895  bl 0x822c0890
	ctx.lr = 0x826E5000;
	sub_822C0890(ctx, base);
	// 826E5000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5004: 4BFBCD85  bl 0x826a1d88
	ctx.lr = 0x826E5008;
	sub_826A1D88(ctx, base);
	// 826E5008: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E500C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E5018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E5020 size=8
    let mut pc: u32 = 0x826E5020;
    'dispatch: loop {
        match pc {
            0x826E5020 => {
    //   block [0x826E5020..0x826E5028)
	// 826E5020: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E5024: 4800022C  b 0x826e5250
	sub_826E5250(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E5028 size=8
    let mut pc: u32 = 0x826E5028;
    'dispatch: loop {
        match pc {
            0x826E5028 => {
    //   block [0x826E5028..0x826E5030)
	// 826E5028: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E502C: 48000224  b 0x826e5250
	sub_826E5250(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5030 size=272
    let mut pc: u32 = 0x826E5030;
    'dispatch: loop {
        match pc {
            0x826E5030 => {
    //   block [0x826E5030..0x826E5140)
	// 826E5030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E503C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5040: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5044: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E5048: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E504C: 897E0240  lbz r11, 0x240(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(576 as u32) ) } as u64;
	// 826E5050: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 826E5054: 4BE2CA95  bl 0x82511ae8
	ctx.lr = 0x826E5058;
	sub_82511AE8(ctx, base);
	// 826E5058: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 826E505C: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826E5060: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E5064: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 826E5068: 390ADFEC  addi r8, r10, -0x2014
	ctx.r[8].s64 = ctx.r[10].s64 + -8212;
	// 826E506C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5140 size=72
    let mut pc: u32 = 0x826E5140;
    'dispatch: loop {
        match pc {
            0x826E5140 => {
    //   block [0x826E5140..0x826E5188)
	// 826E5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5148: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E514C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 826E5150: 419A001C  beq cr6, 0x826e516c
	if ctx.cr[6].eq {
	pc = 0x826E516C; continue 'dispatch;
	}
	// 826E5154: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826E5158: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826E515C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 826E5160: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E5164: 4BFFFC65  bl 0x826e4dc8
	ctx.lr = 0x826E5168;
	sub_826E4DC8(ctx, base);
	// 826E5168: 48000010  b 0x826e5178
	pc = 0x826E5178; continue 'dispatch;
	// 826E516C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E5170: 396BE050  addi r11, r11, -0x1fb0
	ctx.r[11].s64 = ctx.r[11].s64 + -8112;
	// 826E5174: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E5178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E517C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5188 size=196
    let mut pc: u32 = 0x826E5188;
    'dispatch: loop {
        match pc {
            0x826E5188 => {
    //   block [0x826E5188..0x826E524C)
	// 826E5188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E518C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5194: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5198: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826E519C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E51A0: 4BFBD011  bl 0x826a21b0
	ctx.lr = 0x826E51A4;
	sub_826A21B0(ctx, base);
	// 826E51A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E51A8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E51AC: 396BAE2C  addi r11, r11, -0x51d4
	ctx.r[11].s64 = ctx.r[11].s64 + -20948;
	// 826E51B0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E51B4: 3929ADCC  addi r9, r9, -0x5234
	ctx.r[9].s64 = ctx.r[9].s64 + -21044;
	// 826E51B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E51BC: 394AAE18  addi r10, r10, -0x51e8
	ctx.r[10].s64 = ctx.r[10].s64 + -20968;
	// 826E51C0: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 826E51C4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E51C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E51CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E51D0: 39286910  addi r9, r8, 0x6910
	ctx.r[9].s64 = ctx.r[8].s64 + 26896;
	// 826E51D4: 917F01F0  stw r11, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 826E51D8: 39000210  li r8, 0x210
	ctx.r[8].s64 = 528;
	// 826E51DC: 917F01F4  stw r11, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 826E51E0: 38E00220  li r7, 0x220
	ctx.r[7].s64 = 544;
	// 826E51E4: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 826E51E8: 38C00230  li r6, 0x230
	ctx.r[6].s64 = 560;
	// 826E51EC: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 826E51F0: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 826E51F4: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 826E51F8: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 826E51FC: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E5200: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5250 size=76
    let mut pc: u32 = 0x826E5250;
    'dispatch: loop {
        match pc {
            0x826E5250 => {
    //   block [0x826E5250..0x826E529C)
	// 826E5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E525C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5268: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E526C: 4BFFFD3D  bl 0x826e4fa8
	ctx.lr = 0x826E5270;
	sub_826E4FA8(ctx, base);
	// 826E5270: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5274: 4182000C  beq 0x826e5280
	if ctx.cr[0].eq {
	pc = 0x826E5280; continue 'dispatch;
	}
	// 826E5278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E527C: 4870D15D  bl 0x82df23d8
	ctx.lr = 0x826E5280;
	sub_82DF23D8(ctx, base);
	// 826E5280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5284: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E5288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E528C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5290: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E5294: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E5298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E52A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E52A0 size=260
    let mut pc: u32 = 0x826E52A0;
    'dispatch: loop {
        match pc {
            0x826E52A0 => {
    //   block [0x826E52A0..0x826E53A4)
	// 826E52A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E52A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E52A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E52AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E52B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E52B4: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E52B8: 807F01F0  lwz r3, 0x1f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 826E52BC: 4182007C  beq 0x826e5338
	if ctx.cr[0].eq {
	pc = 0x826E5338; continue 'dispatch;
	}
	// 826E52C0: 4BFA4639  bl 0x826898f8
	ctx.lr = 0x826E52C4;
	sub_826898F8(ctx, base);
	// 826E52C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E52C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E52CC: 38ABAAEC  addi r5, r11, -0x5514
	ctx.r[5].s64 = ctx.r[11].s64 + -21780;
	// 826E52D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E52D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E52D8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E52DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E52E0: 4E800421  bctrl
	ctx.lr = 0x826E52E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E52E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E52E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E52EC: 419A0008  beq cr6, 0x826e52f4
	if ctx.cr[6].eq {
	pc = 0x826E52F4; continue 'dispatch;
	}
	// 826E52F0: 4BBDB5A1  bl 0x822c0890
	ctx.lr = 0x826E52F4;
	sub_822C0890(ctx, base);
	// 826E52F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E52F8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E52FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5300: 38AAAAD4  addi r5, r10, -0x552c
	ctx.r[5].s64 = ctx.r[10].s64 + -21804;
	// 826E5304: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E5308: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826E530C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E5310: 4E800421  bctrl
	ctx.lr = 0x826E5314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E5314: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E5318: 395F01F8  addi r10, r31, 0x1f8
	ctx.r[10].s64 = ctx.r[31].s64 + 504;
	// 826E531C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E5320: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826E5324: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5328: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 826E532C: 4BBDF135  bl 0x822c4460
	ctx.lr = 0x826E5330;
	sub_822C4460(ctx, base);
	// 826E5330: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E5334: 48000050  b 0x826e5384
	pc = 0x826E5384; continue 'dispatch;
	// 826E5338: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E533C: 4BFA452D  bl 0x82689868
	ctx.lr = 0x826E5340;
	sub_82689868(ctx, base);
	// 826E5340: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826E5344: 397F01F8  addi r11, r31, 0x1f8
	ctx.r[11].s64 = ctx.r[31].s64 + 504;
	// 826E5348: 915F01F8  stw r10, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[10].u32 ) };
	// 826E534C: 807F01FC  lwz r3, 0x1fc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 826E5350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5354: 915F01FC  stw r10, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[10].u32 ) };
	// 826E5358: 419A0008  beq cr6, 0x826e5360
	if ctx.cr[6].eq {
	pc = 0x826E5360; continue 'dispatch;
	}
	// 826E535C: 4BBDB535  bl 0x822c0890
	ctx.lr = 0x826E5360;
	sub_822C0890(ctx, base);
	// 826E5360: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5364: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E5368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E536C: 38AAAAB8  addi r5, r10, -0x5548
	ctx.r[5].s64 = ctx.r[10].s64 + -21832;
	// 826E5370: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E5374: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E5378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E537C: 4E800421  bctrl
	ctx.lr = 0x826E5380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E5380: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E5384: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5388: 419A0008  beq cr6, 0x826e5390
	if ctx.cr[6].eq {
	pc = 0x826E5390; continue 'dispatch;
	}
	// 826E538C: 4BBDB505  bl 0x822c0890
	ctx.lr = 0x826E5390;
	sub_822C0890(ctx, base);
	// 826E5390: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E5394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E539C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E53A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E53A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E53A8 size=20
    let mut pc: u32 = 0x826E53A8;
    'dispatch: loop {
        match pc {
            0x826E53A8 => {
    //   block [0x826E53A8..0x826E53BC)
	// 826E53A8: 8164015C  lwz r11, 0x15c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(348 as u32) ) } as u64;
	// 826E53AC: 39240158  addi r9, r4, 0x158
	ctx.r[9].s64 = ctx.r[4].s64 + 344;
	// 826E53B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E53B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826E53B8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E53BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826E53BC size=92
    let mut pc: u32 = 0x826E53BC;
    'dispatch: loop {
        match pc {
            0x826E53BC => {
    //   block [0x826E53BC..0x826E5418)
	// 826E53BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E53C0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E53C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E53C8: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 826E53CC: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E53D0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 826E53D4: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 826E53D8: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 826E53DC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E53E0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826E53E4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826E53E8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826E53EC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 826E53F0: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 826E53F4: D161FFF4  stfs f11, -0xc(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 826E53F8: D181FFF8  stfs f12, -8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 826E53FC: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5418 size=328
    let mut pc: u32 = 0x826E5418;
    'dispatch: loop {
        match pc {
            0x826E5418 => {
    //   block [0x826E5418..0x826E5560)
	// 826E5418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E541C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E5424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5428: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826E542C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826E5430: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826E5434: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E543C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E5440: 419A00FC  beq cr6, 0x826e553c
	if ctx.cr[6].eq {
	pc = 0x826E553C; continue 'dispatch;
	}
	// 826E5444: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E5448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E544C: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826E5450: 4870E5B9  bl 0x82df3a08
	ctx.lr = 0x826E5454;
	sub_82DF3A08(ctx, base);
	// 826E5454: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E5458: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E545C: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826E5460: 4870E5A9  bl 0x82df3a08
	ctx.lr = 0x826E5464;
	sub_82DF3A08(ctx, base);
	// 826E5464: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E5468: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E546C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826E5470: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826E5474: 3BCBDFEC  addi r30, r11, -0x2014
	ctx.r[30].s64 = ctx.r[11].s64 + -8212;
	// 826E5478: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E547C: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E5480: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E5484: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E5488: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E548C: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826E5490: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E5494: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E5498: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E549C: 4BEBDE0D  bl 0x825a32a8
	ctx.lr = 0x826E54A0;
	sub_825A32A8(ctx, base);
	// 826E54A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E54A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E54A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E54AC: 4BEBC2C5  bl 0x825a1770
	ctx.lr = 0x826E54B0;
	sub_825A1770(ctx, base);
	// 826E54B0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E54B4: 4870DF75  bl 0x82df3428
	ctx.lr = 0x826E54B8;
	sub_82DF3428(ctx, base);
	// 826E54B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E54BC: 4BBE37FD  bl 0x822c8cb8
	ctx.lr = 0x826E54C0;
	sub_822C8CB8(ctx, base);
	// 826E54C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E54C4: 4870DF65  bl 0x82df3428
	ctx.lr = 0x826E54C8;
	sub_82DF3428(ctx, base);
	// 826E54C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E54CC: 4870DF5D  bl 0x82df3428
	ctx.lr = 0x826E54D0;
	sub_82DF3428(ctx, base);
	// 826E54D0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E54D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E54D8: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 826E54DC: 4870E52D  bl 0x82df3a08
	ctx.lr = 0x826E54E0;
	sub_82DF3A08(ctx, base);
	// 826E54E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E54E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E54E8: 388BAB0C  addi r4, r11, -0x54f4
	ctx.r[4].s64 = ctx.r[11].s64 + -21748;
	// 826E54EC: 4870E51D  bl 0x82df3a08
	ctx.lr = 0x826E54F0;
	sub_82DF3A08(ctx, base);
	// 826E54F0: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 826E54F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E54F8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E54FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826E5500: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E5504: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E5508: 4BEBDDA1  bl 0x825a32a8
	ctx.lr = 0x826E550C;
	sub_825A32A8(ctx, base);
	// 826E550C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E5510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5518: 4BEBC259  bl 0x825a1770
	ctx.lr = 0x826E551C;
	sub_825A1770(ctx, base);
	// 826E551C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826E5520: 4870DF09  bl 0x82df3428
	ctx.lr = 0x826E5524;
	sub_82DF3428(ctx, base);
	// 826E5524: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E5528: 4BBE3791  bl 0x822c8cb8
	ctx.lr = 0x826E552C;
	sub_822C8CB8(ctx, base);
	// 826E552C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5530: 4870DEF9  bl 0x82df3428
	ctx.lr = 0x826E5534;
	sub_82DF3428(ctx, base);
	// 826E5534: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5538: 4870DEF1  bl 0x82df3428
	ctx.lr = 0x826E553C;
	sub_82DF3428(ctx, base);
	// 826E553C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826E5540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5548: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826E554C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826E5550: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826E5554: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E5558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E555C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5560 size=416
    let mut pc: u32 = 0x826E5560;
    'dispatch: loop {
        match pc {
            0x826E5560 => {
    //   block [0x826E5560..0x826E5700)
	// 826E5560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E556C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5570: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826E5574: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826E5578: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826E557C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E5588: 4BFBC941  bl 0x826a1ec8
	ctx.lr = 0x826E558C;
	sub_826A1EC8(ctx, base);
	// 826E558C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E5590: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5594: 388BD300  addi r4, r11, -0x2d00
	ctx.r[4].s64 = ctx.r[11].s64 + -11520;
	// 826E5598: 4870E471  bl 0x82df3a08
	ctx.lr = 0x826E559C;
	sub_82DF3A08(ctx, base);
	// 826E559C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E55A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E55A4: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 826E55A8: 4870E461  bl 0x82df3a08
	ctx.lr = 0x826E55AC;
	sub_82DF3A08(ctx, base);
	// 826E55AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E55B0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826E55B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E55B8: 38BF0160  addi r5, r31, 0x160
	ctx.r[5].s64 = ctx.r[31].s64 + 352;
	// 826E55BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E55C0: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E55C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826E55C8: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826E55CC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E55D0: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826E55D4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E55D8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E55DC: 4BEBDCCD  bl 0x825a32a8
	ctx.lr = 0x826E55E0;
	sub_825A32A8(ctx, base);
	// 826E55E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E55E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E55E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E55EC: 4BEBC185  bl 0x825a1770
	ctx.lr = 0x826E55F0;
	sub_825A1770(ctx, base);
	// 826E55F0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826E55F4: 4870DE35  bl 0x82df3428
	ctx.lr = 0x826E55F8;
	sub_82DF3428(ctx, base);
	// 826E55F8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826E55FC: 4BBE36BD  bl 0x822c8cb8
	ctx.lr = 0x826E5600;
	sub_822C8CB8(ctx, base);
	// 826E5600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5604: 4870DE25  bl 0x82df3428
	ctx.lr = 0x826E5608;
	sub_82DF3428(ctx, base);
	// 826E5608: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E560C: 4870DE1D  bl 0x82df3428
	ctx.lr = 0x826E5610;
	sub_82DF3428(ctx, base);
	// 826E5610: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826E5614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5618: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 826E561C: 4870E3ED  bl 0x82df3a08
	ctx.lr = 0x826E5620;
	sub_82DF3A08(ctx, base);
	// 826E5620: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E5624: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5628: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 826E562C: 4870E3DD  bl 0x82df3a08
	ctx.lr = 0x826E5630;
	sub_82DF3A08(ctx, base);
	// 826E5630: 38BF0164  addi r5, r31, 0x164
	ctx.r[5].s64 = ctx.r[31].s64 + 356;
	// 826E5634: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5638: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826E563C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826E5640: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826E5644: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826E5648: 4BEBDC61  bl 0x825a32a8
	ctx.lr = 0x826E564C;
	sub_825A32A8(ctx, base);
	// 826E564C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E5650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E5654: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E5658: 4BEBC119  bl 0x825a1770
	ctx.lr = 0x826E565C;
	sub_825A1770(ctx, base);
	// 826E565C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826E5660: 4870DDC9  bl 0x82df3428
	ctx.lr = 0x826E5664;
	sub_82DF3428(ctx, base);
	// 826E5664: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826E5668: 4BBE3651  bl 0x822c8cb8
	ctx.lr = 0x826E566C;
	sub_822C8CB8(ctx, base);
	// 826E566C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5670: 4870DDB9  bl 0x82df3428
	ctx.lr = 0x826E5674;
	sub_82DF3428(ctx, base);
	// 826E5674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5678: 4870DDB1  bl 0x82df3428
	ctx.lr = 0x826E567C;
	sub_82DF3428(ctx, base);
	// 826E567C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E5680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5684: 388B8674  addi r4, r11, -0x798c
	ctx.r[4].s64 = ctx.r[11].s64 + -31116;
	// 826E5688: 4870E381  bl 0x82df3a08
	ctx.lr = 0x826E568C;
	sub_82DF3A08(ctx, base);
	// 826E568C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E5690: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5694: 388BAD24  addi r4, r11, -0x52dc
	ctx.r[4].s64 = ctx.r[11].s64 + -21212;
	// 826E5698: 4870E371  bl 0x82df3a08
	ctx.lr = 0x826E569C;
	sub_82DF3A08(ctx, base);
	// 826E569C: 38BF0168  addi r5, r31, 0x168
	ctx.r[5].s64 = ctx.r[31].s64 + 360;
	// 826E56A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E56A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E56A8: 4BEBD9A9  bl 0x825a3050
	ctx.lr = 0x826E56AC;
	sub_825A3050(ctx, base);
	// 826E56AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E56B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E56B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E56B8: 4BEBCAD1  bl 0x825a2188
	ctx.lr = 0x826E56BC;
	sub_825A2188(ctx, base);
	// 826E56BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826E56C0: 4870DD69  bl 0x82df3428
	ctx.lr = 0x826E56C4;
	sub_82DF3428(ctx, base);
	// 826E56C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E56C8: 4BBE35F1  bl 0x822c8cb8
	ctx.lr = 0x826E56CC;
	sub_822C8CB8(ctx, base);
	// 826E56CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E56D0: 4870DD59  bl 0x82df3428
	ctx.lr = 0x826E56D4;
	sub_82DF3428(ctx, base);
	// 826E56D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E56D8: 4870DD51  bl 0x82df3428
	ctx.lr = 0x826E56DC;
	sub_82DF3428(ctx, base);
	// 826E56DC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826E56E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E56E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E56E8: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826E56EC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826E56F0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826E56F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E56F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E56FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5700 size=232
    let mut pc: u32 = 0x826E5700;
    'dispatch: loop {
        match pc {
            0x826E5700 => {
    //   block [0x826E5700..0x826E57E8)
	// 826E5700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5704: 48AC2A69  bl 0x831a816c
	ctx.lr = 0x826E5708;
	sub_831A8130(ctx, base);
	// 826E5708: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E570C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5710: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E5714: 4BFBCB7D  bl 0x826a2290
	ctx.lr = 0x826E5718;
	sub_826A2290(ctx, base);
	// 826E5718: 807F01BC  lwz r3, 0x1bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) } as u64;
	// 826E571C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826E5720: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826E5724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5728: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826E572C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E5730: 4E800421  bctrl
	ctx.lr = 0x826E5734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E5734: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E5738: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E573C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826E5740: 48796589  bl 0x82e7bcc8
	ctx.lr = 0x826E5744;
	sub_82E7BCC8(ctx, base);
	// 826E5744: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826E5748: 397F0220  addi r11, r31, 0x220
	ctx.r[11].s64 = ctx.r[31].s64 + 544;
	// 826E574C: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E5750: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E5754: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826E5758: 38E00230  li r7, 0x230
	ctx.r[7].s64 = 560;
	// 826E575C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E5760: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E5764: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E5768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E57E8 size=236
    let mut pc: u32 = 0x826E57E8;
    'dispatch: loop {
        match pc {
            0x826E57E8 => {
    //   block [0x826E57E8..0x826E58D4)
	// 826E57E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E57EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E57F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E57F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E57F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E57FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5804: 397F0210  addi r11, r31, 0x210
	ctx.r[11].s64 = ctx.r[31].s64 + 528;
	// 826E5808: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E580C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826E5810: 4BC379C1  bl 0x8231d1d0
	ctx.lr = 0x826E5814;
	sub_8231D1D0(ctx, base);
	// 826E5814: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5818: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E581C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E5820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E5824: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826E5828: 419A0024  beq cr6, 0x826e584c
	if ctx.cr[6].eq {
	pc = 0x826E584C; continue 'dispatch;
	}
	// 826E582C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E5830: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E5834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E5838: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E583C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E5840: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E5844: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E5848: 4082FFE8  bne 0x826e5830
	if !ctx.cr[0].eq {
	pc = 0x826E5830; continue 'dispatch;
	}
	// 826E584C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E5854: 4BE29C75  bl 0x8250f4c8
	ctx.lr = 0x826E5858;
	sub_8250F4C8(ctx, base);
	// 826E5858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E585C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E5860: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826E5864: 409A0008  bne cr6, 0x826e586c
	if !ctx.cr[6].eq {
	pc = 0x826E586C; continue 'dispatch;
	}
	// 826E5868: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E586C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E5870: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 826E5874: 4BE231A5  bl 0x82508a18
	ctx.lr = 0x826E5878;
	sub_82508A18(ctx, base);
	// 826E5878: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E587C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826E5880: 388BAE70  addi r4, r11, -0x5190
	ctx.r[4].s64 = ctx.r[11].s64 + -20880;
	// 826E5884: 38A000A3  li r5, 0xa3
	ctx.r[5].s64 = 163;
	// 826E5888: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826E588C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826E5890: 48771759  bl 0x82e56fe8
	ctx.lr = 0x826E5894;
	sub_82E56FE8(ctx, base);
	// 826E5894: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E5898: 4870C3F9  bl 0x82df1c90
	ctx.lr = 0x826E589C;
	sub_82DF1C90(ctx, base);
	// 826E589C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E58A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E58A4: 419A0008  beq cr6, 0x826e58ac
	if ctx.cr[6].eq {
	pc = 0x826E58AC; continue 'dispatch;
	}
	// 826E58A8: 4BBDAFE9  bl 0x822c0890
	ctx.lr = 0x826E58AC;
	sub_822C0890(ctx, base);
	// 826E58AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826E58B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E58B4: 419A0008  beq cr6, 0x826e58bc
	if ctx.cr[6].eq {
	pc = 0x826E58BC; continue 'dispatch;
	}
	// 826E58B8: 4BBDAFD9  bl 0x822c0890
	ctx.lr = 0x826E58BC;
	sub_822C0890(ctx, base);
	// 826E58BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826E58C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E58C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E58C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E58CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E58D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E58D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E58D8 size=424
    let mut pc: u32 = 0x826E58D8;
    'dispatch: loop {
        match pc {
            0x826E58D8 => {
    //   block [0x826E58D8..0x826E5A80)
	// 826E58D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E58DC: 48AC2889  bl 0x831a8164
	ctx.lr = 0x826E58E0;
	sub_831A8130(ctx, base);
	// 826E58E0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E58E4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E58E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E58EC: 3BCBAE70  addi r30, r11, -0x5190
	ctx.r[30].s64 = ctx.r[11].s64 + -20880;
	// 826E58F0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E58F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E58F8: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 826E58FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E5900: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E5904: 38600250  li r3, 0x250
	ctx.r[3].s64 = 592;
	// 826E5908: 4870CAE1  bl 0x82df23e8
	ctx.lr = 0x826E590C;
	sub_82DF23E8(ctx, base);
	// 826E590C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E5910: 41820010  beq 0x826e5920
	if ctx.cr[0].eq {
	pc = 0x826E5920; continue 'dispatch;
	}
	// 826E5914: 4BFFF875  bl 0x826e5188
	ctx.lr = 0x826E5918;
	sub_826E5188(ctx, base);
	// 826E5918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E591C: 48000008  b 0x826e5924
	pc = 0x826E5924; continue 'dispatch;
	// 826E5920: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E5924: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E5928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E592C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5930: 4BFFF5B1  bl 0x826e4ee0
	ctx.lr = 0x826E5934;
	sub_826E4EE0(ctx, base);
	// 826E5934: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E5938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E593C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E5940: 4BBDA6C1  bl 0x822c0000
	ctx.lr = 0x826E5944;
	sub_822C0000(ctx, base);
	// 826E5944: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E5948: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E594C: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 826E5950: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E5954: 4BBDAA85  bl 0x822c03d8
	ctx.lr = 0x826E5958;
	sub_822C03D8(ctx, base);
	// 826E5958: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E595C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E5960: 418200B4  beq 0x826e5a14
	if ctx.cr[0].eq {
	pc = 0x826E5A14; continue 'dispatch;
	}
	// 826E5964: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E5968: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E596C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E5970: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E5974: 409A0008  bne cr6, 0x826e597c
	if !ctx.cr[6].eq {
	pc = 0x826E597C; continue 'dispatch;
	}
	// 826E5978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E597C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E5980: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E5984: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E5988: 419A0024  beq cr6, 0x826e59ac
	if ctx.cr[6].eq {
	pc = 0x826E59AC; continue 'dispatch;
	}
	// 826E598C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E5990: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E5994: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E5998: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E599C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E59A0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E59A4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E59A8: 4082FFE8  bne 0x826e5990
	if !ctx.cr[0].eq {
	pc = 0x826E5990; continue 'dispatch;
	}
	// 826E59AC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E59B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E59B4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E59B8: 419A0024  beq cr6, 0x826e59dc
	if ctx.cr[6].eq {
	pc = 0x826E59DC; continue 'dispatch;
	}
	// 826E59BC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E59C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E59C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E59C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E59CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E59D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E59D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E59D8: 4082FFE8  bne 0x826e59c0
	if !ctx.cr[0].eq {
	pc = 0x826E59C0; continue 'dispatch;
	}
	// 826E59DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E59E0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E59E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E59E8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E59EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E59F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E59F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E59F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E59FC: 480B3535  bl 0x82798f30
	ctx.lr = 0x826E5A00;
	sub_82798F30(ctx, base);
	// 826E5A00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E5A04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5A08: 480B5C61  bl 0x8279b668
	ctx.lr = 0x826E5A0C;
	sub_8279B668(ctx, base);
	// 826E5A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5A10: 48000008  b 0x826e5a18
	pc = 0x826E5A18; continue 'dispatch;
	// 826E5A14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E5A18: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E5A1C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E5A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E5A28: 4BEB2229  bl 0x82597c50
	ctx.lr = 0x826E5A2C;
	sub_82597C50(ctx, base);
	// 826E5A2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E5A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E5A38: 4BBDA5C9  bl 0x822c0000
	ctx.lr = 0x826E5A3C;
	sub_822C0000(ctx, base);
	// 826E5A3C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5A40: 41820024  beq 0x826e5a64
	if ctx.cr[0].eq {
	pc = 0x826E5A64; continue 'dispatch;
	}
	// 826E5A44: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E5A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5A4C: 419A0008  beq cr6, 0x826e5a54
	if ctx.cr[6].eq {
	pc = 0x826E5A54; continue 'dispatch;
	}
	// 826E5A50: 4BBDAE41  bl 0x822c0890
	ctx.lr = 0x826E5A54;
	sub_822C0890(ctx, base);
	// 826E5A54: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E5A58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5A5C: 419A0008  beq cr6, 0x826e5a64
	if ctx.cr[6].eq {
	pc = 0x826E5A64; continue 'dispatch;
	}
	// 826E5A60: 4BBDAE31  bl 0x822c0890
	ctx.lr = 0x826E5A64;
	sub_822C0890(ctx, base);
	// 826E5A64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E5A68: 419A000C  beq cr6, 0x826e5a74
	if ctx.cr[6].eq {
	pc = 0x826E5A74; continue 'dispatch;
	}
	// 826E5A6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E5A70: 4BBDAE21  bl 0x822c0890
	ctx.lr = 0x826E5A74;
	sub_822C0890(ctx, base);
	// 826E5A74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E5A78: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E5A7C: 48AC2738  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5A80 size=128
    let mut pc: u32 = 0x826E5A80;
    'dispatch: loop {
        match pc {
            0x826E5A80 => {
    //   block [0x826E5A80..0x826E5B00)
	// 826E5A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5A84: 48AC26E9  bl 0x831a816c
	ctx.lr = 0x826E5A88;
	sub_831A8130(ctx, base);
	// 826E5A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5A8C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826E5A90: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826E5A94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E5A98: 3BEB8288  addi r31, r11, -0x7d78
	ctx.r[31].s64 = ctx.r[11].s64 + -32120;
	// 826E5A9C: 816A8290  lwz r11, -0x7d70(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32112 as u32) ) } as u64;
	// 826E5AA0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826E5AA4: 40820024  bne 0x826e5ac8
	if !ctx.cr[0].eq {
	pc = 0x826E5AC8; continue 'dispatch;
	}
	// 826E5AA8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 826E5AAC: 3D00826E  lis r8, -0x7d92
	ctx.r[8].s64 = -2106720256;
	// 826E5AB0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826E5AB4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 826E5AB8: 39085140  addi r8, r8, 0x5140
	ctx.r[8].s64 = ctx.r[8].s64 + 20800;
	// 826E5ABC: 916A8290  stw r11, -0x7d70(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32112 as u32), ctx.r[11].u32 ) };
	// 826E5AC0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826E5AC4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826E5AC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826E5ACC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826E5AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5AD4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826E5AD8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826E5ADC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E5AE0: 4BF6EAE1  bl 0x826545c0
	ctx.lr = 0x826E5AE4;
	sub_826545C0(ctx, base);
	// 826E5AE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5AE8: 4182000C  beq 0x826e5af4
	if ctx.cr[0].eq {
	pc = 0x826E5AF4; continue 'dispatch;
	}
	// 826E5AEC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E5AF0: 48000008  b 0x826e5af8
	pc = 0x826E5AF8; continue 'dispatch;
	// 826E5AF4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826E5AF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E5AFC: 48AC26C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5B00 size=96
    let mut pc: u32 = 0x826E5B00;
    'dispatch: loop {
        match pc {
            0x826E5B00 => {
    //   block [0x826E5B00..0x826E5B60)
	// 826E5B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E5B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5B10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5B14: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E5B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5B1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E5B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5B24: 388BAD94  addi r4, r11, -0x526c
	ctx.r[4].s64 = ctx.r[11].s64 + -21100;
	// 826E5B28: 4870DEE1  bl 0x82df3a08
	ctx.lr = 0x826E5B2C;
	sub_82DF3A08(ctx, base);
	// 826E5B2C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E5B30: 38BF0241  addi r5, r31, 0x241
	ctx.r[5].s64 = ctx.r[31].s64 + 577;
	// 826E5B34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5B38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5B3C: 4BF1254D  bl 0x825f8088
	ctx.lr = 0x826E5B40;
	sub_825F8088(ctx, base);
	// 826E5B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E5B44: 4870D8E5  bl 0x82df3428
	ctx.lr = 0x826E5B48;
	sub_82DF3428(ctx, base);
	// 826E5B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E5B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5B54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E5B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E5B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5B60 size=800
    let mut pc: u32 = 0x826E5B60;
    'dispatch: loop {
        match pc {
            0x826E5B60 => {
    //   block [0x826E5B60..0x826E5E80)
	// 826E5B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5B64: 48AC25FD  bl 0x831a8160
	ctx.lr = 0x826E5B68;
	sub_831A8130(ctx, base);
	// 826E5B68: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 826E5B6C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5B70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E5B74: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 826E5B78: 4BFBD291  bl 0x826a2e08
	ctx.lr = 0x826E5B7C;
	sub_826A2E08(ctx, base);
	// 826E5B7C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E5B80: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826E5B84: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826E5B88: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826E5B8C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E5B90: 487BABA1  bl 0x82ea0730
	ctx.lr = 0x826E5B94;
	sub_82EA0730(ctx, base);
	// 826E5B94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 826E5B98: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 826E5B9C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 826E5BA0: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 826E5BA4: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 826E5BA8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E5BAC: C01E01D8  lfs f0, 0x1d8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(472 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E5BB0: C04BF614  lfs f2, -0x9ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826E5BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E5BB8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 826E5BBC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826E5BC0: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826E5BC4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826E5BC8: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826E5BCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E5BD0: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826E5BD4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826E5BD8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826E5BDC: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826E5BE0: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E5BE4: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5E80 size=80
    let mut pc: u32 = 0x826E5E80;
    'dispatch: loop {
        match pc {
            0x826E5E80 => {
    //   block [0x826E5E80..0x826E5ED0)
	// 826E5E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5E88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5E8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5E90: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826E5E94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E5E98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826E5E9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5EA0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E5EA4: 4BDCF335  bl 0x824b51d8
	ctx.lr = 0x826E5EA8;
	sub_824B51D8(ctx, base);
	// 826E5EA8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 826E5EAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E5EB0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E5EB4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826E5EB8: 4BDCF321  bl 0x824b51d8
	ctx.lr = 0x826E5EBC;
	sub_824B51D8(ctx, base);
	// 826E5EBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E5EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E5EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E5EC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E5ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E5ED0 size=220
    let mut pc: u32 = 0x826E5ED0;
    'dispatch: loop {
        match pc {
            0x826E5ED0 => {
    //   block [0x826E5ED0..0x826E5FAC)
	// 826E5ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5ED4: 48AC2295  bl 0x831a8168
	ctx.lr = 0x826E5ED8;
	sub_831A8130(ctx, base);
	// 826E5ED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5EDC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826E5EE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E5EE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E5EE8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826E5EEC: 41820038  beq 0x826e5f24
	if ctx.cr[0].eq {
	pc = 0x826E5F24; continue 'dispatch;
	}
	// 826E5EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5EF4: 48AC3A95  bl 0x831a9988
	ctx.lr = 0x826E5EF8;
	sub_831A9988(ctx, base);
	// 826E5EF8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E5EFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E5F00: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826E5F04: 48AC21F5  bl 0x831a80f8
	ctx.lr = 0x826E5F08;
	sub_831A80F8(ctx, base);
	// 826E5F08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5F0C: 41820018  beq 0x826e5f24
	if ctx.cr[0].eq {
	pc = 0x826E5F24; continue 'dispatch;
	}
	// 826E5F10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5F14: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E5F18: 4BFFFF69  bl 0x826e5e80
	ctx.lr = 0x826E5F1C;
	sub_826E5E80(ctx, base);
	// 826E5F1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E5F20: 48000084  b 0x826e5fa4
	pc = 0x826E5FA4; continue 'dispatch;
	// 826E5F24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E5F28: 419A006C  beq cr6, 0x826e5f94
	if ctx.cr[6].eq {
	pc = 0x826E5F94; continue 'dispatch;
	}
	// 826E5F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5F30: 48AC3A59  bl 0x831a9988
	ctx.lr = 0x826E5F34;
	sub_831A9988(ctx, base);
	// 826E5F34: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E5F38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E5F3C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826E5F40: 48AC21B9  bl 0x831a80f8
	ctx.lr = 0x826E5F44;
	sub_831A80F8(ctx, base);
	// 826E5F44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5F48: 41820014  beq 0x826e5f5c
	if ctx.cr[0].eq {
	pc = 0x826E5F5C; continue 'dispatch;
	}
	// 826E5F4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5F50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E5F54: 4BFFEE4D  bl 0x826e4da0
	ctx.lr = 0x826E5F58;
	sub_826E4DA0(ctx, base);
	// 826E5F58: 4BFFFFC4  b 0x826e5f1c
	pc = 0x826E5F1C; continue 'dispatch;
	// 826E5F5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E5F60: 419A0034  beq cr6, 0x826e5f94
	if ctx.cr[6].eq {
	pc = 0x826E5F94; continue 'dispatch;
	}
	// 826E5F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E5F68: 48AC3A21  bl 0x831a9988
	ctx.lr = 0x826E5F6C;
	sub_831A9988(ctx, base);
	// 826E5F6C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E5F70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E5F74: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 826E5F78: 48AC2181  bl 0x831a80f8
	ctx.lr = 0x826E5F7C;
	sub_831A80F8(ctx, base);
	// 826E5F7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E5F80: 41820014  beq 0x826e5f94
	if ctx.cr[0].eq {
	pc = 0x826E5F94; continue 'dispatch;
	}
	// 826E5F84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5F88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E5F8C: 4BFFF0A5  bl 0x826e5030
	ctx.lr = 0x826E5F90;
	sub_826E5030(ctx, base);
	// 826E5F90: 4BFFFF8C  b 0x826e5f1c
	pc = 0x826E5F1C; continue 'dispatch;
	// 826E5F94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826E5F98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E5F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E5FA0: 4BFBBB11  bl 0x826a1ab0
	ctx.lr = 0x826E5FA4;
	sub_826A1AB0(ctx, base);
	// 826E5FA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E5FA8: 48AC2210  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E5FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E5FB0 size=96
    let mut pc: u32 = 0x826E5FB0;
    'dispatch: loop {
        match pc {
            0x826E5FB0 => {
    //   block [0x826E5FB0..0x826E6010)
	// 826E5FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E5FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E5FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E5FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E5FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E5FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E5FC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E5FCC: 4BE2A73D  bl 0x82510708
	ctx.lr = 0x826E5FD0;
	sub_82510708(ctx, base);
	// 826E5FD0: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E5FD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5FD8: 419A000C  beq cr6, 0x826e5fe4
	if ctx.cr[6].eq {
	pc = 0x826E5FE4; continue 'dispatch;
	}
	// 826E5FDC: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E5FE0: 480E5539  bl 0x827cb518
	ctx.lr = 0x826E5FE4;
	sub_827CB518(ctx, base);
	// 826E5FE4: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E5FE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E5FEC: 419A000C  beq cr6, 0x826e5ff8
	if ctx.cr[6].eq {
	pc = 0x826E5FF8; continue 'dispatch;
	}
	// 826E5FF0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E5FF4: 480E5525  bl 0x827cb518
	ctx.lr = 0x826E5FF8;
	sub_827CB518(ctx, base);
	// 826E5FF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E5FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E6000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E6004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E6008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E600C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6010 size=196
    let mut pc: u32 = 0x826E6010;
    'dispatch: loop {
        match pc {
            0x826E6010 => {
    //   block [0x826E6010..0x826E60D4)
	// 826E6010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E6018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E601C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E6020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E6028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E602C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E6030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E6034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E6038: 4BBDA901  bl 0x822c0938
	ctx.lr = 0x826E603C;
	sub_822C0938(ctx, base);
	// 826E603C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6040: 41820028  beq 0x826e6068
	if ctx.cr[0].eq {
	pc = 0x826E6068; continue 'dispatch;
	}
	// 826E6044: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E604C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E6050: 392BB0EC  addi r9, r11, -0x4f14
	ctx.r[9].s64 = ctx.r[11].s64 + -20244;
	// 826E6054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E6058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E605C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E6060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E6064: 48000008  b 0x826e606c
	pc = 0x826E606C; continue 'dispatch;
	// 826E6068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E606C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E6070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E6074: 409A0044  bne cr6, 0x826e60b8
	if !ctx.cr[6].eq {
	pc = 0x826E60B8; continue 'dispatch;
	}
	// 826E6078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E607C: 419A001C  beq cr6, 0x826e6098
	if ctx.cr[6].eq {
	pc = 0x826E6098; continue 'dispatch;
	}
	// 826E6080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6084: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E6088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E608C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E6094: 4E800421  bctrl
	ctx.lr = 0x826E6098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E6098: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E609C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E60A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E60A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E60A8: 816BE19C  lwz r11, -0x1e64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7780 as u32) ) } as u64;
	// 826E60AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E60B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E60B4: 4BBD9F4D  bl 0x822c0000
	ctx.lr = 0x826E60B8;
	sub_822C0000(ctx, base);
	// 826E60B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E60BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E60C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E60C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E60C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E60CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E60D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E60D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E60D8 size=196
    let mut pc: u32 = 0x826E60D8;
    'dispatch: loop {
        match pc {
            0x826E60D8 => {
    //   block [0x826E60D8..0x826E619C)
	// 826E60D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E60DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E60E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E60E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E60E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E60EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E60F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E60F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E60F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E60FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E6100: 4BBDA839  bl 0x822c0938
	ctx.lr = 0x826E6104;
	sub_822C0938(ctx, base);
	// 826E6104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6108: 41820028  beq 0x826e6130
	if ctx.cr[0].eq {
	pc = 0x826E6130; continue 'dispatch;
	}
	// 826E610C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6110: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E6114: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E6118: 392BB100  addi r9, r11, -0x4f00
	ctx.r[9].s64 = ctx.r[11].s64 + -20224;
	// 826E611C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E6120: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E6124: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E6128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E612C: 48000008  b 0x826e6134
	pc = 0x826E6134; continue 'dispatch;
	// 826E6130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E6134: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E6138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E613C: 409A0044  bne cr6, 0x826e6180
	if !ctx.cr[6].eq {
	pc = 0x826E6180; continue 'dispatch;
	}
	// 826E6140: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E6144: 419A001C  beq cr6, 0x826e6160
	if ctx.cr[6].eq {
	pc = 0x826E6160; continue 'dispatch;
	}
	// 826E6148: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E614C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E6150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6154: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E615C: 4E800421  bctrl
	ctx.lr = 0x826E6160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E6160: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E6164: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E6168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E616C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E6170: 816BE19C  lwz r11, -0x1e64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7780 as u32) ) } as u64;
	// 826E6174: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E6178: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E617C: 4BBD9E85  bl 0x822c0000
	ctx.lr = 0x826E6180;
	sub_822C0000(ctx, base);
	// 826E6180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E6184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E6188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E618C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E6190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E6194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E6198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E61A0 size=112
    let mut pc: u32 = 0x826E61A0;
    'dispatch: loop {
        match pc {
            0x826E61A0 => {
    //   block [0x826E61A0..0x826E6210)
	// 826E61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E61A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E61A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E61AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E61B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E61B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E61B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E61BC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826E61C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E61C4: 4BFFFF15  bl 0x826e60d8
	ctx.lr = 0x826E61C8;
	sub_826E60D8(ctx, base);
	// 826E61C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E61CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E61D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E61D4: 4BBD9E2D  bl 0x822c0000
	ctx.lr = 0x826E61D8;
	sub_822C0000(ctx, base);
	// 826E61D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E61DC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E61E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E61E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E61E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E61EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E61F0: 419A0008  beq cr6, 0x826e61f8
	if ctx.cr[6].eq {
	pc = 0x826E61F8; continue 'dispatch;
	}
	// 826E61F4: 4BBDA69D  bl 0x822c0890
	ctx.lr = 0x826E61F8;
	sub_822C0890(ctx, base);
	// 826E61F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E61FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E6200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E6204: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E6208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E620C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6210 size=160
    let mut pc: u32 = 0x826E6210;
    'dispatch: loop {
        match pc {
            0x826E6210 => {
    //   block [0x826E6210..0x826E62B0)
	// 826E6210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E6218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E621C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6224: 4BFE43CD  bl 0x826ca5f0
	ctx.lr = 0x826E6228;
	sub_826CA5F0(ctx, base);
	// 826E6228: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E622C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E6230: 396BB174  addi r11, r11, -0x4e8c
	ctx.r[11].s64 = ctx.r[11].s64 + -20108;
	// 826E6234: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E6238: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E623C: 394AB160  addi r10, r10, -0x4ea0
	ctx.r[10].s64 = ctx.r[10].s64 + -20128;
	// 826E6240: 3929B114  addi r9, r9, -0x4eec
	ctx.r[9].s64 = ctx.r[9].s64 + -20204;
	// 826E6244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E6248: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E624C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E6250: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 826E6254: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826E6258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E625C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826E6260: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826E6264: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826E6268: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826E626C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826E6270: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826E6274: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826E6278: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826E627C: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826E6280: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826E6284: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826E6288: 915F0118  stw r10, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[10].u32 ) };
	// 826E628C: 997F011C  stb r11, 0x11c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u8 ) };
	// 826E6290: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826E6294: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826E6298: 915F0128  stw r10, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[10].u32 ) };
	// 826E629C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E62A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E62A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E62A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E62AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E62B0 size=8
    let mut pc: u32 = 0x826E62B0;
    'dispatch: loop {
        match pc {
            0x826E62B0 => {
    //   block [0x826E62B0..0x826E62B8)
	// 826E62B0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E62B4: 480000C4  b 0x826e6378
	sub_826E6378(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E62B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E62B8 size=8
    let mut pc: u32 = 0x826E62B8;
    'dispatch: loop {
        match pc {
            0x826E62B8 => {
    //   block [0x826E62B8..0x826E62C0)
	// 826E62B8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E62BC: 480000BC  b 0x826e6378
	sub_826E6378(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E62C0 size=184
    let mut pc: u32 = 0x826E62C0;
    'dispatch: loop {
        match pc {
            0x826E62C0 => {
    //   block [0x826E62C0..0x826E6378)
	// 826E62C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E62C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E62C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E62CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E62D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E62D4: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826E62D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E62DC: 419A0008  beq cr6, 0x826e62e4
	if ctx.cr[6].eq {
	pc = 0x826E62E4; continue 'dispatch;
	}
	// 826E62E0: 4BBDA5B1  bl 0x822c0890
	ctx.lr = 0x826E62E4;
	sub_822C0890(ctx, base);
	// 826E62E4: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826E62E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E62EC: 419A0008  beq cr6, 0x826e62f4
	if ctx.cr[6].eq {
	pc = 0x826E62F4; continue 'dispatch;
	}
	// 826E62F0: 4BBDA5A1  bl 0x822c0890
	ctx.lr = 0x826E62F4;
	sub_822C0890(ctx, base);
	// 826E62F4: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826E62F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E62FC: 419A0018  beq cr6, 0x826e6314
	if ctx.cr[6].eq {
	pc = 0x826E6314; continue 'dispatch;
	}
	// 826E6300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6304: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E6308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E630C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E6310: 4E800421  bctrl
	ctx.lr = 0x826E6314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E6314: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826E6318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E631C: 419A0008  beq cr6, 0x826e6324
	if ctx.cr[6].eq {
	pc = 0x826E6324; continue 'dispatch;
	}
	// 826E6320: 4BBDA571  bl 0x822c0890
	ctx.lr = 0x826E6324;
	sub_822C0890(ctx, base);
	// 826E6324: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826E6328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E632C: 419A0008  beq cr6, 0x826e6334
	if ctx.cr[6].eq {
	pc = 0x826E6334; continue 'dispatch;
	}
	// 826E6330: 4BBDA561  bl 0x822c0890
	ctx.lr = 0x826E6334;
	sub_822C0890(ctx, base);
	// 826E6334: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826E6338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E633C: 419A0008  beq cr6, 0x826e6344
	if ctx.cr[6].eq {
	pc = 0x826E6344; continue 'dispatch;
	}
	// 826E6340: 4BBDA551  bl 0x822c0890
	ctx.lr = 0x826E6344;
	sub_822C0890(ctx, base);
	// 826E6344: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826E6348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E634C: 419A0008  beq cr6, 0x826e6354
	if ctx.cr[6].eq {
	pc = 0x826E6354; continue 'dispatch;
	}
	// 826E6350: 4BBDA541  bl 0x822c0890
	ctx.lr = 0x826E6354;
	sub_822C0890(ctx, base);
	// 826E6354: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826E6358: 480C1301  bl 0x827a7658
	ctx.lr = 0x826E635C;
	sub_827A7658(ctx, base);
	// 826E635C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6360: 4BC68FF1  bl 0x8234f350
	ctx.lr = 0x826E6364;
	sub_8234F350(ctx, base);
	// 826E6364: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E6368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E636C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E6370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E6374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6378 size=76
    let mut pc: u32 = 0x826E6378;
    'dispatch: loop {
        match pc {
            0x826E6378 => {
    //   block [0x826E6378..0x826E63C4)
	// 826E6378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E637C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E6380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E6384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E6388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E638C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6390: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E6394: 4BFFFF2D  bl 0x826e62c0
	ctx.lr = 0x826E6398;
	sub_826E62C0(ctx, base);
	// 826E6398: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E639C: 4182000C  beq 0x826e63a8
	if ctx.cr[0].eq {
	pc = 0x826E63A8; continue 'dispatch;
	}
	// 826E63A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E63A4: 4870C035  bl 0x82df23d8
	ctx.lr = 0x826E63A8;
	sub_82DF23D8(ctx, base);
	// 826E63A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E63AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E63B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E63B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E63B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E63BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E63C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E63C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E63C8 size=344
    let mut pc: u32 = 0x826E63C8;
    'dispatch: loop {
        match pc {
            0x826E63C8 => {
    //   block [0x826E63C8..0x826E6520)
	// 826E63C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E63CC: 48AC1D9D  bl 0x831a8168
	ctx.lr = 0x826E63D0;
	sub_831A8130(ctx, base);
	// 826E63D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E63D4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E63D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826E63DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826E63E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826E63E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E63E8: 388BB1D0  addi r4, r11, -0x4e30
	ctx.r[4].s64 = ctx.r[11].s64 + -20016;
	// 826E63EC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 826E63F0: 38A00099  li r5, 0x99
	ctx.r[5].s64 = 153;
	// 826E63F4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 826E63F8: 4BBD9FE1  bl 0x822c03d8
	ctx.lr = 0x826E63FC;
	sub_822C03D8(ctx, base);
	// 826E63FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E6400: 4182002C  beq 0x826e642c
	if ctx.cr[0].eq {
	pc = 0x826E642C; continue 'dispatch;
	}
	// 826E6404: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E640C: 388BB1B8  addi r4, r11, -0x4e48
	ctx.r[4].s64 = ctx.r[11].s64 + -20040;
	// 826E6410: 4870D5F9  bl 0x82df3a08
	ctx.lr = 0x826E6414;
	sub_82DF3A08(ctx, base);
	// 826E6414: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E6418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E641C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826E6420: 4BEC4569  bl 0x825aa988
	ctx.lr = 0x826E6424;
	sub_825AA988(ctx, base);
	// 826E6424: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6428: 48000008  b 0x826e6430
	pc = 0x826E6430; continue 'dispatch;
	// 826E642C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E6430: 3BFD003C  addi r31, r29, 0x3c
	ctx.r[31].s64 = ctx.r[29].s64 + 60;
	// 826E6434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6438: 4BF4F771  bl 0x82635ba8
	ctx.lr = 0x826E643C;
	sub_82635BA8(ctx, base);
	// 826E643C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E6440: 4182000C  beq 0x826e644c
	if ctx.cr[0].eq {
	pc = 0x826E644C; continue 'dispatch;
	}
	// 826E6444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6448: 4870CFE1  bl 0x82df3428
	ctx.lr = 0x826E644C;
	sub_82DF3428(ctx, base);
	// 826E644C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826E6450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6454: 388B1BC4  addi r4, r11, 0x1bc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7108;
	// 826E6458: 4870D5B1  bl 0x82df3a08
	ctx.lr = 0x826E645C;
	sub_82DF3A08(ctx, base);
	// 826E645C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E6460: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E6468: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826E646C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826E6470: 419A0024  beq cr6, 0x826e6494
	if ctx.cr[6].eq {
	pc = 0x826E6494; continue 'dispatch;
	}
	// 826E6474: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E6478: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E647C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6480: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E6484: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E6488: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E648C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6490: 4082FFE8  bne 0x826e6478
	if !ctx.cr[0].eq {
	pc = 0x826E6478; continue 'dispatch;
	}
	// 826E6494: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E6498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E649C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826E64A0: 4BEBBC71  bl 0x825a2110
	ctx.lr = 0x826E64A4;
	sub_825A2110(ctx, base);
	// 826E64A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E64A8: 4870CF81  bl 0x82df3428
	ctx.lr = 0x826E64AC;
	sub_82DF3428(ctx, base);
	// 826E64AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E64B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E64B4: 388BB1B0  addi r4, r11, -0x4e50
	ctx.r[4].s64 = ctx.r[11].s64 + -20048;
	// 826E64B8: 4870D551  bl 0x82df3a08
	ctx.lr = 0x826E64BC;
	sub_82DF3A08(ctx, base);
	// 826E64BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E64C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E64C4: 388B03D4  addi r4, r11, 0x3d4
	ctx.r[4].s64 = ctx.r[11].s64 + 980;
	// 826E64C8: 4870D541  bl 0x82df3a08
	ctx.lr = 0x826E64CC;
	sub_82DF3A08(ctx, base);
	// 826E64CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E64D0: 38E0012C  li r7, 0x12c
	ctx.r[7].s64 = 300;
	// 826E64D4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 826E64D8: 38BD0044  addi r5, r29, 0x44
	ctx.r[5].s64 = ctx.r[29].s64 + 68;
	// 826E64DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826E64E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E64E4: 4BEC76AD  bl 0x825adb90
	ctx.lr = 0x826E64E8;
	sub_825ADB90(ctx, base);
	// 826E64E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E64EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E64F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826E64F4: 4BEBB8C5  bl 0x825a1db8
	ctx.lr = 0x826E64F8;
	sub_825A1DB8(ctx, base);
	// 826E64F8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E64FC: 4870CF2D  bl 0x82df3428
	ctx.lr = 0x826E6500;
	sub_82DF3428(ctx, base);
	// 826E6500: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E6504: 4BBE27B5  bl 0x822c8cb8
	ctx.lr = 0x826E6508;
	sub_822C8CB8(ctx, base);
	// 826E6508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E650C: 4870CF1D  bl 0x82df3428
	ctx.lr = 0x826E6510;
	sub_82DF3428(ctx, base);
	// 826E6510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E6514: 4870CF15  bl 0x82df3428
	ctx.lr = 0x826E6518;
	sub_82DF3428(ctx, base);
	// 826E6518: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826E651C: 48AC1C9C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E6520 size=1656
    let mut pc: u32 = 0x826E6520;
    'dispatch: loop {
        match pc {
            0x826E6520 => {
    //   block [0x826E6520..0x826E6B98)
	// 826E6520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6524: 48AC1C21  bl 0x831a8144
	ctx.lr = 0x826E6528;
	sub_831A8130(ctx, base);
	// 826E6528: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 826E652C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6534: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 826E6538: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826E653C: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 826E6540: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826E6544: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 826E6548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E654C: 419A0640  beq cr6, 0x826e6b8c
	if ctx.cr[6].eq {
	pc = 0x826E6B8C; continue 'dispatch;
	}
	// 826E6550: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E6554: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826E6558: 40820450  bne 0x826e69a8
	if !ctx.cr[0].eq {
	pc = 0x826E69A8; continue 'dispatch;
	}
	// 826E655C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826E6560: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 826E6564: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826E6568: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826E656C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826E6570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E6574: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 826E6578: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 826E657C: 419A0024  beq cr6, 0x826e65a0
	if ctx.cr[6].eq {
	pc = 0x826E65A0; continue 'dispatch;
	}
	// 826E6580: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E6584: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E6588: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E658C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E6590: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E6594: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E6598: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E659C: 4082FFE8  bne 0x826e6584
	if !ctx.cr[0].eq {
	pc = 0x826E6584; continue 'dispatch;
	}
	// 826E65A0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E65A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E65A8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 826E65AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E65B0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826E65B4: 4BE29B0D  bl 0x825100c0
	ctx.lr = 0x826E65B8;
	sub_825100C0(ctx, base);
	// 826E65B8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826E65BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E65C0: 419A0008  beq cr6, 0x826e65c8
	if ctx.cr[6].eq {
	pc = 0x826E65C8; continue 'dispatch;
	}
	// 826E65C4: 4BBDA2CD  bl 0x822c0890
	ctx.lr = 0x826E65C8;
	sub_822C0890(ctx, base);
	// 826E65C8: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 826E65CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E65D0: 4BE2A0D9  bl 0x825106a8
	ctx.lr = 0x826E65D4;
	sub_825106A8(ctx, base);
	// 826E65D4: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 826E65D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E65DC: 92810078  stw r20, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[20].u32 ) };
	// 826E65E0: 9281007C  stw r20, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[20].u32 ) };
	// 826E65E4: 4BE2B7B5  bl 0x82511d98
	ctx.lr = 0x826E65E8;
	sub_82511D98(ctx, base);
	// 826E65E8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E65EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E65F0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826E65F4: 3B6BE148  addi r27, r11, -0x1eb8
	ctx.r[27].s64 = ctx.r[11].s64 + -7864;
	// 826E65F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E65FC: 3B5C0050  addi r26, r28, 0x50
	ctx.r[26].s64 = ctx.r[28].s64 + 80;
	// 826E6600: C00A964C  lfs f0, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E6604: 3ABC0040  addi r21, r28, 0x40
	ctx.r[21].s64 = ctx.r[28].s64 + 64;
	// 826E6608: C1A9A9F0  lfs f13, -0x5610(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E660C: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 826E6610: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826E6614: 3B00000F  li r24, 0xf
	ctx.r[24].s64 = 15;
	// 826E6618: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826E661C: 3ACBB1D0  addi r22, r11, -0x4e30
	ctx.r[22].s64 = ctx.r[11].s64 + -20016;
	// 826E6620: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826E6624: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E6628: 38A000D2  li r5, 0xd2
	ctx.r[5].s64 = 210;
	// 826E662C: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 826E6630: 4870BDB9  bl 0x82df23e8
	ctx.lr = 0x826E6634;
	sub_82DF23E8(ctx, base);
	// 826E6634: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826E6638: 41820054  beq 0x826e668c
	if ctx.cr[0].eq {
	pc = 0x826E668C; continue 'dispatch;
	}
	// 826E663C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6640: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6644: 4870D3C5  bl 0x82df3a08
	ctx.lr = 0x826E6648;
	sub_82DF3A08(ctx, base);
	// 826E6648: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E664C: 809B0050  lwz r4, 0x50(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E6650: 633D0001  ori r29, r25, 1
	ctx.r[29].u64 = ctx.r[25].u64 | 1;
	// 826E6654: 4870D3B5  bl 0x82df3a08
	ctx.lr = 0x826E6658;
	sub_82DF3A08(ctx, base);
	// 826E6658: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826E665C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6660: 63BD0002  ori r29, r29, 2
	ctx.r[29].u64 = ctx.r[29].u64 | 2;
	// 826E6664: 4870D3A5  bl 0x82df3a08
	ctx.lr = 0x826E6668;
	sub_82DF3A08(ctx, base);
	// 826E6668: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826E666C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826E6670: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 826E6674: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 826E6678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E667C: 63B90004  ori r25, r29, 4
	ctx.r[25].u64 = ctx.r[29].u64 | 4;
	// 826E6680: 4BFE5849  bl 0x826cbec8
	ctx.lr = 0x826E6684;
	sub_826CBEC8(ctx, base);
	// 826E6684: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6688: 48000008  b 0x826e6690
	pc = 0x826E6690; continue 'dispatch;
	// 826E668C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 826E6690: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E6694: 4BFFFB0D  bl 0x826e61a0
	ctx.lr = 0x826E6698;
	sub_826E61A0(ctx, base);
	// 826E6698: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E669C: 41820010  beq 0x826e66ac
	if ctx.cr[0].eq {
	pc = 0x826E66AC; continue 'dispatch;
	}
	// 826E66A0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 826E66A4: 573907B8  rlwinm r25, r25, 0, 0x1e, 0x1c
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826E66A8: 4870CD81  bl 0x82df3428
	ctx.lr = 0x826E66AC;
	sub_82DF3428(ctx, base);
	// 826E66AC: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E66B0: 41820010  beq 0x826e66c0
	if ctx.cr[0].eq {
	pc = 0x826E66C0; continue 'dispatch;
	}
	// 826E66B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E66B8: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826E66BC: 4870CD6D  bl 0x82df3428
	ctx.lr = 0x826E66C0;
	sub_82DF3428(ctx, base);
	// 826E66C0: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E66C4: 41820010  beq 0x826e66d4
	if ctx.cr[0].eq {
	pc = 0x826E66D4; continue 'dispatch;
	}
	// 826E66C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E66CC: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826E66D0: 4870CD59  bl 0x82df3428
	ctx.lr = 0x826E66D4;
	sub_82DF3428(ctx, base);
	// 826E66D4: 82E1007C  lwz r23, 0x7c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E66D8: 83A10078  lwz r29, 0x78(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 826E66DC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 826E66E0: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 826E66E4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826E66E8: 419A0024  beq cr6, 0x826e670c
	if ctx.cr[6].eq {
	pc = 0x826E670C; continue 'dispatch;
	}
	// 826E66EC: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 826E66F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E66F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E66F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E66FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E6700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E6704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6708: 4082FFE8  bne 0x826e66f0
	if !ctx.cr[0].eq {
	pc = 0x826E66F0; continue 'dispatch;
	}
	// 826E670C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6710: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E6714: 4BE28DB5  bl 0x8250f4c8
	ctx.lr = 0x826E6718;
	sub_8250F4C8(ctx, base);
	// 826E6718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E671C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E6720: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826E6724: 409A0008  bne cr6, 0x826e672c
	if !ctx.cr[6].eq {
	pc = 0x826E672C; continue 'dispatch;
	}
	// 826E6728: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 826E672C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6730: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826E6734: 3A610060  addi r19, r1, 0x60
	ctx.r[19].s64 = ctx.r[1].s64 + 96;
	// 826E6738: 4BE28DE1  bl 0x8250f518
	ctx.lr = 0x826E673C;
	sub_8250F518(ctx, base);
	// 826E673C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E6744: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 826E6748: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826E674C: 4BE26DBD  bl 0x8250d508
	ctx.lr = 0x826E6750;
	sub_8250D508(ctx, base);
	// 826E6750: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E6754: 4870B53D  bl 0x82df1c90
	ctx.lr = 0x826E6758;
	sub_82DF1C90(ctx, base);
	// 826E6758: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826E675C: 4870B535  bl 0x82df1c90
	ctx.lr = 0x826E6760;
	sub_82DF1C90(ctx, base);
	// 826E6760: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 826E6764: 13C0D0C7  vcmpequd (lvx128) v30, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E6768: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 826E676C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E6770: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E6774: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6B98 size=108
    let mut pc: u32 = 0x826E6B98;
    'dispatch: loop {
        match pc {
            0x826E6B98 => {
    //   block [0x826E6B98..0x826E6C04)
	// 826E6B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6B9C: 48AC15D1  bl 0x831a816c
	ctx.lr = 0x826E6BA0;
	sub_831A8130(ctx, base);
	// 826E6BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6BA4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826E6BA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826E6BAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E6BB0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E6BB4: 41820038  beq 0x826e6bec
	if ctx.cr[0].eq {
	pc = 0x826E6BEC; continue 'dispatch;
	}
	// 826E6BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6BBC: 48AC2DCD  bl 0x831a9988
	ctx.lr = 0x826E6BC0;
	sub_831A9988(ctx, base);
	// 826E6BC0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 826E6BC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6BC8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 826E6BCC: 48AC152D  bl 0x831a80f8
	ctx.lr = 0x826E6BD0;
	sub_831A80F8(ctx, base);
	// 826E6BD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E6BD4: 41820018  beq 0x826e6bec
	if ctx.cr[0].eq {
	pc = 0x826E6BEC; continue 'dispatch;
	}
	// 826E6BD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6BDC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 826E6BE0: 4BFFF941  bl 0x826e6520
	ctx.lr = 0x826E6BE4;
	sub_826E6520(ctx, base);
	// 826E6BE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E6BE8: 48000014  b 0x826e6bfc
	pc = 0x826E6BFC; continue 'dispatch;
	// 826E6BEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E6BF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6BF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E6BF8: 4BE2BA21  bl 0x82512618
	ctx.lr = 0x826E6BFC;
	sub_82512618(ctx, base);
	// 826E6BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E6C00: 48AC15BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E6C08 size=424
    let mut pc: u32 = 0x826E6C08;
    'dispatch: loop {
        match pc {
            0x826E6C08 => {
    //   block [0x826E6C08..0x826E6DB0)
	// 826E6C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6C0C: 48AC1559  bl 0x831a8164
	ctx.lr = 0x826E6C10;
	sub_831A8130(ctx, base);
	// 826E6C10: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6C14: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6C18: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E6C1C: 3BCBB1D0  addi r30, r11, -0x4e30
	ctx.r[30].s64 = ctx.r[11].s64 + -20016;
	// 826E6C20: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E6C24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E6C28: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 826E6C2C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E6C30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E6C34: 3860012C  li r3, 0x12c
	ctx.r[3].s64 = 300;
	// 826E6C38: 4870B7B1  bl 0x82df23e8
	ctx.lr = 0x826E6C3C;
	sub_82DF23E8(ctx, base);
	// 826E6C3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6C40: 41820010  beq 0x826e6c50
	if ctx.cr[0].eq {
	pc = 0x826E6C50; continue 'dispatch;
	}
	// 826E6C44: 4BFFF5CD  bl 0x826e6210
	ctx.lr = 0x826E6C48;
	sub_826E6210(ctx, base);
	// 826E6C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6C4C: 48000008  b 0x826e6c54
	pc = 0x826E6C54; continue 'dispatch;
	// 826E6C50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E6C54: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E6C58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6C5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E6C60: 4BFFF3B1  bl 0x826e6010
	ctx.lr = 0x826E6C64;
	sub_826E6010(ctx, base);
	// 826E6C64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E6C68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6C6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E6C70: 4BBD9391  bl 0x822c0000
	ctx.lr = 0x826E6C74;
	sub_822C0000(ctx, base);
	// 826E6C74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E6C78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E6C7C: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 826E6C80: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E6C84: 4BBD9755  bl 0x822c03d8
	ctx.lr = 0x826E6C88;
	sub_822C03D8(ctx, base);
	// 826E6C88: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E6C8C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E6C90: 418200B4  beq 0x826e6d44
	if ctx.cr[0].eq {
	pc = 0x826E6D44; continue 'dispatch;
	}
	// 826E6C94: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E6C98: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E6C9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E6CA0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E6CA4: 409A0008  bne cr6, 0x826e6cac
	if !ctx.cr[6].eq {
	pc = 0x826E6CAC; continue 'dispatch;
	}
	// 826E6CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E6CAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E6CB0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E6CB4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E6CB8: 419A0024  beq cr6, 0x826e6cdc
	if ctx.cr[6].eq {
	pc = 0x826E6CDC; continue 'dispatch;
	}
	// 826E6CBC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E6CC0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E6CC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6CC8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E6CCC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E6CD0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E6CD4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6CD8: 4082FFE8  bne 0x826e6cc0
	if !ctx.cr[0].eq {
	pc = 0x826E6CC0; continue 'dispatch;
	}
	// 826E6CDC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E6CE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E6CE4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E6CE8: 419A0024  beq cr6, 0x826e6d0c
	if ctx.cr[6].eq {
	pc = 0x826E6D0C; continue 'dispatch;
	}
	// 826E6CEC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E6CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E6CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6CF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E6CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E6D00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E6D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6D08: 4082FFE8  bne 0x826e6cf0
	if !ctx.cr[0].eq {
	pc = 0x826E6CF0; continue 'dispatch;
	}
	// 826E6D0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E6D10: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E6D14: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E6D18: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E6D1C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E6D20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E6D24: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E6D28: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E6D2C: 480B2205  bl 0x82798f30
	ctx.lr = 0x826E6D30;
	sub_82798F30(ctx, base);
	// 826E6D30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6D38: 480B4931  bl 0x8279b668
	ctx.lr = 0x826E6D3C;
	sub_8279B668(ctx, base);
	// 826E6D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6D40: 48000008  b 0x826e6d48
	pc = 0x826E6D48; continue 'dispatch;
	// 826E6D44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E6D48: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E6D4C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E6D50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E6D58: 4BEB0EF9  bl 0x82597c50
	ctx.lr = 0x826E6D5C;
	sub_82597C50(ctx, base);
	// 826E6D5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E6D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E6D68: 4BBD9299  bl 0x822c0000
	ctx.lr = 0x826E6D6C;
	sub_822C0000(ctx, base);
	// 826E6D6C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E6D70: 41820024  beq 0x826e6d94
	if ctx.cr[0].eq {
	pc = 0x826E6D94; continue 'dispatch;
	}
	// 826E6D74: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E6D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E6D7C: 419A0008  beq cr6, 0x826e6d84
	if ctx.cr[6].eq {
	pc = 0x826E6D84; continue 'dispatch;
	}
	// 826E6D80: 4BBD9B11  bl 0x822c0890
	ctx.lr = 0x826E6D84;
	sub_822C0890(ctx, base);
	// 826E6D84: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E6D88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E6D8C: 419A0008  beq cr6, 0x826e6d94
	if ctx.cr[6].eq {
	pc = 0x826E6D94; continue 'dispatch;
	}
	// 826E6D90: 4BBD9B01  bl 0x822c0890
	ctx.lr = 0x826E6D94;
	sub_822C0890(ctx, base);
	// 826E6D94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E6D98: 419A000C  beq cr6, 0x826e6da4
	if ctx.cr[6].eq {
	pc = 0x826E6DA4; continue 'dispatch;
	}
	// 826E6D9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E6DA0: 4BBD9AF1  bl 0x822c0890
	ctx.lr = 0x826E6DA4;
	sub_822C0890(ctx, base);
	// 826E6DA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E6DA8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E6DAC: 48AC1408  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6DB0 size=96
    let mut pc: u32 = 0x826E6DB0;
    'dispatch: loop {
        match pc {
            0x826E6DB0 => {
    //   block [0x826E6DB0..0x826E6E10)
	// 826E6DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6DB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E6DB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E6DBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E6DC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6DC4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6DCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E6DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6DD4: 388BB238  addi r4, r11, -0x4dc8
	ctx.r[4].s64 = ctx.r[11].s64 + -19912;
	// 826E6DD8: 4870CC31  bl 0x82df3a08
	ctx.lr = 0x826E6DDC;
	sub_82DF3A08(ctx, base);
	// 826E6DDC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E6DE0: 38BF011C  addi r5, r31, 0x11c
	ctx.r[5].s64 = ctx.r[31].s64 + 284;
	// 826E6DE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6DE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E6DEC: 4BF1129D  bl 0x825f8088
	ctx.lr = 0x826E6DF0;
	sub_825F8088(ctx, base);
	// 826E6DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6DF4: 4870C635  bl 0x82df3428
	ctx.lr = 0x826E6DF8;
	sub_82DF3428(ctx, base);
	// 826E6DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E6DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E6E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E6E04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E6E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E6E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E6E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E6E10 size=876
    let mut pc: u32 = 0x826E6E10;
    'dispatch: loop {
        match pc {
            0x826E6E10 => {
    //   block [0x826E6E10..0x826E717C)
	// 826E6E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E6E14: 48AC134D  bl 0x831a8160
	ctx.lr = 0x826E6E18;
	sub_831A8130(ctx, base);
	// 826E6E18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E6E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E6E20: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 826E6E24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826E6E28: 4BE2ABB1  bl 0x825119d8
	ctx.lr = 0x826E6E2C;
	sub_825119D8(ctx, base);
	// 826E6E2C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E6E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6E34: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826E6E38: 4870CBD1  bl 0x82df3a08
	ctx.lr = 0x826E6E3C;
	sub_82DF3A08(ctx, base);
	// 826E6E3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E6E40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E6E44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826E6E48: 4BE21939  bl 0x82508780
	ctx.lr = 0x826E6E4C;
	sub_82508780(ctx, base);
	// 826E6E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6E50: 4870C5D9  bl 0x82df3428
	ctx.lr = 0x826E6E54;
	sub_82DF3428(ctx, base);
	// 826E6E54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E6E58: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826E6E5C: 409A0008  bne cr6, 0x826e6e64
	if !ctx.cr[6].eq {
	pc = 0x826E6E64; continue 'dispatch;
	}
	// 826E6E60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E6E64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826E6E68: 4BE21939  bl 0x825087a0
	ctx.lr = 0x826E6E6C;
	sub_825087A0(ctx, base);
	// 826E6E6C: 897F011C  lbz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826E6E70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6E74: 4182000C  beq 0x826e6e80
	if ctx.cr[0].eq {
	pc = 0x826E6E80; continue 'dispatch;
	}
	// 826E6E78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E6E7C: 480002F4  b 0x826e7170
	pc = 0x826E7170; continue 'dispatch;
	// 826E6E80: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E6E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6E88: 3B8BE148  addi r28, r11, -0x1eb8
	ctx.r[28].s64 = ctx.r[11].s64 + -7864;
	// 826E6E8C: 808BE148  lwz r4, -0x1eb8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7864 as u32) ) } as u64;
	// 826E6E90: 4870CB79  bl 0x82df3a08
	ctx.lr = 0x826E6E94;
	sub_82DF3A08(ctx, base);
	// 826E6E94: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E6E98: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6E9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6EA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E6EA4: 4BFE3F7D  bl 0x826cae20
	ctx.lr = 0x826E6EA8;
	sub_826CAE20(ctx, base);
	// 826E6EA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E6EAC: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 826E6EB0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E6EB4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826E6EB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6EBC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826E6EC0: 4BBDD5A1  bl 0x822c4460
	ctx.lr = 0x826E6EC4;
	sub_822C4460(ctx, base);
	// 826E6EC4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826E6EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E6ECC: 419A0008  beq cr6, 0x826e6ed4
	if ctx.cr[6].eq {
	pc = 0x826E6ED4; continue 'dispatch;
	}
	// 826E6ED0: 4BBD99C1  bl 0x822c0890
	ctx.lr = 0x826E6ED4;
	sub_822C0890(ctx, base);
	// 826E6ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E6ED8: 4870C551  bl 0x82df3428
	ctx.lr = 0x826E6EDC;
	sub_82DF3428(ctx, base);
	// 826E6EDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E6EE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E6EE4: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6EE8: 4BE2B231  bl 0x82512118
	ctx.lr = 0x826E6EEC;
	sub_82512118(ctx, base);
	// 826E6EEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6EF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E6EF4: 4872E1BD  bl 0x82e150b0
	ctx.lr = 0x826E6EF8;
	sub_82E150B0(ctx, base);
	// 826E6EF8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E6EFC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E6F04: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826E6F08: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E6F0C: 419A0024  beq cr6, 0x826e6f30
	if ctx.cr[6].eq {
	pc = 0x826E6F30; continue 'dispatch;
	}
	// 826E6F10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E6F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E6F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6F1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E6F20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E6F24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E6F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E6F2C: 4082FFE8  bne 0x826e6f14
	if !ctx.cr[0].eq {
	pc = 0x826E6F14; continue 'dispatch;
	}
	// 826E6F30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E6F34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E6F38: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826E6F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E6F40: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826E6F44: 4BE29AB5  bl 0x825109f8
	ctx.lr = 0x826E6F48;
	sub_825109F8(ctx, base);
	// 826E6F48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E6F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E6F50: 419A0008  beq cr6, 0x826e6f58
	if ctx.cr[6].eq {
	pc = 0x826E6F58; continue 'dispatch;
	}
	// 826E6F54: 4BBD993D  bl 0x822c0890
	ctx.lr = 0x826E6F58;
	sub_822C0890(ctx, base);
	// 826E6F58: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6F5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E6F60: 3B6BB1D0  addi r27, r11, -0x4e30
	ctx.r[27].s64 = ctx.r[11].s64 + -20016;
	// 826E6F64: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826E6F68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826E6F6C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 826E6F70: 4BBD9469  bl 0x822c03d8
	ctx.lr = 0x826E6F74;
	sub_822C03D8(ctx, base);
	// 826E6F74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6F78: 4182002C  beq 0x826e6fa4
	if ctx.cr[0].eq {
	pc = 0x826E6FA4; continue 'dispatch;
	}
	// 826E6F7C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6F80: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6F84: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E6F88: 38CBB2BC  addi r6, r11, -0x4d44
	ctx.r[6].s64 = ctx.r[11].s64 + -19780;
	// 826E6F8C: 38AAB294  addi r5, r10, -0x4d6c
	ctx.r[5].s64 = ctx.r[10].s64 + -19820;
	// 826E6F90: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E6F94: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826E6F98: 480E4239  bl 0x827cb1d0
	ctx.lr = 0x826E6F9C;
	sub_827CB1D0(ctx, base);
	// 826E6F9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6FA0: 48000008  b 0x826e6fa8
	pc = 0x826E6FA8; continue 'dispatch;
	// 826E6FA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E6FA8: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 826E6FAC: 4BF11DBD  bl 0x825f8d68
	ctx.lr = 0x826E6FB0;
	sub_825F8D68(ctx, base);
	// 826E6FB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826E6FB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E6FB8: 38A0007A  li r5, 0x7a
	ctx.r[5].s64 = 122;
	// 826E6FBC: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 826E6FC0: 4BBD9419  bl 0x822c03d8
	ctx.lr = 0x826E6FC4;
	sub_822C03D8(ctx, base);
	// 826E6FC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E6FC8: 4182002C  beq 0x826e6ff4
	if ctx.cr[0].eq {
	pc = 0x826E6FF4; continue 'dispatch;
	}
	// 826E6FCC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E6FD0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E6FD4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E6FD8: 38CBB268  addi r6, r11, -0x4d98
	ctx.r[6].s64 = ctx.r[11].s64 + -19864;
	// 826E6FDC: 38AAB240  addi r5, r10, -0x4dc0
	ctx.r[5].s64 = ctx.r[10].s64 + -19904;
	// 826E6FE0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E6FE4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826E6FE8: 480E41E9  bl 0x827cb1d0
	ctx.lr = 0x826E6FEC;
	sub_827CB1D0(ctx, base);
	// 826E6FEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E6FF0: 48000008  b 0x826e6ff8
	pc = 0x826E6FF8; continue 'dispatch;
	// 826E6FF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E6FF8: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 826E6FFC: 4BF11D6D  bl 0x825f8d68
	ctx.lr = 0x826E7000;
	sub_825F8D68(ctx, base);
	// 826E7000: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E7004: 809C004C  lwz r4, 0x4c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 826E7008: 4870CA01  bl 0x82df3a08
	ctx.lr = 0x826E700C;
	sub_82DF3A08(ctx, base);
	// 826E700C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7010: 809C0048  lwz r4, 0x48(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 826E7014: 4870C9F5  bl 0x82df3a08
	ctx.lr = 0x826E7018;
	sub_82DF3A08(ctx, base);
	// 826E7018: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826E701C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E7020: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7028: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E702C: 4BFE3D75  bl 0x826cada0
	ctx.lr = 0x826E7030;
	sub_826CADA0(ctx, base);
	// 826E7030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E7034: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 826E7038: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E703C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826E7040: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7044: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826E7048: 4BBDD419  bl 0x822c4460
	ctx.lr = 0x826E704C;
	sub_822C4460(ctx, base);
	// 826E704C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E7050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7054: 419A0008  beq cr6, 0x826e705c
	if ctx.cr[6].eq {
	pc = 0x826E705C; continue 'dispatch;
	}
	// 826E7058: 4BBD9839  bl 0x822c0890
	ctx.lr = 0x826E705C;
	sub_822C0890(ctx, base);
	// 826E705C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7060: 4870C3C9  bl 0x82df3428
	ctx.lr = 0x826E7064;
	sub_82DF3428(ctx, base);
	// 826E7064: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E7068: 4870C3C1  bl 0x82df3428
	ctx.lr = 0x826E706C;
	sub_82DF3428(ctx, base);
	// 826E706C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7070: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E7074: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7078: 4BE2B0A1  bl 0x82512118
	ctx.lr = 0x826E707C;
	sub_82512118(ctx, base);
	// 826E707C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7080: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E7084: 4BC06EDD  bl 0x822edf60
	ctx.lr = 0x826E7088;
	sub_822EDF60(ctx, base);
	// 826E7088: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E708C: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7090: 4BBFDE31  bl 0x822e4ec0
	ctx.lr = 0x826E7094;
	sub_822E4EC0(ctx, base);
	// 826E7094: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E7098: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826E709C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E70A0: 808B683C  lwz r4, 0x683c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26684 as u32) ) } as u64;
	// 826E70A4: 4BBFDE8D  bl 0x822e4f30
	ctx.lr = 0x826E70A8;
	sub_822E4F30(ctx, base);
	// 826E70A8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826E70AC: E8BC0000  ld r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 826E70B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E70B4: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 826E70B8: 806B674C  lwz r3, 0x674c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E70BC: 4BDA52B5  bl 0x8248c370
	ctx.lr = 0x826E70C0;
	sub_8248C370(ctx, base);
	// 826E70C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E70C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E70C8: 4BDA82D9  bl 0x8248f3a0
	ctx.lr = 0x826E70CC;
	sub_8248F3A0(ctx, base);
	// 826E70CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E70D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E70D4: 4BE29C6D  bl 0x82510d40
	ctx.lr = 0x826E70D8;
	sub_82510D40(ctx, base);
	// 826E70D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826E70DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E70E0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826E70E4: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 826E70E8: 4870B301  bl 0x82df23e8
	ctx.lr = 0x826E70EC;
	sub_82DF23E8(ctx, base);
	// 826E70EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E70F0: 41820010  beq 0x826e7100
	if ctx.cr[0].eq {
	pc = 0x826E7100; continue 'dispatch;
	}
	// 826E70F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826E70F8: 480E9459  bl 0x827d0550
	ctx.lr = 0x826E70FC;
	sub_827D0550(ctx, base);
	// 826E70FC: 48000008  b 0x826e7104
	pc = 0x826E7104; continue 'dispatch;
	// 826E7100: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E7104: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826E7108: 907F0108  stw r3, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 826E710C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E7110: 419A001C  beq cr6, 0x826e712c
	if ctx.cr[6].eq {
	pc = 0x826E712C; continue 'dispatch;
	}
	// 826E7114: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7118: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826E711C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E7120: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E7128: 4E800421  bctrl
	ctx.lr = 0x826E712C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E712C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826E7130: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E7134: 38A0008F  li r5, 0x8f
	ctx.r[5].s64 = 143;
	// 826E7138: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826E713C: 4870B2AD  bl 0x82df23e8
	ctx.lr = 0x826E7140;
	sub_82DF23E8(ctx, base);
	// 826E7140: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E7144: 4182001C  beq 0x826e7160
	if ctx.cr[0].eq {
	pc = 0x826E7160; continue 'dispatch;
	}
	// 826E7148: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 826E714C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826E7150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7154: 4BFE45BD  bl 0x826cb710
	ctx.lr = 0x826E7158;
	sub_826CB710(ctx, base);
	// 826E7158: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E715C: 48000008  b 0x826e7164
	pc = 0x826E7164; continue 'dispatch;
	// 826E7160: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E7164: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 826E7168: 4BFDE259  bl 0x826c53c0
	ctx.lr = 0x826E716C;
	sub_826C53C0(ctx, base);
	// 826E716C: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 826E7170: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826E7174: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826E7178: 48AC1038  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E7180 size=12
    let mut pc: u32 = 0x826E7180;
    'dispatch: loop {
        match pc {
            0x826E7180 => {
    //   block [0x826E7180..0x826E718C)
	// 826E7180: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E7184: 99630178  stb r11, 0x178(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(376 as u32), ctx.r[11].u8 ) };
	// 826E7188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7190 size=196
    let mut pc: u32 = 0x826E7190;
    'dispatch: loop {
        match pc {
            0x826E7190 => {
    //   block [0x826E7190..0x826E7254)
	// 826E7190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E719C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E71A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E71A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E71A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E71AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E71B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E71B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E71B8: 4BBD9781  bl 0x822c0938
	ctx.lr = 0x826E71BC;
	sub_822C0938(ctx, base);
	// 826E71BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E71C0: 41820028  beq 0x826e71e8
	if ctx.cr[0].eq {
	pc = 0x826E71E8; continue 'dispatch;
	}
	// 826E71C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E71C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E71CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E71D0: 392BB3C8  addi r9, r11, -0x4c38
	ctx.r[9].s64 = ctx.r[11].s64 + -19512;
	// 826E71D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E71D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E71DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E71E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E71E4: 48000008  b 0x826e71ec
	pc = 0x826E71EC; continue 'dispatch;
	// 826E71E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E71EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E71F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E71F4: 409A0044  bne cr6, 0x826e7238
	if !ctx.cr[6].eq {
	pc = 0x826E7238; continue 'dispatch;
	}
	// 826E71F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E71FC: 419A001C  beq cr6, 0x826e7218
	if ctx.cr[6].eq {
	pc = 0x826E7218; continue 'dispatch;
	}
	// 826E7200: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7204: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E7208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E720C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E7214: 4E800421  bctrl
	ctx.lr = 0x826E7218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E7218: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E721C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E7220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7224: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E7228: 816BE278  lwz r11, -0x1d88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7560 as u32) ) } as u64;
	// 826E722C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E7230: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E7234: 4BBD8DCD  bl 0x822c0000
	ctx.lr = 0x826E7238;
	sub_822C0000(ctx, base);
	// 826E7238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E723C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7248: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E724C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7258 size=196
    let mut pc: u32 = 0x826E7258;
    'dispatch: loop {
        match pc {
            0x826E7258 => {
    //   block [0x826E7258..0x826E731C)
	// 826E7258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E725C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E7264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E726C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E7270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E7274: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E7278: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E727C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E7280: 4BBD96B9  bl 0x822c0938
	ctx.lr = 0x826E7284;
	sub_822C0938(ctx, base);
	// 826E7284: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E7288: 41820028  beq 0x826e72b0
	if ctx.cr[0].eq {
	pc = 0x826E72B0; continue 'dispatch;
	}
	// 826E728C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7290: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E7294: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E7298: 392BB3DC  addi r9, r11, -0x4c24
	ctx.r[9].s64 = ctx.r[11].s64 + -19492;
	// 826E729C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E72A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E72A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E72A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E72AC: 48000008  b 0x826e72b4
	pc = 0x826E72B4; continue 'dispatch;
	// 826E72B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E72B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E72B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E72BC: 409A0044  bne cr6, 0x826e7300
	if !ctx.cr[6].eq {
	pc = 0x826E7300; continue 'dispatch;
	}
	// 826E72C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E72C4: 419A001C  beq cr6, 0x826e72e0
	if ctx.cr[6].eq {
	pc = 0x826E72E0; continue 'dispatch;
	}
	// 826E72C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E72CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E72D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E72D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E72D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E72DC: 4E800421  bctrl
	ctx.lr = 0x826E72E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E72E0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E72E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E72E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E72EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E72F0: 816BE278  lwz r11, -0x1d88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7560 as u32) ) } as u64;
	// 826E72F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E72F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E72FC: 4BBD8D05  bl 0x822c0000
	ctx.lr = 0x826E7300;
	sub_822C0000(ctx, base);
	// 826E7300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E730C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E7314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7320 size=196
    let mut pc: u32 = 0x826E7320;
    'dispatch: loop {
        match pc {
            0x826E7320 => {
    //   block [0x826E7320..0x826E73E4)
	// 826E7320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E732C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E7338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E733C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E7340: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E7344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E7348: 4BBD95F1  bl 0x822c0938
	ctx.lr = 0x826E734C;
	sub_822C0938(ctx, base);
	// 826E734C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E7350: 41820028  beq 0x826e7378
	if ctx.cr[0].eq {
	pc = 0x826E7378; continue 'dispatch;
	}
	// 826E7354: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7358: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E735C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E7360: 392BB3F0  addi r9, r11, -0x4c10
	ctx.r[9].s64 = ctx.r[11].s64 + -19472;
	// 826E7364: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E7368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E736C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E7370: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E7374: 48000008  b 0x826e737c
	pc = 0x826E737C; continue 'dispatch;
	// 826E7378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E737C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E7380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E7384: 409A0044  bne cr6, 0x826e73c8
	if !ctx.cr[6].eq {
	pc = 0x826E73C8; continue 'dispatch;
	}
	// 826E7388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E738C: 419A001C  beq cr6, 0x826e73a8
	if ctx.cr[6].eq {
	pc = 0x826E73A8; continue 'dispatch;
	}
	// 826E7390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7394: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E7398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E739C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E73A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E73A4: 4E800421  bctrl
	ctx.lr = 0x826E73A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E73A8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E73AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E73B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E73B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E73B8: 816BE278  lwz r11, -0x1d88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7560 as u32) ) } as u64;
	// 826E73BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E73C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E73C4: 4BBD8C3D  bl 0x822c0000
	ctx.lr = 0x826E73C8;
	sub_822C0000(ctx, base);
	// 826E73C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E73CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E73D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E73D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E73D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E73DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E73E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E73E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E73E8 size=220
    let mut pc: u32 = 0x826E73E8;
    'dispatch: loop {
        match pc {
            0x826E73E8 => {
    //   block [0x826E73E8..0x826E74C4)
	// 826E73E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E73EC: 48AC0D81  bl 0x831a816c
	ctx.lr = 0x826E73F0;
	sub_831A8130(ctx, base);
	// 826E73F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E73F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E73F8: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 826E73FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E7400: D06100EC  stfs f3, 0xec(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 826E7404: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826E7408: 3BBF0160  addi r29, r31, 0x160
	ctx.r[29].s64 = ctx.r[31].s64 + 352;
	// 826E740C: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 826E7410: 38DF0140  addi r6, r31, 0x140
	ctx.r[6].s64 = ctx.r[31].s64 + 320;
	// 826E7414: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826E7418: C04BFD2C  lfs f2, -0x2d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-724 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826E741C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E7420: C02A0A98  lfs f1, 0xa98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E7424: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E7428: 4BFE4789  bl 0x826cbbb0
	ctx.lr = 0x826E742C;
	sub_826CBBB0(ctx, base);
	// 826E742C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E7430: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E74C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E74C8 size=252
    let mut pc: u32 = 0x826E74C8;
    'dispatch: loop {
        match pc {
            0x826E74C8 => {
    //   block [0x826E74C8..0x826E75C4)
	// 826E74C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E74CC: 48AC0CA1  bl 0x831a816c
	ctx.lr = 0x826E74D0;
	sub_831A8130(ctx, base);
	// 826E74D0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E75C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E75C8 size=140
    let mut pc: u32 = 0x826E75C8;
    'dispatch: loop {
        match pc {
            0x826E75C8 => {
    //   block [0x826E75C8..0x826E7654)
	// 826E75C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E75CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E75D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E75D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E75D8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E75DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E75E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E75E4: 388BB420  addi r4, r11, -0x4be0
	ctx.r[4].s64 = ctx.r[11].s64 + -19424;
	// 826E75E8: 4870C421  bl 0x82df3a08
	ctx.lr = 0x826E75EC;
	sub_82DF3A08(ctx, base);
	// 826E75EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826E75F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E75F4: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E75F8: 484CB5D1  bl 0x82bb2bc8
	ctx.lr = 0x826E75FC;
	sub_82BB2BC8(ctx, base);
	// 826E75FC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E7600: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E7608: 419A000C  beq cr6, 0x826e7614
	if ctx.cr[6].eq {
	pc = 0x826E7614; continue 'dispatch;
	}
	// 826E760C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826E7610: 4BBD9281  bl 0x822c0890
	ctx.lr = 0x826E7614;
	sub_822C0890(ctx, base);
	// 826E7614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7618: 4870BE11  bl 0x82df3428
	ctx.lr = 0x826E761C;
	sub_82DF3428(ctx, base);
	// 826E761C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7620: 484CF419  bl 0x82bb6a38
	ctx.lr = 0x826E7624;
	sub_82BB6A38(ctx, base);
	// 826E7624: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E7628: C00BBC10  lfs f0, -0x43f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E762C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E7630: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 826E7634: 40980008  bge cr6, 0x826e763c
	if !ctx.cr[6].lt {
	pc = 0x826E763C; continue 'dispatch;
	}
	// 826E7638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E763C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826E7640: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7644: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7648: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E764C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E7658 size=96
    let mut pc: u32 = 0x826E7658;
    'dispatch: loop {
        match pc {
            0x826E7658 => {
    //   block [0x826E7658..0x826E76B8)
	// 826E7658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E765C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7660: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7664: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E76B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E76B8 size=188
    let mut pc: u32 = 0x826E76B8;
    'dispatch: loop {
        match pc {
            0x826E76B8 => {
    //   block [0x826E76B8..0x826E7774)
	// 826E76B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E76BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E76C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E76C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E76C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E76CC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E76D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E76D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E76D8: 388BB420  addi r4, r11, -0x4be0
	ctx.r[4].s64 = ctx.r[11].s64 + -19424;
	// 826E76DC: 4870C32D  bl 0x82df3a08
	ctx.lr = 0x826E76E0;
	sub_82DF3A08(ctx, base);
	// 826E76E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826E76E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E76E8: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E76EC: 484CB4DD  bl 0x82bb2bc8
	ctx.lr = 0x826E76F0;
	sub_82BB2BC8(ctx, base);
	// 826E76F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E76F4: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E76F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E76FC: 419A000C  beq cr6, 0x826e7708
	if ctx.cr[6].eq {
	pc = 0x826E7708; continue 'dispatch;
	}
	// 826E7700: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826E7704: 4BBD918D  bl 0x822c0890
	ctx.lr = 0x826E7708;
	sub_822C0890(ctx, base);
	// 826E7708: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E770C: 4870BD1D  bl 0x82df3428
	ctx.lr = 0x826E7710;
	sub_82DF3428(ctx, base);
	// 826E7710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E7714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7718: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E771C: 484D1355  bl 0x82bb8a70
	ctx.lr = 0x826E7720;
	sub_82BB8A70(ctx, base);
	// 826E7720: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7728: 38ABB428  addi r5, r11, -0x4bd8
	ctx.r[5].s64 = ctx.r[11].s64 + -19416;
	// 826E772C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E7730: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E7734: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826E7738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E773C: 4E800421  bctrl
	ctx.lr = 0x826E7740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E7740: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E7744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7748: 419A0008  beq cr6, 0x826e7750
	if ctx.cr[6].eq {
	pc = 0x826E7750; continue 'dispatch;
	}
	// 826E774C: 4BBD9145  bl 0x822c0890
	ctx.lr = 0x826E7750;
	sub_822C0890(ctx, base);
	// 826E7750: 389F0100  addi r4, r31, 0x100
	ctx.r[4].s64 = ctx.r[31].s64 + 256;
	// 826E7754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7758: 4BE28F51  bl 0x825106a8
	ctx.lr = 0x826E775C;
	sub_825106A8(ctx, base);
	// 826E775C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E7760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7768: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E776C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7778 size=100
    let mut pc: u32 = 0x826E7778;
    'dispatch: loop {
        match pc {
            0x826E7778 => {
    //   block [0x826E7778..0x826E77DC)
	// 826E7778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E777C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E7784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E778C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7790: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E7794: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 826E7798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E779C: 419A0014  beq cr6, 0x826e77b0
	if ctx.cr[6].eq {
	pc = 0x826E77B0; continue 'dispatch;
	}
	// 826E77A0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E77A4: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 826E77A8: 40820008  bne 0x826e77b0
	if !ctx.cr[0].eq {
	pc = 0x826E77B0; continue 'dispatch;
	}
	// 826E77AC: 4BFFFF0D  bl 0x826e76b8
	ctx.lr = 0x826E77B0;
	sub_826E76B8(ctx, base);
	// 826E77B0: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 826E77B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E77B8: 419A000C  beq cr6, 0x826e77c4
	if ctx.cr[6].eq {
	pc = 0x826E77C4; continue 'dispatch;
	}
	// 826E77BC: 389E0040  addi r4, r30, 0x40
	ctx.r[4].s64 = ctx.r[30].s64 + 64;
	// 826E77C0: 4BFE3EA9  bl 0x826cb668
	ctx.lr = 0x826E77C4;
	sub_826CB668(ctx, base);
	// 826E77C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E77C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E77CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E77D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E77D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E77D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E77E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E77E0 size=340
    let mut pc: u32 = 0x826E77E0;
    'dispatch: loop {
        match pc {
            0x826E77E0 => {
    //   block [0x826E77E0..0x826E7934)
	// 826E77E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E77E4: 48AC0981  bl 0x831a8164
	ctx.lr = 0x826E77E8;
	sub_831A8130(ctx, base);
	// 826E77E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E77EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E77F0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826E77F4: 4BFFFDD5  bl 0x826e75c8
	ctx.lr = 0x826E77F8;
	sub_826E75C8(ctx, base);
	// 826E77F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E77FC: 41820130  beq 0x826e792c
	if ctx.cr[0].eq {
	pc = 0x826E792C; continue 'dispatch;
	}
	// 826E7800: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7804: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E7808: 3BABB440  addi r29, r11, -0x4bc0
	ctx.r[29].s64 = ctx.r[11].s64 + -19392;
	// 826E780C: 38A0012A  li r5, 0x12a
	ctx.r[5].s64 = 298;
	// 826E7810: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E7814: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 826E7818: 4870ABD1  bl 0x82df23e8
	ctx.lr = 0x826E781C;
	sub_82DF23E8(ctx, base);
	// 826E781C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E7820: 41820024  beq 0x826e7844
	if ctx.cr[0].eq {
	pc = 0x826E7844; continue 'dispatch;
	}
	// 826E7824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7828: 48771E79  bl 0x82e596a0
	ctx.lr = 0x826E782C;
	sub_82E596A0(ctx, base);
	// 826E782C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826E7830: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 826E7834: 396BAF88  addi r11, r11, -0x5078
	ctx.r[11].s64 = ctx.r[11].s64 + -20600;
	// 826E7838: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E783C: 4BCCC7B5  bl 0x823b3ff0
	ctx.lr = 0x826E7840;
	sub_823B3FF0(ctx, base);
	// 826E7840: 48000008  b 0x826e7848
	pc = 0x826E7848; continue 'dispatch;
	// 826E7844: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E7848: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E784C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E7854: 4BD9567D  bl 0x8247ced0
	ctx.lr = 0x826E7858;
	sub_8247CED0(ctx, base);
	// 826E7858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E785C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7860: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E7864: 4BBD879D  bl 0x822c0000
	ctx.lr = 0x826E7868;
	sub_822C0000(ctx, base);
	// 826E7868: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E786C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E7870: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E7874: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826E7878: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 826E787C: 419A0024  beq cr6, 0x826e78a0
	if ctx.cr[6].eq {
	pc = 0x826E78A0; continue 'dispatch;
	}
	// 826E7880: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826E7884: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E7888: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E788C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E7890: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E7894: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E7898: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E789C: 4082FFE8  bne 0x826e7884
	if !ctx.cr[0].eq {
	pc = 0x826E7884; continue 'dispatch;
	}
	// 826E78A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E78A4: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 826E78A8: 48920881  bl 0x83008128
	ctx.lr = 0x826E78AC;
	sub_83008128(ctx, base);
	// 826E78AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826E78B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E78B4: 38A0012B  li r5, 0x12b
	ctx.r[5].s64 = 299;
	// 826E78B8: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 826E78BC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826E78C0: 4876F729  bl 0x82e56fe8
	ctx.lr = 0x826E78C4;
	sub_82E56FE8(ctx, base);
	// 826E78C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E78C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E78CC: 419A0008  beq cr6, 0x826e78d4
	if ctx.cr[6].eq {
	pc = 0x826E78D4; continue 'dispatch;
	}
	// 826E78D0: 4BBD8FC1  bl 0x822c0890
	ctx.lr = 0x826E78D4;
	sub_822C0890(ctx, base);
	// 826E78D4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E78D8: C19C0064  lfs f12, 0x64(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826E78DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E78E0: 397E0160  addi r11, r30, 0x160
	ctx.r[11].s64 = ctx.r[30].s64 + 352;
	// 826E78E4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826E78E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826E78EC: C1AAB3B8  lfs f13, -0x4c48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E78F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E78F4: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E78F8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 826E78FC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E7900: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826E7904: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826E7908: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826E790C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826E7910: 13C040C7  vcmpequd (lvx128) v30, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E7938 size=324
    let mut pc: u32 = 0x826E7938;
    'dispatch: loop {
        match pc {
            0x826E7938 => {
    //   block [0x826E7938..0x826E7A7C)
	// 826E7938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E793C: 48AC082D  bl 0x831a8168
	ctx.lr = 0x826E7940;
	sub_831A8130(ctx, base);
	// 826E7940: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7948: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E794C: 4BE2A19D  bl 0x82511ae8
	ctx.lr = 0x826E7950;
	sub_82511AE8(ctx, base);
	// 826E7950: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E7954: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E7958: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 826E795C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7960: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7A80 size=112
    let mut pc: u32 = 0x826E7A80;
    'dispatch: loop {
        match pc {
            0x826E7A80 => {
    //   block [0x826E7A80..0x826E7AF0)
	// 826E7A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7A84: 48AC06E9  bl 0x831a816c
	ctx.lr = 0x826E7A88;
	sub_831A8130(ctx, base);
	// 826E7A88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7A8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E7A90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826E7A94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E7A98: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826E7A9C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826E7AA0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826E7AA4: 4870A945  bl 0x82df23e8
	ctx.lr = 0x826E7AA8;
	sub_82DF23E8(ctx, base);
	// 826E7AA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E7AAC: 41820010  beq 0x826e7abc
	if ctx.cr[0].eq {
	pc = 0x826E7ABC; continue 'dispatch;
	}
	// 826E7AB0: 4846BD71  bl 0x82b53820
	ctx.lr = 0x826E7AB4;
	sub_82B53820(ctx, base);
	// 826E7AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7AB8: 48000008  b 0x826e7ac0
	pc = 0x826E7AC0; continue 'dispatch;
	// 826E7ABC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E7AC0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E7AC4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826E7AC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7AD0: 4BFFF789  bl 0x826e7258
	ctx.lr = 0x826E7AD4;
	sub_826E7258(ctx, base);
	// 826E7AD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E7AD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7AE0: 4BBD8521  bl 0x822c0000
	ctx.lr = 0x826E7AE4;
	sub_822C0000(ctx, base);
	// 826E7AE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E7AE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7AEC: 48AC06D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7AF0 size=124
    let mut pc: u32 = 0x826E7AF0;
    'dispatch: loop {
        match pc {
            0x826E7AF0 => {
    //   block [0x826E7AF0..0x826E7B6C)
	// 826E7AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7AF4: 48AC0679  bl 0x831a816c
	ctx.lr = 0x826E7AF8;
	sub_831A8130(ctx, base);
	// 826E7AF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7AFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E7B00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826E7B04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E7B08: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826E7B0C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826E7B10: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 826E7B14: 4870A8D5  bl 0x82df23e8
	ctx.lr = 0x826E7B18;
	sub_82DF23E8(ctx, base);
	// 826E7B18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E7B1C: 4182001C  beq 0x826e7b38
	if ctx.cr[0].eq {
	pc = 0x826E7B38; continue 'dispatch;
	}
	// 826E7B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7B24: 48771B5D  bl 0x82e59680
	ctx.lr = 0x826E7B28;
	sub_82E59680(ctx, base);
	// 826E7B28: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7B2C: 396BB3C0  addi r11, r11, -0x4c40
	ctx.r[11].s64 = ctx.r[11].s64 + -19520;
	// 826E7B30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E7B34: 48000008  b 0x826e7b3c
	pc = 0x826E7B3C; continue 'dispatch;
	// 826E7B38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E7B3C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E7B40: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826E7B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7B4C: 4BFFF7D5  bl 0x826e7320
	ctx.lr = 0x826E7B50;
	sub_826E7320(ctx, base);
	// 826E7B50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E7B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7B58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7B5C: 4BBD84A5  bl 0x822c0000
	ctx.lr = 0x826E7B60;
	sub_822C0000(ctx, base);
	// 826E7B60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E7B64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7B68: 48AC0654  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7B70 size=332
    let mut pc: u32 = 0x826E7B70;
    'dispatch: loop {
        match pc {
            0x826E7B70 => {
    //   block [0x826E7B70..0x826E7CBC)
	// 826E7B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7B74: 48AC05F5  bl 0x831a8168
	ctx.lr = 0x826E7B78;
	sub_831A8130(ctx, base);
	// 826E7B78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7B7C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826E7B80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E7B84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E7B88: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826E7B8C: 41820038  beq 0x826e7bc4
	if ctx.cr[0].eq {
	pc = 0x826E7BC4; continue 'dispatch;
	}
	// 826E7B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7B94: 48AC1DF5  bl 0x831a9988
	ctx.lr = 0x826E7B98;
	sub_831A9988(ctx, base);
	// 826E7B98: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 826E7B9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7BA0: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 826E7BA4: 48AC0555  bl 0x831a80f8
	ctx.lr = 0x826E7BA8;
	sub_831A80F8(ctx, base);
	// 826E7BA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7BAC: 41820018  beq 0x826e7bc4
	if ctx.cr[0].eq {
	pc = 0x826E7BC4; continue 'dispatch;
	}
	// 826E7BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7BB4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E7BB8: 4BFFFBC1  bl 0x826e7778
	ctx.lr = 0x826E7BBC;
	sub_826E7778(ctx, base);
	// 826E7BBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E7BC0: 480000F4  b 0x826e7cb4
	pc = 0x826E7CB4; continue 'dispatch;
	// 826E7BC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E7BC8: 409A00AC  bne cr6, 0x826e7c74
	if !ctx.cr[6].eq {
	pc = 0x826E7C74; continue 'dispatch;
	}
	// 826E7BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7BD0: 48AC1DB9  bl 0x831a9988
	ctx.lr = 0x826E7BD4;
	sub_831A9988(ctx, base);
	// 826E7BD4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826E7BD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7BDC: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826E7BE0: 48AC0519  bl 0x831a80f8
	ctx.lr = 0x826E7BE4;
	sub_831A80F8(ctx, base);
	// 826E7BE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7BE8: 41820014  beq 0x826e7bfc
	if ctx.cr[0].eq {
	pc = 0x826E7BFC; continue 'dispatch;
	}
	// 826E7BEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7BF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E7BF4: 4BFFFBED  bl 0x826e77e0
	ctx.lr = 0x826E7BF8;
	sub_826E77E0(ctx, base);
	// 826E7BF8: 4BFFFFC4  b 0x826e7bbc
	pc = 0x826E7BBC; continue 'dispatch;
	// 826E7BFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E7C00: 409A0074  bne cr6, 0x826e7c74
	if !ctx.cr[6].eq {
	pc = 0x826E7C74; continue 'dispatch;
	}
	// 826E7C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7C08: 48AC1D81  bl 0x831a9988
	ctx.lr = 0x826E7C0C;
	sub_831A9988(ctx, base);
	// 826E7C0C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826E7C10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7C14: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 826E7C18: 48AC04E1  bl 0x831a80f8
	ctx.lr = 0x826E7C1C;
	sub_831A80F8(ctx, base);
	// 826E7C1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7C20: 41820014  beq 0x826e7c34
	if ctx.cr[0].eq {
	pc = 0x826E7C34; continue 'dispatch;
	}
	// 826E7C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7C28: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E7C2C: 4BFFF555  bl 0x826e7180
	ctx.lr = 0x826E7C30;
	sub_826E7180(ctx, base);
	// 826E7C30: 4BFFFF8C  b 0x826e7bbc
	pc = 0x826E7BBC; continue 'dispatch;
	// 826E7C34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E7C38: 409A003C  bne cr6, 0x826e7c74
	if !ctx.cr[6].eq {
	pc = 0x826E7C74; continue 'dispatch;
	}
	// 826E7C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7C40: 48AC1D49  bl 0x831a9988
	ctx.lr = 0x826E7C44;
	sub_831A9988(ctx, base);
	// 826E7C44: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826E7C48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7C4C: 386BE6C4  addi r3, r11, -0x193c
	ctx.r[3].s64 = ctx.r[11].s64 + -6460;
	// 826E7C50: 48AC04A9  bl 0x831a80f8
	ctx.lr = 0x826E7C54;
	sub_831A80F8(ctx, base);
	// 826E7C54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7C58: 41820014  beq 0x826e7c6c
	if ctx.cr[0].eq {
	pc = 0x826E7C6C; continue 'dispatch;
	}
	// 826E7C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7C60: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E7C64: 4BFFFCD5  bl 0x826e7938
	ctx.lr = 0x826E7C68;
	sub_826E7938(ctx, base);
	// 826E7C68: 4BFFFF54  b 0x826e7bbc
	pc = 0x826E7BBC; continue 'dispatch;
	// 826E7C6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E7C70: 419A0034  beq cr6, 0x826e7ca4
	if ctx.cr[6].eq {
	pc = 0x826E7CA4; continue 'dispatch;
	}
	// 826E7C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7C78: 48AC1D11  bl 0x831a9988
	ctx.lr = 0x826E7C7C;
	sub_831A9988(ctx, base);
	// 826E7C7C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 826E7C80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E7C84: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 826E7C88: 48AC0471  bl 0x831a80f8
	ctx.lr = 0x826E7C8C;
	sub_831A80F8(ctx, base);
	// 826E7C8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7C90: 41820014  beq 0x826e7ca4
	if ctx.cr[0].eq {
	pc = 0x826E7CA4; continue 'dispatch;
	}
	// 826E7C94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7C98: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E7C9C: 4BFFF9BD  bl 0x826e7658
	ctx.lr = 0x826E7CA0;
	sub_826E7658(ctx, base);
	// 826E7CA0: 4BFFFF1C  b 0x826e7bbc
	pc = 0x826E7BBC; continue 'dispatch;
	// 826E7CA4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826E7CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E7CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7CB0: 4BE2A969  bl 0x82512618
	ctx.lr = 0x826E7CB4;
	sub_82512618(ctx, base);
	// 826E7CB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E7CB8: 48AC0500  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E7CC0 size=228
    let mut pc: u32 = 0x826E7CC0;
    'dispatch: loop {
        match pc {
            0x826E7CC0 => {
    //   block [0x826E7CC0..0x826E7DA4)
	// 826E7CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7CD4: 4BFE291D  bl 0x826ca5f0
	ctx.lr = 0x826E7CD8;
	sub_826CA5F0(ctx, base);
	// 826E7CD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7CDC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E7CE0: 396BB50C  addi r11, r11, -0x4af4
	ctx.r[11].s64 = ctx.r[11].s64 + -19188;
	// 826E7CE4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E7CE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E7CEC: 394AB4F8  addi r10, r10, -0x4b08
	ctx.r[10].s64 = ctx.r[10].s64 + -19208;
	// 826E7CF0: 3929B4AC  addi r9, r9, -0x4b54
	ctx.r[9].s64 = ctx.r[9].s64 + -19284;
	// 826E7CF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E7CF8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E7CFC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E7D00: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826E7D04: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826E7D08: 39200140  li r9, 0x140
	ctx.r[9].s64 = 320;
	// 826E7D0C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826E7D10: 390A6910  addi r8, r10, 0x6910
	ctx.r[8].s64 = ctx.r[10].s64 + 26896;
	// 826E7D14: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826E7D18: 38E00150  li r7, 0x150
	ctx.r[7].s64 = 336;
	// 826E7D1C: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826E7D20: 38C00160  li r6, 0x160
	ctx.r[6].s64 = 352;
	// 826E7D24: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826E7D28: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E7D2C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826E7D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7D34: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826E7D38: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826E7D3C: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826E7D40: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826E7D44: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826E7D48: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826E7D4C: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826E7D50: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 826E7D54: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826E7D58: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826E7D5C: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 826E7D60: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 826E7D64: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 826E7D68: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 826E7D6C: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E7DA8 size=8
    let mut pc: u32 = 0x826E7DA8;
    'dispatch: loop {
        match pc {
            0x826E7DA8 => {
    //   block [0x826E7DA8..0x826E7DB0)
	// 826E7DA8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E7DAC: 480000F4  b 0x826e7ea0
	sub_826E7EA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E7DB0 size=8
    let mut pc: u32 = 0x826E7DB0;
    'dispatch: loop {
        match pc {
            0x826E7DB0 => {
    //   block [0x826E7DB0..0x826E7DB8)
	// 826E7DB0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E7DB4: 480000EC  b 0x826e7ea0
	sub_826E7EA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7DB8 size=228
    let mut pc: u32 = 0x826E7DB8;
    'dispatch: loop {
        match pc {
            0x826E7DB8 => {
    //   block [0x826E7DB8..0x826E7E9C)
	// 826E7DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7DCC: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 826E7DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7DD4: 419A0008  beq cr6, 0x826e7ddc
	if ctx.cr[6].eq {
	pc = 0x826E7DDC; continue 'dispatch;
	}
	// 826E7DD8: 4BBD8AB9  bl 0x822c0890
	ctx.lr = 0x826E7DDC;
	sub_822C0890(ctx, base);
	// 826E7DDC: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826E7DE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7DE4: 419A0008  beq cr6, 0x826e7dec
	if ctx.cr[6].eq {
	pc = 0x826E7DEC; continue 'dispatch;
	}
	// 826E7DE8: 4BBD8AA9  bl 0x822c0890
	ctx.lr = 0x826E7DEC;
	sub_822C0890(ctx, base);
	// 826E7DEC: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826E7DF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7DF4: 419A0008  beq cr6, 0x826e7dfc
	if ctx.cr[6].eq {
	pc = 0x826E7DFC; continue 'dispatch;
	}
	// 826E7DF8: 4BBD8A99  bl 0x822c0890
	ctx.lr = 0x826E7DFC;
	sub_822C0890(ctx, base);
	// 826E7DFC: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826E7E00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E04: 419A0008  beq cr6, 0x826e7e0c
	if ctx.cr[6].eq {
	pc = 0x826E7E0C; continue 'dispatch;
	}
	// 826E7E08: 4BBD8A89  bl 0x822c0890
	ctx.lr = 0x826E7E0C;
	sub_822C0890(ctx, base);
	// 826E7E0C: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826E7E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E14: 419A0008  beq cr6, 0x826e7e1c
	if ctx.cr[6].eq {
	pc = 0x826E7E1C; continue 'dispatch;
	}
	// 826E7E18: 4BBD8A79  bl 0x822c0890
	ctx.lr = 0x826E7E1C;
	sub_822C0890(ctx, base);
	// 826E7E1C: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 826E7E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E24: 419A0008  beq cr6, 0x826e7e2c
	if ctx.cr[6].eq {
	pc = 0x826E7E2C; continue 'dispatch;
	}
	// 826E7E28: 4BBD8A69  bl 0x822c0890
	ctx.lr = 0x826E7E2C;
	sub_822C0890(ctx, base);
	// 826E7E2C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826E7E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E34: 419A0008  beq cr6, 0x826e7e3c
	if ctx.cr[6].eq {
	pc = 0x826E7E3C; continue 'dispatch;
	}
	// 826E7E38: 4BBD8A59  bl 0x822c0890
	ctx.lr = 0x826E7E3C;
	sub_822C0890(ctx, base);
	// 826E7E3C: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826E7E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E44: 419A0008  beq cr6, 0x826e7e4c
	if ctx.cr[6].eq {
	pc = 0x826E7E4C; continue 'dispatch;
	}
	// 826E7E48: 4BBD8A49  bl 0x822c0890
	ctx.lr = 0x826E7E4C;
	sub_822C0890(ctx, base);
	// 826E7E4C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826E7E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E54: 419A0008  beq cr6, 0x826e7e5c
	if ctx.cr[6].eq {
	pc = 0x826E7E5C; continue 'dispatch;
	}
	// 826E7E58: 4BBD8A39  bl 0x822c0890
	ctx.lr = 0x826E7E5C;
	sub_822C0890(ctx, base);
	// 826E7E5C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826E7E60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E7E64: 419A0008  beq cr6, 0x826e7e6c
	if ctx.cr[6].eq {
	pc = 0x826E7E6C; continue 'dispatch;
	}
	// 826E7E68: 4BBD8A29  bl 0x822c0890
	ctx.lr = 0x826E7E6C;
	sub_822C0890(ctx, base);
	// 826E7E6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E7E70: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826E7E74: 409A0008  bne cr6, 0x826e7e7c
	if !ctx.cr[6].eq {
	pc = 0x826E7E7C; continue 'dispatch;
	}
	// 826E7E78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E7E7C: 480BF7DD  bl 0x827a7658
	ctx.lr = 0x826E7E80;
	sub_827A7658(ctx, base);
	// 826E7E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7E84: 4BC674CD  bl 0x8234f350
	ctx.lr = 0x826E7E88;
	sub_8234F350(ctx, base);
	// 826E7E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E7E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7EA0 size=76
    let mut pc: u32 = 0x826E7EA0;
    'dispatch: loop {
        match pc {
            0x826E7EA0 => {
    //   block [0x826E7EA0..0x826E7EEC)
	// 826E7EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E7EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7EB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E7EBC: 4BFFFEFD  bl 0x826e7db8
	ctx.lr = 0x826E7EC0;
	sub_826E7DB8(ctx, base);
	// 826E7EC0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7EC4: 4182000C  beq 0x826e7ed0
	if ctx.cr[0].eq {
	pc = 0x826E7ED0; continue 'dispatch;
	}
	// 826E7EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7ECC: 4870A50D  bl 0x82df23d8
	ctx.lr = 0x826E7ED0;
	sub_82DF23D8(ctx, base);
	// 826E7ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7ED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E7ED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7EDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E7EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E7EF0 size=160
    let mut pc: u32 = 0x826E7EF0;
    'dispatch: loop {
        match pc {
            0x826E7EF0 => {
    //   block [0x826E7EF0..0x826E7F90)
	// 826E7EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E7EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E7EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E7F00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7F04: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E7F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7F0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E7F10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E7F14: 388BB1B0  addi r4, r11, -0x4e50
	ctx.r[4].s64 = ctx.r[11].s64 + -20048;
	// 826E7F18: 4870BAF1  bl 0x82df3a08
	ctx.lr = 0x826E7F1C;
	sub_82DF3A08(ctx, base);
	// 826E7F1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826E7F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7F24: 388B03D4  addi r4, r11, 0x3d4
	ctx.r[4].s64 = ctx.r[11].s64 + 980;
	// 826E7F28: 4870BAE1  bl 0x82df3a08
	ctx.lr = 0x826E7F2C;
	sub_82DF3A08(ctx, base);
	// 826E7F2C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E7F30: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826E7F34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E7F38: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 826E7F3C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E7F40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E7F44: 4BEBB4D5  bl 0x825a3418
	ctx.lr = 0x826E7F48;
	sub_825A3418(ctx, base);
	// 826E7F48: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E7F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E7F50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E7F54: 4BEB9F85  bl 0x825a1ed8
	ctx.lr = 0x826E7F58;
	sub_825A1ED8(ctx, base);
	// 826E7F58: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E7F5C: 4870B4CD  bl 0x82df3428
	ctx.lr = 0x826E7F60;
	sub_82DF3428(ctx, base);
	// 826E7F60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E7F64: 4BBE0D55  bl 0x822c8cb8
	ctx.lr = 0x826E7F68;
	sub_822C8CB8(ctx, base);
	// 826E7F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E7F6C: 4870B4BD  bl 0x82df3428
	ctx.lr = 0x826E7F70;
	sub_82DF3428(ctx, base);
	// 826E7F70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E7F74: 4870B4B5  bl 0x82df3428
	ctx.lr = 0x826E7F78;
	sub_82DF3428(ctx, base);
	// 826E7F78: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826E7F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E7F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E7F84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E7F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E7F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E7F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E7F90 size=516
    let mut pc: u32 = 0x826E7F90;
    'dispatch: loop {
        match pc {
            0x826E7F90 => {
    //   block [0x826E7F90..0x826E8194)
	// 826E7F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E7F94: 48AC01CD  bl 0x831a8160
	ctx.lr = 0x826E7F98;
	sub_831A8130(ctx, base);
	// 826E7F98: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E7F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E7FA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E7FA4: 4BE28765  bl 0x82510708
	ctx.lr = 0x826E7FA8;
	sub_82510708(ctx, base);
	// 826E7FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7FAC: 4BFFF61D  bl 0x826e75c8
	ctx.lr = 0x826E7FB0;
	sub_826E75C8(ctx, base);
	// 826E7FB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7FB4: 41820038  beq 0x826e7fec
	if ctx.cr[0].eq {
	pc = 0x826E7FEC; continue 'dispatch;
	}
	// 826E7FB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E7FBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7FC0: 4BFFF509  bl 0x826e74c8
	ctx.lr = 0x826E7FC4;
	sub_826E74C8(ctx, base);
	// 826E7FC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7FC8: 41820018  beq 0x826e7fe0
	if ctx.cr[0].eq {
	pc = 0x826E7FE0; continue 'dispatch;
	}
	// 826E7FCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E7FD0: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E7FD4: C00B0A90  lfs f0, 0xa90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E7FD8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826E7FDC: D01F0144  stfs f0, 0x144(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 826E7FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E7FE4: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E7FE8: 4BFFF401  bl 0x826e73e8
	ctx.lr = 0x826E7FEC;
	sub_826E73E8(ctx, base);
	// 826E7FEC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E7FF0: 484CC829  bl 0x82bb4818
	ctx.lr = 0x826E7FF4;
	sub_82BB4818(ctx, base);
	// 826E7FF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E7FF8: 41820010  beq 0x826e8008
	if ctx.cr[0].eq {
	pc = 0x826E8008; continue 'dispatch;
	}
	// 826E7FFC: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E8000: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E8004: 484CD4ED  bl 0x82bb54f0
	ctx.lr = 0x826E8008;
	sub_82BB54F0(ctx, base);
	// 826E8008: 897F0178  lbz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 826E800C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E8010: 4182017C  beq 0x826e818c
	if ctx.cr[0].eq {
	pc = 0x826E818C; continue 'dispatch;
	}
	// 826E8014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8018: 4BFFFA69  bl 0x826e7a80
	ctx.lr = 0x826E801C;
	sub_826E7A80(ctx, base);
	// 826E801C: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E8020: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E8024: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826E8028: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 826E802C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 826E8030: 419A0024  beq cr6, 0x826e8054
	if ctx.cr[6].eq {
	pc = 0x826E8054; continue 'dispatch;
	}
	// 826E8034: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826E8038: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E803C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8040: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E8044: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E8048: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E804C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8050: 4082FFE8  bne 0x826e8038
	if !ctx.cr[0].eq {
	pc = 0x826E8038; continue 'dispatch;
	}
	// 826E8054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8058: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E805C: 4BE2746D  bl 0x8250f4c8
	ctx.lr = 0x826E8060;
	sub_8250F4C8(ctx, base);
	// 826E8060: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E8068: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826E806C: 409A0008  bne cr6, 0x826e8074
	if !ctx.cr[6].eq {
	pc = 0x826E8074; continue 'dispatch;
	}
	// 826E8070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E8074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E8078: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 826E807C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 826E8080: 4BE20999  bl 0x82508a18
	ctx.lr = 0x826E8084;
	sub_82508A18(ctx, base);
	// 826E8084: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E8088: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826E808C: 3BABB440  addi r29, r11, -0x4bc0
	ctx.r[29].s64 = ctx.r[11].s64 + -19392;
	// 826E8090: 38A000CC  li r5, 0xcc
	ctx.r[5].s64 = 204;
	// 826E8094: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E8098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E809C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 826E80A0: 4876EF49  bl 0x82e56fe8
	ctx.lr = 0x826E80A4;
	sub_82E56FE8(ctx, base);
	// 826E80A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826E80A8: 48709BE9  bl 0x82df1c90
	ctx.lr = 0x826E80AC;
	sub_82DF1C90(ctx, base);
	// 826E80AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E80B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E80B4: 419A0008  beq cr6, 0x826e80bc
	if ctx.cr[6].eq {
	pc = 0x826E80BC; continue 'dispatch;
	}
	// 826E80B8: 4BBD87D9  bl 0x822c0890
	ctx.lr = 0x826E80BC;
	sub_822C0890(ctx, base);
	// 826E80BC: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E80C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E80C4: 418200B8  beq 0x826e817c
	if ctx.cr[0].eq {
	pc = 0x826E817C; continue 'dispatch;
	}
	// 826E80C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E80CC: 4BFFFA25  bl 0x826e7af0
	ctx.lr = 0x826E80D0;
	sub_826E7AF0(ctx, base);
	// 826E80D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E80D4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826E80D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E80DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E80E0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826E80E4: 419A0024  beq cr6, 0x826e8108
	if ctx.cr[6].eq {
	pc = 0x826E8108; continue 'dispatch;
	}
	// 826E80E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E80EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E80F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E80F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E80F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E80FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8100: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8104: 4082FFE8  bne 0x826e80ec
	if !ctx.cr[0].eq {
	pc = 0x826E80EC; continue 'dispatch;
	}
	// 826E8108: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E810C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E8110: 4BE273B9  bl 0x8250f4c8
	ctx.lr = 0x826E8114;
	sub_8250F4C8(ctx, base);
	// 826E8114: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E811C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826E8120: 409A0008  bne cr6, 0x826e8128
	if !ctx.cr[6].eq {
	pc = 0x826E8128; continue 'dispatch;
	}
	// 826E8124: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E8128: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E812C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 826E8130: 4BE208E9  bl 0x82508a18
	ctx.lr = 0x826E8134;
	sub_82508A18(ctx, base);
	// 826E8134: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E8138: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826E813C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E8140: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 826E8144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8148: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 826E814C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E8150: 487708F1  bl 0x82e58a40
	ctx.lr = 0x826E8154;
	sub_82E58A40(ctx, base);
	// 826E8154: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E8158: 48709B39  bl 0x82df1c90
	ctx.lr = 0x826E815C;
	sub_82DF1C90(ctx, base);
	// 826E815C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826E8160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8164: 419A0008  beq cr6, 0x826e816c
	if ctx.cr[6].eq {
	pc = 0x826E816C; continue 'dispatch;
	}
	// 826E8168: 4BBD8729  bl 0x822c0890
	ctx.lr = 0x826E816C;
	sub_822C0890(ctx, base);
	// 826E816C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E8170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8174: 419A0008  beq cr6, 0x826e817c
	if ctx.cr[6].eq {
	pc = 0x826E817C; continue 'dispatch;
	}
	// 826E8178: 4BBD8719  bl 0x822c0890
	ctx.lr = 0x826E817C;
	sub_822C0890(ctx, base);
	// 826E817C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826E8180: 419A000C  beq cr6, 0x826e818c
	if ctx.cr[6].eq {
	pc = 0x826E818C; continue 'dispatch;
	}
	// 826E8184: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E8188: 4BBD8709  bl 0x822c0890
	ctx.lr = 0x826E818C;
	sub_822C0890(ctx, base);
	// 826E818C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826E8190: 48AC0020  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E8198 size=424
    let mut pc: u32 = 0x826E8198;
    'dispatch: loop {
        match pc {
            0x826E8198 => {
    //   block [0x826E8198..0x826E8340)
	// 826E8198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E819C: 48ABFFC9  bl 0x831a8164
	ctx.lr = 0x826E81A0;
	sub_831A8130(ctx, base);
	// 826E81A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E81A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E81A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E81AC: 3BCBB440  addi r30, r11, -0x4bc0
	ctx.r[30].s64 = ctx.r[11].s64 + -19392;
	// 826E81B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E81B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E81B8: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 826E81BC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E81C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E81C4: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826E81C8: 4870A221  bl 0x82df23e8
	ctx.lr = 0x826E81CC;
	sub_82DF23E8(ctx, base);
	// 826E81CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E81D0: 41820010  beq 0x826e81e0
	if ctx.cr[0].eq {
	pc = 0x826E81E0; continue 'dispatch;
	}
	// 826E81D4: 4BFFFAED  bl 0x826e7cc0
	ctx.lr = 0x826E81D8;
	sub_826E7CC0(ctx, base);
	// 826E81D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E81DC: 48000008  b 0x826e81e4
	pc = 0x826E81E4; continue 'dispatch;
	// 826E81E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E81E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E81E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E81EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E81F0: 4BFFEFA1  bl 0x826e7190
	ctx.lr = 0x826E81F4;
	sub_826E7190(ctx, base);
	// 826E81F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E81F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E81FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E8200: 4BBD7E01  bl 0x822c0000
	ctx.lr = 0x826E8204;
	sub_822C0000(ctx, base);
	// 826E8204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E8208: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E820C: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 826E8210: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E8214: 4BBD81C5  bl 0x822c03d8
	ctx.lr = 0x826E8218;
	sub_822C03D8(ctx, base);
	// 826E8218: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E821C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E8220: 418200B4  beq 0x826e82d4
	if ctx.cr[0].eq {
	pc = 0x826E82D4; continue 'dispatch;
	}
	// 826E8224: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E8228: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E822C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E8230: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E8234: 409A0008  bne cr6, 0x826e823c
	if !ctx.cr[6].eq {
	pc = 0x826E823C; continue 'dispatch;
	}
	// 826E8238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E823C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E8240: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E8244: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E8248: 419A0024  beq cr6, 0x826e826c
	if ctx.cr[6].eq {
	pc = 0x826E826C; continue 'dispatch;
	}
	// 826E824C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E8250: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E8254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8258: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E825C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E8260: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8264: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8268: 4082FFE8  bne 0x826e8250
	if !ctx.cr[0].eq {
	pc = 0x826E8250; continue 'dispatch;
	}
	// 826E826C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E8270: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E8274: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E8278: 419A0024  beq cr6, 0x826e829c
	if ctx.cr[6].eq {
	pc = 0x826E829C; continue 'dispatch;
	}
	// 826E827C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E8280: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E8284: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8288: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E828C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E8290: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8294: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8298: 4082FFE8  bne 0x826e8280
	if !ctx.cr[0].eq {
	pc = 0x826E8280; continue 'dispatch;
	}
	// 826E829C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E82A0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E82A4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E82A8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E82AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E82B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E82B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E82B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E82BC: 480B0C75  bl 0x82798f30
	ctx.lr = 0x826E82C0;
	sub_82798F30(ctx, base);
	// 826E82C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E82C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E82C8: 480B33A1  bl 0x8279b668
	ctx.lr = 0x826E82CC;
	sub_8279B668(ctx, base);
	// 826E82CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E82D0: 48000008  b 0x826e82d8
	pc = 0x826E82D8; continue 'dispatch;
	// 826E82D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E82D8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E82DC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E82E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E82E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E82E8: 4BEAF969  bl 0x82597c50
	ctx.lr = 0x826E82EC;
	sub_82597C50(ctx, base);
	// 826E82EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E82F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E82F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E82F8: 4BBD7D09  bl 0x822c0000
	ctx.lr = 0x826E82FC;
	sub_822C0000(ctx, base);
	// 826E82FC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E8300: 41820024  beq 0x826e8324
	if ctx.cr[0].eq {
	pc = 0x826E8324; continue 'dispatch;
	}
	// 826E8304: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E8308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E830C: 419A0008  beq cr6, 0x826e8314
	if ctx.cr[6].eq {
	pc = 0x826E8314; continue 'dispatch;
	}
	// 826E8310: 4BBD8581  bl 0x822c0890
	ctx.lr = 0x826E8314;
	sub_822C0890(ctx, base);
	// 826E8314: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E8318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E831C: 419A0008  beq cr6, 0x826e8324
	if ctx.cr[6].eq {
	pc = 0x826E8324; continue 'dispatch;
	}
	// 826E8320: 4BBD8571  bl 0x822c0890
	ctx.lr = 0x826E8324;
	sub_822C0890(ctx, base);
	// 826E8324: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E8328: 419A000C  beq cr6, 0x826e8334
	if ctx.cr[6].eq {
	pc = 0x826E8334; continue 'dispatch;
	}
	// 826E832C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E8330: 4BBD8561  bl 0x822c0890
	ctx.lr = 0x826E8334;
	sub_822C0890(ctx, base);
	// 826E8334: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E8338: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E833C: 48ABFE78  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E8340 size=2340
    let mut pc: u32 = 0x826E8340;
    'dispatch: loop {
        match pc {
            0x826E8340 => {
    //   block [0x826E8340..0x826E8C64)
	// 826E8340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8344: 48ABFE01  bl 0x831a8144
	ctx.lr = 0x826E8348;
	sub_831A8130(ctx, base);
	// 826E8348: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E834C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 826E8350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E8354: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 826E8358: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 826E835C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826E8360: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 826E8364: 4BE29675  bl 0x825119d8
	ctx.lr = 0x826E8368;
	sub_825119D8(ctx, base);
	// 826E8368: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E836C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8370: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826E8374: 4870B695  bl 0x82df3a08
	ctx.lr = 0x826E8378;
	sub_82DF3A08(ctx, base);
	// 826E8378: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E837C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E8380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8384: 4BE203FD  bl 0x82508780
	ctx.lr = 0x826E8388;
	sub_82508780(ctx, base);
	// 826E8388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E838C: 4870B09D  bl 0x82df3428
	ctx.lr = 0x826E8390;
	sub_82DF3428(ctx, base);
	// 826E8390: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E8394: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826E8398: 409A0008  bne cr6, 0x826e83a0
	if !ctx.cr[6].eq {
	pc = 0x826E83A0; continue 'dispatch;
	}
	// 826E839C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E83A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E83A4: 4BE203FD  bl 0x825087a0
	ctx.lr = 0x826E83A8;
	sub_825087A0(ctx, base);
	// 826E83A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E83AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E83B0: 3AEBB440  addi r23, r11, -0x4bc0
	ctx.r[23].s64 = ctx.r[11].s64 + -19392;
	// 826E83B4: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 826E83B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826E83BC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826E83C0: 4870A029  bl 0x82df23e8
	ctx.lr = 0x826E83C4;
	sub_82DF23E8(ctx, base);
	// 826E83C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E83C8: 41820018  beq 0x826e83e0
	if ctx.cr[0].eq {
	pc = 0x826E83E0; continue 'dispatch;
	}
	// 826E83CC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826E83D0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826E83D4: 4872AD1D  bl 0x82e130f0
	ctx.lr = 0x826E83D8;
	sub_82E130F0(ctx, base);
	// 826E83D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E83DC: 48000008  b 0x826e83e4
	pc = 0x826E83E4; continue 'dispatch;
	// 826E83E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E83E4: 3B7F0118  addi r27, r31, 0x118
	ctx.r[27].s64 = ctx.r[31].s64 + 280;
	// 826E83E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E83EC: 4BBF9965  bl 0x822e1d50
	ctx.lr = 0x826E83F0;
	sub_822E1D50(ctx, base);
	// 826E83F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E83F4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826E83F8: 83DF0118  lwz r30, 0x118(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826E83FC: 4BE29D1D  bl 0x82512118
	ctx.lr = 0x826E8400;
	sub_82512118(ctx, base);
	// 826E8400: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E8404: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8408: 4872AA29  bl 0x82e12e30
	ctx.lr = 0x826E840C;
	sub_82E12E30(ctx, base);
	// 826E840C: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 826E8410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8414: 419A0008  beq cr6, 0x826e841c
	if ctx.cr[6].eq {
	pc = 0x826E841C; continue 'dispatch;
	}
	// 826E8418: 4BBD8479  bl 0x822c0890
	ctx.lr = 0x826E841C;
	sub_822C0890(ctx, base);
	// 826E841C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E8420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8424: 3BCBE254  addi r30, r11, -0x1dac
	ctx.r[30].s64 = ctx.r[11].s64 + -7596;
	// 826E8428: 808BE254  lwz r4, -0x1dac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7596 as u32) ) } as u64;
	// 826E842C: 4870B5DD  bl 0x82df3a08
	ctx.lr = 0x826E8430;
	sub_82DF3A08(ctx, base);
	// 826E8430: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E8434: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E843C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826E8440: 4BFE29E1  bl 0x826cae20
	ctx.lr = 0x826E8444;
	sub_826CAE20(ctx, base);
	// 826E8444: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E8448: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 826E844C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E8450: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826E8454: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8458: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826E845C: 4BBDC005  bl 0x822c4460
	ctx.lr = 0x826E8460;
	sub_822C4460(ctx, base);
	// 826E8460: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 826E8464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8468: 419A0008  beq cr6, 0x826e8470
	if ctx.cr[6].eq {
	pc = 0x826E8470; continue 'dispatch;
	}
	// 826E846C: 4BBD8425  bl 0x822c0890
	ctx.lr = 0x826E8470;
	sub_822C0890(ctx, base);
	// 826E8470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8474: 4870AFB5  bl 0x82df3428
	ctx.lr = 0x826E8478;
	sub_82DF3428(ctx, base);
	// 826E8478: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E847C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E8480: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8484: 4BE29C95  bl 0x82512118
	ctx.lr = 0x826E8488;
	sub_82512118(ctx, base);
	// 826E8488: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E848C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826E8490: 4872CC21  bl 0x82e150b0
	ctx.lr = 0x826E8494;
	sub_82E150B0(ctx, base);
	// 826E8494: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826E8498: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E849C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826E84A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E84A4: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826E84A8: 4BE286B1  bl 0x82510b58
	ctx.lr = 0x826E84AC;
	sub_82510B58(ctx, base);
	// 826E84AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E84B0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E84B4: 4870B555  bl 0x82df3a08
	ctx.lr = 0x826E84B8;
	sub_82DF3A08(ctx, base);
	// 826E84B8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E84BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E84C0: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E84C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826E84C8: 4BFE2959  bl 0x826cae20
	ctx.lr = 0x826E84CC;
	sub_826CAE20(ctx, base);
	// 826E84CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E84D0: 3B3F00F0  addi r25, r31, 0xf0
	ctx.r[25].s64 = ctx.r[31].s64 + 240;
	// 826E84D4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E84D8: 38790004  addi r3, r25, 4
	ctx.r[3].s64 = ctx.r[25].s64 + 4;
	// 826E84DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E84E0: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826E84E4: 4BBDBF7D  bl 0x822c4460
	ctx.lr = 0x826E84E8;
	sub_822C4460(ctx, base);
	// 826E84E8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826E84EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E84F0: 419A0008  beq cr6, 0x826e84f8
	if ctx.cr[6].eq {
	pc = 0x826E84F8; continue 'dispatch;
	}
	// 826E84F4: 4BBD839D  bl 0x822c0890
	ctx.lr = 0x826E84F8;
	sub_822C0890(ctx, base);
	// 826E84F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E84FC: 4870AF2D  bl 0x82df3428
	ctx.lr = 0x826E8500;
	sub_82DF3428(ctx, base);
	// 826E8500: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E8504: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E850C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826E8510: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826E8514: 419A0024  beq cr6, 0x826e8538
	if ctx.cr[6].eq {
	pc = 0x826E8538; continue 'dispatch;
	}
	// 826E8518: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E851C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E8520: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8524: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E8528: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E852C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8530: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8534: 4082FFE8  bne 0x826e851c
	if !ctx.cr[0].eq {
	pc = 0x826E851C; continue 'dispatch;
	}
	// 826E8538: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826E853C: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8540: 4872CB71  bl 0x82e150b0
	ctx.lr = 0x826E8544;
	sub_82E150B0(ctx, base);
	// 826E8544: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826E8548: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826E854C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826E8550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8554: 4BE28605  bl 0x82510b58
	ctx.lr = 0x826E8558;
	sub_82510B58(ctx, base);
	// 826E8558: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E855C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E8560: 3B8BB420  addi r28, r11, -0x4be0
	ctx.r[28].s64 = ctx.r[11].s64 + -19424;
	// 826E8564: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E8568: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826E856C: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 826E8570: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826E8574: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E8578: 912100EC  stw r9, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[9].u32 ) };
	// 826E857C: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 826E8580: 990100FC  stb r8, 0xfc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[8].u8 ) };
	// 826E8584: C1AB9534  lfs f13, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E8588: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826E858C: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 826E8590: D1A100F4  stfs f13, 0xf4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 826E8594: D1A100F8  stfs f13, 0xf8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 826E8598: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826E859C: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826E85A0: 48716329  bl 0x82dfe8c8
	ctx.lr = 0x826E85A4;
	sub_82DFE8C8(ctx, base);
	// 826E85A4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826E85A8: 48716321  bl 0x82dfe8c8
	ctx.lr = 0x826E85AC;
	sub_82DFE8C8(ctx, base);
	// 826E85AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E85B0: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826E85B4: 4870B455  bl 0x82df3a08
	ctx.lr = 0x826E85B8;
	sub_82DF3A08(ctx, base);
	// 826E85B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826E85BC: 38C100E0  addi r6, r1, 0xe0
	ctx.r[6].s64 = ctx.r[1].s64 + 224;
	// 826E85C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826E85C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E85C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E85CC: 4BFE2905  bl 0x826caed0
	ctx.lr = 0x826E85D0;
	sub_826CAED0(ctx, base);
	// 826E85D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E85D4: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 826E85D8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E85DC: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826E85E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E85E4: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826E85E8: 4BBDBE79  bl 0x822c4460
	ctx.lr = 0x826E85EC;
	sub_822C4460(ctx, base);
	// 826E85EC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E85F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E85F4: 419A0008  beq cr6, 0x826e85fc
	if ctx.cr[6].eq {
	pc = 0x826E85FC; continue 'dispatch;
	}
	// 826E85F8: 4BBD8299  bl 0x822c0890
	ctx.lr = 0x826E85FC;
	sub_822C0890(ctx, base);
	// 826E85FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8600: 4870AE29  bl 0x82df3428
	ctx.lr = 0x826E8604;
	sub_82DF3428(ctx, base);
	// 826E8604: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E8608: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E860C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E8610: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 826E8614: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 826E8618: 419A0024  beq cr6, 0x826e863c
	if ctx.cr[6].eq {
	pc = 0x826E863C; continue 'dispatch;
	}
	// 826E861C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E8620: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E8624: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8628: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E862C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E8630: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8634: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8638: 4082FFE8  bne 0x826e8620
	if !ctx.cr[0].eq {
	pc = 0x826E8620; continue 'dispatch;
	}
	// 826E863C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826E8640: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8644: 4872C92D  bl 0x82e14f70
	ctx.lr = 0x826E8648;
	sub_82E14F70(ctx, base);
	// 826E8648: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826E864C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8650: 419A0008  beq cr6, 0x826e8658
	if ctx.cr[6].eq {
	pc = 0x826E8658; continue 'dispatch;
	}
	// 826E8654: 4BBD823D  bl 0x822c0890
	ctx.lr = 0x826E8658;
	sub_822C0890(ctx, base);
	// 826E8658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826E865C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8660: 4870B3A9  bl 0x82df3a08
	ctx.lr = 0x826E8664;
	sub_82DF3A08(ctx, base);
	// 826E8664: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826E8668: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826E866C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8670: 484CACA1  bl 0x82bb3310
	ctx.lr = 0x826E8674;
	sub_82BB3310(ctx, base);
	// 826E8674: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826E8678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E867C: 419A0008  beq cr6, 0x826e8684
	if ctx.cr[6].eq {
	pc = 0x826E8684; continue 'dispatch;
	}
	// 826E8680: 4BBD8211  bl 0x822c0890
	ctx.lr = 0x826E8684;
	sub_822C0890(ctx, base);
	// 826E8684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8688: 4870ADA1  bl 0x82df3428
	ctx.lr = 0x826E868C;
	sub_82DF3428(ctx, base);
	// 826E868C: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8694: 419A006C  beq cr6, 0x826e8700
	if ctx.cr[6].eq {
	pc = 0x826E8700; continue 'dispatch;
	}
	// 826E8698: 48740D09  bl 0x82e293a0
	ctx.lr = 0x826E869C;
	sub_82E293A0(ctx, base);
	// 826E869C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E86A0: 40820060  bne 0x826e8700
	if !ctx.cr[0].eq {
	pc = 0x826E8700; continue 'dispatch;
	}
	// 826E86A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E86A8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E86AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E86B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826E86B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826E86B8: 419A0024  beq cr6, 0x826e86dc
	if ctx.cr[6].eq {
	pc = 0x826E86DC; continue 'dispatch;
	}
	// 826E86BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E86C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E86C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E86C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E86CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E86D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E86D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E86D8: 4082FFE8  bne 0x826e86c0
	if !ctx.cr[0].eq {
	pc = 0x826E86C0; continue 'dispatch;
	}
	// 826E86DC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826E86E0: 4BE023A9  bl 0x824eaa88
	ctx.lr = 0x826E86E4;
	sub_824EAA88(ctx, base);
	// 826E86E4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 826E86E8: 38C00079  li r6, 0x79
	ctx.r[6].s64 = 121;
	// 826E86EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E86F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826E86F4: 4BFE9A9D  bl 0x826d2190
	ctx.lr = 0x826E86F8;
	sub_826D2190(ctx, base);
	// 826E86F8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826E86FC: 48709595  bl 0x82df1c90
	ctx.lr = 0x826E8700;
	sub_82DF1C90(ctx, base);
	// 826E8700: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E8704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8708: 388BB30C  addi r4, r11, -0x4cf4
	ctx.r[4].s64 = ctx.r[11].s64 + -19700;
	// 826E870C: 4870B2FD  bl 0x82df3a08
	ctx.lr = 0x826E8710;
	sub_82DF3A08(ctx, base);
	// 826E8710: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826E8714: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826E8718: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E871C: 4872C915  bl 0x82e15030
	ctx.lr = 0x826E8720;
	sub_82E15030(ctx, base);
	// 826E8720: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E8724: 3B1F0120  addi r24, r31, 0x120
	ctx.r[24].s64 = ctx.r[31].s64 + 288;
	// 826E8728: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E872C: 38780004  addi r3, r24, 4
	ctx.r[3].s64 = ctx.r[24].s64 + 4;
	// 826E8730: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8734: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826E8738: 4BBDBD29  bl 0x822c4460
	ctx.lr = 0x826E873C;
	sub_822C4460(ctx, base);
	// 826E873C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826E8740: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8744: 419A0008  beq cr6, 0x826e874c
	if ctx.cr[6].eq {
	pc = 0x826E874C; continue 'dispatch;
	}
	// 826E8748: 4BBD8149  bl 0x822c0890
	ctx.lr = 0x826E874C;
	sub_822C0890(ctx, base);
	// 826E874C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8750: 4870ACD9  bl 0x82df3428
	ctx.lr = 0x826E8754;
	sub_82DF3428(ctx, base);
	// 826E8754: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8758: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 826E875C: 4870B2AD  bl 0x82df3a08
	ctx.lr = 0x826E8760;
	sub_82DF3A08(ctx, base);
	// 826E8760: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E8764: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 826E8768: 4870B2A1  bl 0x82df3a08
	ctx.lr = 0x826E876C;
	sub_82DF3A08(ctx, base);
	// 826E876C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826E8770: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 826E8774: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8778: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E877C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826E8780: 4BFE2621  bl 0x826cada0
	ctx.lr = 0x826E8784;
	sub_826CADA0(ctx, base);
	// 826E8784: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E8788: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 826E878C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E8790: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826E8794: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8798: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826E879C: 4BBDBCC5  bl 0x822c4460
	ctx.lr = 0x826E87A0;
	sub_822C4460(ctx, base);
	// 826E87A0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826E87A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E87A8: 419A0008  beq cr6, 0x826e87b0
	if ctx.cr[6].eq {
	pc = 0x826E87B0; continue 'dispatch;
	}
	// 826E87AC: 4BBD80E5  bl 0x822c0890
	ctx.lr = 0x826E87B0;
	sub_822C0890(ctx, base);
	// 826E87B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E87B4: 4870AC75  bl 0x82df3428
	ctx.lr = 0x826E87B8;
	sub_82DF3428(ctx, base);
	// 826E87B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E87BC: 4870AC6D  bl 0x82df3428
	ctx.lr = 0x826E87C0;
	sub_82DF3428(ctx, base);
	// 826E87C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E87C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E87C8: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E87CC: 4BE2994D  bl 0x82512118
	ctx.lr = 0x826E87D0;
	sub_82512118(ctx, base);
	// 826E87D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E87D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826E87D8: 4BC05789  bl 0x822edf60
	ctx.lr = 0x826E87DC;
	sub_822EDF60(ctx, base);
	// 826E87DC: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826E87E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E87E4: 809B6784  lwz r4, 0x6784(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26500 as u32) ) } as u64;
	// 826E87E8: 829D0000  lwz r20, 0(r29)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E87EC: 4BBFC745  bl 0x822e4f30
	ctx.lr = 0x826E87F0;
	sub_822E4F30(ctx, base);
	// 826E87F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E87F4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826E87F8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 826E87FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8800: 80AB6890  lwz r5, 0x6890(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26768 as u32) ) } as u64;
	// 826E8804: 808A683C  lwz r4, 0x683c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26684 as u32) ) } as u64;
	// 826E8808: 4BC0EF99  bl 0x822f77a0
	ctx.lr = 0x826E880C;
	sub_822F77A0(ctx, base);
	// 826E880C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826E8810: E8830000  ld r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826E8814: E8B30000  ld r5, 0(r19)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	// 826E8818: 807C674C  lwz r3, 0x674c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E881C: 4BDA3B55  bl 0x8248c370
	ctx.lr = 0x826E8820;
	sub_8248C370(ctx, base);
	// 826E8820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E8824: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826E8828: 4BDA6B79  bl 0x8248f3a0
	ctx.lr = 0x826E882C;
	sub_8248F3A0(ctx, base);
	// 826E882C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E8830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8834: 4BE2850D  bl 0x82510d40
	ctx.lr = 0x826E8838;
	sub_82510D40(ctx, base);
	// 826E8838: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E883C: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 826E8840: 4870B1C9  bl 0x82df3a08
	ctx.lr = 0x826E8844;
	sub_82DF3A08(ctx, base);
	// 826E8844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8848: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 826E884C: 4870B1BD  bl 0x82df3a08
	ctx.lr = 0x826E8850;
	sub_82DF3A08(ctx, base);
	// 826E8850: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 826E8854: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826E8858: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E885C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8860: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E8864: 4BFE253D  bl 0x826cada0
	ctx.lr = 0x826E8868;
	sub_826CADA0(ctx, base);
	// 826E8868: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E886C: 3BBF0108  addi r29, r31, 0x108
	ctx.r[29].s64 = ctx.r[31].s64 + 264;
	// 826E8870: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E8874: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826E8878: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E887C: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826E8880: 4BBDBBE1  bl 0x822c4460
	ctx.lr = 0x826E8884;
	sub_822C4460(ctx, base);
	// 826E8884: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826E8888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E888C: 419A0008  beq cr6, 0x826e8894
	if ctx.cr[6].eq {
	pc = 0x826E8894; continue 'dispatch;
	}
	// 826E8890: 4BBD8001  bl 0x822c0890
	ctx.lr = 0x826E8894;
	sub_822C0890(ctx, base);
	// 826E8894: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8898: 4870AB91  bl 0x82df3428
	ctx.lr = 0x826E889C;
	sub_82DF3428(ctx, base);
	// 826E889C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E88A0: 4870AB89  bl 0x82df3428
	ctx.lr = 0x826E88A4;
	sub_82DF3428(ctx, base);
	// 826E88A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E88A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E88AC: 829D0000  lwz r20, 0(r29)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E88B0: 4BE29869  bl 0x82512118
	ctx.lr = 0x826E88B4;
	sub_82512118(ctx, base);
	// 826E88B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E88B8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826E88BC: 4BC056A5  bl 0x822edf60
	ctx.lr = 0x826E88C0;
	sub_822EDF60(ctx, base);
	// 826E88C0: 809C674C  lwz r4, 0x674c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E88C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E88C8: 4BDA6AD9  bl 0x8248f3a0
	ctx.lr = 0x826E88CC;
	sub_8248F3A0(ctx, base);
	// 826E88CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E88D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E88D4: 4BE2846D  bl 0x82510d40
	ctx.lr = 0x826E88D8;
	sub_82510D40(ctx, base);
	// 826E88D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E88DC: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E88E0: 4870B129  bl 0x82df3a08
	ctx.lr = 0x826E88E4;
	sub_82DF3A08(ctx, base);
	// 826E88E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E88E8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 826E88EC: 4870B11D  bl 0x82df3a08
	ctx.lr = 0x826E88F0;
	sub_82DF3A08(ctx, base);
	// 826E88F0: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 826E88F4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826E88F8: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E88FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8900: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826E8904: 4BFE249D  bl 0x826cada0
	ctx.lr = 0x826E8908;
	sub_826CADA0(ctx, base);
	// 826E8908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E890C: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 826E8910: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826E8914: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826E8918: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E891C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826E8920: 4BBDBB41  bl 0x822c4460
	ctx.lr = 0x826E8924;
	sub_822C4460(ctx, base);
	// 826E8924: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 826E8928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E892C: 419A0008  beq cr6, 0x826e8934
	if ctx.cr[6].eq {
	pc = 0x826E8934; continue 'dispatch;
	}
	// 826E8930: 4BBD7F61  bl 0x822c0890
	ctx.lr = 0x826E8934;
	sub_822C0890(ctx, base);
	// 826E8934: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8938: 4870AAF1  bl 0x82df3428
	ctx.lr = 0x826E893C;
	sub_82DF3428(ctx, base);
	// 826E893C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E8940: 4870AAE9  bl 0x82df3428
	ctx.lr = 0x826E8944;
	sub_82DF3428(ctx, base);
	// 826E8944: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 826E8948: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E894C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E8950: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826E8954: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826E8958: 419A0024  beq cr6, 0x826e897c
	if ctx.cr[6].eq {
	pc = 0x826E897C; continue 'dispatch;
	}
	// 826E895C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826E8960: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E8964: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8968: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E896C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E8970: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8974: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8978: 4082FFE8  bne 0x826e8960
	if !ctx.cr[0].eq {
	pc = 0x826E8960; continue 'dispatch;
	}
	// 826E897C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826E8980: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8984: 4BC055DD  bl 0x822edf60
	ctx.lr = 0x826E8988;
	sub_822EDF60(ctx, base);
	// 826E8988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826E898C: 809B6784  lwz r4, 0x6784(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26500 as u32) ) } as u64;
	// 826E8990: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8994: 4BBFC59D  bl 0x822e4f30
	ctx.lr = 0x826E8998;
	sub_822E4F30(ctx, base);
	// 826E8998: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826E899C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E89A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E89A4: 808B684C  lwz r4, 0x684c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26700 as u32) ) } as u64;
	// 826E89A8: 4BBFC589  bl 0x822e4f30
	ctx.lr = 0x826E89AC;
	sub_822E4F30(ctx, base);
	// 826E89AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E89B0: 807C674C  lwz r3, 0x674c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826E89B4: E8BB0000  ld r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 826E89B8: E88B0000  ld r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 826E89BC: 4BDA39B5  bl 0x8248c370
	ctx.lr = 0x826E89C0;
	sub_8248C370(ctx, base);
	// 826E89C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E89C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E89C8: 4BDA69D9  bl 0x8248f3a0
	ctx.lr = 0x826E89CC;
	sub_8248F3A0(ctx, base);
	// 826E89CC: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 826E89D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E89D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826E89D8: 480F1601  bl 0x827d9fd8
	ctx.lr = 0x826E89DC;
	sub_827D9FD8(ctx, base);
	// 826E89DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E89E0: 4BBFE3A1  bl 0x822e6d80
	ctx.lr = 0x826E89E4;
	sub_822E6D80(ctx, base);
	// 826E89E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E89E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E89EC: 4BE28355  bl 0x82510d40
	ctx.lr = 0x826E89F0;
	sub_82510D40(ctx, base);
	// 826E89F0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826E89F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E89F8: 38A00098  li r5, 0x98
	ctx.r[5].s64 = 152;
	// 826E89FC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826E8A00: 487099E9  bl 0x82df23e8
	ctx.lr = 0x826E8A04;
	sub_82DF23E8(ctx, base);
	// 826E8A04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E8A08: 4182001C  beq 0x826e8a24
	if ctx.cr[0].eq {
	pc = 0x826E8A24; continue 'dispatch;
	}
	// 826E8A0C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 826E8A10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826E8A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8A18: 4BFE2CF9  bl 0x826cb710
	ctx.lr = 0x826E8A1C;
	sub_826CB710(ctx, base);
	// 826E8A1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E8A20: 48000008  b 0x826e8a28
	pc = 0x826E8A28; continue 'dispatch;
	// 826E8A24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E8A28: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 826E8A2C: 4BFDC995  bl 0x826c53c0
	ctx.lr = 0x826E8A30;
	sub_826C53C0(ctx, base);
	// 826E8A30: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E8A34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8A38: 388BB560  addi r4, r11, -0x4aa0
	ctx.r[4].s64 = ctx.r[11].s64 + -19104;
	// 826E8A3C: 4870AFCD  bl 0x82df3a08
	ctx.lr = 0x826E8A40;
	sub_82DF3A08(ctx, base);
	// 826E8A40: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826E8A44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E8A48: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8A4C: 4872C5E5  bl 0x82e15030
	ctx.lr = 0x826E8A50;
	sub_82E15030(ctx, base);
	// 826E8A50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8A54: 4870A9D5  bl 0x82df3428
	ctx.lr = 0x826E8A58;
	sub_82DF3428(ctx, base);
	// 826E8A58: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826E8A5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E8A60: 38A0009E  li r5, 0x9e
	ctx.r[5].s64 = 158;
	// 826E8A64: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 826E8A68: 48709981  bl 0x82df23e8
	ctx.lr = 0x826E8A6C;
	sub_82DF23E8(ctx, base);
	// 826E8A6C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826E8A70: 4182007C  beq 0x826e8aec
	if ctx.cr[0].eq {
	pc = 0x826E8AEC; continue 'dispatch;
	}
	// 826E8A74: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8A78: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826E8A7C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826E8A80: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 826E8A84: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826E8A88: 487B7CA9  bl 0x82ea0730
	ctx.lr = 0x826E8A8C;
	sub_82EA0730(ctx, base);
	// 826E8A8C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 826E8A90: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E8A94: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 826E8A98: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E8A9C: 48831755  bl 0x82f1a1f0
	ctx.lr = 0x826E8AA0;
	sub_82F1A1F0(ctx, base);
	// 826E8AA0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E8AA4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826E8AA8: 388BB548  addi r4, r11, -0x4ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -19128;
	// 826E8AAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E8AB0: 4870AF59  bl 0x82df3a08
	ctx.lr = 0x826E8AB4;
	sub_82DF3A08(ctx, base);
	// 826E8AB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E8AB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8ABC: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 826E8AC0: 4870AF49  bl 0x82df3a08
	ctx.lr = 0x826E8AC4;
	sub_82DF3A08(ctx, base);
	// 826E8AC4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E8AC8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 826E8ACC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826E8AD0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 826E8AD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E8AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8ADC: 3AC00003  li r22, 3
	ctx.r[22].s64 = 3;
	// 826E8AE0: 480CB111  bl 0x827b3bf0
	ctx.lr = 0x826E8AE4;
	sub_827B3BF0(ctx, base);
	// 826E8AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E8AE8: 48000008  b 0x826e8af0
	pc = 0x826E8AF0; continue 'dispatch;
	// 826E8AEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826E8AF0: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 826E8AF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E8AF8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826E8AFC: 4BF02ABD  bl 0x825eb5b8
	ctx.lr = 0x826E8B00;
	sub_825EB5B8(ctx, base);
	// 826E8B00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826E8B04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E8B08: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826E8B0C: 4BBD74F5  bl 0x822c0000
	ctx.lr = 0x826E8B10;
	sub_822C0000(ctx, base);
	// 826E8B10: 56CB07BD  rlwinm. r11, r22, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E8B14: 41820010  beq 0x826e8b24
	if ctx.cr[0].eq {
	pc = 0x826E8B24; continue 'dispatch;
	}
	// 826E8B18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E8B1C: 56D607FA  rlwinm r22, r22, 0, 0x1f, 0x1d
	ctx.r[22].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 826E8B20: 4870A909  bl 0x82df3428
	ctx.lr = 0x826E8B24;
	sub_82DF3428(ctx, base);
	// 826E8B24: 56CB07FF  clrlwi. r11, r22, 0x1f
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E8B28: 4182000C  beq 0x826e8b34
	if ctx.cr[0].eq {
	pc = 0x826E8B34; continue 'dispatch;
	}
	// 826E8B2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E8B30: 4870A8F9  bl 0x82df3428
	ctx.lr = 0x826E8B34;
	sub_82DF3428(ctx, base);
	// 826E8B34: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826E8B38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E8B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8B40: 4BECD471  bl 0x825b5fb0
	ctx.lr = 0x826E8B44;
	sub_825B5FB0(ctx, base);
	// 826E8B44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E8B48: 48920471  bl 0x83008fb8
	ctx.lr = 0x826E8B4C;
	sub_83008FB8(ctx, base);
	// 826E8B4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E8B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8B54: 4844E095  bl 0x82b36be8
	ctx.lr = 0x826E8B58;
	sub_82B36BE8(ctx, base);
	// 826E8B58: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826E8B5C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 826E8B60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E8B64: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E8B68: 419A0024  beq cr6, 0x826e8b8c
	if ctx.cr[6].eq {
	pc = 0x826E8B8C; continue 'dispatch;
	}
	// 826E8B6C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E8B70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E8B74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8B78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E8B7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E8B80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E8B84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E8B88: 4082FFE8  bne 0x826e8b70
	if !ctx.cr[0].eq {
	pc = 0x826E8B70; continue 'dispatch;
	}
	// 826E8B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8B90: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E8B94: 4BE26935  bl 0x8250f4c8
	ctx.lr = 0x826E8B98;
	sub_8250F4C8(ctx, base);
	// 826E8B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E8BA0: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826E8BA4: 409A0008  bne cr6, 0x826e8bac
	if !ctx.cr[6].eq {
	pc = 0x826E8BAC; continue 'dispatch;
	}
	// 826E8BA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826E8BAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E8BB0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826E8BB4: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 826E8BB8: 4BE26961  bl 0x8250f518
	ctx.lr = 0x826E8BBC;
	sub_8250F518(ctx, base);
	// 826E8BBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E8BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8BC4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826E8BC8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826E8BCC: 4BE2493D  bl 0x8250d508
	ctx.lr = 0x826E8BD0;
	sub_8250D508(ctx, base);
	// 826E8BD0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826E8BD4: 487090BD  bl 0x82df1c90
	ctx.lr = 0x826E8BD8;
	sub_82DF1C90(ctx, base);
	// 826E8BD8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826E8BDC: 487090B5  bl 0x82df1c90
	ctx.lr = 0x826E8BE0;
	sub_82DF1C90(ctx, base);
	// 826E8BE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E8BE4: 419A000C  beq cr6, 0x826e8bf0
	if ctx.cr[6].eq {
	pc = 0x826E8BF0; continue 'dispatch;
	}
	// 826E8BE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E8BEC: 4BBD7CA5  bl 0x822c0890
	ctx.lr = 0x826E8BF0;
	sub_822C0890(ctx, base);
	// 826E8BF0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E8BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8BF8: 419A0008  beq cr6, 0x826e8c00
	if ctx.cr[6].eq {
	pc = 0x826E8C00; continue 'dispatch;
	}
	// 826E8BFC: 4BBD7C95  bl 0x822c0890
	ctx.lr = 0x826E8C00;
	sub_822C0890(ctx, base);
	// 826E8C00: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826E8C04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E8C08: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 826E8C0C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 826E8C10: 4BBD77C9  bl 0x822c03d8
	ctx.lr = 0x826E8C14;
	sub_822C03D8(ctx, base);
	// 826E8C14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E8C18: 41820014  beq 0x826e8c2c
	if ctx.cr[0].eq {
	pc = 0x826E8C2C; continue 'dispatch;
	}
	// 826E8C1C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826E8C20: 4BDA84D1  bl 0x824910f0
	ctx.lr = 0x826E8C24;
	sub_824910F0(ctx, base);
	// 826E8C24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E8C28: 48000008  b 0x826e8c30
	pc = 0x826E8C30; continue 'dispatch;
	// 826E8C2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826E8C30: 387F0128  addi r3, r31, 0x128
	ctx.r[3].s64 = ctx.r[31].s64 + 296;
	// 826E8C34: 4BC21AAD  bl 0x8230a6e0
	ctx.lr = 0x826E8C38;
	sub_8230A6E0(ctx, base);
	// 826E8C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8C3C: 4BE28EAD  bl 0x82511ae8
	ctx.lr = 0x826E8C40;
	sub_82511AE8(ctx, base);
	// 826E8C40: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 826E8C44: 39400140  li r10, 0x140
	ctx.r[10].s64 = 320;
	// 826E8C48: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E8C68 size=184
    let mut pc: u32 = 0x826E8C68;
    'dispatch: loop {
        match pc {
            0x826E8C68 => {
    //   block [0x826E8C68..0x826E8D20)
	// 826E8C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E8C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E8C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E8C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E8C7C: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826E8C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E8C84: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826E8C88: 419A0044  beq cr6, 0x826e8ccc
	if ctx.cr[6].eq {
	pc = 0x826E8CCC; continue 'dispatch;
	}
	// 826E8C8C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826E8C90: 409A0078  bne cr6, 0x826e8d08
	if !ctx.cr[6].eq {
	pc = 0x826E8D08; continue 'dispatch;
	}
	// 826E8C94: 897F0178  lbz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 826E8C98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826E8C9C: 93DF0194  stw r30, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[30].u32 ) };
	// 826E8CA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E8CA4: 41820020  beq 0x826e8cc4
	if ctx.cr[0].eq {
	pc = 0x826E8CC4; continue 'dispatch;
	}
	// 826E8CA8: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826E8CAC: 9BDF0178  stb r30, 0x178(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u8 ) };
	// 826E8CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8CB4: 419A0010  beq cr6, 0x826e8cc4
	if ctx.cr[6].eq {
	pc = 0x826E8CC4; continue 'dispatch;
	}
	// 826E8CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E8CBC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E8CC0: 480E2859  bl 0x827cb518
	ctx.lr = 0x826E8CC4;
	sub_827CB518(ctx, base);
	// 826E8CC4: 9BDF0190  stb r30, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[30].u8 ) };
	// 826E8CC8: 48000034  b 0x826e8cfc
	pc = 0x826E8CFC; continue 'dispatch;
	// 826E8CCC: 895F0178  lbz r10, 0x178(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 826E8CD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826E8CD4: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 826E8CD8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826E8CDC: 419A0020  beq cr6, 0x826e8cfc
	if ctx.cr[6].eq {
	pc = 0x826E8CFC; continue 'dispatch;
	}
	// 826E8CE0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826E8CE4: 997F0178  stb r11, 0x178(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u8 ) };
	// 826E8CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8CEC: 419A0010  beq cr6, 0x826e8cfc
	if ctx.cr[6].eq {
	pc = 0x826E8CFC; continue 'dispatch;
	}
	// 826E8CF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E8CF4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E8CF8: 480E2821  bl 0x827cb518
	ctx.lr = 0x826E8CFC;
	sub_827CB518(ctx, base);
	// 826E8CFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E8D00: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E8D04: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 826E8D08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E8D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E8D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E8D14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E8D18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E8D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E8D20 size=224
    let mut pc: u32 = 0x826E8D20;
    'dispatch: loop {
        match pc {
            0x826E8D20 => {
    //   block [0x826E8D20..0x826E8E00)
	// 826E8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E8D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E8D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E8D30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E8D34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E8D38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E8D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E8D40: 48000D99  bl 0x826e9ad8
	ctx.lr = 0x826E8D44;
	sub_826E9AD8(ctx, base);
	// 826E8D44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E8D48: 4182005C  beq 0x826e8da4
	if ctx.cr[0].eq {
	pc = 0x826E8DA4; continue 'dispatch;
	}
	// 826E8D4C: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 826E8D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8D54: 4BE28D2D  bl 0x82511a80
	ctx.lr = 0x826E8D58;
	sub_82511A80(ctx, base);
	// 826E8D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8D5C: 4BE28D8D  bl 0x82511ae8
	ctx.lr = 0x826E8D60;
	sub_82511AE8(ctx, base);
	// 826E8D60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E8D64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826E8D68: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E8D6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E8D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8D74: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E8E00 size=196
    let mut pc: u32 = 0x826E8E00;
    'dispatch: loop {
        match pc {
            0x826E8E00 => {
    //   block [0x826E8E00..0x826E8EC4)
	// 826E8E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E8E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E8E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E8E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E8E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E8E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E8E1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E8E20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E8E24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E8E28: 4BBD7B11  bl 0x822c0938
	ctx.lr = 0x826E8E2C;
	sub_822C0938(ctx, base);
	// 826E8E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E8E30: 41820028  beq 0x826e8e58
	if ctx.cr[0].eq {
	pc = 0x826E8E58; continue 'dispatch;
	}
	// 826E8E34: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E8E38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E8E3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E8E40: 392BB590  addi r9, r11, -0x4a70
	ctx.r[9].s64 = ctx.r[11].s64 + -19056;
	// 826E8E44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E8E48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E8E4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E8E50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E8E54: 48000008  b 0x826e8e5c
	pc = 0x826E8E5C; continue 'dispatch;
	// 826E8E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E8E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E8E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E8E64: 409A0044  bne cr6, 0x826e8ea8
	if !ctx.cr[6].eq {
	pc = 0x826E8EA8; continue 'dispatch;
	}
	// 826E8E68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E8E6C: 419A001C  beq cr6, 0x826e8e88
	if ctx.cr[6].eq {
	pc = 0x826E8E88; continue 'dispatch;
	}
	// 826E8E70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8E74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E8E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8E7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E8E80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E8E84: 4E800421  bctrl
	ctx.lr = 0x826E8E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E8E88: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E8E8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E8E90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E8E94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E8E98: 816BE3A4  lwz r11, -0x1c5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7260 as u32) ) } as u64;
	// 826E8E9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E8EA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E8EA4: 4BBD715D  bl 0x822c0000
	ctx.lr = 0x826E8EA8;
	sub_822C0000(ctx, base);
	// 826E8EA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E8EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E8EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E8EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E8EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E8EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E8EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E8EC8 size=180
    let mut pc: u32 = 0x826E8EC8;
    'dispatch: loop {
        match pc {
            0x826E8EC8 => {
    //   block [0x826E8EC8..0x826E8F7C)
	// 826E8EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E8ED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E8ED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E8ED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E8EDC: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 826E8EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8EE4: 419A0008  beq cr6, 0x826e8eec
	if ctx.cr[6].eq {
	pc = 0x826E8EEC; continue 'dispatch;
	}
	// 826E8EE8: 4BBD79A9  bl 0x822c0890
	ctx.lr = 0x826E8EEC;
	sub_822C0890(ctx, base);
	// 826E8EEC: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 826E8EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8EF4: 419A0008  beq cr6, 0x826e8efc
	if ctx.cr[6].eq {
	pc = 0x826E8EFC; continue 'dispatch;
	}
	// 826E8EF8: 4BBD7999  bl 0x822c0890
	ctx.lr = 0x826E8EFC;
	sub_822C0890(ctx, base);
	// 826E8EFC: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826E8F00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8F04: 419A0008  beq cr6, 0x826e8f0c
	if ctx.cr[6].eq {
	pc = 0x826E8F0C; continue 'dispatch;
	}
	// 826E8F08: 4BBD7989  bl 0x822c0890
	ctx.lr = 0x826E8F0C;
	sub_822C0890(ctx, base);
	// 826E8F0C: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826E8F10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8F14: 419A0008  beq cr6, 0x826e8f1c
	if ctx.cr[6].eq {
	pc = 0x826E8F1C; continue 'dispatch;
	}
	// 826E8F18: 4BBD7979  bl 0x822c0890
	ctx.lr = 0x826E8F1C;
	sub_822C0890(ctx, base);
	// 826E8F1C: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826E8F20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8F24: 419A0008  beq cr6, 0x826e8f2c
	if ctx.cr[6].eq {
	pc = 0x826E8F2C; continue 'dispatch;
	}
	// 826E8F28: 4BBD7969  bl 0x822c0890
	ctx.lr = 0x826E8F2C;
	sub_822C0890(ctx, base);
	// 826E8F2C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826E8F30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8F34: 419A0008  beq cr6, 0x826e8f3c
	if ctx.cr[6].eq {
	pc = 0x826E8F3C; continue 'dispatch;
	}
	// 826E8F38: 4BBD7959  bl 0x822c0890
	ctx.lr = 0x826E8F3C;
	sub_822C0890(ctx, base);
	// 826E8F3C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826E8F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E8F44: 419A0008  beq cr6, 0x826e8f4c
	if ctx.cr[6].eq {
	pc = 0x826E8F4C; continue 'dispatch;
	}
	// 826E8F48: 4BBD7949  bl 0x822c0890
	ctx.lr = 0x826E8F4C;
	sub_822C0890(ctx, base);
	// 826E8F4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E8F50: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826E8F54: 409A0008  bne cr6, 0x826e8f5c
	if !ctx.cr[6].eq {
	pc = 0x826E8F5C; continue 'dispatch;
	}
	// 826E8F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826E8F5C: 480BE6FD  bl 0x827a7658
	ctx.lr = 0x826E8F60;
	sub_827A7658(ctx, base);
	// 826E8F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E8F64: 4BC663ED  bl 0x8234f350
	ctx.lr = 0x826E8F68;
	sub_8234F350(ctx, base);
	// 826E8F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E8F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E8F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E8F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E8F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E8F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E8F80 size=1104
    let mut pc: u32 = 0x826E8F80;
    'dispatch: loop {
        match pc {
            0x826E8F80 => {
    //   block [0x826E8F80..0x826E93D0)
	// 826E8F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E8F84: 48ABF1E1  bl 0x831a8164
	ctx.lr = 0x826E8F88;
	sub_831A8130(ctx, base);
	// 826E8F88: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 826E8F8C: 48ABFAED  bl 0x831a8a78
	ctx.lr = 0x826E8F90;
	sub_831A8A40(ctx, base);
	// 826E8F90: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E93D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E93D0 size=152
    let mut pc: u32 = 0x826E93D0;
    'dispatch: loop {
        match pc {
            0x826E93D0 => {
    //   block [0x826E93D0..0x826E9468)
	// 826E93D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E93D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E93D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E93DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E93E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E93E4: 48000D8D  bl 0x826ea170
	ctx.lr = 0x826E93E8;
	sub_826EA170(ctx, base);
	// 826E93E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E93EC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826E93F0: 396BB66C  addi r11, r11, -0x4994
	ctx.r[11].s64 = ctx.r[11].s64 + -18836;
	// 826E93F4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826E93F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E93FC: 394AB658  addi r10, r10, -0x49a8
	ctx.r[10].s64 = ctx.r[10].s64 + -18856;
	// 826E9400: 3929B60C  addi r9, r9, -0x49f4
	ctx.r[9].s64 = ctx.r[9].s64 + -18932;
	// 826E9404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E9408: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826E940C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826E9410: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E9414: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 826E9418: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826E941C: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 826E9420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9424: 997F0178  stb r11, 0x178(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u8 ) };
	// 826E9428: 917F017C  stw r11, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 826E942C: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 826E9430: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E9434: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 826E9438: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826E943C: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 826E9440: D01F0198  stfs f0, 0x198(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 826E9444: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826E9448: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 826E944C: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 826E9450: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 826E9454: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E9458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E945C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E9460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E9464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E9468 size=8
    let mut pc: u32 = 0x826E9468;
    'dispatch: loop {
        match pc {
            0x826E9468 => {
    //   block [0x826E9468..0x826E9470)
	// 826E9468: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826E946C: 4800006C  b 0x826e94d8
	sub_826E94D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E9470 size=8
    let mut pc: u32 = 0x826E9470;
    'dispatch: loop {
        match pc {
            0x826E9470 => {
    //   block [0x826E9470..0x826E9478)
	// 826E9470: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826E9474: 48000064  b 0x826e94d8
	sub_826E94D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E9478 size=96
    let mut pc: u32 = 0x826E9478;
    'dispatch: loop {
        match pc {
            0x826E9478 => {
    //   block [0x826E9478..0x826E94D8)
	// 826E9478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E947C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E9480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E9484: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E9488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E948C: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826E9490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E9494: 419A0008  beq cr6, 0x826e949c
	if ctx.cr[6].eq {
	pc = 0x826E949C; continue 'dispatch;
	}
	// 826E9498: 4BBD73F9  bl 0x822c0890
	ctx.lr = 0x826E949C;
	sub_822C0890(ctx, base);
	// 826E949C: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826E94A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E94A4: 419A0008  beq cr6, 0x826e94ac
	if ctx.cr[6].eq {
	pc = 0x826E94AC; continue 'dispatch;
	}
	// 826E94A8: 4BBD73E9  bl 0x822c0890
	ctx.lr = 0x826E94AC;
	sub_822C0890(ctx, base);
	// 826E94AC: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 826E94B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E94B4: 419A0008  beq cr6, 0x826e94bc
	if ctx.cr[6].eq {
	pc = 0x826E94BC; continue 'dispatch;
	}
	// 826E94B8: 4BBD73D9  bl 0x822c0890
	ctx.lr = 0x826E94BC;
	sub_822C0890(ctx, base);
	// 826E94BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E94C0: 4BFFFA09  bl 0x826e8ec8
	ctx.lr = 0x826E94C4;
	sub_826E8EC8(ctx, base);
	// 826E94C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826E94C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E94CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E94D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E94D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E94D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E94D8 size=76
    let mut pc: u32 = 0x826E94D8;
    'dispatch: loop {
        match pc {
            0x826E94D8 => {
    //   block [0x826E94D8..0x826E9524)
	// 826E94D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E94DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E94E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E94E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E94E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E94EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E94F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E94F4: 4BFFFF85  bl 0x826e9478
	ctx.lr = 0x826E94F8;
	sub_826E9478(ctx, base);
	// 826E94F8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E94FC: 4182000C  beq 0x826e9508
	if ctx.cr[0].eq {
	pc = 0x826E9508; continue 'dispatch;
	}
	// 826E9500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9504: 48708ED5  bl 0x82df23d8
	ctx.lr = 0x826E9508;
	sub_82DF23D8(ctx, base);
	// 826E9508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E950C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E9510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E9514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E9518: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E951C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E9520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E9528 size=176
    let mut pc: u32 = 0x826E9528;
    'dispatch: loop {
        match pc {
            0x826E9528 => {
    //   block [0x826E9528..0x826E95D8)
	// 826E9528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E952C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E9530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E9534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E9538: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E953C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E9540: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E9544: 4BBD6ABD  bl 0x822c0000
	ctx.lr = 0x826E9548;
	sub_822C0000(ctx, base);
	// 826E9548: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E954C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E9550: 388BB6B8  addi r4, r11, -0x4948
	ctx.r[4].s64 = ctx.r[11].s64 + -18760;
	// 826E9554: 4870A4B5  bl 0x82df3a08
	ctx.lr = 0x826E9558;
	sub_82DF3A08(ctx, base);
	// 826E9558: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E955C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E9560: 388BB6A8  addi r4, r11, -0x4958
	ctx.r[4].s64 = ctx.r[11].s64 + -18776;
	// 826E9564: 4870A4A5  bl 0x82df3a08
	ctx.lr = 0x826E9568;
	sub_82DF3A08(ctx, base);
	// 826E9568: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E956C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826E9570: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E9574: 38BF00B8  addi r5, r31, 0xb8
	ctx.r[5].s64 = ctx.r[31].s64 + 184;
	// 826E9578: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826E957C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826E9580: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826E9584: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826E9588: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E958C: 4BEB9D1D  bl 0x825a32a8
	ctx.lr = 0x826E9590;
	sub_825A32A8(ctx, base);
	// 826E9590: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826E9594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E9598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E959C: 4BEB81D5  bl 0x825a1770
	ctx.lr = 0x826E95A0;
	sub_825A1770(ctx, base);
	// 826E95A0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826E95A4: 48709E85  bl 0x82df3428
	ctx.lr = 0x826E95A8;
	sub_82DF3428(ctx, base);
	// 826E95A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826E95AC: 4BBDF70D  bl 0x822c8cb8
	ctx.lr = 0x826E95B0;
	sub_822C8CB8(ctx, base);
	// 826E95B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E95B4: 48709E75  bl 0x82df3428
	ctx.lr = 0x826E95B8;
	sub_82DF3428(ctx, base);
	// 826E95B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E95BC: 48709E6D  bl 0x82df3428
	ctx.lr = 0x826E95C0;
	sub_82DF3428(ctx, base);
	// 826E95C0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826E95C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E95C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E95CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E95D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E95D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E95D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E95D8 size=428
    let mut pc: u32 = 0x826E95D8;
    'dispatch: loop {
        match pc {
            0x826E95D8 => {
    //   block [0x826E95D8..0x826E9784)
	// 826E95D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E95DC: 48ABEB89  bl 0x831a8164
	ctx.lr = 0x826E95E0;
	sub_831A8130(ctx, base);
	// 826E95E0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E95E4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E95E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826E95EC: 3BCBB6C8  addi r30, r11, -0x4938
	ctx.r[30].s64 = ctx.r[11].s64 + -18744;
	// 826E95F0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826E95F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E95F8: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 826E95FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826E9600: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E9604: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 826E9608: 48708DE1  bl 0x82df23e8
	ctx.lr = 0x826E960C;
	sub_82DF23E8(ctx, base);
	// 826E960C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E9610: 41820014  beq 0x826e9624
	if ctx.cr[0].eq {
	pc = 0x826E9624; continue 'dispatch;
	}
	// 826E9614: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E9618: 4BFFFDB9  bl 0x826e93d0
	ctx.lr = 0x826E961C;
	sub_826E93D0(ctx, base);
	// 826E961C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E9620: 48000008  b 0x826e9628
	pc = 0x826E9628; continue 'dispatch;
	// 826E9624: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E9628: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826E962C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E9630: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E9634: 4BFFF7CD  bl 0x826e8e00
	ctx.lr = 0x826E9638;
	sub_826E8E00(ctx, base);
	// 826E9638: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E963C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E9640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826E9644: 4BBD69BD  bl 0x822c0000
	ctx.lr = 0x826E9648;
	sub_822C0000(ctx, base);
	// 826E9648: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826E964C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826E9650: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 826E9654: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826E9658: 4BBD6D81  bl 0x822c03d8
	ctx.lr = 0x826E965C;
	sub_822C03D8(ctx, base);
	// 826E965C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826E9660: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826E9664: 418200B4  beq 0x826e9718
	if ctx.cr[0].eq {
	pc = 0x826E9718; continue 'dispatch;
	}
	// 826E9668: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826E966C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826E9670: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826E9674: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826E9678: 409A0008  bne cr6, 0x826e9680
	if !ctx.cr[6].eq {
	pc = 0x826E9680; continue 'dispatch;
	}
	// 826E967C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E9680: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826E9684: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E9688: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826E968C: 419A0024  beq cr6, 0x826e96b0
	if ctx.cr[6].eq {
	pc = 0x826E96B0; continue 'dispatch;
	}
	// 826E9690: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E9694: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826E9698: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E969C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826E96A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826E96A4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E96A8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E96AC: 4082FFE8  bne 0x826e9694
	if !ctx.cr[0].eq {
	pc = 0x826E9694; continue 'dispatch;
	}
	// 826E96B0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826E96B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E96B8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826E96BC: 419A0024  beq cr6, 0x826e96e0
	if ctx.cr[6].eq {
	pc = 0x826E96E0; continue 'dispatch;
	}
	// 826E96C0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826E96C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826E96C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E96CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826E96D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826E96D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826E96D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826E96DC: 4082FFE8  bne 0x826e96c4
	if !ctx.cr[0].eq {
	pc = 0x826E96C4; continue 'dispatch;
	}
	// 826E96E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826E96E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826E96E8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826E96EC: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826E96F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826E96F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E96F8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826E96FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826E9700: 480AF831  bl 0x82798f30
	ctx.lr = 0x826E9704;
	sub_82798F30(ctx, base);
	// 826E9704: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E9708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E970C: 480B1F5D  bl 0x8279b668
	ctx.lr = 0x826E9710;
	sub_8279B668(ctx, base);
	// 826E9710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E9714: 48000008  b 0x826e971c
	pc = 0x826E971C; continue 'dispatch;
	// 826E9718: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826E971C: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826E9720: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826E9724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E9728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E972C: 4BEAE525  bl 0x82597c50
	ctx.lr = 0x826E9730;
	sub_82597C50(ctx, base);
	// 826E9730: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826E9734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E9738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E973C: 4BBD68C5  bl 0x822c0000
	ctx.lr = 0x826E9740;
	sub_822C0000(ctx, base);
	// 826E9740: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E9744: 41820024  beq 0x826e9768
	if ctx.cr[0].eq {
	pc = 0x826E9768; continue 'dispatch;
	}
	// 826E9748: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826E974C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E9750: 419A0008  beq cr6, 0x826e9758
	if ctx.cr[6].eq {
	pc = 0x826E9758; continue 'dispatch;
	}
	// 826E9754: 4BBD713D  bl 0x822c0890
	ctx.lr = 0x826E9758;
	sub_822C0890(ctx, base);
	// 826E9758: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826E975C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826E9760: 419A0008  beq cr6, 0x826e9768
	if ctx.cr[6].eq {
	pc = 0x826E9768; continue 'dispatch;
	}
	// 826E9764: 4BBD712D  bl 0x822c0890
	ctx.lr = 0x826E9768;
	sub_822C0890(ctx, base);
	// 826E9768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E976C: 419A000C  beq cr6, 0x826e9778
	if ctx.cr[6].eq {
	pc = 0x826E9778; continue 'dispatch;
	}
	// 826E9770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826E9774: 4BBD711D  bl 0x822c0890
	ctx.lr = 0x826E9778;
	sub_822C0890(ctx, base);
	// 826E9778: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826E977C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826E9780: 48ABEA34  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E9788 size=424
    let mut pc: u32 = 0x826E9788;
    'dispatch: loop {
        match pc {
            0x826E9788 => {
    //   block [0x826E9788..0x826E9930)
	// 826E9788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E978C: 48ABE9DD  bl 0x831a8168
	ctx.lr = 0x826E9790;
	sub_831A8130(ctx, base);
	// 826E9790: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E9930 size=220
    let mut pc: u32 = 0x826E9930;
    'dispatch: loop {
        match pc {
            0x826E9930 => {
    //   block [0x826E9930..0x826E9A0C)
	// 826E9930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9934: 48ABE835  bl 0x831a8168
	ctx.lr = 0x826E9938;
	sub_831A8130(ctx, base);
	// 826E9938: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E993C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826E9940: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E9944: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E9948: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826E994C: 41820038  beq 0x826e9984
	if ctx.cr[0].eq {
	pc = 0x826E9984; continue 'dispatch;
	}
	// 826E9950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9954: 48AC0035  bl 0x831a9988
	ctx.lr = 0x826E9958;
	sub_831A9988(ctx, base);
	// 826E9958: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E995C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E9960: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826E9964: 48ABE795  bl 0x831a80f8
	ctx.lr = 0x826E9968;
	sub_831A80F8(ctx, base);
	// 826E9968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E996C: 41820018  beq 0x826e9984
	if ctx.cr[0].eq {
	pc = 0x826E9984; continue 'dispatch;
	}
	// 826E9970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E9974: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E9978: 4BFFC509  bl 0x826e5e80
	ctx.lr = 0x826E997C;
	sub_826E5E80(ctx, base);
	// 826E997C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826E9980: 48000084  b 0x826e9a04
	pc = 0x826E9A04; continue 'dispatch;
	// 826E9984: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E9988: 419A006C  beq cr6, 0x826e99f4
	if ctx.cr[6].eq {
	pc = 0x826E99F4; continue 'dispatch;
	}
	// 826E998C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9990: 48ABFFF9  bl 0x831a9988
	ctx.lr = 0x826E9994;
	sub_831A9988(ctx, base);
	// 826E9994: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826E9998: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E999C: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826E99A0: 48ABE759  bl 0x831a80f8
	ctx.lr = 0x826E99A4;
	sub_831A80F8(ctx, base);
	// 826E99A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E99A8: 41820014  beq 0x826e99bc
	if ctx.cr[0].eq {
	pc = 0x826E99BC; continue 'dispatch;
	}
	// 826E99AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E99B0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E99B4: 4BFFF2B5  bl 0x826e8c68
	ctx.lr = 0x826E99B8;
	sub_826E8C68(ctx, base);
	// 826E99B8: 4BFFFFC4  b 0x826e997c
	pc = 0x826E997C; continue 'dispatch;
	// 826E99BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826E99C0: 419A0034  beq cr6, 0x826e99f4
	if ctx.cr[6].eq {
	pc = 0x826E99F4; continue 'dispatch;
	}
	// 826E99C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E99C8: 48ABFFC1  bl 0x831a9988
	ctx.lr = 0x826E99CC;
	sub_831A9988(ctx, base);
	// 826E99CC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826E99D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826E99D4: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 826E99D8: 48ABE721  bl 0x831a80f8
	ctx.lr = 0x826E99DC;
	sub_831A80F8(ctx, base);
	// 826E99DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E99E0: 41820014  beq 0x826e99f4
	if ctx.cr[0].eq {
	pc = 0x826E99F4; continue 'dispatch;
	}
	// 826E99E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E99E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826E99EC: 4BFFF335  bl 0x826e8d20
	ctx.lr = 0x826E99F0;
	sub_826E8D20(ctx, base);
	// 826E99F0: 4BFFFF8C  b 0x826e997c
	pc = 0x826E997C; continue 'dispatch;
	// 826E99F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826E99F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826E99FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E9A00: 48000B21  bl 0x826ea520
	ctx.lr = 0x826E9A04;
	sub_826EA520(ctx, base);
	// 826E9A04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826E9A08: 48ABE7B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826E9A10 size=196
    let mut pc: u32 = 0x826E9A10;
    'dispatch: loop {
        match pc {
            0x826E9A10 => {
    //   block [0x826E9A10..0x826E9AD4)
	// 826E9A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E9A18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E9A1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E9A20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E9A24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826E9A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E9A2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826E9A30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826E9A34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E9A38: 4BBD6F01  bl 0x822c0938
	ctx.lr = 0x826E9A3C;
	sub_822C0938(ctx, base);
	// 826E9A3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826E9A40: 41820028  beq 0x826e9a68
	if ctx.cr[0].eq {
	pc = 0x826E9A68; continue 'dispatch;
	}
	// 826E9A44: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826E9A48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826E9A4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826E9A50: 392BB838  addi r9, r11, -0x47c8
	ctx.r[9].s64 = ctx.r[11].s64 + -18376;
	// 826E9A54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826E9A58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E9A5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826E9A60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826E9A64: 48000008  b 0x826e9a6c
	pc = 0x826E9A6C; continue 'dispatch;
	// 826E9A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826E9A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826E9A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826E9A74: 409A0044  bne cr6, 0x826e9ab8
	if !ctx.cr[6].eq {
	pc = 0x826E9AB8; continue 'dispatch;
	}
	// 826E9A78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826E9A7C: 419A001C  beq cr6, 0x826e9a98
	if ctx.cr[6].eq {
	pc = 0x826E9A98; continue 'dispatch;
	}
	// 826E9A80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E9A84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826E9A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9A8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826E9A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826E9A94: 4E800421  bctrl
	ctx.lr = 0x826E9A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826E9A98: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826E9A9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E9AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826E9AA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826E9AA8: 816BE47C  lwz r11, -0x1b84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7044 as u32) ) } as u64;
	// 826E9AAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826E9AB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826E9AB4: 4BBD654D  bl 0x822c0000
	ctx.lr = 0x826E9AB8;
	sub_822C0000(ctx, base);
	// 826E9AB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826E9ABC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826E9AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826E9AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826E9AC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826E9ACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826E9AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E9AD8 size=204
    let mut pc: u32 = 0x826E9AD8;
    'dispatch: loop {
        match pc {
            0x826E9AD8 => {
    //   block [0x826E9AD8..0x826E9BA4)
	// 826E9AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E9AE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E9AE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E9AE8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826E9BA8 size=796
    let mut pc: u32 = 0x826E9BA8;
    'dispatch: loop {
        match pc {
            0x826E9BA8 => {
    //   block [0x826E9BA8..0x826E9EC4)
	// 826E9BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9BAC: 48ABE5C1  bl 0x831a816c
	ctx.lr = 0x826E9BB0;
	sub_831A8130(ctx, base);
	// 826E9BB0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 826E9BB4: 48ABEEC5  bl 0x831a8a78
	ctx.lr = 0x826E9BB8;
	sub_831A8A40(ctx, base);
	// 826E9BB8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E9EC8 size=180
    let mut pc: u32 = 0x826E9EC8;
    'dispatch: loop {
        match pc {
            0x826E9EC8 => {
    //   block [0x826E9EC8..0x826E9F7C)
	// 826E9EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826E9ED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826E9ED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826E9ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E9EDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826E9EE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826E9EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E9EE8: 4BFFFBF1  bl 0x826e9ad8
	ctx.lr = 0x826E9EEC;
	sub_826E9AD8(ctx, base);
	// 826E9EEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826E9EF0: 41820050  beq 0x826e9f40
	if ctx.cr[0].eq {
	pc = 0x826E9F40; continue 'dispatch;
	}
	// 826E9EF4: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 826E9EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9EFC: 4BE27B85  bl 0x82511a80
	ctx.lr = 0x826E9F00;
	sub_82511A80(ctx, base);
	// 826E9F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9F04: 4BE27BE5  bl 0x82511ae8
	ctx.lr = 0x826E9F08;
	sub_82511AE8(ctx, base);
	// 826E9F08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826E9F0C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826E9F10: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E9F14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826E9F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826E9F1C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826E9F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826E9F80 size=492
    let mut pc: u32 = 0x826E9F80;
    'dispatch: loop {
        match pc {
            0x826E9F80 => {
    //   block [0x826E9F80..0x826EA16C)
	// 826E9F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826E9F84: 48ABE1E1  bl 0x831a8164
	ctx.lr = 0x826E9F88;
	sub_831A8130(ctx, base);
	// 826E9F88: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826E9F8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826E9F90: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826E9F94: 396BD3D0  addi r11, r11, -0x2c30
	ctx.r[11].s64 = ctx.r[11].s64 + -11312;
	// 826E9F98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826E9F9C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826E9FA0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826E9FA4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826E9FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826E9FAC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826E9FB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EA170 size=240
    let mut pc: u32 = 0x826EA170;
    'dispatch: loop {
        match pc {
            0x826EA170 => {
    //   block [0x826EA170..0x826EA260)
	// 826EA170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EA178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EA17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EA180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA188: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EA18C: 4BE281A5  bl 0x82512330
	ctx.lr = 0x826EA190;
	sub_82512330(ctx, base);
	// 826EA190: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EA194: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EA198: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826EA19C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EA1A0: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826EA1A4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826EA1A8: 394AB8D4  addi r10, r10, -0x472c
	ctx.r[10].s64 = ctx.r[10].s64 + -18220;
	// 826EA1AC: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 826EA1B0: 3929B8C0  addi r9, r9, -0x4740
	ctx.r[9].s64 = ctx.r[9].s64 + -18240;
	// 826EA1B4: 3908B874  addi r8, r8, -0x478c
	ctx.r[8].s64 = ctx.r[8].s64 + -18316;
	// 826EA1B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826EA1BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EA1C0: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826EA1C4: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826EA1C8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826EA1CC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826EA1D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EA1D4: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826EA1D8: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 826EA1DC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826EA1E0: 39000120  li r8, 0x120
	ctx.r[8].s64 = 288;
	// 826EA1E4: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826EA1E8: 38E00130  li r7, 0x130
	ctx.r[7].s64 = 304;
	// 826EA1EC: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826EA1F0: 38C00140  li r6, 0x140
	ctx.r[6].s64 = 320;
	// 826EA1F4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826EA1F8: C0090210  lfs f0, 0x210(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EA1FC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EA200: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EA204: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826EA208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA20C: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826EA210: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826EA214: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 826EA218: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EA260 size=8
    let mut pc: u32 = 0x826EA260;
    'dispatch: loop {
        match pc {
            0x826EA260 => {
    //   block [0x826EA260..0x826EA268)
	// 826EA260: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EA264: 4800039C  b 0x826ea600
	sub_826EA600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EA268 size=8
    let mut pc: u32 = 0x826EA268;
    'dispatch: loop {
        match pc {
            0x826EA268 => {
    //   block [0x826EA268..0x826EA270)
	// 826EA268: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EA26C: 48000394  b 0x826ea600
	sub_826EA600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EA270 size=84
    let mut pc: u32 = 0x826EA270;
    'dispatch: loop {
        match pc {
            0x826EA270 => {
    //   block [0x826EA270..0x826EA2C4)
	// 826EA270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EA278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EA27C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA284: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 826EA288: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 826EA28C: 419A0024  beq cr6, 0x826ea2b0
	if ctx.cr[6].eq {
	pc = 0x826EA2B0; continue 'dispatch;
	}
	// 826EA290: 4845C439  bl 0x82b466c8
	ctx.lr = 0x826EA294;
	sub_82B466C8(ctx, base);
	// 826EA294: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EA298: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 826EA29C: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 826EA2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA2A4: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 826EA2A8: 419A0008  beq cr6, 0x826ea2b0
	if ctx.cr[6].eq {
	pc = 0x826EA2B0; continue 'dispatch;
	}
	// 826EA2AC: 4BBD65E5  bl 0x822c0890
	ctx.lr = 0x826EA2B0;
	sub_822C0890(ctx, base);
	// 826EA2B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EA2B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EA2B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EA2BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EA2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EA2C8 size=96
    let mut pc: u32 = 0x826EA2C8;
    'dispatch: loop {
        match pc {
            0x826EA2C8 => {
    //   block [0x826EA2C8..0x826EA328)
	// 826EA2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EA2D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EA2D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EA2D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA2DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA2E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EA2E4: 4BE26425  bl 0x82510708
	ctx.lr = 0x826EA2E8;
	sub_82510708(ctx, base);
	// 826EA2E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EA2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA2F0: 4BFFF7E9  bl 0x826e9ad8
	ctx.lr = 0x826EA2F4;
	sub_826E9AD8(ctx, base);
	// 826EA2F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA2F8: 4182000C  beq 0x826ea304
	if ctx.cr[0].eq {
	pc = 0x826EA304; continue 'dispatch;
	}
	// 826EA2FC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EA300: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 826EA304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA308: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EA30C: 4BFFF89D  bl 0x826e9ba8
	ctx.lr = 0x826EA310;
	sub_826E9BA8(ctx, base);
	// 826EA310: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EA314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EA318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EA31C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EA320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EA324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EA328 size=500
    let mut pc: u32 = 0x826EA328;
    'dispatch: loop {
        match pc {
            0x826EA328 => {
    //   block [0x826EA328..0x826EA51C)
	// 826EA328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA32C: 48ABDE39  bl 0x831a8164
	ctx.lr = 0x826EA330;
	sub_831A8130(ctx, base);
	// 826EA330: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA334: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EA338: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EA33C: 3BABB928  addi r29, r11, -0x46d8
	ctx.r[29].s64 = ctx.r[11].s64 + -18136;
	// 826EA340: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826EA344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EA348: 38A0016B  li r5, 0x16b
	ctx.r[5].s64 = 363;
	// 826EA34C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826EA350: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 826EA354: 48708095  bl 0x82df23e8
	ctx.lr = 0x826EA358;
	sub_82DF23E8(ctx, base);
	// 826EA358: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EA35C: 41820024  beq 0x826ea380
	if ctx.cr[0].eq {
	pc = 0x826EA380; continue 'dispatch;
	}
	// 826EA360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA364: 4876F33D  bl 0x82e596a0
	ctx.lr = 0x826EA368;
	sub_82E596A0(ctx, base);
	// 826EA368: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 826EA36C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 826EA370: 396BAF88  addi r11, r11, -0x5078
	ctx.r[11].s64 = ctx.r[11].s64 + -20600;
	// 826EA374: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EA378: 4BCC9C79  bl 0x823b3ff0
	ctx.lr = 0x826EA37C;
	sub_823B3FF0(ctx, base);
	// 826EA37C: 48000008  b 0x826ea384
	pc = 0x826EA384; continue 'dispatch;
	// 826EA380: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EA384: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EA388: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA38C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA390: 4BD92B41  bl 0x8247ced0
	ctx.lr = 0x826EA394;
	sub_8247CED0(ctx, base);
	// 826EA394: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EA398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA39C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA3A0: 4BBD5C61  bl 0x822c0000
	ctx.lr = 0x826EA3A4;
	sub_822C0000(ctx, base);
	// 826EA3A4: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EA3A8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EA3AC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826EA3B0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 826EA3B4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 826EA3B8: 419A0024  beq cr6, 0x826ea3dc
	if ctx.cr[6].eq {
	pc = 0x826EA3DC; continue 'dispatch;
	}
	// 826EA3BC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826EA3C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EA3C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA3C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EA3CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EA3D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EA3D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA3D8: 4082FFE8  bne 0x826ea3c0
	if !ctx.cr[0].eq {
	pc = 0x826EA3C0; continue 'dispatch;
	}
	// 826EA3DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826EA3E0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 826EA3E4: 4891DD45  bl 0x83008128
	ctx.lr = 0x826EA3E8;
	sub_83008128(ctx, base);
	// 826EA3E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826EA3EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826EA3F0: 38A0016C  li r5, 0x16c
	ctx.r[5].s64 = 364;
	// 826EA3F4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 826EA3F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 826EA3FC: 4876CBED  bl 0x82e56fe8
	ctx.lr = 0x826EA400;
	sub_82E56FE8(ctx, base);
	// 826EA400: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EA404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA408: 419A0008  beq cr6, 0x826ea410
	if ctx.cr[6].eq {
	pc = 0x826EA410; continue 'dispatch;
	}
	// 826EA40C: 4BBD6485  bl 0x822c0890
	ctx.lr = 0x826EA410;
	sub_822C0890(ctx, base);
	// 826EA410: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 826EA414: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 826EA418: 419A00EC  beq cr6, 0x826ea504
	if ctx.cr[6].eq {
	pc = 0x826EA504; continue 'dispatch;
	}
	// 826EA41C: 817E00E8  lwz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 826EA420: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826EA424: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EA428: C1BF0064  lfs f13, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EA42C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 826EA430: 394AE464  addi r10, r10, -0x1b9c
	ctx.r[10].s64 = ctx.r[10].s64 + -7068;
	// 826EA434: 397E0140  addi r11, r30, 0x140
	ctx.r[11].s64 = ctx.r[30].s64 + 320;
	// 826EA438: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826EA43C: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EA440: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EA444: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826EA448: 7D88542E  lfsx f12, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826EA44C: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 826EA450: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EA454: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826EA458: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826EA45C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826EA460: 13C038C7  vcmpequd (lvx128) v30, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EA520 size=220
    let mut pc: u32 = 0x826EA520;
    'dispatch: loop {
        match pc {
            0x826EA520 => {
    //   block [0x826EA520..0x826EA5FC)
	// 826EA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA524: 48ABDC45  bl 0x831a8168
	ctx.lr = 0x826EA528;
	sub_831A8130(ctx, base);
	// 826EA528: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA52C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826EA530: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EA534: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EA538: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EA53C: 40820038  bne 0x826ea574
	if !ctx.cr[0].eq {
	pc = 0x826EA574; continue 'dispatch;
	}
	// 826EA540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA544: 48ABF445  bl 0x831a9988
	ctx.lr = 0x826EA548;
	sub_831A9988(ctx, base);
	// 826EA548: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826EA54C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EA550: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826EA554: 48ABDBA5  bl 0x831a80f8
	ctx.lr = 0x826EA558;
	sub_831A80F8(ctx, base);
	// 826EA558: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA55C: 41820018  beq 0x826ea574
	if ctx.cr[0].eq {
	pc = 0x826EA574; continue 'dispatch;
	}
	// 826EA560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA564: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EA568: 4BFFFDC1  bl 0x826ea328
	ctx.lr = 0x826EA56C;
	sub_826EA328(ctx, base);
	// 826EA56C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EA570: 48000084  b 0x826ea5f4
	pc = 0x826EA5F4; continue 'dispatch;
	// 826EA574: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA578: 419A006C  beq cr6, 0x826ea5e4
	if ctx.cr[6].eq {
	pc = 0x826EA5E4; continue 'dispatch;
	}
	// 826EA57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA580: 48ABF409  bl 0x831a9988
	ctx.lr = 0x826EA584;
	sub_831A9988(ctx, base);
	// 826EA584: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826EA588: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EA58C: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 826EA590: 48ABDB69  bl 0x831a80f8
	ctx.lr = 0x826EA594;
	sub_831A80F8(ctx, base);
	// 826EA594: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA598: 41820014  beq 0x826ea5ac
	if ctx.cr[0].eq {
	pc = 0x826EA5AC; continue 'dispatch;
	}
	// 826EA59C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA5A0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EA5A4: 4BFFF925  bl 0x826e9ec8
	ctx.lr = 0x826EA5A8;
	sub_826E9EC8(ctx, base);
	// 826EA5A8: 4BFFFFC4  b 0x826ea56c
	pc = 0x826EA56C; continue 'dispatch;
	// 826EA5AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA5B0: 419A0034  beq cr6, 0x826ea5e4
	if ctx.cr[6].eq {
	pc = 0x826EA5E4; continue 'dispatch;
	}
	// 826EA5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA5B8: 48ABF3D1  bl 0x831a9988
	ctx.lr = 0x826EA5BC;
	sub_831A9988(ctx, base);
	// 826EA5BC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EA5C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EA5C4: 386BCB78  addi r3, r11, -0x3488
	ctx.r[3].s64 = ctx.r[11].s64 + -13448;
	// 826EA5C8: 48ABDB31  bl 0x831a80f8
	ctx.lr = 0x826EA5CC;
	sub_831A80F8(ctx, base);
	// 826EA5CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA5D0: 41820014  beq 0x826ea5e4
	if ctx.cr[0].eq {
	pc = 0x826EA5E4; continue 'dispatch;
	}
	// 826EA5D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA5D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EA5DC: 4BFFF9A5  bl 0x826e9f80
	ctx.lr = 0x826EA5E0;
	sub_826E9F80(ctx, base);
	// 826EA5E0: 4BFFFF8C  b 0x826ea56c
	pc = 0x826EA56C; continue 'dispatch;
	// 826EA5E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826EA5E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA5EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EA5F0: 4BE28029  bl 0x82512618
	ctx.lr = 0x826EA5F4;
	sub_82512618(ctx, base);
	// 826EA5F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EA5F8: 48ABDBC0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EA600 size=76
    let mut pc: u32 = 0x826EA600;
    'dispatch: loop {
        match pc {
            0x826EA600 => {
    //   block [0x826EA600..0x826EA64C)
	// 826EA600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EA608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EA60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EA610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EA61C: 4BFFE8AD  bl 0x826e8ec8
	ctx.lr = 0x826EA620;
	sub_826E8EC8(ctx, base);
	// 826EA620: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA624: 4182000C  beq 0x826ea630
	if ctx.cr[0].eq {
	pc = 0x826EA630; continue 'dispatch;
	}
	// 826EA628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA62C: 48707DAD  bl 0x82df23d8
	ctx.lr = 0x826EA630;
	sub_82DF23D8(ctx, base);
	// 826EA630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EA638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EA63C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EA640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EA644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EA648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EA650 size=428
    let mut pc: u32 = 0x826EA650;
    'dispatch: loop {
        match pc {
            0x826EA650 => {
    //   block [0x826EA650..0x826EA7FC)
	// 826EA650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA654: 48ABDB11  bl 0x831a8164
	ctx.lr = 0x826EA658;
	sub_831A8130(ctx, base);
	// 826EA658: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA65C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EA660: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EA664: 3BCBB928  addi r30, r11, -0x46d8
	ctx.r[30].s64 = ctx.r[11].s64 + -18136;
	// 826EA668: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EA66C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EA670: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 826EA674: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EA678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EA67C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 826EA680: 48707D69  bl 0x82df23e8
	ctx.lr = 0x826EA684;
	sub_82DF23E8(ctx, base);
	// 826EA684: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EA688: 41820014  beq 0x826ea69c
	if ctx.cr[0].eq {
	pc = 0x826EA69C; continue 'dispatch;
	}
	// 826EA68C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826EA690: 4BFFFAE1  bl 0x826ea170
	ctx.lr = 0x826EA694;
	sub_826EA170(ctx, base);
	// 826EA694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA698: 48000008  b 0x826ea6a0
	pc = 0x826EA6A0; continue 'dispatch;
	// 826EA69C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EA6A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EA6A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA6A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA6AC: 4BFFF365  bl 0x826e9a10
	ctx.lr = 0x826EA6B0;
	sub_826E9A10(ctx, base);
	// 826EA6B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EA6B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA6B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA6BC: 4BBD5945  bl 0x822c0000
	ctx.lr = 0x826EA6C0;
	sub_822C0000(ctx, base);
	// 826EA6C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EA6C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EA6C8: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 826EA6CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EA6D0: 4BBD5D09  bl 0x822c03d8
	ctx.lr = 0x826EA6D4;
	sub_822C03D8(ctx, base);
	// 826EA6D4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EA6D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EA6DC: 418200B4  beq 0x826ea790
	if ctx.cr[0].eq {
	pc = 0x826EA790; continue 'dispatch;
	}
	// 826EA6E0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EA6E4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EA6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EA6EC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EA6F0: 409A0008  bne cr6, 0x826ea6f8
	if !ctx.cr[6].eq {
	pc = 0x826EA6F8; continue 'dispatch;
	}
	// 826EA6F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EA6F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EA6FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA700: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EA704: 419A0024  beq cr6, 0x826ea728
	if ctx.cr[6].eq {
	pc = 0x826EA728; continue 'dispatch;
	}
	// 826EA708: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EA70C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EA710: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA714: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EA718: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EA71C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EA720: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA724: 4082FFE8  bne 0x826ea70c
	if !ctx.cr[0].eq {
	pc = 0x826EA70C; continue 'dispatch;
	}
	// 826EA728: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EA72C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA730: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EA734: 419A0024  beq cr6, 0x826ea758
	if ctx.cr[6].eq {
	pc = 0x826EA758; continue 'dispatch;
	}
	// 826EA738: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EA73C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EA740: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA744: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EA748: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EA74C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EA750: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA754: 4082FFE8  bne 0x826ea73c
	if !ctx.cr[0].eq {
	pc = 0x826EA73C; continue 'dispatch;
	}
	// 826EA758: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EA75C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EA760: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EA764: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EA768: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EA76C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EA770: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EA774: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EA778: 480AE7B9  bl 0x82798f30
	ctx.lr = 0x826EA77C;
	sub_82798F30(ctx, base);
	// 826EA77C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EA780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA784: 480B0EE5  bl 0x8279b668
	ctx.lr = 0x826EA788;
	sub_8279B668(ctx, base);
	// 826EA788: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA78C: 48000008  b 0x826ea794
	pc = 0x826EA794; continue 'dispatch;
	// 826EA790: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EA794: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EA798: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EA79C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EA7A4: 4BEAD4AD  bl 0x82597c50
	ctx.lr = 0x826EA7A8;
	sub_82597C50(ctx, base);
	// 826EA7A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EA7AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EA7B4: 4BBD584D  bl 0x822c0000
	ctx.lr = 0x826EA7B8;
	sub_822C0000(ctx, base);
	// 826EA7B8: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA7BC: 41820024  beq 0x826ea7e0
	if ctx.cr[0].eq {
	pc = 0x826EA7E0; continue 'dispatch;
	}
	// 826EA7C0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EA7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA7C8: 419A0008  beq cr6, 0x826ea7d0
	if ctx.cr[6].eq {
	pc = 0x826EA7D0; continue 'dispatch;
	}
	// 826EA7CC: 4BBD60C5  bl 0x822c0890
	ctx.lr = 0x826EA7D0;
	sub_822C0890(ctx, base);
	// 826EA7D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EA7D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA7D8: 419A0008  beq cr6, 0x826ea7e0
	if ctx.cr[6].eq {
	pc = 0x826EA7E0; continue 'dispatch;
	}
	// 826EA7DC: 4BBD60B5  bl 0x822c0890
	ctx.lr = 0x826EA7E0;
	sub_822C0890(ctx, base);
	// 826EA7E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA7E4: 419A000C  beq cr6, 0x826ea7f0
	if ctx.cr[6].eq {
	pc = 0x826EA7F0; continue 'dispatch;
	}
	// 826EA7E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EA7EC: 4BBD60A5  bl 0x822c0890
	ctx.lr = 0x826EA7F0;
	sub_822C0890(ctx, base);
	// 826EA7F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EA7F4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EA7F8: 48ABD9BC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EA800 size=428
    let mut pc: u32 = 0x826EA800;
    'dispatch: loop {
        match pc {
            0x826EA800 => {
    //   block [0x826EA800..0x826EA9AC)
	// 826EA800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA804: 48ABD961  bl 0x831a8164
	ctx.lr = 0x826EA808;
	sub_831A8130(ctx, base);
	// 826EA808: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EA80C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EA810: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EA814: 3BCBB928  addi r30, r11, -0x46d8
	ctx.r[30].s64 = ctx.r[11].s64 + -18136;
	// 826EA818: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EA81C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EA820: 38A0006F  li r5, 0x6f
	ctx.r[5].s64 = 111;
	// 826EA824: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EA828: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EA82C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 826EA830: 48707BB9  bl 0x82df23e8
	ctx.lr = 0x826EA834;
	sub_82DF23E8(ctx, base);
	// 826EA834: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EA838: 41820014  beq 0x826ea84c
	if ctx.cr[0].eq {
	pc = 0x826EA84C; continue 'dispatch;
	}
	// 826EA83C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826EA840: 4BFFF931  bl 0x826ea170
	ctx.lr = 0x826EA844;
	sub_826EA170(ctx, base);
	// 826EA844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA848: 48000008  b 0x826ea850
	pc = 0x826EA850; continue 'dispatch;
	// 826EA84C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EA850: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EA854: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA858: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA85C: 4BFFF1B5  bl 0x826e9a10
	ctx.lr = 0x826EA860;
	sub_826E9A10(ctx, base);
	// 826EA860: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EA864: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA868: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EA86C: 4BBD5795  bl 0x822c0000
	ctx.lr = 0x826EA870;
	sub_822C0000(ctx, base);
	// 826EA870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EA874: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EA878: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 826EA87C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EA880: 4BBD5B59  bl 0x822c03d8
	ctx.lr = 0x826EA884;
	sub_822C03D8(ctx, base);
	// 826EA884: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EA888: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EA88C: 418200B4  beq 0x826ea940
	if ctx.cr[0].eq {
	pc = 0x826EA940; continue 'dispatch;
	}
	// 826EA890: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EA894: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EA898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EA89C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EA8A0: 409A0008  bne cr6, 0x826ea8a8
	if !ctx.cr[6].eq {
	pc = 0x826EA8A8; continue 'dispatch;
	}
	// 826EA8A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EA8A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EA8AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA8B0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EA8B4: 419A0024  beq cr6, 0x826ea8d8
	if ctx.cr[6].eq {
	pc = 0x826EA8D8; continue 'dispatch;
	}
	// 826EA8B8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EA8BC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EA8C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA8C4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EA8C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EA8CC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EA8D0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA8D4: 4082FFE8  bne 0x826ea8bc
	if !ctx.cr[0].eq {
	pc = 0x826EA8BC; continue 'dispatch;
	}
	// 826EA8D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EA8DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA8E0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EA8E4: 419A0024  beq cr6, 0x826ea908
	if ctx.cr[6].eq {
	pc = 0x826EA908; continue 'dispatch;
	}
	// 826EA8E8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EA8EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EA8F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA8F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EA8F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EA8FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EA900: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EA904: 4082FFE8  bne 0x826ea8ec
	if !ctx.cr[0].eq {
	pc = 0x826EA8EC; continue 'dispatch;
	}
	// 826EA908: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EA90C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EA910: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EA914: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EA918: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EA91C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EA920: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EA924: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EA928: 480AE609  bl 0x82798f30
	ctx.lr = 0x826EA92C;
	sub_82798F30(ctx, base);
	// 826EA92C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EA930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EA934: 480B0D35  bl 0x8279b668
	ctx.lr = 0x826EA938;
	sub_8279B668(ctx, base);
	// 826EA938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EA93C: 48000008  b 0x826ea944
	pc = 0x826EA944; continue 'dispatch;
	// 826EA940: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EA944: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EA948: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EA94C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EA954: 4BEAD2FD  bl 0x82597c50
	ctx.lr = 0x826EA958;
	sub_82597C50(ctx, base);
	// 826EA958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EA95C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EA960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EA964: 4BBD569D  bl 0x822c0000
	ctx.lr = 0x826EA968;
	sub_822C0000(ctx, base);
	// 826EA968: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EA96C: 41820024  beq 0x826ea990
	if ctx.cr[0].eq {
	pc = 0x826EA990; continue 'dispatch;
	}
	// 826EA970: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EA974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA978: 419A0008  beq cr6, 0x826ea980
	if ctx.cr[6].eq {
	pc = 0x826EA980; continue 'dispatch;
	}
	// 826EA97C: 4BBD5F15  bl 0x822c0890
	ctx.lr = 0x826EA980;
	sub_822C0890(ctx, base);
	// 826EA980: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EA984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EA988: 419A0008  beq cr6, 0x826ea990
	if ctx.cr[6].eq {
	pc = 0x826EA990; continue 'dispatch;
	}
	// 826EA98C: 4BBD5F05  bl 0x822c0890
	ctx.lr = 0x826EA990;
	sub_822C0890(ctx, base);
	// 826EA990: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EA994: 419A000C  beq cr6, 0x826ea9a0
	if ctx.cr[6].eq {
	pc = 0x826EA9A0; continue 'dispatch;
	}
	// 826EA998: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EA99C: 4BBD5EF5  bl 0x822c0890
	ctx.lr = 0x826EA9A0;
	sub_822C0890(ctx, base);
	// 826EA9A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EA9A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EA9A8: 48ABD80C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EA9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EA9B0 size=2384
    let mut pc: u32 = 0x826EA9B0;
    'dispatch: loop {
        match pc {
            0x826EA9B0 => {
    //   block [0x826EA9B0..0x826EB300)
	// 826EA9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EA9B4: 48ABD78D  bl 0x831a8140
	ctx.lr = 0x826EA9B8;
	sub_831A8130(ctx, base);
	// 826EA9B8: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 826EA9BC: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB300 size=52
    let mut pc: u32 = 0x826EB300;
    'dispatch: loop {
        match pc {
            0x826EB300 => {
    //   block [0x826EB300..0x826EB334)
	// 826EB300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB308: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB30C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB314: 4BE267D5  bl 0x82511ae8
	ctx.lr = 0x826EB318;
	sub_82511AE8(ctx, base);
	// 826EB318: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EB31C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826EB320: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EB324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB32C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB338 size=156
    let mut pc: u32 = 0x826EB338;
    'dispatch: loop {
        match pc {
            0x826EB338 => {
    //   block [0x826EB338..0x826EB3D4)
	// 826EB338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB344: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826EB348: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB34C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB350: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826EB354: 4BE26795  bl 0x82511ae8
	ctx.lr = 0x826EB358;
	sub_82511AE8(ctx, base);
	// 826EB358: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826EB35C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EB360: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 826EB364: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB3D8 size=196
    let mut pc: u32 = 0x826EB3D8;
    'dispatch: loop {
        match pc {
            0x826EB3D8 => {
    //   block [0x826EB3D8..0x826EB49C)
	// 826EB3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EB3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB3E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB3EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EB3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EB3F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EB3F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB3FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EB400: 4BBD5539  bl 0x822c0938
	ctx.lr = 0x826EB404;
	sub_822C0938(ctx, base);
	// 826EB404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EB408: 41820028  beq 0x826eb430
	if ctx.cr[0].eq {
	pc = 0x826EB430; continue 'dispatch;
	}
	// 826EB40C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EB410: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EB414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EB418: 392BBA00  addi r9, r11, -0x4600
	ctx.r[9].s64 = ctx.r[11].s64 + -17920;
	// 826EB41C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EB420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EB424: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EB428: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EB42C: 48000008  b 0x826eb434
	pc = 0x826EB434; continue 'dispatch;
	// 826EB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EB434: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EB438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EB43C: 409A0044  bne cr6, 0x826eb480
	if !ctx.cr[6].eq {
	pc = 0x826EB480; continue 'dispatch;
	}
	// 826EB440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EB444: 419A001C  beq cr6, 0x826eb460
	if ctx.cr[6].eq {
	pc = 0x826EB460; continue 'dispatch;
	}
	// 826EB448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB44C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EB450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB454: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EB45C: 4E800421  bctrl
	ctx.lr = 0x826EB460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EB460: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EB464: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EB468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EB46C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EB470: 816BE4D8  lwz r11, -0x1b28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6952 as u32) ) } as u64;
	// 826EB474: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EB478: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EB47C: 4BBD4B85  bl 0x822c0000
	ctx.lr = 0x826EB480;
	sub_822C0000(ctx, base);
	// 826EB480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EB494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB4A0 size=196
    let mut pc: u32 = 0x826EB4A0;
    'dispatch: loop {
        match pc {
            0x826EB4A0 => {
    //   block [0x826EB4A0..0x826EB564)
	// 826EB4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB4A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB4A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EB4AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB4B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB4B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EB4B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EB4BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EB4C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB4C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EB4C8: 4BBD5471  bl 0x822c0938
	ctx.lr = 0x826EB4CC;
	sub_822C0938(ctx, base);
	// 826EB4CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EB4D0: 41820028  beq 0x826eb4f8
	if ctx.cr[0].eq {
	pc = 0x826EB4F8; continue 'dispatch;
	}
	// 826EB4D4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EB4D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EB4DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EB4E0: 392BBA14  addi r9, r11, -0x45ec
	ctx.r[9].s64 = ctx.r[11].s64 + -17900;
	// 826EB4E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EB4E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EB4EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EB4F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EB4F4: 48000008  b 0x826eb4fc
	pc = 0x826EB4FC; continue 'dispatch;
	// 826EB4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EB4FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EB500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EB504: 409A0044  bne cr6, 0x826eb548
	if !ctx.cr[6].eq {
	pc = 0x826EB548; continue 'dispatch;
	}
	// 826EB508: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EB50C: 419A001C  beq cr6, 0x826eb528
	if ctx.cr[6].eq {
	pc = 0x826EB528; continue 'dispatch;
	}
	// 826EB510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB514: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EB518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB51C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EB524: 4E800421  bctrl
	ctx.lr = 0x826EB528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EB528: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EB52C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EB530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EB534: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EB538: 816BE4D8  lwz r11, -0x1b28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6952 as u32) ) } as u64;
	// 826EB53C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EB540: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EB544: 4BBD4ABD  bl 0x822c0000
	ctx.lr = 0x826EB548;
	sub_822C0000(ctx, base);
	// 826EB548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB54C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EB55C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB568 size=80
    let mut pc: u32 = 0x826EB568;
    'dispatch: loop {
        match pc {
            0x826EB568 => {
    //   block [0x826EB568..0x826EB5B8)
	// 826EB568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB56C: 48ABCC01  bl 0x831a816c
	ctx.lr = 0x826EB570;
	sub_831A8130(ctx, base);
	// 826EB570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB574: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EB578: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826EB57C: 4BE2518D  bl 0x82510708
	ctx.lr = 0x826EB580;
	sub_82510708(ctx, base);
	// 826EB580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB584: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EB588: 4BFFFDB1  bl 0x826eb338
	ctx.lr = 0x826EB58C;
	sub_826EB338(ctx, base);
	// 826EB58C: 83FE00FC  lwz r31, 0xfc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 826EB590: 48000014  b 0x826eb5a4
	pc = 0x826EB5A4; continue 'dispatch;
	// 826EB594: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EB598: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB59C: 480DFF7D  bl 0x827cb518
	ctx.lr = 0x826EB5A0;
	sub_827CB518(ctx, base);
	// 826EB5A0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826EB5A4: 817E0100  lwz r11, 0x100(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) } as u64;
	// 826EB5A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826EB5AC: 409AFFE8  bne cr6, 0x826eb594
	if !ctx.cr[6].eq {
	pc = 0x826EB594; continue 'dispatch;
	}
	// 826EB5B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB5B4: 48ABCC08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB5B8 size=180
    let mut pc: u32 = 0x826EB5B8;
    'dispatch: loop {
        match pc {
            0x826EB5B8 => {
    //   block [0x826EB5B8..0x826EB66C)
	// 826EB5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB5C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB5C4: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826EB5C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EB5CC: 2F0A000F  cmpwi cr6, r10, 0xf
	ctx.cr[6].compare_i32(ctx.r[10].s32, 15, &mut ctx.xer);
	// 826EB5D0: 419A0048  beq cr6, 0x826eb618
	if ctx.cr[6].eq {
	pc = 0x826EB618; continue 'dispatch;
	}
	// 826EB5D4: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 826EB5D8: 409A0084  bne cr6, 0x826eb65c
	if !ctx.cr[6].eq {
	pc = 0x826EB65C; continue 'dispatch;
	}
	// 826EB5DC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EB5E0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB5E4: C1AB0108  lfs f13, 0x108(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EB5E8: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826EB5EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 826EB5F0: 38A8BA24  addi r5, r8, -0x45dc
	ctx.r[5].s64 = ctx.r[8].s64 + -17884;
	// 826EB5F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EB5F8: C00AB9F4  lfs f0, -0x460c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17932 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EB5FC: 81490030  lwz r10, 0x30(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 826EB600: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826EB604: D00B0108  stfs f0, 0x108(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826EB608: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826EB60C: 4E800421  bctrl
	ctx.lr = 0x826EB610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EB610: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EB614: 4800003C  b 0x826eb650
	pc = 0x826EB650; continue 'dispatch;
	// 826EB618: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EB61C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB620: C1AB0108  lfs f13, 0x108(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EB624: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826EB628: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 826EB62C: 38A8BA24  addi r5, r8, -0x45dc
	ctx.r[5].s64 = ctx.r[8].s64 + -17884;
	// 826EB630: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826EB634: C00AB9F4  lfs f0, -0x460c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17932 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EB638: 81490030  lwz r10, 0x30(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 826EB63C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826EB640: D00B0108  stfs f0, 0x108(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826EB644: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826EB648: 4E800421  bctrl
	ctx.lr = 0x826EB64C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EB64C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EB650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EB654: 419A0008  beq cr6, 0x826eb65c
	if ctx.cr[6].eq {
	pc = 0x826EB65C; continue 'dispatch;
	}
	// 826EB658: 4BBD5239  bl 0x822c0890
	ctx.lr = 0x826EB65C;
	sub_822C0890(ctx, base);
	// 826EB65C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB670 size=120
    let mut pc: u32 = 0x826EB670;
    'dispatch: loop {
        match pc {
            0x826EB670 => {
    //   block [0x826EB670..0x826EB6E8)
	// 826EB670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB674: 48ABCAF9  bl 0x831a816c
	ctx.lr = 0x826EB678;
	sub_831A8130(ctx, base);
	// 826EB678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB67C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EB680: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826EB684: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB688: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EB68C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826EB690: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826EB694: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826EB698: 48706D51  bl 0x82df23e8
	ctx.lr = 0x826EB69C;
	sub_82DF23E8(ctx, base);
	// 826EB69C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EB6A0: 41820014  beq 0x826eb6b4
	if ctx.cr[0].eq {
	pc = 0x826EB6B4; continue 'dispatch;
	}
	// 826EB6A4: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB6A8: 4846ED09  bl 0x82b5a3b0
	ctx.lr = 0x826EB6AC;
	sub_82B5A3B0(ctx, base);
	// 826EB6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB6B0: 48000008  b 0x826eb6b8
	pc = 0x826EB6B8; continue 'dispatch;
	// 826EB6B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EB6B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EB6BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826EB6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EB6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB6C8: 4BFFFD11  bl 0x826eb3d8
	ctx.lr = 0x826EB6CC;
	sub_826EB3D8(ctx, base);
	// 826EB6CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EB6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EB6D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB6D8: 4BBD4929  bl 0x822c0000
	ctx.lr = 0x826EB6DC;
	sub_822C0000(ctx, base);
	// 826EB6DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EB6E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB6E4: 48ABCAD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB6E8 size=208
    let mut pc: u32 = 0x826EB6E8;
    'dispatch: loop {
        match pc {
            0x826EB6E8 => {
    //   block [0x826EB6E8..0x826EB7B8)
	// 826EB6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB6F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EB6F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB6F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB6FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826EB700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB704: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 826EB708: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EB70C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EB710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EB714: 4BFFFF5D  bl 0x826eb670
	ctx.lr = 0x826EB718;
	sub_826EB670(ctx, base);
	// 826EB718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EB71C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EB720: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EB724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EB728: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826EB72C: 419A0024  beq cr6, 0x826eb750
	if ctx.cr[6].eq {
	pc = 0x826EB750; continue 'dispatch;
	}
	// 826EB730: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826EB734: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EB738: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EB73C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EB740: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EB744: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EB748: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EB74C: 4082FFE8  bne 0x826eb734
	if !ctx.cr[0].eq {
	pc = 0x826EB734; continue 'dispatch;
	}
	// 826EB750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EB754: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 826EB758: 4891C9D1  bl 0x83008128
	ctx.lr = 0x826EB75C;
	sub_83008128(ctx, base);
	// 826EB75C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EB760: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EB764: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826EB768: 388ABA40  addi r4, r10, -0x45c0
	ctx.r[4].s64 = ctx.r[10].s64 + -17856;
	// 826EB76C: 38A000BB  li r5, 0xbb
	ctx.r[5].s64 = 187;
	// 826EB770: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826EB774: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EB778: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826EB77C: 4876D2C5  bl 0x82e58a40
	ctx.lr = 0x826EB780;
	sub_82E58A40(ctx, base);
	// 826EB780: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EB784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EB788: 419A0008  beq cr6, 0x826eb790
	if ctx.cr[6].eq {
	pc = 0x826EB790; continue 'dispatch;
	}
	// 826EB78C: 4BBD5105  bl 0x822c0890
	ctx.lr = 0x826EB790;
	sub_822C0890(ctx, base);
	// 826EB790: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EB794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EB798: 419A0008  beq cr6, 0x826eb7a0
	if ctx.cr[6].eq {
	pc = 0x826EB7A0; continue 'dispatch;
	}
	// 826EB79C: 4BBD50F5  bl 0x822c0890
	ctx.lr = 0x826EB7A0;
	sub_822C0890(ctx, base);
	// 826EB7A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EB7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB7AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EB7B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB7B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EB7B8 size=140
    let mut pc: u32 = 0x826EB7B8;
    'dispatch: loop {
        match pc {
            0x826EB7B8 => {
    //   block [0x826EB7B8..0x826EB844)
	// 826EB7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB7C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB7C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB7C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB7CC: 4BE26B65  bl 0x82512330
	ctx.lr = 0x826EB7D0;
	sub_82512330(ctx, base);
	// 826EB7D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EB7D4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EB7D8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826EB7DC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EB7E0: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826EB7E4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826EB7E8: 394ABAFC  addi r10, r10, -0x4504
	ctx.r[10].s64 = ctx.r[10].s64 + -17668;
	// 826EB7EC: 3929BAE8  addi r9, r9, -0x4518
	ctx.r[9].s64 = ctx.r[9].s64 + -17688;
	// 826EB7F0: 3908BA9C  addi r8, r8, -0x4564
	ctx.r[8].s64 = ctx.r[8].s64 + -17764;
	// 826EB7F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826EB7F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EB7FC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826EB800: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EB804: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826EB808: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826EB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB810: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826EB814: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826EB818: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826EB81C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EB820: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826EB824: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826EB828: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EB82C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826EB830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EB834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB83C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EB848 size=8
    let mut pc: u32 = 0x826EB848;
    'dispatch: loop {
        match pc {
            0x826EB848 => {
    //   block [0x826EB848..0x826EB850)
	// 826EB848: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EB84C: 4800007C  b 0x826eb8c8
	sub_826EB8C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EB850 size=8
    let mut pc: u32 = 0x826EB850;
    'dispatch: loop {
        match pc {
            0x826EB850 => {
    //   block [0x826EB850..0x826EB858)
	// 826EB850: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EB854: 48000074  b 0x826eb8c8
	sub_826EB8C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB858 size=108
    let mut pc: u32 = 0x826EB858;
    'dispatch: loop {
        match pc {
            0x826EB858 => {
    //   block [0x826EB858..0x826EB8C4)
	// 826EB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB860: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB864: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB868: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB86C: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 826EB870: 4BDC5A31  bl 0x824b12a0
	ctx.lr = 0x826EB874;
	sub_824B12A0(ctx, base);
	// 826EB874: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826EB878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EB87C: 419A0008  beq cr6, 0x826eb884
	if ctx.cr[6].eq {
	pc = 0x826EB884; continue 'dispatch;
	}
	// 826EB880: 4BBD5011  bl 0x822c0890
	ctx.lr = 0x826EB884;
	sub_822C0890(ctx, base);
	// 826EB884: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826EB888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EB88C: 419A0008  beq cr6, 0x826eb894
	if ctx.cr[6].eq {
	pc = 0x826EB894; continue 'dispatch;
	}
	// 826EB890: 4BBD5001  bl 0x822c0890
	ctx.lr = 0x826EB894;
	sub_822C0890(ctx, base);
	// 826EB894: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EB898: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826EB89C: 409A0008  bne cr6, 0x826eb8a4
	if !ctx.cr[6].eq {
	pc = 0x826EB8A4; continue 'dispatch;
	}
	// 826EB8A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EB8A4: 480BBDB5  bl 0x827a7658
	ctx.lr = 0x826EB8A8;
	sub_827A7658(ctx, base);
	// 826EB8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB8AC: 4BC63AA5  bl 0x8234f350
	ctx.lr = 0x826EB8B0;
	sub_8234F350(ctx, base);
	// 826EB8B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EB8B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB8B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB8C8 size=76
    let mut pc: u32 = 0x826EB8C8;
    'dispatch: loop {
        match pc {
            0x826EB8C8 => {
    //   block [0x826EB8C8..0x826EB914)
	// 826EB8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EB8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EB8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EB8E4: 4BFFFF75  bl 0x826eb858
	ctx.lr = 0x826EB8E8;
	sub_826EB858(ctx, base);
	// 826EB8E8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EB8EC: 4182000C  beq 0x826eb8f8
	if ctx.cr[0].eq {
	pc = 0x826EB8F8; continue 'dispatch;
	}
	// 826EB8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB8F4: 48706AE5  bl 0x82df23d8
	ctx.lr = 0x826EB8F8;
	sub_82DF23D8(ctx, base);
	// 826EB8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB8FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EB90C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB918 size=80
    let mut pc: u32 = 0x826EB918;
    'dispatch: loop {
        match pc {
            0x826EB918 => {
    //   block [0x826EB918..0x826EB968)
	// 826EB918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EB920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EB924: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB928: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 826EB92C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB930: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826EB934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EB938: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826EB93C: 4BDC989D  bl 0x824b51d8
	ctx.lr = 0x826EB940;
	sub_824B51D8(ctx, base);
	// 826EB940: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826EB944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EB948: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826EB94C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826EB950: 4BDC9889  bl 0x824b51d8
	ctx.lr = 0x826EB954;
	sub_824B51D8(ctx, base);
	// 826EB954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EB958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EB95C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EB960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EB964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EB968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EB968 size=276
    let mut pc: u32 = 0x826EB968;
    'dispatch: loop {
        match pc {
            0x826EB968 => {
    //   block [0x826EB968..0x826EBA7C)
	// 826EB968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EB96C: 48ABC7FD  bl 0x831a8168
	ctx.lr = 0x826EB970;
	sub_831A8130(ctx, base);
	// 826EB970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EB974: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826EB978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EB97C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EB980: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EB984: 41820038  beq 0x826eb9bc
	if ctx.cr[0].eq {
	pc = 0x826EB9BC; continue 'dispatch;
	}
	// 826EB988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB98C: 48ABDFFD  bl 0x831a9988
	ctx.lr = 0x826EB990;
	sub_831A9988(ctx, base);
	// 826EB990: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EB994: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EB998: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826EB99C: 48ABC75D  bl 0x831a80f8
	ctx.lr = 0x826EB9A0;
	sub_831A80F8(ctx, base);
	// 826EB9A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EB9A4: 41820018  beq 0x826eb9bc
	if ctx.cr[0].eq {
	pc = 0x826EB9BC; continue 'dispatch;
	}
	// 826EB9A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EB9AC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EB9B0: 4BFFFF69  bl 0x826eb918
	ctx.lr = 0x826EB9B4;
	sub_826EB918(ctx, base);
	// 826EB9B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EB9B8: 480000BC  b 0x826eba74
	pc = 0x826EBA74; continue 'dispatch;
	// 826EB9BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EB9C0: 419A00A4  beq cr6, 0x826eba64
	if ctx.cr[6].eq {
	pc = 0x826EBA64; continue 'dispatch;
	}
	// 826EB9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EB9C8: 48ABDFC1  bl 0x831a9988
	ctx.lr = 0x826EB9CC;
	sub_831A9988(ctx, base);
	// 826EB9CC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EB9D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EB9D4: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826EB9D8: 48ABC721  bl 0x831a80f8
	ctx.lr = 0x826EB9DC;
	sub_831A80F8(ctx, base);
	// 826EB9DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EB9E0: 41820014  beq 0x826eb9f4
	if ctx.cr[0].eq {
	pc = 0x826EB9F4; continue 'dispatch;
	}
	// 826EB9E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EB9E8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EB9EC: 4BFFFBCD  bl 0x826eb5b8
	ctx.lr = 0x826EB9F0;
	sub_826EB5B8(ctx, base);
	// 826EB9F0: 4BFFFFC4  b 0x826eb9b4
	pc = 0x826EB9B4; continue 'dispatch;
	// 826EB9F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EB9F8: 419A006C  beq cr6, 0x826eba64
	if ctx.cr[6].eq {
	pc = 0x826EBA64; continue 'dispatch;
	}
	// 826EB9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EBA00: 48ABDF89  bl 0x831a9988
	ctx.lr = 0x826EBA04;
	sub_831A9988(ctx, base);
	// 826EBA04: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826EBA08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBA0C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826EBA10: 48ABC6E9  bl 0x831a80f8
	ctx.lr = 0x826EBA14;
	sub_831A80F8(ctx, base);
	// 826EBA14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EBA18: 41820014  beq 0x826eba2c
	if ctx.cr[0].eq {
	pc = 0x826EBA2C; continue 'dispatch;
	}
	// 826EBA1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBA20: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EBA24: 4BFFFCC5  bl 0x826eb6e8
	ctx.lr = 0x826EBA28;
	sub_826EB6E8(ctx, base);
	// 826EBA28: 4BFFFF8C  b 0x826eb9b4
	pc = 0x826EB9B4; continue 'dispatch;
	// 826EBA2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EBA30: 419A0034  beq cr6, 0x826eba64
	if ctx.cr[6].eq {
	pc = 0x826EBA64; continue 'dispatch;
	}
	// 826EBA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EBA38: 48ABDF51  bl 0x831a9988
	ctx.lr = 0x826EBA3C;
	sub_831A9988(ctx, base);
	// 826EBA3C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EBA40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBA44: 386BE59C  addi r3, r11, -0x1a64
	ctx.r[3].s64 = ctx.r[11].s64 + -6756;
	// 826EBA48: 48ABC6B1  bl 0x831a80f8
	ctx.lr = 0x826EBA4C;
	sub_831A80F8(ctx, base);
	// 826EBA4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EBA50: 41820014  beq 0x826eba64
	if ctx.cr[0].eq {
	pc = 0x826EBA64; continue 'dispatch;
	}
	// 826EBA54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBA58: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EBA5C: 4BFFF8A5  bl 0x826eb300
	ctx.lr = 0x826EBA60;
	sub_826EB300(ctx, base);
	// 826EBA60: 4BFFFF54  b 0x826eb9b4
	pc = 0x826EB9B4; continue 'dispatch;
	// 826EBA64: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826EBA68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EBA70: 4BE26BA9  bl 0x82512618
	ctx.lr = 0x826EBA74;
	sub_82512618(ctx, base);
	// 826EBA74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EBA78: 48ABC740  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EBA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EBA80 size=424
    let mut pc: u32 = 0x826EBA80;
    'dispatch: loop {
        match pc {
            0x826EBA80 => {
    //   block [0x826EBA80..0x826EBC28)
	// 826EBA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EBA84: 48ABC6E1  bl 0x831a8164
	ctx.lr = 0x826EBA88;
	sub_831A8130(ctx, base);
	// 826EBA88: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EBA8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EBA90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EBA94: 3BCBBA40  addi r30, r11, -0x45c0
	ctx.r[30].s64 = ctx.r[11].s64 + -17856;
	// 826EBA98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EBA9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EBAA0: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 826EBAA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EBAA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EBAAC: 3860010C  li r3, 0x10c
	ctx.r[3].s64 = 268;
	// 826EBAB0: 48706939  bl 0x82df23e8
	ctx.lr = 0x826EBAB4;
	sub_82DF23E8(ctx, base);
	// 826EBAB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EBAB8: 41820010  beq 0x826ebac8
	if ctx.cr[0].eq {
	pc = 0x826EBAC8; continue 'dispatch;
	}
	// 826EBABC: 4BFFFCFD  bl 0x826eb7b8
	ctx.lr = 0x826EBAC0;
	sub_826EB7B8(ctx, base);
	// 826EBAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EBAC4: 48000008  b 0x826ebacc
	pc = 0x826EBACC; continue 'dispatch;
	// 826EBAC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EBACC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EBAD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBAD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EBAD8: 4BFFF9C9  bl 0x826eb4a0
	ctx.lr = 0x826EBADC;
	sub_826EB4A0(ctx, base);
	// 826EBADC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EBAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBAE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EBAE8: 4BBD4519  bl 0x822c0000
	ctx.lr = 0x826EBAEC;
	sub_822C0000(ctx, base);
	// 826EBAEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EBAF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EBAF4: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 826EBAF8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EBAFC: 4BBD48DD  bl 0x822c03d8
	ctx.lr = 0x826EBB00;
	sub_822C03D8(ctx, base);
	// 826EBB00: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EBB04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EBB08: 418200B4  beq 0x826ebbbc
	if ctx.cr[0].eq {
	pc = 0x826EBBBC; continue 'dispatch;
	}
	// 826EBB0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EBB10: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EBB14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EBB18: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EBB1C: 409A0008  bne cr6, 0x826ebb24
	if !ctx.cr[6].eq {
	pc = 0x826EBB24; continue 'dispatch;
	}
	// 826EBB20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EBB24: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EBB28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EBB2C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EBB30: 419A0024  beq cr6, 0x826ebb54
	if ctx.cr[6].eq {
	pc = 0x826EBB54; continue 'dispatch;
	}
	// 826EBB34: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EBB38: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EBB3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBB40: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EBB44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EBB48: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EBB4C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBB50: 4082FFE8  bne 0x826ebb38
	if !ctx.cr[0].eq {
	pc = 0x826EBB38; continue 'dispatch;
	}
	// 826EBB54: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EBB58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EBB5C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EBB60: 419A0024  beq cr6, 0x826ebb84
	if ctx.cr[6].eq {
	pc = 0x826EBB84; continue 'dispatch;
	}
	// 826EBB64: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EBB68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EBB6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBB70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EBB74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EBB78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EBB7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBB80: 4082FFE8  bne 0x826ebb68
	if !ctx.cr[0].eq {
	pc = 0x826EBB68; continue 'dispatch;
	}
	// 826EBB84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EBB88: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EBB8C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EBB90: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EBB94: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EBB98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EBB9C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EBBA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EBBA4: 480AD38D  bl 0x82798f30
	ctx.lr = 0x826EBBA8;
	sub_82798F30(ctx, base);
	// 826EBBA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBBAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EBBB0: 480AFAB9  bl 0x8279b668
	ctx.lr = 0x826EBBB4;
	sub_8279B668(ctx, base);
	// 826EBBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EBBB8: 48000008  b 0x826ebbc0
	pc = 0x826EBBC0; continue 'dispatch;
	// 826EBBBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EBBC0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EBBC4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EBBC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBBCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EBBD0: 4BEAC081  bl 0x82597c50
	ctx.lr = 0x826EBBD4;
	sub_82597C50(ctx, base);
	// 826EBBD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EBBD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBBDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EBBE0: 4BBD4421  bl 0x822c0000
	ctx.lr = 0x826EBBE4;
	sub_822C0000(ctx, base);
	// 826EBBE4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EBBE8: 41820024  beq 0x826ebc0c
	if ctx.cr[0].eq {
	pc = 0x826EBC0C; continue 'dispatch;
	}
	// 826EBBEC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EBBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EBBF4: 419A0008  beq cr6, 0x826ebbfc
	if ctx.cr[6].eq {
	pc = 0x826EBBFC; continue 'dispatch;
	}
	// 826EBBF8: 4BBD4C99  bl 0x822c0890
	ctx.lr = 0x826EBBFC;
	sub_822C0890(ctx, base);
	// 826EBBFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EBC00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EBC04: 419A0008  beq cr6, 0x826ebc0c
	if ctx.cr[6].eq {
	pc = 0x826EBC0C; continue 'dispatch;
	}
	// 826EBC08: 4BBD4C89  bl 0x822c0890
	ctx.lr = 0x826EBC0C;
	sub_822C0890(ctx, base);
	// 826EBC0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EBC10: 419A000C  beq cr6, 0x826ebc1c
	if ctx.cr[6].eq {
	pc = 0x826EBC1C; continue 'dispatch;
	}
	// 826EBC14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EBC18: 4BBD4C79  bl 0x822c0890
	ctx.lr = 0x826EBC1C;
	sub_822C0890(ctx, base);
	// 826EBC1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EBC20: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EBC24: 48ABC590  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EBC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EBC28 size=1008
    let mut pc: u32 = 0x826EBC28;
    'dispatch: loop {
        match pc {
            0x826EBC28 => {
    //   block [0x826EBC28..0x826EC018)
	// 826EBC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EBC2C: 48ABC529  bl 0x831a8154
	ctx.lr = 0x826EBC30;
	sub_831A8130(ctx, base);
	// 826EBC30: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EBC34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EBC38: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826EBC3C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 826EBC40: 4BE25D99  bl 0x825119d8
	ctx.lr = 0x826EBC44;
	sub_825119D8(ctx, base);
	// 826EBC44: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EBC48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBC4C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826EBC50: 48707DB9  bl 0x82df3a08
	ctx.lr = 0x826EBC54;
	sub_82DF3A08(ctx, base);
	// 826EBC54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826EBC58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EBC5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EBC60: 4BE1CB21  bl 0x82508780
	ctx.lr = 0x826EBC64;
	sub_82508780(ctx, base);
	// 826EBC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBC68: 487077C1  bl 0x82df3428
	ctx.lr = 0x826EBC6C;
	sub_82DF3428(ctx, base);
	// 826EBC6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EBC70: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826EBC74: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 826EBC78: 409A0008  bne cr6, 0x826ebc80
	if !ctx.cr[6].eq {
	pc = 0x826EBC80; continue 'dispatch;
	}
	// 826EBC7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBC80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EBC84: 4BE1CB1D  bl 0x825087a0
	ctx.lr = 0x826EBC88;
	sub_825087A0(ctx, base);
	// 826EBC88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826EBC8C: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EBC90: 4873EE59  bl 0x82e2aae8
	ctx.lr = 0x826EBC94;
	sub_82E2AAE8(ctx, base);
	// 826EBC94: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EBC98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBC9C: 3BABE4C8  addi r29, r11, -0x1b38
	ctx.r[29].s64 = ctx.r[11].s64 + -6968;
	// 826EBCA0: 808BE4C8  lwz r4, -0x1b38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6968 as u32) ) } as u64;
	// 826EBCA4: 48707D65  bl 0x82df3a08
	ctx.lr = 0x826EBCA8;
	sub_82DF3A08(ctx, base);
	// 826EBCA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EBCAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826EBCB0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826EBCB4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EBCB8: 487431B9  bl 0x82e2ee70
	ctx.lr = 0x826EBCBC;
	sub_82E2EE70(ctx, base);
	// 826EBCBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBCC0: 48707769  bl 0x82df3428
	ctx.lr = 0x826EBCC4;
	sub_82DF3428(ctx, base);
	// 826EBCC4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EBCC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EBCCC: 3AEBBA40  addi r23, r11, -0x45c0
	ctx.r[23].s64 = ctx.r[11].s64 + -17856;
	// 826EBCD0: 38A00050  li r5, 0x50
	ctx.r[5].s64 = 80;
	// 826EBCD4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826EBCD8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826EBCDC: 4870670D  bl 0x82df23e8
	ctx.lr = 0x826EBCE0;
	sub_82DF23E8(ctx, base);
	// 826EBCE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EBCE4: 41820014  beq 0x826ebcf8
	if ctx.cr[0].eq {
	pc = 0x826EBCF8; continue 'dispatch;
	}
	// 826EBCE8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826EBCEC: 4872ABA5  bl 0x82e16890
	ctx.lr = 0x826EBCF0;
	sub_82E16890(ctx, base);
	// 826EBCF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBCF4: 48000008  b 0x826ebcfc
	pc = 0x826EBCFC; continue 'dispatch;
	// 826EBCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBCFC: 3B7E00E8  addi r27, r30, 0xe8
	ctx.r[27].s64 = ctx.r[30].s64 + 232;
	// 826EBD00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EBD04: 4BC7166D  bl 0x8235d370
	ctx.lr = 0x826EBD08;
	sub_8235D370(ctx, base);
	// 826EBD08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EBD0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBD10: 839E00E8  lwz r28, 0xe8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 826EBD14: 4BE26405  bl 0x82512118
	ctx.lr = 0x826EBD18;
	sub_82512118(ctx, base);
	// 826EBD18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBD1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826EBD20: 48729391  bl 0x82e150b0
	ctx.lr = 0x826EBD24;
	sub_82E150B0(ctx, base);
	// 826EBD24: 817E00EC  lwz r11, 0xec(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 826EBD28: 815E00E8  lwz r10, 0xe8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 826EBD2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EBD30: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826EBD34: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EBD38: 419A0024  beq cr6, 0x826ebd5c
	if ctx.cr[6].eq {
	pc = 0x826EBD5C; continue 'dispatch;
	}
	// 826EBD3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826EBD40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EBD44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBD48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EBD4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EBD50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EBD54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EBD58: 4082FFE8  bne 0x826ebd40
	if !ctx.cr[0].eq {
	pc = 0x826EBD40; continue 'dispatch;
	}
	// 826EBD5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826EBD60: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826EBD64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826EBD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EBD6C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826EBD70: 4BE24C89  bl 0x825109f8
	ctx.lr = 0x826EBD74;
	sub_825109F8(ctx, base);
	// 826EBD74: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EBD78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EBD7C: 419A0008  beq cr6, 0x826ebd84
	if ctx.cr[6].eq {
	pc = 0x826EBD84; continue 'dispatch;
	}
	// 826EBD80: 4BBD4B11  bl 0x822c0890
	ctx.lr = 0x826EBD84;
	sub_822C0890(ctx, base);
	// 826EBD84: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EBD88: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EBD8C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 826EBD90: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 826EBD94: 3B3E00F8  addi r25, r30, 0xf8
	ctx.r[25].s64 = ctx.r[30].s64 + 248;
	// 826EBD98: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 826EBD9C: 3B4BBB50  addi r26, r11, -0x44b0
	ctx.r[26].s64 = ctx.r[11].s64 + -17584;
	// 826EBDA0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826EBDA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EBDA8: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 826EBDAC: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 826EBDB0: 4BBD4629  bl 0x822c03d8
	ctx.lr = 0x826EBDB4;
	sub_822C03D8(ctx, base);
	// 826EBDB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EBDB8: 41820024  beq 0x826ebddc
	if ctx.cr[0].eq {
	pc = 0x826EBDDC; continue 'dispatch;
	}
	// 826EBDBC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 826EBDC0: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EBDC4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EBDC8: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EBDCC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826EBDD0: 480DF401  bl 0x827cb1d0
	ctx.lr = 0x826EBDD4;
	sub_827CB1D0(ctx, base);
	// 826EBDD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EBDD8: 48000008  b 0x826ebde0
	pc = 0x826EBDE0; continue 'dispatch;
	// 826EBDDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EBDE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EBDE4: 4BF0CF85  bl 0x825f8d68
	ctx.lr = 0x826EBDE8;
	sub_825F8D68(ctx, base);
	// 826EBDE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EBDEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826EBDF0: 484C7319  bl 0x82bb3108
	ctx.lr = 0x826EBDF4;
	sub_82BB3108(ctx, base);
	// 826EBDF4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826EBDF8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 826EBDFC: 4082FFA4  bne 0x826ebda0
	if !ctx.cr[0].eq {
	pc = 0x826EBDA0; continue 'dispatch;
	}
	// 826EBE00: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EBE04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EBE08: 419A0008  beq cr6, 0x826ebe10
	if ctx.cr[6].eq {
	pc = 0x826EBE10; continue 'dispatch;
	}
	// 826EBE0C: 4BBD4A85  bl 0x822c0890
	ctx.lr = 0x826EBE10;
	sub_822C0890(ctx, base);
	// 826EBE10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826EBE14: 487E0BD5  bl 0x82ecc9e8
	ctx.lr = 0x826EBE18;
	sub_82ECC9E8(ctx, base);
	// 826EBE18: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 826EBE1C: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EBE20: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 826EBE24: 99610150  stb r11, 0x150(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u8 ) };
	// 826EBE28: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826EBE2C: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826EBE30: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826EBE34: 487B48FD  bl 0x82ea0730
	ctx.lr = 0x826EBE38;
	sub_82EA0730(ctx, base);
	// 826EBE38: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EBE3C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826EBE40: 396BBB40  addi r11, r11, -0x44c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17600;
	// 826EBE44: 394ABC40  addi r10, r10, -0x43c0
	ctx.r[10].s64 = ctx.r[10].s64 + -17344;
	// 826EBE48: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826EBE4C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 826EBE50: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 826EBE54: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EBE58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EBE5C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EBE60: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EC018 size=84
    let mut pc: u32 = 0x826EC018;
    'dispatch: loop {
        match pc {
            0x826EC018 => {
    //   block [0x826EC018..0x826EC06C)
	// 826EC018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC030: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826EC034: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826EC038: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EC03C: 4BE265DD  bl 0x82512618
	ctx.lr = 0x826EC040;
	sub_82512618(ctx, base);
	// 826EC040: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826EC044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC048: 419A000C  beq cr6, 0x826ec054
	if ctx.cr[6].eq {
	pc = 0x826EC054; continue 'dispatch;
	}
	// 826EC04C: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 826EC050: 4BC016D1  bl 0x822ed720
	ctx.lr = 0x826EC054;
	sub_822ED720(ctx, base);
	// 826EC054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC05C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EC070 size=196
    let mut pc: u32 = 0x826EC070;
    'dispatch: loop {
        match pc {
            0x826EC070 => {
    //   block [0x826EC070..0x826EC134)
	// 826EC070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC07C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EC088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC08C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EC090: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EC094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EC098: 4BBD48A1  bl 0x822c0938
	ctx.lr = 0x826EC09C;
	sub_822C0938(ctx, base);
	// 826EC09C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EC0A0: 41820028  beq 0x826ec0c8
	if ctx.cr[0].eq {
	pc = 0x826EC0C8; continue 'dispatch;
	}
	// 826EC0A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC0A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EC0AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EC0B0: 392BBCFC  addi r9, r11, -0x4304
	ctx.r[9].s64 = ctx.r[11].s64 + -17156;
	// 826EC0B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EC0B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EC0BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EC0C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EC0C4: 48000008  b 0x826ec0cc
	pc = 0x826EC0CC; continue 'dispatch;
	// 826EC0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC0CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EC0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EC0D4: 409A0044  bne cr6, 0x826ec118
	if !ctx.cr[6].eq {
	pc = 0x826EC118; continue 'dispatch;
	}
	// 826EC0D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EC0DC: 419A001C  beq cr6, 0x826ec0f8
	if ctx.cr[6].eq {
	pc = 0x826EC0F8; continue 'dispatch;
	}
	// 826EC0E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EC0E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EC0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC0EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EC0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EC0F4: 4E800421  bctrl
	ctx.lr = 0x826EC0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EC0F8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EC0FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EC100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EC104: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EC108: 816BE624  lwz r11, -0x19dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6620 as u32) ) } as u64;
	// 826EC10C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EC110: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EC114: 4BBD3EED  bl 0x822c0000
	ctx.lr = 0x826EC118;
	sub_822C0000(ctx, base);
	// 826EC118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC11C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC12C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EC138 size=184
    let mut pc: u32 = 0x826EC138;
    'dispatch: loop {
        match pc {
            0x826EC138 => {
    //   block [0x826EC138..0x826EC1F0)
	// 826EC138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC14C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC150: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC154: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EC158: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EC15C: 396BBD74  addi r11, r11, -0x428c
	ctx.r[11].s64 = ctx.r[11].s64 + -17036;
	// 826EC160: 394ABD60  addi r10, r10, -0x42a0
	ctx.r[10].s64 = ctx.r[10].s64 + -17056;
	// 826EC164: 3929BD14  addi r9, r9, -0x42ec
	ctx.r[9].s64 = ctx.r[9].s64 + -17132;
	// 826EC168: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EC16C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826EC170: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 826EC174: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826EC178: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826EC17C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC180: 419A0008  beq cr6, 0x826ec188
	if ctx.cr[6].eq {
	pc = 0x826EC188; continue 'dispatch;
	}
	// 826EC184: 4BBD470D  bl 0x822c0890
	ctx.lr = 0x826EC188;
	sub_822C0890(ctx, base);
	// 826EC188: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826EC18C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC190: 419A0008  beq cr6, 0x826ec198
	if ctx.cr[6].eq {
	pc = 0x826EC198; continue 'dispatch;
	}
	// 826EC194: 4BBD46FD  bl 0x822c0890
	ctx.lr = 0x826EC198;
	sub_822C0890(ctx, base);
	// 826EC198: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826EC19C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC1A0: 419A0008  beq cr6, 0x826ec1a8
	if ctx.cr[6].eq {
	pc = 0x826EC1A8; continue 'dispatch;
	}
	// 826EC1A4: 4BBD46ED  bl 0x822c0890
	ctx.lr = 0x826EC1A8;
	sub_822C0890(ctx, base);
	// 826EC1A8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826EC1AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC1B0: 419A0008  beq cr6, 0x826ec1b8
	if ctx.cr[6].eq {
	pc = 0x826EC1B8; continue 'dispatch;
	}
	// 826EC1B4: 4BBD46DD  bl 0x822c0890
	ctx.lr = 0x826EC1B8;
	sub_822C0890(ctx, base);
	// 826EC1B8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826EC1BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC1C0: 419A0008  beq cr6, 0x826ec1c8
	if ctx.cr[6].eq {
	pc = 0x826EC1C8; continue 'dispatch;
	}
	// 826EC1C4: 4BBD46CD  bl 0x822c0890
	ctx.lr = 0x826EC1C8;
	sub_822C0890(ctx, base);
	// 826EC1C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC1CC: 480BB48D  bl 0x827a7658
	ctx.lr = 0x826EC1D0;
	sub_827A7658(ctx, base);
	// 826EC1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC1D4: 4BC6317D  bl 0x8234f350
	ctx.lr = 0x826EC1D8;
	sub_8234F350(ctx, base);
	// 826EC1D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC1E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EC1F0 size=8
    let mut pc: u32 = 0x826EC1F0;
    'dispatch: loop {
        match pc {
            0x826EC1F0 => {
    //   block [0x826EC1F0..0x826EC1F8)
	// 826EC1F0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EC1F4: 480002EC  b 0x826ec4e0
	sub_826EC4E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EC1F8 size=8
    let mut pc: u32 = 0x826EC1F8;
    'dispatch: loop {
        match pc {
            0x826EC1F8 => {
    //   block [0x826EC1F8..0x826EC200)
	// 826EC1F8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EC1FC: 480002E4  b 0x826ec4e0
	sub_826EC4E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC200 size=176
    let mut pc: u32 = 0x826EC200;
    'dispatch: loop {
        match pc {
            0x826EC200 => {
    //   block [0x826EC200..0x826EC2B0)
	// 826EC200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC20C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC210: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC218: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EC21C: 4BBD3DE5  bl 0x822c0000
	ctx.lr = 0x826EC220;
	sub_822C0000(ctx, base);
	// 826EC220: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC224: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC228: 388BBDB0  addi r4, r11, -0x4250
	ctx.r[4].s64 = ctx.r[11].s64 + -16976;
	// 826EC22C: 487077DD  bl 0x82df3a08
	ctx.lr = 0x826EC230;
	sub_82DF3A08(ctx, base);
	// 826EC230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EC234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EC238: 388B1334  addi r4, r11, 0x1334
	ctx.r[4].s64 = ctx.r[11].s64 + 4916;
	// 826EC23C: 487077CD  bl 0x82df3a08
	ctx.lr = 0x826EC240;
	sub_82DF3A08(ctx, base);
	// 826EC240: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EC244: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826EC248: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EC24C: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 826EC250: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EC254: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EC258: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826EC25C: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826EC260: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EC264: 4BEB7045  bl 0x825a32a8
	ctx.lr = 0x826EC268;
	sub_825A32A8(ctx, base);
	// 826EC268: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EC26C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EC270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC274: 4BEB54FD  bl 0x825a1770
	ctx.lr = 0x826EC278;
	sub_825A1770(ctx, base);
	// 826EC278: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826EC27C: 487071AD  bl 0x82df3428
	ctx.lr = 0x826EC280;
	sub_82DF3428(ctx, base);
	// 826EC280: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826EC284: 4BBDCA35  bl 0x822c8cb8
	ctx.lr = 0x826EC288;
	sub_822C8CB8(ctx, base);
	// 826EC288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EC28C: 4870719D  bl 0x82df3428
	ctx.lr = 0x826EC290;
	sub_82DF3428(ctx, base);
	// 826EC290: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC294: 48707195  bl 0x82df3428
	ctx.lr = 0x826EC298;
	sub_82DF3428(ctx, base);
	// 826EC298: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826EC29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC2A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC2A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC2B0 size=160
    let mut pc: u32 = 0x826EC2B0;
    'dispatch: loop {
        match pc {
            0x826EC2B0 => {
    //   block [0x826EC2B0..0x826EC350)
	// 826EC2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC2BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC2C4: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826EC2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EC2CC: 409A0070  bne cr6, 0x826ec33c
	if !ctx.cr[6].eq {
	pc = 0x826EC33C; continue 'dispatch;
	}
	// 826EC2D0: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826EC2D4: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826EC2D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EC2DC: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EC2E0: 394AE604  addi r10, r10, -0x19fc
	ctx.r[10].s64 = ctx.r[10].s64 + -6652;
	// 826EC2E4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826EC2E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826EC2EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC2F0: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EC2F4: 90FF0114  stw r7, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[7].u32 ) };
	// 826EC2F8: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 826EC2FC: 81280038  lwz r9, 0x38(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 826EC300: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826EC304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EC308: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826EC30C: 4E800421  bctrl
	ctx.lr = 0x826EC310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EC310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EC314: 395F0104  addi r10, r31, 0x104
	ctx.r[10].s64 = ctx.r[31].s64 + 260;
	// 826EC318: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826EC31C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826EC320: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EC324: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EC328: 4BBD8139  bl 0x822c4460
	ctx.lr = 0x826EC32C;
	sub_822C4460(ctx, base);
	// 826EC32C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EC330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC334: 419A0008  beq cr6, 0x826ec33c
	if ctx.cr[6].eq {
	pc = 0x826EC33C; continue 'dispatch;
	}
	// 826EC338: 4BBD4559  bl 0x822c0890
	ctx.lr = 0x826EC33C;
	sub_822C0890(ctx, base);
	// 826EC33C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC348: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC34C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EC350 size=220
    let mut pc: u32 = 0x826EC350;
    'dispatch: loop {
        match pc {
            0x826EC350 => {
    //   block [0x826EC350..0x826EC42C)
	// 826EC350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC354: 48ABBE15  bl 0x831a8168
	ctx.lr = 0x826EC358;
	sub_831A8130(ctx, base);
	// 826EC358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC35C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826EC360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EC364: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EC368: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EC36C: 41820038  beq 0x826ec3a4
	if ctx.cr[0].eq {
	pc = 0x826EC3A4; continue 'dispatch;
	}
	// 826EC370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC374: 48ABD615  bl 0x831a9988
	ctx.lr = 0x826EC378;
	sub_831A9988(ctx, base);
	// 826EC378: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826EC37C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC380: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826EC384: 48ABBD75  bl 0x831a80f8
	ctx.lr = 0x826EC388;
	sub_831A80F8(ctx, base);
	// 826EC388: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC38C: 41820018  beq 0x826ec3a4
	if ctx.cr[0].eq {
	pc = 0x826EC3A4; continue 'dispatch;
	}
	// 826EC390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC394: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EC398: 4BFFFF19  bl 0x826ec2b0
	ctx.lr = 0x826EC39C;
	sub_826EC2B0(ctx, base);
	// 826EC39C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EC3A0: 48000084  b 0x826ec424
	pc = 0x826EC424; continue 'dispatch;
	// 826EC3A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC3A8: 419A006C  beq cr6, 0x826ec414
	if ctx.cr[6].eq {
	pc = 0x826EC414; continue 'dispatch;
	}
	// 826EC3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC3B0: 48ABD5D9  bl 0x831a9988
	ctx.lr = 0x826EC3B4;
	sub_831A9988(ctx, base);
	// 826EC3B4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826EC3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC3BC: 386B5BA8  addi r3, r11, 0x5ba8
	ctx.r[3].s64 = ctx.r[11].s64 + 23464;
	// 826EC3C0: 48ABBD39  bl 0x831a80f8
	ctx.lr = 0x826EC3C4;
	sub_831A80F8(ctx, base);
	// 826EC3C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC3C8: 41820014  beq 0x826ec3dc
	if ctx.cr[0].eq {
	pc = 0x826EC3DC; continue 'dispatch;
	}
	// 826EC3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC3D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EC3D4: 4BFFFC45  bl 0x826ec018
	ctx.lr = 0x826EC3D8;
	sub_826EC018(ctx, base);
	// 826EC3D8: 4BFFFFC4  b 0x826ec39c
	pc = 0x826EC39C; continue 'dispatch;
	// 826EC3DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC3E0: 419A0034  beq cr6, 0x826ec414
	if ctx.cr[6].eq {
	pc = 0x826EC414; continue 'dispatch;
	}
	// 826EC3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC3E8: 48ABD5A1  bl 0x831a9988
	ctx.lr = 0x826EC3EC;
	sub_831A9988(ctx, base);
	// 826EC3EC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EC3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC3F4: 386BCB78  addi r3, r11, -0x3488
	ctx.r[3].s64 = ctx.r[11].s64 + -13448;
	// 826EC3F8: 48ABBD01  bl 0x831a80f8
	ctx.lr = 0x826EC3FC;
	sub_831A80F8(ctx, base);
	// 826EC3FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC400: 41820014  beq 0x826ec414
	if ctx.cr[0].eq {
	pc = 0x826EC414; continue 'dispatch;
	}
	// 826EC404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC408: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EC40C: 48017BF5  bl 0x82704000
	ctx.lr = 0x826EC410;
	sub_82704000(ctx, base);
	// 826EC410: 4BFFFF8C  b 0x826ec39c
	pc = 0x826EC39C; continue 'dispatch;
	// 826EC414: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826EC418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC420: 4BE261F9  bl 0x82512618
	ctx.lr = 0x826EC424;
	sub_82512618(ctx, base);
	// 826EC424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EC428: 48ABBD90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC430 size=172
    let mut pc: u32 = 0x826EC430;
    'dispatch: loop {
        match pc {
            0x826EC430 => {
    //   block [0x826EC430..0x826EC4DC)
	// 826EC430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC43C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EC44C: 4BFDE1A5  bl 0x826ca5f0
	ctx.lr = 0x826EC450;
	sub_826CA5F0(ctx, base);
	// 826EC450: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC454: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 826EC458: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EC45C: 396BBD74  addi r11, r11, -0x428c
	ctx.r[11].s64 = ctx.r[11].s64 + -17036;
	// 826EC460: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EC464: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EC468: 394ABD60  addi r10, r10, -0x42a0
	ctx.r[10].s64 = ctx.r[10].s64 + -17056;
	// 826EC46C: 3929BD14  addi r9, r9, -0x42ec
	ctx.r[9].s64 = ctx.r[9].s64 + -17132;
	// 826EC470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC474: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826EC478: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826EC47C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EC480: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826EC484: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EC488: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826EC48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC490: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826EC494: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826EC498: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826EC49C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EC4A0: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826EC4A4: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EC4A8: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EC4AC: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826EC4B0: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826EC4B4: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826EC4B8: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 826EC4BC: D1BF011C  stfs f13, 0x11c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 826EC4C0: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826EC4C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC4C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC4CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC4D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EC4E0 size=76
    let mut pc: u32 = 0x826EC4E0;
    'dispatch: loop {
        match pc {
            0x826EC4E0 => {
    //   block [0x826EC4E0..0x826EC52C)
	// 826EC4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EC4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EC4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EC4F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC4F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EC4FC: 4BFFFC3D  bl 0x826ec138
	ctx.lr = 0x826EC500;
	sub_826EC138(ctx, base);
	// 826EC500: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC504: 4182000C  beq 0x826ec510
	if ctx.cr[0].eq {
	pc = 0x826EC510; continue 'dispatch;
	}
	// 826EC508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC50C: 48705ECD  bl 0x82df23d8
	ctx.lr = 0x826EC510;
	sub_82DF23D8(ctx, base);
	// 826EC510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EC518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EC51C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EC520: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EC524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EC528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC530 size=428
    let mut pc: u32 = 0x826EC530;
    'dispatch: loop {
        match pc {
            0x826EC530 => {
    //   block [0x826EC530..0x826EC6DC)
	// 826EC530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC534: 48ABBC31  bl 0x831a8164
	ctx.lr = 0x826EC538;
	sub_831A8130(ctx, base);
	// 826EC538: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC53C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC540: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EC544: 3BCBBDC0  addi r30, r11, -0x4240
	ctx.r[30].s64 = ctx.r[11].s64 + -16960;
	// 826EC548: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EC54C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC550: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 826EC554: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EC558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC55C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826EC560: 48705E89  bl 0x82df23e8
	ctx.lr = 0x826EC564;
	sub_82DF23E8(ctx, base);
	// 826EC564: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EC568: 41820014  beq 0x826ec57c
	if ctx.cr[0].eq {
	pc = 0x826EC57C; continue 'dispatch;
	}
	// 826EC56C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826EC570: 4BFFFEC1  bl 0x826ec430
	ctx.lr = 0x826EC574;
	sub_826EC430(ctx, base);
	// 826EC574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC578: 48000008  b 0x826ec580
	pc = 0x826EC580; continue 'dispatch;
	// 826EC57C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC580: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EC584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC588: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC58C: 4BFFFAE5  bl 0x826ec070
	ctx.lr = 0x826EC590;
	sub_826EC070(ctx, base);
	// 826EC590: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC594: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC598: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC59C: 4BBD3A65  bl 0x822c0000
	ctx.lr = 0x826EC5A0;
	sub_822C0000(ctx, base);
	// 826EC5A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC5A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC5A8: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826EC5AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EC5B0: 4BBD3E29  bl 0x822c03d8
	ctx.lr = 0x826EC5B4;
	sub_822C03D8(ctx, base);
	// 826EC5B4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EC5B8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EC5BC: 418200B4  beq 0x826ec670
	if ctx.cr[0].eq {
	pc = 0x826EC670; continue 'dispatch;
	}
	// 826EC5C0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EC5C4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EC5C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EC5CC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EC5D0: 409A0008  bne cr6, 0x826ec5d8
	if !ctx.cr[6].eq {
	pc = 0x826EC5D8; continue 'dispatch;
	}
	// 826EC5D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC5D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EC5DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC5E0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EC5E4: 419A0024  beq cr6, 0x826ec608
	if ctx.cr[6].eq {
	pc = 0x826EC608; continue 'dispatch;
	}
	// 826EC5E8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC5EC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EC5F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC5F4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EC5F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EC5FC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC600: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC604: 4082FFE8  bne 0x826ec5ec
	if !ctx.cr[0].eq {
	pc = 0x826EC5EC; continue 'dispatch;
	}
	// 826EC608: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EC60C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC610: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EC614: 419A0024  beq cr6, 0x826ec638
	if ctx.cr[6].eq {
	pc = 0x826EC638; continue 'dispatch;
	}
	// 826EC618: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC61C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EC620: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC624: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EC628: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EC62C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC630: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC634: 4082FFE8  bne 0x826ec61c
	if !ctx.cr[0].eq {
	pc = 0x826EC61C; continue 'dispatch;
	}
	// 826EC638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EC63C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EC640: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EC644: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EC648: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EC64C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EC650: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EC654: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EC658: 480AC8D9  bl 0x82798f30
	ctx.lr = 0x826EC65C;
	sub_82798F30(ctx, base);
	// 826EC65C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC664: 480AF005  bl 0x8279b668
	ctx.lr = 0x826EC668;
	sub_8279B668(ctx, base);
	// 826EC668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC66C: 48000008  b 0x826ec674
	pc = 0x826EC674; continue 'dispatch;
	// 826EC670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC674: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EC678: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EC67C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC684: 4BEAB5CD  bl 0x82597c50
	ctx.lr = 0x826EC688;
	sub_82597C50(ctx, base);
	// 826EC688: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC68C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC694: 4BBD396D  bl 0x822c0000
	ctx.lr = 0x826EC698;
	sub_822C0000(ctx, base);
	// 826EC698: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC69C: 41820024  beq 0x826ec6c0
	if ctx.cr[0].eq {
	pc = 0x826EC6C0; continue 'dispatch;
	}
	// 826EC6A0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EC6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC6A8: 419A0008  beq cr6, 0x826ec6b0
	if ctx.cr[6].eq {
	pc = 0x826EC6B0; continue 'dispatch;
	}
	// 826EC6AC: 4BBD41E5  bl 0x822c0890
	ctx.lr = 0x826EC6B0;
	sub_822C0890(ctx, base);
	// 826EC6B0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EC6B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC6B8: 419A0008  beq cr6, 0x826ec6c0
	if ctx.cr[6].eq {
	pc = 0x826EC6C0; continue 'dispatch;
	}
	// 826EC6BC: 4BBD41D5  bl 0x822c0890
	ctx.lr = 0x826EC6C0;
	sub_822C0890(ctx, base);
	// 826EC6C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC6C4: 419A000C  beq cr6, 0x826ec6d0
	if ctx.cr[6].eq {
	pc = 0x826EC6D0; continue 'dispatch;
	}
	// 826EC6C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EC6CC: 4BBD41C5  bl 0x822c0890
	ctx.lr = 0x826EC6D0;
	sub_822C0890(ctx, base);
	// 826EC6D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EC6D4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EC6D8: 48ABBADC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC6E0 size=428
    let mut pc: u32 = 0x826EC6E0;
    'dispatch: loop {
        match pc {
            0x826EC6E0 => {
    //   block [0x826EC6E0..0x826EC88C)
	// 826EC6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC6E4: 48ABBA81  bl 0x831a8164
	ctx.lr = 0x826EC6E8;
	sub_831A8130(ctx, base);
	// 826EC6E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC6EC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC6F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EC6F4: 3BCBBDC0  addi r30, r11, -0x4240
	ctx.r[30].s64 = ctx.r[11].s64 + -16960;
	// 826EC6F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EC6FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC700: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 826EC704: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EC708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC70C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826EC710: 48705CD9  bl 0x82df23e8
	ctx.lr = 0x826EC714;
	sub_82DF23E8(ctx, base);
	// 826EC714: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EC718: 41820014  beq 0x826ec72c
	if ctx.cr[0].eq {
	pc = 0x826EC72C; continue 'dispatch;
	}
	// 826EC71C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EC720: 4BFFFD11  bl 0x826ec430
	ctx.lr = 0x826EC724;
	sub_826EC430(ctx, base);
	// 826EC724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC728: 48000008  b 0x826ec730
	pc = 0x826EC730; continue 'dispatch;
	// 826EC72C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC730: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EC734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC738: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC73C: 4BFFF935  bl 0x826ec070
	ctx.lr = 0x826EC740;
	sub_826EC070(ctx, base);
	// 826EC740: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC748: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC74C: 4BBD38B5  bl 0x822c0000
	ctx.lr = 0x826EC750;
	sub_822C0000(ctx, base);
	// 826EC750: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC754: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC758: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 826EC75C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EC760: 4BBD3C79  bl 0x822c03d8
	ctx.lr = 0x826EC764;
	sub_822C03D8(ctx, base);
	// 826EC764: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EC768: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EC76C: 418200B4  beq 0x826ec820
	if ctx.cr[0].eq {
	pc = 0x826EC820; continue 'dispatch;
	}
	// 826EC770: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EC774: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EC778: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EC77C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EC780: 409A0008  bne cr6, 0x826ec788
	if !ctx.cr[6].eq {
	pc = 0x826EC788; continue 'dispatch;
	}
	// 826EC784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC788: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EC78C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC790: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EC794: 419A0024  beq cr6, 0x826ec7b8
	if ctx.cr[6].eq {
	pc = 0x826EC7B8; continue 'dispatch;
	}
	// 826EC798: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC79C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EC7A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC7A4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EC7A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EC7AC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC7B0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC7B4: 4082FFE8  bne 0x826ec79c
	if !ctx.cr[0].eq {
	pc = 0x826EC79C; continue 'dispatch;
	}
	// 826EC7B8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EC7BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC7C0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EC7C4: 419A0024  beq cr6, 0x826ec7e8
	if ctx.cr[6].eq {
	pc = 0x826EC7E8; continue 'dispatch;
	}
	// 826EC7C8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC7CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EC7D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC7D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EC7D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EC7DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC7E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC7E4: 4082FFE8  bne 0x826ec7cc
	if !ctx.cr[0].eq {
	pc = 0x826EC7CC; continue 'dispatch;
	}
	// 826EC7E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EC7EC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EC7F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EC7F4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EC7F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EC7FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EC800: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EC804: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EC808: 480AC729  bl 0x82798f30
	ctx.lr = 0x826EC80C;
	sub_82798F30(ctx, base);
	// 826EC80C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC814: 480AEE55  bl 0x8279b668
	ctx.lr = 0x826EC818;
	sub_8279B668(ctx, base);
	// 826EC818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC81C: 48000008  b 0x826ec824
	pc = 0x826EC824; continue 'dispatch;
	// 826EC820: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC824: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EC828: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EC82C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC834: 4BEAB41D  bl 0x82597c50
	ctx.lr = 0x826EC838;
	sub_82597C50(ctx, base);
	// 826EC838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC844: 4BBD37BD  bl 0x822c0000
	ctx.lr = 0x826EC848;
	sub_822C0000(ctx, base);
	// 826EC848: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC84C: 41820024  beq 0x826ec870
	if ctx.cr[0].eq {
	pc = 0x826EC870; continue 'dispatch;
	}
	// 826EC850: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EC854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC858: 419A0008  beq cr6, 0x826ec860
	if ctx.cr[6].eq {
	pc = 0x826EC860; continue 'dispatch;
	}
	// 826EC85C: 4BBD4035  bl 0x822c0890
	ctx.lr = 0x826EC860;
	sub_822C0890(ctx, base);
	// 826EC860: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EC864: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EC868: 419A0008  beq cr6, 0x826ec870
	if ctx.cr[6].eq {
	pc = 0x826EC870; continue 'dispatch;
	}
	// 826EC86C: 4BBD4025  bl 0x822c0890
	ctx.lr = 0x826EC870;
	sub_822C0890(ctx, base);
	// 826EC870: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC874: 419A000C  beq cr6, 0x826ec880
	if ctx.cr[6].eq {
	pc = 0x826EC880; continue 'dispatch;
	}
	// 826EC878: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EC87C: 4BBD4015  bl 0x822c0890
	ctx.lr = 0x826EC880;
	sub_822C0890(ctx, base);
	// 826EC880: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EC884: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EC888: 48ABB92C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EC890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EC890 size=428
    let mut pc: u32 = 0x826EC890;
    'dispatch: loop {
        match pc {
            0x826EC890 => {
    //   block [0x826EC890..0x826ECA3C)
	// 826EC890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EC894: 48ABB8D1  bl 0x831a8164
	ctx.lr = 0x826EC898;
	sub_831A8130(ctx, base);
	// 826EC898: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EC89C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EC8A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EC8A4: 3BCBBDC0  addi r30, r11, -0x4240
	ctx.r[30].s64 = ctx.r[11].s64 + -16960;
	// 826EC8A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EC8AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC8B0: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 826EC8B4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EC8B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC8BC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826EC8C0: 48705B29  bl 0x82df23e8
	ctx.lr = 0x826EC8C4;
	sub_82DF23E8(ctx, base);
	// 826EC8C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EC8C8: 41820014  beq 0x826ec8dc
	if ctx.cr[0].eq {
	pc = 0x826EC8DC; continue 'dispatch;
	}
	// 826EC8CC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826EC8D0: 4BFFFB61  bl 0x826ec430
	ctx.lr = 0x826EC8D4;
	sub_826EC430(ctx, base);
	// 826EC8D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC8D8: 48000008  b 0x826ec8e0
	pc = 0x826EC8E0; continue 'dispatch;
	// 826EC8DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC8E0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EC8E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC8E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC8EC: 4BFFF785  bl 0x826ec070
	ctx.lr = 0x826EC8F0;
	sub_826EC070(ctx, base);
	// 826EC8F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC8F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC8F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EC8FC: 4BBD3705  bl 0x822c0000
	ctx.lr = 0x826EC900;
	sub_822C0000(ctx, base);
	// 826EC900: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EC904: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EC908: 38A00087  li r5, 0x87
	ctx.r[5].s64 = 135;
	// 826EC90C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EC910: 4BBD3AC9  bl 0x822c03d8
	ctx.lr = 0x826EC914;
	sub_822C03D8(ctx, base);
	// 826EC914: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EC918: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EC91C: 418200B4  beq 0x826ec9d0
	if ctx.cr[0].eq {
	pc = 0x826EC9D0; continue 'dispatch;
	}
	// 826EC920: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EC924: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EC928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EC92C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EC930: 409A0008  bne cr6, 0x826ec938
	if !ctx.cr[6].eq {
	pc = 0x826EC938; continue 'dispatch;
	}
	// 826EC934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EC938: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EC93C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC940: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EC944: 419A0024  beq cr6, 0x826ec968
	if ctx.cr[6].eq {
	pc = 0x826EC968; continue 'dispatch;
	}
	// 826EC948: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC94C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EC950: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC954: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EC958: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EC95C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC960: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC964: 4082FFE8  bne 0x826ec94c
	if !ctx.cr[0].eq {
	pc = 0x826EC94C; continue 'dispatch;
	}
	// 826EC968: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EC96C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EC970: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EC974: 419A0024  beq cr6, 0x826ec998
	if ctx.cr[6].eq {
	pc = 0x826EC998; continue 'dispatch;
	}
	// 826EC978: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EC97C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EC980: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC984: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EC988: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EC98C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EC990: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EC994: 4082FFE8  bne 0x826ec97c
	if !ctx.cr[0].eq {
	pc = 0x826EC97C; continue 'dispatch;
	}
	// 826EC998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EC99C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EC9A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EC9A4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EC9A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EC9AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EC9B0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EC9B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EC9B8: 480AC579  bl 0x82798f30
	ctx.lr = 0x826EC9BC;
	sub_82798F30(ctx, base);
	// 826EC9BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EC9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EC9C4: 480AECA5  bl 0x8279b668
	ctx.lr = 0x826EC9C8;
	sub_8279B668(ctx, base);
	// 826EC9C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EC9CC: 48000008  b 0x826ec9d4
	pc = 0x826EC9D4; continue 'dispatch;
	// 826EC9D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EC9D4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EC9D8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EC9DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC9E4: 4BEAB26D  bl 0x82597c50
	ctx.lr = 0x826EC9E8;
	sub_82597C50(ctx, base);
	// 826EC9E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EC9EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EC9F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EC9F4: 4BBD360D  bl 0x822c0000
	ctx.lr = 0x826EC9F8;
	sub_822C0000(ctx, base);
	// 826EC9F8: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EC9FC: 41820024  beq 0x826eca20
	if ctx.cr[0].eq {
	pc = 0x826ECA20; continue 'dispatch;
	}
	// 826ECA00: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826ECA04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECA08: 419A0008  beq cr6, 0x826eca10
	if ctx.cr[6].eq {
	pc = 0x826ECA10; continue 'dispatch;
	}
	// 826ECA0C: 4BBD3E85  bl 0x822c0890
	ctx.lr = 0x826ECA10;
	sub_822C0890(ctx, base);
	// 826ECA10: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826ECA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECA18: 419A0008  beq cr6, 0x826eca20
	if ctx.cr[6].eq {
	pc = 0x826ECA20; continue 'dispatch;
	}
	// 826ECA1C: 4BBD3E75  bl 0x822c0890
	ctx.lr = 0x826ECA20;
	sub_822C0890(ctx, base);
	// 826ECA20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826ECA24: 419A000C  beq cr6, 0x826eca30
	if ctx.cr[6].eq {
	pc = 0x826ECA30; continue 'dispatch;
	}
	// 826ECA28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826ECA2C: 4BBD3E65  bl 0x822c0890
	ctx.lr = 0x826ECA30;
	sub_822C0890(ctx, base);
	// 826ECA30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826ECA34: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826ECA38: 48ABB77C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ECA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ECA40 size=948
    let mut pc: u32 = 0x826ECA40;
    'dispatch: loop {
        match pc {
            0x826ECA40 => {
    //   block [0x826ECA40..0x826ECDF4)
	// 826ECA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ECA44: 48ABB711  bl 0x831a8154
	ctx.lr = 0x826ECA48;
	sub_831A8130(ctx, base);
	// 826ECA48: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ECA4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ECA50: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 826ECA54: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826ECA58: 4BE24F81  bl 0x825119d8
	ctx.lr = 0x826ECA5C;
	sub_825119D8(ctx, base);
	// 826ECA5C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826ECA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECA64: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826ECA68: 48706FA1  bl 0x82df3a08
	ctx.lr = 0x826ECA6C;
	sub_82DF3A08(ctx, base);
	// 826ECA6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826ECA70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ECA74: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826ECA78: 4BE1BD09  bl 0x82508780
	ctx.lr = 0x826ECA7C;
	sub_82508780(ctx, base);
	// 826ECA7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECA80: 487069A9  bl 0x82df3428
	ctx.lr = 0x826ECA84;
	sub_82DF3428(ctx, base);
	// 826ECA84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ECA88: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826ECA8C: 409A0008  bne cr6, 0x826eca94
	if !ctx.cr[6].eq {
	pc = 0x826ECA94; continue 'dispatch;
	}
	// 826ECA90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826ECA94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826ECA98: 4BE1BD09  bl 0x825087a0
	ctx.lr = 0x826ECA9C;
	sub_825087A0(ctx, base);
	// 826ECA9C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ECAA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ECAA4: 388BBDC0  addi r4, r11, -0x4240
	ctx.r[4].s64 = ctx.r[11].s64 + -16960;
	// 826ECAA8: 38A000AC  li r5, 0xac
	ctx.r[5].s64 = 172;
	// 826ECAAC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826ECAB0: 48705939  bl 0x82df23e8
	ctx.lr = 0x826ECAB4;
	sub_82DF23E8(ctx, base);
	// 826ECAB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ECAB8: 41820018  beq 0x826ecad0
	if ctx.cr[0].eq {
	pc = 0x826ECAD0; continue 'dispatch;
	}
	// 826ECABC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826ECAC0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826ECAC4: 4872662D  bl 0x82e130f0
	ctx.lr = 0x826ECAC8;
	sub_82E130F0(ctx, base);
	// 826ECAC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ECACC: 48000008  b 0x826ecad4
	pc = 0x826ECAD4; continue 'dispatch;
	// 826ECAD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826ECAD4: 3B5F010C  addi r26, r31, 0x10c
	ctx.r[26].s64 = ctx.r[31].s64 + 268;
	// 826ECAD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826ECADC: 4BBF5275  bl 0x822e1d50
	ctx.lr = 0x826ECAE0;
	sub_822E1D50(ctx, base);
	// 826ECAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ECAE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826ECAE8: 83DF010C  lwz r30, 0x10c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 826ECAEC: 4BE2562D  bl 0x82512118
	ctx.lr = 0x826ECAF0;
	sub_82512118(ctx, base);
	// 826ECAF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826ECAF4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECAF8: 48726339  bl 0x82e12e30
	ctx.lr = 0x826ECAFC;
	sub_82E12E30(ctx, base);
	// 826ECAFC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826ECB00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECB04: 419A0008  beq cr6, 0x826ecb0c
	if ctx.cr[6].eq {
	pc = 0x826ECB0C; continue 'dispatch;
	}
	// 826ECB08: 4BBD3D89  bl 0x822c0890
	ctx.lr = 0x826ECB0C;
	sub_822C0890(ctx, base);
	// 826ECB0C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ECB10: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECB14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECB18: 3BABE5C8  addi r29, r11, -0x1a38
	ctx.r[29].s64 = ctx.r[11].s64 + -6712;
	// 826ECB1C: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826ECB20: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826ECB24: 48706EE5  bl 0x82df3a08
	ctx.lr = 0x826ECB28;
	sub_82DF3A08(ctx, base);
	// 826ECB28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826ECB2C: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECB30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ECB34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826ECB38: 4BFDE2E9  bl 0x826cae20
	ctx.lr = 0x826ECB3C;
	sub_826CAE20(ctx, base);
	// 826ECB3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ECB40: 3B7F00EC  addi r27, r31, 0xec
	ctx.r[27].s64 = ctx.r[31].s64 + 236;
	// 826ECB44: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826ECB48: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 826ECB4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECB50: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826ECB54: 4BBD790D  bl 0x822c4460
	ctx.lr = 0x826ECB58;
	sub_822C4460(ctx, base);
	// 826ECB58: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826ECB5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECB60: 419A0008  beq cr6, 0x826ecb68
	if ctx.cr[6].eq {
	pc = 0x826ECB68; continue 'dispatch;
	}
	// 826ECB64: 4BBD3D2D  bl 0x822c0890
	ctx.lr = 0x826ECB68;
	sub_822C0890(ctx, base);
	// 826ECB68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECB6C: 487068BD  bl 0x82df3428
	ctx.lr = 0x826ECB70;
	sub_82DF3428(ctx, base);
	// 826ECB70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECB74: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826ECB78: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826ECB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECB80: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826ECB84: 4BE23FD5  bl 0x82510b58
	ctx.lr = 0x826ECB88;
	sub_82510B58(ctx, base);
	// 826ECB88: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECB8C: 397D0018  addi r11, r29, 0x18
	ctx.r[11].s64 = ctx.r[29].s64 + 24;
	// 826ECB90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECB94: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826ECB98: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826ECB9C: 48706E6D  bl 0x82df3a08
	ctx.lr = 0x826ECBA0;
	sub_82DF3A08(ctx, base);
	// 826ECBA0: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECBA4: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 826ECBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECBAC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826ECBB0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826ECBB4: 48706E55  bl 0x82df3a08
	ctx.lr = 0x826ECBB8;
	sub_82DF3A08(ctx, base);
	// 826ECBB8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826ECBBC: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECBC0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826ECBC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ECBC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826ECBCC: 4BFDE1D5  bl 0x826cada0
	ctx.lr = 0x826ECBD0;
	sub_826CADA0(ctx, base);
	// 826ECBD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ECBD4: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 826ECBD8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826ECBDC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826ECBE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECBE4: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826ECBE8: 4BBD7879  bl 0x822c4460
	ctx.lr = 0x826ECBEC;
	sub_822C4460(ctx, base);
	// 826ECBEC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826ECBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECBF4: 419A0008  beq cr6, 0x826ecbfc
	if ctx.cr[6].eq {
	pc = 0x826ECBFC; continue 'dispatch;
	}
	// 826ECBF8: 4BBD3C99  bl 0x822c0890
	ctx.lr = 0x826ECBFC;
	sub_822C0890(ctx, base);
	// 826ECBFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECC00: 48706829  bl 0x82df3428
	ctx.lr = 0x826ECC04;
	sub_82DF3428(ctx, base);
	// 826ECC04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECC08: 48706821  bl 0x82df3428
	ctx.lr = 0x826ECC0C;
	sub_82DF3428(ctx, base);
	// 826ECC0C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826ECC10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECC14: 4BE25185  bl 0x82511d98
	ctx.lr = 0x826ECC18;
	sub_82511D98(ctx, base);
	// 826ECC18: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826ECC1C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECC20: 4BC00D01  bl 0x822ed920
	ctx.lr = 0x826ECC24;
	sub_822ED920(ctx, base);
	// 826ECC24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECC28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECC2C: 808B6784  lwz r4, 0x6784(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26500 as u32) ) } as u64;
	// 826ECC30: 831E0000  lwz r24, 0(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECC34: 4BBF82FD  bl 0x822e4f30
	ctx.lr = 0x826ECC38;
	sub_822E4F30(ctx, base);
	// 826ECC38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECC3C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826ECC40: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 826ECC44: 3CA08335  lis r5, -0x7ccb
	ctx.r[5].s64 = -2093678592;
	// 826ECC48: 3C808335  lis r4, -0x7ccb
	ctx.r[4].s64 = -2093678592;
	// 826ECC4C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 826ECC50: 810B6764  lwz r8, 0x6764(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26468 as u32) ) } as u64;
	// 826ECC54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECC58: 80EA675C  lwz r7, 0x675c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26460 as u32) ) } as u64;
	// 826ECC5C: 80C9677C  lwz r6, 0x677c(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26492 as u32) ) } as u64;
	// 826ECC60: 80A56768  lwz r5, 0x6768(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(26472 as u32) ) } as u64;
	// 826ECC64: 80846754  lwz r4, 0x6754(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26452 as u32) ) } as u64;
	// 826ECC68: 4BCC33A9  bl 0x823b0010
	ctx.lr = 0x826ECC6C;
	sub_823B0010(ctx, base);
	// 826ECC6C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826ECC70: E8970000  ld r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	// 826ECC74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ECC78: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826ECC7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826ECC80: 4BD9F609  bl 0x8248c288
	ctx.lr = 0x826ECC84;
	sub_8248C288(ctx, base);
	// 826ECC84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ECC88: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826ECC8C: 4BDA2715  bl 0x8248f3a0
	ctx.lr = 0x826ECC90;
	sub_8248F3A0(ctx, base);
	// 826ECC90: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826ECC94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECC98: 480ED341  bl 0x827d9fd8
	ctx.lr = 0x826ECC9C;
	sub_827D9FD8(ctx, base);
	// 826ECC9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECCA0: 4BBFA0E1  bl 0x822e6d80
	ctx.lr = 0x826ECCA4;
	sub_822E6D80(ctx, base);
	// 826ECCA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826ECCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECCAC: 4BE24095  bl 0x82510d40
	ctx.lr = 0x826ECCB0;
	sub_82510D40(ctx, base);
	// 826ECCB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ECCB4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECCB8: 4BC00D81  bl 0x822eda38
	ctx.lr = 0x826ECCBC;
	sub_822EDA38(ctx, base);
	// 826ECCBC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECCC0: 397D0030  addi r11, r29, 0x30
	ctx.r[11].s64 = ctx.r[29].s64 + 48;
	// 826ECCC4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826ECCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECCCC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826ECCD0: 48706D39  bl 0x82df3a08
	ctx.lr = 0x826ECCD4;
	sub_82DF3A08(ctx, base);
	// 826ECCD4: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECCD8: 397D0024  addi r11, r29, 0x24
	ctx.r[11].s64 = ctx.r[29].s64 + 36;
	// 826ECCDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECCE0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826ECCE4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826ECCE8: 48706D21  bl 0x82df3a08
	ctx.lr = 0x826ECCEC;
	sub_82DF3A08(ctx, base);
	// 826ECCEC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826ECCF0: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECCF4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826ECCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ECCFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826ECD00: 4BFDE0A1  bl 0x826cada0
	ctx.lr = 0x826ECD04;
	sub_826CADA0(ctx, base);
	// 826ECD04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ECD08: 3BBF00FC  addi r29, r31, 0xfc
	ctx.r[29].s64 = ctx.r[31].s64 + 252;
	// 826ECD0C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826ECD10: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826ECD14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECD18: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826ECD1C: 4BBD7745  bl 0x822c4460
	ctx.lr = 0x826ECD20;
	sub_822C4460(ctx, base);
	// 826ECD20: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826ECD24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECD28: 419A0008  beq cr6, 0x826ecd30
	if ctx.cr[6].eq {
	pc = 0x826ECD30; continue 'dispatch;
	}
	// 826ECD2C: 4BBD3B65  bl 0x822c0890
	ctx.lr = 0x826ECD30;
	sub_822C0890(ctx, base);
	// 826ECD30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECD34: 487066F5  bl 0x82df3428
	ctx.lr = 0x826ECD38;
	sub_82DF3428(ctx, base);
	// 826ECD38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ECD3C: 487066ED  bl 0x82df3428
	ctx.lr = 0x826ECD40;
	sub_82DF3428(ctx, base);
	// 826ECD40: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826ECD44: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECD48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ECD4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826ECD50: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826ECD54: 419A0024  beq cr6, 0x826ecd78
	if ctx.cr[6].eq {
	pc = 0x826ECD78; continue 'dispatch;
	}
	// 826ECD58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826ECD5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826ECD60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ECD64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826ECD68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826ECD6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826ECD70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826ECD74: 4082FFE8  bne 0x826ecd5c
	if !ctx.cr[0].eq {
	pc = 0x826ECD5C; continue 'dispatch;
	}
	// 826ECD78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826ECD7C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECD80: 4BC011E1  bl 0x822edf60
	ctx.lr = 0x826ECD84;
	sub_822EDF60(ctx, base);
	// 826ECD84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECD88: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECD8C: 808B674C  lwz r4, 0x674c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826ECD90: 4BDA2611  bl 0x8248f3a0
	ctx.lr = 0x826ECD94;
	sub_8248F3A0(ctx, base);
	// 826ECD94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826ECD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECD9C: 4BE23FA5  bl 0x82510d40
	ctx.lr = 0x826ECDA0;
	sub_82510D40(ctx, base);
	// 826ECDA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ECDA4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECDA8: 4BC01541  bl 0x822ee2e8
	ctx.lr = 0x826ECDAC;
	sub_822EE2E8(ctx, base);
	// 826ECDAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ECDB0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826ECDB4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826ECDB8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECDBC: 4BE1BDE5  bl 0x82508ba0
	ctx.lr = 0x826ECDC0;
	sub_82508BA0(ctx, base);
	// 826ECDC0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826ECDC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECDC8: 419A0008  beq cr6, 0x826ecdd0
	if ctx.cr[6].eq {
	pc = 0x826ECDD0; continue 'dispatch;
	}
	// 826ECDCC: 4BBD3AC5  bl 0x822c0890
	ctx.lr = 0x826ECDD0;
	sub_822C0890(ctx, base);
	// 826ECDD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ECDD4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECDD8: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECDDC: 4BC015B5  bl 0x822ee390
	ctx.lr = 0x826ECDE0;
	sub_822EE390(ctx, base);
	// 826ECDE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ECDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECDE8: 48728309  bl 0x82e150f0
	ctx.lr = 0x826ECDEC;
	sub_82E150F0(ctx, base);
	// 826ECDEC: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 826ECDF0: 48ABB3B4  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ECDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ECDF8 size=424
    let mut pc: u32 = 0x826ECDF8;
    'dispatch: loop {
        match pc {
            0x826ECDF8 => {
    //   block [0x826ECDF8..0x826ECFA0)
	// 826ECDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ECDFC: 48ABB371  bl 0x831a816c
	ctx.lr = 0x826ECE00;
	sub_831A8130(ctx, base);
	// 826ECE00: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ECE04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ECE08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826ECE0C: 4BE238FD  bl 0x82510708
	ctx.lr = 0x826ECE10;
	sub_82510708(ctx, base);
	// 826ECE10: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826ECE14: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826ECE18: 409A0180  bne cr6, 0x826ecf98
	if !ctx.cr[6].eq {
	pc = 0x826ECF98; continue 'dispatch;
	}
	// 826ECE1C: C1BF0118  lfs f13, 0x118(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ECE20: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ECE24: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826ECE28: C1BF011C  lfs f13, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ECE2C: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 826ECE30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826ECE34: 419900C0  bgt cr6, 0x826ecef4
	if ctx.cr[6].gt {
	pc = 0x826ECEF4; continue 'dispatch;
	}
	// 826ECE38: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECE3C: 83DF00F4  lwz r30, 0xf4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826ECE40: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826ECE44: 808B6784  lwz r4, 0x6784(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26500 as u32) ) } as u64;
	// 826ECE48: 4BBF80E9  bl 0x822e4f30
	ctx.lr = 0x826ECE4C;
	sub_822E4F30(ctx, base);
	// 826ECE4C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826ECE50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826ECE54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ECE58: 808B6774  lwz r4, 0x6774(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26484 as u32) ) } as u64;
	// 826ECE5C: 4BBF80D5  bl 0x822e4f30
	ctx.lr = 0x826ECE60;
	sub_822E4F30(ctx, base);
	// 826ECE60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826ECE64: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 826ECE68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ECE6C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826ECE70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826ECE74: 4BD9F415  bl 0x8248c288
	ctx.lr = 0x826ECE78;
	sub_8248C288(ctx, base);
	// 826ECE78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ECE7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ECE80: 4BDA2521  bl 0x8248f3a0
	ctx.lr = 0x826ECE84;
	sub_8248F3A0(ctx, base);
	// 826ECE84: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826ECE88: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826ECE8C: 4BC00BAD  bl 0x822eda38
	ctx.lr = 0x826ECE90;
	sub_822EDA38(ctx, base);
	// 826ECE90: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 826ECE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECE98: 4BE23811  bl 0x825106a8
	ctx.lr = 0x826ECE9C;
	sub_825106A8(ctx, base);
	// 826ECE9C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826ECEA0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826ECEA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECEA8: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826ECEAC: 419A0008  beq cr6, 0x826eceb4
	if ctx.cr[6].eq {
	pc = 0x826ECEB4; continue 'dispatch;
	}
	// 826ECEB0: 48459819  bl 0x82b466c8
	ctx.lr = 0x826ECEB4;
	sub_82B466C8(ctx, base);
	// 826ECEB4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826ECEB8: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826ECEBC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ECEC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826ECEC4: 394AE610  addi r10, r10, -0x19f0
	ctx.r[10].s64 = ctx.r[10].s64 + -6640;
	// 826ECEC8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826ECECC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826ECED0: 81290030  lwz r9, 0x30(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 826ECED4: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826ECED8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 826ECEDC: 4E800421  bctrl
	ctx.lr = 0x826ECEE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ECEE0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826ECEE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ECEE8: 419A00B0  beq cr6, 0x826ecf98
	if ctx.cr[6].eq {
	pc = 0x826ECF98; continue 'dispatch;
	}
	// 826ECEEC: 4BBD39A5  bl 0x822c0890
	ctx.lr = 0x826ECEF0;
	sub_822C0890(ctx, base);
	// 826ECEF0: 480000A8  b 0x826ecf98
	pc = 0x826ECF98; continue 'dispatch;
	// 826ECEF4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826ECEF8: EC6D0028  fsubs f3, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826ECEFC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826ECF00: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826ECF04: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826ECF08: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826ECF0C: C18B3FFC  lfs f12, 0x3ffc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16380 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826ECF10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826ECF14: C16A967C  lfs f11, -0x6984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826ECF18: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826ECF1C: C1499670  lfs f10, -0x6990(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 826ECF20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826ECF24: C1A808A4  lfs f13, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ECF28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826ECF2C: C007CFC8  lfs f0, -0x3038(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ECF30: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826ECF34: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826ECF38: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826ECF3C: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826ECF40: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826ECF44: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826ECF48: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826ECF4C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826ECF50: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826ECF54: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826ECF58: C02AD5B8  lfs f1, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826ECF5C: 4BFDEB85  bl 0x826cbae0
	ctx.lr = 0x826ECF60;
	sub_826CBAE0(ctx, base);
	// 826ECF60: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826ECF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECF68: 4BE24E31  bl 0x82511d98
	ctx.lr = 0x826ECF6C;
	sub_82511D98(ctx, base);
	// 826ECF6C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826ECF70: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826ECF74: 83FF00F4  lwz r31, 0xf4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826ECF78: 4878F061  bl 0x82e7bfd8
	ctx.lr = 0x826ECF7C;
	sub_82E7BFD8(ctx, base);
	// 826ECF7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ECF80: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826ECF84: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826ECF88: 4BBD7979  bl 0x822c4900
	ctx.lr = 0x826ECF8C;
	sub_822C4900(ctx, base);
	// 826ECF8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826ECF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ECF94: 4BC0098D  bl 0x822ed920
	ctx.lr = 0x826ECF98;
	sub_822ED920(ctx, base);
	// 826ECF98: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 826ECF9C: 48ABB220  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ECFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826ECFA0 size=16
    let mut pc: u32 = 0x826ECFA0;
    'dispatch: loop {
        match pc {
            0x826ECFA0 => {
    //   block [0x826ECFA0..0x826ECFB0)
	// 826ECFA0: 81630114  lwz r11, 0x114(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) } as u64;
	// 826ECFA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826ECFA8: 91630114  stw r11, 0x114(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826ECFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ECFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ECFB0 size=196
    let mut pc: u32 = 0x826ECFB0;
    'dispatch: loop {
        match pc {
            0x826ECFB0 => {
    //   block [0x826ECFB0..0x826ED074)
	// 826ECFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ECFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ECFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ECFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ECFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ECFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ECFC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ECFCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826ECFD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826ECFD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ECFD8: 4BBD3961  bl 0x822c0938
	ctx.lr = 0x826ECFDC;
	sub_822C0938(ctx, base);
	// 826ECFDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ECFE0: 41820028  beq 0x826ed008
	if ctx.cr[0].eq {
	pc = 0x826ED008; continue 'dispatch;
	}
	// 826ECFE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ECFE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826ECFEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826ECFF0: 392BBE30  addi r9, r11, -0x41d0
	ctx.r[9].s64 = ctx.r[11].s64 + -16848;
	// 826ECFF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ECFF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ECFFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826ED000: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826ED004: 48000008  b 0x826ed00c
	pc = 0x826ED00C; continue 'dispatch;
	// 826ED008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ED00C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ED010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ED014: 409A0044  bne cr6, 0x826ed058
	if !ctx.cr[6].eq {
	pc = 0x826ED058; continue 'dispatch;
	}
	// 826ED018: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ED01C: 419A001C  beq cr6, 0x826ed038
	if ctx.cr[6].eq {
	pc = 0x826ED038; continue 'dispatch;
	}
	// 826ED020: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED024: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ED028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ED02C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED030: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ED034: 4E800421  bctrl
	ctx.lr = 0x826ED038;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ED038: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ED03C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826ED040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED044: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826ED048: 816BE698  lwz r11, -0x1968(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6504 as u32) ) } as u64;
	// 826ED04C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826ED050: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826ED054: 4BBD2FAD  bl 0x822c0000
	ctx.lr = 0x826ED058;
	sub_822C0000(ctx, base);
	// 826ED058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED05C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ED064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ED068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ED06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ED070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED078 size=196
    let mut pc: u32 = 0x826ED078;
    'dispatch: loop {
        match pc {
            0x826ED078 => {
    //   block [0x826ED078..0x826ED13C)
	// 826ED078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ED080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ED084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ED088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED08C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ED090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ED094: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826ED098: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826ED09C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ED0A0: 4BBD3899  bl 0x822c0938
	ctx.lr = 0x826ED0A4;
	sub_822C0938(ctx, base);
	// 826ED0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ED0A8: 41820028  beq 0x826ed0d0
	if ctx.cr[0].eq {
	pc = 0x826ED0D0; continue 'dispatch;
	}
	// 826ED0AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED0B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826ED0B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826ED0B8: 392BBE44  addi r9, r11, -0x41bc
	ctx.r[9].s64 = ctx.r[11].s64 + -16828;
	// 826ED0BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ED0C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826ED0C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826ED0C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826ED0CC: 48000008  b 0x826ed0d4
	pc = 0x826ED0D4; continue 'dispatch;
	// 826ED0D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826ED0D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ED0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826ED0DC: 409A0044  bne cr6, 0x826ed120
	if !ctx.cr[6].eq {
	pc = 0x826ED120; continue 'dispatch;
	}
	// 826ED0E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826ED0E4: 419A001C  beq cr6, 0x826ed100
	if ctx.cr[6].eq {
	pc = 0x826ED100; continue 'dispatch;
	}
	// 826ED0E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED0EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826ED0F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ED0F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED0F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ED0FC: 4E800421  bctrl
	ctx.lr = 0x826ED100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ED100: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826ED104: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826ED108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED10C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826ED110: 816BE698  lwz r11, -0x1968(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6504 as u32) ) } as u64;
	// 826ED114: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826ED118: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826ED11C: 4BBD2EE5  bl 0x822c0000
	ctx.lr = 0x826ED120;
	sub_822C0000(ctx, base);
	// 826ED120: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ED12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ED130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ED134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ED138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ED140 size=796
    let mut pc: u32 = 0x826ED140;
    'dispatch: loop {
        match pc {
            0x826ED140 => {
    //   block [0x826ED140..0x826ED45C)
	// 826ED140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED144: 48ABB015  bl 0x831a8158
	ctx.lr = 0x826ED148;
	sub_831A8130(ctx, base);
	// 826ED148: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED14C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 826ED150: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826ED154: 4BE24C45  bl 0x82511d98
	ctx.lr = 0x826ED158;
	sub_82511D98(ctx, base);
	// 826ED158: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED15C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826ED160: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826ED164: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826ED168: C06BBE64  lfs f3, -0x419c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16796 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826ED16C: C04ABE60  lfs f2, -0x41a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16800 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826ED170: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826ED174: 4878EEA5  bl 0x82e7c018
	ctx.lr = 0x826ED178;
	sub_82E7C018(ctx, base);
	// 826ED178: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED17C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826ED180: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 826ED184: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 826ED188: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 826ED18C: C02BBE5C  lfs f1, -0x41a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16804 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826ED190: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 826ED194: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 826ED198: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826ED19C: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 826ED1A0: 13DB5407  vcmpneb. (lvlx128) v30, v27, v10
	tmp.u32 = ctx.r[27].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826ED1A4: 38E100F0  addi r7, r1, 0xf0
	ctx.r[7].s64 = ctx.r[1].s64 + 240;
	// 826ED1A8: 13BC5407  vcmpneb. (lvlx128) v29, v28, v10
	tmp.u32 = ctx.r[28].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826ED1AC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 826ED1B0: 139D5407  vcmpneb. (lvlx128) v28, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED460 size=148
    let mut pc: u32 = 0x826ED460;
    'dispatch: loop {
        match pc {
            0x826ED460 => {
    //   block [0x826ED460..0x826ED4F4)
	// 826ED460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ED468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ED46C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED470: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826ED474: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 826ED478: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 826ED47C: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 826ED480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ED484: 80EB0124  lwz r7, 0x124(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(292 as u32) ) } as u64;
	// 826ED488: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826ED48C: 80CB0120  lwz r6, 0x120(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) } as u64;
	// 826ED490: 41980048  blt cr6, 0x826ed4d8
	if ctx.cr[6].lt {
	pc = 0x826ED4D8; continue 'dispatch;
	}
	// 826ED494: 419A003C  beq cr6, 0x826ed4d0
	if ctx.cr[6].eq {
	pc = 0x826ED4D0; continue 'dispatch;
	}
	// 826ED498: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 826ED49C: 4198002C  blt cr6, 0x826ed4c8
	if ctx.cr[6].lt {
	pc = 0x826ED4C8; continue 'dispatch;
	}
	// 826ED4A0: 419A0020  beq cr6, 0x826ed4c0
	if ctx.cr[6].eq {
	pc = 0x826ED4C0; continue 'dispatch;
	}
	// 826ED4A4: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 826ED4A8: 41980010  blt cr6, 0x826ed4b8
	if ctx.cr[6].lt {
	pc = 0x826ED4B8; continue 'dispatch;
	}
	// 826ED4AC: 409A002C  bne cr6, 0x826ed4d8
	if !ctx.cr[6].eq {
	pc = 0x826ED4D8; continue 'dispatch;
	}
	// 826ED4B0: 4819A6B9  bl 0x82887b68
	ctx.lr = 0x826ED4B4;
	sub_82887B68(ctx, base);
	// 826ED4B4: 48000028  b 0x826ed4dc
	pc = 0x826ED4DC; continue 'dispatch;
	// 826ED4B8: 4819A529  bl 0x828879e0
	ctx.lr = 0x826ED4BC;
	sub_828879E0(ctx, base);
	// 826ED4BC: 48000020  b 0x826ed4dc
	pc = 0x826ED4DC; continue 'dispatch;
	// 826ED4C0: 4819A3A1  bl 0x82887860
	ctx.lr = 0x826ED4C4;
	sub_82887860(ctx, base);
	// 826ED4C4: 48000018  b 0x826ed4dc
	pc = 0x826ED4DC; continue 'dispatch;
	// 826ED4C8: 4819A079  bl 0x82887540
	ctx.lr = 0x826ED4CC;
	sub_82887540(ctx, base);
	// 826ED4CC: 48000010  b 0x826ed4dc
	pc = 0x826ED4DC; continue 'dispatch;
	// 826ED4D0: 48199D61  bl 0x82887230
	ctx.lr = 0x826ED4D4;
	sub_82887230(ctx, base);
	// 826ED4D4: 48000008  b 0x826ed4dc
	pc = 0x826ED4DC; continue 'dispatch;
	// 826ED4D8: 48199BC9  bl 0x828870a0
	ctx.lr = 0x826ED4DC;
	sub_828870A0(ctx, base);
	// 826ED4DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826ED4E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826ED4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ED4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ED4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ED4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED4F8 size=100
    let mut pc: u32 = 0x826ED4F8;
    'dispatch: loop {
        match pc {
            0x826ED4F8 => {
    //   block [0x826ED4F8..0x826ED55C)
	// 826ED4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED4FC: 48ABAC71  bl 0x831a816c
	ctx.lr = 0x826ED500;
	sub_831A8130(ctx, base);
	// 826ED500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ED508: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826ED50C: 4BE231FD  bl 0x82510708
	ctx.lr = 0x826ED510;
	sub_82510708(ctx, base);
	// 826ED510: 83FE0104  lwz r31, 0x104(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 826ED514: 48000020  b 0x826ed534
	pc = 0x826ED534; continue 'dispatch;
	// 826ED518: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED51C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826ED520: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED524: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826ED528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ED52C: 4E800421  bctrl
	ctx.lr = 0x826ED530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ED530: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826ED534: 817E0108  lwz r11, 0x108(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 826ED538: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826ED53C: 409AFFDC  bne cr6, 0x826ed518
	if !ctx.cr[6].eq {
	pc = 0x826ED518; continue 'dispatch;
	}
	// 826ED540: 897E0110  lbz r11, 0x110(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 826ED544: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826ED548: 4182000C  beq 0x826ed554
	if ctx.cr[0].eq {
	pc = 0x826ED554; continue 'dispatch;
	}
	// 826ED54C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED550: 4BFFFBF1  bl 0x826ed140
	ctx.lr = 0x826ED554;
	sub_826ED140(ctx, base);
	// 826ED554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED558: 48ABAC64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED560 size=80
    let mut pc: u32 = 0x826ED560;
    'dispatch: loop {
        match pc {
            0x826ED560 => {
    //   block [0x826ED560..0x826ED5B0)
	// 826ED560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED564: 48ABAC09  bl 0x831a816c
	ctx.lr = 0x826ED568;
	sub_831A8130(ctx, base);
	// 826ED568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ED570: 83DF0104  lwz r30, 0x104(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826ED574: 83BF0114  lwz r29, 0x114(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826ED578: 4800001C  b 0x826ed594
	pc = 0x826ED594; continue 'dispatch;
	// 826ED57C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED580: 48000CB1  bl 0x826ee230
	ctx.lr = 0x826ED584;
	sub_826EE230(ctx, base);
	// 826ED584: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826ED588: 41820008  beq 0x826ed590
	if ctx.cr[0].eq {
	pc = 0x826ED590; continue 'dispatch;
	}
	// 826ED58C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826ED590: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826ED594: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826ED598: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826ED59C: 409AFFE0  bne cr6, 0x826ed57c
	if !ctx.cr[6].eq {
	pc = 0x826ED57C; continue 'dispatch;
	}
	// 826ED5A0: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826ED5A4: 7C7D5850  subf r3, r29, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 826ED5A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED5AC: 48ABAC10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826ED5B0 size=448
    let mut pc: u32 = 0x826ED5B0;
    'dispatch: loop {
        match pc {
            0x826ED5B0 => {
    //   block [0x826ED5B0..0x826ED770)
	// 826ED5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED5B4: 48ABABB5  bl 0x831a8168
	ctx.lr = 0x826ED5B8;
	sub_831A8130(ctx, base);
	// 826ED5B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED5BC: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 826ED5C0: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826ED5C4: C0050000  lfs f0, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826ED5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ED5CC: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826ED5D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826ED5D4: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826ED5D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826ED5DC: C165000C  lfs f11, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826ED5E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 826ED5E4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 826ED5E8: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 826ED5EC: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 826ED5F0: D161009C  stfs f11, 0x9c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED770 size=160
    let mut pc: u32 = 0x826ED770;
    'dispatch: loop {
        match pc {
            0x826ED770 => {
    //   block [0x826ED770..0x826ED810)
	// 826ED770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ED778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ED77C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ED780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED784: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826ED788: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826ED78C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826ED790: 83FE0104  lwz r31, 0x104(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 826ED794: 419A0040  beq cr6, 0x826ed7d4
	if ctx.cr[6].eq {
	pc = 0x826ED7D4; continue 'dispatch;
	}
	// 826ED798: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826ED79C: 409A005C  bne cr6, 0x826ed7f8
	if !ctx.cr[6].eq {
	pc = 0x826ED7F8; continue 'dispatch;
	}
	// 826ED7A0: 48000010  b 0x826ed7b0
	pc = 0x826ED7B0; continue 'dispatch;
	// 826ED7A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED7A8: 48001331  bl 0x826eead8
	ctx.lr = 0x826ED7AC;
	sub_826EEAD8(ctx, base);
	// 826ED7AC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826ED7B0: 817E0108  lwz r11, 0x108(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 826ED7B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826ED7B8: 409AFFEC  bne cr6, 0x826ed7a4
	if !ctx.cr[6].eq {
	pc = 0x826ED7A4; continue 'dispatch;
	}
	// 826ED7BC: 807E00F0  lwz r3, 0xf0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 826ED7C0: 48458F09  bl 0x82b466c8
	ctx.lr = 0x826ED7C4;
	sub_82B466C8(ctx, base);
	// 826ED7C4: 48000034  b 0x826ed7f8
	pc = 0x826ED7F8; continue 'dispatch;
	// 826ED7C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED7CC: 4800117D  bl 0x826ee948
	ctx.lr = 0x826ED7D0;
	sub_826EE948(ctx, base);
	// 826ED7D0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826ED7D4: 817E0108  lwz r11, 0x108(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 826ED7D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826ED7DC: 409AFFEC  bne cr6, 0x826ed7c8
	if !ctx.cr[6].eq {
	pc = 0x826ED7C8; continue 'dispatch;
	}
	// 826ED7E0: 807E00F0  lwz r3, 0xf0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 826ED7E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826ED7E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826ED7EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826ED7F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826ED7F4: 4E800421  bctrl
	ctx.lr = 0x826ED7F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826ED7F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ED800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ED804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ED808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ED80C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED810 size=112
    let mut pc: u32 = 0x826ED810;
    'dispatch: loop {
        match pc {
            0x826ED810 => {
    //   block [0x826ED810..0x826ED880)
	// 826ED810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ED818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ED81C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ED820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED824: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826ED828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ED82C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826ED830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED834: 4BFFF845  bl 0x826ed078
	ctx.lr = 0x826ED838;
	sub_826ED078(ctx, base);
	// 826ED838: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826ED83C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826ED840: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED844: 4BBD27BD  bl 0x822c0000
	ctx.lr = 0x826ED848;
	sub_822C0000(ctx, base);
	// 826ED848: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826ED84C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826ED850: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826ED854: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826ED858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826ED85C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826ED860: 419A0008  beq cr6, 0x826ed868
	if ctx.cr[6].eq {
	pc = 0x826ED868; continue 'dispatch;
	}
	// 826ED864: 4BBD302D  bl 0x822c0890
	ctx.lr = 0x826ED868;
	sub_822C0890(ctx, base);
	// 826ED868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826ED86C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826ED870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826ED874: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826ED878: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826ED87C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826ED880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826ED880 size=484
    let mut pc: u32 = 0x826ED880;
    'dispatch: loop {
        match pc {
            0x826ED880 => {
    //   block [0x826ED880..0x826EDA64)
	// 826ED880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826ED884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826ED888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826ED88C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826ED890: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826ED894: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826ED89C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826ED8A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED8A4: 388BBEDC  addi r4, r11, -0x4124
	ctx.r[4].s64 = ctx.r[11].s64 + -16676;
	// 826ED8A8: 48706161  bl 0x82df3a08
	ctx.lr = 0x826ED8AC;
	sub_82DF3A08(ctx, base);
	// 826ED8AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED8B4: 388BBED0  addi r4, r11, -0x4130
	ctx.r[4].s64 = ctx.r[11].s64 + -16688;
	// 826ED8B8: 48706151  bl 0x82df3a08
	ctx.lr = 0x826ED8BC;
	sub_82DF3A08(ctx, base);
	// 826ED8BC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826ED8C0: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826ED8C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ED8C8: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 826ED8CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826ED8D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826ED8D4: 4BEB5B45  bl 0x825a3418
	ctx.lr = 0x826ED8D8;
	sub_825A3418(ctx, base);
	// 826ED8D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ED8DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED8E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ED8E4: 4BEB45F5  bl 0x825a1ed8
	ctx.lr = 0x826ED8E8;
	sub_825A1ED8(ctx, base);
	// 826ED8E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826ED8EC: 48705B3D  bl 0x82df3428
	ctx.lr = 0x826ED8F0;
	sub_82DF3428(ctx, base);
	// 826ED8F0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826ED8F4: 4BBDB3C5  bl 0x822c8cb8
	ctx.lr = 0x826ED8F8;
	sub_822C8CB8(ctx, base);
	// 826ED8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED8FC: 48705B2D  bl 0x82df3428
	ctx.lr = 0x826ED900;
	sub_82DF3428(ctx, base);
	// 826ED900: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED904: 48705B25  bl 0x82df3428
	ctx.lr = 0x826ED908;
	sub_82DF3428(ctx, base);
	// 826ED908: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED910: 388BBEBC  addi r4, r11, -0x4144
	ctx.r[4].s64 = ctx.r[11].s64 + -16708;
	// 826ED914: 487060F5  bl 0x82df3a08
	ctx.lr = 0x826ED918;
	sub_82DF3A08(ctx, base);
	// 826ED918: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED91C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED920: 388BBEAC  addi r4, r11, -0x4154
	ctx.r[4].s64 = ctx.r[11].s64 + -16724;
	// 826ED924: 487060E5  bl 0x82df3a08
	ctx.lr = 0x826ED928;
	sub_82DF3A08(ctx, base);
	// 826ED928: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826ED92C: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826ED930: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ED934: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 826ED938: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ED93C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826ED940: 4BEB5AD9  bl 0x825a3418
	ctx.lr = 0x826ED944;
	sub_825A3418(ctx, base);
	// 826ED944: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ED948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED94C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826ED950: 4BEB4589  bl 0x825a1ed8
	ctx.lr = 0x826ED954;
	sub_825A1ED8(ctx, base);
	// 826ED954: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826ED958: 48705AD1  bl 0x82df3428
	ctx.lr = 0x826ED95C;
	sub_82DF3428(ctx, base);
	// 826ED95C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826ED960: 4BBDB359  bl 0x822c8cb8
	ctx.lr = 0x826ED964;
	sub_822C8CB8(ctx, base);
	// 826ED964: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED968: 48705AC1  bl 0x82df3428
	ctx.lr = 0x826ED96C;
	sub_82DF3428(ctx, base);
	// 826ED96C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED970: 48705AB9  bl 0x82df3428
	ctx.lr = 0x826ED974;
	sub_82DF3428(ctx, base);
	// 826ED974: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED978: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED97C: 388BBE9C  addi r4, r11, -0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + -16740;
	// 826ED980: 48706089  bl 0x82df3a08
	ctx.lr = 0x826ED984;
	sub_82DF3A08(ctx, base);
	// 826ED984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826ED988: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED98C: 388B4858  addi r4, r11, 0x4858
	ctx.r[4].s64 = ctx.r[11].s64 + 18520;
	// 826ED990: 48706079  bl 0x82df3a08
	ctx.lr = 0x826ED994;
	sub_82DF3A08(ctx, base);
	// 826ED994: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826ED998: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 826ED99C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826ED9A0: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 826ED9A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826ED9A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826ED9AC: 4BEB5A6D  bl 0x825a3418
	ctx.lr = 0x826ED9B0;
	sub_825A3418(ctx, base);
	// 826ED9B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826ED9B4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826ED9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826ED9BC: 4BEB451D  bl 0x825a1ed8
	ctx.lr = 0x826ED9C0;
	sub_825A1ED8(ctx, base);
	// 826ED9C0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826ED9C4: 48705A65  bl 0x82df3428
	ctx.lr = 0x826ED9C8;
	sub_82DF3428(ctx, base);
	// 826ED9C8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826ED9CC: 4BBDB2ED  bl 0x822c8cb8
	ctx.lr = 0x826ED9D0;
	sub_822C8CB8(ctx, base);
	// 826ED9D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED9D4: 48705A55  bl 0x82df3428
	ctx.lr = 0x826ED9D8;
	sub_82DF3428(ctx, base);
	// 826ED9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED9DC: 48705A4D  bl 0x82df3428
	ctx.lr = 0x826ED9E0;
	sub_82DF3428(ctx, base);
	// 826ED9E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED9E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826ED9E8: 388BBE8C  addi r4, r11, -0x4174
	ctx.r[4].s64 = ctx.r[11].s64 + -16756;
	// 826ED9EC: 4870601D  bl 0x82df3a08
	ctx.lr = 0x826ED9F0;
	sub_82DF3A08(ctx, base);
	// 826ED9F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826ED9F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826ED9F8: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 826ED9FC: 4870600D  bl 0x82df3a08
	ctx.lr = 0x826EDA00;
	sub_82DF3A08(ctx, base);
	// 826EDA00: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EDA04: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 826EDA08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EDA0C: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 826EDA10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EDA14: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 826EDA18: 4BEB5A01  bl 0x825a3418
	ctx.lr = 0x826EDA1C;
	sub_825A3418(ctx, base);
	// 826EDA1C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EDA20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EDA24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EDA28: 4BEB44B1  bl 0x825a1ed8
	ctx.lr = 0x826EDA2C;
	sub_825A1ED8(ctx, base);
	// 826EDA2C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 826EDA30: 487059F9  bl 0x82df3428
	ctx.lr = 0x826EDA34;
	sub_82DF3428(ctx, base);
	// 826EDA34: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 826EDA38: 4BBDB281  bl 0x822c8cb8
	ctx.lr = 0x826EDA3C;
	sub_822C8CB8(ctx, base);
	// 826EDA3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EDA40: 487059E9  bl 0x82df3428
	ctx.lr = 0x826EDA44;
	sub_82DF3428(ctx, base);
	// 826EDA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EDA48: 487059E1  bl 0x82df3428
	ctx.lr = 0x826EDA4C;
	sub_82DF3428(ctx, base);
	// 826EDA4C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 826EDA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EDA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EDA58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EDA5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EDA60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EDA68 size=156
    let mut pc: u32 = 0x826EDA68;
    'dispatch: loop {
        match pc {
            0x826EDA68 => {
    //   block [0x826EDA68..0x826EDB04)
	// 826EDA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EDA70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EDA74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EDA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EDA7C: 4BFDCB75  bl 0x826ca5f0
	ctx.lr = 0x826EDA80;
	sub_826CA5F0(ctx, base);
	// 826EDA80: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EDA84: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EDA88: 396BBF5C  addi r11, r11, -0x40a4
	ctx.r[11].s64 = ctx.r[11].s64 + -16548;
	// 826EDA8C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EDA90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EDA94: 394ABF48  addi r10, r10, -0x40b8
	ctx.r[10].s64 = ctx.r[10].s64 + -16568;
	// 826EDA98: 3929BEFC  addi r9, r9, -0x4104
	ctx.r[9].s64 = ctx.r[9].s64 + -16644;
	// 826EDA9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EDAA0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826EDAA4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826EDAA8: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 826EDAAC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826EDAB0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 826EDAB4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826EDAB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDABC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826EDAC0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826EDAC4: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826EDAC8: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826EDACC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EDAD0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826EDAD4: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826EDAD8: 997F0110  stb r11, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u8 ) };
	// 826EDADC: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826EDAE0: 915F0118  stw r10, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[10].u32 ) };
	// 826EDAE4: 913F011C  stw r9, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[9].u32 ) };
	// 826EDAE8: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826EDAEC: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826EDAF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EDAF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EDAF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EDAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EDB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EDB08 size=8
    let mut pc: u32 = 0x826EDB08;
    'dispatch: loop {
        match pc {
            0x826EDB08 => {
    //   block [0x826EDB08..0x826EDB10)
	// 826EDB08: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EDB0C: 4800008C  b 0x826edb98
	sub_826EDB98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EDB10 size=8
    let mut pc: u32 = 0x826EDB10;
    'dispatch: loop {
        match pc {
            0x826EDB10 => {
    //   block [0x826EDB10..0x826EDB18)
	// 826EDB10: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EDB14: 48000084  b 0x826edb98
	sub_826EDB98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EDB18 size=124
    let mut pc: u32 = 0x826EDB18;
    'dispatch: loop {
        match pc {
            0x826EDB18 => {
    //   block [0x826EDB18..0x826EDB94)
	// 826EDB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EDB20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EDB24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EDB28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EDB2C: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 826EDB30: 4BDC3771  bl 0x824b12a0
	ctx.lr = 0x826EDB34;
	sub_824B12A0(ctx, base);
	// 826EDB34: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826EDB38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EDB3C: 419A0008  beq cr6, 0x826edb44
	if ctx.cr[6].eq {
	pc = 0x826EDB44; continue 'dispatch;
	}
	// 826EDB40: 4BBD2D51  bl 0x822c0890
	ctx.lr = 0x826EDB44;
	sub_822C0890(ctx, base);
	// 826EDB44: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826EDB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EDB4C: 419A0008  beq cr6, 0x826edb54
	if ctx.cr[6].eq {
	pc = 0x826EDB54; continue 'dispatch;
	}
	// 826EDB50: 4BBD2D41  bl 0x822c0890
	ctx.lr = 0x826EDB54;
	sub_822C0890(ctx, base);
	// 826EDB54: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826EDB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EDB5C: 419A0008  beq cr6, 0x826edb64
	if ctx.cr[6].eq {
	pc = 0x826EDB64; continue 'dispatch;
	}
	// 826EDB60: 4BBD2D31  bl 0x822c0890
	ctx.lr = 0x826EDB64;
	sub_822C0890(ctx, base);
	// 826EDB64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EDB68: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826EDB6C: 409A0008  bne cr6, 0x826edb74
	if !ctx.cr[6].eq {
	pc = 0x826EDB74; continue 'dispatch;
	}
	// 826EDB70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EDB74: 480B9AE5  bl 0x827a7658
	ctx.lr = 0x826EDB78;
	sub_827A7658(ctx, base);
	// 826EDB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDB7C: 4BC617D5  bl 0x8234f350
	ctx.lr = 0x826EDB80;
	sub_8234F350(ctx, base);
	// 826EDB80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EDB84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EDB88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EDB8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EDB90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EDB98 size=76
    let mut pc: u32 = 0x826EDB98;
    'dispatch: loop {
        match pc {
            0x826EDB98 => {
    //   block [0x826EDB98..0x826EDBE4)
	// 826EDB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EDBA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EDBA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EDBA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EDBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EDBB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EDBB4: 4BFFFF65  bl 0x826edb18
	ctx.lr = 0x826EDBB8;
	sub_826EDB18(ctx, base);
	// 826EDBB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EDBBC: 4182000C  beq 0x826edbc8
	if ctx.cr[0].eq {
	pc = 0x826EDBC8; continue 'dispatch;
	}
	// 826EDBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDBC4: 48704815  bl 0x82df23d8
	ctx.lr = 0x826EDBC8;
	sub_82DF23D8(ctx, base);
	// 826EDBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDBCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EDBD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EDBD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EDBD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EDBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EDBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EDBE8 size=220
    let mut pc: u32 = 0x826EDBE8;
    'dispatch: loop {
        match pc {
            0x826EDBE8 => {
    //   block [0x826EDBE8..0x826EDCC4)
	// 826EDBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDBEC: 48ABA57D  bl 0x831a8168
	ctx.lr = 0x826EDBF0;
	sub_831A8130(ctx, base);
	// 826EDBF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EDBF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826EDBF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EDBFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EDC00: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EDC04: 41820038  beq 0x826edc3c
	if ctx.cr[0].eq {
	pc = 0x826EDC3C; continue 'dispatch;
	}
	// 826EDC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDC0C: 48ABBD7D  bl 0x831a9988
	ctx.lr = 0x826EDC10;
	sub_831A9988(ctx, base);
	// 826EDC10: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EDC14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EDC18: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826EDC1C: 48ABA4DD  bl 0x831a80f8
	ctx.lr = 0x826EDC20;
	sub_831A80F8(ctx, base);
	// 826EDC20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EDC24: 41820018  beq 0x826edc3c
	if ctx.cr[0].eq {
	pc = 0x826EDC3C; continue 'dispatch;
	}
	// 826EDC28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDC2C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EDC30: 4BFF8251  bl 0x826e5e80
	ctx.lr = 0x826EDC34;
	sub_826E5E80(ctx, base);
	// 826EDC34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EDC38: 48000084  b 0x826edcbc
	pc = 0x826EDCBC; continue 'dispatch;
	// 826EDC3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EDC40: 419A006C  beq cr6, 0x826edcac
	if ctx.cr[6].eq {
	pc = 0x826EDCAC; continue 'dispatch;
	}
	// 826EDC44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDC48: 48ABBD41  bl 0x831a9988
	ctx.lr = 0x826EDC4C;
	sub_831A9988(ctx, base);
	// 826EDC4C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826EDC50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EDC54: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826EDC58: 48ABA4A1  bl 0x831a80f8
	ctx.lr = 0x826EDC5C;
	sub_831A80F8(ctx, base);
	// 826EDC5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EDC60: 41820014  beq 0x826edc74
	if ctx.cr[0].eq {
	pc = 0x826EDC74; continue 'dispatch;
	}
	// 826EDC64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDC68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EDC6C: 4BFFFB05  bl 0x826ed770
	ctx.lr = 0x826EDC70;
	sub_826ED770(ctx, base);
	// 826EDC70: 4BFFFFC4  b 0x826edc34
	pc = 0x826EDC34; continue 'dispatch;
	// 826EDC74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EDC78: 419A0034  beq cr6, 0x826edcac
	if ctx.cr[6].eq {
	pc = 0x826EDCAC; continue 'dispatch;
	}
	// 826EDC7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDC80: 48ABBD09  bl 0x831a9988
	ctx.lr = 0x826EDC84;
	sub_831A9988(ctx, base);
	// 826EDC84: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EDC88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EDC8C: 386BE758  addi r3, r11, -0x18a8
	ctx.r[3].s64 = ctx.r[11].s64 + -6312;
	// 826EDC90: 48ABA469  bl 0x831a80f8
	ctx.lr = 0x826EDC94;
	sub_831A80F8(ctx, base);
	// 826EDC94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EDC98: 41820014  beq 0x826edcac
	if ctx.cr[0].eq {
	pc = 0x826EDCAC; continue 'dispatch;
	}
	// 826EDC9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDCA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EDCA4: 4BFFF2FD  bl 0x826ecfa0
	ctx.lr = 0x826EDCA8;
	sub_826ECFA0(ctx, base);
	// 826EDCA8: 4BFFFF8C  b 0x826edc34
	pc = 0x826EDC34; continue 'dispatch;
	// 826EDCAC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826EDCB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDCB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EDCB8: 4BE24961  bl 0x82512618
	ctx.lr = 0x826EDCBC;
	sub_82512618(ctx, base);
	// 826EDCBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EDCC0: 48ABA4F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EDCC8 size=424
    let mut pc: u32 = 0x826EDCC8;
    'dispatch: loop {
        match pc {
            0x826EDCC8 => {
    //   block [0x826EDCC8..0x826EDE70)
	// 826EDCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDCCC: 48ABA499  bl 0x831a8164
	ctx.lr = 0x826EDCD0;
	sub_831A8130(ctx, base);
	// 826EDCD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EDCD4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EDCD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826EDCDC: 3BCBBF98  addi r30, r11, -0x4068
	ctx.r[30].s64 = ctx.r[11].s64 + -16488;
	// 826EDCE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826EDCE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EDCE8: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 826EDCEC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826EDCF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EDCF4: 38600128  li r3, 0x128
	ctx.r[3].s64 = 296;
	// 826EDCF8: 487046F1  bl 0x82df23e8
	ctx.lr = 0x826EDCFC;
	sub_82DF23E8(ctx, base);
	// 826EDCFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EDD00: 41820010  beq 0x826edd10
	if ctx.cr[0].eq {
	pc = 0x826EDD10; continue 'dispatch;
	}
	// 826EDD04: 4BFFFD65  bl 0x826eda68
	ctx.lr = 0x826EDD08;
	sub_826EDA68(ctx, base);
	// 826EDD08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EDD0C: 48000008  b 0x826edd14
	pc = 0x826EDD14; continue 'dispatch;
	// 826EDD10: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EDD14: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EDD18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDD1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EDD20: 4BFFF291  bl 0x826ecfb0
	ctx.lr = 0x826EDD24;
	sub_826ECFB0(ctx, base);
	// 826EDD24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EDD28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDD2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EDD30: 4BBD22D1  bl 0x822c0000
	ctx.lr = 0x826EDD34;
	sub_822C0000(ctx, base);
	// 826EDD34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EDD38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EDD3C: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 826EDD40: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826EDD44: 4BBD2695  bl 0x822c03d8
	ctx.lr = 0x826EDD48;
	sub_822C03D8(ctx, base);
	// 826EDD48: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EDD4C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EDD50: 418200B4  beq 0x826ede04
	if ctx.cr[0].eq {
	pc = 0x826EDE04; continue 'dispatch;
	}
	// 826EDD54: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EDD58: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826EDD5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EDD60: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826EDD64: 409A0008  bne cr6, 0x826edd6c
	if !ctx.cr[6].eq {
	pc = 0x826EDD6C; continue 'dispatch;
	}
	// 826EDD68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EDD6C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EDD70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EDD74: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826EDD78: 419A0024  beq cr6, 0x826edd9c
	if ctx.cr[6].eq {
	pc = 0x826EDD9C; continue 'dispatch;
	}
	// 826EDD7C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EDD80: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EDD84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EDD88: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EDD8C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EDD90: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EDD94: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EDD98: 4082FFE8  bne 0x826edd80
	if !ctx.cr[0].eq {
	pc = 0x826EDD80; continue 'dispatch;
	}
	// 826EDD9C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826EDDA0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EDDA4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826EDDA8: 419A0024  beq cr6, 0x826eddcc
	if ctx.cr[6].eq {
	pc = 0x826EDDCC; continue 'dispatch;
	}
	// 826EDDAC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826EDDB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EDDB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EDDB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EDDBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EDDC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EDDC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EDDC8: 4082FFE8  bne 0x826eddb0
	if !ctx.cr[0].eq {
	pc = 0x826EDDB0; continue 'dispatch;
	}
	// 826EDDCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EDDD0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826EDDD4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EDDD8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826EDDDC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EDDE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826EDDE4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EDDE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EDDEC: 480AB145  bl 0x82798f30
	ctx.lr = 0x826EDDF0;
	sub_82798F30(ctx, base);
	// 826EDDF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EDDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EDDF8: 480AD871  bl 0x8279b668
	ctx.lr = 0x826EDDFC;
	sub_8279B668(ctx, base);
	// 826EDDFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EDE00: 48000008  b 0x826ede08
	pc = 0x826EDE08; continue 'dispatch;
	// 826EDE04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EDE08: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826EDE0C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826EDE10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EDE18: 4BEA9E39  bl 0x82597c50
	ctx.lr = 0x826EDE1C;
	sub_82597C50(ctx, base);
	// 826EDE1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EDE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EDE24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EDE28: 4BBD21D9  bl 0x822c0000
	ctx.lr = 0x826EDE2C;
	sub_822C0000(ctx, base);
	// 826EDE2C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EDE30: 41820024  beq 0x826ede54
	if ctx.cr[0].eq {
	pc = 0x826EDE54; continue 'dispatch;
	}
	// 826EDE34: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EDE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EDE3C: 419A0008  beq cr6, 0x826ede44
	if ctx.cr[6].eq {
	pc = 0x826EDE44; continue 'dispatch;
	}
	// 826EDE40: 4BBD2A51  bl 0x822c0890
	ctx.lr = 0x826EDE44;
	sub_822C0890(ctx, base);
	// 826EDE44: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826EDE48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EDE4C: 419A0008  beq cr6, 0x826ede54
	if ctx.cr[6].eq {
	pc = 0x826EDE54; continue 'dispatch;
	}
	// 826EDE50: 4BBD2A41  bl 0x822c0890
	ctx.lr = 0x826EDE54;
	sub_822C0890(ctx, base);
	// 826EDE54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826EDE58: 419A000C  beq cr6, 0x826ede64
	if ctx.cr[6].eq {
	pc = 0x826EDE64; continue 'dispatch;
	}
	// 826EDE5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EDE60: 4BBD2A31  bl 0x822c0890
	ctx.lr = 0x826EDE64;
	sub_822C0890(ctx, base);
	// 826EDE64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826EDE68: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826EDE6C: 48ABA348  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EDE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EDE70 size=960
    let mut pc: u32 = 0x826EDE70;
    'dispatch: loop {
        match pc {
            0x826EDE70 => {
    //   block [0x826EDE70..0x826EE230)
	// 826EDE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EDE74: 48ABA2E5  bl 0x831a8158
	ctx.lr = 0x826EDE78;
	sub_831A8130(ctx, base);
	// 826EDE78: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 826EDE7C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 826EDE80: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EE230 size=8
    let mut pc: u32 = 0x826EE230;
    'dispatch: loop {
        match pc {
            0x826EE230 => {
    //   block [0x826EE230..0x826EE238)
	// 826EE230: 88630190  lbz r3, 0x190(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 826EE234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EE238 size=100
    let mut pc: u32 = 0x826EE238;
    'dispatch: loop {
        match pc {
            0x826EE238 => {
    //   block [0x826EE238..0x826EE29C)
	// 826EE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE23C: 48AB9F31  bl 0x831a816c
	ctx.lr = 0x826EE240;
	sub_831A8130(ctx, base);
	// 826EE240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE248: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EE24C: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826EE250: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826EE254: 419A0040  beq cr6, 0x826ee294
	if ctx.cr[6].eq {
	pc = 0x826EE294; continue 'dispatch;
	}
	// 826EE258: 396B0029  addi r11, r11, 0x29
	ctx.r[11].s64 = ctx.r[11].s64 + 41;
	// 826EE25C: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 826EE260: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826EE264: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826EE268: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 826EE26C: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826EE270: 4BE21F81  bl 0x825101f0
	ctx.lr = 0x826EE274;
	sub_825101F0(ctx, base);
	// 826EE274: 397E0029  addi r11, r30, 0x29
	ctx.r[11].s64 = ctx.r[30].s64 + 41;
	// 826EE278: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826EE27C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826EE280: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826EE284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE288: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 826EE28C: 4BE228CD  bl 0x82510b58
	ctx.lr = 0x826EE290;
	sub_82510B58(ctx, base);
	// 826EE290: 93DF0188  stw r30, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[30].u32 ) };
	// 826EE294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EE298: 48AB9F24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE2A0 size=140
    let mut pc: u32 = 0x826EE2A0;
    'dispatch: loop {
        match pc {
            0x826EE2A0 => {
    //   block [0x826EE2A0..0x826EE32C)
	// 826EE2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE2A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EE2AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EE2B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE2B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE2B8: 48A66349  bl 0x83154600
	ctx.lr = 0x826EE2BC;
	sub_83154600(ctx, base);
	// 826EE2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EE2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE2C4: 4876B4A5  bl 0x82e59768
	ctx.lr = 0x826EE2C8;
	sub_82E59768(ctx, base);
	// 826EE2C8: C01E018C  lfs f0, 0x18c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE2CC: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EE2D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EE2D4: C19E0178  lfs f12, 0x178(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826EE2D8: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 826EE2DC: EC2C037A  fmadds f1, f12, f13, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 826EE2E0: D03E018C  stfs f1, 0x18c(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 826EE2E4: C1AB9524  lfs f13, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EE2E8: C00ADFAC  lfs f0, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE2EC: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826EE2F0: 48ABC521  bl 0x831aa810
	ctx.lr = 0x826EE2F4;
	sub_831AA810(ctx, base);
	// 826EE2F4: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826EE2F8: D03E018C  stfs f1, 0x18c(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 826EE2FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EE300: 83FE0168  lwz r31, 0x168(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 826EE304: 4878E6E5  bl 0x82e7c9e8
	ctx.lr = 0x826EE308;
	sub_82E7C9E8(ctx, base);
	// 826EE308: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EE30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE310: 48724F51  bl 0x82e13260
	ctx.lr = 0x826EE314;
	sub_82E13260(ctx, base);
	// 826EE314: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826EE318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE31C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE320: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EE324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EE328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE330 size=116
    let mut pc: u32 = 0x826EE330;
    'dispatch: loop {
        match pc {
            0x826EE330 => {
    //   block [0x826EE330..0x826EE3A4)
	// 826EE330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE338: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE33C: 48A662C5  bl 0x83154600
	ctx.lr = 0x826EE340;
	sub_83154600(ctx, base);
	// 826EE340: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EE344: C1A3018C  lfs f13, 0x18c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EE348: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EE34C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE350: 394AC04C  addi r10, r10, -0x3fb4
	ctx.r[10].s64 = ctx.r[10].s64 + -16308;
	// 826EE354: C009BBEC  lfs f0, -0x4414(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE358: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EE35C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EE360: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE364: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826EE368: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 826EE36C: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 826EE370: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 826EE374: 41980028  blt cr6, 0x826ee39c
	if ctx.cr[6].lt {
	pc = 0x826EE39C; continue 'dispatch;
	}
	// 826EE378: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826EE37C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826EE380: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826EE384: 4198FFE0  blt cr6, 0x826ee364
	if ctx.cr[6].lt {
	pc = 0x826EE364; continue 'dispatch;
	}
	// 826EE388: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EE38C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EE390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE398: 4E800020  blr
	return;
	// 826EE39C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EE3A0: 4BFFFFEC  b 0x826ee38c
	pc = 0x826EE38C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE3A8 size=116
    let mut pc: u32 = 0x826EE3A8;
    'dispatch: loop {
        match pc {
            0x826EE3A8 => {
    //   block [0x826EE3A8..0x826EE41C)
	// 826EE3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE3B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE3B4: 48A6624D  bl 0x83154600
	ctx.lr = 0x826EE3B8;
	sub_83154600(ctx, base);
	// 826EE3B8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EE3BC: C1A3018C  lfs f13, 0x18c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EE3C0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EE3C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE3C8: 394AC054  addi r10, r10, -0x3fac
	ctx.r[10].s64 = ctx.r[10].s64 + -16300;
	// 826EE3CC: C009BBEC  lfs f0, -0x4414(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE3D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EE3D4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EE3D8: C0099524  lfs f0, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EE3DC: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826EE3E0: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 826EE3E4: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 826EE3E8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 826EE3EC: 41980028  blt cr6, 0x826ee414
	if ctx.cr[6].lt {
	pc = 0x826EE414; continue 'dispatch;
	}
	// 826EE3F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826EE3F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826EE3F8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 826EE3FC: 4198FFE0  blt cr6, 0x826ee3dc
	if ctx.cr[6].lt {
	pc = 0x826EE3DC; continue 'dispatch;
	}
	// 826EE400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EE404: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EE408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE40C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE410: 4E800020  blr
	return;
	// 826EE414: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EE418: 4BFFFFEC  b 0x826ee404
	pc = 0x826EE404; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EE420 size=196
    let mut pc: u32 = 0x826EE420;
    'dispatch: loop {
        match pc {
            0x826EE420 => {
    //   block [0x826EE420..0x826EE4E4)
	// 826EE420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EE42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EE430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EE438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE43C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EE440: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EE444: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE448: 4BBD24F1  bl 0x822c0938
	ctx.lr = 0x826EE44C;
	sub_822C0938(ctx, base);
	// 826EE44C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EE450: 41820028  beq 0x826ee478
	if ctx.cr[0].eq {
	pc = 0x826EE478; continue 'dispatch;
	}
	// 826EE454: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EE458: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EE45C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EE460: 392BC0C0  addi r9, r11, -0x3f40
	ctx.r[9].s64 = ctx.r[11].s64 + -16192;
	// 826EE464: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EE468: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EE46C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EE470: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EE474: 48000008  b 0x826ee47c
	pc = 0x826EE47C; continue 'dispatch;
	// 826EE478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE47C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EE484: 409A0044  bne cr6, 0x826ee4c8
	if !ctx.cr[6].eq {
	pc = 0x826EE4C8; continue 'dispatch;
	}
	// 826EE488: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EE48C: 419A001C  beq cr6, 0x826ee4a8
	if ctx.cr[6].eq {
	pc = 0x826EE4A8; continue 'dispatch;
	}
	// 826EE490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EE494: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EE498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE49C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EE4A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EE4A4: 4E800421  bctrl
	ctx.lr = 0x826EE4A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EE4A8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EE4AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EE4B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EE4B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EE4B8: 816BE794  lwz r11, -0x186c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6252 as u32) ) } as u64;
	// 826EE4BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EE4C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EE4C4: 4BBD1B3D  bl 0x822c0000
	ctx.lr = 0x826EE4C8;
	sub_822C0000(ctx, base);
	// 826EE4C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EE4CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EE4D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE4D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE4D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EE4DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EE4E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EE4E8 size=196
    let mut pc: u32 = 0x826EE4E8;
    'dispatch: loop {
        match pc {
            0x826EE4E8 => {
    //   block [0x826EE4E8..0x826EE5AC)
	// 826EE4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE4EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE4F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EE4F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EE4F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE4FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EE500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE504: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EE508: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EE50C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE510: 4BBD2429  bl 0x822c0938
	ctx.lr = 0x826EE514;
	sub_822C0938(ctx, base);
	// 826EE514: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EE518: 41820028  beq 0x826ee540
	if ctx.cr[0].eq {
	pc = 0x826EE540; continue 'dispatch;
	}
	// 826EE51C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EE520: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EE524: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EE528: 392BC0D4  addi r9, r11, -0x3f2c
	ctx.r[9].s64 = ctx.r[11].s64 + -16172;
	// 826EE52C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EE530: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EE534: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EE538: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EE53C: 48000008  b 0x826ee544
	pc = 0x826EE544; continue 'dispatch;
	// 826EE540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE544: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EE54C: 409A0044  bne cr6, 0x826ee590
	if !ctx.cr[6].eq {
	pc = 0x826EE590; continue 'dispatch;
	}
	// 826EE550: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EE554: 419A001C  beq cr6, 0x826ee570
	if ctx.cr[6].eq {
	pc = 0x826EE570; continue 'dispatch;
	}
	// 826EE558: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EE55C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EE560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE564: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EE568: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EE56C: 4E800421  bctrl
	ctx.lr = 0x826EE570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EE570: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EE574: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EE578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EE57C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EE580: 816BE794  lwz r11, -0x186c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6252 as u32) ) } as u64;
	// 826EE584: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EE588: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EE58C: 4BBD1A75  bl 0x822c0000
	ctx.lr = 0x826EE590;
	sub_822C0000(ctx, base);
	// 826EE590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EE594: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EE598: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE59C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE5A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EE5A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EE5A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE5B0 size=372
    let mut pc: u32 = 0x826EE5B0;
    'dispatch: loop {
        match pc {
            0x826EE5B0 => {
    //   block [0x826EE5B0..0x826EE724)
	// 826EE5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE5B4: 48AB9BB9  bl 0x831a816c
	ctx.lr = 0x826EE5B8;
	sub_831A8130(ctx, base);
	// 826EE5B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE5BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EE5C0: 48A66041  bl 0x83154600
	ctx.lr = 0x826EE5C4;
	sub_83154600(ctx, base);
	// 826EE5C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EE5CC: 4BFFFCD5  bl 0x826ee2a0
	ctx.lr = 0x826EE5D0;
	sub_826EE2A0(ctx, base);
	// 826EE5D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826EE5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EE5D8: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826EE5DC: 897F0190  lbz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826EE5E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EE5E4: 418200CC  beq 0x826ee6b0
	if ctx.cr[0].eq {
	pc = 0x826EE6B0; continue 'dispatch;
	}
	// 826EE5E8: 4BFFFDC1  bl 0x826ee3a8
	ctx.lr = 0x826EE5EC;
	sub_826EE3A8(ctx, base);
	// 826EE5EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EE5F0: 418200F0  beq 0x826ee6e0
	if ctx.cr[0].eq {
	pc = 0x826EE6E0; continue 'dispatch;
	}
	// 826EE5F4: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 826EE5F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EE5FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826EE600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EE604: 4E800421  bctrl
	ctx.lr = 0x826EE608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EE608: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826EE60C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826EE610: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EE614: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826EE618: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 826EE61C: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 826EE620: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EE624: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 826EE628: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 826EE62C: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EE630: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EE634: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE728 size=288
    let mut pc: u32 = 0x826EE728;
    'dispatch: loop {
        match pc {
            0x826EE728 => {
    //   block [0x826EE728..0x826EE848)
	// 826EE728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE72C: 48AB9A39  bl 0x831a8164
	ctx.lr = 0x826EE730;
	sub_831A8130(ctx, base);
	// 826EE730: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 826EE734: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826EE738: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE740: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826EE744: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826EE748: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 826EE74C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826EE750: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 826EE754: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 826EE758: 4BE23BD9  bl 0x82512330
	ctx.lr = 0x826EE75C;
	sub_82512330(ctx, base);
	// 826EE75C: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826EE760: 4876F171  bl 0x82e5d8d0
	ctx.lr = 0x826EE764;
	sub_82E5D8D0(ctx, base);
	// 826EE764: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EE768: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EE76C: 396BC060  addi r11, r11, -0x3fa0
	ctx.r[11].s64 = ctx.r[11].s64 + -16288;
	// 826EE770: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EE774: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826EE778: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826EE77C: 394AC10C  addi r10, r10, -0x3ef4
	ctx.r[10].s64 = ctx.r[10].s64 + -16116;
	// 826EE780: 937F0144  stw r27, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[27].u32 ) };
	// 826EE784: 3929C0F8  addi r9, r9, -0x3f08
	ctx.r[9].s64 = ctx.r[9].s64 + -16136;
	// 826EE788: 3968C0E8  addi r11, r8, -0x3f18
	ctx.r[11].s64 = ctx.r[8].s64 + -16152;
	// 826EE78C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826EE790: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826EE794: 395F0148  addi r10, r31, 0x148
	ctx.r[10].s64 = ctx.r[31].s64 + 328;
	// 826EE798: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826EE79C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826EE7A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EE7A4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE7A8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826EE7AC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826EE7B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826EE7B4: 4080FFF0  bge 0x826ee7a4
	if !ctx.cr[0].lt {
	pc = 0x826EE7A4; continue 'dispatch;
	}
	// 826EE7B8: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 826EE7BC: 395F0160  addi r10, r31, 0x160
	ctx.r[10].s64 = ctx.r[31].s64 + 352;
	// 826EE7C0: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 826EE7C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EE7C8: 915F0160  stw r10, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[10].u32 ) };
	// 826EE7CC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EE7D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826EE7D4: 915F0164  stw r10, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 826EE7D8: 419A0024  beq cr6, 0x826ee7fc
	if ctx.cr[6].eq {
	pc = 0x826EE7FC; continue 'dispatch;
	}
	// 826EE7DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 826EE7E0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826EE7E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EE7E8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826EE7EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826EE7F0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EE7F4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EE7F8: 4082FFE8  bne 0x826ee7e0
	if !ctx.cr[0].eq {
	pc = 0x826EE7E0; continue 'dispatch;
	}
	// 826EE7FC: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 826EE800: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 826EE804: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 826EE808: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 826EE80C: D3DF0178  stfs f30, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 826EE810: D3FF017C  stfs f31, 0x17c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 826EE814: 93BF0180  stw r29, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 826EE818: D3FF018C  stfs f31, 0x18c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 826EE81C: 939F0184  stw r28, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[28].u32 ) };
	// 826EE820: 997F0190  stb r11, 0x190(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 826EE824: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EE828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE82C: 419A0008  beq cr6, 0x826ee834
	if ctx.cr[6].eq {
	pc = 0x826EE834; continue 'dispatch;
	}
	// 826EE830: 4BBD2061  bl 0x822c0890
	ctx.lr = 0x826EE834;
	sub_822C0890(ctx, base);
	// 826EE834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE838: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826EE83C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826EE840: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826EE844: 48AB9970  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EE848 size=8
    let mut pc: u32 = 0x826EE848;
    'dispatch: loop {
        match pc {
            0x826EE848 => {
    //   block [0x826EE848..0x826EE850)
	// 826EE848: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EE84C: 480000AC  b 0x826ee8f8
	sub_826EE8F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EE850 size=8
    let mut pc: u32 = 0x826EE850;
    'dispatch: loop {
        match pc {
            0x826EE850 => {
    //   block [0x826EE850..0x826EE858)
	// 826EE850: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EE854: 480000A4  b 0x826ee8f8
	sub_826EE8F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EE858 size=156
    let mut pc: u32 = 0x826EE858;
    'dispatch: loop {
        match pc {
            0x826EE858 => {
    //   block [0x826EE858..0x826EE8F4)
	// 826EE858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE85C: 48AB9911  bl 0x831a816c
	ctx.lr = 0x826EE860;
	sub_831A8130(ctx, base);
	// 826EE860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE868: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 826EE86C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE870: 419A0008  beq cr6, 0x826ee878
	if ctx.cr[6].eq {
	pc = 0x826EE878; continue 'dispatch;
	}
	// 826EE874: 4BBD201D  bl 0x822c0890
	ctx.lr = 0x826EE878;
	sub_822C0890(ctx, base);
	// 826EE878: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 826EE87C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE880: 419A0008  beq cr6, 0x826ee888
	if ctx.cr[6].eq {
	pc = 0x826EE888; continue 'dispatch;
	}
	// 826EE884: 4BBD200D  bl 0x822c0890
	ctx.lr = 0x826EE888;
	sub_822C0890(ctx, base);
	// 826EE888: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826EE88C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE890: 419A0008  beq cr6, 0x826ee898
	if ctx.cr[6].eq {
	pc = 0x826EE898; continue 'dispatch;
	}
	// 826EE894: 4BBD1FFD  bl 0x822c0890
	ctx.lr = 0x826EE898;
	sub_822C0890(ctx, base);
	// 826EE898: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 826EE89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE8A0: 419A0008  beq cr6, 0x826ee8a8
	if ctx.cr[6].eq {
	pc = 0x826EE8A8; continue 'dispatch;
	}
	// 826EE8A4: 4BBD1FED  bl 0x822c0890
	ctx.lr = 0x826EE8A8;
	sub_822C0890(ctx, base);
	// 826EE8A8: 397F0158  addi r11, r31, 0x158
	ctx.r[11].s64 = ctx.r[31].s64 + 344;
	// 826EE8AC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826EE8B0: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826EE8B4: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826EE8B8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EE8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EE8C0: 419A0008  beq cr6, 0x826ee8c8
	if ctx.cr[6].eq {
	pc = 0x826EE8C8; continue 'dispatch;
	}
	// 826EE8C4: 4BBD1FCD  bl 0x822c0890
	ctx.lr = 0x826EE8C8;
	sub_822C0890(ctx, base);
	// 826EE8C8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EE8CC: 4080FFE8  bge 0x826ee8b4
	if !ctx.cr[0].lt {
	pc = 0x826EE8B4; continue 'dispatch;
	}
	// 826EE8D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EE8D4: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826EE8D8: 409A0008  bne cr6, 0x826ee8e0
	if !ctx.cr[6].eq {
	pc = 0x826EE8E0; continue 'dispatch;
	}
	// 826EE8DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EE8E0: 4876EF69  bl 0x82e5d848
	ctx.lr = 0x826EE8E4;
	sub_82E5D848(ctx, base);
	// 826EE8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE8E8: 4BC60A69  bl 0x8234f350
	ctx.lr = 0x826EE8EC;
	sub_8234F350(ctx, base);
	// 826EE8EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EE8F0: 48AB98CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EE8F8 size=76
    let mut pc: u32 = 0x826EE8F8;
    'dispatch: loop {
        match pc {
            0x826EE8F8 => {
    //   block [0x826EE8F8..0x826EE944)
	// 826EE8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EE904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EE908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE910: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EE914: 4BFFFF45  bl 0x826ee858
	ctx.lr = 0x826EE918;
	sub_826EE858(ctx, base);
	// 826EE918: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EE91C: 4182000C  beq 0x826ee928
	if ctx.cr[0].eq {
	pc = 0x826EE928; continue 'dispatch;
	}
	// 826EE920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE924: 48703AB5  bl 0x82df23d8
	ctx.lr = 0x826EE928;
	sub_82DF23D8(ctx, base);
	// 826EE928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EE92C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EE930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EE934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EE938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EE93C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EE940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EE948 size=400
    let mut pc: u32 = 0x826EE948;
    'dispatch: loop {
        match pc {
            0x826EE948 => {
    //   block [0x826EE948..0x826EEAD8)
	// 826EE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EE94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EE950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EE954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EE958: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EE95C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EE960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EE964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EE968: 388BC160  addi r4, r11, -0x3ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -16032;
	// 826EE96C: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 826EE970: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826EE974: 48703A75  bl 0x82df23e8
	ctx.lr = 0x826EE978;
	sub_82DF23E8(ctx, base);
	// 826EE978: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826EE97C: 4182001C  beq 0x826ee998
	if ctx.cr[0].eq {
	pc = 0x826EE998; continue 'dispatch;
	}
	// 826EE980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EE984: 4876DFA5  bl 0x82e5c928
	ctx.lr = 0x826EE988;
	sub_82E5C928(ctx, base);
	// 826EE988: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EE98C: 396BC098  addi r11, r11, -0x3f68
	ctx.r[11].s64 = ctx.r[11].s64 + -16232;
	// 826EE990: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EE994: 48000008  b 0x826ee99c
	pc = 0x826EE99C; continue 'dispatch;
	// 826EE998: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826EE99C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826EE9A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EE9A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EE9A8: 4BFFFB41  bl 0x826ee4e8
	ctx.lr = 0x826EE9AC;
	sub_826EE4E8(ctx, base);
	// 826EE9AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826EE9B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826EE9B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EE9B8: 4BBD1649  bl 0x822c0000
	ctx.lr = 0x826EE9BC;
	sub_822C0000(ctx, base);
	// 826EE9BC: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EE9C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EE9C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826EE9C8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826EE9CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EE9D0: 419A0024  beq cr6, 0x826ee9f4
	if ctx.cr[6].eq {
	pc = 0x826EE9F4; continue 'dispatch;
	}
	// 826EE9D4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826EE9D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EE9DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EE9E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EE9E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EE9E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EE9EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EE9F0: 4082FFE8  bne 0x826ee9d8
	if !ctx.cr[0].eq {
	pc = 0x826EE9D8; continue 'dispatch;
	}
	// 826EE9F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EE9F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EE9FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEA00: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EEA04: 389F00E4  addi r4, r31, 0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + 228;
	// 826EEA08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EEA0C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EEA10: 4876FC99  bl 0x82e5e6a8
	ctx.lr = 0x826EEA14;
	sub_82E5E6A8(ctx, base);
	// 826EEA14: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EEA18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEA1C: 419A0008  beq cr6, 0x826eea24
	if ctx.cr[6].eq {
	pc = 0x826EEA24; continue 'dispatch;
	}
	// 826EEA20: 4BBD1E71  bl 0x822c0890
	ctx.lr = 0x826EEA24;
	sub_822C0890(ctx, base);
	// 826EEA24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EEA28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEA2C: 419A0008  beq cr6, 0x826eea34
	if ctx.cr[6].eq {
	pc = 0x826EEA34; continue 'dispatch;
	}
	// 826EEA30: 4BBD1E61  bl 0x822c0890
	ctx.lr = 0x826EEA34;
	sub_822C0890(ctx, base);
	// 826EEA34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826EEA38: 419A000C  beq cr6, 0x826eea44
	if ctx.cr[6].eq {
	pc = 0x826EEA44; continue 'dispatch;
	}
	// 826EEA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EEA40: 4BBD1E51  bl 0x822c0890
	ctx.lr = 0x826EEA44;
	sub_822C0890(ctx, base);
	// 826EEA44: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 826EEA48: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826EEA4C: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826EEA50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EEA54: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826EEA58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EEA5C: 4E800421  bctrl
	ctx.lr = 0x826EEA60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EEA60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEA64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EEA68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826EEA6C: 4878D25D  bl 0x82e7bcc8
	ctx.lr = 0x826EEA70;
	sub_82E7BCC8(ctx, base);
	// 826EEA70: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEA74: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826EEA78: 38ABC148  addi r5, r11, -0x3eb8
	ctx.r[5].s64 = ctx.r[11].s64 + -16056;
	// 826EEA7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEA80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826EEA84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EEA88: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 826EEA8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EEA90: 4E800421  bctrl
	ctx.lr = 0x826EEA94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EEA94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EEA98: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 826EEA9C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826EEAA0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826EEAA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EEAA8: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 826EEAAC: 4BBD59B5  bl 0x822c4460
	ctx.lr = 0x826EEAB0;
	sub_822C4460(ctx, base);
	// 826EEAB0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826EEAB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEAB8: 419A0008  beq cr6, 0x826eeac0
	if ctx.cr[6].eq {
	pc = 0x826EEAC0; continue 'dispatch;
	}
	// 826EEABC: 4BBD1DD5  bl 0x822c0890
	ctx.lr = 0x826EEAC0;
	sub_822C0890(ctx, base);
	// 826EEAC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826EEAC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EEAC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EEACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EEAD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EEAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EEAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EEAD8 size=284
    let mut pc: u32 = 0x826EEAD8;
    'dispatch: loop {
        match pc {
            0x826EEAD8 => {
    //   block [0x826EEAD8..0x826EEBF4)
	// 826EEAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EEADC: 48AB9691  bl 0x831a816c
	ctx.lr = 0x826EEAE0;
	sub_831A8130(ctx, base);
	// 826EEAE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EEAE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEAE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EEAEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEAF0: 388BC160  addi r4, r11, -0x3ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -16032;
	// 826EEAF4: 38A000E7  li r5, 0xe7
	ctx.r[5].s64 = 231;
	// 826EEAF8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826EEAFC: 487038ED  bl 0x82df23e8
	ctx.lr = 0x826EEB00;
	sub_82DF23E8(ctx, base);
	// 826EEB00: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EEB04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826EEB08: 4182001C  beq 0x826eeb24
	if ctx.cr[0].eq {
	pc = 0x826EEB24; continue 'dispatch;
	}
	// 826EEB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEB10: 4876DE19  bl 0x82e5c928
	ctx.lr = 0x826EEB14;
	sub_82E5C928(ctx, base);
	// 826EEB14: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEB18: 396BC070  addi r11, r11, -0x3f90
	ctx.r[11].s64 = ctx.r[11].s64 + -16272;
	// 826EEB1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EEB20: 48000008  b 0x826eeb28
	pc = 0x826EEB28; continue 'dispatch;
	// 826EEB24: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 826EEB28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EEB2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEB30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EEB34: 4BFFF8ED  bl 0x826ee420
	ctx.lr = 0x826EEB38;
	sub_826EE420(ctx, base);
	// 826EEB38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EEB3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEB40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EEB44: 4BBD14BD  bl 0x822c0000
	ctx.lr = 0x826EEB48;
	sub_822C0000(ctx, base);
	// 826EEB48: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EEB4C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EEB50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EEB54: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826EEB58: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EEB5C: 419A0024  beq cr6, 0x826eeb80
	if ctx.cr[6].eq {
	pc = 0x826EEB80; continue 'dispatch;
	}
	// 826EEB60: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826EEB64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EEB68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EEB6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EEB70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EEB74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EEB78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EEB7C: 4082FFE8  bne 0x826eeb64
	if !ctx.cr[0].eq {
	pc = 0x826EEB64; continue 'dispatch;
	}
	// 826EEB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EEB84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EEB88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEB8C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EEB90: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 826EEB94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EEB98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EEB9C: 4876FB0D  bl 0x82e5e6a8
	ctx.lr = 0x826EEBA0;
	sub_82E5E6A8(ctx, base);
	// 826EEBA0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EEBA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEBA8: 419A0008  beq cr6, 0x826eebb0
	if ctx.cr[6].eq {
	pc = 0x826EEBB0; continue 'dispatch;
	}
	// 826EEBAC: 4BBD1CE5  bl 0x822c0890
	ctx.lr = 0x826EEBB0;
	sub_822C0890(ctx, base);
	// 826EEBB0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EEBB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEBB8: 419A0008  beq cr6, 0x826eebc0
	if ctx.cr[6].eq {
	pc = 0x826EEBC0; continue 'dispatch;
	}
	// 826EEBBC: 4BBD1CD5  bl 0x822c0890
	ctx.lr = 0x826EEBC0;
	sub_822C0890(ctx, base);
	// 826EEBC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EEBC4: 419A000C  beq cr6, 0x826eebd0
	if ctx.cr[6].eq {
	pc = 0x826EEBD0; continue 'dispatch;
	}
	// 826EEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEBCC: 4BBD1CC5  bl 0x822c0890
	ctx.lr = 0x826EEBD0;
	sub_822C0890(ctx, base);
	// 826EEBD0: 93BE0158  stw r29, 0x158(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(344 as u32), ctx.r[29].u32 ) };
	// 826EEBD4: 397E0158  addi r11, r30, 0x158
	ctx.r[11].s64 = ctx.r[30].s64 + 344;
	// 826EEBD8: 807E015C  lwz r3, 0x15c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 826EEBDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEBE0: 93BE015C  stw r29, 0x15c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(348 as u32), ctx.r[29].u32 ) };
	// 826EEBE4: 419A0008  beq cr6, 0x826eebec
	if ctx.cr[6].eq {
	pc = 0x826EEBEC; continue 'dispatch;
	}
	// 826EEBE8: 4BBD1CA9  bl 0x822c0890
	ctx.lr = 0x826EEBEC;
	sub_822C0890(ctx, base);
	// 826EEBEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826EEBF0: 48AB95CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EEBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EEBF8 size=276
    let mut pc: u32 = 0x826EEBF8;
    'dispatch: loop {
        match pc {
            0x826EEBF8 => {
    //   block [0x826EEBF8..0x826EED0C)
	// 826EEBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EEBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EEC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EEC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EEC08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EEC0C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEC10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EEC14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEC18: 388BC160  addi r4, r11, -0x3ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -16032;
	// 826EEC1C: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 826EEC20: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826EEC24: 487037C5  bl 0x82df23e8
	ctx.lr = 0x826EEC28;
	sub_82DF23E8(ctx, base);
	// 826EEC28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EEC2C: 4182001C  beq 0x826eec48
	if ctx.cr[0].eq {
	pc = 0x826EEC48; continue 'dispatch;
	}
	// 826EEC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEC34: 4876DCF5  bl 0x82e5c928
	ctx.lr = 0x826EEC38;
	sub_82E5C928(ctx, base);
	// 826EEC38: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEC3C: 396BC098  addi r11, r11, -0x3f68
	ctx.r[11].s64 = ctx.r[11].s64 + -16232;
	// 826EEC40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EEC44: 48000008  b 0x826eec4c
	pc = 0x826EEC4C; continue 'dispatch;
	// 826EEC48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EEC4C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EEC50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEC54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EEC58: 4BFFF891  bl 0x826ee4e8
	ctx.lr = 0x826EEC5C;
	sub_826EE4E8(ctx, base);
	// 826EEC5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EEC60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEC64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EEC68: 4BBD1399  bl 0x822c0000
	ctx.lr = 0x826EEC6C;
	sub_822C0000(ctx, base);
	// 826EEC6C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EEC70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EEC74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EEC78: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826EEC7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EEC80: 419A0024  beq cr6, 0x826eeca4
	if ctx.cr[6].eq {
	pc = 0x826EECA4; continue 'dispatch;
	}
	// 826EEC84: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826EEC88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EEC8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EEC90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EEC94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EEC98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EEC9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EECA0: 4082FFE8  bne 0x826eec88
	if !ctx.cr[0].eq {
	pc = 0x826EEC88; continue 'dispatch;
	}
	// 826EECA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EECA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EECAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EECB0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EECB4: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 826EECB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EECBC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EECC0: 4876F9E9  bl 0x82e5e6a8
	ctx.lr = 0x826EECC4;
	sub_82E5E6A8(ctx, base);
	// 826EECC4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EECC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EECCC: 419A0008  beq cr6, 0x826eecd4
	if ctx.cr[6].eq {
	pc = 0x826EECD4; continue 'dispatch;
	}
	// 826EECD0: 4BBD1BC1  bl 0x822c0890
	ctx.lr = 0x826EECD4;
	sub_822C0890(ctx, base);
	// 826EECD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EECD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EECDC: 419A0008  beq cr6, 0x826eece4
	if ctx.cr[6].eq {
	pc = 0x826EECE4; continue 'dispatch;
	}
	// 826EECE0: 4BBD1BB1  bl 0x822c0890
	ctx.lr = 0x826EECE4;
	sub_822C0890(ctx, base);
	// 826EECE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EECE8: 419A000C  beq cr6, 0x826eecf4
	if ctx.cr[6].eq {
	pc = 0x826EECF4; continue 'dispatch;
	}
	// 826EECEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EECF0: 4BBD1BA1  bl 0x822c0890
	ctx.lr = 0x826EECF4;
	sub_822C0890(ctx, base);
	// 826EECF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EECF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EECFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EED00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EED04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EED08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EED10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EED10 size=276
    let mut pc: u32 = 0x826EED10;
    'dispatch: loop {
        match pc {
            0x826EED10 => {
    //   block [0x826EED10..0x826EEE24)
	// 826EED10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EED14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EED18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EED1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EED20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EED24: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EED28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EED2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EED30: 388BC160  addi r4, r11, -0x3ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -16032;
	// 826EED34: 38A00101  li r5, 0x101
	ctx.r[5].s64 = 257;
	// 826EED38: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826EED3C: 487036AD  bl 0x82df23e8
	ctx.lr = 0x826EED40;
	sub_82DF23E8(ctx, base);
	// 826EED40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EED44: 4182001C  beq 0x826eed60
	if ctx.cr[0].eq {
	pc = 0x826EED60; continue 'dispatch;
	}
	// 826EED48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EED4C: 4876DBDD  bl 0x82e5c928
	ctx.lr = 0x826EED50;
	sub_82E5C928(ctx, base);
	// 826EED50: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EED54: 396BC070  addi r11, r11, -0x3f90
	ctx.r[11].s64 = ctx.r[11].s64 + -16272;
	// 826EED58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EED5C: 48000008  b 0x826eed64
	pc = 0x826EED64; continue 'dispatch;
	// 826EED60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826EED64: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EED68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EED6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EED70: 4BFFF6B1  bl 0x826ee420
	ctx.lr = 0x826EED74;
	sub_826EE420(ctx, base);
	// 826EED74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EED78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EED7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EED80: 4BBD1281  bl 0x822c0000
	ctx.lr = 0x826EED84;
	sub_822C0000(ctx, base);
	// 826EED84: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EED88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EED8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EED90: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 826EED94: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EED98: 419A0024  beq cr6, 0x826eedbc
	if ctx.cr[6].eq {
	pc = 0x826EEDBC; continue 'dispatch;
	}
	// 826EED9C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826EEDA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EEDA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EEDA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EEDAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EEDB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EEDB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EEDB8: 4082FFE8  bne 0x826eeda0
	if !ctx.cr[0].eq {
	pc = 0x826EEDA0; continue 'dispatch;
	}
	// 826EEDBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EEDC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EEDC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEDC8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826EEDCC: 389E00E4  addi r4, r30, 0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + 228;
	// 826EEDD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EEDD4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EEDD8: 4876F8D1  bl 0x82e5e6a8
	ctx.lr = 0x826EEDDC;
	sub_82E5E6A8(ctx, base);
	// 826EEDDC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EEDE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEDE4: 419A0008  beq cr6, 0x826eedec
	if ctx.cr[6].eq {
	pc = 0x826EEDEC; continue 'dispatch;
	}
	// 826EEDE8: 4BBD1AA9  bl 0x822c0890
	ctx.lr = 0x826EEDEC;
	sub_822C0890(ctx, base);
	// 826EEDEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EEDF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EEDF4: 419A0008  beq cr6, 0x826eedfc
	if ctx.cr[6].eq {
	pc = 0x826EEDFC; continue 'dispatch;
	}
	// 826EEDF8: 4BBD1A99  bl 0x822c0890
	ctx.lr = 0x826EEDFC;
	sub_822C0890(ctx, base);
	// 826EEDFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EEE00: 419A000C  beq cr6, 0x826eee0c
	if ctx.cr[6].eq {
	pc = 0x826EEE0C; continue 'dispatch;
	}
	// 826EEE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEE08: 4BBD1A89  bl 0x822c0890
	ctx.lr = 0x826EEE0C;
	sub_822C0890(ctx, base);
	// 826EEE0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EEE10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EEE14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EEE18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EEE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EEE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EEE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EEE28 size=164
    let mut pc: u32 = 0x826EEE28;
    'dispatch: loop {
        match pc {
            0x826EEE28 => {
    //   block [0x826EEE28..0x826EEECC)
	// 826EEE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EEE2C: 48AB933D  bl 0x831a8168
	ctx.lr = 0x826EEE30;
	sub_831A8130(ctx, base);
	// 826EEE30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EEE34: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826EEE38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EEE3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EEE40: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826EEE44: 41820038  beq 0x826eee7c
	if ctx.cr[0].eq {
	pc = 0x826EEE7C; continue 'dispatch;
	}
	// 826EEE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEE4C: 48ABAB3D  bl 0x831a9988
	ctx.lr = 0x826EEE50;
	sub_831A9988(ctx, base);
	// 826EEE50: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EEE54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEE58: 386BE9A8  addi r3, r11, -0x1658
	ctx.r[3].s64 = ctx.r[11].s64 + -5720;
	// 826EEE5C: 48AB929D  bl 0x831a80f8
	ctx.lr = 0x826EEE60;
	sub_831A80F8(ctx, base);
	// 826EEE60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EEE64: 41820018  beq 0x826eee7c
	if ctx.cr[0].eq {
	pc = 0x826EEE7C; continue 'dispatch;
	}
	// 826EEE68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEE6C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EEE70: 4BFFFD89  bl 0x826eebf8
	ctx.lr = 0x826EEE74;
	sub_826EEBF8(ctx, base);
	// 826EEE74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826EEE78: 4800004C  b 0x826eeec4
	pc = 0x826EEEC4; continue 'dispatch;
	// 826EEE7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826EEE80: 419A0034  beq cr6, 0x826eeeb4
	if ctx.cr[6].eq {
	pc = 0x826EEEB4; continue 'dispatch;
	}
	// 826EEE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EEE88: 48ABAB01  bl 0x831a9988
	ctx.lr = 0x826EEE8C;
	sub_831A9988(ctx, base);
	// 826EEE8C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EEE90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEE94: 386BE978  addi r3, r11, -0x1688
	ctx.r[3].s64 = ctx.r[11].s64 + -5768;
	// 826EEE98: 48AB9261  bl 0x831a80f8
	ctx.lr = 0x826EEE9C;
	sub_831A80F8(ctx, base);
	// 826EEE9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EEEA0: 41820014  beq 0x826eeeb4
	if ctx.cr[0].eq {
	pc = 0x826EEEB4; continue 'dispatch;
	}
	// 826EEEA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEEA8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826EEEAC: 4BFFFE65  bl 0x826eed10
	ctx.lr = 0x826EEEB0;
	sub_826EED10(ctx, base);
	// 826EEEB0: 4BFFFFC4  b 0x826eee74
	pc = 0x826EEE74; continue 'dispatch;
	// 826EEEB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826EEEB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEEBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EEEC0: 4BE23759  bl 0x82512618
	ctx.lr = 0x826EEEC4;
	sub_82512618(ctx, base);
	// 826EEEC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826EEEC8: 48AB92F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EEED0 size=836
    let mut pc: u32 = 0x826EEED0;
    'dispatch: loop {
        match pc {
            0x826EEED0 => {
    //   block [0x826EEED0..0x826EF214)
	// 826EEED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EEED4: 48AB9281  bl 0x831a8154
	ctx.lr = 0x826EEED8;
	sub_831A8130(ctx, base);
	// 826EEED8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 826EEEDC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EEEE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EEEE4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826EEEE8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826EEEEC: 4BE22AED  bl 0x825119d8
	ctx.lr = 0x826EEEF0;
	sub_825119D8(ctx, base);
	// 826EEEF0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 826EEEF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EEEF8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826EEEFC: 409A0008  bne cr6, 0x826eef04
	if !ctx.cr[6].eq {
	pc = 0x826EEF04; continue 'dispatch;
	}
	// 826EEF00: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826EEF04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EEF08: 4BE19899  bl 0x825087a0
	ctx.lr = 0x826EEF0C;
	sub_825087A0(ctx, base);
	// 826EEF0C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 826EEF10: 3AFF00E4  addi r23, r31, 0xe4
	ctx.r[23].s64 = ctx.r[31].s64 + 228;
	// 826EEF14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EEF18: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826EEF1C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826EEF20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EEF24: 4E800421  bctrl
	ctx.lr = 0x826EEF28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EEF28: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEF2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEF30: 3B0BC160  addi r24, r11, -0x3ea0
	ctx.r[24].s64 = ctx.r[11].s64 + -16032;
	// 826EEF34: 38A000B3  li r5, 0xb3
	ctx.r[5].s64 = 179;
	// 826EEF38: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826EEF3C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826EEF40: 487034A9  bl 0x82df23e8
	ctx.lr = 0x826EEF44;
	sub_82DF23E8(ctx, base);
	// 826EEF44: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826EEF48: 41820024  beq 0x826eef6c
	if ctx.cr[0].eq {
	pc = 0x826EEF6C; continue 'dispatch;
	}
	// 826EEF4C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826EEF50: C03F018C  lfs f1, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EEF54: 4878DA95  bl 0x82e7c9e8
	ctx.lr = 0x826EEF58;
	sub_82E7C9E8(ctx, base);
	// 826EEF58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EEF60: 48724191  bl 0x82e130f0
	ctx.lr = 0x826EEF64;
	sub_82E130F0(ctx, base);
	// 826EEF64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEF68: 48000008  b 0x826eef70
	pc = 0x826EEF70; continue 'dispatch;
	// 826EEF6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826EEF70: 3BDF0168  addi r30, r31, 0x168
	ctx.r[30].s64 = ctx.r[31].s64 + 360;
	// 826EEF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EEF78: 4BBF2DD9  bl 0x822e1d50
	ctx.lr = 0x826EEF7C;
	sub_822E1D50(ctx, base);
	// 826EEF7C: 809F0168  lwz r4, 0x168(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 826EEF80: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 826EEF84: 48723EAD  bl 0x82e12e30
	ctx.lr = 0x826EEF88;
	sub_82E12E30(ctx, base);
	// 826EEF88: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826EEF8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EEF90: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 826EEF94: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826EEF98: 48703451  bl 0x82df23e8
	ctx.lr = 0x826EEF9C;
	sub_82DF23E8(ctx, base);
	// 826EEF9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EEFA0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EEFA4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826EEFA8: 41820030  beq 0x826eefd8
	if ctx.cr[0].eq {
	pc = 0x826EEFD8; continue 'dispatch;
	}
	// 826EEFAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EEFB0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826EEFB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826EEFB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EEFBC: C06BC048  lfs f3, -0x3fb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16312 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826EEFC0: 4878D059  bl 0x82e7c018
	ctx.lr = 0x826EEFC4;
	sub_82E7C018(ctx, base);
	// 826EEFC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EEFCC: 48724125  bl 0x82e130f0
	ctx.lr = 0x826EEFD0;
	sub_82E130F0(ctx, base);
	// 826EEFD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EEFD4: 48000008  b 0x826eefdc
	pc = 0x826EEFDC; continue 'dispatch;
	// 826EEFD8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826EEFDC: 3BBF0170  addi r29, r31, 0x170
	ctx.r[29].s64 = ctx.r[31].s64 + 368;
	// 826EEFE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EEFE4: 4BBF2D6D  bl 0x822e1d50
	ctx.lr = 0x826EEFE8;
	sub_822E1D50(ctx, base);
	// 826EEFE8: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 826EEFEC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EEFF0: 48723E41  bl 0x82e12e30
	ctx.lr = 0x826EEFF4;
	sub_82E12E30(ctx, base);
	// 826EEFF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EEFF8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EEFFC: 4873BAED  bl 0x82e2aae8
	ctx.lr = 0x826EF000;
	sub_82E2AAE8(ctx, base);
	// 826EF000: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EF004: 3B9F0148  addi r28, r31, 0x148
	ctx.r[28].s64 = ctx.r[31].s64 + 328;
	// 826EF008: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 826EF00C: 3B6BE78C  addi r27, r11, -0x1874
	ctx.r[27].s64 = ctx.r[11].s64 + -6260;
	// 826EF010: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 826EF014: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 826EF018: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 826EF01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF020: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF024: 487049E5  bl 0x82df3a08
	ctx.lr = 0x826EF028;
	sub_82DF3A08(ctx, base);
	// 826EF028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EF02C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826EF030: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826EF034: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826EF038: 4873FE39  bl 0x82e2ee70
	ctx.lr = 0x826EF03C;
	sub_82E2EE70(ctx, base);
	// 826EF03C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EF040: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826EF044: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826EF048: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF04C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826EF050: 4BBD5411  bl 0x822c4460
	ctx.lr = 0x826EF054;
	sub_822C4460(ctx, base);
	// 826EF054: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826EF058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF05C: 419A0008  beq cr6, 0x826ef064
	if ctx.cr[6].eq {
	pc = 0x826EF064; continue 'dispatch;
	}
	// 826EF060: 4BBD1831  bl 0x822c0890
	ctx.lr = 0x826EF064;
	sub_822C0890(ctx, base);
	// 826EF064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF068: 487043C1  bl 0x82df3428
	ctx.lr = 0x826EF06C;
	sub_82DF3428(ctx, base);
	// 826EF06C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826EF070: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EF074: 38A000C1  li r5, 0xc1
	ctx.r[5].s64 = 193;
	// 826EF078: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826EF07C: 4870336D  bl 0x82df23e8
	ctx.lr = 0x826EF080;
	sub_82DF23E8(ctx, base);
	// 826EF080: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EF084: 41820014  beq 0x826ef098
	if ctx.cr[0].eq {
	pc = 0x826EF098; continue 'dispatch;
	}
	// 826EF088: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826EF08C: 48727805  bl 0x82e16890
	ctx.lr = 0x826EF090;
	sub_82E16890(ctx, base);
	// 826EF090: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EF094: 48000008  b 0x826ef09c
	pc = 0x826EF09C; continue 'dispatch;
	// 826EF098: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826EF09C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EF0A0: 4BC6E2D1  bl 0x8235d370
	ctx.lr = 0x826EF0A4;
	sub_8235D370(ctx, base);
	// 826EF0A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826EF0A8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EF0B0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 826EF0B4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 826EF0B8: 419A0024  beq cr6, 0x826ef0dc
	if ctx.cr[6].eq {
	pc = 0x826EF0DC; continue 'dispatch;
	}
	// 826EF0BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826EF0C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EF0C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EF0C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EF0CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EF0D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EF0D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EF0D8: 4082FFE8  bne 0x826ef0c0
	if !ctx.cr[0].eq {
	pc = 0x826EF0C0; continue 'dispatch;
	}
	// 826EF0DC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826EF0E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF0E4: 48725FCD  bl 0x82e150b0
	ctx.lr = 0x826EF0E8;
	sub_82E150B0(ctx, base);
	// 826EF0E8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 826EF0EC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 826EF0F0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 826EF0F4: 4082FF28  bne 0x826ef01c
	if !ctx.cr[0].eq {
	pc = 0x826EF01C; continue 'dispatch;
	}
	// 826EF0F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826EF0FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826EF100: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826EF104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF108: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826EF10C: 4BE21A4D  bl 0x82510b58
	ctx.lr = 0x826EF110;
	sub_82510B58(ctx, base);
	// 826EF110: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826EF114: 933F0188  stw r25, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[25].u32 ) };
	// 826EF118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF11C: 419A0008  beq cr6, 0x826ef124
	if ctx.cr[6].eq {
	pc = 0x826EF124; continue 'dispatch;
	}
	// 826EF120: 4BBD1771  bl 0x822c0890
	ctx.lr = 0x826EF124;
	sub_822C0890(ctx, base);
	// 826EF124: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EF128: 4873B9D9  bl 0x82e2ab00
	ctx.lr = 0x826EF12C;
	sub_82E2AB00(ctx, base);
	// 826EF12C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826EF130: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EF134: 38A000CB  li r5, 0xcb
	ctx.r[5].s64 = 203;
	// 826EF138: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826EF13C: 487032AD  bl 0x82df23e8
	ctx.lr = 0x826EF140;
	sub_82DF23E8(ctx, base);
	// 826EF140: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826EF144: 4182001C  beq 0x826ef160
	if ctx.cr[0].eq {
	pc = 0x826EF160; continue 'dispatch;
	}
	// 826EF148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF14C: 4876D7DD  bl 0x82e5c928
	ctx.lr = 0x826EF150;
	sub_82E5C928(ctx, base);
	// 826EF150: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EF154: 396BC070  addi r11, r11, -0x3f90
	ctx.r[11].s64 = ctx.r[11].s64 + -16272;
	// 826EF158: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF15C: 48000008  b 0x826ef164
	pc = 0x826EF164; continue 'dispatch;
	// 826EF160: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 826EF164: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826EF168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EF16C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF170: 4BFFF2B1  bl 0x826ee420
	ctx.lr = 0x826EF174;
	sub_826EE420(ctx, base);
	// 826EF174: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826EF178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EF17C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF180: 4BBD0E81  bl 0x822c0000
	ctx.lr = 0x826EF184;
	sub_822C0000(ctx, base);
	// 826EF184: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EF188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826EF18C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EF190: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826EF194: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826EF198: 419A0024  beq cr6, 0x826ef1bc
	if ctx.cr[6].eq {
	pc = 0x826EF1BC; continue 'dispatch;
	}
	// 826EF19C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826EF1A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826EF1A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EF1A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826EF1AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826EF1B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826EF1B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826EF1B8: 4082FFE8  bne 0x826ef1a0
	if !ctx.cr[0].eq {
	pc = 0x826EF1A0; continue 'dispatch;
	}
	// 826EF1BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826EF1C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EF1C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EF1C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826EF1CC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826EF1D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826EF1D4: 4876F4D5  bl 0x82e5e6a8
	ctx.lr = 0x826EF1D8;
	sub_82E5E6A8(ctx, base);
	// 826EF1D8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826EF1DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF1E0: 419A0008  beq cr6, 0x826ef1e8
	if ctx.cr[6].eq {
	pc = 0x826EF1E8; continue 'dispatch;
	}
	// 826EF1E4: 4BBD16AD  bl 0x822c0890
	ctx.lr = 0x826EF1E8;
	sub_822C0890(ctx, base);
	// 826EF1E8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826EF1EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF1F0: 419A0008  beq cr6, 0x826ef1f8
	if ctx.cr[6].eq {
	pc = 0x826EF1F8; continue 'dispatch;
	}
	// 826EF1F4: 4BBD169D  bl 0x822c0890
	ctx.lr = 0x826EF1F8;
	sub_822C0890(ctx, base);
	// 826EF1F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EF1FC: 419A000C  beq cr6, 0x826ef208
	if ctx.cr[6].eq {
	pc = 0x826EF208; continue 'dispatch;
	}
	// 826EF200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF204: 4BBD168D  bl 0x822c0890
	ctx.lr = 0x826EF208;
	sub_822C0890(ctx, base);
	// 826EF208: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 826EF20C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 826EF210: 48AB8F94  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF218 size=20
    let mut pc: u32 = 0x826EF218;
    'dispatch: loop {
        match pc {
            0x826EF218 => {
    //   block [0x826EF218..0x826EF22C)
	// 826EF218: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826EF21C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826EF220: 419A0014  beq cr6, 0x826ef234
	if ctx.cr[6].eq {
		sub_826EF234(ctx, base);
		return;
	}
	// 826EF224: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826EF228: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF22C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF22C size=8
    let mut pc: u32 = 0x826EF22C;
    'dispatch: loop {
        match pc {
            0x826EF22C => {
    //   block [0x826EF22C..0x826EF234)
	// 826EF22C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EF230: 48000008  b 0x826ef238
	sub_826EF234(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF234(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF234 size=12
    let mut pc: u32 = 0x826EF234;
    'dispatch: loop {
        match pc {
            0x826EF234 => {
    //   block [0x826EF234..0x826EF240)
	// 826EF234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826EF238: 99630171  stb r11, 0x171(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(369 as u32), ctx.r[11].u8 ) };
	// 826EF23C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF240 size=12
    let mut pc: u32 = 0x826EF240;
    'dispatch: loop {
        match pc {
            0x826EF240 => {
    //   block [0x826EF240..0x826EF24C)
	// 826EF240: 80630104  lwz r3, 0x104(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(260 as u32) ) } as u64;
	// 826EF244: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF248: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF24C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF24C size=8
    let mut pc: u32 = 0x826EF24C;
    'dispatch: loop {
        match pc {
            0x826EF24C => {
    //   block [0x826EF24C..0x826EF254)
	// 826EF24C: 4BF9A70C  b 0x82689958
	sub_82689958(ctx, base);
	return;
	// 826EF250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EF258 size=120
    let mut pc: u32 = 0x826EF258;
    'dispatch: loop {
        match pc {
            0x826EF258 => {
    //   block [0x826EF258..0x826EF2D0)
	// 826EF258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF264: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF26C: 897F0171  lbz r11, 0x171(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(369 as u32) ) } as u64;
	// 826EF270: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EF274: 4082000C  bne 0x826ef280
	if !ctx.cr[0].eq {
	pc = 0x826EF280; continue 'dispatch;
	}
	// 826EF278: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EF27C: 48000040  b 0x826ef2bc
	pc = 0x826EF2BC; continue 'dispatch;
	// 826EF280: C01F017C  lfs f0, 0x17c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EF284: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826EF288: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EF28C: EC40682A  fadds f2, f0, f13
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826EF290: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EF294: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826EF298: 4099FFE0  ble cr6, 0x826ef278
	if !ctx.cr[6].gt {
	pc = 0x826EF278; continue 'dispatch;
	}
	// 826EF29C: 48ABB575  bl 0x831aa810
	ctx.lr = 0x826EF2A0;
	sub_831AA810(ctx, base);
	// 826EF2A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826EF2A4: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EF2A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826EF2AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826EF2B0: 41980008  blt cr6, 0x826ef2b8
	if ctx.cr[6].lt {
	pc = 0x826EF2B8; continue 'dispatch;
	}
	// 826EF2B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EF2B8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826EF2BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826EF2C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EF2C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EF2C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EF2CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EF2D0 size=196
    let mut pc: u32 = 0x826EF2D0;
    'dispatch: loop {
        match pc {
            0x826EF2D0 => {
    //   block [0x826EF2D0..0x826EF394)
	// 826EF2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EF2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF2E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EF2E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EF2EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826EF2F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EF2F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF2F8: 4BBD1641  bl 0x822c0938
	ctx.lr = 0x826EF2FC;
	sub_822C0938(ctx, base);
	// 826EF2FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826EF300: 41820028  beq 0x826ef328
	if ctx.cr[0].eq {
	pc = 0x826EF328; continue 'dispatch;
	}
	// 826EF304: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EF308: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826EF30C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826EF310: 392BC1F4  addi r9, r11, -0x3e0c
	ctx.r[9].s64 = ctx.r[11].s64 + -15884;
	// 826EF314: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826EF318: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EF31C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826EF320: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826EF324: 48000008  b 0x826ef32c
	pc = 0x826EF32C; continue 'dispatch;
	// 826EF328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EF32C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EF334: 409A0044  bne cr6, 0x826ef378
	if !ctx.cr[6].eq {
	pc = 0x826EF378; continue 'dispatch;
	}
	// 826EF338: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EF33C: 419A001C  beq cr6, 0x826ef358
	if ctx.cr[6].eq {
	pc = 0x826EF358; continue 'dispatch;
	}
	// 826EF340: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF344: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EF348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF34C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EF354: 4E800421  bctrl
	ctx.lr = 0x826EF358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EF358: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EF35C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EF360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF364: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826EF368: 816BE9F0  lwz r11, -0x1610(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5648 as u32) ) } as u64;
	// 826EF36C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826EF370: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826EF374: 4BBD0C8D  bl 0x822c0000
	ctx.lr = 0x826EF378;
	sub_822C0000(ctx, base);
	// 826EF378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EF37C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EF380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EF384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EF388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EF38C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EF390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EF398 size=172
    let mut pc: u32 = 0x826EF398;
    'dispatch: loop {
        match pc {
            0x826EF398 => {
    //   block [0x826EF398..0x826EF444)
	// 826EF398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF39C: 48AB8DD1  bl 0x831a816c
	ctx.lr = 0x826EF3A0;
	sub_831A8130(ctx, base);
	// 826EF3A0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826EF3A4: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF3A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF3AC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826EF3B0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826EF3B4: 83DF0128  lwz r30, 0x128(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 826EF3B8: C02BDFAC  lfs f1, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EF3BC: 4878D62D  bl 0x82e7c9e8
	ctx.lr = 0x826EF3C0;
	sub_82E7C9E8(ctx, base);
	// 826EF3C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EF3C4: C1BF0174  lfs f13, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EF3C8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826EF3CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826EF3D0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826EF3D4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826EF3D8: C00A9530  lfs f0, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EF3DC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826EF3E0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826EF3E4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EF3E8: 4878CC31  bl 0x82e7c018
	ctx.lr = 0x826EF3EC;
	sub_82E7C018(ctx, base);
	// 826EF3EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EF3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF3F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826EF3F8: 4BBD5509  bl 0x822c4900
	ctx.lr = 0x826EF3FC;
	sub_822C4900(ctx, base);
	// 826EF3FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EF400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EF404: 48723E5D  bl 0x82e13260
	ctx.lr = 0x826EF408;
	sub_82E13260(ctx, base);
	// 826EF408: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EF40C: C1BF0174  lfs f13, 0x174(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EF410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF414: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826EF418: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826EF41C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EF420: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EF424: 83FF0130  lwz r31, 0x130(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 826EF428: 4878CBF1  bl 0x82e7c018
	ctx.lr = 0x826EF42C;
	sub_82E7C018(ctx, base);
	// 826EF42C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EF430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF434: 48723E2D  bl 0x82e13260
	ctx.lr = 0x826EF438;
	sub_82E13260(ctx, base);
	// 826EF438: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826EF43C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826EF440: 48AB8D7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EF448 size=360
    let mut pc: u32 = 0x826EF448;
    'dispatch: loop {
        match pc {
            0x826EF448 => {
    //   block [0x826EF448..0x826EF5B0)
	// 826EF448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EF454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF458: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826EF45C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF460: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826EF464: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826EF468: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826EF46C: 4BE2292D  bl 0x82511d98
	ctx.lr = 0x826EF470;
	sub_82511D98(ctx, base);
	// 826EF470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EF474: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826EF478: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 826EF47C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826EF480: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EF484: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826EF488: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EF48C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826EF490: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826EF494: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826EF498: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826EF49C: 4878C8AD  bl 0x82e7bd48
	ctx.lr = 0x826EF4A0;
	sub_82E7BD48(ctx, base);
	// 826EF4A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EF4A4: 4BE22645  bl 0x82511ae8
	ctx.lr = 0x826EF4A8;
	sub_82511AE8(ctx, base);
	// 826EF4A8: 39600140  li r11, 0x140
	ctx.r[11].s64 = 320;
	// 826EF4AC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EF4B0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826EF4B4: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826EF4B8: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EF5B0 size=196
    let mut pc: u32 = 0x826EF5B0;
    'dispatch: loop {
        match pc {
            0x826EF5B0 => {
    //   block [0x826EF5B0..0x826EF674)
	// 826EF5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF5B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF5BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF5C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF5C4: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EF5C8: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826EF5CC: 4182005C  beq 0x826ef628
	if ctx.cr[0].eq {
	pc = 0x826EF628; continue 'dispatch;
	}
	// 826EF5D0: 4BF9A329  bl 0x826898f8
	ctx.lr = 0x826EF5D4;
	sub_826898F8(ctx, base);
	// 826EF5D4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826EF5D8: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826EF5DC: 808B674C  lwz r4, 0x674c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826EF5E0: 4BD9FDC1  bl 0x8248f3a0
	ctx.lr = 0x826EF5E4;
	sub_8248F3A0(ctx, base);
	// 826EF5E4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826EF5E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EF5EC: 38AB2AD4  addi r5, r11, 0x2ad4
	ctx.r[5].s64 = ctx.r[11].s64 + 10964;
	// 826EF5F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF5F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF5F8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826EF5FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EF600: 4E800421  bctrl
	ctx.lr = 0x826EF604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EF604: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826EF608: 395F010C  addi r10, r31, 0x10c
	ctx.r[10].s64 = ctx.r[31].s64 + 268;
	// 826EF60C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826EF610: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826EF614: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF618: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826EF61C: 4BBD4E45  bl 0x822c4460
	ctx.lr = 0x826EF620;
	sub_822C4460(ctx, base);
	// 826EF620: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826EF624: 48000030  b 0x826ef654
	pc = 0x826EF654; continue 'dispatch;
	// 826EF628: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826EF62C: 4BF9A23D  bl 0x82689868
	ctx.lr = 0x826EF630;
	sub_82689868(ctx, base);
	// 826EF630: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826EF634: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826EF638: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 826EF63C: 4BD9FD65  bl 0x8248f3a0
	ctx.lr = 0x826EF640;
	sub_8248F3A0(ctx, base);
	// 826EF640: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826EF644: 397F010C  addi r11, r31, 0x10c
	ctx.r[11].s64 = ctx.r[31].s64 + 268;
	// 826EF648: 915F010C  stw r10, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[10].u32 ) };
	// 826EF64C: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826EF650: 915F0110  stw r10, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	// 826EF654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF658: 419A0008  beq cr6, 0x826ef660
	if ctx.cr[6].eq {
	pc = 0x826EF660; continue 'dispatch;
	}
	// 826EF65C: 4BBD1235  bl 0x822c0890
	ctx.lr = 0x826EF660;
	sub_822C0890(ctx, base);
	// 826EF660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EF664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EF668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EF66C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EF670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EF678 size=328
    let mut pc: u32 = 0x826EF678;
    'dispatch: loop {
        match pc {
            0x826EF678 => {
    //   block [0x826EF678..0x826EF7C0)
	// 826EF678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF67C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EF684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF688: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826EF68C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826EF690: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826EF694: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF69C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EF6A0: 419A00FC  beq cr6, 0x826ef79c
	if ctx.cr[6].eq {
	pc = 0x826EF79C; continue 'dispatch;
	}
	// 826EF6A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EF6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF6AC: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826EF6B0: 48704359  bl 0x82df3a08
	ctx.lr = 0x826EF6B4;
	sub_82DF3A08(ctx, base);
	// 826EF6B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EF6B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF6BC: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826EF6C0: 48704349  bl 0x82df3a08
	ctx.lr = 0x826EF6C4;
	sub_82DF3A08(ctx, base);
	// 826EF6C4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826EF6C8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826EF6CC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826EF6D0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826EF6D4: 3BCBE9DC  addi r30, r11, -0x1624
	ctx.r[30].s64 = ctx.r[11].s64 + -5668;
	// 826EF6D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EF6DC: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826EF6E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826EF6E4: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826EF6E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EF6EC: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826EF6F0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826EF6F4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826EF6F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826EF6FC: 4BEB3BAD  bl 0x825a32a8
	ctx.lr = 0x826EF700;
	sub_825A32A8(ctx, base);
	// 826EF700: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EF704: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EF708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF70C: 4BEB2065  bl 0x825a1770
	ctx.lr = 0x826EF710;
	sub_825A1770(ctx, base);
	// 826EF710: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826EF714: 48703D15  bl 0x82df3428
	ctx.lr = 0x826EF718;
	sub_82DF3428(ctx, base);
	// 826EF718: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826EF71C: 4BBD959D  bl 0x822c8cb8
	ctx.lr = 0x826EF720;
	sub_822C8CB8(ctx, base);
	// 826EF720: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF724: 48703D05  bl 0x82df3428
	ctx.lr = 0x826EF728;
	sub_82DF3428(ctx, base);
	// 826EF728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF72C: 48703CFD  bl 0x82df3428
	ctx.lr = 0x826EF730;
	sub_82DF3428(ctx, base);
	// 826EF730: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EF734: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF738: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 826EF73C: 487042CD  bl 0x82df3a08
	ctx.lr = 0x826EF740;
	sub_82DF3A08(ctx, base);
	// 826EF740: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EF744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF748: 388BAB0C  addi r4, r11, -0x54f4
	ctx.r[4].s64 = ctx.r[11].s64 + -21748;
	// 826EF74C: 487042BD  bl 0x82df3a08
	ctx.lr = 0x826EF750;
	sub_82DF3A08(ctx, base);
	// 826EF750: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 826EF754: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EF758: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826EF75C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826EF760: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826EF764: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826EF768: 4BEB3B41  bl 0x825a32a8
	ctx.lr = 0x826EF76C;
	sub_825A32A8(ctx, base);
	// 826EF76C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EF770: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EF774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF778: 4BEB1FF9  bl 0x825a1770
	ctx.lr = 0x826EF77C;
	sub_825A1770(ctx, base);
	// 826EF77C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826EF780: 48703CA9  bl 0x82df3428
	ctx.lr = 0x826EF784;
	sub_82DF3428(ctx, base);
	// 826EF784: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826EF788: 4BBD9531  bl 0x822c8cb8
	ctx.lr = 0x826EF78C;
	sub_822C8CB8(ctx, base);
	// 826EF78C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EF790: 48703C99  bl 0x82df3428
	ctx.lr = 0x826EF794;
	sub_82DF3428(ctx, base);
	// 826EF794: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EF798: 48703C91  bl 0x82df3428
	ctx.lr = 0x826EF79C;
	sub_82DF3428(ctx, base);
	// 826EF79C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826EF7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EF7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EF7A8: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826EF7AC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826EF7B0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826EF7B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EF7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EF7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EF7C0 size=324
    let mut pc: u32 = 0x826EF7C0;
    'dispatch: loop {
        match pc {
            0x826EF7C0 => {
    //   block [0x826EF7C0..0x826EF904)
	// 826EF7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EF7C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EF7CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EF7D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF7D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF7D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EF7DC: 4BFDAE15  bl 0x826ca5f0
	ctx.lr = 0x826EF7E0;
	sub_826CA5F0(ctx, base);
	// 826EF7E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826EF7E4: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 826EF7E8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826EF7EC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826EF7F0: 396BC26C  addi r11, r11, -0x3d94
	ctx.r[11].s64 = ctx.r[11].s64 + -15764;
	// 826EF7F4: 394AC258  addi r10, r10, -0x3da8
	ctx.r[10].s64 = ctx.r[10].s64 + -15784;
	// 826EF7F8: 3929C20C  addi r9, r9, -0x3df4
	ctx.r[9].s64 = ctx.r[9].s64 + -15860;
	// 826EF7FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF800: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EF804: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826EF808: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826EF80C: 395F00EC  addi r10, r31, 0xec
	ctx.r[10].s64 = ctx.r[31].s64 + 236;
	// 826EF810: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 826EF814: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826EF818: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF81C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826EF820: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826EF824: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826EF828: 4080FFF0  bge 0x826ef818
	if !ctx.cr[0].lt {
	pc = 0x826EF818; continue 'dispatch;
	}
	// 826EF82C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826EF830: 395F0128  addi r10, r31, 0x128
	ctx.r[10].s64 = ctx.r[31].s64 + 296;
	// 826EF834: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826EF838: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 826EF83C: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826EF840: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826EF844: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826EF848: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826EF84C: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826EF850: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826EF854: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 826EF858: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826EF85C: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826EF860: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826EF864: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826EF868: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826EF86C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826EF870: 4080FFF0  bge 0x826ef860
	if !ctx.cr[0].lt {
	pc = 0x826EF860; continue 'dispatch;
	}
	// 826EF874: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826EF878: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 826EF87C: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 826EF880: 39200140  li r9, 0x140
	ctx.r[9].s64 = 320;
	// 826EF884: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 826EF888: 38E00150  li r7, 0x150
	ctx.r[7].s64 = 336;
	// 826EF88C: 38C00160  li r6, 0x160
	ctx.r[6].s64 = 352;
	// 826EF890: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 826EF894: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 826EF898: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EF89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF908 size=8
    let mut pc: u32 = 0x826EF908;
    'dispatch: loop {
        match pc {
            0x826EF908 => {
    //   block [0x826EF908..0x826EF910)
	// 826EF908: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826EF90C: 480000F4  b 0x826efa00
	sub_826EFA00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826EF910 size=8
    let mut pc: u32 = 0x826EF910;
    'dispatch: loop {
        match pc {
            0x826EF910 => {
    //   block [0x826EF910..0x826EF918)
	// 826EF910: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826EF914: 480000EC  b 0x826efa00
	sub_826EFA00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EF918 size=228
    let mut pc: u32 = 0x826EF918;
    'dispatch: loop {
        match pc {
            0x826EF918 => {
    //   block [0x826EF918..0x826EF9FC)
	// 826EF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EF91C: 48AB8851  bl 0x831a816c
	ctx.lr = 0x826EF920;
	sub_831A8130(ctx, base);
	// 826EF920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EF924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EF928: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 826EF92C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF930: 419A0008  beq cr6, 0x826ef938
	if ctx.cr[6].eq {
	pc = 0x826EF938; continue 'dispatch;
	}
	// 826EF934: 4BBD0F5D  bl 0x822c0890
	ctx.lr = 0x826EF938;
	sub_822C0890(ctx, base);
	// 826EF938: 397F0138  addi r11, r31, 0x138
	ctx.r[11].s64 = ctx.r[31].s64 + 312;
	// 826EF93C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826EF940: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826EF944: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826EF948: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF950: 419A0008  beq cr6, 0x826ef958
	if ctx.cr[6].eq {
	pc = 0x826EF958; continue 'dispatch;
	}
	// 826EF954: 4BBD0F3D  bl 0x822c0890
	ctx.lr = 0x826EF958;
	sub_822C0890(ctx, base);
	// 826EF958: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EF95C: 4080FFE8  bge 0x826ef944
	if !ctx.cr[0].lt {
	pc = 0x826EF944; continue 'dispatch;
	}
	// 826EF960: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826EF964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF968: 419A0008  beq cr6, 0x826ef970
	if ctx.cr[6].eq {
	pc = 0x826EF970; continue 'dispatch;
	}
	// 826EF96C: 4BBD0F25  bl 0x822c0890
	ctx.lr = 0x826EF970;
	sub_822C0890(ctx, base);
	// 826EF970: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826EF974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF978: 419A0008  beq cr6, 0x826ef980
	if ctx.cr[6].eq {
	pc = 0x826EF980; continue 'dispatch;
	}
	// 826EF97C: 4BBD0F15  bl 0x822c0890
	ctx.lr = 0x826EF980;
	sub_822C0890(ctx, base);
	// 826EF980: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826EF984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF988: 419A0008  beq cr6, 0x826ef990
	if ctx.cr[6].eq {
	pc = 0x826EF990; continue 'dispatch;
	}
	// 826EF98C: 4BBD0F05  bl 0x822c0890
	ctx.lr = 0x826EF990;
	sub_822C0890(ctx, base);
	// 826EF990: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826EF994: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF998: 419A0008  beq cr6, 0x826ef9a0
	if ctx.cr[6].eq {
	pc = 0x826EF9A0; continue 'dispatch;
	}
	// 826EF99C: 4BBD0EF5  bl 0x822c0890
	ctx.lr = 0x826EF9A0;
	sub_822C0890(ctx, base);
	// 826EF9A0: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826EF9A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF9A8: 419A0008  beq cr6, 0x826ef9b0
	if ctx.cr[6].eq {
	pc = 0x826EF9B0; continue 'dispatch;
	}
	// 826EF9AC: 4BBD0EE5  bl 0x822c0890
	ctx.lr = 0x826EF9B0;
	sub_822C0890(ctx, base);
	// 826EF9B0: 397F00FC  addi r11, r31, 0xfc
	ctx.r[11].s64 = ctx.r[31].s64 + 252;
	// 826EF9B4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826EF9B8: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826EF9BC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826EF9C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EF9C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826EF9C8: 419A0008  beq cr6, 0x826ef9d0
	if ctx.cr[6].eq {
	pc = 0x826EF9D0; continue 'dispatch;
	}
	// 826EF9CC: 4BBD0EC5  bl 0x822c0890
	ctx.lr = 0x826EF9D0;
	sub_822C0890(ctx, base);
	// 826EF9D0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826EF9D4: 4080FFE8  bge 0x826ef9bc
	if !ctx.cr[0].lt {
	pc = 0x826EF9BC; continue 'dispatch;
	}
	// 826EF9D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826EF9DC: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826EF9E0: 409A0008  bne cr6, 0x826ef9e8
	if !ctx.cr[6].eq {
	pc = 0x826EF9E8; continue 'dispatch;
	}
	// 826EF9E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EF9E8: 480B7C71  bl 0x827a7658
	ctx.lr = 0x826EF9EC;
	sub_827A7658(ctx, base);
	// 826EF9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EF9F0: 4BC5F961  bl 0x8234f350
	ctx.lr = 0x826EF9F4;
	sub_8234F350(ctx, base);
	// 826EF9F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EF9F8: 48AB87C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EFA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826EFA00 size=76
    let mut pc: u32 = 0x826EFA00;
    'dispatch: loop {
        match pc {
            0x826EFA00 => {
    //   block [0x826EFA00..0x826EFA4C)
	// 826EFA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EFA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EFA08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EFA0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EFA10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EFA14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EFA18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EFA1C: 4BFFFEFD  bl 0x826ef918
	ctx.lr = 0x826EFA20;
	sub_826EF918(ctx, base);
	// 826EFA20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826EFA24: 4182000C  beq 0x826efa30
	if ctx.cr[0].eq {
	pc = 0x826EFA30; continue 'dispatch;
	}
	// 826EFA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EFA2C: 487029AD  bl 0x82df23d8
	ctx.lr = 0x826EFA30;
	sub_82DF23D8(ctx, base);
	// 826EFA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EFA34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826EFA38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EFA3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EFA40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EFA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EFA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EFA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EFA50 size=1192
    let mut pc: u32 = 0x826EFA50;
    'dispatch: loop {
        match pc {
            0x826EFA50 => {
    //   block [0x826EFA50..0x826EFEF8)
	// 826EFA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EFA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826EFA58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826EFA5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826EFA60: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 826EFA64: 48AB900D  bl 0x831a8a70
	ctx.lr = 0x826EFA68;
	sub_831A8A40(ctx, base);
	// 826EFA68: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EFA6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EFA74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EFA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFA7C: 388B5688  addi r4, r11, 0x5688
	ctx.r[4].s64 = ctx.r[11].s64 + 22152;
	// 826EFA80: 48703F89  bl 0x82df3a08
	ctx.lr = 0x826EFA84;
	sub_82DF3A08(ctx, base);
	// 826EFA84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFA88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFA8C: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 826EFA90: 48703F79  bl 0x82df3a08
	ctx.lr = 0x826EFA94;
	sub_82DF3A08(ctx, base);
	// 826EFA94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826EFA98: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826EFA9C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826EFAA0: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 826EFAA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFAA8: C38B08A8  lfs f28, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826EFAAC: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826EFAB0: C36ADD6C  lfs f27, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 826EFAB4: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 826EFAB8: C3C9964C  lfs f30, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826EFABC: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 826EFAC0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826EFAC4: 4BEB37E5  bl 0x825a32a8
	ctx.lr = 0x826EFAC8;
	sub_825A32A8(ctx, base);
	// 826EFAC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFAD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFAD4: 4BEB1C9D  bl 0x825a1770
	ctx.lr = 0x826EFAD8;
	sub_825A1770(ctx, base);
	// 826EFAD8: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826EFADC: 4870394D  bl 0x82df3428
	ctx.lr = 0x826EFAE0;
	sub_82DF3428(ctx, base);
	// 826EFAE0: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826EFAE4: 4BBD91D5  bl 0x822c8cb8
	ctx.lr = 0x826EFAE8;
	sub_822C8CB8(ctx, base);
	// 826EFAE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFAEC: 4870393D  bl 0x82df3428
	ctx.lr = 0x826EFAF0;
	sub_82DF3428(ctx, base);
	// 826EFAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFAF4: 48703935  bl 0x82df3428
	ctx.lr = 0x826EFAF8;
	sub_82DF3428(ctx, base);
	// 826EFAF8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFAFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFB00: 388BD300  addi r4, r11, -0x2d00
	ctx.r[4].s64 = ctx.r[11].s64 + -11520;
	// 826EFB04: 48703F05  bl 0x82df3a08
	ctx.lr = 0x826EFB08;
	sub_82DF3A08(ctx, base);
	// 826EFB08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFB10: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 826EFB14: 48703EF5  bl 0x82df3a08
	ctx.lr = 0x826EFB18;
	sub_82DF3A08(ctx, base);
	// 826EFB18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EFB1C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826EFB20: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EFB24: 38BF0094  addi r5, r31, 0x94
	ctx.r[5].s64 = ctx.r[31].s64 + 148;
	// 826EFB28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFB2C: C34B9528  lfs f26, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 826EFB30: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 826EFB34: C3AA6218  lfs f29, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826EFB38: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 826EFB3C: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826EFB40: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826EFB44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFB48: 4BEB3761  bl 0x825a32a8
	ctx.lr = 0x826EFB4C;
	sub_825A32A8(ctx, base);
	// 826EFB4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFB54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFB58: 4BEB1C19  bl 0x825a1770
	ctx.lr = 0x826EFB5C;
	sub_825A1770(ctx, base);
	// 826EFB5C: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 826EFB60: 487038C9  bl 0x82df3428
	ctx.lr = 0x826EFB64;
	sub_82DF3428(ctx, base);
	// 826EFB64: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 826EFB68: 4BBD9151  bl 0x822c8cb8
	ctx.lr = 0x826EFB6C;
	sub_822C8CB8(ctx, base);
	// 826EFB6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFB70: 487038B9  bl 0x82df3428
	ctx.lr = 0x826EFB74;
	sub_82DF3428(ctx, base);
	// 826EFB74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFB78: 487038B1  bl 0x82df3428
	ctx.lr = 0x826EFB7C;
	sub_82DF3428(ctx, base);
	// 826EFB7C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFB84: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 826EFB88: 48703E81  bl 0x82df3a08
	ctx.lr = 0x826EFB8C;
	sub_82DF3A08(ctx, base);
	// 826EFB8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFB90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFB94: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 826EFB98: 48703E71  bl 0x82df3a08
	ctx.lr = 0x826EFB9C;
	sub_82DF3A08(ctx, base);
	// 826EFB9C: 38BF0098  addi r5, r31, 0x98
	ctx.r[5].s64 = ctx.r[31].s64 + 152;
	// 826EFBA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFBA4: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 826EFBA8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826EFBAC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826EFBB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFBB4: 4BEB36F5  bl 0x825a32a8
	ctx.lr = 0x826EFBB8;
	sub_825A32A8(ctx, base);
	// 826EFBB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFBBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFBC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFBC4: 4BEB1BAD  bl 0x825a1770
	ctx.lr = 0x826EFBC8;
	sub_825A1770(ctx, base);
	// 826EFBC8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826EFBCC: 4870385D  bl 0x82df3428
	ctx.lr = 0x826EFBD0;
	sub_82DF3428(ctx, base);
	// 826EFBD0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826EFBD4: 4BBD90E5  bl 0x822c8cb8
	ctx.lr = 0x826EFBD8;
	sub_822C8CB8(ctx, base);
	// 826EFBD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFBDC: 4870384D  bl 0x82df3428
	ctx.lr = 0x826EFBE0;
	sub_82DF3428(ctx, base);
	// 826EFBE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFBE4: 48703845  bl 0x82df3428
	ctx.lr = 0x826EFBE8;
	sub_82DF3428(ctx, base);
	// 826EFBE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFBEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFBF0: 388B4164  addi r4, r11, 0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + 16740;
	// 826EFBF4: 48703E15  bl 0x82df3a08
	ctx.lr = 0x826EFBF8;
	sub_82DF3A08(ctx, base);
	// 826EFBF8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFBFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFC00: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826EFC04: 48703E05  bl 0x82df3a08
	ctx.lr = 0x826EFC08;
	sub_82DF3A08(ctx, base);
	// 826EFC08: 38BF009C  addi r5, r31, 0x9c
	ctx.r[5].s64 = ctx.r[31].s64 + 156;
	// 826EFC0C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFC10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EFC14: 4BEB343D  bl 0x825a3050
	ctx.lr = 0x826EFC18;
	sub_825A3050(ctx, base);
	// 826EFC18: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFC24: 4BEB2565  bl 0x825a2188
	ctx.lr = 0x826EFC28;
	sub_825A2188(ctx, base);
	// 826EFC28: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826EFC2C: 487037FD  bl 0x82df3428
	ctx.lr = 0x826EFC30;
	sub_82DF3428(ctx, base);
	// 826EFC30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826EFC34: 4BBD9085  bl 0x822c8cb8
	ctx.lr = 0x826EFC38;
	sub_822C8CB8(ctx, base);
	// 826EFC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFC3C: 487037ED  bl 0x82df3428
	ctx.lr = 0x826EFC40;
	sub_82DF3428(ctx, base);
	// 826EFC40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFC44: 487037E5  bl 0x82df3428
	ctx.lr = 0x826EFC48;
	sub_82DF3428(ctx, base);
	// 826EFC48: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFC4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFC50: 388BC4D4  addi r4, r11, -0x3b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -15148;
	// 826EFC54: 48703DB5  bl 0x82df3a08
	ctx.lr = 0x826EFC58;
	sub_82DF3A08(ctx, base);
	// 826EFC58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFC5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFC60: 388B1310  addi r4, r11, 0x1310
	ctx.r[4].s64 = ctx.r[11].s64 + 4880;
	// 826EFC64: 48703DA5  bl 0x82df3a08
	ctx.lr = 0x826EFC68;
	sub_82DF3A08(ctx, base);
	// 826EFC68: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 826EFC6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFC70: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826EFC74: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 826EFC78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFC7C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 826EFC80: 4BEB3629  bl 0x825a32a8
	ctx.lr = 0x826EFC84;
	sub_825A32A8(ctx, base);
	// 826EFC84: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFC88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFC90: 4BEB1AE1  bl 0x825a1770
	ctx.lr = 0x826EFC94;
	sub_825A1770(ctx, base);
	// 826EFC94: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 826EFC98: 48703791  bl 0x82df3428
	ctx.lr = 0x826EFC9C;
	sub_82DF3428(ctx, base);
	// 826EFC9C: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 826EFCA0: 4BBD9019  bl 0x822c8cb8
	ctx.lr = 0x826EFCA4;
	sub_822C8CB8(ctx, base);
	// 826EFCA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFCA8: 48703781  bl 0x82df3428
	ctx.lr = 0x826EFCAC;
	sub_82DF3428(ctx, base);
	// 826EFCAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFCB0: 48703779  bl 0x82df3428
	ctx.lr = 0x826EFCB4;
	sub_82DF3428(ctx, base);
	// 826EFCB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFCB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFCBC: 388BD2E0  addi r4, r11, -0x2d20
	ctx.r[4].s64 = ctx.r[11].s64 + -11552;
	// 826EFCC0: 48703D49  bl 0x82df3a08
	ctx.lr = 0x826EFCC4;
	sub_82DF3A08(ctx, base);
	// 826EFCC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFCCC: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826EFCD0: 48703D39  bl 0x82df3a08
	ctx.lr = 0x826EFCD4;
	sub_82DF3A08(ctx, base);
	// 826EFCD4: 38BF00A4  addi r5, r31, 0xa4
	ctx.r[5].s64 = ctx.r[31].s64 + 164;
	// 826EFCD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFCDC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826EFCE0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826EFCE4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826EFCE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFCEC: 4BEB35BD  bl 0x825a32a8
	ctx.lr = 0x826EFCF0;
	sub_825A32A8(ctx, base);
	// 826EFCF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFCF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFCF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFCFC: 4BEB1A75  bl 0x825a1770
	ctx.lr = 0x826EFD00;
	sub_825A1770(ctx, base);
	// 826EFD00: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826EFD04: 48703725  bl 0x82df3428
	ctx.lr = 0x826EFD08;
	sub_82DF3428(ctx, base);
	// 826EFD08: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826EFD0C: 4BBD8FAD  bl 0x822c8cb8
	ctx.lr = 0x826EFD10;
	sub_822C8CB8(ctx, base);
	// 826EFD10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFD14: 48703715  bl 0x82df3428
	ctx.lr = 0x826EFD18;
	sub_82DF3428(ctx, base);
	// 826EFD18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFD1C: 4870370D  bl 0x82df3428
	ctx.lr = 0x826EFD20;
	sub_82DF3428(ctx, base);
	// 826EFD20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFD24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFD28: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826EFD2C: 48703CDD  bl 0x82df3a08
	ctx.lr = 0x826EFD30;
	sub_82DF3A08(ctx, base);
	// 826EFD30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFD34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFD38: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826EFD3C: 48703CCD  bl 0x82df3a08
	ctx.lr = 0x826EFD40;
	sub_82DF3A08(ctx, base);
	// 826EFD40: 38BF00A8  addi r5, r31, 0xa8
	ctx.r[5].s64 = ctx.r[31].s64 + 168;
	// 826EFD44: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFD48: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826EFD4C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826EFD50: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826EFD54: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFD58: 4BEB3551  bl 0x825a32a8
	ctx.lr = 0x826EFD5C;
	sub_825A32A8(ctx, base);
	// 826EFD5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFD60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFD64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFD68: 4BEB1A09  bl 0x825a1770
	ctx.lr = 0x826EFD6C;
	sub_825A1770(ctx, base);
	// 826EFD6C: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826EFD70: 487036B9  bl 0x82df3428
	ctx.lr = 0x826EFD74;
	sub_82DF3428(ctx, base);
	// 826EFD74: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826EFD78: 4BBD8F41  bl 0x822c8cb8
	ctx.lr = 0x826EFD7C;
	sub_822C8CB8(ctx, base);
	// 826EFD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFD80: 487036A9  bl 0x82df3428
	ctx.lr = 0x826EFD84;
	sub_82DF3428(ctx, base);
	// 826EFD84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFD88: 487036A1  bl 0x82df3428
	ctx.lr = 0x826EFD8C;
	sub_82DF3428(ctx, base);
	// 826EFD8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826EFD90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFD94: 388BFD18  addi r4, r11, -0x2e8
	ctx.r[4].s64 = ctx.r[11].s64 + -744;
	// 826EFD98: 48703C71  bl 0x82df3a08
	ctx.lr = 0x826EFD9C;
	sub_82DF3A08(ctx, base);
	// 826EFD9C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFDA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFDA4: 388BD2D0  addi r4, r11, -0x2d30
	ctx.r[4].s64 = ctx.r[11].s64 + -11568;
	// 826EFDA8: 48703C61  bl 0x82df3a08
	ctx.lr = 0x826EFDAC;
	sub_82DF3A08(ctx, base);
	// 826EFDAC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826EFDB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826EFDB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826EFDB8: 38BF00AC  addi r5, r31, 0xac
	ctx.r[5].s64 = ctx.r[31].s64 + 172;
	// 826EFDBC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFDC0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 826EFDC4: 4BEB3655  bl 0x825a3418
	ctx.lr = 0x826EFDC8;
	sub_825A3418(ctx, base);
	// 826EFDC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFDCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFDD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFDD4: 4BEB2105  bl 0x825a1ed8
	ctx.lr = 0x826EFDD8;
	sub_825A1ED8(ctx, base);
	// 826EFDD8: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 826EFDDC: 4870364D  bl 0x82df3428
	ctx.lr = 0x826EFDE0;
	sub_82DF3428(ctx, base);
	// 826EFDE0: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 826EFDE4: 4BBD8ED5  bl 0x822c8cb8
	ctx.lr = 0x826EFDE8;
	sub_822C8CB8(ctx, base);
	// 826EFDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFDEC: 4870363D  bl 0x82df3428
	ctx.lr = 0x826EFDF0;
	sub_82DF3428(ctx, base);
	// 826EFDF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFDF4: 48703635  bl 0x82df3428
	ctx.lr = 0x826EFDF8;
	sub_82DF3428(ctx, base);
	// 826EFDF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EFDFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFE00: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 826EFE04: 48703C05  bl 0x82df3a08
	ctx.lr = 0x826EFE08;
	sub_82DF3A08(ctx, base);
	// 826EFE08: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFE0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFE10: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 826EFE14: 48703BF5  bl 0x82df3a08
	ctx.lr = 0x826EFE18;
	sub_82DF3A08(ctx, base);
	// 826EFE18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EFE1C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826EFE20: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 826EFE24: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 826EFE28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFE2C: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 826EFE30: C04BE0B4  lfs f2, -0x1f4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826EFE34: C02A8404  lfs f1, -0x7bfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31740 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826EFE38: 4BEB3471  bl 0x825a32a8
	ctx.lr = 0x826EFE3C;
	sub_825A32A8(ctx, base);
	// 826EFE3C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFE40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFE44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFE48: 4BEB1929  bl 0x825a1770
	ctx.lr = 0x826EFE4C;
	sub_825A1770(ctx, base);
	// 826EFE4C: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 826EFE50: 487035D9  bl 0x82df3428
	ctx.lr = 0x826EFE54;
	sub_82DF3428(ctx, base);
	// 826EFE54: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 826EFE58: 4BBD8E61  bl 0x822c8cb8
	ctx.lr = 0x826EFE5C;
	sub_822C8CB8(ctx, base);
	// 826EFE5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFE60: 487035C9  bl 0x82df3428
	ctx.lr = 0x826EFE64;
	sub_82DF3428(ctx, base);
	// 826EFE64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFE68: 487035C1  bl 0x82df3428
	ctx.lr = 0x826EFE6C;
	sub_82DF3428(ctx, base);
	// 826EFE6C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFE70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFE74: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 826EFE78: 48703B91  bl 0x82df3a08
	ctx.lr = 0x826EFE7C;
	sub_82DF3A08(ctx, base);
	// 826EFE7C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826EFE80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFE84: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 826EFE88: 48703B81  bl 0x82df3a08
	ctx.lr = 0x826EFE8C;
	sub_82DF3A08(ctx, base);
	// 826EFE8C: 38BF00B4  addi r5, r31, 0xb4
	ctx.r[5].s64 = ctx.r[31].s64 + 180;
	// 826EFE90: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826EFE94: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826EFE98: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 826EFE9C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826EFEA0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFEA4: 4BEB3405  bl 0x825a32a8
	ctx.lr = 0x826EFEA8;
	sub_825A32A8(ctx, base);
	// 826EFEA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826EFEAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826EFEB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826EFEB4: 4BEB18BD  bl 0x825a1770
	ctx.lr = 0x826EFEB8;
	sub_825A1770(ctx, base);
	// 826EFEB8: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 826EFEBC: 4870356D  bl 0x82df3428
	ctx.lr = 0x826EFEC0;
	sub_82DF3428(ctx, base);
	// 826EFEC0: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 826EFEC4: 4BBD8DF5  bl 0x822c8cb8
	ctx.lr = 0x826EFEC8;
	sub_822C8CB8(ctx, base);
	// 826EFEC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826EFECC: 4870355D  bl 0x82df3428
	ctx.lr = 0x826EFED0;
	sub_82DF3428(ctx, base);
	// 826EFED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826EFED4: 48703555  bl 0x82df3428
	ctx.lr = 0x826EFED8;
	sub_82DF3428(ctx, base);
	// 826EFED8: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 826EFEDC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 826EFEE0: 48AB8BDD  bl 0x831a8abc
	ctx.lr = 0x826EFEE4;
	sub_831A8A8C(ctx, base);
	// 826EFEE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826EFEE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826EFEEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826EFEF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826EFEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826EFEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826EFEF8 size=348
    let mut pc: u32 = 0x826EFEF8;
    'dispatch: loop {
        match pc {
            0x826EFEF8 => {
    //   block [0x826EFEF8..0x826F0054)
	// 826EFEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826EFEFC: 48AB8271  bl 0x831a816c
	ctx.lr = 0x826EFF00;
	sub_831A8130(ctx, base);
	// 826EFF00: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826EFF04: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826EFF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826EFF0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826EFF10: 4BE207F9  bl 0x82510708
	ctx.lr = 0x826EFF14;
	sub_82510708(ctx, base);
	// 826EFF14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826EFF18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826EFF1C: 4BE1F5AD  bl 0x8250f4c8
	ctx.lr = 0x826EFF20;
	sub_8250F4C8(ctx, base);
	// 826EFF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EFF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826EFF28: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826EFF2C: 409A0008  bne cr6, 0x826eff34
	if !ctx.cr[6].eq {
	pc = 0x826EFF34; continue 'dispatch;
	}
	// 826EFF30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826EFF34: 4BE185E5  bl 0x82508518
	ctx.lr = 0x826EFF38;
	sub_82508518(ctx, base);
	// 826EFF38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826EFF3C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826EFF40: 48701D51  bl 0x82df1c90
	ctx.lr = 0x826EFF44;
	sub_82DF1C90(ctx, base);
	// 826EFF44: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EFF48: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826EFF4C: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 826EFF50: 4BFDB929  bl 0x826cb878
	ctx.lr = 0x826EFF54;
	sub_826CB878(ctx, base);
	// 826EFF54: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826EFF58: 4BFDB929  bl 0x826cb880
	ctx.lr = 0x826EFF5C;
	sub_826CB880(ctx, base);
	// 826EFF5C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826EFF60: 809F0138  lwz r4, 0x138(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826EFF64: 83BF0118  lwz r29, 0x118(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826EFF68: 4BFDB989  bl 0x826cb8f0
	ctx.lr = 0x826EFF6C;
	sub_826CB8F0(ctx, base);
	// 826EFF6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EFF70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826EFF74: 487232ED  bl 0x82e13260
	ctx.lr = 0x826EFF78;
	sub_82E13260(ctx, base);
	// 826EFF78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826EFF7C: C1BF0198  lfs f13, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EFF80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826EFF84: C19F0194  lfs f12, 0x194(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826EFF88: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 826EFF8C: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826EFF90: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EFF94: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826EFF98: 4878CAB1  bl 0x82e7ca48
	ctx.lr = 0x826EFF9C;
	sub_82E7CA48(ctx, base);
	// 826EFF9C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826EFFA0: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 826EFFA4: 487232BD  bl 0x82e13260
	ctx.lr = 0x826EFFA8;
	sub_82E13260(ctx, base);
	// 826EFFA8: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826EFFAC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826EFFB0: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826EFFB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826EFFB8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826EFFBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826EFFC0: 4E800421  bctrl
	ctx.lr = 0x826EFFC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826EFFC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826EFFC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826EFFCC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826EFFD0: 4878BCF9  bl 0x82e7bcc8
	ctx.lr = 0x826EFFD4;
	sub_82E7BCC8(ctx, base);
	// 826EFFD4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826EFFD8: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 826EFFDC: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826EFFE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826EFFE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826EFFE8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826EFFEC: 38E00160  li r7, 0x160
	ctx.r[7].s64 = 352;
	// 826EFFF0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826EFFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826EFFF8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0058 size=236
    let mut pc: u32 = 0x826F0058;
    'dispatch: loop {
        match pc {
            0x826F0058 => {
    //   block [0x826F0058..0x826F0144)
	// 826F0058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F005C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826F0064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F006C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0070: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826F0074: 397F0140  addi r11, r31, 0x140
	ctx.r[11].s64 = ctx.r[31].s64 + 320;
	// 826F0078: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826F007C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826F0080: 4BC2D151  bl 0x8231d1d0
	ctx.lr = 0x826F0084;
	sub_8231D1D0(ctx, base);
	// 826F0084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F0088: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826F008C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826F0090: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826F0094: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826F0098: 419A0024  beq cr6, 0x826f00bc
	if ctx.cr[6].eq {
	pc = 0x826F00BC; continue 'dispatch;
	}
	// 826F009C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826F00A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826F00A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F00A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826F00AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826F00B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826F00B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F00B8: 4082FFE8  bne 0x826f00a0
	if !ctx.cr[0].eq {
	pc = 0x826F00A0; continue 'dispatch;
	}
	// 826F00BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F00C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F00C4: 4BE1F405  bl 0x8250f4c8
	ctx.lr = 0x826F00C8;
	sub_8250F4C8(ctx, base);
	// 826F00C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F00CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826F00D0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826F00D4: 409A0008  bne cr6, 0x826f00dc
	if !ctx.cr[6].eq {
	pc = 0x826F00DC; continue 'dispatch;
	}
	// 826F00D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826F00DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826F00E0: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 826F00E4: 4BE18935  bl 0x82508a18
	ctx.lr = 0x826F00E8;
	sub_82508A18(ctx, base);
	// 826F00E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F00EC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826F00F0: 388BC2A8  addi r4, r11, -0x3d58
	ctx.r[4].s64 = ctx.r[11].s64 + -15704;
	// 826F00F4: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 826F00F8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826F00FC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826F0100: 48766EE9  bl 0x82e56fe8
	ctx.lr = 0x826F0104;
	sub_82E56FE8(ctx, base);
	// 826F0104: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F0108: 48701B89  bl 0x82df1c90
	ctx.lr = 0x826F010C;
	sub_82DF1C90(ctx, base);
	// 826F010C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826F0110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F0114: 419A0008  beq cr6, 0x826f011c
	if ctx.cr[6].eq {
	pc = 0x826F011C; continue 'dispatch;
	}
	// 826F0118: 4BBD0779  bl 0x822c0890
	ctx.lr = 0x826F011C;
	sub_822C0890(ctx, base);
	// 826F011C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826F0120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F0124: 419A0008  beq cr6, 0x826f012c
	if ctx.cr[6].eq {
	pc = 0x826F012C; continue 'dispatch;
	}
	// 826F0128: 4BBD0769  bl 0x822c0890
	ctx.lr = 0x826F012C;
	sub_822C0890(ctx, base);
	// 826F012C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826F0130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F0134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F0138: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826F013C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F0140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F0148 size=188
    let mut pc: u32 = 0x826F0148;
    'dispatch: loop {
        match pc {
            0x826F0148 => {
    //   block [0x826F0148..0x826F0204)
	// 826F0148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F014C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0154: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826F0158: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F015C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0160: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826F0164: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826F0168: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826F016C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826F0170: 4198001C  blt cr6, 0x826f018c
	if ctx.cr[6].lt {
	pc = 0x826F018C; continue 'dispatch;
	}
	// 826F0174: 409A0030  bne cr6, 0x826f01a4
	if !ctx.cr[6].eq {
	pc = 0x826F01A4; continue 'dispatch;
	}
	// 826F0178: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826F017C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826F0180: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F0184: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826F0188: 48000014  b 0x826f019c
	pc = 0x826F019C; continue 'dispatch;
	// 826F018C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826F0190: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826F0194: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F0198: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826F019C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826F01A0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826F01A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F01A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826F01AC: 388BC2A8  addi r4, r11, -0x3d58
	ctx.r[4].s64 = ctx.r[11].s64 + -15704;
	// 826F01B0: 38A00144  li r5, 0x144
	ctx.r[5].s64 = 324;
	// 826F01B4: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 826F01B8: 48702231  bl 0x82df23e8
	ctx.lr = 0x826F01BC;
	sub_82DF23E8(ctx, base);
	// 826F01BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826F01C0: 41820020  beq 0x826f01e0
	if ctx.cr[0].eq {
	pc = 0x826F01E0; continue 'dispatch;
	}
	// 826F01C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826F01C8: C05F0188  lfs f2, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826F01CC: C03F0184  lfs f1, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826F01D0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826F01D4: 4BFDC4AD  bl 0x826cc680
	ctx.lr = 0x826F01D8;
	sub_826CC680(ctx, base);
	// 826F01D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F01DC: 48000008  b 0x826f01e4
	pc = 0x826F01E4; continue 'dispatch;
	// 826F01E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826F01E4: 387F0138  addi r3, r31, 0x138
	ctx.r[3].s64 = ctx.r[31].s64 + 312;
	// 826F01E8: 4BF91FD1  bl 0x826821b8
	ctx.lr = 0x826F01EC;
	sub_826821B8(ctx, base);
	// 826F01EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826F01F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F01F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F01F8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826F01FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F0200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0208 size=56
    let mut pc: u32 = 0x826F0208;
    'dispatch: loop {
        match pc {
            0x826F0208 => {
    //   block [0x826F0208..0x826F0240)
	// 826F0208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F020C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0218: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 826F021C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0220: 4BFFF179  bl 0x826ef398
	ctx.lr = 0x826F0224;
	sub_826EF398(ctx, base);
	// 826F0224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0228: 4BFFFF21  bl 0x826f0148
	ctx.lr = 0x826F022C;
	sub_826F0148(ctx, base);
	// 826F022C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826F0230: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F0234: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F0238: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F023C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F0240 size=432
    let mut pc: u32 = 0x826F0240;
    'dispatch: loop {
        match pc {
            0x826F0240 => {
    //   block [0x826F0240..0x826F03F0)
	// 826F0240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F0244: 48AB7F21  bl 0x831a8164
	ctx.lr = 0x826F0248;
	sub_831A8130(ctx, base);
	// 826F0248: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F024C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F0250: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826F0254: 3BCBC2A8  addi r30, r11, -0x3d58
	ctx.r[30].s64 = ctx.r[11].s64 + -15704;
	// 826F0258: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826F025C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826F0260: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826F0264: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 826F0268: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826F026C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826F0270: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 826F0274: 48702175  bl 0x82df23e8
	ctx.lr = 0x826F0278;
	sub_82DF23E8(ctx, base);
	// 826F0278: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826F027C: 41820014  beq 0x826f0290
	if ctx.cr[0].eq {
	pc = 0x826F0290; continue 'dispatch;
	}
	// 826F0280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0284: 4BFFF53D  bl 0x826ef7c0
	ctx.lr = 0x826F0288;
	sub_826EF7C0(ctx, base);
	// 826F0288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F028C: 48000008  b 0x826f0294
	pc = 0x826F0294; continue 'dispatch;
	// 826F0290: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826F0294: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826F0298: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F029C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F02A0: 4BFFF031  bl 0x826ef2d0
	ctx.lr = 0x826F02A4;
	sub_826EF2D0(ctx, base);
	// 826F02A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826F02A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F02AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F02B0: 4BBCFD51  bl 0x822c0000
	ctx.lr = 0x826F02B4;
	sub_822C0000(ctx, base);
	// 826F02B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826F02B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826F02BC: 38A00045  li r5, 0x45
	ctx.r[5].s64 = 69;
	// 826F02C0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826F02C4: 4BBD0115  bl 0x822c03d8
	ctx.lr = 0x826F02C8;
	sub_822C03D8(ctx, base);
	// 826F02C8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826F02CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826F02D0: 418200B4  beq 0x826f0384
	if ctx.cr[0].eq {
	pc = 0x826F0384; continue 'dispatch;
	}
	// 826F02D4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826F02D8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826F02DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826F02E0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826F02E4: 409A0008  bne cr6, 0x826f02ec
	if !ctx.cr[6].eq {
	pc = 0x826F02EC; continue 'dispatch;
	}
	// 826F02E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F02EC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826F02F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826F02F4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826F02F8: 419A0024  beq cr6, 0x826f031c
	if ctx.cr[6].eq {
	pc = 0x826F031C; continue 'dispatch;
	}
	// 826F02FC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826F0300: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826F0304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F0308: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826F030C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826F0310: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826F0314: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F0318: 4082FFE8  bne 0x826f0300
	if !ctx.cr[0].eq {
	pc = 0x826F0300; continue 'dispatch;
	}
	// 826F031C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826F0320: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826F0324: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826F0328: 419A0024  beq cr6, 0x826f034c
	if ctx.cr[6].eq {
	pc = 0x826F034C; continue 'dispatch;
	}
	// 826F032C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826F0330: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826F0334: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F0338: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826F033C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826F0340: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826F0344: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826F0348: 4082FFE8  bne 0x826f0330
	if !ctx.cr[0].eq {
	pc = 0x826F0330; continue 'dispatch;
	}
	// 826F034C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826F0350: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826F0354: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826F0358: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826F035C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826F0360: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826F0364: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826F0368: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826F036C: 480A8BC5  bl 0x82798f30
	ctx.lr = 0x826F0370;
	sub_82798F30(ctx, base);
	// 826F0370: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0378: 480AB2F1  bl 0x8279b668
	ctx.lr = 0x826F037C;
	sub_8279B668(ctx, base);
	// 826F037C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0380: 48000008  b 0x826f0388
	pc = 0x826F0388; continue 'dispatch;
	// 826F0384: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826F0388: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826F038C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826F0390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F0398: 4BEA78B9  bl 0x82597c50
	ctx.lr = 0x826F039C;
	sub_82597C50(ctx, base);
	// 826F039C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826F03A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F03A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F03A8: 4BBCFC59  bl 0x822c0000
	ctx.lr = 0x826F03AC;
	sub_822C0000(ctx, base);
	// 826F03AC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826F03B0: 41820024  beq 0x826f03d4
	if ctx.cr[0].eq {
	pc = 0x826F03D4; continue 'dispatch;
	}
	// 826F03B4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826F03B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F03BC: 419A0008  beq cr6, 0x826f03c4
	if ctx.cr[6].eq {
	pc = 0x826F03C4; continue 'dispatch;
	}
	// 826F03C0: 4BBD04D1  bl 0x822c0890
	ctx.lr = 0x826F03C4;
	sub_822C0890(ctx, base);
	// 826F03C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826F03C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F03CC: 419A0008  beq cr6, 0x826f03d4
	if ctx.cr[6].eq {
	pc = 0x826F03D4; continue 'dispatch;
	}
	// 826F03D0: 4BBD04C1  bl 0x822c0890
	ctx.lr = 0x826F03D4;
	sub_822C0890(ctx, base);
	// 826F03D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826F03D8: 419A000C  beq cr6, 0x826f03e4
	if ctx.cr[6].eq {
	pc = 0x826F03E4; continue 'dispatch;
	}
	// 826F03DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826F03E0: 4BBD04B1  bl 0x822c0890
	ctx.lr = 0x826F03E4;
	sub_822C0890(ctx, base);
	// 826F03E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826F03E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826F03EC: 48AB7DC8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F03F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F03F0 size=52
    let mut pc: u32 = 0x826F03F0;
    'dispatch: loop {
        match pc {
            0x826F03F0 => {
    //   block [0x826F03F0..0x826F0424)
	// 826F03F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F03F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F03F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F03FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826F0404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0408: 4BFFFE39  bl 0x826f0240
	ctx.lr = 0x826F040C;
	sub_826F0240(ctx, base);
	// 826F040C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0410: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826F0414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F0418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F041C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F0420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0428 size=52
    let mut pc: u32 = 0x826F0428;
    'dispatch: loop {
        match pc {
            0x826F0428 => {
    //   block [0x826F0428..0x826F045C)
	// 826F0428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F042C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0430: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0434: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0438: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826F043C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0440: 4BFFFE01  bl 0x826f0240
	ctx.lr = 0x826F0444;
	sub_826F0240(ctx, base);
	// 826F0444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0448: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826F044C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F0450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F0454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F0458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0460 size=96
    let mut pc: u32 = 0x826F0460;
    'dispatch: loop {
        match pc {
            0x826F0460 => {
    //   block [0x826F0460..0x826F04C0)
	// 826F0460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F0464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826F046C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0474: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F0478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F047C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826F0480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F0484: 388BAD94  addi r4, r11, -0x526c
	ctx.r[4].s64 = ctx.r[11].s64 + -21100;
	// 826F0488: 48703581  bl 0x82df3a08
	ctx.lr = 0x826F048C;
	sub_82DF3A08(ctx, base);
	// 826F048C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826F0490: 38BF0171  addi r5, r31, 0x171
	ctx.r[5].s64 = ctx.r[31].s64 + 369;
	// 826F0494: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F0498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826F049C: 4BF07BED  bl 0x825f8088
	ctx.lr = 0x826F04A0;
	sub_825F8088(ctx, base);
	// 826F04A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F04A4: 48702F85  bl 0x82df3428
	ctx.lr = 0x826F04A8;
	sub_82DF3428(ctx, base);
	// 826F04A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826F04AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F04B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F04B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826F04B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F04BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F04C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F04C0 size=2356
    let mut pc: u32 = 0x826F04C0;
    'dispatch: loop {
        match pc {
            0x826F04C0 => {
    //   block [0x826F04C0..0x826F0DF4)
	// 826F04C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F04C4: 48AB7C71  bl 0x831a8134
	ctx.lr = 0x826F04C8;
	sub_831A8130(ctx, base);
	// 826F04C8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 826F04CC: 48AB85AD  bl 0x831a8a78
	ctx.lr = 0x826F04D0;
	sub_831A8A40(ctx, base);
	// 826F04D0: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0DF8 size=220
    let mut pc: u32 = 0x826F0DF8;
    'dispatch: loop {
        match pc {
            0x826F0DF8 => {
    //   block [0x826F0DF8..0x826F0ED4)
	// 826F0DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F0DFC: 48AB736D  bl 0x831a8168
	ctx.lr = 0x826F0E00;
	sub_831A8130(ctx, base);
	// 826F0E00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0E04: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826F0E08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826F0E0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826F0E10: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826F0E14: 41820038  beq 0x826f0e4c
	if ctx.cr[0].eq {
	pc = 0x826F0E4C; continue 'dispatch;
	}
	// 826F0E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0E1C: 48AB8B6D  bl 0x831a9988
	ctx.lr = 0x826F0E20;
	sub_831A9988(ctx, base);
	// 826F0E20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826F0E24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F0E28: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826F0E2C: 48AB72CD  bl 0x831a80f8
	ctx.lr = 0x826F0E30;
	sub_831A80F8(ctx, base);
	// 826F0E30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826F0E34: 41820018  beq 0x826f0e4c
	if ctx.cr[0].eq {
	pc = 0x826F0E4C; continue 'dispatch;
	}
	// 826F0E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0E3C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826F0E40: 4BFF5041  bl 0x826e5e80
	ctx.lr = 0x826F0E44;
	sub_826E5E80(ctx, base);
	// 826F0E44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826F0E48: 48000084  b 0x826f0ecc
	pc = 0x826F0ECC; continue 'dispatch;
	// 826F0E4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826F0E50: 419A006C  beq cr6, 0x826f0ebc
	if ctx.cr[6].eq {
	pc = 0x826F0EBC; continue 'dispatch;
	}
	// 826F0E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0E58: 48AB8B31  bl 0x831a9988
	ctx.lr = 0x826F0E5C;
	sub_831A9988(ctx, base);
	// 826F0E5C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826F0E60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F0E64: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826F0E68: 48AB7291  bl 0x831a80f8
	ctx.lr = 0x826F0E6C;
	sub_831A80F8(ctx, base);
	// 826F0E6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826F0E70: 41820014  beq 0x826f0e84
	if ctx.cr[0].eq {
	pc = 0x826F0E84; continue 'dispatch;
	}
	// 826F0E74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0E78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826F0E7C: 4BFFE39D  bl 0x826ef218
	ctx.lr = 0x826F0E80;
	sub_826EF218(ctx, base);
	// 826F0E80: 4BFFFFC4  b 0x826f0e44
	pc = 0x826F0E44; continue 'dispatch;
	// 826F0E84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826F0E88: 419A0034  beq cr6, 0x826f0ebc
	if ctx.cr[6].eq {
	pc = 0x826F0EBC; continue 'dispatch;
	}
	// 826F0E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F0E90: 48AB8AF9  bl 0x831a9988
	ctx.lr = 0x826F0E94;
	sub_831A9988(ctx, base);
	// 826F0E94: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826F0E98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F0E9C: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 826F0EA0: 48AB7259  bl 0x831a80f8
	ctx.lr = 0x826F0EA4;
	sub_831A80F8(ctx, base);
	// 826F0EA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826F0EA8: 41820014  beq 0x826f0ebc
	if ctx.cr[0].eq {
	pc = 0x826F0EBC; continue 'dispatch;
	}
	// 826F0EAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0EB0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826F0EB4: 4BFFE595  bl 0x826ef448
	ctx.lr = 0x826F0EB8;
	sub_826EF448(ctx, base);
	// 826F0EB8: 4BFFFF8C  b 0x826f0e44
	pc = 0x826F0E44; continue 'dispatch;
	// 826F0EBC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826F0EC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F0EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F0EC8: 4BE21751  bl 0x82512618
	ctx.lr = 0x826F0ECC;
	sub_82512618(ctx, base);
	// 826F0ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826F0ED0: 48AB72E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F0ED8 size=20
    let mut pc: u32 = 0x826F0ED8;
    'dispatch: loop {
        match pc {
            0x826F0ED8 => {
    //   block [0x826F0ED8..0x826F0EEC)
	// 826F0ED8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826F0EDC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826F0EE0: 419A0014  beq cr6, 0x826f0ef4
	if ctx.cr[6].eq {
		sub_826F0EF4(ctx, base);
		return;
	}
	// 826F0EE4: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826F0EE8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0EEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F0EEC size=8
    let mut pc: u32 = 0x826F0EEC;
    'dispatch: loop {
        match pc {
            0x826F0EEC => {
    //   block [0x826F0EEC..0x826F0EF4)
	// 826F0EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F0EF0: 48000008  b 0x826f0ef8
	sub_826F0EF4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F0EF4 size=12
    let mut pc: u32 = 0x826F0EF4;
    'dispatch: loop {
        match pc {
            0x826F0EF4 => {
    //   block [0x826F0EF4..0x826F0F00)
	// 826F0EF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826F0EF8: 99630161  stb r11, 0x161(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(353 as u32), ctx.r[11].u8 ) };
	// 826F0EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F0F00 size=12
    let mut pc: u32 = 0x826F0F00;
    'dispatch: loop {
        match pc {
            0x826F0F00 => {
    //   block [0x826F0F00..0x826F0F0C)
	// 826F0F00: 80630118  lwz r3, 0x118(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 826F0F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F0F08: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0F0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F0F0C size=8
    let mut pc: u32 = 0x826F0F0C;
    'dispatch: loop {
        match pc {
            0x826F0F0C => {
    //   block [0x826F0F0C..0x826F0F14)
	// 826F0F0C: 4BF98A4C  b 0x82689958
	sub_82689958(ctx, base);
	return;
	// 826F0F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F0F18 size=120
    let mut pc: u32 = 0x826F0F18;
    'dispatch: loop {
        match pc {
            0x826F0F18 => {
    //   block [0x826F0F18..0x826F0F90)
	// 826F0F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F0F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F0F2C: 897F0161  lbz r11, 0x161(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(353 as u32) ) } as u64;
	// 826F0F30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826F0F34: 4082000C  bne 0x826f0f40
	if !ctx.cr[0].eq {
	pc = 0x826F0F40; continue 'dispatch;
	}
	// 826F0F38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826F0F3C: 48000040  b 0x826f0f7c
	pc = 0x826F0F7C; continue 'dispatch;
	// 826F0F40: C01F016C  lfs f0, 0x16c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F0F44: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826F0F48: C1BF0168  lfs f13, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826F0F4C: EC40682A  fadds f2, f0, f13
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826F0F50: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F0F54: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826F0F58: 4099FFE0  ble cr6, 0x826f0f38
	if !ctx.cr[6].gt {
	pc = 0x826F0F38; continue 'dispatch;
	}
	// 826F0F5C: 48AB98B5  bl 0x831aa810
	ctx.lr = 0x826F0F60;
	sub_831AA810(ctx, base);
	// 826F0F60: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826F0F64: C1BF0168  lfs f13, 0x168(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826F0F68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826F0F6C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826F0F70: 41980008  blt cr6, 0x826f0f78
	if ctx.cr[6].lt {
	pc = 0x826F0F78; continue 'dispatch;
	}
	// 826F0F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F0F78: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826F0F7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826F0F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F0F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F0F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F0F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F0F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F0F90 size=196
    let mut pc: u32 = 0x826F0F90;
    'dispatch: loop {
        match pc {
            0x826F0F90 => {
    //   block [0x826F0F90..0x826F1054)
	// 826F0F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F0F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F0F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826F0F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F0FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F0FA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826F0FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F0FAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826F0FB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826F0FB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F0FB8: 4BBCF981  bl 0x822c0938
	ctx.lr = 0x826F0FBC;
	sub_822C0938(ctx, base);
	// 826F0FBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826F0FC0: 41820028  beq 0x826f0fe8
	if ctx.cr[0].eq {
	pc = 0x826F0FE8; continue 'dispatch;
	}
	// 826F0FC4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F0FC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826F0FCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826F0FD0: 392BC380  addi r9, r11, -0x3c80
	ctx.r[9].s64 = ctx.r[11].s64 + -15488;
	// 826F0FD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826F0FD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826F0FDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826F0FE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826F0FE4: 48000008  b 0x826f0fec
	pc = 0x826F0FEC; continue 'dispatch;
	// 826F0FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F0FEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F0FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826F0FF4: 409A0044  bne cr6, 0x826f1038
	if !ctx.cr[6].eq {
	pc = 0x826F1038; continue 'dispatch;
	}
	// 826F0FF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826F0FFC: 419A001C  beq cr6, 0x826f1018
	if ctx.cr[6].eq {
	pc = 0x826F1018; continue 'dispatch;
	}
	// 826F1000: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F1004: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826F1008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F100C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F1010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826F1014: 4E800421  bctrl
	ctx.lr = 0x826F1018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826F1018: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826F101C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826F1020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F1024: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826F1028: 816BEA80  lwz r11, -0x1580(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5504 as u32) ) } as u64;
	// 826F102C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826F1030: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826F1034: 4BBCEFCD  bl 0x822c0000
	ctx.lr = 0x826F1038;
	sub_822C0000(ctx, base);
	// 826F1038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F103C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826F1040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F1044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F1048: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826F104C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F1050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F1058 size=192
    let mut pc: u32 = 0x826F1058;
    'dispatch: loop {
        match pc {
            0x826F1058 => {
    //   block [0x826F1058..0x826F1118)
	// 826F1058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F105C: 48AB7111  bl 0x831a816c
	ctx.lr = 0x826F1060;
	sub_831A8130(ctx, base);
	// 826F1060: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826F1064: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826F1068: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F106C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F1070: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 826F1074: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826F1078: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 826F107C: 83DF012C  lwz r30, 0x12c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826F1080: C02ADFAC  lfs f1, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826F1084: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 826F1088: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826F108C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826F1090: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826F1094: 4878B955  bl 0x82e7c9e8
	ctx.lr = 0x826F1098;
	sub_82E7C9E8(ctx, base);
	// 826F1098: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826F109C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826F10A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826F10A4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826F10A8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826F10AC: C00A9530  lfs f0, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F10B0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826F10B4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826F10B8: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826F10BC: 4878AF5D  bl 0x82e7c018
	ctx.lr = 0x826F10C0;
	sub_82E7C018(ctx, base);
	// 826F10C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F10C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F10C8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826F10CC: 4BBD3835  bl 0x822c4900
	ctx.lr = 0x826F10D0;
	sub_822C4900(ctx, base);
	// 826F10D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F10D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F10D8: 48722189  bl 0x82e13260
	ctx.lr = 0x826F10DC;
	sub_82E13260(ctx, base);
	// 826F10DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826F10E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F10E4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826F10E8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826F10EC: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F10F0: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 826F10F4: 83FF0134  lwz r31, 0x134(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 826F10F8: 4878AF21  bl 0x82e7c018
	ctx.lr = 0x826F10FC;
	sub_82E7C018(ctx, base);
	// 826F10FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826F1100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F1104: 4872215D  bl 0x82e13260
	ctx.lr = 0x826F1108;
	sub_82E13260(ctx, base);
	// 826F1108: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 826F110C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826F1110: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826F1114: 48AB70A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F1118 size=360
    let mut pc: u32 = 0x826F1118;
    'dispatch: loop {
        match pc {
            0x826F1118 => {
    //   block [0x826F1118..0x826F1280)
	// 826F1118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F111C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F1120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826F1124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F1128: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826F112C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F1130: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826F1134: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826F1138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826F113C: 4BE20C5D  bl 0x82511d98
	ctx.lr = 0x826F1140;
	sub_82511D98(ctx, base);
	// 826F1140: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826F1144: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826F1148: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 826F114C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826F1150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F1154: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826F1158: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826F115C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826F1160: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826F1164: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826F1168: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826F116C: 4878ABDD  bl 0x82e7bd48
	ctx.lr = 0x826F1170;
	sub_82E7BD48(ctx, base);
	// 826F1170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826F1174: 4BE20975  bl 0x82511ae8
	ctx.lr = 0x826F1178;
	sub_82511AE8(ctx, base);
	// 826F1178: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 826F117C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826F1180: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826F1184: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826F1188: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F1280 size=8
    let mut pc: u32 = 0x826F1280;
    'dispatch: loop {
        match pc {
            0x826F1280 => {
    //   block [0x826F1280..0x826F1288)
	// 826F1280: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826F1284: 4BFFFDD4  b 0x826f1058
	sub_826F1058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826F1288 size=292
    let mut pc: u32 = 0x826F1288;
    'dispatch: loop {
        match pc {
            0x826F1288 => {
    //   block [0x826F1288..0x826F13AC)
	// 826F1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F128C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F1290: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F1294: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F1298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F129C: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826F12A0: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826F12A4: 4182008C  beq 0x826f1330
	if ctx.cr[0].eq {
	pc = 0x826F1330; continue 'dispatch;
	}
	// 826F12A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826F12AC: 808B674C  lwz r4, 0x674c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826F12B0: 4BD9E0F1  bl 0x8248f3a0
	ctx.lr = 0x826F12B4;
	sub_8248F3A0(ctx, base);
	// 826F12B4: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826F12B8: 4BF98641  bl 0x826898f8
	ctx.lr = 0x826F12BC;
	sub_826898F8(ctx, base);
	// 826F12BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F12C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F12C4: 38ABAAEC  addi r5, r11, -0x5514
	ctx.r[5].s64 = ctx.r[11].s64 + -21780;
	// 826F12C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F12CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F12D0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826F12D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826F12D8: 4E800421  bctrl
	ctx.lr = 0x826F12DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826F12DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826F12E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F12E4: 419A0008  beq cr6, 0x826f12ec
	if ctx.cr[6].eq {
	pc = 0x826F12EC; continue 'dispatch;
	}
	// 826F12E8: 4BBCF5A9  bl 0x822c0890
	ctx.lr = 0x826F12EC;
	sub_822C0890(ctx, base);
	// 826F12EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F12F0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826F12F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F12F8: 38AAAAD4  addi r5, r10, -0x552c
	ctx.r[5].s64 = ctx.r[10].s64 + -21804;
	// 826F12FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826F1300: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826F1304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826F1308: 4E800421  bctrl
	ctx.lr = 0x826F130C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826F130C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826F1310: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	// 826F1314: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826F1318: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826F131C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F1320: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826F1324: 4BBD313D  bl 0x822c4460
	ctx.lr = 0x826F1328;
	sub_822C4460(ctx, base);
	// 826F1328: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826F132C: 48000060  b 0x826f138c
	pc = 0x826F138C; continue 'dispatch;
	// 826F1330: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826F1334: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 826F1338: 4BD9E069  bl 0x8248f3a0
	ctx.lr = 0x826F133C;
	sub_8248F3A0(ctx, base);
	// 826F133C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826F1340: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826F1344: 4BF98525  bl 0x82689868
	ctx.lr = 0x826F1348;
	sub_82689868(ctx, base);
	// 826F1348: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826F134C: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 826F1350: 915F0110  stw r10, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	// 826F1354: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826F1358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F135C: 915F0114  stw r10, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 826F1360: 419A0008  beq cr6, 0x826f1368
	if ctx.cr[6].eq {
	pc = 0x826F1368; continue 'dispatch;
	}
	// 826F1364: 4BBCF52D  bl 0x822c0890
	ctx.lr = 0x826F1368;
	sub_822C0890(ctx, base);
	// 826F1368: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826F136C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826F1370: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826F1374: 38AAAAB8  addi r5, r10, -0x5548
	ctx.r[5].s64 = ctx.r[10].s64 + -21832;
	// 826F1378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F137C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 826F1380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826F1384: 4E800421  bctrl
	ctx.lr = 0x826F1388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826F1388: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826F138C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826F1390: 419A0008  beq cr6, 0x826f1398
	if ctx.cr[6].eq {
	pc = 0x826F1398; continue 'dispatch;
	}
	// 826F1394: 4BBCF4FD  bl 0x822c0890
	ctx.lr = 0x826F1398;
	sub_822C0890(ctx, base);
	// 826F1398: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826F139C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F13A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F13A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F13A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F13B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F13B0 size=328
    let mut pc: u32 = 0x826F13B0;
    'dispatch: loop {
        match pc {
            0x826F13B0 => {
    //   block [0x826F13B0..0x826F14F8)
	// 826F13B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F13B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F13B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826F13BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F13C0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826F13C4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826F13C8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826F13CC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F13D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F13D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826F13D8: 419A00FC  beq cr6, 0x826f14d4
	if ctx.cr[6].eq {
	pc = 0x826F14D4; continue 'dispatch;
	}
	// 826F13DC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826F13E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F13E4: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826F13E8: 48702621  bl 0x82df3a08
	ctx.lr = 0x826F13EC;
	sub_82DF3A08(ctx, base);
	// 826F13EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826F13F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F13F4: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826F13F8: 48702611  bl 0x82df3a08
	ctx.lr = 0x826F13FC;
	sub_82DF3A08(ctx, base);
	// 826F13FC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826F1400: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826F1404: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826F1408: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826F140C: 3BCBEA64  addi r30, r11, -0x159c
	ctx.r[30].s64 = ctx.r[11].s64 + -5532;
	// 826F1410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826F1414: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826F1418: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826F141C: C3C9DD6C  lfs f30, -0x2294(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826F1420: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826F1424: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826F1428: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826F142C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826F1430: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826F1434: 4BEB1E75  bl 0x825a32a8
	ctx.lr = 0x826F1438;
	sub_825A32A8(ctx, base);
	// 826F1438: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826F143C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826F1440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F1444: 4BEB032D  bl 0x825a1770
	ctx.lr = 0x826F1448;
	sub_825A1770(ctx, base);
	// 826F1448: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826F144C: 48701FDD  bl 0x82df3428
	ctx.lr = 0x826F1450;
	sub_82DF3428(ctx, base);
	// 826F1450: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826F1454: 4BBD7865  bl 0x822c8cb8
	ctx.lr = 0x826F1458;
	sub_822C8CB8(ctx, base);
	// 826F1458: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F145C: 48701FCD  bl 0x82df3428
	ctx.lr = 0x826F1460;
	sub_82DF3428(ctx, base);
	// 826F1460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F1464: 48701FC5  bl 0x82df3428
	ctx.lr = 0x826F1468;
	sub_82DF3428(ctx, base);
	// 826F1468: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F146C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F1470: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 826F1474: 48702595  bl 0x82df3a08
	ctx.lr = 0x826F1478;
	sub_82DF3A08(ctx, base);
	// 826F1478: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F147C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F1480: 388BAB0C  addi r4, r11, -0x54f4
	ctx.r[4].s64 = ctx.r[11].s64 + -21748;
	// 826F1484: 48702585  bl 0x82df3a08
	ctx.lr = 0x826F1488;
	sub_82DF3A08(ctx, base);
	// 826F1488: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 826F148C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826F1490: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826F1494: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826F1498: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826F149C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826F14A0: 4BEB1E09  bl 0x825a32a8
	ctx.lr = 0x826F14A4;
	sub_825A32A8(ctx, base);
	// 826F14A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826F14A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826F14AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F14B0: 4BEB02C1  bl 0x825a1770
	ctx.lr = 0x826F14B4;
	sub_825A1770(ctx, base);
	// 826F14B4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826F14B8: 48701F71  bl 0x82df3428
	ctx.lr = 0x826F14BC;
	sub_82DF3428(ctx, base);
	// 826F14BC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826F14C0: 4BBD77F9  bl 0x822c8cb8
	ctx.lr = 0x826F14C4;
	sub_822C8CB8(ctx, base);
	// 826F14C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826F14C8: 48701F61  bl 0x82df3428
	ctx.lr = 0x826F14CC;
	sub_82DF3428(ctx, base);
	// 826F14CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826F14D0: 48701F59  bl 0x82df3428
	ctx.lr = 0x826F14D4;
	sub_82DF3428(ctx, base);
	// 826F14D4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826F14D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826F14DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826F14E0: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826F14E4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826F14E8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826F14EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826F14F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826F14F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F14F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826F14F8 size=284
    let mut pc: u32 = 0x826F14F8;
    'dispatch: loop {
        match pc {
            0x826F14F8 => {
    //   block [0x826F14F8..0x826F1614)
	// 826F14F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826F14FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826F1500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826F1504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826F1508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826F150C: 4BFD90E5  bl 0x826ca5f0
	ctx.lr = 0x826F1510;
	sub_826CA5F0(ctx, base);
	// 826F1510: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826F1514: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826F1518: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826F151C: 396BC3F4  addi r11, r11, -0x3c0c
	ctx.r[11].s64 = ctx.r[11].s64 + -15372;
	// 826F1520: 394AC3E0  addi r10, r10, -0x3c20
	ctx.r[10].s64 = ctx.r[10].s64 + -15392;
	// 826F1524: 3929C394  addi r9, r9, -0x3c6c
	ctx.r[9].s64 = ctx.r[9].s64 + -15468;
	// 826F1528: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F152C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826F1530: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826F1534: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826F1538: 395F00E8  addi r10, r31, 0xe8
	ctx.r[10].s64 = ctx.r[31].s64 + 232;
	// 826F153C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 826F1540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826F1544: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F1548: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826F154C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826F1550: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826F1554: 4080FFF0  bge 0x826f1544
	if !ctx.cr[0].lt {
	pc = 0x826F1544; continue 'dispatch;
	}
	// 826F1558: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826F155C: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 826F1560: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826F1564: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 826F1568: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F156C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826F1570: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826F1574: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826F1578: 4080FFF0  bge 0x826f1568
	if !ctx.cr[0].lt {
	pc = 0x826F1568; continue 'dispatch;
	}
	// 826F157C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826F1580: 395F012C  addi r10, r31, 0x12c
	ctx.r[10].s64 = ctx.r[31].s64 + 300;
	// 826F1584: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826F1588: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 826F158C: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 826F1590: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 826F1594: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 826F1598: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826F159C: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 826F15A0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826F15A4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826F15A8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826F15AC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826F15B0: 4080FFF0  bge 0x826f15a0
	if !ctx.cr[0].lt {
	pc = 0x826F15A0; continue 'dispatch;
	}
	// 826F15B4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826F15B8: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 826F15BC: 39200150  li r9, 0x150
	ctx.r[9].s64 = 336;
	// 826F15C0: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 826F15C4: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 826F15C8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826F15CC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 826F15D0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 826F15D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826F15D8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F1618 size=8
    let mut pc: u32 = 0x826F1618;
    'dispatch: loop {
        match pc {
            0x826F1618 => {
    //   block [0x826F1618..0x826F1620)
	// 826F1618: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826F161C: 4800010C  b 0x826f1728
	sub_826F1728(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826F1620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826F1620 size=8
    let mut pc: u32 = 0x826F1620;
    'dispatch: loop {
        match pc {
            0x826F1620 => {
    //   block [0x826F1620..0x826F1628)
	// 826F1620: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826F1624: 48000104  b 0x826f1728
	sub_826F1728(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


