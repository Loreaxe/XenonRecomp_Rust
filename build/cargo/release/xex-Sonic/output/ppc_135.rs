pub fn sub_82A9F9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9F9E8 size=100
    let mut pc: u32 = 0x82A9F9E8;
    'dispatch: loop {
        match pc {
            0x82A9F9E8 => {
    //   block [0x82A9F9E8..0x82A9FA4C)
	// 82A9F9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9F9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A9F9F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A9F9F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9F9F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9F9FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FA00: 4BFFFEB1  bl 0x82a9f8b0
	ctx.lr = 0x82A9FA04;
	sub_82A9F8B0(ctx, base);
	// 82A9FA04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA08: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA0C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A9FA10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A9FA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FA18: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A9FA1C: 419A0018  beq cr6, 0x82a9fa34
	if ctx.cr[6].eq {
	pc = 0x82A9FA34; continue 'dispatch;
	}
	// 82A9FA20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A9FA28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9FA30: 4E800421  bctrl
	ctx.lr = 0x82A9FA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9FA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9FA38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A9FA3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A9FA40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A9FA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A9FA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A9FA50 size=320
    let mut pc: u32 = 0x82A9FA50;
    'dispatch: loop {
        match pc {
            0x82A9FA50 => {
    //   block [0x82A9FA50..0x82A9FB90)
	// 82A9FA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FA54: 48708719  bl 0x831a816c
	ctx.lr = 0x82A9FA58;
	sub_831A8130(ctx, base);
	// 82A9FA58: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A9FA5C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A9FA60: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FA64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A9FA68: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A9FA6C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82A9FA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9FA74: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FA78: 4BB2AA89  bl 0x825ca500
	ctx.lr = 0x82A9FA7C;
	sub_825CA500(ctx, base);
	// 82A9FA7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FA80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9FA84: 388B58F8  addi r4, r11, 0x58f8
	ctx.r[4].s64 = ctx.r[11].s64 + 22776;
	// 82A9FA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FA8C: 48353F7D  bl 0x82df3a08
	ctx.lr = 0x82A9FA90;
	sub_82DF3A08(ctx, base);
	// 82A9FA90: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FA94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9FA98: 388B58EC  addi r4, r11, 0x58ec
	ctx.r[4].s64 = ctx.r[11].s64 + 22764;
	// 82A9FA9C: 48353F6D  bl 0x82df3a08
	ctx.lr = 0x82A9FAA0;
	sub_82DF3A08(ctx, base);
	// 82A9FAA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A9FAA4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A9FAA8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A9FAAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A9FAB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9FAB4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A9FAB8: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A9FABC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A9FAC0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A9FAC4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A9FAC8: 4BB037E1  bl 0x825a32a8
	ctx.lr = 0x82A9FACC;
	sub_825A32A8(ctx, base);
	// 82A9FACC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9FAD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FAD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A9FAD8: 4BB01C99  bl 0x825a1770
	ctx.lr = 0x82A9FADC;
	sub_825A1770(ctx, base);
	// 82A9FADC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A9FAE0: 48353949  bl 0x82df3428
	ctx.lr = 0x82A9FAE4;
	sub_82DF3428(ctx, base);
	// 82A9FAE4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A9FAE8: 4B8291D1  bl 0x822c8cb8
	ctx.lr = 0x82A9FAEC;
	sub_822C8CB8(ctx, base);
	// 82A9FAEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9FAF0: 48353939  bl 0x82df3428
	ctx.lr = 0x82A9FAF4;
	sub_82DF3428(ctx, base);
	// 82A9FAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FAF8: 48353931  bl 0x82df3428
	ctx.lr = 0x82A9FAFC;
	sub_82DF3428(ctx, base);
	// 82A9FAFC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FB00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9FB04: 388B58E0  addi r4, r11, 0x58e0
	ctx.r[4].s64 = ctx.r[11].s64 + 22752;
	// 82A9FB08: 48353F01  bl 0x82df3a08
	ctx.lr = 0x82A9FB0C;
	sub_82DF3A08(ctx, base);
	// 82A9FB0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FB10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FB14: 388B58D8  addi r4, r11, 0x58d8
	ctx.r[4].s64 = ctx.r[11].s64 + 22744;
	// 82A9FB18: 48353EF1  bl 0x82df3a08
	ctx.lr = 0x82A9FB1C;
	sub_82DF3A08(ctx, base);
	// 82A9FB1C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82A9FB20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A9FB24: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A9FB28: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A9FB2C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A9FB30: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A9FB34: 4BB03775  bl 0x825a32a8
	ctx.lr = 0x82A9FB38;
	sub_825A32A8(ctx, base);
	// 82A9FB38: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9FB3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A9FB40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A9FB44: 4BB01C2D  bl 0x825a1770
	ctx.lr = 0x82A9FB48;
	sub_825A1770(ctx, base);
	// 82A9FB48: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A9FB4C: 483538DD  bl 0x82df3428
	ctx.lr = 0x82A9FB50;
	sub_82DF3428(ctx, base);
	// 82A9FB50: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A9FB54: 4B829165  bl 0x822c8cb8
	ctx.lr = 0x82A9FB58;
	sub_822C8CB8(ctx, base);
	// 82A9FB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FB5C: 483538CD  bl 0x82df3428
	ctx.lr = 0x82A9FB60;
	sub_82DF3428(ctx, base);
	// 82A9FB60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A9FB64: 483538C5  bl 0x82df3428
	ctx.lr = 0x82A9FB68;
	sub_82DF3428(ctx, base);
	// 82A9FB68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FB6C: 4BB2A165  bl 0x825c9cd0
	ctx.lr = 0x82A9FB70;
	sub_825C9CD0(ctx, base);
	// 82A9FB70: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FB74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FB78: 419A0008  beq cr6, 0x82a9fb80
	if ctx.cr[6].eq {
	pc = 0x82A9FB80; continue 'dispatch;
	}
	// 82A9FB7C: 4B820D15  bl 0x822c0890
	ctx.lr = 0x82A9FB80;
	sub_822C0890(ctx, base);
	// 82A9FB80: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A9FB84: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A9FB88: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A9FB8C: 48708630  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A9FB90 size=560
    let mut pc: u32 = 0x82A9FB90;
    'dispatch: loop {
        match pc {
            0x82A9FB90 => {
    //   block [0x82A9FB90..0x82A9FDC0)
	// 82A9FB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FB94: 487085D9  bl 0x831a816c
	ctx.lr = 0x82A9FB98;
	sub_831A8130(ctx, base);
	// 82A9FB98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FB9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FBA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A9FBA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A9FBA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9FBAC: 388B6010  addi r4, r11, 0x6010
	ctx.r[4].s64 = ctx.r[11].s64 + 24592;
	// 82A9FBB0: 48353E59  bl 0x82df3a08
	ctx.lr = 0x82A9FBB4;
	sub_82DF3A08(ctx, base);
	// 82A9FBB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FBBC: 388B6000  addi r4, r11, 0x6000
	ctx.r[4].s64 = ctx.r[11].s64 + 24576;
	// 82A9FBC0: 48353E49  bl 0x82df3a08
	ctx.lr = 0x82A9FBC4;
	sub_82DF3A08(ctx, base);
	// 82A9FBC4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FBC8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A9FBCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A9FBD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A9FBD4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FBD8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A9FBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9FBE0: 4E800421  bctrl
	ctx.lr = 0x82A9FBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9FBE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FBE8: 48353841  bl 0x82df3428
	ctx.lr = 0x82A9FBEC;
	sub_82DF3428(ctx, base);
	// 82A9FBEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9FBF0: 48353839  bl 0x82df3428
	ctx.lr = 0x82A9FBF4;
	sub_82DF3428(ctx, base);
	// 82A9FBF4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A9FBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FBFC: 388B89B8  addi r4, r11, -0x7648
	ctx.r[4].s64 = ctx.r[11].s64 + -30280;
	// 82A9FC00: 48353E09  bl 0x82df3a08
	ctx.lr = 0x82A9FC04;
	sub_82DF3A08(ctx, base);
	// 82A9FC04: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A9FC08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9FC0C: 388B89A8  addi r4, r11, -0x7658
	ctx.r[4].s64 = ctx.r[11].s64 + -30296;
	// 82A9FC10: 48353DF9  bl 0x82df3a08
	ctx.lr = 0x82A9FC14;
	sub_82DF3A08(ctx, base);
	// 82A9FC14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A9FC18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A9FC1C: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9FC20: 4BB2A8E1  bl 0x825ca500
	ctx.lr = 0x82A9FC24;
	sub_825CA500(ctx, base);
	// 82A9FC24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9FC28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A9FC2C: 483537FD  bl 0x82df3428
	ctx.lr = 0x82A9FC30;
	sub_82DF3428(ctx, base);
	// 82A9FC30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A9FC34: 483537F5  bl 0x82df3428
	ctx.lr = 0x82A9FC38;
	sub_82DF3428(ctx, base);
	// 82A9FC38: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FC3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9FC40: 388B5FE0  addi r4, r11, 0x5fe0
	ctx.r[4].s64 = ctx.r[11].s64 + 24544;
	// 82A9FC44: 48353DC5  bl 0x82df3a08
	ctx.lr = 0x82A9FC48;
	sub_82DF3A08(ctx, base);
	// 82A9FC48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FC4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9FC50: 388B5FCC  addi r4, r11, 0x5fcc
	ctx.r[4].s64 = ctx.r[11].s64 + 24524;
	// 82A9FC54: 48353DB5  bl 0x82df3a08
	ctx.lr = 0x82A9FC58;
	sub_82DF3A08(ctx, base);
	// 82A9FC58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A9FC5C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A9FC60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A9FC64: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A9FC68: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A9FC6C: C06B9528  lfs f3, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A9FC70: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A9FC74: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82A9FC78: 4BB03631  bl 0x825a32a8
	ctx.lr = 0x82A9FC7C;
	sub_825A32A8(ctx, base);
	// 82A9FC7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A9FC80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A9FC84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9FC88: 4BB01AE9  bl 0x825a1770
	ctx.lr = 0x82A9FC8C;
	sub_825A1770(ctx, base);
	// 82A9FC8C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A9FC90: 48353799  bl 0x82df3428
	ctx.lr = 0x82A9FC94;
	sub_82DF3428(ctx, base);
	// 82A9FC94: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A9FC98: 4B829021  bl 0x822c8cb8
	ctx.lr = 0x82A9FC9C;
	sub_822C8CB8(ctx, base);
	// 82A9FC9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9FCA0: 48353789  bl 0x82df3428
	ctx.lr = 0x82A9FCA4;
	sub_82DF3428(ctx, base);
	// 82A9FCA4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9FCA8: 48353781  bl 0x82df3428
	ctx.lr = 0x82A9FCAC;
	sub_82DF3428(ctx, base);
	// 82A9FCAC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9FCB0: 4BB2A021  bl 0x825c9cd0
	ctx.lr = 0x82A9FCB4;
	sub_825C9CD0(ctx, base);
	// 82A9FCB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A9FCB8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A9FCBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9FCC0: 4BFEEED1  bl 0x82a8eb90
	ctx.lr = 0x82A9FCC4;
	sub_82A8EB90(ctx, base);
	// 82A9FCC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A9FCC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9FCCC: 48353D3D  bl 0x82df3a08
	ctx.lr = 0x82A9FCD0;
	sub_82DF3A08(ctx, base);
	// 82A9FCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9FCD4: 4BFEEEBD  bl 0x82a8eb90
	ctx.lr = 0x82A9FCD8;
	sub_82A8EB90(ctx, base);
	// 82A9FCD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A9FCDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9FCE0: 48353D29  bl 0x82df3a08
	ctx.lr = 0x82A9FCE4;
	sub_82DF3A08(ctx, base);
	// 82A9FCE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A9FCE8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9FCEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FCF0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A9FCF4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A9FCF8: 419A0024  beq cr6, 0x82a9fd1c
	if ctx.cr[6].eq {
	pc = 0x82A9FD1C; continue 'dispatch;
	}
	// 82A9FCFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FD00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9FD04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FD08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9FD0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9FD10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9FD14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FD18: 4082FFE8  bne 0x82a9fd00
	if !ctx.cr[0].eq {
	pc = 0x82A9FD00; continue 'dispatch;
	}
	// 82A9FD1C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A9FD20: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A9FD24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A9FD28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FD2C: 4BFFFD25  bl 0x82a9fa50
	ctx.lr = 0x82A9FD30;
	sub_82A9FA50(ctx, base);
	// 82A9FD30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A9FD34: 483536F5  bl 0x82df3428
	ctx.lr = 0x82A9FD38;
	sub_82DF3428(ctx, base);
	// 82A9FD38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A9FD3C: 483536ED  bl 0x82df3428
	ctx.lr = 0x82A9FD40;
	sub_82DF3428(ctx, base);
	// 82A9FD40: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A9FD44: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A9FD48: 2B1F0002  cmplwi cr6, r31, 2
	ctx.cr[6].compare_u32(ctx.r[31].u32, 2 as u32, &mut ctx.xer);
	// 82A9FD4C: 4198FF70  blt cr6, 0x82a9fcbc
	if ctx.cr[6].lt {
	pc = 0x82A9FCBC; continue 'dispatch;
	}
	// 82A9FD50: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A9FD54: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9FD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FD5C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A9FD60: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A9FD64: 419A0024  beq cr6, 0x82a9fd88
	if ctx.cr[6].eq {
	pc = 0x82A9FD88; continue 'dispatch;
	}
	// 82A9FD68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FD6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9FD70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FD74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9FD78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9FD7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9FD80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FD84: 4082FFE8  bne 0x82a9fd6c
	if !ctx.cr[0].eq {
	pc = 0x82A9FD6C; continue 'dispatch;
	}
	// 82A9FD88: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82A9FD8C: 4BFF7DCD  bl 0x82a97b58
	ctx.lr = 0x82A9FD90;
	sub_82A97B58(ctx, base);
	// 82A9FD90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A9FD94: 4BFF7DDD  bl 0x82a97b70
	ctx.lr = 0x82A9FD98;
	sub_82A97B70(ctx, base);
	// 82A9FD98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A9FD9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDA0: 419A0008  beq cr6, 0x82a9fda8
	if ctx.cr[6].eq {
	pc = 0x82A9FDA8; continue 'dispatch;
	}
	// 82A9FDA4: 4B820AED  bl 0x822c0890
	ctx.lr = 0x82A9FDA8;
	sub_822C0890(ctx, base);
	// 82A9FDA8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FDAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDB0: 419A0008  beq cr6, 0x82a9fdb8
	if ctx.cr[6].eq {
	pc = 0x82A9FDB8; continue 'dispatch;
	}
	// 82A9FDB4: 4B820ADD  bl 0x822c0890
	ctx.lr = 0x82A9FDB8;
	sub_822C0890(ctx, base);
	// 82A9FDB8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A9FDBC: 48708400  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A9FDC0 size=128
    let mut pc: u32 = 0x82A9FDC0;
    'dispatch: loop {
        match pc {
            0x82A9FDC0 => {
    //   block [0x82A9FDC0..0x82A9FE40)
	// 82A9FDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FDC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A9FDC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A9FDCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FDD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A9FDD4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82A9FDD8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FDDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FDE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A9FDE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A9FDE8: 419A0024  beq cr6, 0x82a9fe0c
	if ctx.cr[6].eq {
	pc = 0x82A9FE0C; continue 'dispatch;
	}
	// 82A9FDEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A9FDF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A9FDF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FDF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A9FDFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A9FE00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A9FE04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A9FE08: 4082FFE8  bne 0x82a9fdf0
	if !ctx.cr[0].eq {
	pc = 0x82A9FDF0; continue 'dispatch;
	}
	// 82A9FE0C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A9FE10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A9FE14: 386BC480  addi r3, r11, -0x3b80
	ctx.r[3].s64 = ctx.r[11].s64 + -15232;
	// 82A9FE18: 4BFFFD79  bl 0x82a9fb90
	ctx.lr = 0x82A9FE1C;
	sub_82A9FB90(ctx, base);
	// 82A9FE1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FE20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FE24: 419A0008  beq cr6, 0x82a9fe2c
	if ctx.cr[6].eq {
	pc = 0x82A9FE2C; continue 'dispatch;
	}
	// 82A9FE28: 4B820A69  bl 0x822c0890
	ctx.lr = 0x82A9FE2C;
	sub_822C0890(ctx, base);
	// 82A9FE2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A9FE30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A9FE34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A9FE38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A9FE3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A9FE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A9FE40 size=2312
    let mut pc: u32 = 0x82A9FE40;
    'dispatch: loop {
        match pc {
            0x82A9FE40 => {
    //   block [0x82A9FE40..0x82AA0748)
	// 82A9FE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A9FE44: 48708319  bl 0x831a815c
	ctx.lr = 0x82A9FE48;
	sub_831A8130(ctx, base);
	// 82A9FE48: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82A9FE4C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A9FE50: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A9FE54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A9FE58: 486B47A9  bl 0x83154600
	ctx.lr = 0x82A9FE5C;
	sub_83154600(ctx, base);
	// 82A9FE5C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A9FE60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A9FE64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A9FE68: 4198061C  blt cr6, 0x82aa0484
	if ctx.cr[6].lt {
	pc = 0x82AA0484; continue 'dispatch;
	}
	// 82A9FE6C: 419A0378  beq cr6, 0x82aa01e4
	if ctx.cr[6].eq {
	pc = 0x82AA01E4; continue 'dispatch;
	}
	// 82A9FE70: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A9FE74: 4198012C  blt cr6, 0x82a9ffa0
	if ctx.cr[6].lt {
	pc = 0x82A9FFA0; continue 'dispatch;
	}
	// 82A9FE78: 419A0040  beq cr6, 0x82a9feb8
	if ctx.cr[6].eq {
	pc = 0x82A9FEB8; continue 'dispatch;
	}
	// 82A9FE7C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A9FE80: 409808B8  bge cr6, 0x82aa0738
	if !ctx.cr[6].lt {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82A9FE84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FE88: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A9FE8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9FE90: 4E800421  bctrl
	ctx.lr = 0x82A9FE94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9FE94: 4BD4A47D  bl 0x827ea310
	ctx.lr = 0x82A9FE98;
	sub_827EA310(ctx, base);
	// 82A9FE98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9FE9C: 4182089C  beq 0x82aa0738
	if ctx.cr[0].eq {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82A9FEA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FEA4: 4BE18E45  bl 0x828b8ce8
	ctx.lr = 0x82A9FEA8;
	sub_828B8CE8(ctx, base);
	// 82A9FEA8: 4BDF82F1  bl 0x82898198
	ctx.lr = 0x82A9FEAC;
	sub_82898198(ctx, base);
	// 82A9FEAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A9FEB0: 4BFEC5E9  bl 0x82a8c498
	ctx.lr = 0x82A9FEB4;
	sub_82A8C498(ctx, base);
	// 82A9FEB4: 48000884  b 0x82aa0738
	pc = 0x82AA0738; continue 'dispatch;
	// 82A9FEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A9FEBC: 483B98BD  bl 0x82e59778
	ctx.lr = 0x82A9FEC0;
	sub_82E59778(ctx, base);
	// 82A9FEC0: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A9FEC4: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A9FEC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A9FECC: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A9FED0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A9FED4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A9FED8: 40980860  bge cr6, 0x82aa0738
	if !ctx.cr[6].lt {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82A9FEDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FEE0: 4BE18E09  bl 0x828b8ce8
	ctx.lr = 0x82A9FEE4;
	sub_828B8CE8(ctx, base);
	// 82A9FEE4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82A9FEE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9FEEC: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82A9FEF0: 808B9F6C  lwz r4, -0x6094(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24724 as u32) ) } as u64;
	// 82A9FEF4: 48353B15  bl 0x82df3a08
	ctx.lr = 0x82A9FEF8;
	sub_82DF3A08(ctx, base);
	// 82A9FEF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FEFC: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82A9FF00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FF04: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A9FF08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9FF0C: 4E800421  bctrl
	ctx.lr = 0x82A9FF10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9FF10: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82A9FF14: 48353515  bl 0x82df3428
	ctx.lr = 0x82A9FF18;
	sub_82DF3428(ctx, base);
	// 82A9FF18: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82A9FF1C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A9FF20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9FF24: 4BA6F5A5  bl 0x8250f4c8
	ctx.lr = 0x82A9FF28;
	sub_8250F4C8(ctx, base);
	// 82A9FF28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FF30: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A9FF34: 409A0008  bne cr6, 0x82a9ff3c
	if !ctx.cr[6].eq {
	pc = 0x82A9FF3C; continue 'dispatch;
	}
	// 82A9FF38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A9FF3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FF40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A9FF44: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82A9FF48: 3B8B1FD8  addi r28, r11, 0x1fd8
	ctx.r[28].s64 = ctx.r[11].s64 + 8152;
	// 82A9FF4C: 4BD4C67D  bl 0x827ec5c8
	ctx.lr = 0x82A9FF50;
	sub_827EC5C8(ctx, base);
	// 82A9FF50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A9FF54: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A9FF58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FF5C: 3BCB5A2C  addi r30, r11, 0x5a2c
	ctx.r[30].s64 = ctx.r[11].s64 + 23084;
	// 82A9FF60: 4BE6A4D1  bl 0x8290a430
	ctx.lr = 0x82A9FF64;
	sub_8290A430(ctx, base);
	// 82A9FF64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A9FF68: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A9FF6C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A9FF70: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A9FF74: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A9FF78: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82A9FF7C: 480A5C1D  bl 0x82b45b98
	ctx.lr = 0x82A9FF80;
	sub_82B45B98(ctx, base);
	// 82A9FF80: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A9FF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A9FF88: 419A0008  beq cr6, 0x82a9ff90
	if ctx.cr[6].eq {
	pc = 0x82A9FF90; continue 'dispatch;
	}
	// 82A9FF8C: 4B820905  bl 0x822c0890
	ctx.lr = 0x82A9FF90;
	sub_822C0890(ctx, base);
	// 82A9FF90: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A9FF94: 48351CFD  bl 0x82df1c90
	ctx.lr = 0x82A9FF98;
	sub_82DF1C90(ctx, base);
	// 82A9FF98: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A9FF9C: 480004E0  b 0x82aa047c
	pc = 0x82AA047C; continue 'dispatch;
	// 82A9FFA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FFA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FFA8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A9FFAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A9FFB0: 4E800421  bctrl
	ctx.lr = 0x82A9FFB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A9FFB4: 4BD4A35D  bl 0x827ea310
	ctx.lr = 0x82A9FFB8;
	sub_827EA310(ctx, base);
	// 82A9FFB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A9FFBC: 4182077C  beq 0x82aa0738
	if ctx.cr[0].eq {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82A9FFC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A9FFC4: 4BE18D25  bl 0x828b8ce8
	ctx.lr = 0x82A9FFC8;
	sub_828B8CE8(ctx, base);
	// 82A9FFC8: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A9FFCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A9FFD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A9FFD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A9FFD8: 419A0048  beq cr6, 0x82aa0020
	if ctx.cr[6].eq {
	pc = 0x82AA0020; continue 'dispatch;
	}
	// 82A9FFDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A9FFE0: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A9FFE4: 4BD2F62D  bl 0x827cf610
	ctx.lr = 0x82A9FFE8;
	sub_827CF610(ctx, base);
	// 82A9FFE8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 82A9FFEC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A9FFF0: 4BA6F4D9  bl 0x8250f4c8
	ctx.lr = 0x82A9FFF4;
	sub_8250F4C8(ctx, base);
	// 82A9FFF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A9FFF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A9FFFC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA0000: 409A0008  bne cr6, 0x82aa0008
	if !ctx.cr[6].eq {
	pc = 0x82AA0008; continue 'dispatch;
	}
	// 82AA0004: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA0008: 80BF007C  lwz r5, 0x7c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA000C: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA0010: 4BD2FD91  bl 0x827cfda0
	ctx.lr = 0x82AA0014;
	sub_827CFDA0(ctx, base);
	// 82AA0014: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA0018: 48351C79  bl 0x82df1c90
	ctx.lr = 0x82AA001C;
	sub_82DF1C90(ctx, base);
	// 82AA001C: 939F007C  stw r28, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 82AA0020: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0024: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA0028: 808B9F60  lwz r4, -0x60a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24736 as u32) ) } as u64;
	// 82AA002C: 483539DD  bl 0x82df3a08
	ctx.lr = 0x82AA0030;
	sub_82DF3A08(ctx, base);
	// 82AA0030: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0034: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82AA0038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA003C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA0040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0044: 4E800421  bctrl
	ctx.lr = 0x82AA0048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0048: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA004C: 483533DD  bl 0x82df3428
	ctx.lr = 0x82AA0050;
	sub_82DF3428(ctx, base);
	// 82AA0050: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0054: 4BDC6775  bl 0x828667c8
	ctx.lr = 0x82AA0058;
	sub_828667C8(ctx, base);
	// 82AA0058: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA005C: 4BFE7CC5  bl 0x82a87d20
	ctx.lr = 0x82AA0060;
	sub_82A87D20(ctx, base);
	// 82AA0060: 4B9EF419  bl 0x8248f478
	ctx.lr = 0x82AA0064;
	sub_8248F478(ctx, base);
	// 82AA0064: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0068: 4BDC6761  bl 0x828667c8
	ctx.lr = 0x82AA006C;
	sub_828667C8(ctx, base);
	// 82AA006C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AA0070: 4BFE7CB1  bl 0x82a87d20
	ctx.lr = 0x82AA0074;
	sub_82A87D20(ctx, base);
	// 82AA0074: 4B9EF405  bl 0x8248f478
	ctx.lr = 0x82AA0078;
	sub_8248F478(ctx, base);
	// 82AA0078: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA007C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AA0080: 409A011C  bne cr6, 0x82aa019c
	if !ctx.cr[6].eq {
	pc = 0x82AA019C; continue 'dispatch;
	}
	// 82AA0084: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA0088: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA008C: 41820110  beq 0x82aa019c
	if ctx.cr[0].eq {
	pc = 0x82AA019C; continue 'dispatch;
	}
	// 82AA0090: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82AA0094: 83BF0080  lwz r29, 0x80(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA0098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA009C: 4BE6A395  bl 0x8290a430
	ctx.lr = 0x82AA00A0;
	sub_8290A430(ctx, base);
	// 82AA00A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA00A4: 480A5C85  bl 0x82b45d28
	ctx.lr = 0x82AA00A8;
	sub_82B45D28(ctx, base);
	// 82AA00A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA00AC: 83BF0080  lwz r29, 0x80(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA00B0: 4BE6A381  bl 0x8290a430
	ctx.lr = 0x82AA00B4;
	sub_8290A430(ctx, base);
	// 82AA00B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA00B8: 480A5CC9  bl 0x82b45d80
	ctx.lr = 0x82AA00BC;
	sub_82B45D80(ctx, base);
	// 82AA00BC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA00C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA00C4: 409A00C0  bne cr6, 0x82aa0184
	if !ctx.cr[6].eq {
	pc = 0x82AA0184; continue 'dispatch;
	}
	// 82AA00C8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA00CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA00D0: 388B23C4  addi r4, r11, 0x23c4
	ctx.r[4].s64 = ctx.r[11].s64 + 9156;
	// 82AA00D4: 48353935  bl 0x82df3a08
	ctx.lr = 0x82AA00D8;
	sub_82DF3A08(ctx, base);
	// 82AA00D8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA00DC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA00E0: 388B605C  addi r4, r11, 0x605c
	ctx.r[4].s64 = ctx.r[11].s64 + 24668;
	// 82AA00E4: 48353925  bl 0x82df3a08
	ctx.lr = 0x82AA00E8;
	sub_82DF3A08(ctx, base);
	// 82AA00E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA00EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA00F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA00F4: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82AA00F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA00FC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0100: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82AA0104: C1AA95A0  lfs f13, -0x6a60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA0108: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA010C: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA0110: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AA0114: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA0118: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA011C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA0120: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA0124: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA0128: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA012C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA0130: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AA0134: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA0138: 837F0060  lwz r27, 0x60(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA013C: 4BD4C48D  bl 0x827ec5c8
	ctx.lr = 0x82AA0140;
	sub_827EC5C8(ctx, base);
	// 82AA0140: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA0144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA0148: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA014C: 4BA6F37D  bl 0x8250f4c8
	ctx.lr = 0x82AA0150;
	sub_8250F4C8(ctx, base);
	// 82AA0150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA0154: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA0158: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA015C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA0160: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA0164: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA0168: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA016C: 4BD2FF55  bl 0x827d00c0
	ctx.lr = 0x82AA0170;
	sub_827D00C0(ctx, base);
	// 82AA0170: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82AA0174: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA0178: 483532B1  bl 0x82df3428
	ctx.lr = 0x82AA017C;
	sub_82DF3428(ctx, base);
	// 82AA017C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA0180: 483532A9  bl 0x82df3428
	ctx.lr = 0x82AA0184;
	sub_82DF3428(ctx, base);
	// 82AA0184: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0188: 9B9F006C  stb r28, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	// 82AA018C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA0190: C00BC480  lfs f0, -0x3b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0194: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82AA0198: 48000044  b 0x82aa01dc
	pc = 0x82AA01DC; continue 'dispatch;
	// 82AA019C: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82AA01A0: 83BF0080  lwz r29, 0x80(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA01A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA01A8: 4BE6A289  bl 0x8290a430
	ctx.lr = 0x82AA01AC;
	sub_8290A430(ctx, base);
	// 82AA01AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA01B0: 480A5B79  bl 0x82b45d28
	ctx.lr = 0x82AA01B4;
	sub_82B45D28(ctx, base);
	// 82AA01B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA01B8: 83DF0080  lwz r30, 0x80(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA01BC: 4BE6A275  bl 0x8290a430
	ctx.lr = 0x82AA01C0;
	sub_8290A430(ctx, base);
	// 82AA01C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA01C4: 480A5E3D  bl 0x82b46000
	ctx.lr = 0x82AA01C8;
	sub_82B46000(ctx, base);
	// 82AA01C8: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA01CC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA01D0: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82AA01D4: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA01D8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA01DC: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA01E0: 48000558  b 0x82aa0738
	pc = 0x82AA0738; continue 'dispatch;
	// 82AA01E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA01E8: 483B9591  bl 0x82e59778
	ctx.lr = 0x82AA01EC;
	sub_82E59778(ctx, base);
	// 82AA01EC: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA01F0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA01F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA01F8: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA01FC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA0200: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA0204: 40980534  bge cr6, 0x82aa0738
	if !ctx.cr[6].lt {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82AA0208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA020C: 4BE18ADD  bl 0x828b8ce8
	ctx.lr = 0x82AA0210;
	sub_828B8CE8(ctx, base);
	// 82AA0210: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA0214: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA0218: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA021C: 41820010  beq 0x82aa022c
	if ctx.cr[0].eq {
	pc = 0x82AA022C; continue 'dispatch;
	}
	// 82AA0220: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0224: 808B9F64  lwz r4, -0x609c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24732 as u32) ) } as u64;
	// 82AA0228: 4800000C  b 0x82aa0234
	pc = 0x82AA0234; continue 'dispatch;
	// 82AA022C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0230: 808B9F68  lwz r4, -0x6098(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24728 as u32) ) } as u64;
	// 82AA0234: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA0238: 483537D1  bl 0x82df3a08
	ctx.lr = 0x82AA023C;
	sub_82DF3A08(ctx, base);
	// 82AA023C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0240: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82AA0244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0248: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA024C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0250: 4E800421  bctrl
	ctx.lr = 0x82AA0254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0254: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA0258: 483531D1  bl 0x82df3428
	ctx.lr = 0x82AA025C;
	sub_82DF3428(ctx, base);
	// 82AA025C: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA0260: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AA0264: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AA0268: 419A0100  beq cr6, 0x82aa0368
	if ctx.cr[6].eq {
	pc = 0x82AA0368; continue 'dispatch;
	}
	// 82AA026C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA0270: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA0274: 4BD2F39D  bl 0x827cf610
	ctx.lr = 0x82AA0278;
	sub_827CF610(ctx, base);
	// 82AA0278: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82AA027C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA0280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA0284: 4BA6F245  bl 0x8250f4c8
	ctx.lr = 0x82AA0288;
	sub_8250F4C8(ctx, base);
	// 82AA0288: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA028C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0290: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA0294: 409A0008  bne cr6, 0x82aa029c
	if !ctx.cr[6].eq {
	pc = 0x82AA029C; continue 'dispatch;
	}
	// 82AA0298: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA029C: 80BF0078  lwz r5, 0x78(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA02A0: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA02A4: 4BD2FAFD  bl 0x827cfda0
	ctx.lr = 0x82AA02A8;
	sub_827CFDA0(ctx, base);
	// 82AA02A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA02AC: 483519E5  bl 0x82df1c90
	ctx.lr = 0x82AA02B0;
	sub_82DF1C90(ctx, base);
	// 82AA02B0: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 82AA02B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA02B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA02BC: 388B23C4  addi r4, r11, 0x23c4
	ctx.r[4].s64 = ctx.r[11].s64 + 9156;
	// 82AA02C0: 48353749  bl 0x82df3a08
	ctx.lr = 0x82AA02C4;
	sub_82DF3A08(ctx, base);
	// 82AA02C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA02C8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA02CC: 388B6044  addi r4, r11, 0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + 24644;
	// 82AA02D0: 48353739  bl 0x82df3a08
	ctx.lr = 0x82AA02D4;
	sub_82DF3A08(ctx, base);
	// 82AA02D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA02D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA02DC: D3E1006C  stfs f31, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA02E0: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82AA02E4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA02E8: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA02EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA02F0: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA02F4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82AA02F8: C00B95A0  lfs f0, -0x6a60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA02FC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AA0300: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA0304: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82AA0308: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA030C: D3C10088  stfs f30, 0x88(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA0310: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA0314: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AA0318: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA031C: 835F0060  lwz r26, 0x60(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA0320: 4BD4C2A9  bl 0x827ec5c8
	ctx.lr = 0x82AA0324;
	sub_827EC5C8(ctx, base);
	// 82AA0324: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA0328: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA032C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA0330: 4BA6F199  bl 0x8250f4c8
	ctx.lr = 0x82AA0334;
	sub_8250F4C8(ctx, base);
	// 82AA0334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA0338: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA033C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA0340: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82AA0344: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA0348: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA034C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA0350: 4BD2FD71  bl 0x827d00c0
	ctx.lr = 0x82AA0354;
	sub_827D00C0(ctx, base);
	// 82AA0354: 907F007C  stw r3, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82AA0358: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA035C: 483530CD  bl 0x82df3428
	ctx.lr = 0x82AA0360;
	sub_82DF3428(ctx, base);
	// 82AA0360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA0364: 483530C5  bl 0x82df3428
	ctx.lr = 0x82AA0368;
	sub_82DF3428(ctx, base);
	// 82AA0368: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA036C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA0370: 41820010  beq 0x82aa0380
	if ctx.cr[0].eq {
	pc = 0x82AA0380; continue 'dispatch;
	}
	// 82AA0374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA0378: 396BFE6C  addi r11, r11, -0x194
	ctx.r[11].s64 = ctx.r[11].s64 + -404;
	// 82AA037C: 4800000C  b 0x82aa0388
	pc = 0x82AA0388; continue 'dispatch;
	// 82AA0380: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AA0384: 396BFE78  addi r11, r11, -0x188
	ctx.r[11].s64 = ctx.r[11].s64 + -392;
	// 82AA0388: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82AA038C: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82AA0390: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82AA0394: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA0398: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82AA039C: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 82AA03A0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA03A4: 4BFE3545  bl 0x82a838e8
	ctx.lr = 0x82AA03A8;
	sub_82A838E8(ctx, base);
	// 82AA03A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA03AC: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82AA03B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA03B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA03B8: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82AA03BC: 419A0024  beq cr6, 0x82aa03e0
	if ctx.cr[6].eq {
	pc = 0x82AA03E0; continue 'dispatch;
	}
	// 82AA03C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA03C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA03C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA03CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA03D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA03D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA03D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA03DC: 4082FFE8  bne 0x82aa03c4
	if !ctx.cr[0].eq {
	pc = 0x82AA03C4; continue 'dispatch;
	}
	// 82AA03E0: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 82AA03E4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA03E8: 4BA6F0E1  bl 0x8250f4c8
	ctx.lr = 0x82AA03EC;
	sub_8250F4C8(ctx, base);
	// 82AA03EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA03F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA03F4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA03F8: 409A0008  bne cr6, 0x82aa0400
	if !ctx.cr[6].eq {
	pc = 0x82AA0400; continue 'dispatch;
	}
	// 82AA03FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA0400: 3BC100C8  addi r30, r1, 0xc8
	ctx.r[30].s64 = ctx.r[1].s64 + 200;
	// 82AA0404: 4BA68215  bl 0x82508618
	ctx.lr = 0x82AA0408;
	sub_82508618(ctx, base);
	// 82AA0408: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA040C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA0410: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA0414: 388B5F70  addi r4, r11, 0x5f70
	ctx.r[4].s64 = ctx.r[11].s64 + 24432;
	// 82AA0418: 38A00150  li r5, 0x150
	ctx.r[5].s64 = 336;
	// 82AA041C: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 82AA0420: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA0424: 483B861D  bl 0x82e58a40
	ctx.lr = 0x82AA0428;
	sub_82E58A40(ctx, base);
	// 82AA0428: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA042C: 48351865  bl 0x82df1c90
	ctx.lr = 0x82AA0430;
	sub_82DF1C90(ctx, base);
	// 82AA0430: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AA0434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0438: 419A0008  beq cr6, 0x82aa0440
	if ctx.cr[6].eq {
	pc = 0x82AA0440; continue 'dispatch;
	}
	// 82AA043C: 4B820455  bl 0x822c0890
	ctx.lr = 0x82AA0440;
	sub_822C0890(ctx, base);
	// 82AA0440: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AA0444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0448: 419A0008  beq cr6, 0x82aa0450
	if ctx.cr[6].eq {
	pc = 0x82AA0450; continue 'dispatch;
	}
	// 82AA044C: 4B820445  bl 0x822c0890
	ctx.lr = 0x82AA0450;
	sub_822C0890(ctx, base);
	// 82AA0450: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0454: 4BDC6375  bl 0x828667c8
	ctx.lr = 0x82AA0458;
	sub_828667C8(ctx, base);
	// 82AA0458: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA045C: 4BFE78C5  bl 0x82a87d20
	ctx.lr = 0x82AA0460;
	sub_82A87D20(ctx, base);
	// 82AA0460: 4B9EEF89  bl 0x8248f3e8
	ctx.lr = 0x82AA0464;
	sub_8248F3E8(ctx, base);
	// 82AA0464: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0468: 4BDC6361  bl 0x828667c8
	ctx.lr = 0x82AA046C;
	sub_828667C8(ctx, base);
	// 82AA046C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AA0470: 4BFE78B1  bl 0x82a87d20
	ctx.lr = 0x82AA0474;
	sub_82A87D20(ctx, base);
	// 82AA0474: 4B9EEF75  bl 0x8248f3e8
	ctx.lr = 0x82AA0478;
	sub_8248F3E8(ctx, base);
	// 82AA0478: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AA047C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA0480: 480002B8  b 0x82aa0738
	pc = 0x82AA0738; continue 'dispatch;
	// 82AA0484: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA048C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA0490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0494: 4E800421  bctrl
	ctx.lr = 0x82AA0498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0498: 4BD49E79  bl 0x827ea310
	ctx.lr = 0x82AA049C;
	sub_827EA310(ctx, base);
	// 82AA049C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA04A0: 41820298  beq 0x82aa0738
	if ctx.cr[0].eq {
	pc = 0x82AA0738; continue 'dispatch;
	}
	// 82AA04A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA04A8: 4BE18841  bl 0x828b8ce8
	ctx.lr = 0x82AA04AC;
	sub_828B8CE8(ctx, base);
	// 82AA04AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA04B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA04B4: 3B8B23C4  addi r28, r11, 0x23c4
	ctx.r[28].s64 = ctx.r[11].s64 + 9156;
	// 82AA04B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA04BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA04C0: 48353549  bl 0x82df3a08
	ctx.lr = 0x82AA04C4;
	sub_82DF3A08(ctx, base);
	// 82AA04C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA04C8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA04CC: 388B605C  addi r4, r11, 0x605c
	ctx.r[4].s64 = ctx.r[11].s64 + 24668;
	// 82AA04D0: 48353539  bl 0x82df3a08
	ctx.lr = 0x82AA04D4;
	sub_82DF3A08(ctx, base);
	// 82AA04D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA04D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA04DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA04E0: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82AA04E4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82AA04E8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA04EC: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82AA04F0: C00A95A0  lfs f0, -0x6a60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA04F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA04F8: C3C908A8  lfs f30, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA04FC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AA0500: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA0504: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82AA0508: D3C10088  stfs f30, 0x88(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA050C: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA0510: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA0514: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA0518: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA051C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA0520: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AA0524: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA0528: 835F0060  lwz r26, 0x60(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA052C: 4BD4C09D  bl 0x827ec5c8
	ctx.lr = 0x82AA0530;
	sub_827EC5C8(ctx, base);
	// 82AA0530: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA0534: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA0538: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA053C: 4BA6EF8D  bl 0x8250f4c8
	ctx.lr = 0x82AA0540;
	sub_8250F4C8(ctx, base);
	// 82AA0540: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA0544: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA0548: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA054C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82AA0550: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA0554: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA0558: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA055C: 4BD2FB65  bl 0x827d00c0
	ctx.lr = 0x82AA0560;
	sub_827D00C0(ctx, base);
	// 82AA0560: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82AA0564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA0568: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA056C: 4BA6EF5D  bl 0x8250f4c8
	ctx.lr = 0x82AA0570;
	sub_8250F4C8(ctx, base);
	// 82AA0570: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0578: 3B6BFFFC  addi r27, r11, -4
	ctx.r[27].s64 = ctx.r[11].s64 + -4;
	// 82AA057C: 409A0008  bne cr6, 0x82aa0584
	if !ctx.cr[6].eq {
	pc = 0x82AA0584; continue 'dispatch;
	}
	// 82AA0580: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AA0584: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA0588: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA058C: 4BD4C03D  bl 0x827ec5c8
	ctx.lr = 0x82AA0590;
	sub_827EC5C8(ctx, base);
	// 82AA0590: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA0594: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0598: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA059C: 3BAB5E9C  addi r29, r11, 0x5e9c
	ctx.r[29].s64 = ctx.r[11].s64 + 24220;
	// 82AA05A0: 4BE69E91  bl 0x8290a430
	ctx.lr = 0x82AA05A4;
	sub_8290A430(ctx, base);
	// 82AA05A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA05A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA05AC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82AA05B0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA05B4: 480A5D35  bl 0x82b462e8
	ctx.lr = 0x82AA05B8;
	sub_82B462E8(ctx, base);
	// 82AA05B8: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82AA05BC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA05C0: 483516D1  bl 0x82df1c90
	ctx.lr = 0x82AA05C4;
	sub_82DF1C90(ctx, base);
	// 82AA05C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA05C8: 4BE5F429  bl 0x828ff9f0
	ctx.lr = 0x82AA05CC;
	sub_828FF9F0(ctx, base);
	// 82AA05CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA05D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA05D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA05D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA05DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA05E0: 4E800421  bctrl
	ctx.lr = 0x82AA05E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA05E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA05E8: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82AA05EC: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82AA05F0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA05F4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA05F8: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0748 size=184
    let mut pc: u32 = 0x82AA0748;
    'dispatch: loop {
        match pc {
            0x82AA0748 => {
    //   block [0x82AA0748..0x82AA0800)
	// 82AA0748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA074C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA075C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0760: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA0764: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AA0768: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82AA076C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0770: 4B9F1B99  bl 0x82492308
	ctx.lr = 0x82AA0774;
	sub_82492308(ctx, base);
	// 82AA0774: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA0778: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AA077C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA0780: 419A0064  beq cr6, 0x82aa07e4
	if ctx.cr[6].eq {
	pc = 0x82AA07E4; continue 'dispatch;
	}
	// 82AA0784: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA0788: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82AA078C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0790: 419A0018  beq cr6, 0x82aa07a8
	if ctx.cr[6].eq {
	pc = 0x82AA07A8; continue 'dispatch;
	}
	// 82AA0794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA079C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA07A0: 4E800421  bctrl
	ctx.lr = 0x82AA07A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA07A4: 4800000C  b 0x82aa07b0
	pc = 0x82AA07B0; continue 'dispatch;
	// 82AA07A8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA07AC: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA07B0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA07B4: 388BC4CC  addi r4, r11, -0x3b34
	ctx.r[4].s64 = ctx.r[11].s64 + -15156;
	// 82AA07B8: 48707941  bl 0x831a80f8
	ctx.lr = 0x82AA07BC;
	sub_831A80F8(ctx, base);
	// 82AA07BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA07C0: 41820024  beq 0x82aa07e4
	if ctx.cr[0].eq {
	pc = 0x82AA07E4; continue 'dispatch;
	}
	// 82AA07C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA07C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA07CC: 4BFFF05D  bl 0x82a9f828
	ctx.lr = 0x82AA07D0;
	sub_82A9F828(ctx, base);
	// 82AA07D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA07D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA07D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA07DC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA07E0: 48000008  b 0x82aa07e8
	pc = 0x82AA07E8; continue 'dispatch;
	// 82AA07E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA07E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA07EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA07F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA07F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA07F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA07FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0800 size=612
    let mut pc: u32 = 0x82AA0800;
    'dispatch: loop {
        match pc {
            0x82AA0800 => {
    //   block [0x82AA0800..0x82AA0A64)
	// 82AA0800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0804: 48707951  bl 0x831a8154
	ctx.lr = 0x82AA0808;
	sub_831A8130(ctx, base);
	// 82AA0808: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA080C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AA0810: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0814: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 82AA0818: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82AA081C: 486B3DE5  bl 0x83154600
	ctx.lr = 0x82AA0820;
	sub_83154600(ctx, base);
	// 82AA0820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0824: 4BE184C5  bl 0x828b8ce8
	ctx.lr = 0x82AA0828;
	sub_828B8CE8(ctx, base);
	// 82AA0828: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA082C: 4BFE0E8D  bl 0x82a816b8
	ctx.lr = 0x82AA0830;
	sub_82A816B8(ctx, base);
	// 82AA0830: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0834: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82AA0838: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA083C: 396BC480  addi r11, r11, -0x3b80
	ctx.r[11].s64 = ctx.r[11].s64 + -15232;
	// 82AA0840: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA0844: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA0848: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82AA084C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA0850: 39485F1C  addi r10, r8, 0x5f1c
	ctx.r[10].s64 = ctx.r[8].s64 + 24348;
	// 82AA0854: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA0858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA085C: 8089C478  lwz r4, -0x3b88(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-15240 as u32) ) } as u64;
	// 82AA0860: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AA0864: 483531A5  bl 0x82df3a08
	ctx.lr = 0x82AA0868;
	sub_82DF3A08(ctx, base);
	// 82AA0868: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA086C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0874: 4BFFFED5  bl 0x82aa0748
	ctx.lr = 0x82AA0878;
	sub_82AA0748(ctx, base);
	// 82AA0878: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA087C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0880: 48352BA9  bl 0x82df3428
	ctx.lr = 0x82AA0884;
	sub_82DF3428(ctx, base);
	// 82AA0884: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0888: 41820010  beq 0x82aa0898
	if ctx.cr[0].eq {
	pc = 0x82AA0898; continue 'dispatch;
	}
	// 82AA088C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA0890: 917E0068  stw r11, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA0894: 48000034  b 0x82aa08c8
	pc = 0x82AA08C8; continue 'dispatch;
	// 82AA0898: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA089C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA08A0: 4BFE12C1  bl 0x82a81b60
	ctx.lr = 0x82AA08A4;
	sub_82A81B60(ctx, base);
	// 82AA08A4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA08A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA08AC: 7D635B96  divwu r11, r3, r11
	ctx.r[11].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 82AA08B0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA08B4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 * 3;
	// 82AA08B8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82AA08BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA08C0: 917E0068  stw r11, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA08C4: 4BFE12AD  bl 0x82a81b70
	ctx.lr = 0x82AA08C8;
	sub_82A81B70(ctx, base);
	// 82AA08C8: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA08CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA08D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA08D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82AA08D8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AA08DC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AA08E0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82AA08E4: 997E006C  stb r11, 0x6c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82AA08E8: 4BFE7DA9  bl 0x82a88690
	ctx.lr = 0x82AA08EC;
	sub_82A88690(ctx, base);
	// 82AA08EC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA08F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA08F4: 808BCA1C  lwz r4, -0x35e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13796 as u32) ) } as u64;
	// 82AA08F8: 48353111  bl 0x82df3a08
	ctx.lr = 0x82AA08FC;
	sub_82DF3A08(ctx, base);
	// 82AA08FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0904: 4BD4EE6D  bl 0x827ef770
	ctx.lr = 0x82AA0908;
	sub_827EF770(ctx, base);
	// 82AA0908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA090C: 48352B1D  bl 0x82df3428
	ctx.lr = 0x82AA0910;
	sub_82DF3428(ctx, base);
	// 82AA0910: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0918: 808B9F5C  lwz r4, -0x60a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24740 as u32) ) } as u64;
	// 82AA091C: 483530ED  bl 0x82df3a08
	ctx.lr = 0x82AA0920;
	sub_82DF3A08(ctx, base);
	// 82AA0920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0924: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA092C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA0930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0934: 4E800421  bctrl
	ctx.lr = 0x82AA0938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA093C: 48352AED  bl 0x82df3428
	ctx.lr = 0x82AA0940;
	sub_82DF3428(ctx, base);
	// 82AA0940: 3BFC0010  addi r31, r28, 0x10
	ctx.r[31].s64 = ctx.r[28].s64 + 16;
	// 82AA0944: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA0948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA094C: 4BA6EB7D  bl 0x8250f4c8
	ctx.lr = 0x82AA0950;
	sub_8250F4C8(ctx, base);
	// 82AA0950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0958: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82AA095C: 409A0008  bne cr6, 0x82aa0964
	if !ctx.cr[6].eq {
	pc = 0x82AA0964; continue 'dispatch;
	}
	// 82AA0960: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82AA0964: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA096C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA0970: 3B2B1FD8  addi r25, r11, 0x1fd8
	ctx.r[25].s64 = ctx.r[11].s64 + 8152;
	// 82AA0974: 4BD4BC55  bl 0x827ec5c8
	ctx.lr = 0x82AA0978;
	sub_827EC5C8(ctx, base);
	// 82AA0978: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA097C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0984: 3AEB24CC  addi r23, r11, 0x24cc
	ctx.r[23].s64 = ctx.r[11].s64 + 9420;
	// 82AA0988: 4BE69AA9  bl 0x8290a430
	ctx.lr = 0x82AA098C;
	sub_8290A430(ctx, base);
	// 82AA098C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA0990: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA0994: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA0998: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82AA099C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82AA09A0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82AA09A4: 480A51F5  bl 0x82b45b98
	ctx.lr = 0x82AA09A8;
	sub_82B45B98(ctx, base);
	// 82AA09A8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA09AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA09B0: 419A0008  beq cr6, 0x82aa09b8
	if ctx.cr[6].eq {
	pc = 0x82AA09B8; continue 'dispatch;
	}
	// 82AA09B4: 4B81FEDD  bl 0x822c0890
	ctx.lr = 0x82AA09B8;
	sub_822C0890(ctx, base);
	// 82AA09B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA09BC: 483512D5  bl 0x82df1c90
	ctx.lr = 0x82AA09C0;
	sub_82DF1C90(ctx, base);
	// 82AA09C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA09C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA09C8: 388B5F70  addi r4, r11, 0x5f70
	ctx.r[4].s64 = ctx.r[11].s64 + 24432;
	// 82AA09CC: 38A000FB  li r5, 0xfb
	ctx.r[5].s64 = 251;
	// 82AA09D0: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82AA09D4: 48351A15  bl 0x82df23e8
	ctx.lr = 0x82AA09D8;
	sub_82DF23E8(ctx, base);
	// 82AA09D8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA09DC: 41820034  beq 0x82aa0a10
	if ctx.cr[0].eq {
	pc = 0x82AA0A10; continue 'dispatch;
	}
	// 82AA09E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA09E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA09E8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82AA09EC: 4BA6EADD  bl 0x8250f4c8
	ctx.lr = 0x82AA09F0;
	sub_8250F4C8(ctx, base);
	// 82AA09F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA09F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA09F8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA09FC: 409A0008  bne cr6, 0x82aa0a04
	if !ctx.cr[6].eq {
	pc = 0x82AA0A04; continue 'dispatch;
	}
	// 82AA0A00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA0A04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0A08: 4BD2FB49  bl 0x827d0550
	ctx.lr = 0x82AA0A0C;
	sub_827D0550(ctx, base);
	// 82AA0A0C: 48000008  b 0x82aa0a14
	pc = 0x82AA0A14; continue 'dispatch;
	// 82AA0A10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA0A14: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA0A18: 907E0060  stw r3, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82AA0A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0A20: 419A001C  beq cr6, 0x82aa0a3c
	if ctx.cr[6].eq {
	pc = 0x82AA0A3C; continue 'dispatch;
	}
	// 82AA0A24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0A28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA0A2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0A30: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0A38: 4E800421  bctrl
	ctx.lr = 0x82AA0A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0A3C: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0A40: 4182000C  beq 0x82aa0a4c
	if ctx.cr[0].eq {
	pc = 0x82AA0A4C; continue 'dispatch;
	}
	// 82AA0A44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA0A48: 48351249  bl 0x82df1c90
	ctx.lr = 0x82AA0A4C;
	sub_82DF1C90(ctx, base);
	// 82AA0A4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA0A50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA0A54: 4BFE3F15  bl 0x82a84968
	ctx.lr = 0x82AA0A58;
	sub_82A84968(ctx, base);
	// 82AA0A58: 937E0070  stw r27, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82AA0A5C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AA0A60: 48707744  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0A68 size=96
    let mut pc: u32 = 0x82AA0A68;
    'dispatch: loop {
        match pc {
            0x82AA0A68 => {
    //   block [0x82AA0A68..0x82AA0AC8)
	// 82AA0A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0A78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0A7C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0A80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0A88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0A8C: 808BC478  lwz r4, -0x3b88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15240 as u32) ) } as u64;
	// 82AA0A90: 48352F79  bl 0x82df3a08
	ctx.lr = 0x82AA0A94;
	sub_82DF3A08(ctx, base);
	// 82AA0A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0A98: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA0A9C: 4B88BDA5  bl 0x8232c840
	ctx.lr = 0x82AA0AA0;
	sub_8232C840(ctx, base);
	// 82AA0AA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA0AA4: 4BFFEF45  bl 0x82a9f9e8
	ctx.lr = 0x82AA0AA8;
	sub_82A9F9E8(ctx, base);
	// 82AA0AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0AAC: 4835297D  bl 0x82df3428
	ctx.lr = 0x82AA0AB0;
	sub_82DF3428(ctx, base);
	// 82AA0AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0ABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA0AC8 size=20
    let mut pc: u32 = 0x82AA0AC8;
    'dispatch: loop {
        match pc {
            0x82AA0AC8 => {
    //   block [0x82AA0AC8..0x82AA0ADC)
	// 82AA0AC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA0ACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA0AD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA0AD4: 994B0098  stb r10, 0x98(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u8 ) };
	// 82AA0AD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0AE0 size=136
    let mut pc: u32 = 0x82AA0AE0;
    'dispatch: loop {
        match pc {
            0x82AA0AE0 => {
    //   block [0x82AA0AE0..0x82AA0B68)
	// 82AA0AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0AE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0AEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0AF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0AF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0AFC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82AA0B00: 409A0020  bne cr6, 0x82aa0b20
	if !ctx.cr[6].eq {
	pc = 0x82AA0B20; continue 'dispatch;
	}
	// 82AA0B04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA0B08: 419A0048  beq cr6, 0x82aa0b50
	if ctx.cr[6].eq {
	pc = 0x82AA0B50; continue 'dispatch;
	}
	// 82AA0B0C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82AA0B10: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA0B14: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82AA0B18: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82AA0B1C: 48000034  b 0x82aa0b50
	pc = 0x82AA0B50; continue 'dispatch;
	// 82AA0B20: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82AA0B24: 419A002C  beq cr6, 0x82aa0b50
	if ctx.cr[6].eq {
	pc = 0x82AA0B50; continue 'dispatch;
	}
	// 82AA0B28: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0B2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0B30: 388BC718  addi r4, r11, -0x38e8
	ctx.r[4].s64 = ctx.r[11].s64 + -14568;
	// 82AA0B34: 487075C5  bl 0x831a80f8
	ctx.lr = 0x82AA0B38;
	sub_831A80F8(ctx, base);
	// 82AA0B38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0B3C: 4182000C  beq 0x82aa0b48
	if ctx.cr[0].eq {
	pc = 0x82AA0B48; continue 'dispatch;
	}
	// 82AA0B40: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA0B44: 4800000C  b 0x82aa0b50
	pc = 0x82AA0B50; continue 'dispatch;
	// 82AA0B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0B4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0B50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0B5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0B60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA0B68 size=140
    let mut pc: u32 = 0x82AA0B68;
    'dispatch: loop {
        match pc {
            0x82AA0B68 => {
    //   block [0x82AA0B68..0x82AA0BF4)
	// 82AA0B68: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA0B6C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82AA0B70: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82AA0B74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA0B78: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA0B7C: C00908A8  lfs f0, 0x8a8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0B80: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82AA0B84: C168D86C  lfs f11, -0x2794(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA0B88: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82AA0B8C: C14795A0  lfs f10, -0x6a60(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AA0B90: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82AA0B94: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 82AA0B98: C1AB9584  lfs f13, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA0B9C: C18AD72C  lfs f12, -0x28d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA0BA0: 3963001C  addi r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 + 28;
	// 82AA0BA4: C126D5B8  lfs f9, -0x2a48(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AA0BA8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82AA0BAC: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AA0BB0: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA0BB4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA0BB8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82AA0BBC: C189A1C4  lfs f12, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA0BC0: C1A8D7BC  lfs f13, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA0BC4: C0077BC4  lfs f0, 0x7bc4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0BC8: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AA0BCC: D1430014  stfs f10, 0x14(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82AA0BD0: D1230018  stfs f9, 0x18(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82AA0BD4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AA0BD8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA0BDC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA0BE0: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA0BE4: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AA0BE8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82AA0BEC: 4080FFE8  bge 0x82aa0bd4
	if !ctx.cr[0].lt {
	pc = 0x82AA0BD4; continue 'dispatch;
	}
	// 82AA0BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0BF8 size=104
    let mut pc: u32 = 0x82AA0BF8;
    'dispatch: loop {
        match pc {
            0x82AA0BF8 => {
    //   block [0x82AA0BF8..0x82AA0C60)
	// 82AA0BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0BFC: 48707571  bl 0x831a816c
	ctx.lr = 0x82AA0C00;
	sub_831A8130(ctx, base);
	// 82AA0C00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0C04: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA0C08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA0C0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0C10: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0C14: 41820034  beq 0x82aa0c48
	if ctx.cr[0].eq {
	pc = 0x82AA0C48; continue 'dispatch;
	}
	// 82AA0C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0C1C: 48708D6D  bl 0x831a9988
	ctx.lr = 0x82AA0C20;
	sub_831A9988(ctx, base);
	// 82AA0C20: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0C24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA0C28: 386B99A8  addi r3, r11, -0x6658
	ctx.r[3].s64 = ctx.r[11].s64 + -26200;
	// 82AA0C2C: 487074CD  bl 0x831a80f8
	ctx.lr = 0x82AA0C30;
	sub_831A80F8(ctx, base);
	// 82AA0C30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA0C34: 41820014  beq 0x82aa0c48
	if ctx.cr[0].eq {
	pc = 0x82AA0C48; continue 'dispatch;
	}
	// 82AA0C38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA0C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0C40: 4BFFFE89  bl 0x82aa0ac8
	ctx.lr = 0x82AA0C44;
	sub_82AA0AC8(ctx, base);
	// 82AA0C44: 48000014  b 0x82aa0c58
	pc = 0x82AA0C58; continue 'dispatch;
	// 82AA0C48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA0C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA0C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA0C54: 486DD835  bl 0x8317e488
	ctx.lr = 0x82AA0C58;
	sub_8317E488(ctx, base);
	// 82AA0C58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0C5C: 48707560  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0C60 size=72
    let mut pc: u32 = 0x82AA0C60;
    'dispatch: loop {
        match pc {
            0x82AA0C60 => {
    //   block [0x82AA0C60..0x82AA0CA8)
	// 82AA0C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0C6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0C74: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA0C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0C7C: 419A0008  beq cr6, 0x82aa0c84
	if ctx.cr[6].eq {
	pc = 0x82AA0C84; continue 'dispatch;
	}
	// 82AA0C80: 4BEDBE79  bl 0x8297caf8
	ctx.lr = 0x82AA0C84;
	sub_8297CAF8(ctx, base);
	// 82AA0C84: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA0C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0C8C: 419A0008  beq cr6, 0x82aa0c94
	if ctx.cr[6].eq {
	pc = 0x82AA0C94; continue 'dispatch;
	}
	// 82AA0C90: 4BEDBE69  bl 0x8297caf8
	ctx.lr = 0x82AA0C94;
	sub_8297CAF8(ctx, base);
	// 82AA0C94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA0C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0CA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0CA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA0CA8 size=160
    let mut pc: u32 = 0x82AA0CA8;
    'dispatch: loop {
        match pc {
            0x82AA0CA8 => {
    //   block [0x82AA0CA8..0x82AA0D48)
	// 82AA0CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0CAC: 487074C1  bl 0x831a816c
	ctx.lr = 0x82AA0CB0;
	sub_831A8130(ctx, base);
	// 82AA0CB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0CB4: 486B394D  bl 0x83154600
	ctx.lr = 0x82AA0CB8;
	sub_83154600(ctx, base);
	// 82AA0CB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA0CBC: 4BE1802D  bl 0x828b8ce8
	ctx.lr = 0x82AA0CC0;
	sub_828B8CE8(ctx, base);
	// 82AA0CC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0CC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA0CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0CCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0CD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0CD4: 4E800421  bctrl
	ctx.lr = 0x82AA0CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0CD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0CDC: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 82AA0CE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA0CE4: 4BE68975  bl 0x82909658
	ctx.lr = 0x82AA0CE8;
	sub_82909658(ctx, base);
	// 82AA0CE8: C1A10064  lfs f13, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA0CEC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA0CF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA0CF4: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82AA0CF8: C00BE418  lfs f0, -0x1be8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0CFC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82AA0D00: 40980040  bge cr6, 0x82aa0d40
	if !ctx.cr[6].lt {
	pc = 0x82AA0D40; continue 'dispatch;
	}
	// 82AA0D04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA0D08: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AA0D0C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA0D10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0D14: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA0D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0D1C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82AA0D20: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AA0D24: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA0D28: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82AA0D2C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82AA0D30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0D34: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA0D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0D3C: 4E800421  bctrl
	ctx.lr = 0x82AA0D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0D40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA0D44: 48707478  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0D48 size=164
    let mut pc: u32 = 0x82AA0D48;
    'dispatch: loop {
        match pc {
            0x82AA0D48 => {
    //   block [0x82AA0D48..0x82AA0DEC)
	// 82AA0D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0D4C: 48707421  bl 0x831a816c
	ctx.lr = 0x82AA0D50;
	sub_831A8130(ctx, base);
	// 82AA0D50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0D58: 486B38A9  bl 0x83154600
	ctx.lr = 0x82AA0D5C;
	sub_83154600(ctx, base);
	// 82AA0D5C: 4BE17F8D  bl 0x828b8ce8
	ctx.lr = 0x82AA0D60;
	sub_828B8CE8(ctx, base);
	// 82AA0D60: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA0D64: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82AA0D68: 419A0010  beq cr6, 0x82aa0d78
	if ctx.cr[6].eq {
	pc = 0x82AA0D78; continue 'dispatch;
	}
	// 82AA0D6C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82AA0D70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0D74: 409A0008  bne cr6, 0x82aa0d7c
	if !ctx.cr[6].eq {
	pc = 0x82AA0D7C; continue 'dispatch;
	}
	// 82AA0D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA0D7C: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 82AA0D80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA0D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA0D88: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA0D8C: 4BE688CD  bl 0x82909658
	ctx.lr = 0x82AA0D90;
	sub_82909658(ctx, base);
	// 82AA0D90: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA0D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0D98: 4BD4B3C1  bl 0x827ec158
	ctx.lr = 0x82AA0D9C;
	sub_827EC158(ctx, base);
	// 82AA0D9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA0DA0: 483DAD61  bl 0x82e7bb00
	ctx.lr = 0x82AA0DA4;
	sub_82E7BB00(ctx, base);
	// 82AA0DA4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA0DA8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA0DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0DB0: 483DAF19  bl 0x82e7bcc8
	ctx.lr = 0x82AA0DB4;
	sub_82E7BCC8(ctx, base);
	// 82AA0DB4: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA0DB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0DBC: 419A0010  beq cr6, 0x82aa0dcc
	if ctx.cr[6].eq {
	pc = 0x82AA0DCC; continue 'dispatch;
	}
	// 82AA0DC0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA0DC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0DC8: 4BEDC409  bl 0x8297d1d0
	ctx.lr = 0x82AA0DCC;
	sub_8297D1D0(ctx, base);
	// 82AA0DCC: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA0DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA0DD4: 419A0010  beq cr6, 0x82aa0de4
	if ctx.cr[6].eq {
	pc = 0x82AA0DE4; continue 'dispatch;
	}
	// 82AA0DD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA0DDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA0DE0: 4BEDC3F1  bl 0x8297d1d0
	ctx.lr = 0x82AA0DE4;
	sub_8297D1D0(ctx, base);
	// 82AA0DE4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AA0DE8: 487073D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0DF0 size=196
    let mut pc: u32 = 0x82AA0DF0;
    'dispatch: loop {
        match pc {
            0x82AA0DF0 => {
    //   block [0x82AA0DF0..0x82AA0EB4)
	// 82AA0DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0DF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0DFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0E00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0E04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0E0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA0E10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0E14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0E18: 4B81FB21  bl 0x822c0938
	ctx.lr = 0x82AA0E1C;
	sub_822C0938(ctx, base);
	// 82AA0E1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E20: 41820028  beq 0x82aa0e48
	if ctx.cr[0].eq {
	pc = 0x82AA0E48; continue 'dispatch;
	}
	// 82AA0E24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0E28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA0E2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA0E30: 392B60D8  addi r9, r11, 0x60d8
	ctx.r[9].s64 = ctx.r[11].s64 + 24792;
	// 82AA0E34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA0E38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA0E3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA0E40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA0E44: 48000008  b 0x82aa0e4c
	pc = 0x82AA0E4C; continue 'dispatch;
	// 82AA0E48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0E4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E54: 409A0044  bne cr6, 0x82aa0e98
	if !ctx.cr[6].eq {
	pc = 0x82AA0E98; continue 'dispatch;
	}
	// 82AA0E58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA0E5C: 419A001C  beq cr6, 0x82aa0e78
	if ctx.cr[6].eq {
	pc = 0x82AA0E78; continue 'dispatch;
	}
	// 82AA0E60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0E64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0E6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA0E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0E74: 4E800421  bctrl
	ctx.lr = 0x82AA0E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0E78: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0E7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA0E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0E84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA0E88: 816BC610  lwz r11, -0x39f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14832 as u32) ) } as u64;
	// 82AA0E8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA0E90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA0E94: 4B81F16D  bl 0x822c0000
	ctx.lr = 0x82AA0E98;
	sub_822C0000(ctx, base);
	// 82AA0E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0E9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0EA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0EAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0EB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0EB8 size=196
    let mut pc: u32 = 0x82AA0EB8;
    'dispatch: loop {
        match pc {
            0x82AA0EB8 => {
    //   block [0x82AA0EB8..0x82AA0F7C)
	// 82AA0EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0EC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0EC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0EC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0ED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0ED4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA0ED8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0EDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0EE0: 4B81FA59  bl 0x822c0938
	ctx.lr = 0x82AA0EE4;
	sub_822C0938(ctx, base);
	// 82AA0EE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA0EE8: 41820028  beq 0x82aa0f10
	if ctx.cr[0].eq {
	pc = 0x82AA0F10; continue 'dispatch;
	}
	// 82AA0EEC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0EF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA0EF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA0EF8: 392B60EC  addi r9, r11, 0x60ec
	ctx.r[9].s64 = ctx.r[11].s64 + 24812;
	// 82AA0EFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA0F00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA0F04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA0F08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA0F0C: 48000008  b 0x82aa0f14
	pc = 0x82AA0F14; continue 'dispatch;
	// 82AA0F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0F14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0F1C: 409A0044  bne cr6, 0x82aa0f60
	if !ctx.cr[6].eq {
	pc = 0x82AA0F60; continue 'dispatch;
	}
	// 82AA0F20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA0F24: 419A001C  beq cr6, 0x82aa0f40
	if ctx.cr[6].eq {
	pc = 0x82AA0F40; continue 'dispatch;
	}
	// 82AA0F28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0F2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0F34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0F38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA0F3C: 4E800421  bctrl
	ctx.lr = 0x82AA0F40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA0F40: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA0F44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA0F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA0F4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA0F50: 816BC610  lwz r11, -0x39f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14832 as u32) ) } as u64;
	// 82AA0F54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA0F58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA0F5C: 4B81F0A5  bl 0x822c0000
	ctx.lr = 0x82AA0F60;
	sub_822C0000(ctx, base);
	// 82AA0F60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA0F64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA0F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA0F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA0F70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA0F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA0F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA0F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA0F80 size=196
    let mut pc: u32 = 0x82AA0F80;
    'dispatch: loop {
        match pc {
            0x82AA0F80 => {
    //   block [0x82AA0F80..0x82AA1044)
	// 82AA0F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA0F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA0F88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA0F8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA0F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA0F94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA0F98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0F9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA0FA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA0FA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0FA8: 4B81F991  bl 0x822c0938
	ctx.lr = 0x82AA0FAC;
	sub_822C0938(ctx, base);
	// 82AA0FAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA0FB0: 41820028  beq 0x82aa0fd8
	if ctx.cr[0].eq {
	pc = 0x82AA0FD8; continue 'dispatch;
	}
	// 82AA0FB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA0FB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA0FBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA0FC0: 392B6100  addi r9, r11, 0x6100
	ctx.r[9].s64 = ctx.r[11].s64 + 24832;
	// 82AA0FC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA0FC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA0FCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA0FD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA0FD4: 48000008  b 0x82aa0fdc
	pc = 0x82AA0FDC; continue 'dispatch;
	// 82AA0FD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA0FDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA0FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA0FE4: 409A0044  bne cr6, 0x82aa1028
	if !ctx.cr[6].eq {
	pc = 0x82AA1028; continue 'dispatch;
	}
	// 82AA0FE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA0FEC: 419A001C  beq cr6, 0x82aa1008
	if ctx.cr[6].eq {
	pc = 0x82AA1008; continue 'dispatch;
	}
	// 82AA0FF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA0FF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA0FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA0FFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1004: 4E800421  bctrl
	ctx.lr = 0x82AA1008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1008: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA100C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA1010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1014: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA1018: 816BC610  lwz r11, -0x39f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14832 as u32) ) } as u64;
	// 82AA101C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA1020: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA1024: 4B81EFDD  bl 0x822c0000
	ctx.lr = 0x82AA1028;
	sub_822C0000(ctx, base);
	// 82AA1028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA102C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA1030: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1034: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1038: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA103C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA1040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1048 size=72
    let mut pc: u32 = 0x82AA1048;
    'dispatch: loop {
        match pc {
            0x82AA1048 => {
    //   block [0x82AA1048..0x82AA1090)
	// 82AA1048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA104C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1050: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1054: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82AA1058: 419A001C  beq cr6, 0x82aa1074
	if ctx.cr[6].eq {
	pc = 0x82AA1074; continue 'dispatch;
	}
	// 82AA105C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA1060: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA1064: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AA1068: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA106C: 4BFFFA75  bl 0x82aa0ae0
	ctx.lr = 0x82AA1070;
	sub_82AA0AE0(ctx, base);
	// 82AA1070: 48000010  b 0x82aa1080
	pc = 0x82AA1080; continue 'dispatch;
	// 82AA1074: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA1078: 396BC718  addi r11, r11, -0x38e8
	ctx.r[11].s64 = ctx.r[11].s64 + -14568;
	// 82AA107C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA1080: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA1084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA108C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1090 size=124
    let mut pc: u32 = 0x82AA1090;
    'dispatch: loop {
        match pc {
            0x82AA1090 => {
    //   block [0x82AA1090..0x82AA110C)
	// 82AA1090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA109C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA10A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA10A4: 4BFF8DF5  bl 0x82a99e98
	ctx.lr = 0x82AA10A8;
	sub_82A99E98(ctx, base);
	// 82AA10A8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA10AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA10B0: 394A6114  addi r10, r10, 0x6114
	ctx.r[10].s64 = ctx.r[10].s64 + 24852;
	// 82AA10B4: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA10B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA10BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA10C0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA10C4: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA10C8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA10CC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA10D0: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA10D4: 997F0098  stb r11, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 82AA10D8: 8089C9FC  lwz r4, -0x3604(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13828 as u32) ) } as u64;
	// 82AA10DC: 4835292D  bl 0x82df3a08
	ctx.lr = 0x82AA10E0;
	sub_82DF3A08(ctx, base);
	// 82AA10E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA10E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA10E8: 483B8601  bl 0x82e596e8
	ctx.lr = 0x82AA10EC;
	sub_82E596E8(ctx, base);
	// 82AA10EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA10F0: 48352339  bl 0x82df3428
	ctx.lr = 0x82AA10F4;
	sub_82DF3428(ctx, base);
	// 82AA10F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA10F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA10FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1100: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA1108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1110 size=112
    let mut pc: u32 = 0x82AA1110;
    'dispatch: loop {
        match pc {
            0x82AA1110 => {
    //   block [0x82AA1110..0x82AA1180)
	// 82AA1110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA111C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1124: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA1128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA112C: 419A0018  beq cr6, 0x82aa1144
	if ctx.cr[6].eq {
	pc = 0x82AA1144; continue 'dispatch;
	}
	// 82AA1130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA1138: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA113C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1140: 4E800421  bctrl
	ctx.lr = 0x82AA1144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1144: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA1148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA114C: 419A0008  beq cr6, 0x82aa1154
	if ctx.cr[6].eq {
	pc = 0x82AA1154; continue 'dispatch;
	}
	// 82AA1150: 4B81F741  bl 0x822c0890
	ctx.lr = 0x82AA1154;
	sub_822C0890(ctx, base);
	// 82AA1154: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA1158: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA115C: 419A0008  beq cr6, 0x82aa1164
	if ctx.cr[6].eq {
	pc = 0x82AA1164; continue 'dispatch;
	}
	// 82AA1160: 4B81F731  bl 0x822c0890
	ctx.lr = 0x82AA1164;
	sub_822C0890(ctx, base);
	// 82AA1164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1168: 483BB421  bl 0x82e5c588
	ctx.lr = 0x82AA116C;
	sub_82E5C588(ctx, base);
	// 82AA116C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA1170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA117C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1180 size=76
    let mut pc: u32 = 0x82AA1180;
    'dispatch: loop {
        match pc {
            0x82AA1180 => {
    //   block [0x82AA1180..0x82AA11CC)
	// 82AA1180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA118C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA1190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1198: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA119C: 4BFFFF75  bl 0x82aa1110
	ctx.lr = 0x82AA11A0;
	sub_82AA1110(ctx, base);
	// 82AA11A0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA11A4: 4182000C  beq 0x82aa11b0
	if ctx.cr[0].eq {
	pc = 0x82AA11B0; continue 'dispatch;
	}
	// 82AA11A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA11AC: 4835122D  bl 0x82df23d8
	ctx.lr = 0x82AA11B0;
	sub_82DF23D8(ctx, base);
	// 82AA11B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA11B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA11B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA11BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA11C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA11C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA11C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA11D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA11D0 size=316
    let mut pc: u32 = 0x82AA11D0;
    'dispatch: loop {
        match pc {
            0x82AA11D0 => {
    //   block [0x82AA11D0..0x82AA130C)
	// 82AA11D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA11D4: 48706F91  bl 0x831a8164
	ctx.lr = 0x82AA11D8;
	sub_831A8130(ctx, base);
	// 82AA11D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA11DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA11E0: 486B3421  bl 0x83154600
	ctx.lr = 0x82AA11E4;
	sub_83154600(ctx, base);
	// 82AA11E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA11E8: 4BE17B01  bl 0x828b8ce8
	ctx.lr = 0x82AA11EC;
	sub_828B8CE8(ctx, base);
	// 82AA11EC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA11F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA11F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA11F8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA11FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1200: 4E800421  bctrl
	ctx.lr = 0x82AA1204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1204: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA1208: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 82AA120C: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82AA1210: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA1214: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA1218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA121C: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82AA1220: 419A000C  beq cr6, 0x82aa122c
	if ctx.cr[6].eq {
	pc = 0x82AA122C; continue 'dispatch;
	}
	// 82AA1224: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA1228: 4B81F669  bl 0x822c0890
	ctx.lr = 0x82AA122C;
	sub_822C0890(ctx, base);
	// 82AA122C: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82AA1230: 397F006C  addi r11, r31, 0x6c
	ctx.r[11].s64 = ctx.r[31].s64 + 108;
	// 82AA1234: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA1238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA123C: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AA1240: 419A0008  beq cr6, 0x82aa1248
	if ctx.cr[6].eq {
	pc = 0x82AA1248; continue 'dispatch;
	}
	// 82AA1244: 4B81F64D  bl 0x822c0890
	ctx.lr = 0x82AA1248;
	sub_822C0890(ctx, base);
	// 82AA1248: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA124C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1250: 808BC5E8  lwz r4, -0x3a18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14872 as u32) ) } as u64;
	// 82AA1254: 483527B5  bl 0x82df3a08
	ctx.lr = 0x82AA1258;
	sub_82DF3A08(ctx, base);
	// 82AA1258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA125C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA1260: 4BD49119  bl 0x827ea378
	ctx.lr = 0x82AA1264;
	sub_827EA378(ctx, base);
	// 82AA1264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1268: 483521C1  bl 0x82df3428
	ctx.lr = 0x82AA126C;
	sub_82DF3428(ctx, base);
	// 82AA126C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1270: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA1274: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA1278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA127C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1280: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1284: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AA1288: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AA128C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AA1290: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA1294: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1298: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA129C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA12A0: 4E800421  bctrl
	ctx.lr = 0x82AA12A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA12A4: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA12A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA12AC: 419A003C  beq cr6, 0x82aa12e8
	if ctx.cr[6].eq {
	pc = 0x82AA12E8; continue 'dispatch;
	}
	// 82AA12B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA12B4: 4BD2E0BD  bl 0x827cf370
	ctx.lr = 0x82AA12B8;
	sub_827CF370(ctx, base);
	// 82AA12B8: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 82AA12BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA12C0: 4BA6E209  bl 0x8250f4c8
	ctx.lr = 0x82AA12C4;
	sub_8250F4C8(ctx, base);
	// 82AA12C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA12C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA12CC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA12D0: 409A0008  bne cr6, 0x82aa12d8
	if !ctx.cr[6].eq {
	pc = 0x82AA12D8; continue 'dispatch;
	}
	// 82AA12D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA12D8: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA12DC: 4BD2EB65  bl 0x827cfe40
	ctx.lr = 0x82AA12E0;
	sub_827CFE40(ctx, base);
	// 82AA12E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA12E4: 483509AD  bl 0x82df1c90
	ctx.lr = 0x82AA12E8;
	sub_82DF1C90(ctx, base);
	// 82AA12E8: 83FF0094  lwz r31, 0x94(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA12EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA12F0: 419A0014  beq cr6, 0x82aa1304
	if ctx.cr[6].eq {
	pc = 0x82AA1304; continue 'dispatch;
	}
	// 82AA12F4: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 82AA12F8: 4BE69139  bl 0x8290a430
	ctx.lr = 0x82AA12FC;
	sub_8290A430(ctx, base);
	// 82AA12FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1300: 480A4D01  bl 0x82b46000
	ctx.lr = 0x82AA1304;
	sub_82B46000(ctx, base);
	// 82AA1304: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA1308: 48706EAC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1310 size=112
    let mut pc: u32 = 0x82AA1310;
    'dispatch: loop {
        match pc {
            0x82AA1310 => {
    //   block [0x82AA1310..0x82AA1380)
	// 82AA1310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA131C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA1320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1324: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA1328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA132C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AA1330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1334: 4BFFFC4D  bl 0x82aa0f80
	ctx.lr = 0x82AA1338;
	sub_82AA0F80(ctx, base);
	// 82AA1338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA133C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA1340: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1344: 4B81ECBD  bl 0x822c0000
	ctx.lr = 0x82AA1348;
	sub_822C0000(ctx, base);
	// 82AA1348: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA134C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA1350: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA1354: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA135C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA1360: 419A0008  beq cr6, 0x82aa1368
	if ctx.cr[6].eq {
	pc = 0x82AA1368; continue 'dispatch;
	}
	// 82AA1364: 4B81F52D  bl 0x822c0890
	ctx.lr = 0x82AA1368;
	sub_822C0890(ctx, base);
	// 82AA1368: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA136C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1374: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA1378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA137C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA1380 size=536
    let mut pc: u32 = 0x82AA1380;
    'dispatch: loop {
        match pc {
            0x82AA1380 => {
    //   block [0x82AA1380..0x82AA1598)
	// 82AA1380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1384: 48706DE9  bl 0x831a816c
	ctx.lr = 0x82AA1388;
	sub_831A8130(ctx, base);
	// 82AA1388: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA138C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA1390: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1394: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA1398: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA139C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA13A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA13A4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA13A8: 4BB29159  bl 0x825ca500
	ctx.lr = 0x82AA13AC;
	sub_825CA500(ctx, base);
	// 82AA13AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA13B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA13B4: 388B61C0  addi r4, r11, 0x61c0
	ctx.r[4].s64 = ctx.r[11].s64 + 25024;
	// 82AA13B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA13BC: 4835264D  bl 0x82df3a08
	ctx.lr = 0x82AA13C0;
	sub_82DF3A08(ctx, base);
	// 82AA13C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA13C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA13C8: 388B61B4  addi r4, r11, 0x61b4
	ctx.r[4].s64 = ctx.r[11].s64 + 25012;
	// 82AA13CC: 4835263D  bl 0x82df3a08
	ctx.lr = 0x82AA13D0;
	sub_82DF3A08(ctx, base);
	// 82AA13D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA13D4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA13D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA13DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA13E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA13E4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA13E8: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA13EC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA13F0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA13F4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA13F8: 4BB01EB1  bl 0x825a32a8
	ctx.lr = 0x82AA13FC;
	sub_825A32A8(ctx, base);
	// 82AA13FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1400: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA1404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA1408: 4BB00369  bl 0x825a1770
	ctx.lr = 0x82AA140C;
	sub_825A1770(ctx, base);
	// 82AA140C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA1410: 48352019  bl 0x82df3428
	ctx.lr = 0x82AA1414;
	sub_82DF3428(ctx, base);
	// 82AA1414: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA1418: 4B8278A1  bl 0x822c8cb8
	ctx.lr = 0x82AA141C;
	sub_822C8CB8(ctx, base);
	// 82AA141C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1420: 48352009  bl 0x82df3428
	ctx.lr = 0x82AA1424;
	sub_82DF3428(ctx, base);
	// 82AA1424: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1428: 48352001  bl 0x82df3428
	ctx.lr = 0x82AA142C;
	sub_82DF3428(ctx, base);
	// 82AA142C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1434: 388B619C  addi r4, r11, 0x619c
	ctx.r[4].s64 = ctx.r[11].s64 + 24988;
	// 82AA1438: 483525D1  bl 0x82df3a08
	ctx.lr = 0x82AA143C;
	sub_82DF3A08(ctx, base);
	// 82AA143C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1440: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1444: 388B6188  addi r4, r11, 0x6188
	ctx.r[4].s64 = ctx.r[11].s64 + 24968;
	// 82AA1448: 483525C1  bl 0x82df3a08
	ctx.lr = 0x82AA144C;
	sub_82DF3A08(ctx, base);
	// 82AA144C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA1450: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA1454: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA1458: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA145C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA1460: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA1464: 4BB01E45  bl 0x825a32a8
	ctx.lr = 0x82AA1468;
	sub_825A32A8(ctx, base);
	// 82AA1468: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA146C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA1470: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA1474: 4BB002FD  bl 0x825a1770
	ctx.lr = 0x82AA1478;
	sub_825A1770(ctx, base);
	// 82AA1478: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA147C: 48351FAD  bl 0x82df3428
	ctx.lr = 0x82AA1480;
	sub_82DF3428(ctx, base);
	// 82AA1480: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA1484: 4B827835  bl 0x822c8cb8
	ctx.lr = 0x82AA1488;
	sub_822C8CB8(ctx, base);
	// 82AA1488: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA148C: 48351F9D  bl 0x82df3428
	ctx.lr = 0x82AA1490;
	sub_82DF3428(ctx, base);
	// 82AA1490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1494: 48351F95  bl 0x82df3428
	ctx.lr = 0x82AA1498;
	sub_82DF3428(ctx, base);
	// 82AA1498: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA149C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA14A0: 388B6170  addi r4, r11, 0x6170
	ctx.r[4].s64 = ctx.r[11].s64 + 24944;
	// 82AA14A4: 48352565  bl 0x82df3a08
	ctx.lr = 0x82AA14A8;
	sub_82DF3A08(ctx, base);
	// 82AA14A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA14AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA14B0: 388B6160  addi r4, r11, 0x6160
	ctx.r[4].s64 = ctx.r[11].s64 + 24928;
	// 82AA14B4: 48352555  bl 0x82df3a08
	ctx.lr = 0x82AA14B8;
	sub_82DF3A08(ctx, base);
	// 82AA14B8: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82AA14BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA14C0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA14C4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA14C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA14CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA14D0: 4BB01DD9  bl 0x825a32a8
	ctx.lr = 0x82AA14D4;
	sub_825A32A8(ctx, base);
	// 82AA14D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA14D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA14DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA14E0: 4BB00291  bl 0x825a1770
	ctx.lr = 0x82AA14E4;
	sub_825A1770(ctx, base);
	// 82AA14E4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA14E8: 48351F41  bl 0x82df3428
	ctx.lr = 0x82AA14EC;
	sub_82DF3428(ctx, base);
	// 82AA14EC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA14F0: 4B8277C9  bl 0x822c8cb8
	ctx.lr = 0x82AA14F4;
	sub_822C8CB8(ctx, base);
	// 82AA14F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA14F8: 48351F31  bl 0x82df3428
	ctx.lr = 0x82AA14FC;
	sub_82DF3428(ctx, base);
	// 82AA14FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1500: 48351F29  bl 0x82df3428
	ctx.lr = 0x82AA1504;
	sub_82DF3428(ctx, base);
	// 82AA1504: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA150C: 388B614C  addi r4, r11, 0x614c
	ctx.r[4].s64 = ctx.r[11].s64 + 24908;
	// 82AA1510: 483524F9  bl 0x82df3a08
	ctx.lr = 0x82AA1514;
	sub_82DF3A08(ctx, base);
	// 82AA1514: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1518: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA151C: 388B613C  addi r4, r11, 0x613c
	ctx.r[4].s64 = ctx.r[11].s64 + 24892;
	// 82AA1520: 483524E9  bl 0x82df3a08
	ctx.lr = 0x82AA1524;
	sub_82DF3A08(ctx, base);
	// 82AA1524: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82AA1528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA152C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA1530: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA1534: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA1538: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA153C: 4BB01D6D  bl 0x825a32a8
	ctx.lr = 0x82AA1540;
	sub_825A32A8(ctx, base);
	// 82AA1540: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1544: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA1548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA154C: 4BB00225  bl 0x825a1770
	ctx.lr = 0x82AA1550;
	sub_825A1770(ctx, base);
	// 82AA1550: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82AA1554: 48351ED5  bl 0x82df3428
	ctx.lr = 0x82AA1558;
	sub_82DF3428(ctx, base);
	// 82AA1558: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA155C: 4B82775D  bl 0x822c8cb8
	ctx.lr = 0x82AA1560;
	sub_822C8CB8(ctx, base);
	// 82AA1560: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1564: 48351EC5  bl 0x82df3428
	ctx.lr = 0x82AA1568;
	sub_82DF3428(ctx, base);
	// 82AA1568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA156C: 48351EBD  bl 0x82df3428
	ctx.lr = 0x82AA1570;
	sub_82DF3428(ctx, base);
	// 82AA1570: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1574: 4BB2875D  bl 0x825c9cd0
	ctx.lr = 0x82AA1578;
	sub_825C9CD0(ctx, base);
	// 82AA1578: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA157C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1580: 419A0008  beq cr6, 0x82aa1588
	if ctx.cr[6].eq {
	pc = 0x82AA1588; continue 'dispatch;
	}
	// 82AA1584: 4B81F30D  bl 0x822c0890
	ctx.lr = 0x82AA1588;
	sub_822C0890(ctx, base);
	// 82AA1588: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82AA158C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA1590: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA1594: 48706C28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA1598 size=1216
    let mut pc: u32 = 0x82AA1598;
    'dispatch: loop {
        match pc {
            0x82AA1598 => {
    //   block [0x82AA1598..0x82AA1A58)
	// 82AA1598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA159C: 48706BCD  bl 0x831a8168
	ctx.lr = 0x82AA15A0;
	sub_831A8130(ctx, base);
	// 82AA15A0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82AA15A4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82AA15A8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AA15AC: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA15B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA15B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA15B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA15BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA15C0: 388B630C  addi r4, r11, 0x630c
	ctx.r[4].s64 = ctx.r[11].s64 + 25356;
	// 82AA15C4: 48352445  bl 0x82df3a08
	ctx.lr = 0x82AA15C8;
	sub_82DF3A08(ctx, base);
	// 82AA15C8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA15CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA15D0: 388B6300  addi r4, r11, 0x6300
	ctx.r[4].s64 = ctx.r[11].s64 + 25344;
	// 82AA15D4: 48352435  bl 0x82df3a08
	ctx.lr = 0x82AA15D8;
	sub_82DF3A08(ctx, base);
	// 82AA15D8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA15DC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AA15E0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA15E4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA15E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA15EC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA15F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA15F4: 4E800421  bctrl
	ctx.lr = 0x82AA15F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA15F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA15FC: 48351E2D  bl 0x82df3428
	ctx.lr = 0x82AA1600;
	sub_82DF3428(ctx, base);
	// 82AA1600: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA1604: 48351E25  bl 0x82df3428
	ctx.lr = 0x82AA1608;
	sub_82DF3428(ctx, base);
	// 82AA1608: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AA160C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA1610: 388B89B8  addi r4, r11, -0x7648
	ctx.r[4].s64 = ctx.r[11].s64 + -30280;
	// 82AA1614: 483523F5  bl 0x82df3a08
	ctx.lr = 0x82AA1618;
	sub_82DF3A08(ctx, base);
	// 82AA1618: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AA161C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA1620: 388B89A8  addi r4, r11, -0x7658
	ctx.r[4].s64 = ctx.r[11].s64 + -30296;
	// 82AA1624: 483523E5  bl 0x82df3a08
	ctx.lr = 0x82AA1628;
	sub_82DF3A08(ctx, base);
	// 82AA1628: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA162C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA1630: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA1634: 4BB28ECD  bl 0x825ca500
	ctx.lr = 0x82AA1638;
	sub_825CA500(ctx, base);
	// 82AA1638: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA163C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA1640: 48351DE9  bl 0x82df3428
	ctx.lr = 0x82AA1644;
	sub_82DF3428(ctx, base);
	// 82AA1644: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA1648: 48351DE1  bl 0x82df3428
	ctx.lr = 0x82AA164C;
	sub_82DF3428(ctx, base);
	// 82AA164C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1650: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1654: 388B62E0  addi r4, r11, 0x62e0
	ctx.r[4].s64 = ctx.r[11].s64 + 25312;
	// 82AA1658: 483523B1  bl 0x82df3a08
	ctx.lr = 0x82AA165C;
	sub_82DF3A08(ctx, base);
	// 82AA165C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1664: 388B62D0  addi r4, r11, 0x62d0
	ctx.r[4].s64 = ctx.r[11].s64 + 25296;
	// 82AA1668: 483523A1  bl 0x82df3a08
	ctx.lr = 0x82AA166C;
	sub_82DF3A08(ctx, base);
	// 82AA166C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA1670: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AA1674: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA1678: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA167C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA1680: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA1684: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA1688: C3AADD6C  lfs f29, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AA168C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA1690: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA1694: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA1698: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA169C: 4BB01C0D  bl 0x825a32a8
	ctx.lr = 0x82AA16A0;
	sub_825A32A8(ctx, base);
	// 82AA16A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA16A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA16A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA16AC: 4BB000C5  bl 0x825a1770
	ctx.lr = 0x82AA16B0;
	sub_825A1770(ctx, base);
	// 82AA16B0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA16B4: 48351D75  bl 0x82df3428
	ctx.lr = 0x82AA16B8;
	sub_82DF3428(ctx, base);
	// 82AA16B8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AA16BC: 4B8275FD  bl 0x822c8cb8
	ctx.lr = 0x82AA16C0;
	sub_822C8CB8(ctx, base);
	// 82AA16C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA16C4: 48351D65  bl 0x82df3428
	ctx.lr = 0x82AA16C8;
	sub_82DF3428(ctx, base);
	// 82AA16C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA16CC: 48351D5D  bl 0x82df3428
	ctx.lr = 0x82AA16D0;
	sub_82DF3428(ctx, base);
	// 82AA16D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA16D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA16D8: 388B62B8  addi r4, r11, 0x62b8
	ctx.r[4].s64 = ctx.r[11].s64 + 25272;
	// 82AA16DC: 4835232D  bl 0x82df3a08
	ctx.lr = 0x82AA16E0;
	sub_82DF3A08(ctx, base);
	// 82AA16E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA16E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA16E8: 388B62A8  addi r4, r11, 0x62a8
	ctx.r[4].s64 = ctx.r[11].s64 + 25256;
	// 82AA16EC: 4835231D  bl 0x82df3a08
	ctx.lr = 0x82AA16F0;
	sub_82DF3A08(ctx, base);
	// 82AA16F0: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA16F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA16F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA16FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA1700: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA1704: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA1708: 4BB01BA1  bl 0x825a32a8
	ctx.lr = 0x82AA170C;
	sub_825A32A8(ctx, base);
	// 82AA170C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1714: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA1718: 4BB00059  bl 0x825a1770
	ctx.lr = 0x82AA171C;
	sub_825A1770(ctx, base);
	// 82AA171C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA1720: 48351D09  bl 0x82df3428
	ctx.lr = 0x82AA1724;
	sub_82DF3428(ctx, base);
	// 82AA1724: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AA1728: 4B827591  bl 0x822c8cb8
	ctx.lr = 0x82AA172C;
	sub_822C8CB8(ctx, base);
	// 82AA172C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1730: 48351CF9  bl 0x82df3428
	ctx.lr = 0x82AA1734;
	sub_82DF3428(ctx, base);
	// 82AA1734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1738: 48351CF1  bl 0x82df3428
	ctx.lr = 0x82AA173C;
	sub_82DF3428(ctx, base);
	// 82AA173C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1744: 388B6290  addi r4, r11, 0x6290
	ctx.r[4].s64 = ctx.r[11].s64 + 25232;
	// 82AA1748: 483522C1  bl 0x82df3a08
	ctx.lr = 0x82AA174C;
	sub_82DF3A08(ctx, base);
	// 82AA174C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1750: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1754: 388B6284  addi r4, r11, 0x6284
	ctx.r[4].s64 = ctx.r[11].s64 + 25220;
	// 82AA1758: 483522B1  bl 0x82df3a08
	ctx.lr = 0x82AA175C;
	sub_82DF3A08(ctx, base);
	// 82AA175C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA1760: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82AA1764: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AA1768: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA176C: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 82AA1770: C3CB9F7C  lfs f30, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA1774: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA1778: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA177C: 4BB01B2D  bl 0x825a32a8
	ctx.lr = 0x82AA1780;
	sub_825A32A8(ctx, base);
	// 82AA1780: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1788: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA178C: 4BAFFFE5  bl 0x825a1770
	ctx.lr = 0x82AA1790;
	sub_825A1770(ctx, base);
	// 82AA1790: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 82AA1794: 48351C95  bl 0x82df3428
	ctx.lr = 0x82AA1798;
	sub_82DF3428(ctx, base);
	// 82AA1798: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 82AA179C: 4B82751D  bl 0x822c8cb8
	ctx.lr = 0x82AA17A0;
	sub_822C8CB8(ctx, base);
	// 82AA17A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA17A4: 48351C85  bl 0x82df3428
	ctx.lr = 0x82AA17A8;
	sub_82DF3428(ctx, base);
	// 82AA17A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA17AC: 48351C7D  bl 0x82df3428
	ctx.lr = 0x82AA17B0;
	sub_82DF3428(ctx, base);
	// 82AA17B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA17B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA17B8: 388B6268  addi r4, r11, 0x6268
	ctx.r[4].s64 = ctx.r[11].s64 + 25192;
	// 82AA17BC: 4835224D  bl 0x82df3a08
	ctx.lr = 0x82AA17C0;
	sub_82DF3A08(ctx, base);
	// 82AA17C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA17C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA17C8: 388B6258  addi r4, r11, 0x6258
	ctx.r[4].s64 = ctx.r[11].s64 + 25176;
	// 82AA17CC: 4835223D  bl 0x82df3a08
	ctx.lr = 0x82AA17D0;
	sub_82DF3A08(ctx, base);
	// 82AA17D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA17D4: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82AA17D8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA17DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA17E0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA17E4: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82AA17E8: C3ABD0F8  lfs f29, -0x2f08(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AA17EC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA17F0: 4BB01AB9  bl 0x825a32a8
	ctx.lr = 0x82AA17F4;
	sub_825A32A8(ctx, base);
	// 82AA17F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA17F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA17FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1800: 4BAFFF71  bl 0x825a1770
	ctx.lr = 0x82AA1804;
	sub_825A1770(ctx, base);
	// 82AA1804: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82AA1808: 48351C21  bl 0x82df3428
	ctx.lr = 0x82AA180C;
	sub_82DF3428(ctx, base);
	// 82AA180C: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82AA1810: 4B8274A9  bl 0x822c8cb8
	ctx.lr = 0x82AA1814;
	sub_822C8CB8(ctx, base);
	// 82AA1814: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1818: 48351C11  bl 0x82df3428
	ctx.lr = 0x82AA181C;
	sub_82DF3428(ctx, base);
	// 82AA181C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1820: 48351C09  bl 0x82df3428
	ctx.lr = 0x82AA1824;
	sub_82DF3428(ctx, base);
	// 82AA1824: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA182C: 388B6240  addi r4, r11, 0x6240
	ctx.r[4].s64 = ctx.r[11].s64 + 25152;
	// 82AA1830: 483521D9  bl 0x82df3a08
	ctx.lr = 0x82AA1834;
	sub_82DF3A08(ctx, base);
	// 82AA1834: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1838: 388B6234  addi r4, r11, 0x6234
	ctx.r[4].s64 = ctx.r[11].s64 + 25140;
	// 82AA183C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1840: 483521C9  bl 0x82df3a08
	ctx.lr = 0x82AA1844;
	sub_82DF3A08(ctx, base);
	// 82AA1844: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82AA1848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA184C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA1850: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA1854: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AA1858: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA185C: 4BB01A4D  bl 0x825a32a8
	ctx.lr = 0x82AA1860;
	sub_825A32A8(ctx, base);
	// 82AA1860: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1868: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA186C: 4BAFFF05  bl 0x825a1770
	ctx.lr = 0x82AA1870;
	sub_825A1770(ctx, base);
	// 82AA1870: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA1874: 48351BB5  bl 0x82df3428
	ctx.lr = 0x82AA1878;
	sub_82DF3428(ctx, base);
	// 82AA1878: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AA187C: 4B82743D  bl 0x822c8cb8
	ctx.lr = 0x82AA1880;
	sub_822C8CB8(ctx, base);
	// 82AA1880: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1884: 48351BA5  bl 0x82df3428
	ctx.lr = 0x82AA1888;
	sub_82DF3428(ctx, base);
	// 82AA1888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA188C: 48351B9D  bl 0x82df3428
	ctx.lr = 0x82AA1890;
	sub_82DF3428(ctx, base);
	// 82AA1890: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1898: 388B6218  addi r4, r11, 0x6218
	ctx.r[4].s64 = ctx.r[11].s64 + 25112;
	// 82AA189C: 4835216D  bl 0x82df3a08
	ctx.lr = 0x82AA18A0;
	sub_82DF3A08(ctx, base);
	// 82AA18A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA18A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA18A8: 388B6208  addi r4, r11, 0x6208
	ctx.r[4].s64 = ctx.r[11].s64 + 25096;
	// 82AA18AC: 4835215D  bl 0x82df3a08
	ctx.lr = 0x82AA18B0;
	sub_82DF3A08(ctx, base);
	// 82AA18B0: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 82AA18B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA18B8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA18BC: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA18C0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA18C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA18C8: 4BB019E1  bl 0x825a32a8
	ctx.lr = 0x82AA18CC;
	sub_825A32A8(ctx, base);
	// 82AA18CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA18D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA18D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA18D8: 4BAFFE99  bl 0x825a1770
	ctx.lr = 0x82AA18DC;
	sub_825A1770(ctx, base);
	// 82AA18DC: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82AA18E0: 48351B49  bl 0x82df3428
	ctx.lr = 0x82AA18E4;
	sub_82DF3428(ctx, base);
	// 82AA18E4: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AA18E8: 4B8273D1  bl 0x822c8cb8
	ctx.lr = 0x82AA18EC;
	sub_822C8CB8(ctx, base);
	// 82AA18EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA18F0: 48351B39  bl 0x82df3428
	ctx.lr = 0x82AA18F4;
	sub_82DF3428(ctx, base);
	// 82AA18F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA18F8: 48351B31  bl 0x82df3428
	ctx.lr = 0x82AA18FC;
	sub_82DF3428(ctx, base);
	// 82AA18FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1904: 388B61F4  addi r4, r11, 0x61f4
	ctx.r[4].s64 = ctx.r[11].s64 + 25076;
	// 82AA1908: 48352101  bl 0x82df3a08
	ctx.lr = 0x82AA190C;
	sub_82DF3A08(ctx, base);
	// 82AA190C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1910: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1914: 388B61E4  addi r4, r11, 0x61e4
	ctx.r[4].s64 = ctx.r[11].s64 + 25060;
	// 82AA1918: 483520F1  bl 0x82df3a08
	ctx.lr = 0x82AA191C;
	sub_82DF3A08(ctx, base);
	// 82AA191C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA1920: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AA1924: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82AA1928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA192C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82AA1930: C06B9528  lfs f3, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AA1934: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AA1938: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82AA193C: 4BB0196D  bl 0x825a32a8
	ctx.lr = 0x82AA1940;
	sub_825A32A8(ctx, base);
	// 82AA1940: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1944: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA1948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA194C: 4BAFFE25  bl 0x825a1770
	ctx.lr = 0x82AA1950;
	sub_825A1770(ctx, base);
	// 82AA1950: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 82AA1954: 48351AD5  bl 0x82df3428
	ctx.lr = 0x82AA1958;
	sub_82DF3428(ctx, base);
	// 82AA1958: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 82AA195C: 4B82735D  bl 0x822c8cb8
	ctx.lr = 0x82AA1960;
	sub_822C8CB8(ctx, base);
	// 82AA1960: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1964: 48351AC5  bl 0x82df3428
	ctx.lr = 0x82AA1968;
	sub_82DF3428(ctx, base);
	// 82AA1968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA196C: 48351ABD  bl 0x82df3428
	ctx.lr = 0x82AA1970;
	sub_82DF3428(ctx, base);
	// 82AA1970: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA1974: 4BB2835D  bl 0x825c9cd0
	ctx.lr = 0x82AA1978;
	sub_825C9CD0(ctx, base);
	// 82AA1978: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA197C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1980: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82AA1984: 3BAB61D0  addi r29, r11, 0x61d0
	ctx.r[29].s64 = ctx.r[11].s64 + 25040;
	// 82AA1988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA198C: 4BFED21D  bl 0x82a8eba8
	ctx.lr = 0x82AA1990;
	sub_82A8EBA8(ctx, base);
	// 82AA1990: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1994: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA1998: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82AA199C: 4870713D  bl 0x831a8ad8
	ctx.lr = 0x82AA19A0;
	sub_831A8AD8(ctx, base);
	// 82AA19A0: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 82AA19A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA19A8: 48352061  bl 0x82df3a08
	ctx.lr = 0x82AA19AC;
	sub_82DF3A08(ctx, base);
	// 82AA19AC: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 82AA19B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA19B4: 48352055  bl 0x82df3a08
	ctx.lr = 0x82AA19B8;
	sub_82DF3A08(ctx, base);
	// 82AA19B8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA19BC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA19C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA19C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA19C8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA19CC: 419A0024  beq cr6, 0x82aa19f0
	if ctx.cr[6].eq {
	pc = 0x82AA19F0; continue 'dispatch;
	}
	// 82AA19D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA19D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA19D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA19DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA19E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA19E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA19E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA19EC: 4082FFE8  bne 0x82aa19d4
	if !ctx.cr[0].eq {
	pc = 0x82AA19D4; continue 'dispatch;
	}
	// 82AA19F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA19F4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA19F8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA19FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1A00: 4BFFF981  bl 0x82aa1380
	ctx.lr = 0x82AA1A04;
	sub_82AA1380(ctx, base);
	// 82AA1A04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA1A08: 48351A21  bl 0x82df3428
	ctx.lr = 0x82AA1A0C;
	sub_82DF3428(ctx, base);
	// 82AA1A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA1A10: 48351A19  bl 0x82df3428
	ctx.lr = 0x82AA1A14;
	sub_82DF3428(ctx, base);
	// 82AA1A14: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AA1A18: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82AA1A1C: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 82AA1A20: 4198FF68  blt cr6, 0x82aa1988
	if ctx.cr[6].lt {
	pc = 0x82AA1988; continue 'dispatch;
	}
	// 82AA1A24: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA1A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1A2C: 419A0008  beq cr6, 0x82aa1a34
	if ctx.cr[6].eq {
	pc = 0x82AA1A34; continue 'dispatch;
	}
	// 82AA1A30: 4B81EE61  bl 0x822c0890
	ctx.lr = 0x82AA1A34;
	sub_822C0890(ctx, base);
	// 82AA1A34: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1A3C: 419A0008  beq cr6, 0x82aa1a44
	if ctx.cr[6].eq {
	pc = 0x82AA1A44; continue 'dispatch;
	}
	// 82AA1A40: 4B81EE51  bl 0x822c0890
	ctx.lr = 0x82AA1A44;
	sub_822C0890(ctx, base);
	// 82AA1A44: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 82AA1A48: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AA1A4C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AA1A50: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA1A54: 48706764  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1A58 size=112
    let mut pc: u32 = 0x82AA1A58;
    'dispatch: loop {
        match pc {
            0x82AA1A58 => {
    //   block [0x82AA1A58..0x82AA1AC8)
	// 82AA1A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1A5C: 48706711  bl 0x831a816c
	ctx.lr = 0x82AA1A60;
	sub_831A8130(ctx, base);
	// 82AA1A60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1A64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1A68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA1A6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA1A70: 388B6320  addi r4, r11, 0x6320
	ctx.r[4].s64 = ctx.r[11].s64 + 25376;
	// 82AA1A74: 38A000B9  li r5, 0xb9
	ctx.r[5].s64 = 185;
	// 82AA1A78: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 82AA1A7C: 4835096D  bl 0x82df23e8
	ctx.lr = 0x82AA1A80;
	sub_82DF23E8(ctx, base);
	// 82AA1A80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA1A84: 41820010  beq 0x82aa1a94
	if ctx.cr[0].eq {
	pc = 0x82AA1A94; continue 'dispatch;
	}
	// 82AA1A88: 4BFFF609  bl 0x82aa1090
	ctx.lr = 0x82AA1A8C;
	sub_82AA1090(ctx, base);
	// 82AA1A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1A90: 48000008  b 0x82aa1a98
	pc = 0x82AA1A98; continue 'dispatch;
	// 82AA1A94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA1A98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA1A9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA1AA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1AA8: 4BFFF349  bl 0x82aa0df0
	ctx.lr = 0x82AA1AAC;
	sub_82AA0DF0(ctx, base);
	// 82AA1AAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA1AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1AB8: 4B81E549  bl 0x822c0000
	ctx.lr = 0x82AA1ABC;
	sub_822C0000(ctx, base);
	// 82AA1ABC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA1AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA1AC4: 487066F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA1AC8 size=128
    let mut pc: u32 = 0x82AA1AC8;
    'dispatch: loop {
        match pc {
            0x82AA1AC8 => {
    //   block [0x82AA1AC8..0x82AA1B48)
	// 82AA1AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA1AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA1AD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1AD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1ADC: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA1AE0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA1AEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA1AF0: 419A0024  beq cr6, 0x82aa1b14
	if ctx.cr[6].eq {
	pc = 0x82AA1B14; continue 'dispatch;
	}
	// 82AA1AF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA1AF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA1AFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA1B00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA1B04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA1B08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA1B0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA1B10: 4082FFE8  bne 0x82aa1af8
	if !ctx.cr[0].eq {
	pc = 0x82AA1AF8; continue 'dispatch;
	}
	// 82AA1B14: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA1B18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA1B1C: 386BE418  addi r3, r11, -0x1be8
	ctx.r[3].s64 = ctx.r[11].s64 + -7144;
	// 82AA1B20: 4BFFFA79  bl 0x82aa1598
	ctx.lr = 0x82AA1B24;
	sub_82AA1598(ctx, base);
	// 82AA1B24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1B28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1B2C: 419A0008  beq cr6, 0x82aa1b34
	if ctx.cr[6].eq {
	pc = 0x82AA1B34; continue 'dispatch;
	}
	// 82AA1B30: 4B81ED61  bl 0x822c0890
	ctx.lr = 0x82AA1B34;
	sub_822C0890(ctx, base);
	// 82AA1B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA1B38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA1B3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA1B40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA1B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA1B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA1B48 size=2884
    let mut pc: u32 = 0x82AA1B48;
    'dispatch: loop {
        match pc {
            0x82AA1B48 => {
    //   block [0x82AA1B48..0x82AA268C)
	// 82AA1B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA1B4C: 48706611  bl 0x831a815c
	ctx.lr = 0x82AA1B50;
	sub_831A8130(ctx, base);
	// 82AA1B50: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AA1B54: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA1B58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA1B5C: 486B2AA5  bl 0x83154600
	ctx.lr = 0x82AA1B60;
	sub_83154600(ctx, base);
	// 82AA1B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA1B64: 4BE17185  bl 0x828b8ce8
	ctx.lr = 0x82AA1B68;
	sub_828B8CE8(ctx, base);
	// 82AA1B68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA1B6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1B70: 4BFFF139  bl 0x82aa0ca8
	ctx.lr = 0x82AA1B74;
	sub_82AA0CA8(ctx, base);
	// 82AA1B74: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA1B78: 3BABE418  addi r29, r11, -0x1be8
	ctx.r[29].s64 = ctx.r[11].s64 + -7144;
	// 82AA1B7C: 897E0098  lbz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA1B80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA1B84: 4182008C  beq 0x82aa1c10
	if ctx.cr[0].eq {
	pc = 0x82AA1C10; continue 'dispatch;
	}
	// 82AA1B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1B8C: 4BE5DE65  bl 0x828ff9f0
	ctx.lr = 0x82AA1B90;
	sub_828FF9F0(ctx, base);
	// 82AA1B90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA1B94: 897C0029  lbz r11, 0x29(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(41 as u32) ) } as u64;
	// 82AA1B98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA1B9C: 40820074  bne 0x82aa1c10
	if !ctx.cr[0].eq {
	pc = 0x82AA1C10; continue 'dispatch;
	}
	// 82AA1BA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1BA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1BAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1BB0: 4E800421  bctrl
	ctx.lr = 0x82AA1BB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1BB4: C1BC0014  lfs f13, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1BB8: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1BBC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA1BC0: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1BC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA1BC8: 40980048  bge cr6, 0x82aa1c10
	if !ctx.cr[6].lt {
	pc = 0x82AA1C10; continue 'dispatch;
	}
	// 82AA1BCC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA1BD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA1BD4: 808BCA00  lwz r4, -0x3600(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13824 as u32) ) } as u64;
	// 82AA1BD8: 48351E31  bl 0x82df3a08
	ctx.lr = 0x82AA1BDC;
	sub_82DF3A08(ctx, base);
	// 82AA1BDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1BE0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA1BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA1BE8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AA1BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA1BF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA1BF4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA1BF8: 483BCE99  bl 0x82e5ea90
	ctx.lr = 0x82AA1BFC;
	sub_82E5EA90(ctx, base);
	// 82AA1BFC: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82AA1C00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1C04: 419A0A7C  beq cr6, 0x82aa2680
	if ctx.cr[6].eq {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1C08: 4B81EC89  bl 0x822c0890
	ctx.lr = 0x82AA1C0C;
	sub_822C0890(ctx, base);
	// 82AA1C0C: 48000A74  b 0x82aa2680
	pc = 0x82AA2680; continue 'dispatch;
	// 82AA1C10: 817E007C  lwz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA1C14: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82AA1C18: 41990A68  bgt cr6, 0x82aa2680
	if ctx.cr[6].gt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1C1C: 3D80820B  lis r12, -0x7df5
	ctx.r[12].s64 = -2113208320;
	// 82AA1C20: 398C6378  addi r12, r12, 0x6378
	ctx.r[12].s64 = ctx.r[12].s64 + 25464;
	// 82AA1C24: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82AA1C28: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82AA1C2C: 3D8082AA  lis r12, -0x7d56
	ctx.r[12].s64 = -2102788096;
	// 82AA1C30: 398C1C44  addi r12, r12, 0x1c44
	ctx.r[12].s64 = ctx.r[12].s64 + 7236;
	// 82AA1C34: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82AA1C38: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82AA1C3C: 60000000  nop
	// 82AA1C40: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82AA1C44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1C4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1C50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1C54: 4E800421  bctrl
	ctx.lr = 0x82AA1C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1C58: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1C5C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1C60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AA1C64: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA1C68: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1C6C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA1C70: 40990A10  ble cr6, 0x82aa2680
	if !ctx.cr[6].gt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA1C78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1C7C: 915E007C  stw r10, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82AA1C80: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1C84: D01E0080  stfs f0, 0x80(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA1C88: 480009F8  b 0x82aa2680
	pc = 0x82AA2680; continue 'dispatch;
	// 82AA1C8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA1C90: 483B7AE9  bl 0x82e59778
	ctx.lr = 0x82AA1C94;
	sub_82E59778(ctx, base);
	// 82AA1C94: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1C98: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA1C9C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA1CA0: D01E0080  stfs f0, 0x80(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA1CA4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1CA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA1CAC: 409909D4  ble cr6, 0x82aa2680
	if !ctx.cr[6].gt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1CB0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA1CB4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA1CB8: 808B9F80  lwz r4, -0x6080(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24704 as u32) ) } as u64;
	// 82AA1CBC: 48351D4D  bl 0x82df3a08
	ctx.lr = 0x82AA1CC0;
	sub_82DF3A08(ctx, base);
	// 82AA1CC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1CC4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AA1CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1CCC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA1CD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1CD4: 4E800421  bctrl
	ctx.lr = 0x82AA1CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1CD8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA1CDC: 4835174D  bl 0x82df3428
	ctx.lr = 0x82AA1CE0;
	sub_82DF3428(ctx, base);
	// 82AA1CE0: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82AA1CE4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA1CE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1CEC: 4BA6D7DD  bl 0x8250f4c8
	ctx.lr = 0x82AA1CF0;
	sub_8250F4C8(ctx, base);
	// 82AA1CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1CF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1CF8: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82AA1CFC: 409A0008  bne cr6, 0x82aa1d04
	if !ctx.cr[6].eq {
	pc = 0x82AA1D04; continue 'dispatch;
	}
	// 82AA1D00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA1D04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1D08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1D0C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82AA1D10: 3B8B1FD8  addi r28, r11, 0x1fd8
	ctx.r[28].s64 = ctx.r[11].s64 + 8152;
	// 82AA1D14: 4BD4A8B5  bl 0x827ec5c8
	ctx.lr = 0x82AA1D18;
	sub_827EC5C8(ctx, base);
	// 82AA1D18: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA1D1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1D24: 3B2B5A2C  addi r25, r11, 0x5a2c
	ctx.r[25].s64 = ctx.r[11].s64 + 23084;
	// 82AA1D28: 4BE68709  bl 0x8290a430
	ctx.lr = 0x82AA1D2C;
	sub_8290A430(ctx, base);
	// 82AA1D2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA1D30: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82AA1D34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA1D38: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82AA1D3C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82AA1D40: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA1D44: 480A3E55  bl 0x82b45b98
	ctx.lr = 0x82AA1D48;
	sub_82B45B98(ctx, base);
	// 82AA1D48: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AA1D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1D50: 419A0008  beq cr6, 0x82aa1d58
	if ctx.cr[6].eq {
	pc = 0x82AA1D58; continue 'dispatch;
	}
	// 82AA1D54: 4B81EB3D  bl 0x822c0890
	ctx.lr = 0x82AA1D58;
	sub_822C0890(ctx, base);
	// 82AA1D58: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA1D5C: 4834FF35  bl 0x82df1c90
	ctx.lr = 0x82AA1D60;
	sub_82DF1C90(ctx, base);
	// 82AA1D60: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AA1D64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA1D68: 4BFDFDF9  bl 0x82a81b60
	ctx.lr = 0x82AA1D6C;
	sub_82A81B60(ctx, base);
	// 82AA1D6C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AA1D70: 409900D4  ble cr6, 0x82aa1e44
	if !ctx.cr[6].gt {
	pc = 0x82AA1E44; continue 'dispatch;
	}
	// 82AA1D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA1D78: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA1D7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA1D80: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82AA1D84: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AA1D88: 388A63E4  addi r4, r10, 0x63e4
	ctx.r[4].s64 = ctx.r[10].s64 + 25572;
	// 82AA1D8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA1D90: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AA1D94: 4BFD1E35  bl 0x82a73bc8
	ctx.lr = 0x82AA1D98;
	sub_82A73BC8(ctx, base);
	// 82AA1D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1D9C: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82AA1DA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA1DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1DA8: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82AA1DAC: 419A0024  beq cr6, 0x82aa1dd0
	if ctx.cr[6].eq {
	pc = 0x82AA1DD0; continue 'dispatch;
	}
	// 82AA1DB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA1DB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA1DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA1DBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA1DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA1DC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA1DC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA1DCC: 4082FFE8  bne 0x82aa1db4
	if !ctx.cr[0].eq {
	pc = 0x82AA1DB4; continue 'dispatch;
	}
	// 82AA1DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1DD4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA1DD8: 4BA6D6F1  bl 0x8250f4c8
	ctx.lr = 0x82AA1DDC;
	sub_8250F4C8(ctx, base);
	// 82AA1DDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1DE4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA1DE8: 409A0008  bne cr6, 0x82aa1df0
	if !ctx.cr[6].eq {
	pc = 0x82AA1DF0; continue 'dispatch;
	}
	// 82AA1DEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA1DF0: 3BE100B0  addi r31, r1, 0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + 176;
	// 82AA1DF4: 4BA66825  bl 0x82508618
	ctx.lr = 0x82AA1DF8;
	sub_82508618(ctx, base);
	// 82AA1DF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1DFC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA1E00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA1E04: 388A6320  addi r4, r10, 0x6320
	ctx.r[4].s64 = ctx.r[10].s64 + 25376;
	// 82AA1E08: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 82AA1E0C: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82AA1E10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA1E14: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA1E18: 483B6C29  bl 0x82e58a40
	ctx.lr = 0x82AA1E1C;
	sub_82E58A40(ctx, base);
	// 82AA1E1C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA1E20: 4834FE71  bl 0x82df1c90
	ctx.lr = 0x82AA1E24;
	sub_82DF1C90(ctx, base);
	// 82AA1E24: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA1E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1E2C: 419A0008  beq cr6, 0x82aa1e34
	if ctx.cr[6].eq {
	pc = 0x82AA1E34; continue 'dispatch;
	}
	// 82AA1E30: 4B81EA61  bl 0x822c0890
	ctx.lr = 0x82AA1E34;
	sub_822C0890(ctx, base);
	// 82AA1E34: 80610144  lwz r3, 0x144(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 82AA1E38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA1E3C: 419A0008  beq cr6, 0x82aa1e44
	if ctx.cr[6].eq {
	pc = 0x82AA1E44; continue 'dispatch;
	}
	// 82AA1E40: 4B81EA51  bl 0x822c0890
	ctx.lr = 0x82AA1E44;
	sub_822C0890(ctx, base);
	// 82AA1E44: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AA1E48: 48000834  b 0x82aa267c
	pc = 0x82AA267C; continue 'dispatch;
	// 82AA1E4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1E54: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA1E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1E5C: 4E800421  bctrl
	ctx.lr = 0x82AA1E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1E60: 4BD484B1  bl 0x827ea310
	ctx.lr = 0x82AA1E64;
	sub_827EA310(ctx, base);
	// 82AA1E64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA1E68: 41820818  beq 0x82aa2680
	if ctx.cr[0].eq {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1E6C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA1E70: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AA1E74: 808B9F84  lwz r4, -0x607c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24700 as u32) ) } as u64;
	// 82AA1E78: 48351B91  bl 0x82df3a08
	ctx.lr = 0x82AA1E7C;
	sub_82DF3A08(ctx, base);
	// 82AA1E7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1E80: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AA1E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1E88: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA1E8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1E90: 4E800421  bctrl
	ctx.lr = 0x82AA1E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1E94: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AA1E98: 48351591  bl 0x82df3428
	ctx.lr = 0x82AA1E9C;
	sub_82DF3428(ctx, base);
	// 82AA1E9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AA1EA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA1EA4: 3BABC77C  addi r29, r11, -0x3884
	ctx.r[29].s64 = ctx.r[11].s64 + -14468;
	// 82AA1EA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA1EAC: 48351B5D  bl 0x82df3a08
	ctx.lr = 0x82AA1EB0;
	sub_82DF3A08(ctx, base);
	// 82AA1EB0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1EB4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AA1EB8: 388B63CC  addi r4, r11, 0x63cc
	ctx.r[4].s64 = ctx.r[11].s64 + 25548;
	// 82AA1EBC: 48351B4D  bl 0x82df3a08
	ctx.lr = 0x82AA1EC0;
	sub_82DF3A08(ctx, base);
	// 82AA1EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1EC4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA1EC8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA1ECC: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82AA1ED0: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82AA1ED4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA1ED8: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 82AA1EDC: C1AA95A0  lfs f13, -0x6a60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA1EE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1EE4: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA1EE8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82AA1EEC: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA1EF0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 82AA1EF4: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA1EF8: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AA1EFC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA1F00: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AA1F04: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AA1F08: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AA1F0C: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AA1F10: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA1F14: 837E0074  lwz r27, 0x74(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA1F18: 4BD4A6B1  bl 0x827ec5c8
	ctx.lr = 0x82AA1F1C;
	sub_827EC5C8(ctx, base);
	// 82AA1F1C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA1F20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1F24: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82AA1F28: 4BA6D5A1  bl 0x8250f4c8
	ctx.lr = 0x82AA1F2C;
	sub_8250F4C8(ctx, base);
	// 82AA1F2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA1F30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA1F34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA1F38: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA1F3C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AA1F40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA1F44: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA1F48: 4BD2E179  bl 0x827d00c0
	ctx.lr = 0x82AA1F4C;
	sub_827D00C0(ctx, base);
	// 82AA1F4C: 907E008C  stw r3, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82AA1F50: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AA1F54: 483514D5  bl 0x82df3428
	ctx.lr = 0x82AA1F58;
	sub_82DF3428(ctx, base);
	// 82AA1F58: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA1F5C: 483514CD  bl 0x82df3428
	ctx.lr = 0x82AA1F60;
	sub_82DF3428(ctx, base);
	// 82AA1F60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1F64: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA1F68: 4BA6D561  bl 0x8250f4c8
	ctx.lr = 0x82AA1F6C;
	sub_8250F4C8(ctx, base);
	// 82AA1F6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA1F74: 3B8BFFFC  addi r28, r11, -4
	ctx.r[28].s64 = ctx.r[11].s64 + -4;
	// 82AA1F78: 409A0008  bne cr6, 0x82aa1f80
	if !ctx.cr[6].eq {
	pc = 0x82AA1F80; continue 'dispatch;
	}
	// 82AA1F7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AA1F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA1F84: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82AA1F88: 4BD4A641  bl 0x827ec5c8
	ctx.lr = 0x82AA1F8C;
	sub_827EC5C8(ctx, base);
	// 82AA1F8C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA1F90: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1F98: 3BEB63B4  addi r31, r11, 0x63b4
	ctx.r[31].s64 = ctx.r[11].s64 + 25524;
	// 82AA1F9C: 4BE68495  bl 0x8290a430
	ctx.lr = 0x82AA1FA0;
	sub_8290A430(ctx, base);
	// 82AA1FA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA1FA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA1FA8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82AA1FAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA1FB0: 480A4339  bl 0x82b462e8
	ctx.lr = 0x82AA1FB4;
	sub_82B462E8(ctx, base);
	// 82AA1FB4: 907E0094  stw r3, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82AA1FB8: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA1FBC: 4834FCD5  bl 0x82df1c90
	ctx.lr = 0x82AA1FC0;
	sub_82DF1C90(ctx, base);
	// 82AA1FC0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA1FC4: 480006B8  b 0x82aa267c
	pc = 0x82AA267C; continue 'dispatch;
	// 82AA1FC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA1FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA1FD0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA1FD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA1FD8: 4E800421  bctrl
	ctx.lr = 0x82AA1FDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA1FDC: 4BD48335  bl 0x827ea310
	ctx.lr = 0x82AA1FE0;
	sub_827EA310(ctx, base);
	// 82AA1FE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA1FE4: 4182069C  beq 0x82aa2680
	if ctx.cr[0].eq {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA1FE8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AA1FEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA1FF0: 4BFDFB71  bl 0x82a81b60
	ctx.lr = 0x82AA1FF4;
	sub_82A81B60(ctx, base);
	// 82AA1FF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA1FF8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AA1FFC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA2000: 409A00D0  bne cr6, 0x82aa20d0
	if !ctx.cr[6].eq {
	pc = 0x82AA20D0; continue 'dispatch;
	}
	// 82AA2004: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA2008: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA200C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA2010: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82AA2014: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AA2018: 388A63A8  addi r4, r10, 0x63a8
	ctx.r[4].s64 = ctx.r[10].s64 + 25512;
	// 82AA201C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA2020: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AA2024: 4BFD1BA5  bl 0x82a73bc8
	ctx.lr = 0x82AA2028;
	sub_82A73BC8(ctx, base);
	// 82AA2028: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA202C: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82AA2030: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2038: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82AA203C: 419A0024  beq cr6, 0x82aa2060
	if ctx.cr[6].eq {
	pc = 0x82AA2060; continue 'dispatch;
	}
	// 82AA2040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA2044: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA2048: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA204C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA2050: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA2054: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2058: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA205C: 4082FFE8  bne 0x82aa2044
	if !ctx.cr[0].eq {
	pc = 0x82AA2044; continue 'dispatch;
	}
	// 82AA2060: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 82AA2064: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA2068: 4BA6D461  bl 0x8250f4c8
	ctx.lr = 0x82AA206C;
	sub_8250F4C8(ctx, base);
	// 82AA206C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2074: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA2078: 409A0008  bne cr6, 0x82aa2080
	if !ctx.cr[6].eq {
	pc = 0x82AA2080; continue 'dispatch;
	}
	// 82AA207C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA2080: 3BA100B8  addi r29, r1, 0xb8
	ctx.r[29].s64 = ctx.r[1].s64 + 184;
	// 82AA2084: 4BA66595  bl 0x82508618
	ctx.lr = 0x82AA2088;
	sub_82508618(ctx, base);
	// 82AA2088: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA208C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA2090: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA2094: 388B6320  addi r4, r11, 0x6320
	ctx.r[4].s64 = ctx.r[11].s64 + 25376;
	// 82AA2098: 38A0017C  li r5, 0x17c
	ctx.r[5].s64 = 380;
	// 82AA209C: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82AA20A0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA20A4: 483B699D  bl 0x82e58a40
	ctx.lr = 0x82AA20A8;
	sub_82E58A40(ctx, base);
	// 82AA20A8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA20AC: 4834FBE5  bl 0x82df1c90
	ctx.lr = 0x82AA20B0;
	sub_82DF1C90(ctx, base);
	// 82AA20B0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA20B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA20B8: 419A0008  beq cr6, 0x82aa20c0
	if ctx.cr[6].eq {
	pc = 0x82AA20C0; continue 'dispatch;
	}
	// 82AA20BC: 4B81E7D5  bl 0x822c0890
	ctx.lr = 0x82AA20C0;
	sub_822C0890(ctx, base);
	// 82AA20C0: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82AA20C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA20C8: 419A0008  beq cr6, 0x82aa20d0
	if ctx.cr[6].eq {
	pc = 0x82AA20D0; continue 'dispatch;
	}
	// 82AA20CC: 4B81E7C5  bl 0x822c0890
	ctx.lr = 0x82AA20D0;
	sub_822C0890(ctx, base);
	// 82AA20D0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA20D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA20D8: 808B9F88  lwz r4, -0x6078(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24696 as u32) ) } as u64;
	// 82AA20DC: 4835192D  bl 0x82df3a08
	ctx.lr = 0x82AA20E0;
	sub_82DF3A08(ctx, base);
	// 82AA20E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA20E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA20E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA20EC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA20F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA20F4: 4E800421  bctrl
	ctx.lr = 0x82AA20F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA20F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA20FC: 4835132D  bl 0x82df3428
	ctx.lr = 0x82AA2100;
	sub_82DF3428(ctx, base);
	// 82AA2100: D3FE0080  stfs f31, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA2104: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AA2108: 48000574  b 0x82aa267c
	pc = 0x82AA267C; continue 'dispatch;
	// 82AA210C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA2110: 483B7669  bl 0x82e59778
	ctx.lr = 0x82AA2114;
	sub_82E59778(ctx, base);
	// 82AA2114: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2118: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA211C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA2120: D01E0080  stfs f0, 0x80(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA2124: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2128: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA212C: 40990554  ble cr6, 0x82aa2680
	if !ctx.cr[6].gt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA2130: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2134: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AA2138: 808B9F8C  lwz r4, -0x6074(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24692 as u32) ) } as u64;
	// 82AA213C: 483518CD  bl 0x82df3a08
	ctx.lr = 0x82AA2140;
	sub_82DF3A08(ctx, base);
	// 82AA2140: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2144: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82AA2148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA214C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA2150: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2154: 4E800421  bctrl
	ctx.lr = 0x82AA2158;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2158: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AA215C: 483512CD  bl 0x82df3428
	ctx.lr = 0x82AA2160;
	sub_82DF3428(ctx, base);
	// 82AA2160: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA2164: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82AA2168: 809E008C  lwz r4, 0x8c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA216C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA2170: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA2174: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA2178: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA217C: D3FE0080  stfs f31, 0x80(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA2180: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2184: 913E0088  stw r9, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82AA2188: D01E0084  stfs f0, 0x84(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA218C: 915E007C  stw r10, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 82AA2190: 4BD2D481  bl 0x827cf610
	ctx.lr = 0x82AA2194;
	sub_827CF610(ctx, base);
	// 82AA2194: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82AA2198: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA219C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA21A0: 4BA6D329  bl 0x8250f4c8
	ctx.lr = 0x82AA21A4;
	sub_8250F4C8(ctx, base);
	// 82AA21A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA21A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA21AC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA21B0: 409A0008  bne cr6, 0x82aa21b8
	if !ctx.cr[6].eq {
	pc = 0x82AA21B8; continue 'dispatch;
	}
	// 82AA21B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA21B8: 80BE008C  lwz r5, 0x8c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA21BC: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA21C0: 4BD2DBE1  bl 0x827cfda0
	ctx.lr = 0x82AA21C4;
	sub_827CFDA0(ctx, base);
	// 82AA21C4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA21C8: 4834FAC9  bl 0x82df1c90
	ctx.lr = 0x82AA21CC;
	sub_82DF1C90(ctx, base);
	// 82AA21CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA21D0: 83BE0094  lwz r29, 0x94(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA21D4: 4BE6825D  bl 0x8290a430
	ctx.lr = 0x82AA21D8;
	sub_8290A430(ctx, base);
	// 82AA21D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA21DC: 480A3B4D  bl 0x82b45d28
	ctx.lr = 0x82AA21E0;
	sub_82B45D28(ctx, base);
	// 82AA21E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA21E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA21E8: 388B1EBC  addi r4, r11, 0x1ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 7868;
	// 82AA21EC: 4835181D  bl 0x82df3a08
	ctx.lr = 0x82AA21F0;
	sub_82DF3A08(ctx, base);
	// 82AA21F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA21F4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AA21F8: 388B638C  addi r4, r11, 0x638c
	ctx.r[4].s64 = ctx.r[11].s64 + 25484;
	// 82AA21FC: 4835180D  bl 0x82df3a08
	ctx.lr = 0x82AA2200;
	sub_82DF3A08(ctx, base);
	// 82AA2200: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2204: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AA2208: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AA220C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA2210: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AA2214: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82AA2218: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AA221C: D3E100A0  stfs f31, 0xa0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA2220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2224: C00B6388  lfs f0, 0x6388(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2228: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 82AA222C: C1AA7218  lfs f13, 0x7218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2230: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82AA2234: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA2238: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 82AA223C: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA2240: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA2244: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AA2248: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA224C: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AA2250: 839E0074  lwz r28, 0x74(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA2254: 4BD4A375  bl 0x827ec5c8
	ctx.lr = 0x82AA2258;
	sub_827EC5C8(ctx, base);
	// 82AA2258: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA225C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2260: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82AA2264: 4BA6D265  bl 0x8250f4c8
	ctx.lr = 0x82AA2268;
	sub_8250F4C8(ctx, base);
	// 82AA2268: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA226C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA2270: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA2274: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AA2278: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA227C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA2280: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA2284: 4BD2DE3D  bl 0x827d00c0
	ctx.lr = 0x82AA2288;
	sub_827D00C0(ctx, base);
	// 82AA2288: 907E0090  stw r3, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82AA228C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82AA2290: 48351199  bl 0x82df3428
	ctx.lr = 0x82AA2294;
	sub_82DF3428(ctx, base);
	// 82AA2294: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA2298: 48351191  bl 0x82df3428
	ctx.lr = 0x82AA229C;
	sub_82DF3428(ctx, base);
	// 82AA229C: 480003E4  b 0x82aa2680
	pc = 0x82AA2680; continue 'dispatch;
	// 82AA22A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA22A4: 483B74D5  bl 0x82e59778
	ctx.lr = 0x82AA22A8;
	sub_82E59778(ctx, base);
	// 82AA22A8: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA22AC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA22B0: D01E0080  stfs f0, 0x80(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA22B4: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA22B8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA22BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA22C0: 41990244  bgt cr6, 0x82aa2504
	if ctx.cr[6].gt {
	pc = 0x82AA2504; continue 'dispatch;
	}
	// 82AA22C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA22C8: 483B74B1  bl 0x82e59778
	ctx.lr = 0x82AA22CC;
	sub_82E59778(ctx, base);
	// 82AA22CC: C01E0084  lfs f0, 0x84(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA22D0: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA22D4: D1BE0084  stfs f13, 0x84(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA22D8: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA22DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA22E0: 419803A0  blt cr6, 0x82aa2680
	if ctx.cr[6].lt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA22E4: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AA22E8: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AA22EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA22F0: 394AC5EC  addi r10, r10, -0x3a14
	ctx.r[10].s64 = ctx.r[10].s64 + -14868;
	// 82AA22F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA22F8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA22FC: 4835170D  bl 0x82df3a08
	ctx.lr = 0x82AA2300;
	sub_82DF3A08(ctx, base);
	// 82AA2300: 3B9B0010  addi r28, r27, 0x10
	ctx.r[28].s64 = ctx.r[27].s64 + 16;
	// 82AA2304: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA2308: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA230C: 4BD4A2BD  bl 0x827ec5c8
	ctx.lr = 0x82AA2310;
	sub_827EC5C8(ctx, base);
	// 82AA2310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2314: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82AA2318: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA231C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2320: 48372D11  bl 0x82e15030
	ctx.lr = 0x82AA2324;
	sub_82E15030(ctx, base);
	// 82AA2324: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA232C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA2330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2334: 4E800421  bctrl
	ctx.lr = 0x82AA2338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2338: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82AA233C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2344: 419A000C  beq cr6, 0x82aa2350
	if ctx.cr[6].eq {
	pc = 0x82AA2350; continue 'dispatch;
	}
	// 82AA2348: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA234C: 4B81E545  bl 0x822c0890
	ctx.lr = 0x82AA2350;
	sub_822C0890(ctx, base);
	// 82AA2350: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AA2354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA2358: 419A0008  beq cr6, 0x82aa2360
	if ctx.cr[6].eq {
	pc = 0x82AA2360; continue 'dispatch;
	}
	// 82AA235C: 4B81E535  bl 0x822c0890
	ctx.lr = 0x82AA2360;
	sub_822C0890(ctx, base);
	// 82AA2360: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA2364: 483510C5  bl 0x82df3428
	ctx.lr = 0x82AA2368;
	sub_82DF3428(ctx, base);
	// 82AA2368: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA236C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82AA2370: C02B1A38  lfs f1, 0x1a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA2374: 483DA675  bl 0x82e7c9e8
	ctx.lr = 0x82AA2378;
	sub_82E7C9E8(ctx, base);
	// 82AA2378: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA237C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2380: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82AA2384: 4B82257D  bl 0x822c4900
	ctx.lr = 0x82AA2388;
	sub_822C4900(ctx, base);
	// 82AA2388: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA238C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA2390: 388B6320  addi r4, r11, 0x6320
	ctx.r[4].s64 = ctx.r[11].s64 + 25376;
	// 82AA2394: 38A001B4  li r5, 0x1b4
	ctx.r[5].s64 = 436;
	// 82AA2398: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82AA239C: 4835004D  bl 0x82df23e8
	ctx.lr = 0x82AA23A0;
	sub_82DF23E8(ctx, base);
	// 82AA23A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA23A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA23A8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA23AC: 41820060  beq 0x82aa240c
	if ctx.cr[0].eq {
	pc = 0x82AA240C; continue 'dispatch;
	}
	// 82AA23B0: C00101C0  lfs f0, 0x1c0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA23B4: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82AA23B8: C1A101C4  lfs f13, 0x1c4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA23BC: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 82AA23C0: C18101C8  lfs f12, 0x1c8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA23C4: C16101CC  lfs f11, 0x1cc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA23C8: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82AA23CC: D1A100D4  stfs f13, 0xd4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AA23D0: D18100D8  stfs f12, 0xd8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82AA23D4: D16100DC  stfs f11, 0xdc(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82AA23D8: 483DAA31  bl 0x82e7ce08
	ctx.lr = 0x82AA23DC;
	sub_82E7CE08(ctx, base);
	// 82AA23DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA23E0: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82AA23E4: 3B4100D0  addi r26, r1, 0xd0
	ctx.r[26].s64 = ctx.r[1].s64 + 208;
	// 82AA23E8: 48566BD1  bl 0x83008fb8
	ctx.lr = 0x82AA23EC;
	sub_83008FB8(ctx, base);
	// 82AA23EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA23F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA23F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA23F8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA23FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA2400: 4BFF64D1  bl 0x82a988d0
	ctx.lr = 0x82AA2404;
	sub_82A988D0(ctx, base);
	// 82AA2404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2408: 48000008  b 0x82aa2410
	pc = 0x82AA2410; continue 'dispatch;
	// 82AA240C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA2410: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AA2414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2418: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA241C: 4BFFEA9D  bl 0x82aa0eb8
	ctx.lr = 0x82AA2420;
	sub_82AA0EB8(ctx, base);
	// 82AA2420: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA2424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2428: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA242C: 4B81DBD5  bl 0x822c0000
	ctx.lr = 0x82AA2430;
	sub_822C0000(ctx, base);
	// 82AA2430: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA2434: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA2438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA243C: 419A0098  beq cr6, 0x82aa24d4
	if ctx.cr[6].eq {
	pc = 0x82AA24D4; continue 'dispatch;
	}
	// 82AA2440: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AA2444: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82AA2448: 409A0008  bne cr6, 0x82aa2450
	if !ctx.cr[6].eq {
	pc = 0x82AA2450; continue 'dispatch;
	}
	// 82AA244C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA2450: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82AA2454: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA2458: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 82AA245C: 419A0024  beq cr6, 0x82aa2480
	if ctx.cr[6].eq {
	pc = 0x82AA2480; continue 'dispatch;
	}
	// 82AA2460: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82AA2464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA2468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA246C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA2470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA2474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA247C: 4082FFE8  bne 0x82aa2464
	if !ctx.cr[0].eq {
	pc = 0x82AA2464; continue 'dispatch;
	}
	// 82AA2480: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA2484: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA2488: 4BA6D041  bl 0x8250f4c8
	ctx.lr = 0x82AA248C;
	sub_8250F4C8(ctx, base);
	// 82AA248C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2494: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AA2498: 409A0008  bne cr6, 0x82aa24a0
	if !ctx.cr[6].eq {
	pc = 0x82AA24A0; continue 'dispatch;
	}
	// 82AA249C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA24A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA24A4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA24A8: 3B8100C0  addi r28, r1, 0xc0
	ctx.r[28].s64 = ctx.r[1].s64 + 192;
	// 82AA24AC: 4BA6D06D  bl 0x8250f518
	ctx.lr = 0x82AA24B0;
	sub_8250F518(ctx, base);
	// 82AA24B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA24B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA24B8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA24BC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA24C0: 4BA6B049  bl 0x8250d508
	ctx.lr = 0x82AA24C4;
	sub_8250D508(ctx, base);
	// 82AA24C4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA24C8: 4834F7C9  bl 0x82df1c90
	ctx.lr = 0x82AA24CC;
	sub_82DF1C90(ctx, base);
	// 82AA24CC: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA24D0: 4834F7C1  bl 0x82df1c90
	ctx.lr = 0x82AA24D4;
	sub_82DF1C90(ctx, base);
	// 82AA24D4: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 82AA24D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA24DC: 917E0088  stw r11, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AA24E0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82AA24E4: 41980008  blt cr6, 0x82aa24ec
	if ctx.cr[6].lt {
	pc = 0x82AA24EC; continue 'dispatch;
	}
	// 82AA24E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA24EC: D3FE0084  stfs f31, 0x84(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA24F0: 917E0088  stw r11, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AA24F4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA24F8: 419A0188  beq cr6, 0x82aa2680
	if ctx.cr[6].eq {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA24FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA2500: 4BFFF708  b 0x82aa1c08
	pc = 0x82AA1C08; continue 'dispatch;
	// 82AA2504: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA2508: 809E0090  lwz r4, 0x90(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA250C: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA2510: 4BD2D101  bl 0x827cf610
	ctx.lr = 0x82AA2514;
	sub_827CF610(ctx, base);
	// 82AA2514: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2518: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AA251C: 808B9F88  lwz r4, -0x6078(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24696 as u32) ) } as u64;
	// 82AA2520: 483514E9  bl 0x82df3a08
	ctx.lr = 0x82AA2524;
	sub_82DF3A08(ctx, base);
	// 82AA2524: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2528: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82AA252C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2530: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA2534: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2538: 4E800421  bctrl
	ctx.lr = 0x82AA253C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA253C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82AA2540: 48350EE9  bl 0x82df3428
	ctx.lr = 0x82AA2544;
	sub_82DF3428(ctx, base);
	// 82AA2544: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82AA2548: 4BFFF730  b 0x82aa1c78
	pc = 0x82AA1C78; continue 'dispatch;
	// 82AA254C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA2550: 483B7229  bl 0x82e59778
	ctx.lr = 0x82AA2554;
	sub_82E59778(ctx, base);
	// 82AA2554: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2558: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA255C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA2560: D01E0080  stfs f0, 0x80(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA2564: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2568: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA256C: 40990114  ble cr6, 0x82aa2680
	if !ctx.cr[6].gt {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA2570: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2574: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA2578: 808B9F90  lwz r4, -0x6070(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24688 as u32) ) } as u64;
	// 82AA257C: 4835148D  bl 0x82df3a08
	ctx.lr = 0x82AA2580;
	sub_82DF3A08(ctx, base);
	// 82AA2580: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2584: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA2588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA258C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA2590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2594: 4E800421  bctrl
	ctx.lr = 0x82AA2598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA259C: 48350E8D  bl 0x82df3428
	ctx.lr = 0x82AA25A0;
	sub_82DF3428(ctx, base);
	// 82AA25A0: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82AA25A4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA25A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA25AC: 4BA6CF1D  bl 0x8250f4c8
	ctx.lr = 0x82AA25B0;
	sub_8250F4C8(ctx, base);
	// 82AA25B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA25B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA25B8: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82AA25BC: 409A0008  bne cr6, 0x82aa25c4
	if !ctx.cr[6].eq {
	pc = 0x82AA25C4; continue 'dispatch;
	}
	// 82AA25C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA25C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA25C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA25CC: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82AA25D0: 3B8B1FD8  addi r28, r11, 0x1fd8
	ctx.r[28].s64 = ctx.r[11].s64 + 8152;
	// 82AA25D4: 4BD49FF5  bl 0x827ec5c8
	ctx.lr = 0x82AA25D8;
	sub_827EC5C8(ctx, base);
	// 82AA25D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA25DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA25E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA25E4: 3BEB5A2C  addi r31, r11, 0x5a2c
	ctx.r[31].s64 = ctx.r[11].s64 + 23084;
	// 82AA25E8: 4BE67E49  bl 0x8290a430
	ctx.lr = 0x82AA25EC;
	sub_8290A430(ctx, base);
	// 82AA25EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA25F0: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA25F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA25F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AA25FC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AA2600: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA2604: 480A3595  bl 0x82b45b98
	ctx.lr = 0x82AA2608;
	sub_82B45B98(ctx, base);
	// 82AA2608: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82AA260C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA2610: 419A0008  beq cr6, 0x82aa2618
	if ctx.cr[6].eq {
	pc = 0x82AA2618; continue 'dispatch;
	}
	// 82AA2614: 4B81E27D  bl 0x822c0890
	ctx.lr = 0x82AA2618;
	sub_822C0890(ctx, base);
	// 82AA2618: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA261C: 4834F675  bl 0x82df1c90
	ctx.lr = 0x82AA2620;
	sub_82DF1C90(ctx, base);
	// 82AA2620: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82AA2624: 48000058  b 0x82aa267c
	pc = 0x82AA267C; continue 'dispatch;
	// 82AA2628: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA262C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2630: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA2634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2638: 4E800421  bctrl
	ctx.lr = 0x82AA263C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA263C: 4BD47CD5  bl 0x827ea310
	ctx.lr = 0x82AA2640;
	sub_827EA310(ctx, base);
	// 82AA2640: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA2644: 4182003C  beq 0x82aa2680
	if ctx.cr[0].eq {
	pc = 0x82AA2680; continue 'dispatch;
	}
	// 82AA2648: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA264C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA2650: 808B9F94  lwz r4, -0x606c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24684 as u32) ) } as u64;
	// 82AA2654: 483513B5  bl 0x82df3a08
	ctx.lr = 0x82AA2658;
	sub_82DF3A08(ctx, base);
	// 82AA2658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA265C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AA2660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2664: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA2668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA266C: 4E800421  bctrl
	ctx.lr = 0x82AA2670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2670: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AA2674: 48350DB5  bl 0x82df3428
	ctx.lr = 0x82AA2678;
	sub_82DF3428(ctx, base);
	// 82AA2678: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82AA267C: 917E007C  stw r11, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AA2680: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82AA2684: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AA2688: 48705B24  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2690 size=128
    let mut pc: u32 = 0x82AA2690;
    'dispatch: loop {
        match pc {
            0x82AA2690 => {
    //   block [0x82AA2690..0x82AA2710)
	// 82AA2690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2694: 48705AD9  bl 0x831a816c
	ctx.lr = 0x82AA2698;
	sub_831A8130(ctx, base);
	// 82AA2698: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA269C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AA26A0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA26A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA26A8: 3BEBE404  addi r31, r11, -0x1bfc
	ctx.r[31].s64 = ctx.r[11].s64 + -7164;
	// 82AA26AC: 816AE40C  lwz r11, -0x1bf4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7156 as u32) ) } as u64;
	// 82AA26B0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AA26B4: 40820024  bne 0x82aa26d8
	if !ctx.cr[0].eq {
	pc = 0x82AA26D8; continue 'dispatch;
	}
	// 82AA26B8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82AA26BC: 3D0082AA  lis r8, -0x7d56
	ctx.r[8].s64 = -2102788096;
	// 82AA26C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AA26C4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82AA26C8: 39081048  addi r8, r8, 0x1048
	ctx.r[8].s64 = ctx.r[8].s64 + 4168;
	// 82AA26CC: 916AE40C  stw r11, -0x1bf4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7156 as u32), ctx.r[11].u32 ) };
	// 82AA26D0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA26D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA26D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA26DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA26E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA26E4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82AA26E8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82AA26EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA26F0: 4BBB1ED1  bl 0x826545c0
	ctx.lr = 0x82AA26F4;
	sub_826545C0(ctx, base);
	// 82AA26F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA26F8: 4182000C  beq 0x82aa2704
	if ctx.cr[0].eq {
	pc = 0x82AA2704; continue 'dispatch;
	}
	// 82AA26FC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA2700: 48000008  b 0x82aa2708
	pc = 0x82AA2708; continue 'dispatch;
	// 82AA2704: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AA2708: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA270C: 48705AB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2710 size=1112
    let mut pc: u32 = 0x82AA2710;
    'dispatch: loop {
        match pc {
            0x82AA2710 => {
    //   block [0x82AA2710..0x82AA2B68)
	// 82AA2710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2714: 48705A35  bl 0x831a8148
	ctx.lr = 0x82AA2718;
	sub_831A8130(ctx, base);
	// 82AA2718: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82AA271C: 4870635D  bl 0x831a8a78
	ctx.lr = 0x82AA2720;
	sub_831A8A40(ctx, base);
	// 82AA2720: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2724: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82AA2728: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA272C: 7EF6BB78  mr r22, r23
	ctx.r[22].u64 = ctx.r[23].u64;
	// 82AA2730: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82AA2734: 486B1ECD  bl 0x83154600
	ctx.lr = 0x82AA2738;
	sub_83154600(ctx, base);
	// 82AA2738: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA273C: 4BE165AD  bl 0x828b8ce8
	ctx.lr = 0x82AA2740;
	sub_828B8CE8(ctx, base);
	// 82AA2740: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2744: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AA2748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA274C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA2750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2754: 4E800421  bctrl
	ctx.lr = 0x82AA2758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2758: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA275C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AA2760: 4BFDF429  bl 0x82a81b88
	ctx.lr = 0x82AA2764;
	sub_82A81B88(ctx, base);
	// 82AA2764: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA2768: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA276C: 3BCBE418  addi r30, r11, -0x1be8
	ctx.r[30].s64 = ctx.r[11].s64 + -7144;
	// 82AA2770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2774: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 82AA2778: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA277C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA2780: 917D0060  stw r11, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA2784: 4BFE5F0D  bl 0x82a88690
	ctx.lr = 0x82AA2788;
	sub_82A88690(ctx, base);
	// 82AA2788: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA278C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2790: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA2794: 48351275  bl 0x82df3a08
	ctx.lr = 0x82AA2798;
	sub_82DF3A08(ctx, base);
	// 82AA2798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA279C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA27A0: 4BD4CFD1  bl 0x827ef770
	ctx.lr = 0x82AA27A4;
	sub_827EF770(ctx, base);
	// 82AA27A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA27A8: 48350C81  bl 0x82df3428
	ctx.lr = 0x82AA27AC;
	sub_82DF3428(ctx, base);
	// 82AA27AC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA27B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA27B4: 808B9F7C  lwz r4, -0x6084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) } as u64;
	// 82AA27B8: 48351251  bl 0x82df3a08
	ctx.lr = 0x82AA27BC;
	sub_82DF3A08(ctx, base);
	// 82AA27BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA27C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA27C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA27C8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA27CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA27D0: 4E800421  bctrl
	ctx.lr = 0x82AA27D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA27D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA27D8: 48350C51  bl 0x82df3428
	ctx.lr = 0x82AA27DC;
	sub_82DF3428(ctx, base);
	// 82AA27DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA27E0: 4BE5D211  bl 0x828ff9f0
	ctx.lr = 0x82AA27E4;
	sub_828FF9F0(ctx, base);
	// 82AA27E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA27E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82AA27EC: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA27F0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82AA27F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA27F8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82AA27FC: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2B68 size=248
    let mut pc: u32 = 0x82AA2B68;
    'dispatch: loop {
        match pc {
            0x82AA2B68 => {
    //   block [0x82AA2B68..0x82AA2C60)
	// 82AA2B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2B6C: 487055FD  bl 0x831a8168
	ctx.lr = 0x82AA2B70;
	sub_831A8130(ctx, base);
	// 82AA2B70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2B74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA2B78: 486B1A89  bl 0x83154600
	ctx.lr = 0x82AA2B7C;
	sub_83154600(ctx, base);
	// 82AA2B7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA2B80: 4BE16169  bl 0x828b8ce8
	ctx.lr = 0x82AA2B84;
	sub_828B8CE8(ctx, base);
	// 82AA2B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2B88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2B8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA2B90: 4BFE5B01  bl 0x82a88690
	ctx.lr = 0x82AA2B94;
	sub_82A88690(ctx, base);
	// 82AA2B94: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2B9C: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA2BA0: 48350E69  bl 0x82df3a08
	ctx.lr = 0x82AA2BA4;
	sub_82DF3A08(ctx, base);
	// 82AA2BA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2BA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA2BAC: 4BD4CBC5  bl 0x827ef770
	ctx.lr = 0x82AA2BB0;
	sub_827EF770(ctx, base);
	// 82AA2BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2BB4: 48350875  bl 0x82df3428
	ctx.lr = 0x82AA2BB8;
	sub_82DF3428(ctx, base);
	// 82AA2BB8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2BC0: 808B9F98  lwz r4, -0x6068(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24680 as u32) ) } as u64;
	// 82AA2BC4: 48350E45  bl 0x82df3a08
	ctx.lr = 0x82AA2BC8;
	sub_82DF3A08(ctx, base);
	// 82AA2BC8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2BCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2BD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA2BD4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA2BD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2BDC: 4E800421  bctrl
	ctx.lr = 0x82AA2BE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2BE4: 48350845  bl 0x82df3428
	ctx.lr = 0x82AA2BE8;
	sub_82DF3428(ctx, base);
	// 82AA2BE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA2BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2BF0: 4BFE1D79  bl 0x82a84968
	ctx.lr = 0x82AA2BF4;
	sub_82A84968(ctx, base);
	// 82AA2BF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2BF8: 4BE5CDF9  bl 0x828ff9f0
	ctx.lr = 0x82AA2BFC;
	sub_828FF9F0(ctx, base);
	// 82AA2BFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2C00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA2C04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2C08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2C0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2C10: 4E800421  bctrl
	ctx.lr = 0x82AA2C14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2C14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2C18: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 82AA2C1C: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AA2C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA2C24: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2C60 size=96
    let mut pc: u32 = 0x82AA2C60;
    'dispatch: loop {
        match pc {
            0x82AA2C60 => {
    //   block [0x82AA2C60..0x82AA2CC0)
	// 82AA2C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA2C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA2C6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2C74: 4BFF7225  bl 0x82a99e98
	ctx.lr = 0x82AA2C78;
	sub_82A99E98(ctx, base);
	// 82AA2C78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2C7C: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AA2C80: 396B640C  addi r11, r11, 0x640c
	ctx.r[11].s64 = ctx.r[11].s64 + 25612;
	// 82AA2C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2C88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA2C8C: 808ACA00  lwz r4, -0x3600(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13824 as u32) ) } as u64;
	// 82AA2C90: 48350D79  bl 0x82df3a08
	ctx.lr = 0x82AA2C94;
	sub_82DF3A08(ctx, base);
	// 82AA2C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA2C9C: 483B6A4D  bl 0x82e596e8
	ctx.lr = 0x82AA2CA0;
	sub_82E596E8(ctx, base);
	// 82AA2CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2CA4: 48350785  bl 0x82df3428
	ctx.lr = 0x82AA2CA8;
	sub_82DF3428(ctx, base);
	// 82AA2CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA2CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA2CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA2CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA2CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2CC0 size=196
    let mut pc: u32 = 0x82AA2CC0;
    'dispatch: loop {
        match pc {
            0x82AA2CC0 => {
    //   block [0x82AA2CC0..0x82AA2D84)
	// 82AA2CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA2CC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA2CCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA2CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2CD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA2CD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA2CDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA2CE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA2CE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA2CE8: 4B81DC51  bl 0x822c0938
	ctx.lr = 0x82AA2CEC;
	sub_822C0938(ctx, base);
	// 82AA2CEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA2CF0: 41820028  beq 0x82aa2d18
	if ctx.cr[0].eq {
	pc = 0x82AA2D18; continue 'dispatch;
	}
	// 82AA2CF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2CF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA2CFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA2D00: 392B63F8  addi r9, r11, 0x63f8
	ctx.r[9].s64 = ctx.r[11].s64 + 25592;
	// 82AA2D04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA2D08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2D0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA2D10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA2D14: 48000008  b 0x82aa2d1c
	pc = 0x82AA2D1C; continue 'dispatch;
	// 82AA2D18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA2D1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA2D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2D24: 409A0044  bne cr6, 0x82aa2d68
	if !ctx.cr[6].eq {
	pc = 0x82AA2D68; continue 'dispatch;
	}
	// 82AA2D28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA2D2C: 419A001C  beq cr6, 0x82aa2d48
	if ctx.cr[6].eq {
	pc = 0x82AA2D48; continue 'dispatch;
	}
	// 82AA2D30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2D34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA2D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2D3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA2D44: 4E800421  bctrl
	ctx.lr = 0x82AA2D48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA2D48: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2D4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA2D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA2D54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA2D58: 816BC818  lwz r11, -0x37e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14312 as u32) ) } as u64;
	// 82AA2D5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA2D60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA2D64: 4B81D29D  bl 0x822c0000
	ctx.lr = 0x82AA2D68;
	sub_822C0000(ctx, base);
	// 82AA2D68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA2D6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA2D70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA2D74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA2D78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA2D7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA2D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA2D88 size=112
    let mut pc: u32 = 0x82AA2D88;
    'dispatch: loop {
        match pc {
            0x82AA2D88 => {
    //   block [0x82AA2D88..0x82AA2DF8)
	// 82AA2D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2D8C: 487053E1  bl 0x831a816c
	ctx.lr = 0x82AA2D90;
	sub_831A8130(ctx, base);
	// 82AA2D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2D94: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2D98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA2D9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA2DA0: 388B6438  addi r4, r11, 0x6438
	ctx.r[4].s64 = ctx.r[11].s64 + 25656;
	// 82AA2DA4: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 82AA2DA8: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82AA2DAC: 4834F63D  bl 0x82df23e8
	ctx.lr = 0x82AA2DB0;
	sub_82DF23E8(ctx, base);
	// 82AA2DB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA2DB4: 41820010  beq 0x82aa2dc4
	if ctx.cr[0].eq {
	pc = 0x82AA2DC4; continue 'dispatch;
	}
	// 82AA2DB8: 4BFFFEA9  bl 0x82aa2c60
	ctx.lr = 0x82AA2DBC;
	sub_82AA2C60(ctx, base);
	// 82AA2DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2DC0: 48000008  b 0x82aa2dc8
	pc = 0x82AA2DC8; continue 'dispatch;
	// 82AA2DC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA2DC8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA2DCC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA2DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2DD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA2DD8: 4BFFFEE9  bl 0x82aa2cc0
	ctx.lr = 0x82AA2DDC;
	sub_82AA2CC0(ctx, base);
	// 82AA2DDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA2DE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA2DE8: 4B81D219  bl 0x822c0000
	ctx.lr = 0x82AA2DEC;
	sub_822C0000(ctx, base);
	// 82AA2DEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA2DF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA2DF4: 487053C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA2DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA2DF8 size=1528
    let mut pc: u32 = 0x82AA2DF8;
    'dispatch: loop {
        match pc {
            0x82AA2DF8 => {
    //   block [0x82AA2DF8..0x82AA33F0)
	// 82AA2DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA2DFC: 48705365  bl 0x831a8160
	ctx.lr = 0x82AA2E00;
	sub_831A8130(ctx, base);
	// 82AA2E00: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82AA2E04: 48705C71  bl 0x831a8a74
	ctx.lr = 0x82AA2E08;
	sub_831A8A40(ctx, base);
	// 82AA2E08: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA2E0C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA2E10: 486B17F1  bl 0x83154600
	ctx.lr = 0x82AA2E14;
	sub_83154600(ctx, base);
	// 82AA2E14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2E18: 4BE15ED1  bl 0x828b8ce8
	ctx.lr = 0x82AA2E1C;
	sub_828B8CE8(ctx, base);
	// 82AA2E1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA2E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2E24: 4BE5CBCD  bl 0x828ff9f0
	ctx.lr = 0x82AA2E28;
	sub_828FF9F0(ctx, base);
	// 82AA2E28: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA2E2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA2E30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA2E34: 41980450  blt cr6, 0x82aa3284
	if ctx.cr[6].lt {
	pc = 0x82AA3284; continue 'dispatch;
	}
	// 82AA2E38: 419A03C4  beq cr6, 0x82aa31fc
	if ctx.cr[6].eq {
	pc = 0x82AA31FC; continue 'dispatch;
	}
	// 82AA2E3C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AA2E40: 419800DC  blt cr6, 0x82aa2f1c
	if ctx.cr[6].lt {
	pc = 0x82AA2F1C; continue 'dispatch;
	}
	// 82AA2E44: 409A059C  bne cr6, 0x82aa33e0
	if !ctx.cr[6].eq {
	pc = 0x82AA33E0; continue 'dispatch;
	}
	// 82AA2E48: 3BFC0010  addi r31, r28, 0x10
	ctx.r[31].s64 = ctx.r[28].s64 + 16;
	// 82AA2E4C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA2E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2E54: 4BA6C715  bl 0x8250f568
	ctx.lr = 0x82AA2E58;
	sub_8250F568(ctx, base);
	// 82AA2E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2E60: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AA2E64: 409A0008  bne cr6, 0x82aa2e6c
	if !ctx.cr[6].eq {
	pc = 0x82AA2E6C; continue 'dispatch;
	}
	// 82AA2E68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA2E6C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2E70: 808BB56C  lwz r4, -0x4a94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19092 as u32) ) } as u64;
	// 82AA2E74: 4BD08235  bl 0x827ab0a8
	ctx.lr = 0x82AA2E78;
	sub_827AB0A8(ctx, base);
	// 82AA2E78: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA2E7C: 4834EE15  bl 0x82df1c90
	ctx.lr = 0x82AA2E80;
	sub_82DF1C90(ctx, base);
	// 82AA2E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA2E84: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA2E88: 4BA6C6E1  bl 0x8250f568
	ctx.lr = 0x82AA2E8C;
	sub_8250F568(ctx, base);
	// 82AA2E8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2E94: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AA2E98: 409A0008  bne cr6, 0x82aa2ea0
	if !ctx.cr[6].eq {
	pc = 0x82AA2EA0; continue 'dispatch;
	}
	// 82AA2E9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA2EA0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA2EA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA2EA8: 808BB570  lwz r4, -0x4a90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19088 as u32) ) } as u64;
	// 82AA2EAC: 4BD080B5  bl 0x827aaf60
	ctx.lr = 0x82AA2EB0;
	sub_827AAF60(ctx, base);
	// 82AA2EB0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA2EB4: 4834EDDD  bl 0x82df1c90
	ctx.lr = 0x82AA2EB8;
	sub_82DF1C90(ctx, base);
	// 82AA2EB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA2EBC: 4BDF52DD  bl 0x82898198
	ctx.lr = 0x82AA2EC0;
	sub_82898198(ctx, base);
	// 82AA2EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA2EC4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AA2EC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA2ECC: 4BFDEC95  bl 0x82a81b60
	ctx.lr = 0x82AA2ED0;
	sub_82A81B60(ctx, base);
	// 82AA2ED0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AA2ED4: 41990030  bgt cr6, 0x82aa2f04
	if ctx.cr[6].gt {
	pc = 0x82AA2F04; continue 'dispatch;
	}
	// 82AA2ED8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA2EDC: 4BFDE7CD  bl 0x82a816a8
	ctx.lr = 0x82AA2EE0;
	sub_82A816A8(ctx, base);
	// 82AA2EE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA2EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2EE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2EEC: 556BE7FE  rlwinm r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82AA2EF0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AA2EF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AA2EF8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82AA2EFC: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82AA2F00: 4BFE83F1  bl 0x82a8b2f0
	ctx.lr = 0x82AA2F04;
	sub_82A8B2F0(ctx, base);
	// 82AA2F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2F08: 4BFE9949  bl 0x82a8c850
	ctx.lr = 0x82AA2F0C;
	sub_82A8C850(ctx, base);
	// 82AA2F0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA2F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2F14: 4BFE9585  bl 0x82a8c498
	ctx.lr = 0x82AA2F18;
	sub_82A8C498(ctx, base);
	// 82AA2F18: 480004C8  b 0x82aa33e0
	pc = 0x82AA33E0; continue 'dispatch;
	// 82AA2F1C: 3B7C0010  addi r27, r28, 0x10
	ctx.r[27].s64 = ctx.r[28].s64 + 16;
	// 82AA2F20: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA2F24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA2F28: 4BE66731  bl 0x82909658
	ctx.lr = 0x82AA2F2C;
	sub_82909658(ctx, base);
	// 82AA2F2C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA2F30: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA2F34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AA2F38: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA2F3C: C3EB6150  lfs f31, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA2F40: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA2F44: 4098049C  bge cr6, 0x82aa33e0
	if !ctx.cr[6].lt {
	pc = 0x82AA33E0; continue 'dispatch;
	}
	// 82AA2F48: 897E0028  lbz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AA2F4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA2F50: 41820198  beq 0x82aa30e8
	if ctx.cr[0].eq {
	pc = 0x82AA30E8; continue 'dispatch;
	}
	// 82AA2F54: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AA2F58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2F5C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AA2F60: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA2F64: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82AA2F68: 388B64C0  addi r4, r11, 0x64c0
	ctx.r[4].s64 = ctx.r[11].s64 + 25792;
	// 82AA2F6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA2F70: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA2F74: 4BFD0C55  bl 0x82a73bc8
	ctx.lr = 0x82AA2F78;
	sub_82A73BC8(ctx, base);
	// 82AA2F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2F7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA2F80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA2F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2F88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA2F8C: 419A0024  beq cr6, 0x82aa2fb0
	if ctx.cr[6].eq {
	pc = 0x82AA2FB0; continue 'dispatch;
	}
	// 82AA2F90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA2F94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA2F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2F9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA2FA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA2FA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA2FA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA2FAC: 4082FFE8  bne 0x82aa2f94
	if !ctx.cr[0].eq {
	pc = 0x82AA2F94; continue 'dispatch;
	}
	// 82AA2FB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA2FB4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA2FB8: 4BA6C511  bl 0x8250f4c8
	ctx.lr = 0x82AA2FBC;
	sub_8250F4C8(ctx, base);
	// 82AA2FBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA2FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA2FC4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA2FC8: 409A0008  bne cr6, 0x82aa2fd0
	if !ctx.cr[6].eq {
	pc = 0x82AA2FD0; continue 'dispatch;
	}
	// 82AA2FCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA2FD0: 3BFC0038  addi r31, r28, 0x38
	ctx.r[31].s64 = ctx.r[28].s64 + 56;
	// 82AA2FD4: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82AA2FD8: 4BA65641  bl 0x82508618
	ctx.lr = 0x82AA2FDC;
	sub_82508618(ctx, base);
	// 82AA2FDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA2FE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA2FE4: 3BCB6438  addi r30, r11, 0x6438
	ctx.r[30].s64 = ctx.r[11].s64 + 25656;
	// 82AA2FE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA2FEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA2FF0: 38A000BA  li r5, 0xba
	ctx.r[5].s64 = 186;
	// 82AA2FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA2FF8: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA2FFC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA3000: 483B5A41  bl 0x82e58a40
	ctx.lr = 0x82AA3004;
	sub_82E58A40(ctx, base);
	// 82AA3004: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA3008: 4834EC89  bl 0x82df1c90
	ctx.lr = 0x82AA300C;
	sub_82DF1C90(ctx, base);
	// 82AA300C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA3010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3014: 419A0008  beq cr6, 0x82aa301c
	if ctx.cr[6].eq {
	pc = 0x82AA301C; continue 'dispatch;
	}
	// 82AA3018: 4B81D879  bl 0x822c0890
	ctx.lr = 0x82AA301C;
	sub_822C0890(ctx, base);
	// 82AA301C: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AA3020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3024: 419A0008  beq cr6, 0x82aa302c
	if ctx.cr[6].eq {
	pc = 0x82AA302C; continue 'dispatch;
	}
	// 82AA3028: 4B81D869  bl 0x822c0890
	ctx.lr = 0x82AA302C;
	sub_822C0890(ctx, base);
	// 82AA302C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AA3030: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3034: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82AA3038: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA303C: 388B64B4  addi r4, r11, 0x64b4
	ctx.r[4].s64 = ctx.r[11].s64 + 25780;
	// 82AA3040: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA3044: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA3048: 4BFD0B81  bl 0x82a73bc8
	ctx.lr = 0x82AA304C;
	sub_82A73BC8(ctx, base);
	// 82AA304C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3050: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA3054: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA305C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA3060: 419A0024  beq cr6, 0x82aa3084
	if ctx.cr[6].eq {
	pc = 0x82AA3084; continue 'dispatch;
	}
	// 82AA3064: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA3068: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA306C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3070: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA3074: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3078: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA307C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3080: 4082FFE8  bne 0x82aa3068
	if !ctx.cr[0].eq {
	pc = 0x82AA3068; continue 'dispatch;
	}
	// 82AA3084: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA3088: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA308C: 4BA6C43D  bl 0x8250f4c8
	ctx.lr = 0x82AA3090;
	sub_8250F4C8(ctx, base);
	// 82AA3090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3098: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA309C: 409A0008  bne cr6, 0x82aa30a4
	if !ctx.cr[6].eq {
	pc = 0x82AA30A4; continue 'dispatch;
	}
	// 82AA30A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA30A4: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82AA30A8: 4BA65571  bl 0x82508618
	ctx.lr = 0x82AA30AC;
	sub_82508618(ctx, base);
	// 82AA30AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA30B0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA30B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA30B8: 38A000BB  li r5, 0xbb
	ctx.r[5].s64 = 187;
	// 82AA30BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA30C0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA30C4: 483B597D  bl 0x82e58a40
	ctx.lr = 0x82AA30C8;
	sub_82E58A40(ctx, base);
	// 82AA30C8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA30CC: 4834EBC5  bl 0x82df1c90
	ctx.lr = 0x82AA30D0;
	sub_82DF1C90(ctx, base);
	// 82AA30D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA30D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA30D8: 419A0008  beq cr6, 0x82aa30e0
	if ctx.cr[6].eq {
	pc = 0x82AA30E0; continue 'dispatch;
	}
	// 82AA30DC: 4B81D7B5  bl 0x822c0890
	ctx.lr = 0x82AA30E0;
	sub_822C0890(ctx, base);
	// 82AA30E0: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AA30E4: 48000104  b 0x82aa31e8
	pc = 0x82AA31E8; continue 'dispatch;
	// 82AA30E8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AA30EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA30F0: 4BFDEA71  bl 0x82a81b60
	ctx.lr = 0x82AA30F4;
	sub_82A81B60(ctx, base);
	// 82AA30F4: 2B030002  cmplwi cr6, r3, 2
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2 as u32, &mut ctx.xer);
	// 82AA30F8: 419A0024  beq cr6, 0x82aa311c
	if ctx.cr[6].eq {
	pc = 0x82AA311C; continue 'dispatch;
	}
	// 82AA30FC: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82AA3100: 419A0010  beq cr6, 0x82aa3110
	if ctx.cr[6].eq {
	pc = 0x82AA3110; continue 'dispatch;
	}
	// 82AA3104: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3108: 396B64A8  addi r11, r11, 0x64a8
	ctx.r[11].s64 = ctx.r[11].s64 + 25768;
	// 82AA310C: 48000018  b 0x82aa3124
	pc = 0x82AA3124; continue 'dispatch;
	// 82AA3110: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3114: 396B649C  addi r11, r11, 0x649c
	ctx.r[11].s64 = ctx.r[11].s64 + 25756;
	// 82AA3118: 4800000C  b 0x82aa3124
	pc = 0x82AA3124; continue 'dispatch;
	// 82AA311C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3120: 396B6490  addi r11, r11, 0x6490
	ctx.r[11].s64 = ctx.r[11].s64 + 25744;
	// 82AA3124: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AA3128: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA312C: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82AA3130: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82AA3134: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA3138: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82AA313C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA3140: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA3144: 4BFE07A5  bl 0x82a838e8
	ctx.lr = 0x82AA3148;
	sub_82A838E8(ctx, base);
	// 82AA3148: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA314C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA3150: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3158: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA315C: 419A0024  beq cr6, 0x82aa3180
	if ctx.cr[6].eq {
	pc = 0x82AA3180; continue 'dispatch;
	}
	// 82AA3160: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA3164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA3168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA316C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA3170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA3178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA317C: 4082FFE8  bne 0x82aa3164
	if !ctx.cr[0].eq {
	pc = 0x82AA3164; continue 'dispatch;
	}
	// 82AA3180: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA3184: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA3188: 4BA6C341  bl 0x8250f4c8
	ctx.lr = 0x82AA318C;
	sub_8250F4C8(ctx, base);
	// 82AA318C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3194: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA3198: 409A0008  bne cr6, 0x82aa31a0
	if !ctx.cr[6].eq {
	pc = 0x82AA31A0; continue 'dispatch;
	}
	// 82AA319C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA31A0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82AA31A4: 4BA65475  bl 0x82508618
	ctx.lr = 0x82AA31A8;
	sub_82508618(ctx, base);
	// 82AA31A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA31AC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA31B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA31B4: 388A6438  addi r4, r10, 0x6438
	ctx.r[4].s64 = ctx.r[10].s64 + 25656;
	// 82AA31B8: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 82AA31BC: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82AA31C0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA31C4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA31C8: 483B5879  bl 0x82e58a40
	ctx.lr = 0x82AA31CC;
	sub_82E58A40(ctx, base);
	// 82AA31CC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA31D0: 4834EAC1  bl 0x82df1c90
	ctx.lr = 0x82AA31D4;
	sub_82DF1C90(ctx, base);
	// 82AA31D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA31D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA31DC: 419A0008  beq cr6, 0x82aa31e4
	if ctx.cr[6].eq {
	pc = 0x82AA31E4; continue 'dispatch;
	}
	// 82AA31E0: 4B81D6B1  bl 0x822c0890
	ctx.lr = 0x82AA31E4;
	sub_822C0890(ctx, base);
	// 82AA31E4: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AA31E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA31EC: 419A0008  beq cr6, 0x82aa31f4
	if ctx.cr[6].eq {
	pc = 0x82AA31F4; continue 'dispatch;
	}
	// 82AA31F0: 4B81D6A1  bl 0x822c0890
	ctx.lr = 0x82AA31F4;
	sub_822C0890(ctx, base);
	// 82AA31F4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA31F8: 480001E4  b 0x82aa33dc
	pc = 0x82AA33DC; continue 'dispatch;
	// 82AA31FC: 4BFDE415  bl 0x82a81610
	ctx.lr = 0x82AA3200;
	sub_82A81610(ctx, base);
	// 82AA3200: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA3204: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 82AA3208: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA320C: 4BE6644D  bl 0x82909658
	ctx.lr = 0x82AA3210;
	sub_82909658(ctx, base);
	// 82AA3210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3214: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA321C: C1BA0070  lfs f13, 0x70(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA3220: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA3224: C19D0030  lfs f12, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA3228: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA322C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3230: EFCC002A  fadds f30, f12, f0
	ctx.f[30].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA3234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3238: 4E800421  bctrl
	ctx.lr = 0x82AA323C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA323C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82AA3240: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA3244: FF1FF000  fcmpu cr6, f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA33F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA33F0 size=36
    let mut pc: u32 = 0x82AA33F0;
    'dispatch: loop {
        match pc {
            0x82AA33F0 => {
    //   block [0x82AA33F0..0x82AA3414)
	// 82AA33F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AA33F4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA33F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82AA33FC: 394A64F0  addi r10, r10, 0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + 25840;
	// 82AA3400: 99230008  stb r9, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82AA3404: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3408: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA340C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA3410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA3418 size=24
    let mut pc: u32 = 0x82AA3418;
    'dispatch: loop {
        match pc {
            0x82AA3418 => {
    //   block [0x82AA3418..0x82AA3430)
	// 82AA3418: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA341C: D0230004  stfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA3420: 98A30008  stb r5, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u8 ) };
	// 82AA3424: 396B64F0  addi r11, r11, 0x64f0
	ctx.r[11].s64 = ctx.r[11].s64 + 25840;
	// 82AA3428: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA342C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3430 size=196
    let mut pc: u32 = 0x82AA3430;
    'dispatch: loop {
        match pc {
            0x82AA3430 => {
    //   block [0x82AA3430..0x82AA34F4)
	// 82AA3430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA343C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA344C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA3450: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA3454: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA3458: 4B81D4E1  bl 0x822c0938
	ctx.lr = 0x82AA345C;
	sub_822C0938(ctx, base);
	// 82AA345C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA3460: 41820028  beq 0x82aa3488
	if ctx.cr[0].eq {
	pc = 0x82AA3488; continue 'dispatch;
	}
	// 82AA3464: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3468: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA346C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA3470: 392B64F8  addi r9, r11, 0x64f8
	ctx.r[9].s64 = ctx.r[11].s64 + 25848;
	// 82AA3474: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA3478: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA347C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA3480: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA3484: 48000008  b 0x82aa348c
	pc = 0x82AA348C; continue 'dispatch;
	// 82AA3488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA348C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA3490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3494: 409A0044  bne cr6, 0x82aa34d8
	if !ctx.cr[6].eq {
	pc = 0x82AA34D8; continue 'dispatch;
	}
	// 82AA3498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA349C: 419A001C  beq cr6, 0x82aa34b8
	if ctx.cr[6].eq {
	pc = 0x82AA34B8; continue 'dispatch;
	}
	// 82AA34A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA34A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA34A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA34AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA34B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA34B4: 4E800421  bctrl
	ctx.lr = 0x82AA34B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA34B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA34BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA34C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA34C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA34C8: 816BC8A8  lwz r11, -0x3758(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14168 as u32) ) } as u64;
	// 82AA34CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA34D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA34D4: 4B81CB2D  bl 0x822c0000
	ctx.lr = 0x82AA34D8;
	sub_822C0000(ctx, base);
	// 82AA34D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA34DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA34E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA34E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA34E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA34EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA34F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA34F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA34F8 size=124
    let mut pc: u32 = 0x82AA34F8;
    'dispatch: loop {
        match pc {
            0x82AA34F8 => {
    //   block [0x82AA34F8..0x82AA3574)
	// 82AA34F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA34FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA350C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA3510: 419A004C  beq cr6, 0x82aa355c
	if ctx.cr[6].eq {
	pc = 0x82AA355C; continue 'dispatch;
	}
	// 82AA3514: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA351C: 419A0018  beq cr6, 0x82aa3534
	if ctx.cr[6].eq {
	pc = 0x82AA3534; continue 'dispatch;
	}
	// 82AA3520: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3524: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA352C: 4E800421  bctrl
	ctx.lr = 0x82AA3530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3530: 4800000C  b 0x82aa353c
	pc = 0x82AA353C; continue 'dispatch;
	// 82AA3534: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA3538: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA353C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3540: 388BC8AC  addi r4, r11, -0x3754
	ctx.r[4].s64 = ctx.r[11].s64 + -14164;
	// 82AA3544: 48704BB5  bl 0x831a80f8
	ctx.lr = 0x82AA3548;
	sub_831A80F8(ctx, base);
	// 82AA3548: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA354C: 41820010  beq 0x82aa355c
	if ctx.cr[0].eq {
	pc = 0x82AA355C; continue 'dispatch;
	}
	// 82AA3550: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3554: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AA3558: 48000008  b 0x82aa3560
	pc = 0x82AA3560; continue 'dispatch;
	// 82AA355C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA3560: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA3564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA356C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA3578 size=12
    let mut pc: u32 = 0x82AA3578;
    'dispatch: loop {
        match pc {
            0x82AA3578 => {
    //   block [0x82AA3578..0x82AA3584)
	// 82AA3578: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA357C: 386BC8AC  addi r3, r11, -0x3754
	ctx.r[3].s64 = ctx.r[11].s64 + -14164;
	// 82AA3580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3588 size=104
    let mut pc: u32 = 0x82AA3588;
    'dispatch: loop {
        match pc {
            0x82AA3588 => {
    //   block [0x82AA3588..0x82AA35F0)
	// 82AA3588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA358C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA359C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA35A0: 4B81D399  bl 0x822c0938
	ctx.lr = 0x82AA35A4;
	sub_822C0938(ctx, base);
	// 82AA35A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA35A8: 41820030  beq 0x82aa35d8
	if ctx.cr[0].eq {
	pc = 0x82AA35D8; continue 'dispatch;
	}
	// 82AA35AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA35B0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA35B4: 396B650C  addi r11, r11, 0x650c
	ctx.r[11].s64 = ctx.r[11].s64 + 25868;
	// 82AA35B8: 394A64F0  addi r10, r10, 0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + 25840;
	// 82AA35BC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA35C0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA35C4: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA35C8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA35CC: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA35D0: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82AA35D4: 48000008  b 0x82aa35dc
	pc = 0x82AA35DC; continue 'dispatch;
	// 82AA35D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA35DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA35E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA35E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA35E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA35EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA35F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA35F0 size=128
    let mut pc: u32 = 0x82AA35F0;
    'dispatch: loop {
        match pc {
            0x82AA35F0 => {
    //   block [0x82AA35F0..0x82AA3670)
	// 82AA35F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA35F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA35F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA35FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3604: 4BFF6895  bl 0x82a99e98
	ctx.lr = 0x82AA3608;
	sub_82A99E98(ctx, base);
	// 82AA3608: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AA360C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3610: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AA3614: 396B651C  addi r11, r11, 0x651c
	ctx.r[11].s64 = ctx.r[11].s64 + 25884;
	// 82AA3618: 392964F0  addi r9, r9, 0x64f0
	ctx.r[9].s64 = ctx.r[9].s64 + 25840;
	// 82AA361C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AA3620: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA3624: C00AD7BC  lfs f0, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3628: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82AA362C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AA3630: 991F006C  stb r8, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u8 ) };
	// 82AA3634: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA363C: 808BC9E8  lwz r4, -0x3618(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13848 as u32) ) } as u64;
	// 82AA3640: 483503C9  bl 0x82df3a08
	ctx.lr = 0x82AA3644;
	sub_82DF3A08(ctx, base);
	// 82AA3644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA364C: 483B609D  bl 0x82e596e8
	ctx.lr = 0x82AA3650;
	sub_82E596E8(ctx, base);
	// 82AA3650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3654: 4834FDD5  bl 0x82df3428
	ctx.lr = 0x82AA3658;
	sub_82DF3428(ctx, base);
	// 82AA3658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA365C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3668: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA366C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA3670 size=660
    let mut pc: u32 = 0x82AA3670;
    'dispatch: loop {
        match pc {
            0x82AA3670 => {
    //   block [0x82AA3670..0x82AA3904)
	// 82AA3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3674: 48704AF5  bl 0x831a8168
	ctx.lr = 0x82AA3678;
	sub_831A8130(ctx, base);
	// 82AA3678: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82AA367C: 487053F9  bl 0x831a8a74
	ctx.lr = 0x82AA3680;
	sub_831A8A40(ctx, base);
	// 82AA3680: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3908 size=140
    let mut pc: u32 = 0x82AA3908;
    'dispatch: loop {
        match pc {
            0x82AA3908 => {
    //   block [0x82AA3908..0x82AA3994)
	// 82AA3908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA390C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA3914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA391C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3920: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA3924: 4BFFFBD5  bl 0x82aa34f8
	ctx.lr = 0x82AA3928;
	sub_82AA34F8(ctx, base);
	// 82AA3928: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA392C: 40820030  bne 0x82aa395c
	if !ctx.cr[0].eq {
	pc = 0x82AA395C; continue 'dispatch;
	}
	// 82AA3930: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA3934: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA3938: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82AA393C: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82AA3940: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA3944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3948: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA394C: 4B81C6B5  bl 0x822c0000
	ctx.lr = 0x82AA3950;
	sub_822C0000(ctx, base);
	// 82AA3950: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA3954: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82AA3958: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA395C: 897E0008  lbz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA3960: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA3964: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA396C: 394A64F0  addi r10, r10, 0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + 25840;
	// 82AA3970: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA3974: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA3978: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82AA397C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA398C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3998 size=128
    let mut pc: u32 = 0x82AA3998;
    'dispatch: loop {
        match pc {
            0x82AA3998 => {
    //   block [0x82AA3998..0x82AA3A18)
	// 82AA3998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA399C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA39A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA39A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA39A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA39AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA39B0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA39B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA39B8: 4B81CF81  bl 0x822c0938
	ctx.lr = 0x82AA39BC;
	sub_822C0938(ctx, base);
	// 82AA39BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA39C0: 41820034  beq 0x82aa39f4
	if ctx.cr[0].eq {
	pc = 0x82AA39F4; continue 'dispatch;
	}
	// 82AA39C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA39C8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA39CC: 396B650C  addi r11, r11, 0x650c
	ctx.r[11].s64 = ctx.r[11].s64 + 25868;
	// 82AA39D0: 394A64F0  addi r10, r10, 0x64f0
	ctx.r[10].s64 = ctx.r[10].s64 + 25840;
	// 82AA39D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA39D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA39DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA39E0: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA39E4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA39E8: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA39EC: 9943000C  stb r10, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 82AA39F0: 48000008  b 0x82aa39f8
	pc = 0x82AA39F8; continue 'dispatch;
	// 82AA39F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA39F8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA39FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3A0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA3A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3A18 size=112
    let mut pc: u32 = 0x82AA3A18;
    'dispatch: loop {
        match pc {
            0x82AA3A18 => {
    //   block [0x82AA3A18..0x82AA3A88)
	// 82AA3A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3A1C: 48704751  bl 0x831a816c
	ctx.lr = 0x82AA3A20;
	sub_831A8130(ctx, base);
	// 82AA3A20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3A24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3A28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA3A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA3A30: 388B6548  addi r4, r11, 0x6548
	ctx.r[4].s64 = ctx.r[11].s64 + 25928;
	// 82AA3A34: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 82AA3A38: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 82AA3A3C: 4834E9AD  bl 0x82df23e8
	ctx.lr = 0x82AA3A40;
	sub_82DF23E8(ctx, base);
	// 82AA3A40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA3A44: 41820010  beq 0x82aa3a54
	if ctx.cr[0].eq {
	pc = 0x82AA3A54; continue 'dispatch;
	}
	// 82AA3A48: 4BFFFBA9  bl 0x82aa35f0
	ctx.lr = 0x82AA3A4C;
	sub_82AA35F0(ctx, base);
	// 82AA3A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3A50: 48000008  b 0x82aa3a58
	pc = 0x82AA3A58; continue 'dispatch;
	// 82AA3A54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA3A58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA3A5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA3A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3A68: 4BFFF9C9  bl 0x82aa3430
	ctx.lr = 0x82AA3A6C;
	sub_82AA3430(ctx, base);
	// 82AA3A6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA3A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3A78: 4B81C589  bl 0x822c0000
	ctx.lr = 0x82AA3A7C;
	sub_822C0000(ctx, base);
	// 82AA3A7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA3A80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3A84: 48704738  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3A88 size=308
    let mut pc: u32 = 0x82AA3A88;
    'dispatch: loop {
        match pc {
            0x82AA3A88 => {
    //   block [0x82AA3A88..0x82AA3BBC)
	// 82AA3A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3A90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA3A94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3A98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3A9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3AA0: 486B0B61  bl 0x83154600
	ctx.lr = 0x82AA3AA4;
	sub_83154600(ctx, base);
	// 82AA3AA4: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA3AA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3AAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA3AB0: 41980088  blt cr6, 0x82aa3b38
	if ctx.cr[6].lt {
	pc = 0x82AA3B38; continue 'dispatch;
	}
	// 82AA3AB4: 409A00F0  bne cr6, 0x82aa3ba4
	if !ctx.cr[6].eq {
	pc = 0x82AA3BA4; continue 'dispatch;
	}
	// 82AA3AB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3ABC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA3AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3AC4: 4E800421  bctrl
	ctx.lr = 0x82AA3AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3AC8: 4BD46849  bl 0x827ea310
	ctx.lr = 0x82AA3ACC;
	sub_827EA310(ctx, base);
	// 82AA3ACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA3AD0: 418200D4  beq 0x82aa3ba4
	if ctx.cr[0].eq {
	pc = 0x82AA3BA4; continue 'dispatch;
	}
	// 82AA3AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3AD8: 486B0B29  bl 0x83154600
	ctx.lr = 0x82AA3ADC;
	sub_83154600(ctx, base);
	// 82AA3ADC: 4BE1520D  bl 0x828b8ce8
	ctx.lr = 0x82AA3AE0;
	sub_828B8CE8(ctx, base);
	// 82AA3AE0: 4BDF46B9  bl 0x82898198
	ctx.lr = 0x82AA3AE4;
	sub_82898198(ctx, base);
	// 82AA3AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3AE8: 4BFE8351  bl 0x82a8be38
	ctx.lr = 0x82AA3AEC;
	sub_82A8BE38(ctx, base);
	// 82AA3AEC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3AF0: 816BC9E8  lwz r11, -0x3618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13848 as u32) ) } as u64;
	// 82AA3AF4: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3AF8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3AFC: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82AA3B00: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AA3B04: 41820014  beq 0x82aa3b18
	if ctx.cr[0].eq {
	pc = 0x82AA3B18; continue 'dispatch;
	}
	// 82AA3B08: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82AA3B0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA3B10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA3B14: 419AFFE0  beq cr6, 0x82aa3af4
	if ctx.cr[6].eq {
	pc = 0x82AA3AF4; continue 'dispatch;
	}
	// 82AA3B18: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82AA3B1C: 4082000C  bne 0x82aa3b28
	if !ctx.cr[0].eq {
	pc = 0x82AA3B28; continue 'dispatch;
	}
	// 82AA3B20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3B24: 4BFE8C95  bl 0x82a8c7b8
	ctx.lr = 0x82AA3B28;
	sub_82A8C7B8(ctx, base);
	// 82AA3B28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3B2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3B30: 4BFE8969  bl 0x82a8c498
	ctx.lr = 0x82AA3B34;
	sub_82A8C498(ctx, base);
	// 82AA3B34: 48000070  b 0x82aa3ba4
	pc = 0x82AA3BA4; continue 'dispatch;
	// 82AA3B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3B3C: 4BFFFB35  bl 0x82aa3670
	ctx.lr = 0x82AA3B40;
	sub_82AA3670(ctx, base);
	// 82AA3B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3B44: 483B5C1D  bl 0x82e59760
	ctx.lr = 0x82AA3B48;
	sub_82E59760(ctx, base);
	// 82AA3B48: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3B4C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AA3B50: 40990054  ble cr6, 0x82aa3ba4
	if !ctx.cr[6].gt {
	pc = 0x82AA3BA4; continue 'dispatch;
	}
	// 82AA3B54: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA3B58: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA3B5C: 41820010  beq 0x82aa3b6c
	if ctx.cr[0].eq {
	pc = 0x82AA3B6C; continue 'dispatch;
	}
	// 82AA3B60: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3B64: 808B9F30  lwz r4, -0x60d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24784 as u32) ) } as u64;
	// 82AA3B68: 4800000C  b 0x82aa3b74
	pc = 0x82AA3B74; continue 'dispatch;
	// 82AA3B6C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3B70: 808B9F34  lwz r4, -0x60cc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24780 as u32) ) } as u64;
	// 82AA3B74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3B78: 4834FE91  bl 0x82df3a08
	ctx.lr = 0x82AA3B7C;
	sub_82DF3A08(ctx, base);
	// 82AA3B7C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA3B84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3B88: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA3B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3B90: 4E800421  bctrl
	ctx.lr = 0x82AA3B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3B98: 4834F891  bl 0x82df3428
	ctx.lr = 0x82AA3B9C;
	sub_82DF3428(ctx, base);
	// 82AA3B9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA3BA0: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA3BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3BA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3BAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3BB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA3BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3BC0 size=100
    let mut pc: u32 = 0x82AA3BC0;
    'dispatch: loop {
        match pc {
            0x82AA3BC0 => {
    //   block [0x82AA3BC0..0x82AA3C24)
	// 82AA3BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3BC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3BCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3BD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3BD8: 4BFFFDC1  bl 0x82aa3998
	ctx.lr = 0x82AA3BDC;
	sub_82AA3998(ctx, base);
	// 82AA3BDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3BE0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3BE4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA3BE8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA3BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3BF0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA3BF4: 419A0018  beq cr6, 0x82aa3c0c
	if ctx.cr[6].eq {
	pc = 0x82AA3C0C; continue 'dispatch;
	}
	// 82AA3BF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3BFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA3C00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3C04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3C08: 4E800421  bctrl
	ctx.lr = 0x82AA3C0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3C10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3C28 size=320
    let mut pc: u32 = 0x82AA3C28;
    'dispatch: loop {
        match pc {
            0x82AA3C28 => {
    //   block [0x82AA3C28..0x82AA3D68)
	// 82AA3C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3C2C: 48704541  bl 0x831a816c
	ctx.lr = 0x82AA3C30;
	sub_831A8130(ctx, base);
	// 82AA3C30: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA3C34: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA3C38: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3C3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA3C40: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA3C44: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA3C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3C4C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3C50: 4BB268B1  bl 0x825ca500
	ctx.lr = 0x82AA3C54;
	sub_825CA500(ctx, base);
	// 82AA3C54: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82AA3C58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA3C5C: 388B6980  addi r4, r11, 0x6980
	ctx.r[4].s64 = ctx.r[11].s64 + 27008;
	// 82AA3C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3C64: 4834FDA5  bl 0x82df3a08
	ctx.lr = 0x82AA3C68;
	sub_82DF3A08(ctx, base);
	// 82AA3C68: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AA3C6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3C70: 388B4C4C  addi r4, r11, 0x4c4c
	ctx.r[4].s64 = ctx.r[11].s64 + 19532;
	// 82AA3C74: 4834FD95  bl 0x82df3a08
	ctx.lr = 0x82AA3C78;
	sub_82DF3A08(ctx, base);
	// 82AA3C78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA3C7C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA3C80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA3C84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA3C88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA3C8C: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA3C90: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA3C94: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA3C98: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA3C9C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA3CA0: 4BAFF609  bl 0x825a32a8
	ctx.lr = 0x82AA3CA4;
	sub_825A32A8(ctx, base);
	// 82AA3CA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA3CA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA3CAC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA3CB0: 4BAFDAC1  bl 0x825a1770
	ctx.lr = 0x82AA3CB4;
	sub_825A1770(ctx, base);
	// 82AA3CB4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA3CB8: 4834F771  bl 0x82df3428
	ctx.lr = 0x82AA3CBC;
	sub_82DF3428(ctx, base);
	// 82AA3CBC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA3CC0: 4B824FF9  bl 0x822c8cb8
	ctx.lr = 0x82AA3CC4;
	sub_822C8CB8(ctx, base);
	// 82AA3CC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3CC8: 4834F761  bl 0x82df3428
	ctx.lr = 0x82AA3CCC;
	sub_82DF3428(ctx, base);
	// 82AA3CCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3CD0: 4834F759  bl 0x82df3428
	ctx.lr = 0x82AA3CD4;
	sub_82DF3428(ctx, base);
	// 82AA3CD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3CD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3CDC: 388B65A4  addi r4, r11, 0x65a4
	ctx.r[4].s64 = ctx.r[11].s64 + 26020;
	// 82AA3CE0: 4834FD29  bl 0x82df3a08
	ctx.lr = 0x82AA3CE4;
	sub_82DF3A08(ctx, base);
	// 82AA3CE4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AA3CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3CEC: 388B4BA4  addi r4, r11, 0x4ba4
	ctx.r[4].s64 = ctx.r[11].s64 + 19364;
	// 82AA3CF0: 4834FD19  bl 0x82df3a08
	ctx.lr = 0x82AA3CF4;
	sub_82DF3A08(ctx, base);
	// 82AA3CF4: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA3CF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA3CFC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA3D00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA3D04: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA3D08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA3D0C: 4BAFF59D  bl 0x825a32a8
	ctx.lr = 0x82AA3D10;
	sub_825A32A8(ctx, base);
	// 82AA3D10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA3D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA3D18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA3D1C: 4BAFDA55  bl 0x825a1770
	ctx.lr = 0x82AA3D20;
	sub_825A1770(ctx, base);
	// 82AA3D20: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA3D24: 4834F705  bl 0x82df3428
	ctx.lr = 0x82AA3D28;
	sub_82DF3428(ctx, base);
	// 82AA3D28: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA3D2C: 4B824F8D  bl 0x822c8cb8
	ctx.lr = 0x82AA3D30;
	sub_822C8CB8(ctx, base);
	// 82AA3D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3D34: 4834F6F5  bl 0x82df3428
	ctx.lr = 0x82AA3D38;
	sub_82DF3428(ctx, base);
	// 82AA3D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3D3C: 4834F6ED  bl 0x82df3428
	ctx.lr = 0x82AA3D40;
	sub_82DF3428(ctx, base);
	// 82AA3D40: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3D44: 4BB25F8D  bl 0x825c9cd0
	ctx.lr = 0x82AA3D48;
	sub_825C9CD0(ctx, base);
	// 82AA3D48: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3D50: 419A0008  beq cr6, 0x82aa3d58
	if ctx.cr[6].eq {
	pc = 0x82AA3D58; continue 'dispatch;
	}
	// 82AA3D54: 4B81CB3D  bl 0x822c0890
	ctx.lr = 0x82AA3D58;
	sub_822C0890(ctx, base);
	// 82AA3D58: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82AA3D5C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA3D60: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA3D64: 48704458  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3D68 size=292
    let mut pc: u32 = 0x82AA3D68;
    'dispatch: loop {
        match pc {
            0x82AA3D68 => {
    //   block [0x82AA3D68..0x82AA3E8C)
	// 82AA3D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3D6C: 48704401  bl 0x831a816c
	ctx.lr = 0x82AA3D70;
	sub_831A8130(ctx, base);
	// 82AA3D70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3D74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3D78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3D7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA3D80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3D84: 388B65D4  addi r4, r11, 0x65d4
	ctx.r[4].s64 = ctx.r[11].s64 + 26068;
	// 82AA3D88: 4834FC81  bl 0x82df3a08
	ctx.lr = 0x82AA3D8C;
	sub_82DF3A08(ctx, base);
	// 82AA3D8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA3D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3D94: 388B65C0  addi r4, r11, 0x65c0
	ctx.r[4].s64 = ctx.r[11].s64 + 26048;
	// 82AA3D98: 4834FC71  bl 0x82df3a08
	ctx.lr = 0x82AA3D9C;
	sub_82DF3A08(ctx, base);
	// 82AA3D9C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3DA0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA3DA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA3DA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3DAC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3DB0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA3DB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3DB8: 4E800421  bctrl
	ctx.lr = 0x82AA3DBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3DC0: 4834F669  bl 0x82df3428
	ctx.lr = 0x82AA3DC4;
	sub_82DF3428(ctx, base);
	// 82AA3DC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3DC8: 4834F661  bl 0x82df3428
	ctx.lr = 0x82AA3DCC;
	sub_82DF3428(ctx, base);
	// 82AA3DCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA3DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3DD4: 4BFEADBD  bl 0x82a8eb90
	ctx.lr = 0x82AA3DD8;
	sub_82A8EB90(ctx, base);
	// 82AA3DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA3DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3DE0: 4834FC29  bl 0x82df3a08
	ctx.lr = 0x82AA3DE4;
	sub_82DF3A08(ctx, base);
	// 82AA3DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3DE8: 4BFEADA9  bl 0x82a8eb90
	ctx.lr = 0x82AA3DEC;
	sub_82A8EB90(ctx, base);
	// 82AA3DEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA3DF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3DF4: 4834FC15  bl 0x82df3a08
	ctx.lr = 0x82AA3DF8;
	sub_82DF3A08(ctx, base);
	// 82AA3DF8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA3DFC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA3E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3E04: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA3E08: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA3E0C: 419A0024  beq cr6, 0x82aa3e30
	if ctx.cr[6].eq {
	pc = 0x82AA3E30; continue 'dispatch;
	}
	// 82AA3E10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA3E14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA3E18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3E1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA3E20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3E24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA3E28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3E2C: 4082FFE8  bne 0x82aa3e14
	if !ctx.cr[0].eq {
	pc = 0x82AA3E14; continue 'dispatch;
	}
	// 82AA3E30: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA3E34: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA3E38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA3E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA3E40: 4BFFFDE9  bl 0x82aa3c28
	ctx.lr = 0x82AA3E44;
	sub_82AA3C28(ctx, base);
	// 82AA3E44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA3E48: 4834F5E1  bl 0x82df3428
	ctx.lr = 0x82AA3E4C;
	sub_82DF3428(ctx, base);
	// 82AA3E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3E50: 4834F5D9  bl 0x82df3428
	ctx.lr = 0x82AA3E54;
	sub_82DF3428(ctx, base);
	// 82AA3E54: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82AA3E58: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82AA3E5C: 2B1F0002  cmplwi cr6, r31, 2
	ctx.cr[6].compare_u32(ctx.r[31].u32, 2 as u32, &mut ctx.xer);
	// 82AA3E60: 4198FF70  blt cr6, 0x82aa3dd0
	if ctx.cr[6].lt {
	pc = 0x82AA3DD0; continue 'dispatch;
	}
	// 82AA3E64: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA3E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3E6C: 419A0008  beq cr6, 0x82aa3e74
	if ctx.cr[6].eq {
	pc = 0x82AA3E74; continue 'dispatch;
	}
	// 82AA3E70: 4B81CA21  bl 0x822c0890
	ctx.lr = 0x82AA3E74;
	sub_822C0890(ctx, base);
	// 82AA3E74: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3E78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3E7C: 419A0008  beq cr6, 0x82aa3e84
	if ctx.cr[6].eq {
	pc = 0x82AA3E84; continue 'dispatch;
	}
	// 82AA3E80: 4B81CA11  bl 0x822c0890
	ctx.lr = 0x82AA3E84;
	sub_822C0890(ctx, base);
	// 82AA3E84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA3E88: 48704334  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA3E90 size=128
    let mut pc: u32 = 0x82AA3E90;
    'dispatch: loop {
        match pc {
            0x82AA3E90 => {
    //   block [0x82AA3E90..0x82AA3F10)
	// 82AA3E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3E9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3EA0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3EA4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA3EA8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA3EB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA3EB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA3EB8: 419A0024  beq cr6, 0x82aa3edc
	if ctx.cr[6].eq {
	pc = 0x82AA3EDC; continue 'dispatch;
	}
	// 82AA3EBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA3EC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA3EC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3EC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA3ECC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA3ED0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA3ED4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA3ED8: 4082FFE8  bne 0x82aa3ec0
	if !ctx.cr[0].eq {
	pc = 0x82AA3EC0; continue 'dispatch;
	}
	// 82AA3EDC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA3EE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA3EE4: 386BE464  addi r3, r11, -0x1b9c
	ctx.r[3].s64 = ctx.r[11].s64 + -7068;
	// 82AA3EE8: 4BFFFE81  bl 0x82aa3d68
	ctx.lr = 0x82AA3EEC;
	sub_82AA3D68(ctx, base);
	// 82AA3EEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3EF4: 419A0008  beq cr6, 0x82aa3efc
	if ctx.cr[6].eq {
	pc = 0x82AA3EFC; continue 'dispatch;
	}
	// 82AA3EF8: 4B81C999  bl 0x822c0890
	ctx.lr = 0x82AA3EFC;
	sub_822C0890(ctx, base);
	// 82AA3EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA3F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3F08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3F10 size=192
    let mut pc: u32 = 0x82AA3F10;
    'dispatch: loop {
        match pc {
            0x82AA3F10 => {
    //   block [0x82AA3F10..0x82AA3FD0)
	// 82AA3F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA3F18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA3F1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA3F20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3F28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA3F2C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AA3F30: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82AA3F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA3F38: 4B9EE3D1  bl 0x82492308
	ctx.lr = 0x82AA3F3C;
	sub_82492308(ctx, base);
	// 82AA3F3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA3F40: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AA3F44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA3F48: 419A006C  beq cr6, 0x82aa3fb4
	if ctx.cr[6].eq {
	pc = 0x82AA3FB4; continue 'dispatch;
	}
	// 82AA3F4C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA3F50: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82AA3F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA3F58: 419A0018  beq cr6, 0x82aa3f70
	if ctx.cr[6].eq {
	pc = 0x82AA3F70; continue 'dispatch;
	}
	// 82AA3F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3F60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA3F64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA3F68: 4E800421  bctrl
	ctx.lr = 0x82AA3F6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA3F6C: 4800000C  b 0x82aa3f78
	pc = 0x82AA3F78; continue 'dispatch;
	// 82AA3F70: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA3F74: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA3F78: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA3F7C: 388BC8AC  addi r4, r11, -0x3754
	ctx.r[4].s64 = ctx.r[11].s64 + -14164;
	// 82AA3F80: 48704179  bl 0x831a80f8
	ctx.lr = 0x82AA3F84;
	sub_831A80F8(ctx, base);
	// 82AA3F84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA3F88: 4182002C  beq 0x82aa3fb4
	if ctx.cr[0].eq {
	pc = 0x82AA3FB4; continue 'dispatch;
	}
	// 82AA3F8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA3F90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA3F94: 4BFFF975  bl 0x82aa3908
	ctx.lr = 0x82AA3F98;
	sub_82AA3908(ctx, base);
	// 82AA3F98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA3F9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA3FA0: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA3FA4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA3FA8: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA3FAC: 997E0008  stb r11, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82AA3FB0: 48000008  b 0x82aa3fb8
	pc = 0x82AA3FB8; continue 'dispatch;
	// 82AA3FB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA3FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA3FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA3FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA3FC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA3FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA3FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA3FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA3FD0 size=564
    let mut pc: u32 = 0x82AA3FD0;
    'dispatch: loop {
        match pc {
            0x82AA3FD0 => {
    //   block [0x82AA3FD0..0x82AA4204)
	// 82AA3FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA3FD4: 48704191  bl 0x831a8164
	ctx.lr = 0x82AA3FD8;
	sub_831A8130(ctx, base);
	// 82AA3FD8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AA3FDC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA3FE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA3FE4: 486B061D  bl 0x83154600
	ctx.lr = 0x82AA3FE8;
	sub_83154600(ctx, base);
	// 82AA3FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA3FEC: 4BE14CFD  bl 0x828b8ce8
	ctx.lr = 0x82AA3FF0;
	sub_828B8CE8(ctx, base);
	// 82AA3FF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA3FF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA3FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA3FFC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA4000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA4004: 4E800421  bctrl
	ctx.lr = 0x82AA4008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA4008: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA400C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4010: 4BFDD6A9  bl 0x82a816b8
	ctx.lr = 0x82AA4014;
	sub_82A816B8(ctx, base);
	// 82AA4014: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA4018: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA401C: 396BE464  addi r11, r11, -0x1b9c
	ctx.r[11].s64 = ctx.r[11].s64 + -7068;
	// 82AA4020: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA4024: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA4028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA402C: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA4030: 8089C8A4  lwz r4, -0x375c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14172 as u32) ) } as u64;
	// 82AA4034: 4834F9D5  bl 0x82df3a08
	ctx.lr = 0x82AA4038;
	sub_82DF3A08(ctx, base);
	// 82AA4038: 38BE0064  addi r5, r30, 0x64
	ctx.r[5].s64 = ctx.r[30].s64 + 100;
	// 82AA403C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4044: 4BFFFECD  bl 0x82aa3f10
	ctx.lr = 0x82AA4048;
	sub_82AA3F10(ctx, base);
	// 82AA4048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA404C: 4834F3DD  bl 0x82df3428
	ctx.lr = 0x82AA4050;
	sub_82DF3428(ctx, base);
	// 82AA4050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4054: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA4058: 4BFE4639  bl 0x82a88690
	ctx.lr = 0x82AA405C;
	sub_82A88690(ctx, base);
	// 82AA405C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4064: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA4068: 4834F9A1  bl 0x82df3a08
	ctx.lr = 0x82AA406C;
	sub_82DF3A08(ctx, base);
	// 82AA406C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4074: 4BD4B6FD  bl 0x827ef770
	ctx.lr = 0x82AA4078;
	sub_827EF770(ctx, base);
	// 82AA4078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA407C: 4834F3AD  bl 0x82df3428
	ctx.lr = 0x82AA4080;
	sub_82DF3428(ctx, base);
	// 82AA4080: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA4084: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4088: 41820010  beq 0x82aa4098
	if ctx.cr[0].eq {
	pc = 0x82AA4098; continue 'dispatch;
	}
	// 82AA408C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4090: 808B9F20  lwz r4, -0x60e0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24800 as u32) ) } as u64;
	// 82AA4094: 4800000C  b 0x82aa40a0
	pc = 0x82AA40A0; continue 'dispatch;
	// 82AA4098: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA409C: 808B9F24  lwz r4, -0x60dc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24796 as u32) ) } as u64;
	// 82AA40A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA40A4: 4834F965  bl 0x82df3a08
	ctx.lr = 0x82AA40A8;
	sub_82DF3A08(ctx, base);
	// 82AA40A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA40AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA40B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA40B4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA40B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA40BC: 4E800421  bctrl
	ctx.lr = 0x82AA40C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA40C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA40C4: 4834F365  bl 0x82df3428
	ctx.lr = 0x82AA40C8;
	sub_82DF3428(ctx, base);
	// 82AA40C8: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA40CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA40D0: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA40D4: 4BD46295  bl 0x827ea368
	ctx.lr = 0x82AA40D8;
	sub_827EA368(ctx, base);
	// 82AA40D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA40DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA40E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA40E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA40E8: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA40EC: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA40F0: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA40F4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA40F8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AA40FC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AA4100: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AA4104: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA4108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA410C: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA4110: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA4114: 4E800421  bctrl
	ctx.lr = 0x82AA4118;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA4118: 4BFDD4F9  bl 0x82a81610
	ctx.lr = 0x82AA411C;
	sub_82A81610(ctx, base);
	// 82AA411C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA4120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4124: 4BE5B8CD  bl 0x828ff9f0
	ctx.lr = 0x82AA4128;
	sub_828FF9F0(ctx, base);
	// 82AA4128: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA412C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA4130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4134: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA413C: 4E800421  bctrl
	ctx.lr = 0x82AA4140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA4140: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4208 size=96
    let mut pc: u32 = 0x82AA4208;
    'dispatch: loop {
        match pc {
            0x82AA4208 => {
    //   block [0x82AA4208..0x82AA4268)
	// 82AA4208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA420C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA421C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4228: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA422C: 808BC8A4  lwz r4, -0x375c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14172 as u32) ) } as u64;
	// 82AA4230: 4834F7D9  bl 0x82df3a08
	ctx.lr = 0x82AA4234;
	sub_82DF3A08(ctx, base);
	// 82AA4234: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4238: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA423C: 4B888605  bl 0x8232c840
	ctx.lr = 0x82AA4240;
	sub_8232C840(ctx, base);
	// 82AA4240: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4244: 4BFFF97D  bl 0x82aa3bc0
	ctx.lr = 0x82AA4248;
	sub_82AA3BC0(ctx, base);
	// 82AA4248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA424C: 4834F1DD  bl 0x82df3428
	ctx.lr = 0x82AA4250;
	sub_82DF3428(ctx, base);
	// 82AA4250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA425C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4268 size=196
    let mut pc: u32 = 0x82AA4268;
    'dispatch: loop {
        match pc {
            0x82AA4268 => {
    //   block [0x82AA4268..0x82AA432C)
	// 82AA4268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA426C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA427C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4284: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA4288: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA428C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA4290: 4B81C6A9  bl 0x822c0938
	ctx.lr = 0x82AA4294;
	sub_822C0938(ctx, base);
	// 82AA4294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4298: 41820028  beq 0x82aa42c0
	if ctx.cr[0].eq {
	pc = 0x82AA42C0; continue 'dispatch;
	}
	// 82AA429C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA42A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA42A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA42A8: 392B67D4  addi r9, r11, 0x67d4
	ctx.r[9].s64 = ctx.r[11].s64 + 26580;
	// 82AA42AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA42B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA42B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA42B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA42BC: 48000008  b 0x82aa42c4
	pc = 0x82AA42C4; continue 'dispatch;
	// 82AA42C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA42C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA42C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA42CC: 409A0044  bne cr6, 0x82aa4310
	if !ctx.cr[6].eq {
	pc = 0x82AA4310; continue 'dispatch;
	}
	// 82AA42D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA42D4: 419A001C  beq cr6, 0x82aa42f0
	if ctx.cr[6].eq {
	pc = 0x82AA42F0; continue 'dispatch;
	}
	// 82AA42D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA42DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA42E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA42E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA42E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA42EC: 4E800421  bctrl
	ctx.lr = 0x82AA42F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA42F0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA42F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA42F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA42FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA4300: 816BCA30  lwz r11, -0x35d0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13776 as u32) ) } as u64;
	// 82AA4304: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA4308: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA430C: 4B81BCF5  bl 0x822c0000
	ctx.lr = 0x82AA4310;
	sub_822C0000(ctx, base);
	// 82AA4310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA431C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4320: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4330 size=196
    let mut pc: u32 = 0x82AA4330;
    'dispatch: loop {
        match pc {
            0x82AA4330 => {
    //   block [0x82AA4330..0x82AA43F4)
	// 82AA4330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA433C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA434C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA4350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA4354: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA4358: 4B81C5E1  bl 0x822c0938
	ctx.lr = 0x82AA435C;
	sub_822C0938(ctx, base);
	// 82AA435C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4360: 41820028  beq 0x82aa4388
	if ctx.cr[0].eq {
	pc = 0x82AA4388; continue 'dispatch;
	}
	// 82AA4364: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA4368: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA436C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA4370: 392B67E8  addi r9, r11, 0x67e8
	ctx.r[9].s64 = ctx.r[11].s64 + 26600;
	// 82AA4374: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA4378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA437C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA4380: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA4384: 48000008  b 0x82aa438c
	pc = 0x82AA438C; continue 'dispatch;
	// 82AA4388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA438C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA4390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4394: 409A0044  bne cr6, 0x82aa43d8
	if !ctx.cr[6].eq {
	pc = 0x82AA43D8; continue 'dispatch;
	}
	// 82AA4398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA439C: 419A001C  beq cr6, 0x82aa43b8
	if ctx.cr[6].eq {
	pc = 0x82AA43B8; continue 'dispatch;
	}
	// 82AA43A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA43A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA43A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA43AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA43B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA43B4: 4E800421  bctrl
	ctx.lr = 0x82AA43B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA43B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA43BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA43C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA43C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA43C8: 816BCA30  lwz r11, -0x35d0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13776 as u32) ) } as u64;
	// 82AA43CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA43D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA43D4: 4B81BC2D  bl 0x822c0000
	ctx.lr = 0x82AA43D8;
	sub_822C0000(ctx, base);
	// 82AA43D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA43DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA43E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA43E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA43E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA43EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA43F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA43F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA43F8 size=112
    let mut pc: u32 = 0x82AA43F8;
    'dispatch: loop {
        match pc {
            0x82AA43F8 => {
    //   block [0x82AA43F8..0x82AA4468)
	// 82AA43F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA43FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA440C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA4410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4414: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AA4418: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA441C: 4BFFFF15  bl 0x82aa4330
	ctx.lr = 0x82AA4420;
	sub_82AA4330(ctx, base);
	// 82AA4420: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA4424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA4428: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA442C: 4B81BBD5  bl 0x822c0000
	ctx.lr = 0x82AA4430;
	sub_822C0000(ctx, base);
	// 82AA4430: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA4434: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA4438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA443C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4444: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA4448: 419A0008  beq cr6, 0x82aa4450
	if ctx.cr[6].eq {
	pc = 0x82AA4450; continue 'dispatch;
	}
	// 82AA444C: 4B81C445  bl 0x822c0890
	ctx.lr = 0x82AA4450;
	sub_822C0890(ctx, base);
	// 82AA4450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA445C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA4460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA4468 size=636
    let mut pc: u32 = 0x82AA4468;
    'dispatch: loop {
        match pc {
            0x82AA4468 => {
    //   block [0x82AA4468..0x82AA46E4)
	// 82AA4468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA446C: 48703CF9  bl 0x831a8164
	ctx.lr = 0x82AA4470;
	sub_831A8130(ctx, base);
	// 82AA4470: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AA4474: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4478: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA447C: 486B0185  bl 0x83154600
	ctx.lr = 0x82AA4480;
	sub_83154600(ctx, base);
	// 82AA4480: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA4484: 4BE14865  bl 0x828b8ce8
	ctx.lr = 0x82AA4488;
	sub_828B8CE8(ctx, base);
	// 82AA4488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA448C: 4BFDD26D  bl 0x82a816f8
	ctx.lr = 0x82AA4490;
	sub_82A816F8(ctx, base);
	// 82AA4490: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA4494: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA4498: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA449C: 3B8B67F8  addi r28, r11, 0x67f8
	ctx.r[28].s64 = ctx.r[11].s64 + 26616;
	// 82AA44A0: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA44A4: 41820098  beq 0x82aa453c
	if ctx.cr[0].eq {
	pc = 0x82AA453C; continue 'dispatch;
	}
	// 82AA44A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA44AC: 4BE813A5  bl 0x82925850
	ctx.lr = 0x82AA44B0;
	sub_82925850(ctx, base);
	// 82AA44B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA44B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA44B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA44BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA44C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA44C4: 419A0024  beq cr6, 0x82aa44e8
	if ctx.cr[6].eq {
	pc = 0x82AA44E8; continue 'dispatch;
	}
	// 82AA44C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA44CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA44D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA44D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA44D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA44DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA44E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA44E4: 4082FFE8  bne 0x82aa44cc
	if !ctx.cr[0].eq {
	pc = 0x82AA44CC; continue 'dispatch;
	}
	// 82AA44E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA44EC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82AA44F0: 4BFDD209  bl 0x82a816f8
	ctx.lr = 0x82AA44F4;
	sub_82A816F8(ctx, base);
	// 82AA44F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA44F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA44FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA4500: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 82AA4504: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA4508: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA450C: 483B4535  bl 0x82e58a40
	ctx.lr = 0x82AA4510;
	sub_82E58A40(ctx, base);
	// 82AA4510: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA4514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4518: 419A0008  beq cr6, 0x82aa4520
	if ctx.cr[6].eq {
	pc = 0x82AA4520; continue 'dispatch;
	}
	// 82AA451C: 4B81C375  bl 0x822c0890
	ctx.lr = 0x82AA4520;
	sub_822C0890(ctx, base);
	// 82AA4520: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA4524: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4528: 419A0008  beq cr6, 0x82aa4530
	if ctx.cr[6].eq {
	pc = 0x82AA4530; continue 'dispatch;
	}
	// 82AA452C: 4B81C365  bl 0x822c0890
	ctx.lr = 0x82AA4530;
	sub_822C0890(ctx, base);
	// 82AA4530: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA4534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4538: 4BFDD1B9  bl 0x82a816f0
	ctx.lr = 0x82AA453C;
	sub_82A816F0(ctx, base);
	// 82AA453C: 807D0078  lwz r3, 0x78(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA4540: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA4544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4548: 419A0020  beq cr6, 0x82aa4568
	if ctx.cr[6].eq {
	pc = 0x82AA4568; continue 'dispatch;
	}
	// 82AA454C: 4BFE4D7D  bl 0x82a892c8
	ctx.lr = 0x82AA4550;
	sub_82A892C8(ctx, base);
	// 82AA4550: 93DD0078  stw r30, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82AA4554: 807D007C  lwz r3, 0x7c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA4558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA455C: 93DD007C  stw r30, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82AA4560: 419A0008  beq cr6, 0x82aa4568
	if ctx.cr[6].eq {
	pc = 0x82AA4568; continue 'dispatch;
	}
	// 82AA4564: 4B81C32D  bl 0x822c0890
	ctx.lr = 0x82AA4568;
	sub_822C0890(ctx, base);
	// 82AA4568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA456C: 4BFDE3BD  bl 0x82a82928
	ctx.lr = 0x82AA4570;
	sub_82A82928(ctx, base);
	// 82AA4570: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA4574: 4BF25935  bl 0x829c9ea8
	ctx.lr = 0x82AA4578;
	sub_829C9EA8(ctx, base);
	// 82AA4578: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA457C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA4580: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4588: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA458C: 419A0024  beq cr6, 0x82aa45b0
	if ctx.cr[6].eq {
	pc = 0x82AA45B0; continue 'dispatch;
	}
	// 82AA4590: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA4594: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA4598: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA459C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA45A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA45A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA45A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA45AC: 4082FFE8  bne 0x82aa4594
	if !ctx.cr[0].eq {
	pc = 0x82AA4594; continue 'dispatch;
	}
	// 82AA45B0: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AA45B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA45B8: 4BA6AF11  bl 0x8250f4c8
	ctx.lr = 0x82AA45BC;
	sub_8250F4C8(ctx, base);
	// 82AA45BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA45C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA45C4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA45C8: 409A0008  bne cr6, 0x82aa45d0
	if !ctx.cr[6].eq {
	pc = 0x82AA45D0; continue 'dispatch;
	}
	// 82AA45CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA45D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA45D4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82AA45D8: 4BA64441  bl 0x82508a18
	ctx.lr = 0x82AA45DC;
	sub_82508A18(ctx, base);
	// 82AA45DC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA45E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA45E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA45E8: 38A0018B  li r5, 0x18b
	ctx.r[5].s64 = 395;
	// 82AA45EC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA45F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA45F4: 483B444D  bl 0x82e58a40
	ctx.lr = 0x82AA45F8;
	sub_82E58A40(ctx, base);
	// 82AA45F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA45FC: 4834D695  bl 0x82df1c90
	ctx.lr = 0x82AA4600;
	sub_82DF1C90(ctx, base);
	// 82AA4600: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA4604: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4608: 419A0008  beq cr6, 0x82aa4610
	if ctx.cr[6].eq {
	pc = 0x82AA4610; continue 'dispatch;
	}
	// 82AA460C: 4B81C285  bl 0x822c0890
	ctx.lr = 0x82AA4610;
	sub_822C0890(ctx, base);
	// 82AA4610: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA4614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4618: 419A0008  beq cr6, 0x82aa4620
	if ctx.cr[6].eq {
	pc = 0x82AA4620; continue 'dispatch;
	}
	// 82AA461C: 4B81C275  bl 0x822c0890
	ctx.lr = 0x82AA4620;
	sub_822C0890(ctx, base);
	// 82AA4620: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA4624: 4BE5B3CD  bl 0x828ff9f0
	ctx.lr = 0x82AA4628;
	sub_828FF9F0(ctx, base);
	// 82AA4628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA462C: 4BFDCFE5  bl 0x82a81610
	ctx.lr = 0x82AA4630;
	sub_82A81610(ctx, base);
	// 82AA4630: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82AA4634: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AA4638: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA463C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82AA4640: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 82AA4644: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82AA4648: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA464C: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA4650: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA46E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA46E8 size=128
    let mut pc: u32 = 0x82AA46E8;
    'dispatch: loop {
        match pc {
            0x82AA46E8 => {
    //   block [0x82AA46E8..0x82AA4768)
	// 82AA46E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA46EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA46F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA46F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA46F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA46FC: 4BFF579D  bl 0x82a99e98
	ctx.lr = 0x82AA4700;
	sub_82A99E98(ctx, base);
	// 82AA4700: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA4704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4708: 394A6850  addi r10, r10, 0x6850
	ctx.r[10].s64 = ctx.r[10].s64 + 26704;
	// 82AA470C: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA4710: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA4714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4718: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA471C: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA4720: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA4724: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA4728: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AA472C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AA4730: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA4734: 8089CA08  lwz r4, -0x35f8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13816 as u32) ) } as u64;
	// 82AA4738: 4834F2D1  bl 0x82df3a08
	ctx.lr = 0x82AA473C;
	sub_82DF3A08(ctx, base);
	// 82AA473C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4740: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4744: 483B4FA5  bl 0x82e596e8
	ctx.lr = 0x82AA4748;
	sub_82E596E8(ctx, base);
	// 82AA4748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA474C: 4834ECDD  bl 0x82df3428
	ctx.lr = 0x82AA4750;
	sub_82DF3428(ctx, base);
	// 82AA4750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA4758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA475C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4768 size=104
    let mut pc: u32 = 0x82AA4768;
    'dispatch: loop {
        match pc {
            0x82AA4768 => {
    //   block [0x82AA4768..0x82AA47D0)
	// 82AA4768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA476C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA4774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA477C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA4784: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA4788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA478C: 419A0008  beq cr6, 0x82aa4794
	if ctx.cr[6].eq {
	pc = 0x82AA4794; continue 'dispatch;
	}
	// 82AA4790: 4B81C101  bl 0x822c0890
	ctx.lr = 0x82AA4794;
	sub_822C0890(ctx, base);
	// 82AA4794: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82AA4798: 4BB8AB41  bl 0x8262f2d8
	ctx.lr = 0x82AA479C;
	sub_8262F2D8(ctx, base);
	// 82AA479C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA47A0: 483B7DE9  bl 0x82e5c588
	ctx.lr = 0x82AA47A4;
	sub_82E5C588(ctx, base);
	// 82AA47A4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA47A8: 4182000C  beq 0x82aa47b4
	if ctx.cr[0].eq {
	pc = 0x82AA47B4; continue 'dispatch;
	}
	// 82AA47AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA47B0: 4834DC29  bl 0x82df23d8
	ctx.lr = 0x82AA47B4;
	sub_82DF23D8(ctx, base);
	// 82AA47B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA47B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA47BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA47C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA47C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA47C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA47CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA47D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA47D0 size=112
    let mut pc: u32 = 0x82AA47D0;
    'dispatch: loop {
        match pc {
            0x82AA47D0 => {
    //   block [0x82AA47D0..0x82AA4840)
	// 82AA47D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA47D4: 48703999  bl 0x831a816c
	ctx.lr = 0x82AA47D8;
	sub_831A8130(ctx, base);
	// 82AA47D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA47DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA47E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA47E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA47E8: 388B67F8  addi r4, r11, 0x67f8
	ctx.r[4].s64 = ctx.r[11].s64 + 26616;
	// 82AA47EC: 38A0007C  li r5, 0x7c
	ctx.r[5].s64 = 124;
	// 82AA47F0: 386000AC  li r3, 0xac
	ctx.r[3].s64 = 172;
	// 82AA47F4: 4834DBF5  bl 0x82df23e8
	ctx.lr = 0x82AA47F8;
	sub_82DF23E8(ctx, base);
	// 82AA47F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA47FC: 41820010  beq 0x82aa480c
	if ctx.cr[0].eq {
	pc = 0x82AA480C; continue 'dispatch;
	}
	// 82AA4800: 4BFFFEE9  bl 0x82aa46e8
	ctx.lr = 0x82AA4804;
	sub_82AA46E8(ctx, base);
	// 82AA4804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4808: 48000008  b 0x82aa4810
	pc = 0x82AA4810; continue 'dispatch;
	// 82AA480C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA4810: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA4814: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA4818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA481C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4820: 4BFFFA49  bl 0x82aa4268
	ctx.lr = 0x82AA4824;
	sub_82AA4268(ctx, base);
	// 82AA4824: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA4828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA482C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4830: 4B81B7D1  bl 0x822c0000
	ctx.lr = 0x82AA4834;
	sub_822C0000(ctx, base);
	// 82AA4834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA4838: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA483C: 48703980  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4840 size=96
    let mut pc: u32 = 0x82AA4840;
    'dispatch: loop {
        match pc {
            0x82AA4840 => {
    //   block [0x82AA4840..0x82AA48A0)
	// 82AA4840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4848: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA484C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA4850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4854: 388BCC18  addi r4, r11, -0x33e8
	ctx.r[4].s64 = ctx.r[11].s64 + -13288;
	// 82AA4858: 4B821071  bl 0x822c58c8
	ctx.lr = 0x82AA485C;
	sub_822C58C8(ctx, base);
	// 82AA485C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4860: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA4864: 4B820FB5  bl 0x822c5818
	ctx.lr = 0x82AA4868;
	sub_822C5818(ctx, base);
	// 82AA4868: 4B81FA49  bl 0x822c42b0
	ctx.lr = 0x82AA486C;
	sub_822C42B0(ctx, base);
	// 82AA486C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA4870: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA4874: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 82AA4878: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA487C: 4B820BF5  bl 0x822c5470
	ctx.lr = 0x82AA4880;
	sub_822C5470(ctx, base);
	// 82AA4880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA4884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA4888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA488C: 4B820455  bl 0x822c4ce0
	ctx.lr = 0x82AA4890;
	sub_822C4CE0(ctx, base);
	// 82AA4890: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA4894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA489C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA48A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA48A0 size=484
    let mut pc: u32 = 0x82AA48A0;
    'dispatch: loop {
        match pc {
            0x82AA48A0 => {
    //   block [0x82AA48A0..0x82AA4A84)
	// 82AA48A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA48A4: 487038B9  bl 0x831a815c
	ctx.lr = 0x82AA48A8;
	sub_831A8130(ctx, base);
	// 82AA48A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA48AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA48B0: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82AA48B4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AA48B8: 617FFFFF  ori r31, r11, 0xffff
	ctx.r[31].u64 = ctx.r[11].u64 | 65535;
	// 82AA48BC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA48C0: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82AA48C4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA48C8: 40980008  bge cr6, 0x82aa48d0
	if !ctx.cr[6].lt {
	pc = 0x82AA48D0; continue 'dispatch;
	}
	// 82AA48CC: 4BFFFF75  bl 0x82aa4840
	ctx.lr = 0x82AA48D0;
	sub_82AA4840(ctx, base);
	// 82AA48D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA48D4: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA48D8: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82AA48DC: 40980008  bge cr6, 0x82aa48e4
	if !ctx.cr[6].lt {
	pc = 0x82AA48E4; continue 'dispatch;
	}
	// 82AA48E0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82AA48E4: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA48E8: 40980014  bge cr6, 0x82aa48fc
	if !ctx.cr[6].lt {
	pc = 0x82AA48FC; continue 'dispatch;
	}
	// 82AA48EC: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82AA48F0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82AA48F4: 41990008  bgt cr6, 0x82aa48fc
	if ctx.cr[6].gt {
	pc = 0x82AA48FC; continue 'dispatch;
	}
	// 82AA48F8: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82AA48FC: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 82AA4900: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA4904: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AA4908: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA490C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA4910: 388908B0  addi r4, r9, 0x8b0
	ctx.r[4].s64 = ctx.r[9].s64 + 2224;
	// 82AA4914: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82AA4918: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82AA491C: 555DF0BE  srwi r29, r10, 2
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AA4920: 4834D7A9  bl 0x82df20c8
	ctx.lr = 0x82AA4924;
	sub_82DF20C8(ctx, base);
	// 82AA4924: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4928: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA492C: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82AA4930: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA4934: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA4938: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA493C: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 82AA4940: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82AA4944: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA4948: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA494C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA4950: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82AA4954: 4182000C  beq 0x82aa4960
	if ctx.cr[0].eq {
	pc = 0x82AA4960; continue 'dispatch;
	}
	// 82AA4958: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA495C: 487043AD  bl 0x831a8d08
	ctx.lr = 0x82AA4960;
	sub_831A8D08(ctx, base);
	// 82AA4960: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4964: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82AA4968: 4199007C  bgt cr6, 0x82aa49e4
	if ctx.cr[6].gt {
	pc = 0x82AA49E4; continue 'dispatch;
	}
	// 82AA496C: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82AA4970: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA4974: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4978: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA497C: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 82AA4980: 41820010  beq 0x82aa4990
	if ctx.cr[0].eq {
	pc = 0x82AA4990; continue 'dispatch;
	}
	// 82AA4984: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA4988: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA498C: 4870437D  bl 0x831a8d08
	ctx.lr = 0x82AA4990;
	sub_831A8D08(ctx, base);
	// 82AA4990: 7D7DD051  subf. r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4994: 41820024  beq 0x82aa49b8
	if ctx.cr[0].eq {
	pc = 0x82AA49B8; continue 'dispatch;
	}
	// 82AA4998: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82AA499C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA49A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA49A4: 41820014  beq 0x82aa49b8
	if ctx.cr[0].eq {
	pc = 0x82AA49B8; continue 'dispatch;
	}
	// 82AA49A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA49AC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA49B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82AA49B4: 4200FFF8  bdnz 0x82aa49ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA49AC; continue 'dispatch;
	}
	// 82AA49B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AA49BC: 419A009C  beq cr6, 0x82aa4a58
	if ctx.cr[6].eq {
	pc = 0x82AA4A58; continue 'dispatch;
	}
	// 82AA49C0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82AA49C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA49C8: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA49CC: 4182008C  beq 0x82aa4a58
	if ctx.cr[0].eq {
	pc = 0x82AA4A58; continue 'dispatch;
	}
	// 82AA49D0: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 82AA49D4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA49D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA49DC: 4200FFF8  bdnz 0x82aa49d4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA49D4; continue 'dispatch;
	}
	// 82AA49E0: 48000078  b 0x82aa4a58
	pc = 0x82AA4A58; continue 'dispatch;
	// 82AA49E4: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82AA49E8: 7D65E850  subf r11, r5, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82AA49EC: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82AA49F0: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA49F4: 41820014  beq 0x82aa4a08
	if ctx.cr[0].eq {
	pc = 0x82AA4A08; continue 'dispatch;
	}
	// 82AA49F8: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82AA49FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA4A00: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82AA4A04: 48704305  bl 0x831a8d08
	ctx.lr = 0x82AA4A08;
	sub_831A8D08(ctx, base);
	// 82AA4A08: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4A0C: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82AA4A10: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82AA4A14: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AA4A18: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4A1C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82AA4A20: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82AA4A24: 41820010  beq 0x82aa4a34
	if ctx.cr[0].eq {
	pc = 0x82AA4A34; continue 'dispatch;
	}
	// 82AA4A28: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82AA4A2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA4A30: 487042D9  bl 0x831a8d08
	ctx.lr = 0x82AA4A34;
	sub_831A8D08(ctx, base);
	// 82AA4A34: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82AA4A38: 419A0020  beq cr6, 0x82aa4a58
	if ctx.cr[6].eq {
	pc = 0x82AA4A58; continue 'dispatch;
	}
	// 82AA4A3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4A40: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4A44: 41820014  beq 0x82aa4a58
	if ctx.cr[0].eq {
	pc = 0x82AA4A58; continue 'dispatch;
	}
	// 82AA4A48: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82AA4A4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA4A50: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82AA4A54: 4200FFF8  bdnz 0x82aa4a4c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82AA4A4C; continue 'dispatch;
	}
	// 82AA4A58: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4A5C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AA4A60: 419A000C  beq cr6, 0x82aa4a6c
	if ctx.cr[6].eq {
	pc = 0x82AA4A6C; continue 'dispatch;
	}
	// 82AA4A64: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82AA4A68: 4834D721  bl 0x82df2188
	ctx.lr = 0x82AA4A6C;
	sub_82DF2188(ctx, base);
	// 82AA4A6C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4A70: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82AA4A74: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82AA4A78: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA4A7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA4A80: 4870372C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA4A88 size=484
    let mut pc: u32 = 0x82AA4A88;
    'dispatch: loop {
        match pc {
            0x82AA4A88 => {
    //   block [0x82AA4A88..0x82AA4C6C)
	// 82AA4A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4A8C: 487036DD  bl 0x831a8168
	ctx.lr = 0x82AA4A90;
	sub_831A8130(ctx, base);
	// 82AA4A90: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AA4A94: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4A98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA4A9C: 486AFB65  bl 0x83154600
	ctx.lr = 0x82AA4AA0;
	sub_83154600(ctx, base);
	// 82AA4AA0: 4BE14249  bl 0x828b8ce8
	ctx.lr = 0x82AA4AA4;
	sub_828B8CE8(ctx, base);
	// 82AA4AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4AA8: 4BFDCC01  bl 0x82a816a8
	ctx.lr = 0x82AA4AAC;
	sub_82A816A8(ctx, base);
	// 82AA4AAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4AB0: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA4AB4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA4AB8: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA4ABC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA4AC0: 41980050  blt cr6, 0x82aa4b10
	if ctx.cr[6].lt {
	pc = 0x82AA4B10; continue 'dispatch;
	}
	// 82AA4AC4: 409A019C  bne cr6, 0x82aa4c60
	if !ctx.cr[6].eq {
	pc = 0x82AA4C60; continue 'dispatch;
	}
	// 82AA4AC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA4ACC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82AA4AD0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA4AD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA4AD8: 4BE64A91  bl 0x82909568
	ctx.lr = 0x82AA4ADC;
	sub_82909568(ctx, base);
	// 82AA4ADC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4AE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA4AE4: 808BCA14  lwz r4, -0x35ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13804 as u32) ) } as u64;
	// 82AA4AE8: 4834EF21  bl 0x82df3a08
	ctx.lr = 0x82AA4AEC;
	sub_82DF3A08(ctx, base);
	// 82AA4AEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA4AF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA4AF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA4AF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA4AFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA4B00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA4B04: 483B9F8D  bl 0x82e5ea90
	ctx.lr = 0x82AA4B08;
	sub_82E5EA90(ctx, base);
	// 82AA4B08: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA4B0C: 48000148  b 0x82aa4c54
	pc = 0x82AA4C54; continue 'dispatch;
	// 82AA4B10: 4BFDCB01  bl 0x82a81610
	ctx.lr = 0x82AA4B14;
	sub_82A81610(ctx, base);
	// 82AA4B14: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA4B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4B1C: 4BFDCB8D  bl 0x82a816a8
	ctx.lr = 0x82AA4B20;
	sub_82A816A8(ctx, base);
	// 82AA4B20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA4B24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA4B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4B2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4B30: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 82AA4B34: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA4B38: 4BFDCB89  bl 0x82a816c0
	ctx.lr = 0x82AA4B3C;
	sub_82A816C0(ctx, base);
	// 82AA4B3C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82AA4B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4B44: 4BE6431D  bl 0x82908e60
	ctx.lr = 0x82AA4B48;
	sub_82908E60(ctx, base);
	// 82AA4B48: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA4B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4B50: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA4B54: 4BE64A15  bl 0x82909568
	ctx.lr = 0x82AA4B58;
	sub_82909568(ctx, base);
	// 82AA4B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4B5C: 4BFDE7C5  bl 0x82a83320
	ctx.lr = 0x82AA4B60;
	sub_82A83320(ctx, base);
	// 82AA4B60: 4BFDCAB1  bl 0x82a81610
	ctx.lr = 0x82AA4B64;
	sub_82A81610(ctx, base);
	// 82AA4B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA4B68: 38A30028  addi r5, r3, 0x28
	ctx.r[5].s64 = ctx.r[3].s64 + 40;
	// 82AA4B6C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82AA4B70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA4B74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA4B78: 4BFDEC09  bl 0x82a83780
	ctx.lr = 0x82AA4B7C;
	sub_82A83780(ctx, base);
	// 82AA4B7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4B80: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA4B84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4B8C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA4B90: 419A0024  beq cr6, 0x82aa4bb4
	if ctx.cr[6].eq {
	pc = 0x82AA4BB4; continue 'dispatch;
	}
	// 82AA4B94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA4B98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA4B9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4BA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA4BA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA4BA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA4BAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA4BB0: 4082FFE8  bne 0x82aa4b98
	if !ctx.cr[0].eq {
	pc = 0x82AA4B98; continue 'dispatch;
	}
	// 82AA4BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4BB8: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82AA4BBC: 4BFDCB2D  bl 0x82a816e8
	ctx.lr = 0x82AA4BC0;
	sub_82A816E8(ctx, base);
	// 82AA4BC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA4BC4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA4BC8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA4BCC: 388A67F8  addi r4, r10, 0x67f8
	ctx.r[4].s64 = ctx.r[10].s64 + 26616;
	// 82AA4BD0: 38A001C2  li r5, 0x1c2
	ctx.r[5].s64 = 450;
	// 82AA4BD4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA4BD8: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA4BDC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA4BE0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA4BE4: 483B3E5D  bl 0x82e58a40
	ctx.lr = 0x82AA4BE8;
	sub_82E58A40(ctx, base);
	// 82AA4BE8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA4BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4BF0: 419A0008  beq cr6, 0x82aa4bf8
	if ctx.cr[6].eq {
	pc = 0x82AA4BF8; continue 'dispatch;
	}
	// 82AA4BF4: 4B81BC9D  bl 0x822c0890
	ctx.lr = 0x82AA4BF8;
	sub_822C0890(ctx, base);
	// 82AA4BF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA4BFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4C00: 419A0008  beq cr6, 0x82aa4c08
	if ctx.cr[6].eq {
	pc = 0x82AA4C08; continue 'dispatch;
	}
	// 82AA4C04: 4B81BC8D  bl 0x822c0890
	ctx.lr = 0x82AA4C08;
	sub_822C0890(ctx, base);
	// 82AA4C08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA4C0C: 809D0060  lwz r4, 0x60(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA4C10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA4C14: 48001D0D  bl 0x82aa6920
	ctx.lr = 0x82AA4C18;
	sub_82AA6920(ctx, base);
	// 82AA4C18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA4C1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA4C20: 48002CE9  bl 0x82aa7908
	ctx.lr = 0x82AA4C24;
	sub_82AA7908(ctx, base);
	// 82AA4C24: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4C28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA4C2C: 808BCA10  lwz r4, -0x35f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13808 as u32) ) } as u64;
	// 82AA4C30: 4834EDD9  bl 0x82df3a08
	ctx.lr = 0x82AA4C34;
	sub_82DF3A08(ctx, base);
	// 82AA4C34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA4C38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA4C3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA4C40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA4C44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA4C48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA4C4C: 483B9E45  bl 0x82e5ea90
	ctx.lr = 0x82AA4C50;
	sub_82E5EA90(ctx, base);
	// 82AA4C50: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA4C54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4C58: 419A0008  beq cr6, 0x82aa4c60
	if ctx.cr[6].eq {
	pc = 0x82AA4C60; continue 'dispatch;
	}
	// 82AA4C5C: 4B81BC35  bl 0x822c0890
	ctx.lr = 0x82AA4C60;
	sub_822C0890(ctx, base);
	// 82AA4C60: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AA4C64: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA4C68: 48703550  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA4C70 size=160
    let mut pc: u32 = 0x82AA4C70;
    'dispatch: loop {
        match pc {
            0x82AA4C70 => {
    //   block [0x82AA4C70..0x82AA4D10)
	// 82AA4C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA4C78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA4C7C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4C84: 486AF97D  bl 0x83154600
	ctx.lr = 0x82AA4C88;
	sub_83154600(ctx, base);
	// 82AA4C88: 4BE14061  bl 0x828b8ce8
	ctx.lr = 0x82AA4C8C;
	sub_828B8CE8(ctx, base);
	// 82AA4C8C: 4BFDCA1D  bl 0x82a816a8
	ctx.lr = 0x82AA4C90;
	sub_82A816A8(ctx, base);
	// 82AA4C90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA4C94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA4C98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA4C9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4CA0: 554A0776  rlwinm r10, r10, 0, 0x1d, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA4CA4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA4CA8: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA4CAC: 48001C75  bl 0x82aa6920
	ctx.lr = 0x82AA4CB0;
	sub_82AA6920(ctx, base);
	// 82AA4CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4CB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA4CB8: 48002C51  bl 0x82aa7908
	ctx.lr = 0x82AA4CBC;
	sub_82AA7908(ctx, base);
	// 82AA4CBC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA4CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA4CC4: 808BCA10  lwz r4, -0x35f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13808 as u32) ) } as u64;
	// 82AA4CC8: 4834ED41  bl 0x82df3a08
	ctx.lr = 0x82AA4CCC;
	sub_82DF3A08(ctx, base);
	// 82AA4CCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA4CD0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA4CD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA4CDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA4CE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA4CE4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA4CE8: 483B9DA9  bl 0x82e5ea90
	ctx.lr = 0x82AA4CEC;
	sub_82E5EA90(ctx, base);
	// 82AA4CEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA4CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA4CF4: 419A0008  beq cr6, 0x82aa4cfc
	if ctx.cr[6].eq {
	pc = 0x82AA4CFC; continue 'dispatch;
	}
	// 82AA4CF8: 4B81BB99  bl 0x822c0890
	ctx.lr = 0x82AA4CFC;
	sub_822C0890(ctx, base);
	// 82AA4CFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA4D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA4D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA4D08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA4D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA4D10 size=44
    let mut pc: u32 = 0x82AA4D10;
    'dispatch: loop {
        match pc {
            0x82AA4D10 => {
    //   block [0x82AA4D10..0x82AA4D3C)
	// 82AA4D10: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA4D14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4D18: 409A0024  bne cr6, 0x82aa4d3c
	if !ctx.cr[6].eq {
		sub_82AA4D3C(ctx, base);
		return;
	}
	// 82AA4D1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA4D20: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82AA4D24: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AA4D28: 91440020  stw r10, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82AA4D2C: 99240028  stb r9, 0x28(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), ctx.r[9].u8 ) };
	// 82AA4D30: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA4D34: D0040024  stfs f0, 0x24(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82AA4D38: 48000078  b 0x82aa4db0
	sub_82AA4DA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4D3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA4D3C size=108
    let mut pc: u32 = 0x82AA4D3C;
    'dispatch: loop {
        match pc {
            0x82AA4D3C => {
    //   block [0x82AA4D3C..0x82AA4DA8)
	// 82AA4D3C: 81230070  lwz r9, 0x70(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA4D40: 8143006C  lwz r10, 0x6c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA4D44: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4D48: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA4D4C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA4D50: 41990008  bgt cr6, 0x82aa4d58
	if ctx.cr[6].gt {
	pc = 0x82AA4D58; continue 'dispatch;
	}
	// 82AA4D54: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA4D58: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA4D5C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4D60: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA4D64: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA4D68: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA4D6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4D70: 91640020  stw r11, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82AA4D74: C00300A0  lfs f0, 0xa0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA4D78: D0040024  stfs f0, 0x24(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82AA4D7C: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA4D80: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA4D84: 40820024  bne 0x82aa4da8
	if !ctx.cr[0].eq {
		sub_82AA4DA8(ctx, base);
		return;
	}
	// 82AA4D88: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4D8C: 40820014  bne 0x82aa4da0
	if !ctx.cr[0].eq {
	pc = 0x82AA4DA0; continue 'dispatch;
	}
	// 82AA4D90: C00300A0  lfs f0, 0xa0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA4D94: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA4D98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA4D9C: 4199000C  bgt cr6, 0x82aa4da8
	if ctx.cr[6].gt {
		sub_82AA4DA8(ctx, base);
		return;
	}
	// 82AA4DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA4DA4: 48000008  b 0x82aa4dac
	sub_82AA4DA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA4DA8 size=16
    let mut pc: u32 = 0x82AA4DA8;
    'dispatch: loop {
        match pc {
            0x82AA4DA8 => {
    //   block [0x82AA4DA8..0x82AA4DB8)
	// 82AA4DA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA4DAC: 99640028  stb r11, 0x28(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	// 82AA4DB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA4DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA4DB8 size=32
    let mut pc: u32 = 0x82AA4DB8;
    'dispatch: loop {
        match pc {
            0x82AA4DB8 => {
    //   block [0x82AA4DB8..0x82AA4DD8)
	// 82AA4DB8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AA4DBC: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82AA4DC0: 8964001C  lbz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA4DC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4DC8: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA4DCC: 4182000C  beq 0x82aa4dd8
	if ctx.cr[0].eq {
		sub_82AA4DD8(ctx, base);
		return;
	}
	// 82AA4DD0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82AA4DD4: 48000008  b 0x82aa4ddc
	sub_82AA4DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA4DD8 size=116
    let mut pc: u32 = 0x82AA4DD8;
    'dispatch: loop {
        match pc {
            0x82AA4DD8 => {
    //   block [0x82AA4DD8..0x82AA4E4C)
	// 82AA4DD8: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA4DDC: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA4DE0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4DE4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AA4DE8: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA4DEC: 81230070  lwz r9, 0x70(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA4DF0: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4DF4: 8143006C  lwz r10, 0x6c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA4DF8: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA4DFC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA4E00: 41990008  bgt cr6, 0x82aa4e08
	if ctx.cr[6].gt {
	pc = 0x82AA4E08; continue 'dispatch;
	}
	// 82AA4E04: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA4E08: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA4E0C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4E10: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA4E14: 8904001C  lbz r8, 0x1c(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AA4E18: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82AA4E1C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA4E20: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA4E24: C1A708A4  lfs f13, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA4E28: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA4E2C: 41820020  beq 0x82aa4e4c
	if ctx.cr[0].eq {
		sub_82AA4E4C(ctx, base);
		return;
	}
	// 82AA4E30: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA4E34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA4E38: 41980014  blt cr6, 0x82aa4e4c
	if ctx.cr[6].lt {
		sub_82AA4E4C(ctx, base);
		return;
	}
	// 82AA4E3C: C1A300A0  lfs f13, 0xa0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA4E40: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA4E44: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA4E48: 48000008  b 0x82aa4e50
	sub_82AA4E4C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4E4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA4E4C size=12
    let mut pc: u32 = 0x82AA4E4C;
    'dispatch: loop {
        match pc {
            0x82AA4E4C => {
    //   block [0x82AA4E4C..0x82AA4E58)
	// 82AA4E4C: D1A300A4  stfs f13, 0xa4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA4E50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA4E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4E58 size=204
    let mut pc: u32 = 0x82AA4E58;
    'dispatch: loop {
        match pc {
            0x82AA4E58 => {
    //   block [0x82AA4E58..0x82AA4F24)
	// 82AA4E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4E5C: 4870330D  bl 0x831a8168
	ctx.lr = 0x82AA4E60;
	sub_831A8130(ctx, base);
	// 82AA4E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4E68: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AA4E6C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA4E70: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA4E74: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA4E78: 554A07BF  clrlwi. r10, r10, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA4E7C: 40820020  bne 0x82aa4e9c
	if !ctx.cr[0].eq {
	pc = 0x82AA4E9C; continue 'dispatch;
	}
	// 82AA4E80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA4E84: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4E88: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4E8C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA4E90: 4199000C  bgt cr6, 0x82aa4e9c
	if ctx.cr[6].gt {
	pc = 0x82AA4E9C; continue 'dispatch;
	}
	// 82AA4E94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA4E98: 4BFFFA09  bl 0x82aa48a0
	ctx.lr = 0x82AA4E9C;
	sub_82AA48A0(ctx, base);
	// 82AA4E9C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA4EA0: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA4EA4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA4EA8: 7FA95A14  add r29, r9, r11
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82AA4EAC: 57ABF0BE  srwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA4EB0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA4EB4: 41990008  bgt cr6, 0x82aa4ebc
	if ctx.cr[6].gt {
	pc = 0x82AA4EBC; continue 'dispatch;
	}
	// 82AA4EB8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA4EBC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4EC0: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82AA4EC4: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AA4EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA4ECC: 409A0028  bne cr6, 0x82aa4ef4
	if !ctx.cr[6].eq {
	pc = 0x82AA4EF4; continue 'dispatch;
	}
	// 82AA4ED0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82AA4ED4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA4ED8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82AA4EDC: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82AA4EE0: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82AA4EE4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82AA4EE8: 4834D1E1  bl 0x82df20c8
	ctx.lr = 0x82AA4EEC;
	sub_82DF20C8(ctx, base);
	// 82AA4EEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4EF0: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 82AA4EF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA4EF8: 57AA173A  rlwinm r10, r29, 2, 0x1c, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x3FFFFFFFu64;
	// 82AA4EFC: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82AA4F00: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4F04: 4182000C  beq 0x82aa4f10
	if ctx.cr[0].eq {
	pc = 0x82AA4F10; continue 'dispatch;
	}
	// 82AA4F08: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4F0C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA4F10: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA4F14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA4F18: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82AA4F1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA4F20: 48703298  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA4F28 size=160
    let mut pc: u32 = 0x82AA4F28;
    'dispatch: loop {
        match pc {
            0x82AA4F28 => {
    //   block [0x82AA4F28..0x82AA4FC8)
	// 82AA4F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4F2C: 4870323D  bl 0x831a8168
	ctx.lr = 0x82AA4F30;
	sub_831A8130(ctx, base);
	// 82AA4F30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4F34: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AA4F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4F3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA4F40: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82AA4F44: 41820034  beq 0x82aa4f78
	if ctx.cr[0].eq {
	pc = 0x82AA4F78; continue 'dispatch;
	}
	// 82AA4F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4F4C: 48704A3D  bl 0x831a9988
	ctx.lr = 0x82AA4F50;
	sub_831A9988(ctx, base);
	// 82AA4F50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82AA4F54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA4F58: 386B3BDC  addi r3, r11, 0x3bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 15324;
	// 82AA4F5C: 4870319D  bl 0x831a80f8
	ctx.lr = 0x82AA4F60;
	sub_831A80F8(ctx, base);
	// 82AA4F60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4F64: 41820014  beq 0x82aa4f78
	if ctx.cr[0].eq {
	pc = 0x82AA4F78; continue 'dispatch;
	}
	// 82AA4F68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4F6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4F70: 4BFFFDA1  bl 0x82aa4d10
	ctx.lr = 0x82AA4F74;
	sub_82AA4D10(ctx, base);
	// 82AA4F74: 4800004C  b 0x82aa4fc0
	pc = 0x82AA4FC0; continue 'dispatch;
	// 82AA4F78: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AA4F7C: 419A0034  beq cr6, 0x82aa4fb0
	if ctx.cr[6].eq {
	pc = 0x82AA4FB0; continue 'dispatch;
	}
	// 82AA4F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA4F84: 48704A05  bl 0x831a9988
	ctx.lr = 0x82AA4F88;
	sub_831A9988(ctx, base);
	// 82AA4F88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82AA4F8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA4F90: 386B3BB4  addi r3, r11, 0x3bb4
	ctx.r[3].s64 = ctx.r[11].s64 + 15284;
	// 82AA4F94: 48703165  bl 0x831a80f8
	ctx.lr = 0x82AA4F98;
	sub_831A80F8(ctx, base);
	// 82AA4F98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA4F9C: 41820014  beq 0x82aa4fb0
	if ctx.cr[0].eq {
	pc = 0x82AA4FB0; continue 'dispatch;
	}
	// 82AA4FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4FA8: 4BFFFE11  bl 0x82aa4db8
	ctx.lr = 0x82AA4FAC;
	sub_82AA4DB8(ctx, base);
	// 82AA4FAC: 48000014  b 0x82aa4fc0
	pc = 0x82AA4FC0; continue 'dispatch;
	// 82AA4FB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA4FB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA4FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA4FBC: 486D94CD  bl 0x8317e488
	ctx.lr = 0x82AA4FC0;
	sub_8317E488(ctx, base);
	// 82AA4FC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA4FC4: 487031F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA4FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA4FC8 size=696
    let mut pc: u32 = 0x82AA4FC8;
    'dispatch: loop {
        match pc {
            0x82AA4FC8 => {
    //   block [0x82AA4FC8..0x82AA5280)
	// 82AA4FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA4FCC: 48703191  bl 0x831a815c
	ctx.lr = 0x82AA4FD0;
	sub_831A8130(ctx, base);
	// 82AA4FD0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AA4FD4: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA4FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA4FDC: 486AF625  bl 0x83154600
	ctx.lr = 0x82AA4FE0;
	sub_83154600(ctx, base);
	// 82AA4FE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA4FE4: 4BE13D05  bl 0x828b8ce8
	ctx.lr = 0x82AA4FE8;
	sub_828B8CE8(ctx, base);
	// 82AA4FE8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA4FEC: 4BFDC6BD  bl 0x82a816a8
	ctx.lr = 0x82AA4FF0;
	sub_82A816A8(ctx, base);
	// 82AA4FF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA4FF4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA4FF8: 3B7F0064  addi r27, r31, 0x64
	ctx.r[27].s64 = ctx.r[31].s64 + 100;
	// 82AA4FFC: 556BE7FF  rlwinm. r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5000: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5004: 41820038  beq 0x82aa503c
	if ctx.cr[0].eq {
	pc = 0x82AA503C; continue 'dispatch;
	}
	// 82AA5008: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA500C: 396B6698  addi r11, r11, 0x6698
	ctx.r[11].s64 = ctx.r[11].s64 + 26264;
	// 82AA5010: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA5014: 3BA00006  li r29, 6
	ctx.r[29].s64 = 6;
	// 82AA5018: 3B8B0090  addi r28, r11, 0x90
	ctx.r[28].s64 = ctx.r[11].s64 + 144;
	// 82AA501C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82AA5020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5024: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA5028: 4BFFFE31  bl 0x82aa4e58
	ctx.lr = 0x82AA502C;
	sub_82AA4E58(ctx, base);
	// 82AA502C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA5030: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 82AA5034: 4082FFE8  bne 0x82aa501c
	if !ctx.cr[0].eq {
	pc = 0x82AA501C; continue 'dispatch;
	}
	// 82AA5038: 4800002C  b 0x82aa5064
	pc = 0x82AA5064; continue 'dispatch;
	// 82AA503C: 935F0060  stw r26, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82AA5040: 3B8B6698  addi r28, r11, 0x6698
	ctx.r[28].s64 = ctx.r[11].s64 + 26264;
	// 82AA5044: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 82AA5048: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82AA504C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5050: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA5054: 4BFFFE05  bl 0x82aa4e58
	ctx.lr = 0x82AA5058;
	sub_82AA4E58(ctx, base);
	// 82AA5058: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AA505C: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 82AA5060: 4082FFE8  bne 0x82aa5048
	if !ctx.cr[0].eq {
	pc = 0x82AA5048; continue 'dispatch;
	}
	// 82AA5064: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA5068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA506C: 4BFE3625  bl 0x82a88690
	ctx.lr = 0x82AA5070;
	sub_82A88690(ctx, base);
	// 82AA5070: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA5074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5078: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA507C: 4834E98D  bl 0x82df3a08
	ctx.lr = 0x82AA5080;
	sub_82DF3A08(ctx, base);
	// 82AA5080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5088: 4BD4A6E9  bl 0x827ef770
	ctx.lr = 0x82AA508C;
	sub_827EF770(ctx, base);
	// 82AA508C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5090: 4834E399  bl 0x82df3428
	ctx.lr = 0x82AA5094;
	sub_82DF3428(ctx, base);
	// 82AA5094: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA5098: 935F0094  stw r26, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 82AA509C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA50A0: 935F009C  stw r26, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	// 82AA50A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA50A8: 3B8B67F8  addi r28, r11, 0x67f8
	ctx.r[28].s64 = ctx.r[11].s64 + 26616;
	// 82AA50AC: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 82AA50B0: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA50B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA50B8: D3FF00A0  stfs f31, 0xa0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA50BC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82AA50C0: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA50C4: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA50C8: 935F0098  stw r26, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 82AA50CC: 4B81B30D  bl 0x822c03d8
	ctx.lr = 0x82AA50D0;
	sub_822C03D8(ctx, base);
	// 82AA50D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA50D4: 41820014  beq 0x82aa50e8
	if ctx.cr[0].eq {
	pc = 0x82AA50E8; continue 'dispatch;
	}
	// 82AA50D8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA50DC: 4BFE456D  bl 0x82a89648
	ctx.lr = 0x82AA50E0;
	sub_82A89648(ctx, base);
	// 82AA50E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA50E4: 48000008  b 0x82aa50ec
	pc = 0x82AA50EC; continue 'dispatch;
	// 82AA50E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA50EC: 3BBF0078  addi r29, r31, 0x78
	ctx.r[29].s64 = ctx.r[31].s64 + 120;
	// 82AA50F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA50F4: 4BFFF305  bl 0x82aa43f8
	ctx.lr = 0x82AA50F8;
	sub_82AA43F8(ctx, base);
	// 82AA50F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA50FC: 4BE5A8F5  bl 0x828ff9f0
	ctx.lr = 0x82AA5100;
	sub_828FF9F0(ctx, base);
	// 82AA5100: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 82AA5104: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA5108: 483D6ED1  bl 0x82e7bfd8
	ctx.lr = 0x82AA510C;
	sub_82E7BFD8(ctx, base);
	// 82AA510C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82AA5110: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5114: 4BFE45D5  bl 0x82a896e8
	ctx.lr = 0x82AA5118;
	sub_82A896E8(ctx, base);
	// 82AA5118: C00100E0  lfs f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA511C: C1A100E4  lfs f13, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA5120: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA5124: C18100E8  lfs f12, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA5128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA512C: C16100EC  lfs f11, 0xec(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA5130: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA5134: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82AA5138: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA513C: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AA5140: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5144: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA5148: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA514C: 4E800421  bctrl
	ctx.lr = 0x82AA5150;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA5150: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA5154: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AA5158: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AA515C: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AA5160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA5164: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA5168: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA516C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5170: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5174: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AA5178: C02A029C  lfs f1, 0x29c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA517C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5180: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA5184: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA5188: 4E800421  bctrl
	ctx.lr = 0x82AA518C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA518C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA5190: 4BFDD729  bl 0x82a828b8
	ctx.lr = 0x82AA5194;
	sub_82A828B8(ctx, base);
	// 82AA5194: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AA5198: 4BF24E89  bl 0x829ca020
	ctx.lr = 0x82AA519C;
	sub_829CA020(ctx, base);
	// 82AA519C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA51A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA51A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA51A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA51AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA51B0: 419A0024  beq cr6, 0x82aa51d4
	if ctx.cr[6].eq {
	pc = 0x82AA51D4; continue 'dispatch;
	}
	// 82AA51B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA51B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA51BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA51C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA51C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA51C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA51CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA51D0: 4082FFE8  bne 0x82aa51b8
	if !ctx.cr[0].eq {
	pc = 0x82AA51B8; continue 'dispatch;
	}
	// 82AA51D4: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 82AA51D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AA51DC: 4BA6A2ED  bl 0x8250f4c8
	ctx.lr = 0x82AA51E0;
	sub_8250F4C8(ctx, base);
	// 82AA51E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA51E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA51E8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA51EC: 409A0008  bne cr6, 0x82aa51f4
	if !ctx.cr[6].eq {
	pc = 0x82AA51F4; continue 'dispatch;
	}
	// 82AA51F0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA51F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA51F8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82AA51FC: 4BA6381D  bl 0x82508a18
	ctx.lr = 0x82AA5200;
	sub_82508A18(ctx, base);
	// 82AA5200: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA5204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA5208: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA520C: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 82AA5210: 38790038  addi r3, r25, 0x38
	ctx.r[3].s64 = ctx.r[25].s64 + 56;
	// 82AA5214: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA5218: 483B3829  bl 0x82e58a40
	ctx.lr = 0x82AA521C;
	sub_82E58A40(ctx, base);
	// 82AA521C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AA5220: 4834CA71  bl 0x82df1c90
	ctx.lr = 0x82AA5224;
	sub_82DF1C90(ctx, base);
	// 82AA5224: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA5228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA522C: 419A0008  beq cr6, 0x82aa5234
	if ctx.cr[6].eq {
	pc = 0x82AA5234; continue 'dispatch;
	}
	// 82AA5230: 4B81B661  bl 0x822c0890
	ctx.lr = 0x82AA5234;
	sub_822C0890(ctx, base);
	// 82AA5234: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA5238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA523C: 419A0008  beq cr6, 0x82aa5244
	if ctx.cr[6].eq {
	pc = 0x82AA5244; continue 'dispatch;
	}
	// 82AA5240: 4B81B651  bl 0x822c0890
	ctx.lr = 0x82AA5244;
	sub_822C0890(ctx, base);
	// 82AA5244: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82AA5248: 480FB281  bl 0x82ba04c8
	ctx.lr = 0x82AA524C;
	sub_82BA04C8(ctx, base);
	// 82AA524C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA5250: 480FB279  bl 0x82ba04c8
	ctx.lr = 0x82AA5254;
	sub_82BA04C8(ctx, base);
	// 82AA5254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA5258: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA525C: C00B093C  lfs f0, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5260: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AA5264: 480FB29D  bl 0x82ba0500
	ctx.lr = 0x82AA5268;
	sub_82BA0500(ctx, base);
	// 82AA5268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA526C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5270: 4BFE4A59  bl 0x82a89cc8
	ctx.lr = 0x82AA5274;
	sub_82A89CC8(ctx, base);
	// 82AA5274: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AA5278: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AA527C: 48702F30  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA5280 size=1104
    let mut pc: u32 = 0x82AA5280;
    'dispatch: loop {
        match pc {
            0x82AA5280 => {
    //   block [0x82AA5280..0x82AA56D0)
	// 82AA5280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5284: 48702EDD  bl 0x831a8160
	ctx.lr = 0x82AA5288;
	sub_831A8130(ctx, base);
	// 82AA5288: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AA528C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5294: 486AF36D  bl 0x83154600
	ctx.lr = 0x82AA5298;
	sub_83154600(ctx, base);
	// 82AA5298: 4BE13A51  bl 0x828b8ce8
	ctx.lr = 0x82AA529C;
	sub_828B8CE8(ctx, base);
	// 82AA529C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA52A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA52A4: 483B44D5  bl 0x82e59778
	ctx.lr = 0x82AA52A8;
	sub_82E59778(ctx, base);
	// 82AA52A8: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA52AC: 83DF0078  lwz r30, 0x78(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA52B0: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA52B4: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA52B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA52BC: 419A0014  beq cr6, 0x82aa52d0
	if ctx.cr[6].eq {
	pc = 0x82AA52D0; continue 'dispatch;
	}
	// 82AA52C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA52C4: 483B44B5  bl 0x82e59778
	ctx.lr = 0x82AA52C8;
	sub_82E59778(ctx, base);
	// 82AA52C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA52CC: 4BFE4725  bl 0x82a899f0
	ctx.lr = 0x82AA52D0;
	sub_82A899F0(ctx, base);
	// 82AA52D0: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA52D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA52D8: 4198035C  blt cr6, 0x82aa5634
	if ctx.cr[6].lt {
	pc = 0x82AA5634; continue 'dispatch;
	}
	// 82AA52DC: 419A0108  beq cr6, 0x82aa53e4
	if ctx.cr[6].eq {
	pc = 0x82AA53E4; continue 'dispatch;
	}
	// 82AA52E0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AA52E4: 409803E0  bge cr6, 0x82aa56c4
	if !ctx.cr[6].lt {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA52E8: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA52EC: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA52F0: 418200D4  beq 0x82aa53c4
	if ctx.cr[0].eq {
	pc = 0x82AA53C4; continue 'dispatch;
	}
	// 82AA52F4: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA52F8: 4182007C  beq 0x82aa5374
	if ctx.cr[0].eq {
	pc = 0x82AA5374; continue 'dispatch;
	}
	// 82AA52FC: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA5300: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA5304: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5308: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA530C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA5310: 41990008  bgt cr6, 0x82aa5318
	if ctx.cr[6].gt {
	pc = 0x82AA5318; continue 'dispatch;
	}
	// 82AA5314: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA5318: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA531C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5320: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA5324: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5328: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA532C: 7FCB482E  lwzx r30, r11, r9
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA5330: 4BFE3EB1  bl 0x82a891e0
	ctx.lr = 0x82AA5334;
	sub_82A891E0(ctx, base);
	// 82AA5334: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5338: 4082000C  bne 0x82aa5344
	if !ctx.cr[0].eq {
	pc = 0x82AA5344; continue 'dispatch;
	}
	// 82AA533C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA5340: 48000070  b 0x82aa53b0
	pc = 0x82AA53B0; continue 'dispatch;
	// 82AA5344: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA5348: C1BE000C  lfs f13, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA534C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5350: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA5354: 41980370  blt cr6, 0x82aa56c4
	if ctx.cr[6].lt {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA5358: C01F00A4  lfs f0, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA535C: C1BF00A0  lfs f13, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA5360: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA5364: 40980360  bge cr6, 0x82aa56c4
	if !ctx.cr[6].lt {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA5368: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA536C: 4BFE3F5D  bl 0x82a892c8
	ctx.lr = 0x82AA5370;
	sub_82A892C8(ctx, base);
	// 82AA5370: 4BFFFFCC  b 0x82aa533c
	pc = 0x82AA533C; continue 'dispatch;
	// 82AA5374: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5378: 4BFE3F51  bl 0x82a892c8
	ctx.lr = 0x82AA537C;
	sub_82A892C8(ctx, base);
	// 82AA537C: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA5380: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA5384: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5388: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA538C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA5390: 41990008  bgt cr6, 0x82aa5398
	if ctx.cr[6].gt {
	pc = 0x82AA5398; continue 'dispatch;
	}
	// 82AA5394: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA5398: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA539C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA53A0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA53A4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA53A8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA53AC: 808B0018  lwz r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AA53B0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA53B4: 4BFE4915  bl 0x82a89cc8
	ctx.lr = 0x82AA53B8;
	sub_82A89CC8(ctx, base);
	// 82AA53B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA53BC: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82AA53C0: 48000304  b 0x82aa56c4
	pc = 0x82AA56C4; continue 'dispatch;
	// 82AA53C4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA53C8: 4BFE3E19  bl 0x82a891e0
	ctx.lr = 0x82AA53CC;
	sub_82A891E0(ctx, base);
	// 82AA53CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA53D0: 408202F4  bne 0x82aa56c4
	if !ctx.cr[0].eq {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA53D4: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA53D8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82AA53DC: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA53E0: 480002E4  b 0x82aa56c4
	pc = 0x82AA56C4; continue 'dispatch;
	// 82AA53E4: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA53E8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA53EC: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA53F0: 41820010  beq 0x82aa5400
	if ctx.cr[0].eq {
	pc = 0x82AA5400; continue 'dispatch;
	}
	// 82AA53F4: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA53F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA53FC: 40820008  bne 0x82aa5404
	if !ctx.cr[0].eq {
	pc = 0x82AA5404; continue 'dispatch;
	}
	// 82AA5400: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82AA5404: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA5408: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA540C: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA5410: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82AA5414: 418200A4  beq 0x82aa54b8
	if ctx.cr[0].eq {
	pc = 0x82AA54B8; continue 'dispatch;
	}
	// 82AA5418: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA541C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA5420: 419A0124  beq cr6, 0x82aa5544
	if ctx.cr[6].eq {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA5424: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA5428: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA542C: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5430: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA5434: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA5438: 41990008  bgt cr6, 0x82aa5440
	if ctx.cr[6].gt {
	pc = 0x82AA5440; continue 'dispatch;
	}
	// 82AA543C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA5440: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA5444: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5448: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA544C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA5450: 7FAB482E  lwzx r29, r11, r9
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA5454: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5458: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA545C: 419800E8  blt cr6, 0x82aa5544
	if ctx.cr[6].lt {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA5460: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5464: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA5468: 419800DC  blt cr6, 0x82aa5544
	if ctx.cr[6].lt {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA546C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5470: 483B4309  bl 0x82e59778
	ctx.lr = 0x82AA5474;
	sub_82E59778(ctx, base);
	// 82AA5474: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5478: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA547C: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA5480: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA5484: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA5488: 409900BC  ble cr6, 0x82aa5544
	if !ctx.cr[6].gt {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA548C: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 82AA5490: 839C0010  lwz r28, 0x10(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA5494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5498: 4BE639C9  bl 0x82908e60
	ctx.lr = 0x82AA549C;
	sub_82908E60(ctx, base);
	// 82AA549C: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA54A0: 817C0064  lwz r11, 0x64(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA54A4: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA54A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA54AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA54B0: 4E800421  bctrl
	ctx.lr = 0x82AA54B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA54B4: 48000084  b 0x82aa5538
	pc = 0x82AA5538; continue 'dispatch;
	// 82AA54B8: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA54BC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA54C0: 41980084  blt cr6, 0x82aa5544
	if ctx.cr[6].lt {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA54C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA54C8: 483B42B1  bl 0x82e59778
	ctx.lr = 0x82AA54CC;
	sub_82E59778(ctx, base);
	// 82AA54CC: C01F00A8  lfs f0, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA54D0: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA54D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA54D8: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA54DC: C00B6690  lfs f0, 0x6690(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA54E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA54E4: 40990060  ble cr6, 0x82aa5544
	if !ctx.cr[6].gt {
	pc = 0x82AA5544; continue 'dispatch;
	}
	// 82AA54E8: 4BFDC129  bl 0x82a81610
	ctx.lr = 0x82AA54EC;
	sub_82A81610(ctx, base);
	// 82AA54EC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA54F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA54F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA54F8: 4198001C  blt cr6, 0x82aa5514
	if ctx.cr[6].lt {
	pc = 0x82AA5514; continue 'dispatch;
	}
	// 82AA54FC: 409A003C  bne cr6, 0x82aa5538
	if !ctx.cr[6].eq {
	pc = 0x82AA5538; continue 'dispatch;
	}
	// 82AA5500: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82AA5504: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5508: 4BE63959  bl 0x82908e60
	ctx.lr = 0x82AA550C;
	sub_82908E60(ctx, base);
	// 82AA550C: C1BE0028  lfs f13, 0x28(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA5510: 48000014  b 0x82aa5524
	pc = 0x82AA5524; continue 'dispatch;
	// 82AA5514: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82AA5518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA551C: 4BE63945  bl 0x82908e60
	ctx.lr = 0x82AA5520;
	sub_82908E60(ctx, base);
	// 82AA5520: C1BE0020  lfs f13, 0x20(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA5524: C01E002C  lfs f0, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5528: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA552C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AA5530: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA5534: 4BE64035  bl 0x82909568
	ctx.lr = 0x82AA5538;
	sub_82909568(ctx, base);
	// 82AA5538: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA553C: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5540: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA5544: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5548: 4BFE3C99  bl 0x82a891e0
	ctx.lr = 0x82AA554C;
	sub_82A891E0(ctx, base);
	// 82AA554C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5550: 40820174  bne 0x82aa56c4
	if !ctx.cr[0].eq {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA5554: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AA5558: 419A00D0  beq cr6, 0x82aa5628
	if ctx.cr[6].eq {
	pc = 0x82AA5628; continue 'dispatch;
	}
	// 82AA555C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA5560: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 82AA5564: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82AA5568: 419A0034  beq cr6, 0x82aa559c
	if ctx.cr[6].eq {
	pc = 0x82AA559C; continue 'dispatch;
	}
	// 82AA556C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA5570: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA5574: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA5578: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82AA557C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AA5580: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA5584: 41990008  bgt cr6, 0x82aa558c
	if ctx.cr[6].gt {
	pc = 0x82AA558C; continue 'dispatch;
	}
	// 82AA5588: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 82AA558C: 3549FFFF  addic. r10, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA5590: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82AA5594: 40820008  bne 0x82aa559c
	if !ctx.cr[0].eq {
	pc = 0x82AA559C; continue 'dispatch;
	}
	// 82AA5598: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 82AA559C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA55A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AA55A4: 419A0078  beq cr6, 0x82aa561c
	if ctx.cr[6].eq {
	pc = 0x82AA561C; continue 'dispatch;
	}
	// 82AA55A8: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA55AC: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA55B0: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82AA55B4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA55B8: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA55BC: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82AA55C0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA55C4: 554A07B8  rlwinm r10, r10, 0, 0x1e, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA55C8: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82AA55CC: D3FF00A0  stfs f31, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA55D0: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA55D4: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA55D8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA55DC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA55E0: 550AF0BE  srwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA55E4: 550807BE  clrlwi r8, r8, 0x1e
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 82AA55E8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA55EC: 41990008  bgt cr6, 0x82aa55f4
	if ctx.cr[6].gt {
	pc = 0x82AA55F4; continue 'dispatch;
	}
	// 82AA55F0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82AA55F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA55F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA55FC: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA5600: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5604: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AA5608: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA560C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5610: 4BFE46B9  bl 0x82a89cc8
	ctx.lr = 0x82AA5614;
	sub_82A89CC8(ctx, base);
	// 82AA5614: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AA5618: 4BFFFDA4  b 0x82aa53bc
	pc = 0x82AA53BC; continue 'dispatch;
	// 82AA561C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5620: 4BFFF469  bl 0x82aa4a88
	ctx.lr = 0x82AA5624;
	sub_82AA4A88(ctx, base);
	// 82AA5624: 480000A0  b 0x82aa56c4
	pc = 0x82AA56C4; continue 'dispatch;
	// 82AA5628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA562C: 4BFFF645  bl 0x82aa4c70
	ctx.lr = 0x82AA5630;
	sub_82AA4C70(ctx, base);
	// 82AA5630: 48000094  b 0x82aa56c4
	pc = 0x82AA56C4; continue 'dispatch;
	// 82AA5634: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5638: 4BFE3BA9  bl 0x82a891e0
	ctx.lr = 0x82AA563C;
	sub_82A891E0(ctx, base);
	// 82AA563C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5640: 40820084  bne 0x82aa56c4
	if !ctx.cr[0].eq {
	pc = 0x82AA56C4; continue 'dispatch;
	}
	// 82AA5644: 813F0070  lwz r9, 0x70(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA5648: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA564C: 552BF0BE  srwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5650: 552907BE  clrlwi r9, r9, 0x1e
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82AA5654: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AA5658: 41990008  bgt cr6, 0x82aa5660
	if ctx.cr[6].gt {
	pc = 0x82AA5660; continue 'dispatch;
	}
	// 82AA565C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82AA5660: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA5664: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA5668: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82AA566C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AA5670: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA5674: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82AA5678: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA567C: 4BFE464D  bl 0x82a89cc8
	ctx.lr = 0x82AA5680;
	sub_82A89CC8(ctx, base);
	// 82AA5680: 397F0098  addi r11, r31, 0x98
	ctx.r[11].s64 = ctx.r[31].s64 + 152;
	// 82AA5684: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA5688: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82AA568C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA5690: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA5694: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA5698: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA569C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA56A0: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA56A4: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA56A8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA56AC: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA56B0: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA56B4: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA56B8: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA56BC: 913F0094  stw r9, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82AA56C0: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA56C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AA56C8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AA56CC: 48702AE4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA56D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA56D0 size=128
    let mut pc: u32 = 0x82AA56D0;
    'dispatch: loop {
        match pc {
            0x82AA56D0 => {
    //   block [0x82AA56D0..0x82AA5750)
	// 82AA56D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA56D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA56D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA56DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA56E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA56E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA56E8: 486AEF19  bl 0x83154600
	ctx.lr = 0x82AA56EC;
	sub_83154600(ctx, base);
	// 82AA56EC: 4BE135FD  bl 0x828b8ce8
	ctx.lr = 0x82AA56F0;
	sub_828B8CE8(ctx, base);
	// 82AA56F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA56F4: 807E0060  lwz r3, 0x60(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA56F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA56FC: 419A003C  beq cr6, 0x82aa5738
	if ctx.cr[6].eq {
	pc = 0x82AA5738; continue 'dispatch;
	}
	// 82AA5700: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA5704: 4BD29C6D  bl 0x827cf370
	ctx.lr = 0x82AA5708;
	sub_827CF370(ctx, base);
	// 82AA5708: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AA570C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5710: 4BA69DB9  bl 0x8250f4c8
	ctx.lr = 0x82AA5714;
	sub_8250F4C8(ctx, base);
	// 82AA5714: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA571C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA5720: 409A0008  bne cr6, 0x82aa5728
	if !ctx.cr[6].eq {
	pc = 0x82AA5728; continue 'dispatch;
	}
	// 82AA5724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA5728: 807E0060  lwz r3, 0x60(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA572C: 4BD2A715  bl 0x827cfe40
	ctx.lr = 0x82AA5730;
	sub_827CFE40(ctx, base);
	// 82AA5730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5734: 4834C55D  bl 0x82df1c90
	ctx.lr = 0x82AA5738;
	sub_82DF1C90(ctx, base);
	// 82AA5738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA573C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA5740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA5748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA574C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5750 size=196
    let mut pc: u32 = 0x82AA5750;
    'dispatch: loop {
        match pc {
            0x82AA5750 => {
    //   block [0x82AA5750..0x82AA5814)
	// 82AA5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA5758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA575C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA5760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA5768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA576C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA5770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA5774: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA5778: 4B81B1C1  bl 0x822c0938
	ctx.lr = 0x82AA577C;
	sub_822C0938(ctx, base);
	// 82AA577C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA5780: 41820028  beq 0x82aa57a8
	if ctx.cr[0].eq {
	pc = 0x82AA57A8; continue 'dispatch;
	}
	// 82AA5784: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5788: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA578C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA5790: 392B687C  addi r9, r11, 0x687c
	ctx.r[9].s64 = ctx.r[11].s64 + 26748;
	// 82AA5794: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA5798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA579C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA57A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA57A4: 48000008  b 0x82aa57ac
	pc = 0x82AA57AC; continue 'dispatch;
	// 82AA57A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA57AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA57B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA57B4: 409A0044  bne cr6, 0x82aa57f8
	if !ctx.cr[6].eq {
	pc = 0x82AA57F8; continue 'dispatch;
	}
	// 82AA57B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA57BC: 419A001C  beq cr6, 0x82aa57d8
	if ctx.cr[6].eq {
	pc = 0x82AA57D8; continue 'dispatch;
	}
	// 82AA57C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA57C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA57C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA57CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA57D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA57D4: 4E800421  bctrl
	ctx.lr = 0x82AA57D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA57D8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA57DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA57E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA57E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA57E8: 816BCB08  lwz r11, -0x34f8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13560 as u32) ) } as u64;
	// 82AA57EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA57F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA57F4: 4B81A80D  bl 0x822c0000
	ctx.lr = 0x82AA57F8;
	sub_822C0000(ctx, base);
	// 82AA57F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA57FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA5804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA580C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA5810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5818 size=112
    let mut pc: u32 = 0x82AA5818;
    'dispatch: loop {
        match pc {
            0x82AA5818 => {
    //   block [0x82AA5818..0x82AA5888)
	// 82AA5818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA581C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA5820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA5824: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA582C: 4BFF466D  bl 0x82a99e98
	ctx.lr = 0x82AA5830;
	sub_82A99E98(ctx, base);
	// 82AA5830: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA5834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA5838: 394A6890  addi r10, r10, 0x6890
	ctx.r[10].s64 = ctx.r[10].s64 + 26768;
	// 82AA583C: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA5840: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA5844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5848: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA584C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA5850: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA5854: 8089CA0C  lwz r4, -0x35f4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13812 as u32) ) } as u64;
	// 82AA5858: 4834E1B1  bl 0x82df3a08
	ctx.lr = 0x82AA585C;
	sub_82DF3A08(ctx, base);
	// 82AA585C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5864: 483B3E85  bl 0x82e596e8
	ctx.lr = 0x82AA5868;
	sub_82E596E8(ctx, base);
	// 82AA5868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA586C: 4834DBBD  bl 0x82df3428
	ctx.lr = 0x82AA5870;
	sub_82DF3428(ctx, base);
	// 82AA5870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA587C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA5884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5888 size=96
    let mut pc: u32 = 0x82AA5888;
    'dispatch: loop {
        match pc {
            0x82AA5888 => {
    //   block [0x82AA5888..0x82AA58E8)
	// 82AA5888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA588C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA5890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA5894: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA589C: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA58A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA58A4: 419A0008  beq cr6, 0x82aa58ac
	if ctx.cr[6].eq {
	pc = 0x82AA58AC; continue 'dispatch;
	}
	// 82AA58A8: 4B81AFE9  bl 0x822c0890
	ctx.lr = 0x82AA58AC;
	sub_822C0890(ctx, base);
	// 82AA58AC: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA58B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA58B4: 419A0018  beq cr6, 0x82aa58cc
	if ctx.cr[6].eq {
	pc = 0x82AA58CC; continue 'dispatch;
	}
	// 82AA58B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA58BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA58C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA58C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA58C8: 4E800421  bctrl
	ctx.lr = 0x82AA58CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA58CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA58D0: 483B6CB9  bl 0x82e5c588
	ctx.lr = 0x82AA58D4;
	sub_82E5C588(ctx, base);
	// 82AA58D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA58D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA58DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA58E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA58E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA58E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA58E8 size=76
    let mut pc: u32 = 0x82AA58E8;
    'dispatch: loop {
        match pc {
            0x82AA58E8 => {
    //   block [0x82AA58E8..0x82AA5934)
	// 82AA58E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA58EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA58F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA58F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA58F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA58FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA5904: 4BFFFF85  bl 0x82aa5888
	ctx.lr = 0x82AA5908;
	sub_82AA5888(ctx, base);
	// 82AA5908: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA590C: 4182000C  beq 0x82aa5918
	if ctx.cr[0].eq {
	pc = 0x82AA5918; continue 'dispatch;
	}
	// 82AA5910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5914: 4834CAC5  bl 0x82df23d8
	ctx.lr = 0x82AA5918;
	sub_82DF23D8(ctx, base);
	// 82AA5918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA591C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA5924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA592C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA5930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA5938 size=320
    let mut pc: u32 = 0x82AA5938;
    'dispatch: loop {
        match pc {
            0x82AA5938 => {
    //   block [0x82AA5938..0x82AA5A78)
	// 82AA5938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA593C: 48702831  bl 0x831a816c
	ctx.lr = 0x82AA5940;
	sub_831A8130(ctx, base);
	// 82AA5940: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA5944: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA5948: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA594C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA5950: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA5954: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA5958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA595C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5960: 4BB24BA1  bl 0x825ca500
	ctx.lr = 0x82AA5964;
	sub_825CA500(ctx, base);
	// 82AA5964: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5968: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA596C: 388B58F8  addi r4, r11, 0x58f8
	ctx.r[4].s64 = ctx.r[11].s64 + 22776;
	// 82AA5970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5974: 4834E095  bl 0x82df3a08
	ctx.lr = 0x82AA5978;
	sub_82DF3A08(ctx, base);
	// 82AA5978: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA597C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5980: 388B58EC  addi r4, r11, 0x58ec
	ctx.r[4].s64 = ctx.r[11].s64 + 22764;
	// 82AA5984: 4834E085  bl 0x82df3a08
	ctx.lr = 0x82AA5988;
	sub_82DF3A08(ctx, base);
	// 82AA5988: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA598C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA5990: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA5994: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5998: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA599C: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA59A0: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA59A4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA59A8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA59AC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA59B0: 4BAFD8F9  bl 0x825a32a8
	ctx.lr = 0x82AA59B4;
	sub_825A32A8(ctx, base);
	// 82AA59B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA59B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA59BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA59C0: 4BAFBDB1  bl 0x825a1770
	ctx.lr = 0x82AA59C4;
	sub_825A1770(ctx, base);
	// 82AA59C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA59C8: 4834DA61  bl 0x82df3428
	ctx.lr = 0x82AA59CC;
	sub_82DF3428(ctx, base);
	// 82AA59CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA59D0: 4B8232E9  bl 0x822c8cb8
	ctx.lr = 0x82AA59D4;
	sub_822C8CB8(ctx, base);
	// 82AA59D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA59D8: 4834DA51  bl 0x82df3428
	ctx.lr = 0x82AA59DC;
	sub_82DF3428(ctx, base);
	// 82AA59DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA59E0: 4834DA49  bl 0x82df3428
	ctx.lr = 0x82AA59E4;
	sub_82DF3428(ctx, base);
	// 82AA59E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA59E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA59EC: 388B68C8  addi r4, r11, 0x68c8
	ctx.r[4].s64 = ctx.r[11].s64 + 26824;
	// 82AA59F0: 4834E019  bl 0x82df3a08
	ctx.lr = 0x82AA59F4;
	sub_82DF3A08(ctx, base);
	// 82AA59F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA59F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA59FC: 388B68B8  addi r4, r11, 0x68b8
	ctx.r[4].s64 = ctx.r[11].s64 + 26808;
	// 82AA5A00: 4834E009  bl 0x82df3a08
	ctx.lr = 0x82AA5A04;
	sub_82DF3A08(ctx, base);
	// 82AA5A04: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA5A08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA5A0C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA5A10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA5A14: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA5A18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA5A1C: 4BAFD88D  bl 0x825a32a8
	ctx.lr = 0x82AA5A20;
	sub_825A32A8(ctx, base);
	// 82AA5A20: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA5A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5A28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5A2C: 4BAFBD45  bl 0x825a1770
	ctx.lr = 0x82AA5A30;
	sub_825A1770(ctx, base);
	// 82AA5A30: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA5A34: 4834D9F5  bl 0x82df3428
	ctx.lr = 0x82AA5A38;
	sub_82DF3428(ctx, base);
	// 82AA5A38: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA5A3C: 4B82327D  bl 0x822c8cb8
	ctx.lr = 0x82AA5A40;
	sub_822C8CB8(ctx, base);
	// 82AA5A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5A44: 4834D9E5  bl 0x82df3428
	ctx.lr = 0x82AA5A48;
	sub_82DF3428(ctx, base);
	// 82AA5A48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5A4C: 4834D9DD  bl 0x82df3428
	ctx.lr = 0x82AA5A50;
	sub_82DF3428(ctx, base);
	// 82AA5A50: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5A54: 4BB2427D  bl 0x825c9cd0
	ctx.lr = 0x82AA5A58;
	sub_825C9CD0(ctx, base);
	// 82AA5A58: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5A60: 419A0008  beq cr6, 0x82aa5a68
	if ctx.cr[6].eq {
	pc = 0x82AA5A68; continue 'dispatch;
	}
	// 82AA5A64: 4B81AE2D  bl 0x822c0890
	ctx.lr = 0x82AA5A68;
	sub_822C0890(ctx, base);
	// 82AA5A68: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82AA5A6C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA5A70: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA5A74: 48702748  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5A78 size=412
    let mut pc: u32 = 0x82AA5A78;
    'dispatch: loop {
        match pc {
            0x82AA5A78 => {
    //   block [0x82AA5A78..0x82AA5C14)
	// 82AA5A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA5A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA5A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA5A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5A8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5A94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA5A98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5A9C: 388B6940  addi r4, r11, 0x6940
	ctx.r[4].s64 = ctx.r[11].s64 + 26944;
	// 82AA5AA0: 4834DF69  bl 0x82df3a08
	ctx.lr = 0x82AA5AA4;
	sub_82DF3A08(ctx, base);
	// 82AA5AA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5AAC: 388B6930  addi r4, r11, 0x6930
	ctx.r[4].s64 = ctx.r[11].s64 + 26928;
	// 82AA5AB0: 4834DF59  bl 0x82df3a08
	ctx.lr = 0x82AA5AB4;
	sub_82DF3A08(ctx, base);
	// 82AA5AB4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5AB8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA5ABC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA5AC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA5AC4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5AC8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA5ACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA5AD0: 4E800421  bctrl
	ctx.lr = 0x82AA5AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA5AD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5AD8: 4834D951  bl 0x82df3428
	ctx.lr = 0x82AA5ADC;
	sub_82DF3428(ctx, base);
	// 82AA5ADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5AE0: 4834D949  bl 0x82df3428
	ctx.lr = 0x82AA5AE4;
	sub_82DF3428(ctx, base);
	// 82AA5AE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5AEC: 388B6918  addi r4, r11, 0x6918
	ctx.r[4].s64 = ctx.r[11].s64 + 26904;
	// 82AA5AF0: 4834DF19  bl 0x82df3a08
	ctx.lr = 0x82AA5AF4;
	sub_82DF3A08(ctx, base);
	// 82AA5AF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5AF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5AFC: 388B6904  addi r4, r11, 0x6904
	ctx.r[4].s64 = ctx.r[11].s64 + 26884;
	// 82AA5B00: 4834DF09  bl 0x82df3a08
	ctx.lr = 0x82AA5B04;
	sub_82DF3A08(ctx, base);
	// 82AA5B04: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA5B08: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA5B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA5B10: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA5B14: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA5B18: 419A0024  beq cr6, 0x82aa5b3c
	if ctx.cr[6].eq {
	pc = 0x82AA5B3C; continue 'dispatch;
	}
	// 82AA5B1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA5B20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA5B24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5B28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA5B2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA5B30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA5B34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5B38: 4082FFE8  bne 0x82aa5b20
	if !ctx.cr[0].eq {
	pc = 0x82AA5B20; continue 'dispatch;
	}
	// 82AA5B3C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA5B40: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA5B44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA5B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5B4C: 4BFFFDED  bl 0x82aa5938
	ctx.lr = 0x82AA5B50;
	sub_82AA5938(ctx, base);
	// 82AA5B50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5B54: 4834D8D5  bl 0x82df3428
	ctx.lr = 0x82AA5B58;
	sub_82DF3428(ctx, base);
	// 82AA5B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5B5C: 4834D8CD  bl 0x82df3428
	ctx.lr = 0x82AA5B60;
	sub_82DF3428(ctx, base);
	// 82AA5B60: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5B68: 388B68EC  addi r4, r11, 0x68ec
	ctx.r[4].s64 = ctx.r[11].s64 + 26860;
	// 82AA5B6C: 4834DE9D  bl 0x82df3a08
	ctx.lr = 0x82AA5B70;
	sub_82DF3A08(ctx, base);
	// 82AA5B70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5B74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5B78: 388B68D8  addi r4, r11, 0x68d8
	ctx.r[4].s64 = ctx.r[11].s64 + 26840;
	// 82AA5B7C: 4834DE8D  bl 0x82df3a08
	ctx.lr = 0x82AA5B80;
	sub_82DF3A08(ctx, base);
	// 82AA5B80: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA5B84: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA5B88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA5B8C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA5B90: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA5B94: 419A0024  beq cr6, 0x82aa5bb8
	if ctx.cr[6].eq {
	pc = 0x82AA5BB8; continue 'dispatch;
	}
	// 82AA5B98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA5B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA5BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA5BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA5BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA5BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5BB4: 4082FFE8  bne 0x82aa5b9c
	if !ctx.cr[0].eq {
	pc = 0x82AA5B9C; continue 'dispatch;
	}
	// 82AA5BB8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA5BBC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA5BC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA5BC4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82AA5BC8: 4BFFFD71  bl 0x82aa5938
	ctx.lr = 0x82AA5BCC;
	sub_82AA5938(ctx, base);
	// 82AA5BCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5BD0: 4834D859  bl 0x82df3428
	ctx.lr = 0x82AA5BD4;
	sub_82DF3428(ctx, base);
	// 82AA5BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5BD8: 4834D851  bl 0x82df3428
	ctx.lr = 0x82AA5BDC;
	sub_82DF3428(ctx, base);
	// 82AA5BDC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA5BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5BE4: 419A0008  beq cr6, 0x82aa5bec
	if ctx.cr[6].eq {
	pc = 0x82AA5BEC; continue 'dispatch;
	}
	// 82AA5BE8: 4B81ACA9  bl 0x822c0890
	ctx.lr = 0x82AA5BEC;
	sub_822C0890(ctx, base);
	// 82AA5BEC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5BF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5BF4: 419A0008  beq cr6, 0x82aa5bfc
	if ctx.cr[6].eq {
	pc = 0x82AA5BFC; continue 'dispatch;
	}
	// 82AA5BF8: 4B81AC99  bl 0x822c0890
	ctx.lr = 0x82AA5BFC;
	sub_822C0890(ctx, base);
	// 82AA5BFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA5C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA5C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5C08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA5C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA5C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5C18 size=112
    let mut pc: u32 = 0x82AA5C18;
    'dispatch: loop {
        match pc {
            0x82AA5C18 => {
    //   block [0x82AA5C18..0x82AA5C88)
	// 82AA5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5C1C: 48702551  bl 0x831a816c
	ctx.lr = 0x82AA5C20;
	sub_831A8130(ctx, base);
	// 82AA5C20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5C24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5C28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA5C2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA5C30: 388B6950  addi r4, r11, 0x6950
	ctx.r[4].s64 = ctx.r[11].s64 + 26960;
	// 82AA5C34: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82AA5C38: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 82AA5C3C: 4834C7AD  bl 0x82df23e8
	ctx.lr = 0x82AA5C40;
	sub_82DF23E8(ctx, base);
	// 82AA5C40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA5C44: 41820010  beq 0x82aa5c54
	if ctx.cr[0].eq {
	pc = 0x82AA5C54; continue 'dispatch;
	}
	// 82AA5C48: 4BFFFBD1  bl 0x82aa5818
	ctx.lr = 0x82AA5C4C;
	sub_82AA5818(ctx, base);
	// 82AA5C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5C50: 48000008  b 0x82aa5c58
	pc = 0x82AA5C58; continue 'dispatch;
	// 82AA5C54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA5C58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA5C5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA5C60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA5C64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5C68: 4BFFFAE9  bl 0x82aa5750
	ctx.lr = 0x82AA5C6C;
	sub_82AA5750(ctx, base);
	// 82AA5C6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA5C70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA5C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA5C78: 4B81A389  bl 0x822c0000
	ctx.lr = 0x82AA5C7C;
	sub_822C0000(ctx, base);
	// 82AA5C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5C80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5C84: 48702538  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5C88 size=128
    let mut pc: u32 = 0x82AA5C88;
    'dispatch: loop {
        match pc {
            0x82AA5C88 => {
    //   block [0x82AA5C88..0x82AA5D08)
	// 82AA5C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA5C90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA5C94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5C98: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5C9C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA5CA0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA5CA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA5CAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA5CB0: 419A0024  beq cr6, 0x82aa5cd4
	if ctx.cr[6].eq {
	pc = 0x82AA5CD4; continue 'dispatch;
	}
	// 82AA5CB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA5CB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA5CBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5CC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA5CC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA5CC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA5CCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5CD0: 4082FFE8  bne 0x82aa5cb8
	if !ctx.cr[0].eq {
	pc = 0x82AA5CB8; continue 'dispatch;
	}
	// 82AA5CD4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA5CD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5CDC: 386BE474  addi r3, r11, -0x1b8c
	ctx.r[3].s64 = ctx.r[11].s64 + -7052;
	// 82AA5CE0: 4BFFFD99  bl 0x82aa5a78
	ctx.lr = 0x82AA5CE4;
	sub_82AA5A78(ctx, base);
	// 82AA5CE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5CEC: 419A0008  beq cr6, 0x82aa5cf4
	if ctx.cr[6].eq {
	pc = 0x82AA5CF4; continue 'dispatch;
	}
	// 82AA5CF0: 4B81ABA1  bl 0x822c0890
	ctx.lr = 0x82AA5CF4;
	sub_822C0890(ctx, base);
	// 82AA5CF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5CF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA5CFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA5D00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA5D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA5D08 size=292
    let mut pc: u32 = 0x82AA5D08;
    'dispatch: loop {
        match pc {
            0x82AA5D08 => {
    //   block [0x82AA5D08..0x82AA5E2C)
	// 82AA5D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5D0C: 4870245D  bl 0x831a8168
	ctx.lr = 0x82AA5D10;
	sub_831A8130(ctx, base);
	// 82AA5D10: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AA5D14: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5D18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA5D1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA5D20: 486AE8E1  bl 0x83154600
	ctx.lr = 0x82AA5D24;
	sub_83154600(ctx, base);
	// 82AA5D24: 4BE12FC5  bl 0x828b8ce8
	ctx.lr = 0x82AA5D28;
	sub_828B8CE8(ctx, base);
	// 82AA5D28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA5D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5D30: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA5D34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA5D38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA5D3C: 4BEA45BD  bl 0x8294a2f8
	ctx.lr = 0x82AA5D40;
	sub_8294A2F8(ctx, base);
	// 82AA5D40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5D44: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA5D48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA5D4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA5D50: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA5D54: 419A0024  beq cr6, 0x82aa5d78
	if ctx.cr[6].eq {
	pc = 0x82AA5D78; continue 'dispatch;
	}
	// 82AA5D58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA5D5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA5D60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5D64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA5D68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA5D6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA5D70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA5D74: 4082FFE8  bne 0x82aa5d5c
	if !ctx.cr[0].eq {
	pc = 0x82AA5D5C; continue 'dispatch;
	}
	// 82AA5D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5D7C: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82AA5D80: 4BFDB981  bl 0x82a81700
	ctx.lr = 0x82AA5D84;
	sub_82A81700(ctx, base);
	// 82AA5D84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA5D88: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA5D8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA5D90: 388A6950  addi r4, r10, 0x6950
	ctx.r[4].s64 = ctx.r[10].s64 + 26960;
	// 82AA5D94: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 82AA5D98: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA5D9C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA5DA0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AA5DA4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA5DA8: 483B2C99  bl 0x82e58a40
	ctx.lr = 0x82AA5DAC;
	sub_82E58A40(ctx, base);
	// 82AA5DAC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA5DB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5DB4: 419A0008  beq cr6, 0x82aa5dbc
	if ctx.cr[6].eq {
	pc = 0x82AA5DBC; continue 'dispatch;
	}
	// 82AA5DB8: 4B81AAD9  bl 0x822c0890
	ctx.lr = 0x82AA5DBC;
	sub_822C0890(ctx, base);
	// 82AA5DBC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA5DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5DC4: 419A0008  beq cr6, 0x82aa5dcc
	if ctx.cr[6].eq {
	pc = 0x82AA5DCC; continue 'dispatch;
	}
	// 82AA5DC8: 4B81AAC9  bl 0x822c0890
	ctx.lr = 0x82AA5DCC;
	sub_822C0890(ctx, base);
	// 82AA5DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5DD0: 48562359  bl 0x83008128
	ctx.lr = 0x82AA5DD4;
	sub_83008128(ctx, base);
	// 82AA5DD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA5DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5DDC: 4BFDB915  bl 0x82a816f0
	ctx.lr = 0x82AA5DE0;
	sub_82A816F0(ctx, base);
	// 82AA5DE0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA5DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA5DE8: 808BCA08  lwz r4, -0x35f8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13816 as u32) ) } as u64;
	// 82AA5DEC: 4834DC1D  bl 0x82df3a08
	ctx.lr = 0x82AA5DF0;
	sub_82DF3A08(ctx, base);
	// 82AA5DF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA5DF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA5DF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA5DFC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA5E00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA5E04: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA5E08: 483B8C89  bl 0x82e5ea90
	ctx.lr = 0x82AA5E0C;
	sub_82E5EA90(ctx, base);
	// 82AA5E0C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA5E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA5E14: 419A0008  beq cr6, 0x82aa5e1c
	if ctx.cr[6].eq {
	pc = 0x82AA5E1C; continue 'dispatch;
	}
	// 82AA5E18: 4B81AA79  bl 0x822c0890
	ctx.lr = 0x82AA5E1C;
	sub_822C0890(ctx, base);
	// 82AA5E1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA5E20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA5E24: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA5E28: 48702390  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA5E30 size=104
    let mut pc: u32 = 0x82AA5E30;
    'dispatch: loop {
        match pc {
            0x82AA5E30 => {
    //   block [0x82AA5E30..0x82AA5E98)
	// 82AA5E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5E34: 48702339  bl 0x831a816c
	ctx.lr = 0x82AA5E38;
	sub_831A8130(ctx, base);
	// 82AA5E38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5E3C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA5E40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA5E44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA5E48: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5E4C: 41820034  beq 0x82aa5e80
	if ctx.cr[0].eq {
	pc = 0x82AA5E80; continue 'dispatch;
	}
	// 82AA5E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5E54: 48703B35  bl 0x831a9988
	ctx.lr = 0x82AA5E58;
	sub_831A9988(ctx, base);
	// 82AA5E58: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82AA5E5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA5E60: 386B3A14  addi r3, r11, 0x3a14
	ctx.r[3].s64 = ctx.r[11].s64 + 14868;
	// 82AA5E64: 48702295  bl 0x831a80f8
	ctx.lr = 0x82AA5E68;
	sub_831A80F8(ctx, base);
	// 82AA5E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5E6C: 41820014  beq 0x82aa5e80
	if ctx.cr[0].eq {
	pc = 0x82AA5E80; continue 'dispatch;
	}
	// 82AA5E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA5E74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5E78: 4BFFFE91  bl 0x82aa5d08
	ctx.lr = 0x82AA5E7C;
	sub_82AA5D08(ctx, base);
	// 82AA5E7C: 48000014  b 0x82aa5e90
	pc = 0x82AA5E90; continue 'dispatch;
	// 82AA5E80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA5E84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA5E88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA5E8C: 486D85FD  bl 0x8317e488
	ctx.lr = 0x82AA5E90;
	sub_8317E488(ctx, base);
	// 82AA5E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA5E94: 48702328  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA5E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA5E98 size=1192
    let mut pc: u32 = 0x82AA5E98;
    'dispatch: loop {
        match pc {
            0x82AA5E98 => {
    //   block [0x82AA5E98..0x82AA6340)
	// 82AA5E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA5E9C: 487022BD  bl 0x831a8158
	ctx.lr = 0x82AA5EA0;
	sub_831A8130(ctx, base);
	// 82AA5EA0: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82AA5EA4: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82AA5EA8: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA5EAC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82AA5EB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA5EB4: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82AA5EB8: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82AA5EBC: 486AE745  bl 0x83154600
	ctx.lr = 0x82AA5EC0;
	sub_83154600(ctx, base);
	// 82AA5EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA5EC4: 4BE12E25  bl 0x828b8ce8
	ctx.lr = 0x82AA5EC8;
	sub_828B8CE8(ctx, base);
	// 82AA5EC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA5ECC: 4BFDB7DD  bl 0x82a816a8
	ctx.lr = 0x82AA5ED0;
	sub_82A816A8(ctx, base);
	// 82AA5ED0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5ED4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AA5ED8: 556BE7FF  rlwinm. r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA5EDC: 4182000C  beq 0x82aa5ee8
	if ctx.cr[0].eq {
	pc = 0x82AA5EE8; continue 'dispatch;
	}
	// 82AA5EE0: 93DD006C  stw r30, 0x6c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82AA5EE4: 48000008  b 0x82aa5eec
	pc = 0x82AA5EEC; continue 'dispatch;
	// 82AA5EE8: 933D006C  stw r25, 0x6c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 82AA5EEC: 815D006C  lwz r10, 0x6c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA5EF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA5EF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA5EF8: 396BE474  addi r11, r11, -0x1b8c
	ctx.r[11].s64 = ctx.r[11].s64 + -7052;
	// 82AA5EFC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AA5F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5F04: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA5F08: 917D0070  stw r11, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA5F0C: 4BFE2785  bl 0x82a88690
	ctx.lr = 0x82AA5F10;
	sub_82A88690(ctx, base);
	// 82AA5F10: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA5F14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5F18: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA5F1C: 4834DAED  bl 0x82df3a08
	ctx.lr = 0x82AA5F20;
	sub_82DF3A08(ctx, base);
	// 82AA5F20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA5F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5F28: 4BD49849  bl 0x827ef770
	ctx.lr = 0x82AA5F2C;
	sub_827EF770(ctx, base);
	// 82AA5F2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5F30: 4834D4F9  bl 0x82df3428
	ctx.lr = 0x82AA5F34;
	sub_82DF3428(ctx, base);
	// 82AA5F34: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA5F38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5F3C: 808B9FA0  lwz r4, -0x6060(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24672 as u32) ) } as u64;
	// 82AA5F40: 4834DAC9  bl 0x82df3a08
	ctx.lr = 0x82AA5F44;
	sub_82DF3A08(ctx, base);
	// 82AA5F44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5F48: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA5F50: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA5F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA5F58: 4E800421  bctrl
	ctx.lr = 0x82AA5F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA5F5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA5F60: 4834D4C9  bl 0x82df3428
	ctx.lr = 0x82AA5F64;
	sub_82DF3428(ctx, base);
	// 82AA5F64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA5F68: 4BFDB741  bl 0x82a816a8
	ctx.lr = 0x82AA5F6C;
	sub_82A816A8(ctx, base);
	// 82AA5F6C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AA5F70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5F74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA5F78: 3BEB6950  addi r31, r11, 0x6950
	ctx.r[31].s64 = ctx.r[11].s64 + 26960;
	// 82AA5F7C: 38A000C3  li r5, 0xc3
	ctx.r[5].s64 = 195;
	// 82AA5F80: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA5F84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA5F88: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82AA5F8C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA5F90: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA5F94: 4B81A445  bl 0x822c03d8
	ctx.lr = 0x82AA5F98;
	sub_822C03D8(ctx, base);
	// 82AA5F98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA5F9C: 41820010  beq 0x82aa5fac
	if ctx.cr[0].eq {
	pc = 0x82AA5FAC; continue 'dispatch;
	}
	// 82AA5FA0: 4B9AD251  bl 0x824531f0
	ctx.lr = 0x82AA5FA4;
	sub_824531F0(ctx, base);
	// 82AA5FA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA5FA8: 48000008  b 0x82aa5fb0
	pc = 0x82AA5FB0; continue 'dispatch;
	// 82AA5FAC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA5FB0: 387D0064  addi r3, r29, 0x64
	ctx.r[3].s64 = ctx.r[29].s64 + 100;
	// 82AA5FB4: 4B8634CD  bl 0x82309480
	ctx.lr = 0x82AA5FB8;
	sub_82309480(ctx, base);
	// 82AA5FB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA5FBC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA5FC0: 396B69E4  addi r11, r11, 0x69e4
	ctx.r[11].s64 = ctx.r[11].s64 + 27108;
	// 82AA5FC4: 394A69D8  addi r10, r10, 0x69d8
	ctx.r[10].s64 = ctx.r[10].s64 + 27096;
	// 82AA5FC8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AA5FCC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA5FD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA5FD4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82AA5FD8: 4BFDBB89  bl 0x82a81b60
	ctx.lr = 0x82AA5FDC;
	sub_82A81B60(ctx, base);
	// 82AA5FDC: 546B177A  rlwinm r11, r3, 2, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x3FFFFFFFu64;
	// 82AA5FE0: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82AA5FE4: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82AA5FE8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82AA5FEC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82AA5FF0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82AA5FF4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA5FF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA5FFC: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA6000: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AA6004: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA6008: 4BFDD8E1  bl 0x82a838e8
	ctx.lr = 0x82AA600C;
	sub_82A838E8(ctx, base);
	// 82AA600C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6010: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA6014: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA601C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA6020: 419A0024  beq cr6, 0x82aa6044
	if ctx.cr[6].eq {
	pc = 0x82AA6044; continue 'dispatch;
	}
	// 82AA6024: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA6028: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA602C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6030: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6034: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6038: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA603C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6040: 4082FFE8  bne 0x82aa6028
	if !ctx.cr[0].eq {
	pc = 0x82AA6028; continue 'dispatch;
	}
	// 82AA6044: 3B7C0010  addi r27, r28, 0x10
	ctx.r[27].s64 = ctx.r[28].s64 + 16;
	// 82AA6048: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA604C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA6050: 4BA69479  bl 0x8250f4c8
	ctx.lr = 0x82AA6054;
	sub_8250F4C8(ctx, base);
	// 82AA6054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA605C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA6060: 409A0008  bne cr6, 0x82aa6068
	if !ctx.cr[6].eq {
	pc = 0x82AA6068; continue 'dispatch;
	}
	// 82AA6064: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA6068: 3B010068  addi r24, r1, 0x68
	ctx.r[24].s64 = ctx.r[1].s64 + 104;
	// 82AA606C: 4BA625AD  bl 0x82508618
	ctx.lr = 0x82AA6070;
	sub_82508618(ctx, base);
	// 82AA6070: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA6074: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA6078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA607C: 38A000CE  li r5, 0xce
	ctx.r[5].s64 = 206;
	// 82AA6080: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82AA6084: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA6088: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82AA608C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA6090: 483B29B1  bl 0x82e58a40
	ctx.lr = 0x82AA6094;
	sub_82E58A40(ctx, base);
	// 82AA6094: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA6098: 4834BBF9  bl 0x82df1c90
	ctx.lr = 0x82AA609C;
	sub_82DF1C90(ctx, base);
	// 82AA609C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA60A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA60A4: 419A0008  beq cr6, 0x82aa60ac
	if ctx.cr[6].eq {
	pc = 0x82AA60AC; continue 'dispatch;
	}
	// 82AA60A8: 4B81A7E9  bl 0x822c0890
	ctx.lr = 0x82AA60AC;
	sub_822C0890(ctx, base);
	// 82AA60AC: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82AA60B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA60B4: 419A0008  beq cr6, 0x82aa60bc
	if ctx.cr[6].eq {
	pc = 0x82AA60BC; continue 'dispatch;
	}
	// 82AA60B8: 4B81A7D9  bl 0x822c0890
	ctx.lr = 0x82AA60BC;
	sub_822C0890(ctx, base);
	// 82AA60BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA60C0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AA60C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA60C8: 4BFDBAA9  bl 0x82a81b70
	ctx.lr = 0x82AA60CC;
	sub_82A81B70(ctx, base);
	// 82AA60CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA60D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA60D4: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 82AA60D8: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82AA60DC: 4834C30D  bl 0x82df23e8
	ctx.lr = 0x82AA60E0;
	sub_82DF23E8(ctx, base);
	// 82AA60E0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AA60E4: 41820034  beq 0x82aa6118
	if ctx.cr[0].eq {
	pc = 0x82AA6118; continue 'dispatch;
	}
	// 82AA60E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA60EC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AA60F0: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82AA60F4: 4BA693D5  bl 0x8250f4c8
	ctx.lr = 0x82AA60F8;
	sub_8250F4C8(ctx, base);
	// 82AA60F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA60FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA6100: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA6104: 409A0008  bne cr6, 0x82aa610c
	if !ctx.cr[6].eq {
	pc = 0x82AA610C; continue 'dispatch;
	}
	// 82AA6108: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AA610C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6110: 4BD2A441  bl 0x827d0550
	ctx.lr = 0x82AA6114;
	sub_827D0550(ctx, base);
	// 82AA6114: 48000008  b 0x82aa611c
	pc = 0x82AA611C; continue 'dispatch;
	// 82AA6118: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA611C: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA6120: 3BDD0060  addi r30, r29, 0x60
	ctx.r[30].s64 = ctx.r[29].s64 + 96;
	// 82AA6124: 907D0060  stw r3, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82AA6128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA612C: 419A001C  beq cr6, 0x82aa6148
	if ctx.cr[6].eq {
	pc = 0x82AA6148; continue 'dispatch;
	}
	// 82AA6130: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6134: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA6138: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA613C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA6144: 4E800421  bctrl
	ctx.lr = 0x82AA6148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA6148: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA614C: 4182000C  beq 0x82aa6158
	if ctx.cr[0].eq {
	pc = 0x82AA6158; continue 'dispatch;
	}
	// 82AA6150: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AA6154: 4834BB3D  bl 0x82df1c90
	ctx.lr = 0x82AA6158;
	sub_82DF1C90(ctx, base);
	// 82AA6158: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA615C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA6160: 388B23C4  addi r4, r11, 0x23c4
	ctx.r[4].s64 = ctx.r[11].s64 + 9156;
	// 82AA6164: 4834D8A5  bl 0x82df3a08
	ctx.lr = 0x82AA6168;
	sub_82DF3A08(ctx, base);
	// 82AA6168: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA616C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AA6170: 3B4B69C4  addi r26, r11, 0x69c4
	ctx.r[26].s64 = ctx.r[11].s64 + 27076;
	// 82AA6174: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA6178: 4834D891  bl 0x82df3a08
	ctx.lr = 0x82AA617C;
	sub_82DF3A08(ctx, base);
	// 82AA617C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA6180: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AA6184: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AA6188: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA618C: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA6190: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	// 82AA6194: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA6198: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AA619C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82AA61A0: C00B9530  lfs f0, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA61A4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AA61A8: C1AA6154  lfs f13, 0x6154(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24916 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA61AC: 388869BC  addi r4, r8, 0x69bc
	ctx.r[4].s64 = ctx.r[8].s64 + 27068;
	// 82AA61B0: C3C908A8  lfs f30, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA61B4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA61B8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AA61BC: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AA61C0: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AA61C4: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AA61C8: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AA61CC: 4834D83D  bl 0x82df3a08
	ctx.lr = 0x82AA61D0;
	sub_82DF3A08(ctx, base);
	// 82AA61D0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA61D4: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82AA61D8: 4834D831  bl 0x82df3a08
	ctx.lr = 0x82AA61DC;
	sub_82DF3A08(ctx, base);
	// 82AA61DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA61E0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AA61E4: D3E100AC  stfs f31, 0xac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AA61E8: D3C100B0  stfs f30, 0xb0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82AA61EC: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82AA61F0: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AA61F4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AA61F8: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82AA61FC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA6200: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6204: 388925E8  addi r4, r9, 0x25e8
	ctx.r[4].s64 = ctx.r[9].s64 + 9704;
	// 82AA6208: C1AA7A10  lfs f13, 0x7a10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA620C: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82AA6210: D1A100B8  stfs f13, 0xb8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82AA6214: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AA6218: D3C100C8  stfs f30, 0xc8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AA621C: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AA6220: 4834D7E9  bl 0x82df3a08
	ctx.lr = 0x82AA6224;
	sub_82DF3A08(ctx, base);
	// 82AA6224: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6228: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 82AA622C: 3B4B69A8  addi r26, r11, 0x69a8
	ctx.r[26].s64 = ctx.r[11].s64 + 27048;
	// 82AA6230: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA6234: 4834D7D5  bl 0x82df3a08
	ctx.lr = 0x82AA6238;
	sub_82DF3A08(ctx, base);
	// 82AA6238: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AA623C: D3E100DC  stfs f31, 0xdc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82AA6240: 93E100D8  stw r31, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[31].u32 ) };
	// 82AA6244: D3E100E0  stfs f31, 0xe0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82AA6248: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA624C: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82AA6250: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA6254: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82AA6258: 388A25E0  addi r4, r10, 0x25e0
	ctx.r[4].s64 = ctx.r[10].s64 + 9696;
	// 82AA625C: C00B7218  lfs f0, 0x7218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6260: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82AA6264: D3E100F0  stfs f31, 0xf0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82AA6268: D3C100F4  stfs f30, 0xf4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82AA626C: D3C100F8  stfs f30, 0xf8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82AA6270: D3C100FC  stfs f30, 0xfc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82AA6274: 4834D795  bl 0x82df3a08
	ctx.lr = 0x82AA6278;
	sub_82DF3A08(ctx, base);
	// 82AA6278: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA627C: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 82AA6280: 4834D789  bl 0x82df3a08
	ctx.lr = 0x82AA6284;
	sub_82DF3A08(ctx, base);
	// 82AA6284: D3E1010C  stfs f31, 0x10c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82AA6288: D3C10124  stfs f30, 0x124(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82AA628C: 93E10108  stw r31, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[31].u32 ) };
	// 82AA6290: D3C10128  stfs f30, 0x128(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82AA6294: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA6298: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA629C: D3C1012C  stfs f30, 0x12c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82AA62A0: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA62A4: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82AA62A8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82AA62AC: D3E10114  stfs f31, 0x114(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82AA62B0: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82AA62B4: D3E1011C  stfs f31, 0x11c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82AA62B8: D3E10120  stfs f31, 0x120(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82AA62BC: 4BD4630D  bl 0x827ec5c8
	ctx.lr = 0x82AA62C0;
	sub_827EC5C8(ctx, base);
	// 82AA62C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA62C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA62C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA62CC: 4BA691FD  bl 0x8250f4c8
	ctx.lr = 0x82AA62D0;
	sub_8250F4C8(ctx, base);
	// 82AA62D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA62D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA62D8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA62DC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AA62E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA62E4: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82AA62E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA62EC: 4BD29DD5  bl 0x827d00c0
	ctx.lr = 0x82AA62F0;
	sub_827D00C0(ctx, base);
	// 82AA62F0: 3BE10130  addi r31, r1, 0x130
	ctx.r[31].s64 = ctx.r[1].s64 + 304;
	// 82AA62F4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82AA62F8: 3BFFFFD0  addi r31, r31, -0x30
	ctx.r[31].s64 = ctx.r[31].s64 + -48;
	// 82AA62FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AA6300: 4834D129  bl 0x82df3428
	ctx.lr = 0x82AA6304;
	sub_82DF3428(ctx, base);
	// 82AA6304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6308: 4834D121  bl 0x82df3428
	ctx.lr = 0x82AA630C;
	sub_82DF3428(ctx, base);
	// 82AA630C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA6310: 4080FFE8  bge 0x82aa62f8
	if !ctx.cr[0].lt {
	pc = 0x82AA62F8; continue 'dispatch;
	}
	// 82AA6314: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA6318: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA631C: 4BFDE64D  bl 0x82a84968
	ctx.lr = 0x82AA6320;
	sub_82A84968(ctx, base);
	// 82AA6320: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA6324: 933D0074  stw r25, 0x74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82AA6328: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA632C: D01D0078  stfs f0, 0x78(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA6330: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82AA6334: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82AA6338: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82AA633C: 48701E6C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA6340 size=1504
    let mut pc: u32 = 0x82AA6340;
    'dispatch: loop {
        match pc {
            0x82AA6340 => {
    //   block [0x82AA6340..0x82AA6920)
	// 82AA6340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6344: 48701E1D  bl 0x831a8160
	ctx.lr = 0x82AA6348;
	sub_831A8130(ctx, base);
	// 82AA6348: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82AA634C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AA6350: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6354: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA6358: 486AE2A9  bl 0x83154600
	ctx.lr = 0x82AA635C;
	sub_83154600(ctx, base);
	// 82AA635C: 4BE1298D  bl 0x828b8ce8
	ctx.lr = 0x82AA6360;
	sub_828B8CE8(ctx, base);
	// 82AA6360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA6364: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA6368: 483B3411  bl 0x82e59778
	ctx.lr = 0x82AA636C;
	sub_82E59778(ctx, base);
	// 82AA636C: C01A0078  lfs f0, 0x78(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6370: 817A0074  lwz r11, 0x74(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA6374: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA6378: D01A0078  stfs f0, 0x78(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA637C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA6380: 41980330  blt cr6, 0x82aa66b0
	if ctx.cr[6].lt {
	pc = 0x82AA66B0; continue 'dispatch;
	}
	// 82AA6384: 409A058C  bne cr6, 0x82aa6910
	if !ctx.cr[6].eq {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA6388: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA638C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA6390: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA6394: 40980140  bge cr6, 0x82aa64d4
	if !ctx.cr[6].lt {
	pc = 0x82AA64D4; continue 'dispatch;
	}
	// 82AA6398: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA639C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AA63A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA63A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA63A8: 4BEA3F51  bl 0x8294a2f8
	ctx.lr = 0x82AA63AC;
	sub_8294A2F8(ctx, base);
	// 82AA63AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA63B0: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA63B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA63B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA63BC: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82AA63C0: 419A0024  beq cr6, 0x82aa63e4
	if ctx.cr[6].eq {
	pc = 0x82AA63E4; continue 'dispatch;
	}
	// 82AA63C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA63C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA63CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA63D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA63D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA63D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA63DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA63E0: 4082FFE8  bne 0x82aa63c8
	if !ctx.cr[0].eq {
	pc = 0x82AA63C8; continue 'dispatch;
	}
	// 82AA63E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA63E8: 3BE10098  addi r31, r1, 0x98
	ctx.r[31].s64 = ctx.r[1].s64 + 152;
	// 82AA63EC: 4BFDB315  bl 0x82a81700
	ctx.lr = 0x82AA63F0;
	sub_82A81700(ctx, base);
	// 82AA63F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA63F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA63F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA63FC: 388B6950  addi r4, r11, 0x6950
	ctx.r[4].s64 = ctx.r[11].s64 + 26960;
	// 82AA6400: 38A00127  li r5, 0x127
	ctx.r[5].s64 = 295;
	// 82AA6404: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82AA6408: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA640C: 483B2635  bl 0x82e58a40
	ctx.lr = 0x82AA6410;
	sub_82E58A40(ctx, base);
	// 82AA6410: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AA6414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6418: 419A0008  beq cr6, 0x82aa6420
	if ctx.cr[6].eq {
	pc = 0x82AA6420; continue 'dispatch;
	}
	// 82AA641C: 4B81A475  bl 0x822c0890
	ctx.lr = 0x82AA6420;
	sub_822C0890(ctx, base);
	// 82AA6420: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AA6424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6428: 419A0008  beq cr6, 0x82aa6430
	if ctx.cr[6].eq {
	pc = 0x82AA6430; continue 'dispatch;
	}
	// 82AA642C: 4B81A465  bl 0x822c0890
	ctx.lr = 0x82AA6430;
	sub_822C0890(ctx, base);
	// 82AA6430: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6434: 4BFDB275  bl 0x82a816a8
	ctx.lr = 0x82AA6438;
	sub_82A816A8(ctx, base);
	// 82AA6438: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA643C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82AA6440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6444: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6448: 554A0776  rlwinm r10, r10, 0, 0x1d, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82AA644C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA6450: 4BE62A11  bl 0x82908e60
	ctx.lr = 0x82AA6454;
	sub_82908E60(ctx, base);
	// 82AA6454: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82AA6458: 4BFDB1B9  bl 0x82a81610
	ctx.lr = 0x82AA645C;
	sub_82A81610(ctx, base);
	// 82AA645C: C003002C  lfs f0, 0x2c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6464: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AA6468: 4BE62A01  bl 0x82908e68
	ctx.lr = 0x82AA646C;
	sub_82908E68(ctx, base);
	// 82AA646C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6470: 4BDF1D29  bl 0x82898198
	ctx.lr = 0x82AA6474;
	sub_82898198(ctx, base);
	// 82AA6474: 4BFE644D  bl 0x82a8c8c0
	ctx.lr = 0x82AA6478;
	sub_82A8C8C0(ctx, base);
	// 82AA6478: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA647C: 4BFFCF75  bl 0x82aa33f0
	ctx.lr = 0x82AA6480;
	sub_82AA33F0(ctx, base);
	// 82AA6480: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA6484: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA6488: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA648C: 99410068  stb r10, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 82AA6490: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA6494: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6498: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AA649C: 4BFFDD6D  bl 0x82aa4208
	ctx.lr = 0x82AA64A0;
	sub_82AA4208(ctx, base);
	// 82AA64A0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA64A4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AA64A8: 808BC9E8  lwz r4, -0x3618(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13848 as u32) ) } as u64;
	// 82AA64AC: 4834D55D  bl 0x82df3a08
	ctx.lr = 0x82AA64B0;
	sub_82DF3A08(ctx, base);
	// 82AA64B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA64B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA64B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA64BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA64C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA64C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA64C8: 483B85C9  bl 0x82e5ea90
	ctx.lr = 0x82AA64CC;
	sub_82E5EA90(ctx, base);
	// 82AA64CC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AA64D0: 480001D0  b 0x82aa66a0
	pc = 0x82AA66A0; continue 'dispatch;
	// 82AA64D4: 807A0064  lwz r3, 0x64(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA64D8: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 82AA64DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA64E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA64E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA64E8: 4E800421  bctrl
	ctx.lr = 0x82AA64EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA64EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA64F0: 418200E4  beq 0x82aa65d4
	if ctx.cr[0].eq {
	pc = 0x82AA65D4; continue 'dispatch;
	}
	// 82AA64F4: 3BBE0038  addi r29, r30, 0x38
	ctx.r[29].s64 = ctx.r[30].s64 + 56;
	// 82AA64F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA64FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA6500: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA6504: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA6508: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AA650C: 48562AAD  bl 0x83008fb8
	ctx.lr = 0x82AA6510;
	sub_83008FB8(ctx, base);
	// 82AA6510: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82AA6514: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82AA6518: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA651C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA6520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA6524: 4B9017BD  bl 0x823a7ce0
	ctx.lr = 0x82AA6528;
	sub_823A7CE0(ctx, base);
	// 82AA6528: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82AA652C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82AA6530: 4BA68F99  bl 0x8250f4c8
	ctx.lr = 0x82AA6534;
	sub_8250F4C8(ctx, base);
	// 82AA6534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA653C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA6540: 409A0008  bne cr6, 0x82aa6548
	if !ctx.cr[6].eq {
	pc = 0x82AA6548; continue 'dispatch;
	}
	// 82AA6544: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA6548: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA654C: 4BA62135  bl 0x82508680
	ctx.lr = 0x82AA6550;
	sub_82508680(ctx, base);
	// 82AA6550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6554: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82AA6558: 4834B739  bl 0x82df1c90
	ctx.lr = 0x82AA655C;
	sub_82DF1C90(ctx, base);
	// 82AA655C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA6560: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA6564: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA6568: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82AA656C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AA6570: 419A0024  beq cr6, 0x82aa6594
	if ctx.cr[6].eq {
	pc = 0x82AA6594; continue 'dispatch;
	}
	// 82AA6574: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AA6578: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA657C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6580: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6584: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6588: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA658C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6590: 4082FFE8  bne 0x82aa6578
	if !ctx.cr[0].eq {
	pc = 0x82AA6578; continue 'dispatch;
	}
	// 82AA6594: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6598: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA659C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82AA65A0: 388B6950  addi r4, r11, 0x6950
	ctx.r[4].s64 = ctx.r[11].s64 + 26960;
	// 82AA65A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AA65A8: 38A00145  li r5, 0x145
	ctx.r[5].s64 = 325;
	// 82AA65AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA65B0: 483B2491  bl 0x82e58a40
	ctx.lr = 0x82AA65B4;
	sub_82E58A40(ctx, base);
	// 82AA65B4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA65B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA65BC: 419A0008  beq cr6, 0x82aa65c4
	if ctx.cr[6].eq {
	pc = 0x82AA65C4; continue 'dispatch;
	}
	// 82AA65C0: 4B81A2D1  bl 0x822c0890
	ctx.lr = 0x82AA65C4;
	sub_822C0890(ctx, base);
	// 82AA65C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AA65C8: 419A0348  beq cr6, 0x82aa6910
	if ctx.cr[6].eq {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA65CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA65D0: 480000D8  b 0x82aa66a8
	pc = 0x82AA66A8; continue 'dispatch;
	// 82AA65D4: 817A0070  lwz r11, 0x70(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA65D8: C01A0078  lfs f0, 0x78(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA65DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA65E0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA65E4: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82AA65E8: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA65EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA65F0: 4099000C  ble cr6, 0x82aa65fc
	if !ctx.cr[6].gt {
	pc = 0x82AA65FC; continue 'dispatch;
	}
	// 82AA65F4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82AA65F8: 48000010  b 0x82aa6608
	pc = 0x82AA6608; continue 'dispatch;
	// 82AA65FC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA6600: 40980008  bge cr6, 0x82aa6608
	if !ctx.cr[6].lt {
	pc = 0x82AA6608; continue 'dispatch;
	}
	// 82AA6604: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82AA6608: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA660C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AA6610: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82AA6614: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA6618: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA661C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AA6620: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA6624: 4BEA3C55  bl 0x8294a278
	ctx.lr = 0x82AA6628;
	sub_8294A278(ctx, base);
	// 82AA6628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA662C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82AA6630: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA6638: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82AA663C: 419A0024  beq cr6, 0x82aa6660
	if ctx.cr[6].eq {
	pc = 0x82AA6660; continue 'dispatch;
	}
	// 82AA6640: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA6644: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA6648: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA664C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6650: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6654: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA6658: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA665C: 4082FFE8  bne 0x82aa6644
	if !ctx.cr[0].eq {
	pc = 0x82AA6644; continue 'dispatch;
	}
	// 82AA6660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6664: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 82AA6668: 4BFDB099  bl 0x82a81700
	ctx.lr = 0x82AA666C;
	sub_82A81700(ctx, base);
	// 82AA666C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6670: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA6674: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA6678: 388B6950  addi r4, r11, 0x6950
	ctx.r[4].s64 = ctx.r[11].s64 + 26960;
	// 82AA667C: 38A0014C  li r5, 0x14c
	ctx.r[5].s64 = 332;
	// 82AA6680: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82AA6684: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA6688: 483B23B9  bl 0x82e58a40
	ctx.lr = 0x82AA668C;
	sub_82E58A40(ctx, base);
	// 82AA668C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA6690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6694: 419A0008  beq cr6, 0x82aa669c
	if ctx.cr[6].eq {
	pc = 0x82AA669C; continue 'dispatch;
	}
	// 82AA6698: 4B81A1F9  bl 0x822c0890
	ctx.lr = 0x82AA669C;
	sub_822C0890(ctx, base);
	// 82AA669C: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AA66A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA66A4: 419A026C  beq cr6, 0x82aa6910
	if ctx.cr[6].eq {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA66A8: 4B81A1E9  bl 0x822c0890
	ctx.lr = 0x82AA66AC;
	sub_822C0890(ctx, base);
	// 82AA66AC: 48000264  b 0x82aa6910
	pc = 0x82AA6910; continue 'dispatch;
	// 82AA66B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA66B4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA66B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA66BC: 40980254  bge cr6, 0x82aa6910
	if !ctx.cr[6].lt {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA66C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA66C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA66C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA66CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA66D0: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82AA66D4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA66D8: 4BFF7AB9  bl 0x82a9e190
	ctx.lr = 0x82AA66DC;
	sub_82A9E190(ctx, base);
	// 82AA66DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA66E0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AA66E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA66E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA66EC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AA66F0: 419A0024  beq cr6, 0x82aa6714
	if ctx.cr[6].eq {
	pc = 0x82AA6714; continue 'dispatch;
	}
	// 82AA66F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA66F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA66FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6700: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6704: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6708: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA670C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6710: 4082FFE8  bne 0x82aa66f8
	if !ctx.cr[0].eq {
	pc = 0x82AA66F8; continue 'dispatch;
	}
	// 82AA6714: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 82AA6718: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA671C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA6720: 4BA68DA9  bl 0x8250f4c8
	ctx.lr = 0x82AA6724;
	sub_8250F4C8(ctx, base);
	// 82AA6724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA672C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA6730: 409A0008  bne cr6, 0x82aa6738
	if !ctx.cr[6].eq {
	pc = 0x82AA6738; continue 'dispatch;
	}
	// 82AA6734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA6738: 3BBE0038  addi r29, r30, 0x38
	ctx.r[29].s64 = ctx.r[30].s64 + 56;
	// 82AA673C: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82AA6740: 4BA61ED9  bl 0x82508618
	ctx.lr = 0x82AA6744;
	sub_82508618(ctx, base);
	// 82AA6744: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6748: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA674C: 3B8B6950  addi r28, r11, 0x6950
	ctx.r[28].s64 = ctx.r[11].s64 + 26960;
	// 82AA6750: 38A0010C  li r5, 0x10c
	ctx.r[5].s64 = 268;
	// 82AA6754: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA6758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA675C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AA6760: 483B0889  bl 0x82e56fe8
	ctx.lr = 0x82AA6764;
	sub_82E56FE8(ctx, base);
	// 82AA6764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6768: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA676C: 4834B525  bl 0x82df1c90
	ctx.lr = 0x82AA6770;
	sub_82DF1C90(ctx, base);
	// 82AA6770: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA6774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6778: 419A0008  beq cr6, 0x82aa6780
	if ctx.cr[6].eq {
	pc = 0x82AA6780; continue 'dispatch;
	}
	// 82AA677C: 4B81A115  bl 0x822c0890
	ctx.lr = 0x82AA6780;
	sub_822C0890(ctx, base);
	// 82AA6780: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AA6784: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6788: 419A0008  beq cr6, 0x82aa6790
	if ctx.cr[6].eq {
	pc = 0x82AA6790; continue 'dispatch;
	}
	// 82AA678C: 4B81A105  bl 0x822c0890
	ctx.lr = 0x82AA6790;
	sub_822C0890(ctx, base);
	// 82AA6790: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA6794: 4182017C  beq 0x82aa6910
	if ctx.cr[0].eq {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA6798: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA679C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA67A0: 40820170  bne 0x82aa6910
	if !ctx.cr[0].eq {
	pc = 0x82AA6910; continue 'dispatch;
	}
	// 82AA67A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA67A8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AA67AC: 4BA68D1D  bl 0x8250f4c8
	ctx.lr = 0x82AA67B0;
	sub_8250F4C8(ctx, base);
	// 82AA67B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA67B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA67B8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA67BC: 409A0008  bne cr6, 0x82aa67c4
	if !ctx.cr[6].eq {
	pc = 0x82AA67C4; continue 'dispatch;
	}
	// 82AA67C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA67C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AA67C8: 4BA61EB9  bl 0x82508680
	ctx.lr = 0x82AA67CC;
	sub_82508680(ctx, base);
	// 82AA67CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA67D0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AA67D4: 4834B4BD  bl 0x82df1c90
	ctx.lr = 0x82AA67D8;
	sub_82DF1C90(ctx, base);
	// 82AA67D8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AA67DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA67E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA67E4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA67E8: 4B9187C9  bl 0x823befb0
	ctx.lr = 0x82AA67EC;
	sub_823BEFB0(ctx, base);
	// 82AA67EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA67F0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AA67F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA67F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA67FC: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AA6800: 419A0024  beq cr6, 0x82aa6824
	if ctx.cr[6].eq {
	pc = 0x82AA6824; continue 'dispatch;
	}
	// 82AA6804: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA6808: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA680C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6810: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6814: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6818: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA681C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6820: 4082FFE8  bne 0x82aa6808
	if !ctx.cr[0].eq {
	pc = 0x82AA6808; continue 'dispatch;
	}
	// 82AA6824: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA6828: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA682C: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 82AA6830: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AA6834: 38A00112  li r5, 0x112
	ctx.r[5].s64 = 274;
	// 82AA6838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA683C: 483B2205  bl 0x82e58a40
	ctx.lr = 0x82AA6840;
	sub_82E58A40(ctx, base);
	// 82AA6840: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA6844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6848: 419A0008  beq cr6, 0x82aa6850
	if ctx.cr[6].eq {
	pc = 0x82AA6850; continue 'dispatch;
	}
	// 82AA684C: 4B81A045  bl 0x822c0890
	ctx.lr = 0x82AA6850;
	sub_822C0890(ctx, base);
	// 82AA6850: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AA6854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6858: 419A0008  beq cr6, 0x82aa6860
	if ctx.cr[6].eq {
	pc = 0x82AA6860; continue 'dispatch;
	}
	// 82AA685C: 4B81A035  bl 0x822c0890
	ctx.lr = 0x82AA6860;
	sub_822C0890(ctx, base);
	// 82AA6860: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 82AA6864: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AA6868: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA686C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA6870: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AA6874: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AA6878: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA687C: 4BEA38FD  bl 0x8294a178
	ctx.lr = 0x82AA6880;
	sub_8294A178(ctx, base);
	// 82AA6880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6884: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA6888: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA688C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA6890: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA6894: 419A0024  beq cr6, 0x82aa68b8
	if ctx.cr[6].eq {
	pc = 0x82AA68B8; continue 'dispatch;
	}
	// 82AA6898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA689C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA68A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA68A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA68A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA68AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA68B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA68B4: 4082FFE8  bne 0x82aa689c
	if !ctx.cr[0].eq {
	pc = 0x82AA689C; continue 'dispatch;
	}
	// 82AA68B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA68BC: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82AA68C0: 4BFDAE41  bl 0x82a81700
	ctx.lr = 0x82AA68C4;
	sub_82A81700(ctx, base);
	// 82AA68C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA68C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA68CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA68D0: 38A00116  li r5, 0x116
	ctx.r[5].s64 = 278;
	// 82AA68D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA68D8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82AA68DC: 483B2165  bl 0x82e58a40
	ctx.lr = 0x82AA68E0;
	sub_82E58A40(ctx, base);
	// 82AA68E0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA68E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA68E8: 419A0008  beq cr6, 0x82aa68f0
	if ctx.cr[6].eq {
	pc = 0x82AA68F0; continue 'dispatch;
	}
	// 82AA68EC: 4B819FA5  bl 0x822c0890
	ctx.lr = 0x82AA68F0;
	sub_822C0890(ctx, base);
	// 82AA68F0: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AA68F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA68F8: 419A0008  beq cr6, 0x82aa6900
	if ctx.cr[6].eq {
	pc = 0x82AA6900; continue 'dispatch;
	}
	// 82AA68FC: 4B819F95  bl 0x822c0890
	ctx.lr = 0x82AA6900;
	sub_822C0890(ctx, base);
	// 82AA6900: 817A0070  lwz r11, 0x70(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA6904: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA6908: 93FA0074  stw r31, 0x74(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82AA690C: D01A0078  stfs f0, 0x78(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82AA6910: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82AA6914: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AA6918: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AA691C: 48701894  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA6920 size=24
    let mut pc: u32 = 0x82AA6920;
    'dispatch: loop {
        match pc {
            0x82AA6920 => {
    //   block [0x82AA6920..0x82AA6938)
	// 82AA6920: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6924: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AA6928: 98A30008  stb r5, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u8 ) };
	// 82AA692C: 396B6A10  addi r11, r11, 0x6a10
	ctx.r[11].s64 = ctx.r[11].s64 + 27152;
	// 82AA6930: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6938 size=196
    let mut pc: u32 = 0x82AA6938;
    'dispatch: loop {
        match pc {
            0x82AA6938 => {
    //   block [0x82AA6938..0x82AA69FC)
	// 82AA6938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA693C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA6944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA694C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA6950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA6954: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA6958: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA695C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6960: 4B819FD9  bl 0x822c0938
	ctx.lr = 0x82AA6964;
	sub_822C0938(ctx, base);
	// 82AA6964: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA6968: 41820028  beq 0x82aa6990
	if ctx.cr[0].eq {
	pc = 0x82AA6990; continue 'dispatch;
	}
	// 82AA696C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6970: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA6974: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA6978: 392B6A18  addi r9, r11, 0x6a18
	ctx.r[9].s64 = ctx.r[11].s64 + 27160;
	// 82AA697C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA6980: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA6984: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA6988: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA698C: 48000008  b 0x82aa6994
	pc = 0x82AA6994; continue 'dispatch;
	// 82AA6990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA6994: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA699C: 409A0044  bne cr6, 0x82aa69e0
	if !ctx.cr[6].eq {
	pc = 0x82AA69E0; continue 'dispatch;
	}
	// 82AA69A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA69A4: 419A001C  beq cr6, 0x82aa69c0
	if ctx.cr[6].eq {
	pc = 0x82AA69C0; continue 'dispatch;
	}
	// 82AA69A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA69AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA69B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA69B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA69B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA69BC: 4E800421  bctrl
	ctx.lr = 0x82AA69C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA69C0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA69C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA69C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA69CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA69D0: 816BCBA0  lwz r11, -0x3460(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13408 as u32) ) } as u64;
	// 82AA69D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA69D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA69DC: 4B819625  bl 0x822c0000
	ctx.lr = 0x82AA69E0;
	sub_822C0000(ctx, base);
	// 82AA69E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA69E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA69E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA69EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA69F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA69F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA69F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6A00 size=124
    let mut pc: u32 = 0x82AA6A00;
    'dispatch: loop {
        match pc {
            0x82AA6A00 => {
    //   block [0x82AA6A00..0x82AA6A7C)
	// 82AA6A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6A08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6A0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6A10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6A14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA6A18: 419A004C  beq cr6, 0x82aa6a64
	if ctx.cr[6].eq {
	pc = 0x82AA6A64; continue 'dispatch;
	}
	// 82AA6A1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6A24: 419A0018  beq cr6, 0x82aa6a3c
	if ctx.cr[6].eq {
	pc = 0x82AA6A3C; continue 'dispatch;
	}
	// 82AA6A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6A2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6A30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA6A34: 4E800421  bctrl
	ctx.lr = 0x82AA6A38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA6A38: 4800000C  b 0x82aa6a44
	pc = 0x82AA6A44; continue 'dispatch;
	// 82AA6A3C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA6A40: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA6A44: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA6A48: 388BCBAC  addi r4, r11, -0x3454
	ctx.r[4].s64 = ctx.r[11].s64 + -13396;
	// 82AA6A4C: 487016AD  bl 0x831a80f8
	ctx.lr = 0x82AA6A50;
	sub_831A80F8(ctx, base);
	// 82AA6A50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA6A54: 41820010  beq 0x82aa6a64
	if ctx.cr[0].eq {
	pc = 0x82AA6A64; continue 'dispatch;
	}
	// 82AA6A58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6A5C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AA6A60: 48000008  b 0x82aa6a68
	pc = 0x82AA6A68; continue 'dispatch;
	// 82AA6A64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA6A68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA6A6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6A70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6A74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA6A80 size=12
    let mut pc: u32 = 0x82AA6A80;
    'dispatch: loop {
        match pc {
            0x82AA6A80 => {
    //   block [0x82AA6A80..0x82AA6A8C)
	// 82AA6A80: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA6A84: 386BCBAC  addi r3, r11, -0x3454
	ctx.r[3].s64 = ctx.r[11].s64 + -13396;
	// 82AA6A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6A90 size=104
    let mut pc: u32 = 0x82AA6A90;
    'dispatch: loop {
        match pc {
            0x82AA6A90 => {
    //   block [0x82AA6A90..0x82AA6AF8)
	// 82AA6A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6A9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6AA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6AA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA6AA8: 4B819E91  bl 0x822c0938
	ctx.lr = 0x82AA6AAC;
	sub_822C0938(ctx, base);
	// 82AA6AAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA6AB0: 41820030  beq 0x82aa6ae0
	if ctx.cr[0].eq {
	pc = 0x82AA6AE0; continue 'dispatch;
	}
	// 82AA6AB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6AB8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA6ABC: 396B6A2C  addi r11, r11, 0x6a2c
	ctx.r[11].s64 = ctx.r[11].s64 + 27180;
	// 82AA6AC0: 394A6A10  addi r10, r10, 0x6a10
	ctx.r[10].s64 = ctx.r[10].s64 + 27152;
	// 82AA6AC4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6AC8: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA6ACC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA6AD0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA6AD4: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA6AD8: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82AA6ADC: 48000008  b 0x82aa6ae4
	pc = 0x82AA6AE4; continue 'dispatch;
	// 82AA6AE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA6AE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA6AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6AF8 size=120
    let mut pc: u32 = 0x82AA6AF8;
    'dispatch: loop {
        match pc {
            0x82AA6AF8 => {
    //   block [0x82AA6AF8..0x82AA6B70)
	// 82AA6AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6B00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6B04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6B08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6B0C: 4BFF338D  bl 0x82a99e98
	ctx.lr = 0x82AA6B10;
	sub_82A99E98(ctx, base);
	// 82AA6B10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6B14: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA6B18: 392B6A3C  addi r9, r11, 0x6a3c
	ctx.r[9].s64 = ctx.r[11].s64 + 27196;
	// 82AA6B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA6B20: 394A6A10  addi r10, r10, 0x6a10
	ctx.r[10].s64 = ctx.r[10].s64 + 27152;
	// 82AA6B24: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA6B28: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA6B2C: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA6B30: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA6B34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6B38: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82AA6B3C: 8089CA10  lwz r4, -0x35f0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13808 as u32) ) } as u64;
	// 82AA6B40: 4834CEC9  bl 0x82df3a08
	ctx.lr = 0x82AA6B44;
	sub_82DF3A08(ctx, base);
	// 82AA6B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6B48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA6B4C: 483B2B9D  bl 0x82e596e8
	ctx.lr = 0x82AA6B50;
	sub_82E596E8(ctx, base);
	// 82AA6B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6B54: 4834C8D5  bl 0x82df3428
	ctx.lr = 0x82AA6B58;
	sub_82DF3428(ctx, base);
	// 82AA6B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6B5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6B60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6B64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6B70 size=140
    let mut pc: u32 = 0x82AA6B70;
    'dispatch: loop {
        match pc {
            0x82AA6B70 => {
    //   block [0x82AA6B70..0x82AA6BFC)
	// 82AA6B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA6B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6B88: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA6B8C: 4BFFFE75  bl 0x82aa6a00
	ctx.lr = 0x82AA6B90;
	sub_82AA6A00(ctx, base);
	// 82AA6B90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA6B94: 40820030  bne 0x82aa6bc4
	if !ctx.cr[0].eq {
	pc = 0x82AA6BC4; continue 'dispatch;
	}
	// 82AA6B98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA6B9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA6BA0: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82AA6BA4: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82AA6BA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA6BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6BB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA6BB4: 4B81944D  bl 0x822c0000
	ctx.lr = 0x82AA6BB8;
	sub_822C0000(ctx, base);
	// 82AA6BB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA6BBC: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82AA6BC0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA6BC4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6BC8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA6BCC: 893E0008  lbz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA6BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6BD4: 394A6A10  addi r10, r10, 0x6a10
	ctx.r[10].s64 = ctx.r[10].s64 + 27152;
	// 82AA6BD8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA6BDC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA6BE0: 993F0008  stb r9, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82AA6BE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6BF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA6BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6C00 size=128
    let mut pc: u32 = 0x82AA6C00;
    'dispatch: loop {
        match pc {
            0x82AA6C00 => {
    //   block [0x82AA6C00..0x82AA6C80)
	// 82AA6C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA6C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6C14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA6C18: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA6C1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA6C20: 4B819D19  bl 0x822c0938
	ctx.lr = 0x82AA6C24;
	sub_822C0938(ctx, base);
	// 82AA6C24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA6C28: 41820034  beq 0x82aa6c5c
	if ctx.cr[0].eq {
	pc = 0x82AA6C5C; continue 'dispatch;
	}
	// 82AA6C2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6C30: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA6C34: 396B6A2C  addi r11, r11, 0x6a2c
	ctx.r[11].s64 = ctx.r[11].s64 + 27180;
	// 82AA6C38: 394A6A10  addi r10, r10, 0x6a10
	ctx.r[10].s64 = ctx.r[10].s64 + 27152;
	// 82AA6C3C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6C40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA6C44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA6C48: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6C4C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA6C50: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA6C54: 9943000C  stb r10, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 82AA6C58: 48000008  b 0x82aa6c60
	pc = 0x82AA6C60; continue 'dispatch;
	// 82AA6C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA6C60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6C64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6C68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6C6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6C70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6C74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA6C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6C80 size=68
    let mut pc: u32 = 0x82AA6C80;
    'dispatch: loop {
        match pc {
            0x82AA6C80 => {
    //   block [0x82AA6C80..0x82AA6CC4)
	// 82AA6C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6C88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6C8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6C94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA6C98: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA6C9C: 396BD82C  addi r11, r11, -0x27d4
	ctx.r[11].s64 = ctx.r[11].s64 + -10196;
	// 82AA6CA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6CA4: 41820008  beq 0x82aa6cac
	if ctx.cr[0].eq {
	pc = 0x82AA6CAC; continue 'dispatch;
	}
	// 82AA6CA8: 4B8195C1  bl 0x822c0268
	ctx.lr = 0x82AA6CAC;
	sub_822C0268(ctx, base);
	// 82AA6CAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6CB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA6CB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6CB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6CC8 size=112
    let mut pc: u32 = 0x82AA6CC8;
    'dispatch: loop {
        match pc {
            0x82AA6CC8 => {
    //   block [0x82AA6CC8..0x82AA6D38)
	// 82AA6CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6CCC: 487014A1  bl 0x831a816c
	ctx.lr = 0x82AA6CD0;
	sub_831A8130(ctx, base);
	// 82AA6CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6CD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6CD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA6CDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA6CE0: 388B6A68  addi r4, r11, 0x6a68
	ctx.r[4].s64 = ctx.r[11].s64 + 27240;
	// 82AA6CE4: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 82AA6CE8: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 82AA6CEC: 4834B6FD  bl 0x82df23e8
	ctx.lr = 0x82AA6CF0;
	sub_82DF23E8(ctx, base);
	// 82AA6CF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA6CF4: 41820010  beq 0x82aa6d04
	if ctx.cr[0].eq {
	pc = 0x82AA6D04; continue 'dispatch;
	}
	// 82AA6CF8: 4BFFFE01  bl 0x82aa6af8
	ctx.lr = 0x82AA6CFC;
	sub_82AA6AF8(ctx, base);
	// 82AA6CFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6D00: 48000008  b 0x82aa6d08
	pc = 0x82AA6D08; continue 'dispatch;
	// 82AA6D04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA6D08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA6D0C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA6D10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA6D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6D18: 4BFFFC21  bl 0x82aa6938
	ctx.lr = 0x82AA6D1C;
	sub_82AA6938(ctx, base);
	// 82AA6D1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA6D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA6D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA6D28: 4B8192D9  bl 0x822c0000
	ctx.lr = 0x82AA6D2C;
	sub_822C0000(ctx, base);
	// 82AA6D2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA6D30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6D34: 48701488  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6D38 size=100
    let mut pc: u32 = 0x82AA6D38;
    'dispatch: loop {
        match pc {
            0x82AA6D38 => {
    //   block [0x82AA6D38..0x82AA6D9C)
	// 82AA6D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6D3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6D40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6D44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6D50: 4BFFFEB1  bl 0x82aa6c00
	ctx.lr = 0x82AA6D54;
	sub_82AA6C00(ctx, base);
	// 82AA6D54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6D58: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6D5C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA6D60: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA6D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6D68: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA6D6C: 419A0018  beq cr6, 0x82aa6d84
	if ctx.cr[6].eq {
	pc = 0x82AA6D84; continue 'dispatch;
	}
	// 82AA6D70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6D74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA6D78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6D7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA6D80: 4E800421  bctrl
	ctx.lr = 0x82AA6D84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA6D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA6D88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6D8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6D90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6D94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA6DA0 size=372
    let mut pc: u32 = 0x82AA6DA0;
    'dispatch: loop {
        match pc {
            0x82AA6DA0 => {
    //   block [0x82AA6DA0..0x82AA6F14)
	// 82AA6DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6DA4: 487013C9  bl 0x831a816c
	ctx.lr = 0x82AA6DA8;
	sub_831A8130(ctx, base);
	// 82AA6DA8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA6DAC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA6DB0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6DB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6DBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA6DC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA6DC4: 388B6B28  addi r4, r11, 0x6b28
	ctx.r[4].s64 = ctx.r[11].s64 + 27432;
	// 82AA6DC8: 4834CC41  bl 0x82df3a08
	ctx.lr = 0x82AA6DCC;
	sub_82DF3A08(ctx, base);
	// 82AA6DCC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6DD0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA6DD4: 388B6B18  addi r4, r11, 0x6b18
	ctx.r[4].s64 = ctx.r[11].s64 + 27416;
	// 82AA6DD8: 4834CC31  bl 0x82df3a08
	ctx.lr = 0x82AA6DDC;
	sub_82DF3A08(ctx, base);
	// 82AA6DDC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA6DE0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AA6DE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6DE8: 4BB23719  bl 0x825ca500
	ctx.lr = 0x82AA6DEC;
	sub_825CA500(ctx, base);
	// 82AA6DEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA6DF0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA6DF4: 4834C635  bl 0x82df3428
	ctx.lr = 0x82AA6DF8;
	sub_82DF3428(ctx, base);
	// 82AA6DF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA6DFC: 4834C62D  bl 0x82df3428
	ctx.lr = 0x82AA6E00;
	sub_82DF3428(ctx, base);
	// 82AA6E00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6E04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA6E08: 388B6B00  addi r4, r11, 0x6b00
	ctx.r[4].s64 = ctx.r[11].s64 + 27392;
	// 82AA6E0C: 4834CBFD  bl 0x82df3a08
	ctx.lr = 0x82AA6E10;
	sub_82DF3A08(ctx, base);
	// 82AA6E10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6E18: 388B6AEC  addi r4, r11, 0x6aec
	ctx.r[4].s64 = ctx.r[11].s64 + 27372;
	// 82AA6E1C: 4834CBED  bl 0x82df3a08
	ctx.lr = 0x82AA6E20;
	sub_82DF3A08(ctx, base);
	// 82AA6E20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA6E24: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA6E28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA6E2C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA6E30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA6E34: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA6E38: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA6E3C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA6E40: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA6E44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA6E48: 4BAFC461  bl 0x825a32a8
	ctx.lr = 0x82AA6E4C;
	sub_825A32A8(ctx, base);
	// 82AA6E4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA6E50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA6E54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA6E58: 4BAFA919  bl 0x825a1770
	ctx.lr = 0x82AA6E5C;
	sub_825A1770(ctx, base);
	// 82AA6E5C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA6E60: 4834C5C9  bl 0x82df3428
	ctx.lr = 0x82AA6E64;
	sub_82DF3428(ctx, base);
	// 82AA6E64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA6E68: 4B821E51  bl 0x822c8cb8
	ctx.lr = 0x82AA6E6C;
	sub_822C8CB8(ctx, base);
	// 82AA6E6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6E70: 4834C5B9  bl 0x82df3428
	ctx.lr = 0x82AA6E74;
	sub_82DF3428(ctx, base);
	// 82AA6E74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA6E78: 4834C5B1  bl 0x82df3428
	ctx.lr = 0x82AA6E7C;
	sub_82DF3428(ctx, base);
	// 82AA6E7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6E84: 388B6AD0  addi r4, r11, 0x6ad0
	ctx.r[4].s64 = ctx.r[11].s64 + 27344;
	// 82AA6E88: 4834CB81  bl 0x82df3a08
	ctx.lr = 0x82AA6E8C;
	sub_82DF3A08(ctx, base);
	// 82AA6E8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA6E90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA6E94: 388B6AC4  addi r4, r11, 0x6ac4
	ctx.r[4].s64 = ctx.r[11].s64 + 27332;
	// 82AA6E98: 4834CB71  bl 0x82df3a08
	ctx.lr = 0x82AA6E9C;
	sub_82DF3A08(ctx, base);
	// 82AA6E9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA6EA0: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA6EA4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA6EA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA6EAC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA6EB0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA6EB4: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AA6EB8: 4BAFC3F1  bl 0x825a32a8
	ctx.lr = 0x82AA6EBC;
	sub_825A32A8(ctx, base);
	// 82AA6EBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA6EC0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA6EC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA6EC8: 4BAFA8A9  bl 0x825a1770
	ctx.lr = 0x82AA6ECC;
	sub_825A1770(ctx, base);
	// 82AA6ECC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA6ED0: 4834C559  bl 0x82df3428
	ctx.lr = 0x82AA6ED4;
	sub_82DF3428(ctx, base);
	// 82AA6ED4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA6ED8: 4B821DE1  bl 0x822c8cb8
	ctx.lr = 0x82AA6EDC;
	sub_822C8CB8(ctx, base);
	// 82AA6EDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA6EE0: 4834C549  bl 0x82df3428
	ctx.lr = 0x82AA6EE4;
	sub_82DF3428(ctx, base);
	// 82AA6EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA6EE8: 4834C541  bl 0x82df3428
	ctx.lr = 0x82AA6EEC;
	sub_82DF3428(ctx, base);
	// 82AA6EEC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6EF0: 4BB22DE1  bl 0x825c9cd0
	ctx.lr = 0x82AA6EF4;
	sub_825C9CD0(ctx, base);
	// 82AA6EF4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6EF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6EFC: 419A0008  beq cr6, 0x82aa6f04
	if ctx.cr[6].eq {
	pc = 0x82AA6F04; continue 'dispatch;
	}
	// 82AA6F00: 4B819991  bl 0x822c0890
	ctx.lr = 0x82AA6F04;
	sub_822C0890(ctx, base);
	// 82AA6F04: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82AA6F08: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA6F0C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA6F10: 487012AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA6F18 size=128
    let mut pc: u32 = 0x82AA6F18;
    'dispatch: loop {
        match pc {
            0x82AA6F18 => {
    //   block [0x82AA6F18..0x82AA6F98)
	// 82AA6F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA6F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA6F24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6F28: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA6F2C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA6F30: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA6F38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA6F3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA6F40: 419A0024  beq cr6, 0x82aa6f64
	if ctx.cr[6].eq {
	pc = 0x82AA6F64; continue 'dispatch;
	}
	// 82AA6F44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA6F48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA6F4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6F50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA6F54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA6F58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA6F5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA6F60: 4082FFE8  bne 0x82aa6f48
	if !ctx.cr[0].eq {
	pc = 0x82AA6F48; continue 'dispatch;
	}
	// 82AA6F64: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA6F68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA6F6C: 386BCBA4  addi r3, r11, -0x345c
	ctx.r[3].s64 = ctx.r[11].s64 + -13404;
	// 82AA6F70: 4BFFFE31  bl 0x82aa6da0
	ctx.lr = 0x82AA6F74;
	sub_82AA6DA0(ctx, base);
	// 82AA6F74: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA6F7C: 419A0008  beq cr6, 0x82aa6f84
	if ctx.cr[6].eq {
	pc = 0x82AA6F84; continue 'dispatch;
	}
	// 82AA6F80: 4B819911  bl 0x822c0890
	ctx.lr = 0x82AA6F84;
	sub_822C0890(ctx, base);
	// 82AA6F84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA6F88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA6F8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA6F90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA6F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA6F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA6F98 size=448
    let mut pc: u32 = 0x82AA6F98;
    'dispatch: loop {
        match pc {
            0x82AA6F98 => {
    //   block [0x82AA6F98..0x82AA7158)
	// 82AA6F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA6F9C: 487011C9  bl 0x831a8164
	ctx.lr = 0x82AA6FA0;
	sub_831A8130(ctx, base);
	// 82AA6FA0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AA6FA4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA6FA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA6FAC: 486AD655  bl 0x83154600
	ctx.lr = 0x82AA6FB0;
	sub_83154600(ctx, base);
	// 82AA6FB0: 4BE11D39  bl 0x828b8ce8
	ctx.lr = 0x82AA6FB4;
	sub_828B8CE8(ctx, base);
	// 82AA6FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA6FB8: 4BDF11E1  bl 0x82898198
	ctx.lr = 0x82AA6FBC;
	sub_82898198(ctx, base);
	// 82AA6FBC: 817C0064  lwz r11, 0x64(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA6FC0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA6FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA6FC8: 409A0170  bne cr6, 0x82aa7138
	if !ctx.cr[6].eq {
	pc = 0x82AA7138; continue 'dispatch;
	}
	// 82AA6FCC: 897C0068  lbz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA6FD0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA6FD4: 41820164  beq 0x82aa7138
	if ctx.cr[0].eq {
	pc = 0x82AA7138; continue 'dispatch;
	}
	// 82AA6FD8: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82AA6FDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA6FE0: 4BA684E9  bl 0x8250f4c8
	ctx.lr = 0x82AA6FE4;
	sub_8250F4C8(ctx, base);
	// 82AA6FE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA6FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA6FEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA6FF0: 409A0008  bne cr6, 0x82aa6ff8
	if !ctx.cr[6].eq {
	pc = 0x82AA6FF8; continue 'dispatch;
	}
	// 82AA6FF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA6FF8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AA6FFC: 4BA61685  bl 0x82508680
	ctx.lr = 0x82AA7000;
	sub_82508680(ctx, base);
	// 82AA7000: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA7004: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA7008: 4834AC89  bl 0x82df1c90
	ctx.lr = 0x82AA700C;
	sub_82DF1C90(ctx, base);
	// 82AA700C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA7010: 4BDCF719  bl 0x82876728
	ctx.lr = 0x82AA7014;
	sub_82876728(ctx, base);
	// 82AA7014: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7018: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA701C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA7024: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA7028: 419A0024  beq cr6, 0x82aa704c
	if ctx.cr[6].eq {
	pc = 0x82AA704C; continue 'dispatch;
	}
	// 82AA702C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA7030: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA7034: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA7038: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA703C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA7040: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA7044: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA7048: 4082FFE8  bne 0x82aa7030
	if !ctx.cr[0].eq {
	pc = 0x82AA7030; continue 'dispatch;
	}
	// 82AA704C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7050: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA7054: 3BCB6A68  addi r30, r11, 0x6a68
	ctx.r[30].s64 = ctx.r[11].s64 + 27240;
	// 82AA7058: 3BFF0038  addi r31, r31, 0x38
	ctx.r[31].s64 = ctx.r[31].s64 + 56;
	// 82AA705C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AA7060: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA7064: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA7068: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA706C: 38A00132  li r5, 0x132
	ctx.r[5].s64 = 306;
	// 82AA7070: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA7074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7078: 483B19C9  bl 0x82e58a40
	ctx.lr = 0x82AA707C;
	sub_82E58A40(ctx, base);
	// 82AA707C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AA7080: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7084: 419A0008  beq cr6, 0x82aa708c
	if ctx.cr[6].eq {
	pc = 0x82AA708C; continue 'dispatch;
	}
	// 82AA7088: 4B819809  bl 0x822c0890
	ctx.lr = 0x82AA708C;
	sub_822C0890(ctx, base);
	// 82AA708C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA7090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7094: 419A0008  beq cr6, 0x82aa709c
	if ctx.cr[6].eq {
	pc = 0x82AA709C; continue 'dispatch;
	}
	// 82AA7098: 4B8197F9  bl 0x822c0890
	ctx.lr = 0x82AA709C;
	sub_822C0890(ctx, base);
	// 82AA709C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA70A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA70A4: 388BCA2C  addi r4, r11, -0x35d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13780;
	// 82AA70A8: 4BF30849  bl 0x829d78f0
	ctx.lr = 0x82AA70AC;
	sub_829D78F0(ctx, base);
	// 82AA70AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA70B0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AA70B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA70B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA70BC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AA70C0: 419A0024  beq cr6, 0x82aa70e4
	if ctx.cr[6].eq {
	pc = 0x82AA70E4; continue 'dispatch;
	}
	// 82AA70C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA70C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA70CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA70D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA70D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA70D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA70DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA70E0: 4082FFE8  bne 0x82aa70c8
	if !ctx.cr[0].eq {
	pc = 0x82AA70C8; continue 'dispatch;
	}
	// 82AA70E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA70E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA70EC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82AA70F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA70F4: 38A00135  li r5, 0x135
	ctx.r[5].s64 = 309;
	// 82AA70F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA70FC: 483B1945  bl 0x82e58a40
	ctx.lr = 0x82AA7100;
	sub_82E58A40(ctx, base);
	// 82AA7100: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA7104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7108: 419A0008  beq cr6, 0x82aa7110
	if ctx.cr[6].eq {
	pc = 0x82AA7110; continue 'dispatch;
	}
	// 82AA710C: 4B819785  bl 0x822c0890
	ctx.lr = 0x82AA7110;
	sub_822C0890(ctx, base);
	// 82AA7110: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA7114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7118: 419A0008  beq cr6, 0x82aa7120
	if ctx.cr[6].eq {
	pc = 0x82AA7120; continue 'dispatch;
	}
	// 82AA711C: 4B819775  bl 0x822c0890
	ctx.lr = 0x82AA7120;
	sub_822C0890(ctx, base);
	// 82AA7120: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AA7124: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA7128: 4BFE41C9  bl 0x82a8b2f0
	ctx.lr = 0x82AA712C;
	sub_82A8B2F0(ctx, base);
	// 82AA712C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA7130: 4BFE5721  bl 0x82a8c850
	ctx.lr = 0x82AA7134;
	sub_82A8C850(ctx, base);
	// 82AA7134: 4800000C  b 0x82aa7140
	pc = 0x82AA7140; continue 'dispatch;
	// 82AA7138: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA713C: 4BFE5785  bl 0x82a8c8c0
	ctx.lr = 0x82AA7140;
	sub_82A8C8C0(ctx, base);
	// 82AA7140: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA7144: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA7148: 4BFE5351  bl 0x82a8c498
	ctx.lr = 0x82AA714C;
	sub_82A8C498(ctx, base);
	// 82AA714C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AA7150: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AA7154: 48701060  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7158 size=192
    let mut pc: u32 = 0x82AA7158;
    'dispatch: loop {
        match pc {
            0x82AA7158 => {
    //   block [0x82AA7158..0x82AA7218)
	// 82AA7158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA715C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA7164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7168: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA716C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7170: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA7174: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AA7178: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82AA717C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7180: 4B9EB189  bl 0x82492308
	ctx.lr = 0x82AA7184;
	sub_82492308(ctx, base);
	// 82AA7184: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA7188: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AA718C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA7190: 419A006C  beq cr6, 0x82aa71fc
	if ctx.cr[6].eq {
	pc = 0x82AA71FC; continue 'dispatch;
	}
	// 82AA7194: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA7198: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82AA719C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA71A0: 419A0018  beq cr6, 0x82aa71b8
	if ctx.cr[6].eq {
	pc = 0x82AA71B8; continue 'dispatch;
	}
	// 82AA71A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA71A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA71AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA71B0: 4E800421  bctrl
	ctx.lr = 0x82AA71B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA71B4: 4800000C  b 0x82aa71c0
	pc = 0x82AA71C0; continue 'dispatch;
	// 82AA71B8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA71BC: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA71C0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA71C4: 388BCBAC  addi r4, r11, -0x3454
	ctx.r[4].s64 = ctx.r[11].s64 + -13396;
	// 82AA71C8: 48700F31  bl 0x831a80f8
	ctx.lr = 0x82AA71CC;
	sub_831A80F8(ctx, base);
	// 82AA71CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA71D0: 4182002C  beq 0x82aa71fc
	if ctx.cr[0].eq {
	pc = 0x82AA71FC; continue 'dispatch;
	}
	// 82AA71D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA71D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA71DC: 4BFFF995  bl 0x82aa6b70
	ctx.lr = 0x82AA71E0;
	sub_82AA6B70(ctx, base);
	// 82AA71E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA71E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA71E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA71EC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA71F0: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA71F4: 997E0008  stb r11, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82AA71F8: 48000008  b 0x82aa7200
	pc = 0x82AA7200; continue 'dispatch;
	// 82AA71FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA7200: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA7204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA720C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7218 size=1544
    let mut pc: u32 = 0x82AA7218;
    'dispatch: loop {
        match pc {
            0x82AA7218 => {
    //   block [0x82AA7218..0x82AA7820)
	// 82AA7218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA721C: 48700F3D  bl 0x831a8158
	ctx.lr = 0x82AA7220;
	sub_831A8130(ctx, base);
	// 82AA7220: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82AA7224: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82AA7228: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA722C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7230: 486AD3D1  bl 0x83154600
	ctx.lr = 0x82AA7234;
	sub_83154600(ctx, base);
	// 82AA7234: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA7238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA723C: 486AD3C5  bl 0x83154600
	ctx.lr = 0x82AA7240;
	sub_83154600(ctx, base);
	// 82AA7240: 4BE11AA9  bl 0x828b8ce8
	ctx.lr = 0x82AA7244;
	sub_828B8CE8(ctx, base);
	// 82AA7244: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7248: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AA724C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7250: 808BCB9C  lwz r4, -0x3464(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13412 as u32) ) } as u64;
	// 82AA7254: 4834C7B5  bl 0x82df3a08
	ctx.lr = 0x82AA7258;
	sub_82DF3A08(ctx, base);
	// 82AA7258: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 82AA725C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7264: 4BFFFEF5  bl 0x82aa7158
	ctx.lr = 0x82AA7268;
	sub_82AA7158(ctx, base);
	// 82AA7268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA726C: 4834C1BD  bl 0x82df3428
	ctx.lr = 0x82AA7270;
	sub_82DF3428(ctx, base);
	// 82AA7270: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7274: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA7278: 4BFE1419  bl 0x82a88690
	ctx.lr = 0x82AA727C;
	sub_82A88690(ctx, base);
	// 82AA727C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7284: 808BCA1C  lwz r4, -0x35e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13796 as u32) ) } as u64;
	// 82AA7288: 4834C781  bl 0x82df3a08
	ctx.lr = 0x82AA728C;
	sub_82DF3A08(ctx, base);
	// 82AA728C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7290: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7294: 4BD484DD  bl 0x827ef770
	ctx.lr = 0x82AA7298;
	sub_827EF770(ctx, base);
	// 82AA7298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA729C: 4834C18D  bl 0x82df3428
	ctx.lr = 0x82AA72A0;
	sub_82DF3428(ctx, base);
	// 82AA72A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA72A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA72A8: 4BFDD6C1  bl 0x82a84968
	ctx.lr = 0x82AA72AC;
	sub_82A84968(ctx, base);
	// 82AA72AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA72B0: 4BE58741  bl 0x828ff9f0
	ctx.lr = 0x82AA72B4;
	sub_828FF9F0(ctx, base);
	// 82AA72B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA72B8: 4BFDA359  bl 0x82a81610
	ctx.lr = 0x82AA72BC;
	sub_82A81610(ctx, base);
	// 82AA72BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA72C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA72C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA72C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA72CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA72D0: 4E800421  bctrl
	ctx.lr = 0x82AA72D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA72D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA72D8: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 82AA72DC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82AA72E0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA72E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AA72E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA72EC: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7820 size=232
    let mut pc: u32 = 0x82AA7820;
    'dispatch: loop {
        match pc {
            0x82AA7820 => {
    //   block [0x82AA7820..0x82AA7908)
	// 82AA7820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7824: 48700949  bl 0x831a816c
	ctx.lr = 0x82AA7828;
	sub_831A8130(ctx, base);
	// 82AA7828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA782C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7830: 486ACDD1  bl 0x83154600
	ctx.lr = 0x82AA7834;
	sub_83154600(ctx, base);
	// 82AA7834: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA783C: 486ACDC5  bl 0x83154600
	ctx.lr = 0x82AA7840;
	sub_83154600(ctx, base);
	// 82AA7840: 4BE114A9  bl 0x828b8ce8
	ctx.lr = 0x82AA7844;
	sub_828B8CE8(ctx, base);
	// 82AA7844: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA7848: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA784C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA7850: 41980088  blt cr6, 0x82aa78d8
	if ctx.cr[6].lt {
	pc = 0x82AA78D8; continue 'dispatch;
	}
	// 82AA7854: 419A0034  beq cr6, 0x82aa7888
	if ctx.cr[6].eq {
	pc = 0x82AA7888; continue 'dispatch;
	}
	// 82AA7858: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AA785C: 409800A4  bge cr6, 0x82aa7900
	if !ctx.cr[6].lt {
	pc = 0x82AA7900; continue 'dispatch;
	}
	// 82AA7860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7864: 483B1F15  bl 0x82e59778
	ctx.lr = 0x82AA7868;
	sub_82E59778(ctx, base);
	// 82AA7868: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA786C: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA7870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA7874: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA7878: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA787C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA7880: 41990080  bgt cr6, 0x82aa7900
	if ctx.cr[6].gt {
	pc = 0x82AA7900; continue 'dispatch;
	}
	// 82AA7884: 48000074  b 0x82aa78f8
	pc = 0x82AA78F8; continue 'dispatch;
	// 82AA7888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA788C: 4BE58165  bl 0x828ff9f0
	ctx.lr = 0x82AA7890;
	sub_828FF9F0(ctx, base);
	// 82AA7890: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7894: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 82AA7898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA789C: 4BE61DBD  bl 0x82909658
	ctx.lr = 0x82AA78A0;
	sub_82909658(ctx, base);
	// 82AA78A0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA78A4: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA78A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AA78AC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AA78B0: C00B6150  lfs f0, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA78B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA78B8: 40980048  bge cr6, 0x82aa7900
	if !ctx.cr[6].lt {
	pc = 0x82AA7900; continue 'dispatch;
	}
	// 82AA78BC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA78C0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82AA78C4: 396BCBA4  addi r11, r11, -0x345c
	ctx.r[11].s64 = ctx.r[11].s64 + -13404;
	// 82AA78C8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA78CC: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82AA78D0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AA78D4: 4800002C  b 0x82aa7900
	pc = 0x82AA7900; continue 'dispatch;
	// 82AA78D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA78DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA78E0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA78E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA78E8: 4E800421  bctrl
	ctx.lr = 0x82AA78EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA78EC: 4BD42A25  bl 0x827ea310
	ctx.lr = 0x82AA78F0;
	sub_827EA310(ctx, base);
	// 82AA78F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA78F4: 4182000C  beq 0x82aa7900
	if ctx.cr[0].eq {
	pc = 0x82AA7900; continue 'dispatch;
	}
	// 82AA78F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA78FC: 4BFFF69D  bl 0x82aa6f98
	ctx.lr = 0x82AA7900;
	sub_82AA6F98(ctx, base);
	// 82AA7900: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA7904: 487008B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7908 size=96
    let mut pc: u32 = 0x82AA7908;
    'dispatch: loop {
        match pc {
            0x82AA7908 => {
    //   block [0x82AA7908..0x82AA7968)
	// 82AA7908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA790C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA7914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA791C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7920: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA792C: 808BCB9C  lwz r4, -0x3464(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13412 as u32) ) } as u64;
	// 82AA7930: 4834C0D9  bl 0x82df3a08
	ctx.lr = 0x82AA7934;
	sub_82DF3A08(ctx, base);
	// 82AA7934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7938: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA793C: 4B884F05  bl 0x8232c840
	ctx.lr = 0x82AA7940;
	sub_8232C840(ctx, base);
	// 82AA7940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA7944: 4BFFF3F5  bl 0x82aa6d38
	ctx.lr = 0x82AA7948;
	sub_82AA6D38(ctx, base);
	// 82AA7948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA794C: 4834BADD  bl 0x82df3428
	ctx.lr = 0x82AA7950;
	sub_82DF3428(ctx, base);
	// 82AA7950: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA795C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA7968 size=24
    let mut pc: u32 = 0x82AA7968;
    'dispatch: loop {
        match pc {
            0x82AA7968 => {
    //   block [0x82AA7968..0x82AA7980)
	// 82AA7968: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA796C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AA7970: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82AA7974: 396B6B7C  addi r11, r11, 0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + 27516;
	// 82AA7978: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA797C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7980 size=196
    let mut pc: u32 = 0x82AA7980;
    'dispatch: loop {
        match pc {
            0x82AA7980 => {
    //   block [0x82AA7980..0x82AA7A44)
	// 82AA7980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA798C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7994: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA799C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA79A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA79A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA79A8: 4B818F91  bl 0x822c0938
	ctx.lr = 0x82AA79AC;
	sub_822C0938(ctx, base);
	// 82AA79AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA79B0: 41820028  beq 0x82aa79d8
	if ctx.cr[0].eq {
	pc = 0x82AA79D8; continue 'dispatch;
	}
	// 82AA79B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA79B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA79BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA79C0: 392B6B84  addi r9, r11, 0x6b84
	ctx.r[9].s64 = ctx.r[11].s64 + 27524;
	// 82AA79C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA79C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA79CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA79D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA79D4: 48000008  b 0x82aa79dc
	pc = 0x82AA79DC; continue 'dispatch;
	// 82AA79D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA79DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA79E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA79E4: 409A0044  bne cr6, 0x82aa7a28
	if !ctx.cr[6].eq {
	pc = 0x82AA7A28; continue 'dispatch;
	}
	// 82AA79E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA79EC: 419A001C  beq cr6, 0x82aa7a08
	if ctx.cr[6].eq {
	pc = 0x82AA7A08; continue 'dispatch;
	}
	// 82AA79F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA79F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA79F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA79FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7A00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA7A04: 4E800421  bctrl
	ctx.lr = 0x82AA7A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA7A08: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7A0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA7A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7A14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA7A18: 816BCCCC  lwz r11, -0x3334(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13108 as u32) ) } as u64;
	// 82AA7A1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA7A20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA7A24: 4B8185DD  bl 0x822c0000
	ctx.lr = 0x82AA7A28;
	sub_822C0000(ctx, base);
	// 82AA7A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA7A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7A48 size=124
    let mut pc: u32 = 0x82AA7A48;
    'dispatch: loop {
        match pc {
            0x82AA7A48 => {
    //   block [0x82AA7A48..0x82AA7AC4)
	// 82AA7A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7A50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7A54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA7A60: 419A004C  beq cr6, 0x82aa7aac
	if ctx.cr[6].eq {
	pc = 0x82AA7AAC; continue 'dispatch;
	}
	// 82AA7A64: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7A6C: 419A0018  beq cr6, 0x82aa7a84
	if ctx.cr[6].eq {
	pc = 0x82AA7A84; continue 'dispatch;
	}
	// 82AA7A70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7A74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA7A7C: 4E800421  bctrl
	ctx.lr = 0x82AA7A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA7A80: 4800000C  b 0x82aa7a8c
	pc = 0x82AA7A8C; continue 'dispatch;
	// 82AA7A84: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA7A88: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA7A8C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7A90: 388BCCE0  addi r4, r11, -0x3320
	ctx.r[4].s64 = ctx.r[11].s64 + -13088;
	// 82AA7A94: 48700665  bl 0x831a80f8
	ctx.lr = 0x82AA7A98;
	sub_831A80F8(ctx, base);
	// 82AA7A98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA7A9C: 41820010  beq 0x82aa7aac
	if ctx.cr[0].eq {
	pc = 0x82AA7AAC; continue 'dispatch;
	}
	// 82AA7AA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7AA4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AA7AA8: 48000008  b 0x82aa7ab0
	pc = 0x82AA7AB0; continue 'dispatch;
	// 82AA7AAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA7AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA7AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AA7AC8 size=12
    let mut pc: u32 = 0x82AA7AC8;
    'dispatch: loop {
        match pc {
            0x82AA7AC8 => {
    //   block [0x82AA7AC8..0x82AA7AD4)
	// 82AA7AC8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA7ACC: 386BCCE0  addi r3, r11, -0x3320
	ctx.r[3].s64 = ctx.r[11].s64 + -13088;
	// 82AA7AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7AD8 size=104
    let mut pc: u32 = 0x82AA7AD8;
    'dispatch: loop {
        match pc {
            0x82AA7AD8 => {
    //   block [0x82AA7AD8..0x82AA7B40)
	// 82AA7AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7AE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7AEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA7AF0: 4B818E49  bl 0x822c0938
	ctx.lr = 0x82AA7AF4;
	sub_822C0938(ctx, base);
	// 82AA7AF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA7AF8: 41820030  beq 0x82aa7b28
	if ctx.cr[0].eq {
	pc = 0x82AA7B28; continue 'dispatch;
	}
	// 82AA7AFC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7B00: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA7B04: 396B6B98  addi r11, r11, 0x6b98
	ctx.r[11].s64 = ctx.r[11].s64 + 27544;
	// 82AA7B08: 394A6B7C  addi r10, r10, 0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + 27516;
	// 82AA7B0C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7B10: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA7B14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA7B18: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA7B1C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA7B20: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82AA7B24: 48000008  b 0x82aa7b2c
	pc = 0x82AA7B2C; continue 'dispatch;
	// 82AA7B28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA7B2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA7B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7B40 size=124
    let mut pc: u32 = 0x82AA7B40;
    'dispatch: loop {
        match pc {
            0x82AA7B40 => {
    //   block [0x82AA7B40..0x82AA7BBC)
	// 82AA7B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7B4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7B54: 4BFF2345  bl 0x82a99e98
	ctx.lr = 0x82AA7B58;
	sub_82A99E98(ctx, base);
	// 82AA7B58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7B5C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA7B60: 396B6BA8  addi r11, r11, 0x6ba8
	ctx.r[11].s64 = ctx.r[11].s64 + 27560;
	// 82AA7B64: 394A6B7C  addi r10, r10, 0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + 27516;
	// 82AA7B68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7B6C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82AA7B70: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82AA7B74: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA7B78: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82AA7B7C: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AA7B80: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA7B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7B88: 808ACA04  lwz r4, -0x35fc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13820 as u32) ) } as u64;
	// 82AA7B8C: 4834BE7D  bl 0x82df3a08
	ctx.lr = 0x82AA7B90;
	sub_82DF3A08(ctx, base);
	// 82AA7B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7B94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7B98: 483B1B51  bl 0x82e596e8
	ctx.lr = 0x82AA7B9C;
	sub_82E596E8(ctx, base);
	// 82AA7B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7BA0: 4834B889  bl 0x82df3428
	ctx.lr = 0x82AA7BA4;
	sub_82DF3428(ctx, base);
	// 82AA7BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7BA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7BB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7BC0 size=140
    let mut pc: u32 = 0x82AA7BC0;
    'dispatch: loop {
        match pc {
            0x82AA7BC0 => {
    //   block [0x82AA7BC0..0x82AA7C4C)
	// 82AA7BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7BC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA7BCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7BD8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AA7BDC: 4BFFFE6D  bl 0x82aa7a48
	ctx.lr = 0x82AA7BE0;
	sub_82AA7A48(ctx, base);
	// 82AA7BE0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA7BE4: 40820030  bne 0x82aa7c14
	if !ctx.cr[0].eq {
	pc = 0x82AA7C14; continue 'dispatch;
	}
	// 82AA7BE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA7BEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA7BF0: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82AA7BF4: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82AA7BF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA7BFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7C00: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA7C04: 4B8183FD  bl 0x822c0000
	ctx.lr = 0x82AA7C08;
	sub_822C0000(ctx, base);
	// 82AA7C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA7C0C: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82AA7C10: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AA7C14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7C18: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA7C1C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA7C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7C24: 394A6B7C  addi r10, r10, 0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + 27516;
	// 82AA7C28: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA7C2C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AA7C30: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AA7C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7C40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7C50 size=128
    let mut pc: u32 = 0x82AA7C50;
    'dispatch: loop {
        match pc {
            0x82AA7C50 => {
    //   block [0x82AA7C50..0x82AA7CD0)
	// 82AA7C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA7C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7C64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA7C68: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA7C6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA7C70: 4B818CC9  bl 0x822c0938
	ctx.lr = 0x82AA7C74;
	sub_822C0938(ctx, base);
	// 82AA7C74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA7C78: 41820034  beq 0x82aa7cac
	if ctx.cr[0].eq {
	pc = 0x82AA7CAC; continue 'dispatch;
	}
	// 82AA7C7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7C80: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA7C84: 396B6B98  addi r11, r11, 0x6b98
	ctx.r[11].s64 = ctx.r[11].s64 + 27544;
	// 82AA7C88: 394A6B7C  addi r10, r10, 0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + 27516;
	// 82AA7C8C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7C90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA7C94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA7C98: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7C9C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA7CA0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA7CA4: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82AA7CA8: 48000008  b 0x82aa7cb0
	pc = 0x82AA7CB0; continue 'dispatch;
	// 82AA7CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA7CB0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7CB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA7CB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7CC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA7CC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7CCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7CD0 size=112
    let mut pc: u32 = 0x82AA7CD0;
    'dispatch: loop {
        match pc {
            0x82AA7CD0 => {
    //   block [0x82AA7CD0..0x82AA7D40)
	// 82AA7CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7CD4: 48700499  bl 0x831a816c
	ctx.lr = 0x82AA7CD8;
	sub_831A8130(ctx, base);
	// 82AA7CD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7CDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7CE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA7CE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA7CE8: 388B6BD0  addi r4, r11, 0x6bd0
	ctx.r[4].s64 = ctx.r[11].s64 + 27600;
	// 82AA7CEC: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 82AA7CF0: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82AA7CF4: 4834A6F5  bl 0x82df23e8
	ctx.lr = 0x82AA7CF8;
	sub_82DF23E8(ctx, base);
	// 82AA7CF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA7CFC: 41820010  beq 0x82aa7d0c
	if ctx.cr[0].eq {
	pc = 0x82AA7D0C; continue 'dispatch;
	}
	// 82AA7D00: 4BFFFE41  bl 0x82aa7b40
	ctx.lr = 0x82AA7D04;
	sub_82AA7B40(ctx, base);
	// 82AA7D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7D08: 48000008  b 0x82aa7d10
	pc = 0x82AA7D10; continue 'dispatch;
	// 82AA7D0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA7D10: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA7D14: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA7D18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA7D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA7D20: 4BFFFC61  bl 0x82aa7980
	ctx.lr = 0x82AA7D24;
	sub_82AA7980(ctx, base);
	// 82AA7D24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA7D28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA7D2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA7D30: 4B8182D1  bl 0x822c0000
	ctx.lr = 0x82AA7D34;
	sub_822C0000(ctx, base);
	// 82AA7D34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7D38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7D3C: 48700480  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7D40 size=100
    let mut pc: u32 = 0x82AA7D40;
    'dispatch: loop {
        match pc {
            0x82AA7D40 => {
    //   block [0x82AA7D40..0x82AA7DA4)
	// 82AA7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA7D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA7D4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7D58: 4BFFFEF9  bl 0x82aa7c50
	ctx.lr = 0x82AA7D5C;
	sub_82AA7C50(ctx, base);
	// 82AA7D5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7D60: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7D64: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA7D68: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA7D6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7D70: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA7D74: 419A0018  beq cr6, 0x82aa7d8c
	if ctx.cr[6].eq {
	pc = 0x82AA7D8C; continue 'dispatch;
	}
	// 82AA7D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7D7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA7D80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7D84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA7D88: 4E800421  bctrl
	ctx.lr = 0x82AA7D8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA7D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA7D90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA7D94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA7D98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA7D9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA7DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA7DA8 size=592
    let mut pc: u32 = 0x82AA7DA8;
    'dispatch: loop {
        match pc {
            0x82AA7DA8 => {
    //   block [0x82AA7DA8..0x82AA7FF8)
	// 82AA7DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7DAC: 487003C1  bl 0x831a816c
	ctx.lr = 0x82AA7DB0;
	sub_831A8130(ctx, base);
	// 82AA7DB0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA7DB4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA7DB8: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA7DBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7DC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA7DC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA7DC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA7DCC: 388B6CD8  addi r4, r11, 0x6cd8
	ctx.r[4].s64 = ctx.r[11].s64 + 27864;
	// 82AA7DD0: 4834BC39  bl 0x82df3a08
	ctx.lr = 0x82AA7DD4;
	sub_82DF3A08(ctx, base);
	// 82AA7DD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7DD8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA7DDC: 388B6CCC  addi r4, r11, 0x6ccc
	ctx.r[4].s64 = ctx.r[11].s64 + 27852;
	// 82AA7DE0: 4834BC29  bl 0x82df3a08
	ctx.lr = 0x82AA7DE4;
	sub_82DF3A08(ctx, base);
	// 82AA7DE4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA7DE8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AA7DEC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7DF0: 4BB22711  bl 0x825ca500
	ctx.lr = 0x82AA7DF4;
	sub_825CA500(ctx, base);
	// 82AA7DF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA7DF8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA7DFC: 4834B62D  bl 0x82df3428
	ctx.lr = 0x82AA7E00;
	sub_82DF3428(ctx, base);
	// 82AA7E00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA7E04: 4834B625  bl 0x82df3428
	ctx.lr = 0x82AA7E08;
	sub_82DF3428(ctx, base);
	// 82AA7E08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7E0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7E10: 388B6CC0  addi r4, r11, 0x6cc0
	ctx.r[4].s64 = ctx.r[11].s64 + 27840;
	// 82AA7E14: 4834BBF5  bl 0x82df3a08
	ctx.lr = 0x82AA7E18;
	sub_82DF3A08(ctx, base);
	// 82AA7E18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7E1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7E20: 388B6CB0  addi r4, r11, 0x6cb0
	ctx.r[4].s64 = ctx.r[11].s64 + 27824;
	// 82AA7E24: 4834BBE5  bl 0x82df3a08
	ctx.lr = 0x82AA7E28;
	sub_82DF3A08(ctx, base);
	// 82AA7E28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA7E2C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AA7E30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA7E34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7E38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA7E3C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AA7E40: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AA7E44: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82AA7E48: 4BAFB461  bl 0x825a32a8
	ctx.lr = 0x82AA7E4C;
	sub_825A32A8(ctx, base);
	// 82AA7E4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA7E50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7E54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA7E58: 4BAF9919  bl 0x825a1770
	ctx.lr = 0x82AA7E5C;
	sub_825A1770(ctx, base);
	// 82AA7E5C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA7E60: 4834B5C9  bl 0x82df3428
	ctx.lr = 0x82AA7E64;
	sub_82DF3428(ctx, base);
	// 82AA7E64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA7E68: 4B820E51  bl 0x822c8cb8
	ctx.lr = 0x82AA7E6C;
	sub_822C8CB8(ctx, base);
	// 82AA7E6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7E70: 4834B5B9  bl 0x82df3428
	ctx.lr = 0x82AA7E74;
	sub_82DF3428(ctx, base);
	// 82AA7E74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7E78: 4834B5B1  bl 0x82df3428
	ctx.lr = 0x82AA7E7C;
	sub_82DF3428(ctx, base);
	// 82AA7E7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7E80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7E84: 388B6C98  addi r4, r11, 0x6c98
	ctx.r[4].s64 = ctx.r[11].s64 + 27800;
	// 82AA7E88: 4834BB81  bl 0x82df3a08
	ctx.lr = 0x82AA7E8C;
	sub_82DF3A08(ctx, base);
	// 82AA7E8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7E90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7E94: 388B6C84  addi r4, r11, 0x6c84
	ctx.r[4].s64 = ctx.r[11].s64 + 27780;
	// 82AA7E98: 4834BB71  bl 0x82df3a08
	ctx.lr = 0x82AA7E9C;
	sub_82DF3A08(ctx, base);
	// 82AA7E9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA7EA0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA7EA4: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA7EA8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA7EAC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA7EB0: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA7EB4: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA7EB8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA7EBC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA7EC0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA7EC4: 4BAFB3E5  bl 0x825a32a8
	ctx.lr = 0x82AA7EC8;
	sub_825A32A8(ctx, base);
	// 82AA7EC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA7ECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7ED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7ED4: 4BAF989D  bl 0x825a1770
	ctx.lr = 0x82AA7ED8;
	sub_825A1770(ctx, base);
	// 82AA7ED8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA7EDC: 4834B54D  bl 0x82df3428
	ctx.lr = 0x82AA7EE0;
	sub_82DF3428(ctx, base);
	// 82AA7EE0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA7EE4: 4B820DD5  bl 0x822c8cb8
	ctx.lr = 0x82AA7EE8;
	sub_822C8CB8(ctx, base);
	// 82AA7EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7EEC: 4834B53D  bl 0x82df3428
	ctx.lr = 0x82AA7EF0;
	sub_82DF3428(ctx, base);
	// 82AA7EF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7EF4: 4834B535  bl 0x82df3428
	ctx.lr = 0x82AA7EF8;
	sub_82DF3428(ctx, base);
	// 82AA7EF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7EFC: 388B6C70  addi r4, r11, 0x6c70
	ctx.r[4].s64 = ctx.r[11].s64 + 27760;
	// 82AA7F00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7F04: 4834BB05  bl 0x82df3a08
	ctx.lr = 0x82AA7F08;
	sub_82DF3A08(ctx, base);
	// 82AA7F08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7F10: 388B6C5C  addi r4, r11, 0x6c5c
	ctx.r[4].s64 = ctx.r[11].s64 + 27740;
	// 82AA7F14: 4834BAF5  bl 0x82df3a08
	ctx.lr = 0x82AA7F18;
	sub_82DF3A08(ctx, base);
	// 82AA7F18: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82AA7F1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA7F20: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA7F24: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA7F28: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA7F2C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA7F30: 4BAFB379  bl 0x825a32a8
	ctx.lr = 0x82AA7F34;
	sub_825A32A8(ctx, base);
	// 82AA7F34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA7F38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7F3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7F40: 4BAF9831  bl 0x825a1770
	ctx.lr = 0x82AA7F44;
	sub_825A1770(ctx, base);
	// 82AA7F44: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA7F48: 4834B4E1  bl 0x82df3428
	ctx.lr = 0x82AA7F4C;
	sub_82DF3428(ctx, base);
	// 82AA7F4C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA7F50: 4B820D69  bl 0x822c8cb8
	ctx.lr = 0x82AA7F54;
	sub_822C8CB8(ctx, base);
	// 82AA7F54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7F58: 4834B4D1  bl 0x82df3428
	ctx.lr = 0x82AA7F5C;
	sub_82DF3428(ctx, base);
	// 82AA7F5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7F60: 4834B4C9  bl 0x82df3428
	ctx.lr = 0x82AA7F64;
	sub_82DF3428(ctx, base);
	// 82AA7F64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7F68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7F6C: 388B6C38  addi r4, r11, 0x6c38
	ctx.r[4].s64 = ctx.r[11].s64 + 27704;
	// 82AA7F70: 4834BA99  bl 0x82df3a08
	ctx.lr = 0x82AA7F74;
	sub_82DF3A08(ctx, base);
	// 82AA7F74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA7F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7F7C: 388B6C28  addi r4, r11, 0x6c28
	ctx.r[4].s64 = ctx.r[11].s64 + 27688;
	// 82AA7F80: 4834BA89  bl 0x82df3a08
	ctx.lr = 0x82AA7F84;
	sub_82DF3A08(ctx, base);
	// 82AA7F84: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82AA7F88: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA7F8C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA7F90: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA7F94: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA7F98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA7F9C: 4BAFB30D  bl 0x825a32a8
	ctx.lr = 0x82AA7FA0;
	sub_825A32A8(ctx, base);
	// 82AA7FA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA7FA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA7FA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA7FAC: 4BAF97C5  bl 0x825a1770
	ctx.lr = 0x82AA7FB0;
	sub_825A1770(ctx, base);
	// 82AA7FB0: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82AA7FB4: 4834B475  bl 0x82df3428
	ctx.lr = 0x82AA7FB8;
	sub_82DF3428(ctx, base);
	// 82AA7FB8: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA7FBC: 4B820CFD  bl 0x822c8cb8
	ctx.lr = 0x82AA7FC0;
	sub_822C8CB8(ctx, base);
	// 82AA7FC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA7FC4: 4834B465  bl 0x82df3428
	ctx.lr = 0x82AA7FC8;
	sub_82DF3428(ctx, base);
	// 82AA7FC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA7FCC: 4834B45D  bl 0x82df3428
	ctx.lr = 0x82AA7FD0;
	sub_82DF3428(ctx, base);
	// 82AA7FD0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA7FD4: 4BB21CFD  bl 0x825c9cd0
	ctx.lr = 0x82AA7FD8;
	sub_825C9CD0(ctx, base);
	// 82AA7FD8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA7FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA7FE0: 419A0008  beq cr6, 0x82aa7fe8
	if ctx.cr[6].eq {
	pc = 0x82AA7FE8; continue 'dispatch;
	}
	// 82AA7FE4: 4B8188AD  bl 0x822c0890
	ctx.lr = 0x82AA7FE8;
	sub_822C0890(ctx, base);
	// 82AA7FE8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82AA7FEC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA7FF0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA7FF4: 487001C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA7FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA7FF8 size=128
    let mut pc: u32 = 0x82AA7FF8;
    'dispatch: loop {
        match pc {
            0x82AA7FF8 => {
    //   block [0x82AA7FF8..0x82AA8078)
	// 82AA7FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA7FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA8004: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8008: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA800C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA8010: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA8018: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA801C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA8020: 419A0024  beq cr6, 0x82aa8044
	if ctx.cr[6].eq {
	pc = 0x82AA8044; continue 'dispatch;
	}
	// 82AA8024: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA8028: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA802C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA8030: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA8034: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA8038: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA803C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA8040: 4082FFE8  bne 0x82aa8028
	if !ctx.cr[0].eq {
	pc = 0x82AA8028; continue 'dispatch;
	}
	// 82AA8044: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8048: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA804C: 386BCCD0  addi r3, r11, -0x3330
	ctx.r[3].s64 = ctx.r[11].s64 + -13104;
	// 82AA8050: 4BFFFD59  bl 0x82aa7da8
	ctx.lr = 0x82AA8054;
	sub_82AA7DA8(ctx, base);
	// 82AA8054: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA805C: 419A0008  beq cr6, 0x82aa8064
	if ctx.cr[6].eq {
	pc = 0x82AA8064; continue 'dispatch;
	}
	// 82AA8060: 4B818831  bl 0x822c0890
	ctx.lr = 0x82AA8064;
	sub_822C0890(ctx, base);
	// 82AA8064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA8068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA806C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA8074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8078 size=964
    let mut pc: u32 = 0x82AA8078;
    'dispatch: loop {
        match pc {
            0x82AA8078 => {
    //   block [0x82AA8078..0x82AA843C)
	// 82AA8078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA807C: 487000DD  bl 0x831a8158
	ctx.lr = 0x82AA8080;
	sub_831A8130(ctx, base);
	// 82AA8080: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 82AA8084: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82AA8088: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82AA808C: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8094: 486AC56D  bl 0x83154600
	ctx.lr = 0x82AA8098;
	sub_83154600(ctx, base);
	// 82AA8098: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA809C: 4BE10C4D  bl 0x828b8ce8
	ctx.lr = 0x82AA80A0;
	sub_828B8CE8(ctx, base);
	// 82AA80A0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA80A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA80A8: 4BE57949  bl 0x828ff9f0
	ctx.lr = 0x82AA80AC;
	sub_828FF9F0(ctx, base);
	// 82AA80AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA80B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82AA80B4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82AA80B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA80BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA80C0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA80C4: 13FD50C7  vcmpequd (lvx128) v31, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA80C8: 3BCBCCD0  addi r30, r11, -0x3330
	ctx.r[30].s64 = ctx.r[11].s64 + -13104;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8440 size=192
    let mut pc: u32 = 0x82AA8440;
    'dispatch: loop {
        match pc {
            0x82AA8440 => {
    //   block [0x82AA8440..0x82AA8500)
	// 82AA8440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8448: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA844C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA8450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8458: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AA845C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AA8460: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82AA8464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8468: 4B9E9EA1  bl 0x82492308
	ctx.lr = 0x82AA846C;
	sub_82492308(ctx, base);
	// 82AA846C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8470: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AA8474: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AA8478: 419A006C  beq cr6, 0x82aa84e4
	if ctx.cr[6].eq {
	pc = 0x82AA84E4; continue 'dispatch;
	}
	// 82AA847C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AA8480: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82AA8484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8488: 419A0018  beq cr6, 0x82aa84a0
	if ctx.cr[6].eq {
	pc = 0x82AA84A0; continue 'dispatch;
	}
	// 82AA848C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8490: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8498: 4E800421  bctrl
	ctx.lr = 0x82AA849C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA849C: 4800000C  b 0x82aa84a8
	pc = 0x82AA84A8; continue 'dispatch;
	// 82AA84A0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AA84A4: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AA84A8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA84AC: 388BCCE0  addi r4, r11, -0x3320
	ctx.r[4].s64 = ctx.r[11].s64 + -13088;
	// 82AA84B0: 486FFC49  bl 0x831a80f8
	ctx.lr = 0x82AA84B4;
	sub_831A80F8(ctx, base);
	// 82AA84B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA84B8: 4182002C  beq 0x82aa84e4
	if ctx.cr[0].eq {
	pc = 0x82AA84E4; continue 'dispatch;
	}
	// 82AA84BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA84C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA84C4: 4BFFF6FD  bl 0x82aa7bc0
	ctx.lr = 0x82AA84C8;
	sub_82AA7BC0(ctx, base);
	// 82AA84C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA84CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AA84D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA84D4: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA84D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AA84DC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82AA84E0: 48000008  b 0x82aa84e8
	pc = 0x82AA84E8; continue 'dispatch;
	// 82AA84E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AA84E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA84EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA84F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA84F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA84F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA84FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8500 size=204
    let mut pc: u32 = 0x82AA8500;
    'dispatch: loop {
        match pc {
            0x82AA8500 => {
    //   block [0x82AA8500..0x82AA85CC)
	// 82AA8500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8504: 486FFC69  bl 0x831a816c
	ctx.lr = 0x82AA8508;
	sub_831A8130(ctx, base);
	// 82AA8508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA850C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8510: 486AC0F1  bl 0x83154600
	ctx.lr = 0x82AA8514;
	sub_83154600(ctx, base);
	// 82AA8514: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8518: 4BE107D1  bl 0x828b8ce8
	ctx.lr = 0x82AA851C;
	sub_828B8CE8(ctx, base);
	// 82AA851C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8520: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA8524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8528: 808BCCC8  lwz r4, -0x3338(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13112 as u32) ) } as u64;
	// 82AA852C: 4834B4DD  bl 0x82df3a08
	ctx.lr = 0x82AA8530;
	sub_82DF3A08(ctx, base);
	// 82AA8530: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 82AA8534: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA853C: 4BFFFF05  bl 0x82aa8440
	ctx.lr = 0x82AA8540;
	sub_82AA8440(ctx, base);
	// 82AA8540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8544: 4834AEE5  bl 0x82df3428
	ctx.lr = 0x82AA8548;
	sub_82DF3428(ctx, base);
	// 82AA8548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA854C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA8550: 4BFE0141  bl 0x82a88690
	ctx.lr = 0x82AA8554;
	sub_82A88690(ctx, base);
	// 82AA8554: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA855C: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AA8560: 4834B4A9  bl 0x82df3a08
	ctx.lr = 0x82AA8564;
	sub_82DF3A08(ctx, base);
	// 82AA8564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8568: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA856C: 4BD47205  bl 0x827ef770
	ctx.lr = 0x82AA8570;
	sub_827EF770(ctx, base);
	// 82AA8570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8574: 4834AEB5  bl 0x82df3428
	ctx.lr = 0x82AA8578;
	sub_82DF3428(ctx, base);
	// 82AA8578: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA857C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8580: 808B9F9C  lwz r4, -0x6064(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24676 as u32) ) } as u64;
	// 82AA8584: 4834B485  bl 0x82df3a08
	ctx.lr = 0x82AA8588;
	sub_82DF3A08(ctx, base);
	// 82AA8588: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA858C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8594: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA8598: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA859C: 4E800421  bctrl
	ctx.lr = 0x82AA85A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA85A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA85A4: 4834AE85  bl 0x82df3428
	ctx.lr = 0x82AA85A8;
	sub_82DF3428(ctx, base);
	// 82AA85A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA85AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA85B0: 4BFDC3B9  bl 0x82a84968
	ctx.lr = 0x82AA85B4;
	sub_82A84968(ctx, base);
	// 82AA85B4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA85B8: 396BCCD0  addi r11, r11, -0x3330
	ctx.r[11].s64 = ctx.r[11].s64 + -13104;
	// 82AA85BC: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA85C0: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA85C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA85C8: 486FFBF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA85D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA85D0 size=164
    let mut pc: u32 = 0x82AA85D0;
    'dispatch: loop {
        match pc {
            0x82AA85D0 => {
    //   block [0x82AA85D0..0x82AA8674)
	// 82AA85D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA85D4: 486FFB99  bl 0x831a816c
	ctx.lr = 0x82AA85D8;
	sub_831A8130(ctx, base);
	// 82AA85D8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA85DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA85E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA85E4: 486AC01D  bl 0x83154600
	ctx.lr = 0x82AA85E8;
	sub_83154600(ctx, base);
	// 82AA85E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA85EC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA85F0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA85F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA85F8: 4E800421  bctrl
	ctx.lr = 0x82AA85FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA85FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA8600: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA8604: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA8608: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA860C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA8610: 40990034  ble cr6, 0x82aa8644
	if !ctx.cr[6].gt {
	pc = 0x82AA8644; continue 'dispatch;
	}
	// 82AA8614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8618: 483B1161  bl 0x82e59778
	ctx.lr = 0x82AA861C;
	sub_82E59778(ctx, base);
	// 82AA861C: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA8620: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA8624: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA8628: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA862C: 41990018  bgt cr6, 0x82aa8644
	if ctx.cr[6].gt {
	pc = 0x82AA8644; continue 'dispatch;
	}
	// 82AA8630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8634: 4BFFFA45  bl 0x82aa8078
	ctx.lr = 0x82AA8638;
	sub_82AA8078(ctx, base);
	// 82AA8638: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA863C: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA8640: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA8644: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8648: 4BD41CC9  bl 0x827ea310
	ctx.lr = 0x82AA864C;
	sub_827EA310(ctx, base);
	// 82AA864C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8650: 41820018  beq 0x82aa8668
	if ctx.cr[0].eq {
	pc = 0x82AA8668; continue 'dispatch;
	}
	// 82AA8654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8658: 4BE10691  bl 0x828b8ce8
	ctx.lr = 0x82AA865C;
	sub_828B8CE8(ctx, base);
	// 82AA865C: 4BDEFB3D  bl 0x82898198
	ctx.lr = 0x82AA8660;
	sub_82898198(ctx, base);
	// 82AA8660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA8664: 4BFE3E35  bl 0x82a8c498
	ctx.lr = 0x82AA8668;
	sub_82A8C498(ctx, base);
	// 82AA8668: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA866C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA8670: 486FFB4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8678 size=96
    let mut pc: u32 = 0x82AA8678;
    'dispatch: loop {
        match pc {
            0x82AA8678 => {
    //   block [0x82AA8678..0x82AA86D8)
	// 82AA8678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA867C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA8684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA8688: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA868C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8698: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA869C: 808BCCC8  lwz r4, -0x3338(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13112 as u32) ) } as u64;
	// 82AA86A0: 4834B369  bl 0x82df3a08
	ctx.lr = 0x82AA86A4;
	sub_82DF3A08(ctx, base);
	// 82AA86A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA86A8: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AA86AC: 4B884195  bl 0x8232c840
	ctx.lr = 0x82AA86B0;
	sub_8232C840(ctx, base);
	// 82AA86B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA86B4: 4BFFF68D  bl 0x82aa7d40
	ctx.lr = 0x82AA86B8;
	sub_82AA7D40(ctx, base);
	// 82AA86B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA86BC: 4834AD6D  bl 0x82df3428
	ctx.lr = 0x82AA86C0;
	sub_82DF3428(ctx, base);
	// 82AA86C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA86C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA86C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA86CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA86D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA86D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA86D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA86D8 size=136
    let mut pc: u32 = 0x82AA86D8;
    'dispatch: loop {
        match pc {
            0x82AA86D8 => {
    //   block [0x82AA86D8..0x82AA8760)
	// 82AA86D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA86DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA86E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA86E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA86E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA86EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA86F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA86F4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82AA86F8: 409A0020  bne cr6, 0x82aa8718
	if !ctx.cr[6].eq {
	pc = 0x82AA8718; continue 'dispatch;
	}
	// 82AA86FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA8700: 419A0048  beq cr6, 0x82aa8748
	if ctx.cr[6].eq {
	pc = 0x82AA8748; continue 'dispatch;
	}
	// 82AA8704: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82AA8708: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82AA870C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82AA8710: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82AA8714: 48000034  b 0x82aa8748
	pc = 0x82AA8748; continue 'dispatch;
	// 82AA8718: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82AA871C: 419A002C  beq cr6, 0x82aa8748
	if ctx.cr[6].eq {
	pc = 0x82AA8748; continue 'dispatch;
	}
	// 82AA8720: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8724: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8728: 388BCE80  addi r4, r11, -0x3180
	ctx.r[4].s64 = ctx.r[11].s64 + -12672;
	// 82AA872C: 486FF9CD  bl 0x831a80f8
	ctx.lr = 0x82AA8730;
	sub_831A80F8(ctx, base);
	// 82AA8730: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8734: 4182000C  beq 0x82aa8740
	if ctx.cr[0].eq {
	pc = 0x82AA8740; continue 'dispatch;
	}
	// 82AA8738: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AA873C: 4800000C  b 0x82aa8748
	pc = 0x82AA8748; continue 'dispatch;
	// 82AA8740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA8744: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA8748: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA874C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA8750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8754: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA8758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA875C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AA8760 size=156
    let mut pc: u32 = 0x82AA8760;
    'dispatch: loop {
        match pc {
            0x82AA8760 => {
    //   block [0x82AA8760..0x82AA87FC)
	// 82AA8760: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82AA8764: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82AA8768: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82AA876C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA8770: 3CC08203  lis r6, -0x7dfd
	ctx.r[6].s64 = -2113732608;
	// 82AA8774: C009D86C  lfs f0, -0x2794(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA8778: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82AA877C: C1A895A0  lfs f13, -0x6a60(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA8780: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82AA8784: C187D5B8  lfs f12, -0x2a48(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA8788: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82AA878C: C14A08A8  lfs f10, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AA8790: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 82AA8794: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA8798: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA879C: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AA87A0: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82AA87A4: C169964C  lfs f11, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA87A8: C008A1C4  lfs f0, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA87AC: C187D7BC  lfs f12, -0x2844(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA87B0: C1A67BC4  lfs f13, 0x7bc4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA87B4: D1430000  stfs f10, 0(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AA87B8: D1430004  stfs f10, 4(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA87BC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AA87C0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AA87C4: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AA87C8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AA87CC: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AA87D0: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82AA87D4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82AA87D8: 4080FFE4  bge 0x82aa87bc
	if !ctx.cr[0].lt {
	pc = 0x82AA87BC; continue 'dispatch;
	}
	// 82AA87DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA87E0: D1430030  stfs f10, 0x30(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82AA87E4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA87E8: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA87EC: C1AA6D34  lfs f13, 0x6d34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27956 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA87F0: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82AA87F4: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82AA87F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8800 size=164
    let mut pc: u32 = 0x82AA8800;
    'dispatch: loop {
        match pc {
            0x82AA8800 => {
    //   block [0x82AA8800..0x82AA88A4)
	// 82AA8800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8804: 486FF969  bl 0x831a816c
	ctx.lr = 0x82AA8808;
	sub_831A8130(ctx, base);
	// 82AA8808: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA880C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8810: 486ABDF1  bl 0x83154600
	ctx.lr = 0x82AA8814;
	sub_83154600(ctx, base);
	// 82AA8814: 4BE104D5  bl 0x828b8ce8
	ctx.lr = 0x82AA8818;
	sub_828B8CE8(ctx, base);
	// 82AA8818: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA881C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA8820: 419A0010  beq cr6, 0x82aa8830
	if ctx.cr[6].eq {
	pc = 0x82AA8830; continue 'dispatch;
	}
	// 82AA8824: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82AA8828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA882C: 409A0008  bne cr6, 0x82aa8834
	if !ctx.cr[6].eq {
	pc = 0x82AA8834; continue 'dispatch;
	}
	// 82AA8830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA8834: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 82AA8838: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA883C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA8840: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82AA8844: 4BE60E15  bl 0x82909658
	ctx.lr = 0x82AA8848;
	sub_82909658(ctx, base);
	// 82AA8848: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA884C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8850: 4BD43909  bl 0x827ec158
	ctx.lr = 0x82AA8854;
	sub_827EC158(ctx, base);
	// 82AA8854: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA8858: 483D32A9  bl 0x82e7bb00
	ctx.lr = 0x82AA885C;
	sub_82E7BB00(ctx, base);
	// 82AA885C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AA8860: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA8864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8868: 483D3461  bl 0x82e7bcc8
	ctx.lr = 0x82AA886C;
	sub_82E7BCC8(ctx, base);
	// 82AA886C: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AA8870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8874: 419A0010  beq cr6, 0x82aa8884
	if ctx.cr[6].eq {
	pc = 0x82AA8884; continue 'dispatch;
	}
	// 82AA8878: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA887C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8880: 4BED4951  bl 0x8297d1d0
	ctx.lr = 0x82AA8884;
	sub_8297D1D0(ctx, base);
	// 82AA8884: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA8888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA888C: 419A0010  beq cr6, 0x82aa889c
	if ctx.cr[6].eq {
	pc = 0x82AA889C; continue 'dispatch;
	}
	// 82AA8890: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA8894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8898: 4BED4939  bl 0x8297d1d0
	ctx.lr = 0x82AA889C;
	sub_8297D1D0(ctx, base);
	// 82AA889C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AA88A0: 486FF91C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA88A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA88A8 size=196
    let mut pc: u32 = 0x82AA88A8;
    'dispatch: loop {
        match pc {
            0x82AA88A8 => {
    //   block [0x82AA88A8..0x82AA896C)
	// 82AA88A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA88AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA88B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA88B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA88B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA88BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA88C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA88C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AA88C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AA88CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA88D0: 4B818069  bl 0x822c0938
	ctx.lr = 0x82AA88D4;
	sub_822C0938(ctx, base);
	// 82AA88D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA88D8: 41820028  beq 0x82aa8900
	if ctx.cr[0].eq {
	pc = 0x82AA8900; continue 'dispatch;
	}
	// 82AA88DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA88E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AA88E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AA88E8: 392B6D24  addi r9, r11, 0x6d24
	ctx.r[9].s64 = ctx.r[11].s64 + 27940;
	// 82AA88EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AA88F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA88F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AA88F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AA88FC: 48000008  b 0x82aa8904
	pc = 0x82AA8904; continue 'dispatch;
	// 82AA8900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA8904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA8908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA890C: 409A0044  bne cr6, 0x82aa8950
	if !ctx.cr[6].eq {
	pc = 0x82AA8950; continue 'dispatch;
	}
	// 82AA8910: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA8914: 419A001C  beq cr6, 0x82aa8930
	if ctx.cr[6].eq {
	pc = 0x82AA8930; continue 'dispatch;
	}
	// 82AA8918: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA891C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA8920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA892C: 4E800421  bctrl
	ctx.lr = 0x82AA8930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA8930: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8934: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA8938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA893C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AA8940: 816BCE18  lwz r11, -0x31e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12776 as u32) ) } as u64;
	// 82AA8944: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA8948: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA894C: 4B8176B5  bl 0x822c0000
	ctx.lr = 0x82AA8950;
	sub_822C0000(ctx, base);
	// 82AA8950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA8958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA895C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8960: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA8964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA8968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8970 size=72
    let mut pc: u32 = 0x82AA8970;
    'dispatch: loop {
        match pc {
            0x82AA8970 => {
    //   block [0x82AA8970..0x82AA89B8)
	// 82AA8970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8978: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA897C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82AA8980: 419A001C  beq cr6, 0x82aa899c
	if ctx.cr[6].eq {
	pc = 0x82AA899C; continue 'dispatch;
	}
	// 82AA8984: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA8988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AA898C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82AA8990: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA8994: 4BFFFD45  bl 0x82aa86d8
	ctx.lr = 0x82AA8998;
	sub_82AA86D8(ctx, base);
	// 82AA8998: 48000010  b 0x82aa89a8
	pc = 0x82AA89A8; continue 'dispatch;
	// 82AA899C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA89A0: 396BCE80  addi r11, r11, -0x3180
	ctx.r[11].s64 = ctx.r[11].s64 + -12672;
	// 82AA89A4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AA89A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA89AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA89B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA89B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA89B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA89B8 size=148
    let mut pc: u32 = 0x82AA89B8;
    'dispatch: loop {
        match pc {
            0x82AA89B8 => {
    //   block [0x82AA89B8..0x82AA8A4C)
	// 82AA89B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA89BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA89C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA89C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA89C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA89CC: 4BFF14CD  bl 0x82a99e98
	ctx.lr = 0x82AA89D0;
	sub_82A99E98(ctx, base);
	// 82AA89D0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AA89D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AA89D8: 394A6D3C  addi r10, r10, 0x6d3c
	ctx.r[10].s64 = ctx.r[10].s64 + 27964;
	// 82AA89DC: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AA89E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AA89E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA89E8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA89EC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AA89F0: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AA89F4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82AA89F8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AA89FC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82AA8A00: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AA8A04: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82AA8A08: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82AA8A0C: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82AA8A10: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82AA8A14: 997F00A0  stb r11, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 82AA8A18: 8089C9EC  lwz r4, -0x3614(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13844 as u32) ) } as u64;
	// 82AA8A1C: 4834AFED  bl 0x82df3a08
	ctx.lr = 0x82AA8A20;
	sub_82DF3A08(ctx, base);
	// 82AA8A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8A28: 483B0CC1  bl 0x82e596e8
	ctx.lr = 0x82AA8A2C;
	sub_82E596E8(ctx, base);
	// 82AA8A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8A30: 4834A9F9  bl 0x82df3428
	ctx.lr = 0x82AA8A34;
	sub_82DF3428(ctx, base);
	// 82AA8A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8A38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA8A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA8A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA8A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8A50 size=128
    let mut pc: u32 = 0x82AA8A50;
    'dispatch: loop {
        match pc {
            0x82AA8A50 => {
    //   block [0x82AA8A50..0x82AA8AD0)
	// 82AA8A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA8A5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8A60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8A64: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AA8A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8A6C: 419A0008  beq cr6, 0x82aa8a74
	if ctx.cr[6].eq {
	pc = 0x82AA8A74; continue 'dispatch;
	}
	// 82AA8A70: 4B817E21  bl 0x822c0890
	ctx.lr = 0x82AA8A74;
	sub_822C0890(ctx, base);
	// 82AA8A74: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA8A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8A7C: 419A0018  beq cr6, 0x82aa8a94
	if ctx.cr[6].eq {
	pc = 0x82AA8A94; continue 'dispatch;
	}
	// 82AA8A80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8A84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA8A88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8A8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8A90: 4E800421  bctrl
	ctx.lr = 0x82AA8A94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA8A94: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA8A98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8A9C: 419A0008  beq cr6, 0x82aa8aa4
	if ctx.cr[6].eq {
	pc = 0x82AA8AA4; continue 'dispatch;
	}
	// 82AA8AA0: 4B817DF1  bl 0x822c0890
	ctx.lr = 0x82AA8AA4;
	sub_822C0890(ctx, base);
	// 82AA8AA4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA8AA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8AAC: 419A0008  beq cr6, 0x82aa8ab4
	if ctx.cr[6].eq {
	pc = 0x82AA8AB4; continue 'dispatch;
	}
	// 82AA8AB0: 4B817DE1  bl 0x822c0890
	ctx.lr = 0x82AA8AB4;
	sub_822C0890(ctx, base);
	// 82AA8AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8AB8: 483B3AD1  bl 0x82e5c588
	ctx.lr = 0x82AA8ABC;
	sub_82E5C588(ctx, base);
	// 82AA8ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AA8AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA8AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA8ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA8AD0 size=76
    let mut pc: u32 = 0x82AA8AD0;
    'dispatch: loop {
        match pc {
            0x82AA8AD0 => {
    //   block [0x82AA8AD0..0x82AA8B1C)
	// 82AA8AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA8AD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AA8ADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA8AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8AE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA8AEC: 4BFFFF65  bl 0x82aa8a50
	ctx.lr = 0x82AA8AF0;
	sub_82AA8A50(ctx, base);
	// 82AA8AF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA8AF4: 4182000C  beq 0x82aa8b00
	if ctx.cr[0].eq {
	pc = 0x82AA8B00; continue 'dispatch;
	}
	// 82AA8AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8AFC: 483498DD  bl 0x82df23d8
	ctx.lr = 0x82AA8B00;
	sub_82DF23D8(ctx, base);
	// 82AA8B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA8B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA8B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA8B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA8B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AA8B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA8B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8B20 size=316
    let mut pc: u32 = 0x82AA8B20;
    'dispatch: loop {
        match pc {
            0x82AA8B20 => {
    //   block [0x82AA8B20..0x82AA8C5C)
	// 82AA8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8B24: 486FF641  bl 0x831a8164
	ctx.lr = 0x82AA8B28;
	sub_831A8130(ctx, base);
	// 82AA8B28: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8B30: 486ABAD1  bl 0x83154600
	ctx.lr = 0x82AA8B34;
	sub_83154600(ctx, base);
	// 82AA8B34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8B38: 4BE101B1  bl 0x828b8ce8
	ctx.lr = 0x82AA8B3C;
	sub_828B8CE8(ctx, base);
	// 82AA8B3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8B40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA8B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8B48: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA8B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8B50: 4E800421  bctrl
	ctx.lr = 0x82AA8B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA8B54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA8B58: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 82AA8B5C: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82AA8B60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA8B64: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA8B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA8B6C: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82AA8B70: 419A000C  beq cr6, 0x82aa8b7c
	if ctx.cr[6].eq {
	pc = 0x82AA8B7C; continue 'dispatch;
	}
	// 82AA8B74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA8B78: 4B817D19  bl 0x822c0890
	ctx.lr = 0x82AA8B7C;
	sub_822C0890(ctx, base);
	// 82AA8B7C: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82AA8B80: 397F006C  addi r11, r31, 0x6c
	ctx.r[11].s64 = ctx.r[31].s64 + 108;
	// 82AA8B84: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AA8B88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8B8C: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82AA8B90: 419A0008  beq cr6, 0x82aa8b98
	if ctx.cr[6].eq {
	pc = 0x82AA8B98; continue 'dispatch;
	}
	// 82AA8B94: 4B817CFD  bl 0x822c0890
	ctx.lr = 0x82AA8B98;
	sub_822C0890(ctx, base);
	// 82AA8B98: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA8B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8BA0: 808BCDF0  lwz r4, -0x3210(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12816 as u32) ) } as u64;
	// 82AA8BA4: 4834AE65  bl 0x82df3a08
	ctx.lr = 0x82AA8BA8;
	sub_82DF3A08(ctx, base);
	// 82AA8BA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8BAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA8BB0: 4BD417C9  bl 0x827ea378
	ctx.lr = 0x82AA8BB4;
	sub_827EA378(ctx, base);
	// 82AA8BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8BB8: 4834A871  bl 0x82df3428
	ctx.lr = 0x82AA8BBC;
	sub_82DF3428(ctx, base);
	// 82AA8BBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA8BC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA8BC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA8BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8BCC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA8BD0: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA8BD4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AA8BD8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AA8BDC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AA8BE0: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AA8BE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8BE8: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA8BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8BF0: 4E800421  bctrl
	ctx.lr = 0x82AA8BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA8BF4: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA8BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8BFC: 419A003C  beq cr6, 0x82aa8c38
	if ctx.cr[6].eq {
	pc = 0x82AA8C38; continue 'dispatch;
	}
	// 82AA8C00: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA8C04: 4BD2676D  bl 0x827cf370
	ctx.lr = 0x82AA8C08;
	sub_827CF370(ctx, base);
	// 82AA8C08: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 82AA8C0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8C10: 4BA668B9  bl 0x8250f4c8
	ctx.lr = 0x82AA8C14;
	sub_8250F4C8(ctx, base);
	// 82AA8C14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA8C1C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA8C20: 409A0008  bne cr6, 0x82aa8c28
	if !ctx.cr[6].eq {
	pc = 0x82AA8C28; continue 'dispatch;
	}
	// 82AA8C24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA8C28: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA8C2C: 4BD27215  bl 0x827cfe40
	ctx.lr = 0x82AA8C30;
	sub_827CFE40(ctx, base);
	// 82AA8C30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8C34: 4834905D  bl 0x82df1c90
	ctx.lr = 0x82AA8C38;
	sub_82DF1C90(ctx, base);
	// 82AA8C38: 83FF009C  lwz r31, 0x9c(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AA8C3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AA8C40: 419A0014  beq cr6, 0x82aa8c54
	if ctx.cr[6].eq {
	pc = 0x82AA8C54; continue 'dispatch;
	}
	// 82AA8C44: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 82AA8C48: 4BE617E9  bl 0x8290a430
	ctx.lr = 0x82AA8C4C;
	sub_8290A430(ctx, base);
	// 82AA8C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA8C50: 4809D3B1  bl 0x82b46000
	ctx.lr = 0x82AA8C54;
	sub_82B46000(ctx, base);
	// 82AA8C54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AA8C58: 486FF55C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8C60 size=652
    let mut pc: u32 = 0x82AA8C60;
    'dispatch: loop {
        match pc {
            0x82AA8C60 => {
    //   block [0x82AA8C60..0x82AA8EEC)
	// 82AA8C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8C64: 486FF509  bl 0x831a816c
	ctx.lr = 0x82AA8C68;
	sub_831A8130(ctx, base);
	// 82AA8C68: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA8C6C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA8C70: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8C74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AA8C78: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82AA8C7C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82AA8C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8C84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8C88: 4BB21879  bl 0x825ca500
	ctx.lr = 0x82AA8C8C;
	sub_825CA500(ctx, base);
	// 82AA8C8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8C90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA8C94: 388B6DD4  addi r4, r11, 0x6dd4
	ctx.r[4].s64 = ctx.r[11].s64 + 28116;
	// 82AA8C98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8C9C: 4834AD6D  bl 0x82df3a08
	ctx.lr = 0x82AA8CA0;
	sub_82DF3A08(ctx, base);
	// 82AA8CA0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8CA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8CA8: 388B58EC  addi r4, r11, 0x58ec
	ctx.r[4].s64 = ctx.r[11].s64 + 22764;
	// 82AA8CAC: 4834AD5D  bl 0x82df3a08
	ctx.lr = 0x82AA8CB0;
	sub_82DF3A08(ctx, base);
	// 82AA8CB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA8CB4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA8CB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA8CBC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8CC0: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA8CC4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA8CC8: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA8CCC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA8CD0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA8CD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA8CD8: 4BAFA5D1  bl 0x825a32a8
	ctx.lr = 0x82AA8CDC;
	sub_825A32A8(ctx, base);
	// 82AA8CDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8CE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8CE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8CE8: 4BAF8A89  bl 0x825a1770
	ctx.lr = 0x82AA8CEC;
	sub_825A1770(ctx, base);
	// 82AA8CEC: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82AA8CF0: 4834A739  bl 0x82df3428
	ctx.lr = 0x82AA8CF4;
	sub_82DF3428(ctx, base);
	// 82AA8CF4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA8CF8: 4B81FFC1  bl 0x822c8cb8
	ctx.lr = 0x82AA8CFC;
	sub_822C8CB8(ctx, base);
	// 82AA8CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8D00: 4834A729  bl 0x82df3428
	ctx.lr = 0x82AA8D04;
	sub_82DF3428(ctx, base);
	// 82AA8D04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8D08: 4834A721  bl 0x82df3428
	ctx.lr = 0x82AA8D0C;
	sub_82DF3428(ctx, base);
	// 82AA8D0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8D14: 388B6DC0  addi r4, r11, 0x6dc0
	ctx.r[4].s64 = ctx.r[11].s64 + 28096;
	// 82AA8D18: 4834ACF1  bl 0x82df3a08
	ctx.lr = 0x82AA8D1C;
	sub_82DF3A08(ctx, base);
	// 82AA8D1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8D20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8D24: 388B6DB8  addi r4, r11, 0x6db8
	ctx.r[4].s64 = ctx.r[11].s64 + 28088;
	// 82AA8D28: 4834ACE1  bl 0x82df3a08
	ctx.lr = 0x82AA8D2C;
	sub_82DF3A08(ctx, base);
	// 82AA8D2C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA8D30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8D34: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA8D38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8D3C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA8D40: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA8D44: 4BAFA565  bl 0x825a32a8
	ctx.lr = 0x82AA8D48;
	sub_825A32A8(ctx, base);
	// 82AA8D48: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8D4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8D50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8D54: 4BAF8A1D  bl 0x825a1770
	ctx.lr = 0x82AA8D58;
	sub_825A1770(ctx, base);
	// 82AA8D58: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AA8D5C: 4834A6CD  bl 0x82df3428
	ctx.lr = 0x82AA8D60;
	sub_82DF3428(ctx, base);
	// 82AA8D60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA8D64: 4B81FF55  bl 0x822c8cb8
	ctx.lr = 0x82AA8D68;
	sub_822C8CB8(ctx, base);
	// 82AA8D68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8D6C: 4834A6BD  bl 0x82df3428
	ctx.lr = 0x82AA8D70;
	sub_82DF3428(ctx, base);
	// 82AA8D70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8D74: 4834A6B5  bl 0x82df3428
	ctx.lr = 0x82AA8D78;
	sub_82DF3428(ctx, base);
	// 82AA8D78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8D80: 388B6DA8  addi r4, r11, 0x6da8
	ctx.r[4].s64 = ctx.r[11].s64 + 28072;
	// 82AA8D84: 4834AC85  bl 0x82df3a08
	ctx.lr = 0x82AA8D88;
	sub_82DF3A08(ctx, base);
	// 82AA8D88: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8D8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8D90: 388B58D8  addi r4, r11, 0x58d8
	ctx.r[4].s64 = ctx.r[11].s64 + 22744;
	// 82AA8D94: 4834AC75  bl 0x82df3a08
	ctx.lr = 0x82AA8D98;
	sub_82DF3A08(ctx, base);
	// 82AA8D98: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82AA8D9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8DA0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA8DA4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AA8DA8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA8DAC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA8DB0: 4BAFA4F9  bl 0x825a32a8
	ctx.lr = 0x82AA8DB4;
	sub_825A32A8(ctx, base);
	// 82AA8DB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8DB8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8DBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8DC0: 4BAF89B1  bl 0x825a1770
	ctx.lr = 0x82AA8DC4;
	sub_825A1770(ctx, base);
	// 82AA8DC4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AA8DC8: 4834A661  bl 0x82df3428
	ctx.lr = 0x82AA8DCC;
	sub_82DF3428(ctx, base);
	// 82AA8DCC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AA8DD0: 4B81FEE9  bl 0x822c8cb8
	ctx.lr = 0x82AA8DD4;
	sub_822C8CB8(ctx, base);
	// 82AA8DD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8DD8: 4834A651  bl 0x82df3428
	ctx.lr = 0x82AA8DDC;
	sub_82DF3428(ctx, base);
	// 82AA8DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8DE0: 4834A649  bl 0x82df3428
	ctx.lr = 0x82AA8DE4;
	sub_82DF3428(ctx, base);
	// 82AA8DE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8DEC: 388B6D8C  addi r4, r11, 0x6d8c
	ctx.r[4].s64 = ctx.r[11].s64 + 28044;
	// 82AA8DF0: 4834AC19  bl 0x82df3a08
	ctx.lr = 0x82AA8DF4;
	sub_82DF3A08(ctx, base);
	// 82AA8DF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8DF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8DFC: 388B6D84  addi r4, r11, 0x6d84
	ctx.r[4].s64 = ctx.r[11].s64 + 28036;
	// 82AA8E00: 4834AC09  bl 0x82df3a08
	ctx.lr = 0x82AA8E04;
	sub_82DF3A08(ctx, base);
	// 82AA8E04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA8E08: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA8E0C: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82AA8E10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8E14: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AA8E18: C06B9F7C  lfs f3, -0x6084(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AA8E1C: C04A08A8  lfs f2, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AA8E20: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82AA8E24: 4BAFA485  bl 0x825a32a8
	ctx.lr = 0x82AA8E28;
	sub_825A32A8(ctx, base);
	// 82AA8E28: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8E30: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8E34: 4BAF893D  bl 0x825a1770
	ctx.lr = 0x82AA8E38;
	sub_825A1770(ctx, base);
	// 82AA8E38: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA8E3C: 4834A5ED  bl 0x82df3428
	ctx.lr = 0x82AA8E40;
	sub_82DF3428(ctx, base);
	// 82AA8E40: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AA8E44: 4B81FE75  bl 0x822c8cb8
	ctx.lr = 0x82AA8E48;
	sub_822C8CB8(ctx, base);
	// 82AA8E48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8E4C: 4834A5DD  bl 0x82df3428
	ctx.lr = 0x82AA8E50;
	sub_82DF3428(ctx, base);
	// 82AA8E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8E54: 4834A5D5  bl 0x82df3428
	ctx.lr = 0x82AA8E58;
	sub_82DF3428(ctx, base);
	// 82AA8E58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8E60: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82AA8E64: 4834ABA5  bl 0x82df3a08
	ctx.lr = 0x82AA8E68;
	sub_82DF3A08(ctx, base);
	// 82AA8E68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8E6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8E70: 388B6D64  addi r4, r11, 0x6d64
	ctx.r[4].s64 = ctx.r[11].s64 + 28004;
	// 82AA8E74: 4834AB95  bl 0x82df3a08
	ctx.lr = 0x82AA8E78;
	sub_82DF3A08(ctx, base);
	// 82AA8E78: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82AA8E7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8E80: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA8E84: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82AA8E88: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA8E8C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA8E90: 4BAFA419  bl 0x825a32a8
	ctx.lr = 0x82AA8E94;
	sub_825A32A8(ctx, base);
	// 82AA8E94: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8E98: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8E9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA8EA0: 4BAF88D1  bl 0x825a1770
	ctx.lr = 0x82AA8EA4;
	sub_825A1770(ctx, base);
	// 82AA8EA4: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 82AA8EA8: 4834A581  bl 0x82df3428
	ctx.lr = 0x82AA8EAC;
	sub_82DF3428(ctx, base);
	// 82AA8EAC: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82AA8EB0: 4B81FE09  bl 0x822c8cb8
	ctx.lr = 0x82AA8EB4;
	sub_822C8CB8(ctx, base);
	// 82AA8EB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8EB8: 4834A571  bl 0x82df3428
	ctx.lr = 0x82AA8EBC;
	sub_82DF3428(ctx, base);
	// 82AA8EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8EC0: 4834A569  bl 0x82df3428
	ctx.lr = 0x82AA8EC4;
	sub_82DF3428(ctx, base);
	// 82AA8EC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8EC8: 4BB20E09  bl 0x825c9cd0
	ctx.lr = 0x82AA8ECC;
	sub_825C9CD0(ctx, base);
	// 82AA8ECC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA8ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA8ED4: 419A0008  beq cr6, 0x82aa8edc
	if ctx.cr[6].eq {
	pc = 0x82AA8EDC; continue 'dispatch;
	}
	// 82AA8ED8: 4B8179B9  bl 0x822c0890
	ctx.lr = 0x82AA8EDC;
	sub_822C0890(ctx, base);
	// 82AA8EDC: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82AA8EE0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA8EE4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA8EE8: 486FF2D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA8EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA8EF0 size=972
    let mut pc: u32 = 0x82AA8EF0;
    'dispatch: loop {
        match pc {
            0x82AA8EF0 => {
    //   block [0x82AA8EF0..0x82AA92BC)
	// 82AA8EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA8EF4: 486FF279  bl 0x831a816c
	ctx.lr = 0x82AA8EF8;
	sub_831A8130(ctx, base);
	// 82AA8EF8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82AA8EFC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82AA8F00: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AA8F04: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA8F08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA8F10: 3BCB6ED8  addi r30, r11, 0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + 28376;
	// 82AA8F14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AA8F18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8F1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8F20: 4834AAE9  bl 0x82df3a08
	ctx.lr = 0x82AA8F24;
	sub_82DF3A08(ctx, base);
	// 82AA8F24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA8F28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8F2C: 4834AADD  bl 0x82df3a08
	ctx.lr = 0x82AA8F30;
	sub_82DF3A08(ctx, base);
	// 82AA8F30: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F34: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82AA8F38: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA8F3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA8F40: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA8F44: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82AA8F48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA8F4C: 4E800421  bctrl
	ctx.lr = 0x82AA8F50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA8F50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8F54: 4834A4D5  bl 0x82df3428
	ctx.lr = 0x82AA8F58;
	sub_82DF3428(ctx, base);
	// 82AA8F58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8F5C: 4834A4CD  bl 0x82df3428
	ctx.lr = 0x82AA8F60;
	sub_82DF3428(ctx, base);
	// 82AA8F60: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8F64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8F68: 388B6EBC  addi r4, r11, 0x6ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 28348;
	// 82AA8F6C: 4834AA9D  bl 0x82df3a08
	ctx.lr = 0x82AA8F70;
	sub_82DF3A08(ctx, base);
	// 82AA8F70: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AA8F74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8F78: 388B89A8  addi r4, r11, -0x7658
	ctx.r[4].s64 = ctx.r[11].s64 + -30296;
	// 82AA8F7C: 4834AA8D  bl 0x82df3a08
	ctx.lr = 0x82AA8F80;
	sub_82DF3A08(ctx, base);
	// 82AA8F80: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AA8F84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA8F88: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA8F8C: 4BB21575  bl 0x825ca500
	ctx.lr = 0x82AA8F90;
	sub_825CA500(ctx, base);
	// 82AA8F90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA8F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AA8F98: 4834A491  bl 0x82df3428
	ctx.lr = 0x82AA8F9C;
	sub_82DF3428(ctx, base);
	// 82AA8F9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AA8FA0: 4834A489  bl 0x82df3428
	ctx.lr = 0x82AA8FA4;
	sub_82DF3428(ctx, base);
	// 82AA8FA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8FA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA8FAC: 388B6E94  addi r4, r11, 0x6e94
	ctx.r[4].s64 = ctx.r[11].s64 + 28308;
	// 82AA8FB0: 4834AA59  bl 0x82df3a08
	ctx.lr = 0x82AA8FB4;
	sub_82DF3A08(ctx, base);
	// 82AA8FB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA8FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA8FBC: 388B6E7C  addi r4, r11, 0x6e7c
	ctx.r[4].s64 = ctx.r[11].s64 + 28284;
	// 82AA8FC0: 4834AA49  bl 0x82df3a08
	ctx.lr = 0x82AA8FC4;
	sub_82DF3A08(ctx, base);
	// 82AA8FC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA8FC8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AA8FCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA8FD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA8FD4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA8FD8: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA8FDC: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA8FE0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA8FE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA8FE8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA8FEC: 4BAFA2BD  bl 0x825a32a8
	ctx.lr = 0x82AA8FF0;
	sub_825A32A8(ctx, base);
	// 82AA8FF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA8FF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA8FF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA8FFC: 4BAF8775  bl 0x825a1770
	ctx.lr = 0x82AA9000;
	sub_825A1770(ctx, base);
	// 82AA9000: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AA9004: 4834A425  bl 0x82df3428
	ctx.lr = 0x82AA9008;
	sub_82DF3428(ctx, base);
	// 82AA9008: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AA900C: 4B81FCAD  bl 0x822c8cb8
	ctx.lr = 0x82AA9010;
	sub_822C8CB8(ctx, base);
	// 82AA9010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9014: 4834A415  bl 0x82df3428
	ctx.lr = 0x82AA9018;
	sub_82DF3428(ctx, base);
	// 82AA9018: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA901C: 4834A40D  bl 0x82df3428
	ctx.lr = 0x82AA9020;
	sub_82DF3428(ctx, base);
	// 82AA9020: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9028: 388B6E54  addi r4, r11, 0x6e54
	ctx.r[4].s64 = ctx.r[11].s64 + 28244;
	// 82AA902C: 4834A9DD  bl 0x82df3a08
	ctx.lr = 0x82AA9030;
	sub_82DF3A08(ctx, base);
	// 82AA9030: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA9038: 388B5908  addi r4, r11, 0x5908
	ctx.r[4].s64 = ctx.r[11].s64 + 22792;
	// 82AA903C: 4834A9CD  bl 0x82df3a08
	ctx.lr = 0x82AA9040;
	sub_82DF3A08(ctx, base);
	// 82AA9040: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AA9044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9048: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA904C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA9050: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AA9054: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA9058: 4BAFA251  bl 0x825a32a8
	ctx.lr = 0x82AA905C;
	sub_825A32A8(ctx, base);
	// 82AA905C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA9060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9064: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA9068: 4BAF8709  bl 0x825a1770
	ctx.lr = 0x82AA906C;
	sub_825A1770(ctx, base);
	// 82AA906C: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82AA9070: 4834A3B9  bl 0x82df3428
	ctx.lr = 0x82AA9074;
	sub_82DF3428(ctx, base);
	// 82AA9074: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AA9078: 4B81FC41  bl 0x822c8cb8
	ctx.lr = 0x82AA907C;
	sub_822C8CB8(ctx, base);
	// 82AA907C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA9080: 4834A3A9  bl 0x82df3428
	ctx.lr = 0x82AA9084;
	sub_82DF3428(ctx, base);
	// 82AA9084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9088: 4834A3A1  bl 0x82df3428
	ctx.lr = 0x82AA908C;
	sub_82DF3428(ctx, base);
	// 82AA908C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9094: 388B6E2C  addi r4, r11, 0x6e2c
	ctx.r[4].s64 = ctx.r[11].s64 + 28204;
	// 82AA9098: 4834A971  bl 0x82df3a08
	ctx.lr = 0x82AA909C;
	sub_82DF3A08(ctx, base);
	// 82AA909C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA90A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA90A4: 388B6258  addi r4, r11, 0x6258
	ctx.r[4].s64 = ctx.r[11].s64 + 25176;
	// 82AA90A8: 4834A961  bl 0x82df3a08
	ctx.lr = 0x82AA90AC;
	sub_82DF3A08(ctx, base);
	// 82AA90AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AA90B0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA90B4: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82AA90B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA90BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA90C0: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA90C4: C3AAD0F8  lfs f29, -0x2f08(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AA90C8: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA90CC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA90D0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA90D4: 4BAFA1D5  bl 0x825a32a8
	ctx.lr = 0x82AA90D8;
	sub_825A32A8(ctx, base);
	// 82AA90D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA90DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA90E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA90E4: 4BAF868D  bl 0x825a1770
	ctx.lr = 0x82AA90E8;
	sub_825A1770(ctx, base);
	// 82AA90E8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AA90EC: 4834A33D  bl 0x82df3428
	ctx.lr = 0x82AA90F0;
	sub_82DF3428(ctx, base);
	// 82AA90F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AA90F4: 4B81FBC5  bl 0x822c8cb8
	ctx.lr = 0x82AA90F8;
	sub_822C8CB8(ctx, base);
	// 82AA90F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA90FC: 4834A32D  bl 0x82df3428
	ctx.lr = 0x82AA9100;
	sub_82DF3428(ctx, base);
	// 82AA9100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9104: 4834A325  bl 0x82df3428
	ctx.lr = 0x82AA9108;
	sub_82DF3428(ctx, base);
	// 82AA9108: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA910C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9110: 388B6E04  addi r4, r11, 0x6e04
	ctx.r[4].s64 = ctx.r[11].s64 + 28164;
	// 82AA9114: 4834A8F5  bl 0x82df3a08
	ctx.lr = 0x82AA9118;
	sub_82DF3A08(ctx, base);
	// 82AA9118: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA911C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA9120: 388B6208  addi r4, r11, 0x6208
	ctx.r[4].s64 = ctx.r[11].s64 + 25096;
	// 82AA9124: 4834A8E5  bl 0x82df3a08
	ctx.lr = 0x82AA9128;
	sub_82DF3A08(ctx, base);
	// 82AA9128: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82AA912C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9130: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AA9134: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA9138: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82AA913C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA9140: 4BAFA169  bl 0x825a32a8
	ctx.lr = 0x82AA9144;
	sub_825A32A8(ctx, base);
	// 82AA9144: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA9148: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA914C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9150: 4BAF8621  bl 0x825a1770
	ctx.lr = 0x82AA9154;
	sub_825A1770(ctx, base);
	// 82AA9154: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA9158: 4834A2D1  bl 0x82df3428
	ctx.lr = 0x82AA915C;
	sub_82DF3428(ctx, base);
	// 82AA915C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AA9160: 4B81FB59  bl 0x822c8cb8
	ctx.lr = 0x82AA9164;
	sub_822C8CB8(ctx, base);
	// 82AA9164: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA9168: 4834A2C1  bl 0x82df3428
	ctx.lr = 0x82AA916C;
	sub_82DF3428(ctx, base);
	// 82AA916C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9170: 4834A2B9  bl 0x82df3428
	ctx.lr = 0x82AA9174;
	sub_82DF3428(ctx, base);
	// 82AA9174: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA917C: 388B6DE8  addi r4, r11, 0x6de8
	ctx.r[4].s64 = ctx.r[11].s64 + 28136;
	// 82AA9180: 4834A889  bl 0x82df3a08
	ctx.lr = 0x82AA9184;
	sub_82DF3A08(ctx, base);
	// 82AA9184: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9188: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA918C: 388B61E4  addi r4, r11, 0x61e4
	ctx.r[4].s64 = ctx.r[11].s64 + 25060;
	// 82AA9190: 4834A879  bl 0x82df3a08
	ctx.lr = 0x82AA9194;
	sub_82DF3A08(ctx, base);
	// 82AA9194: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AA9198: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82AA919C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82AA91A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA91A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA91A8: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82AA91AC: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AA91B0: 4BAFA0F9  bl 0x825a32a8
	ctx.lr = 0x82AA91B4;
	sub_825A32A8(ctx, base);
	// 82AA91B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA91B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AA91BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA91C0: 4BAF85B1  bl 0x825a1770
	ctx.lr = 0x82AA91C4;
	sub_825A1770(ctx, base);
	// 82AA91C4: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82AA91C8: 4834A261  bl 0x82df3428
	ctx.lr = 0x82AA91CC;
	sub_82DF3428(ctx, base);
	// 82AA91CC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82AA91D0: 4B81FAE9  bl 0x822c8cb8
	ctx.lr = 0x82AA91D4;
	sub_822C8CB8(ctx, base);
	// 82AA91D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA91D8: 4834A251  bl 0x82df3428
	ctx.lr = 0x82AA91DC;
	sub_82DF3428(ctx, base);
	// 82AA91DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA91E0: 4834A249  bl 0x82df3428
	ctx.lr = 0x82AA91E4;
	sub_82DF3428(ctx, base);
	// 82AA91E4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA91E8: 4BB20AE9  bl 0x825c9cd0
	ctx.lr = 0x82AA91EC;
	sub_825C9CD0(ctx, base);
	// 82AA91EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AA91F0: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82AA91F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA91F8: 4BFE5999  bl 0x82a8eb90
	ctx.lr = 0x82AA91FC;
	sub_82A8EB90(ctx, base);
	// 82AA91FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9204: 4834A805  bl 0x82df3a08
	ctx.lr = 0x82AA9208;
	sub_82DF3A08(ctx, base);
	// 82AA9208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA920C: 4BFE5985  bl 0x82a8eb90
	ctx.lr = 0x82AA9210;
	sub_82A8EB90(ctx, base);
	// 82AA9210: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA9218: 4834A7F1  bl 0x82df3a08
	ctx.lr = 0x82AA921C;
	sub_82DF3A08(ctx, base);
	// 82AA921C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA9220: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AA9224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9228: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AA922C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AA9230: 419A0024  beq cr6, 0x82aa9254
	if ctx.cr[6].eq {
	pc = 0x82AA9254; continue 'dispatch;
	}
	// 82AA9234: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA9238: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA923C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA9240: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA9244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA9248: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA924C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA9250: 4082FFE8  bne 0x82aa9238
	if !ctx.cr[0].eq {
	pc = 0x82AA9238; continue 'dispatch;
	}
	// 82AA9254: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AA9258: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AA925C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AA9260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9264: 4BFFF9FD  bl 0x82aa8c60
	ctx.lr = 0x82AA9268;
	sub_82AA8C60(ctx, base);
	// 82AA9268: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AA926C: 4834A1BD  bl 0x82df3428
	ctx.lr = 0x82AA9270;
	sub_82DF3428(ctx, base);
	// 82AA9270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9274: 4834A1B5  bl 0x82df3428
	ctx.lr = 0x82AA9278;
	sub_82DF3428(ctx, base);
	// 82AA9278: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82AA927C: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82AA9280: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 82AA9284: 4198FF70  blt cr6, 0x82aa91f4
	if ctx.cr[6].lt {
	pc = 0x82AA91F4; continue 'dispatch;
	}
	// 82AA9288: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AA928C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9290: 419A0008  beq cr6, 0x82aa9298
	if ctx.cr[6].eq {
	pc = 0x82AA9298; continue 'dispatch;
	}
	// 82AA9294: 4B8175FD  bl 0x822c0890
	ctx.lr = 0x82AA9298;
	sub_822C0890(ctx, base);
	// 82AA9298: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA929C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA92A0: 419A0008  beq cr6, 0x82aa92a8
	if ctx.cr[6].eq {
	pc = 0x82AA92A8; continue 'dispatch;
	}
	// 82AA92A4: 4B8175ED  bl 0x822c0890
	ctx.lr = 0x82AA92A8;
	sub_822C0890(ctx, base);
	// 82AA92A8: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82AA92AC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AA92B0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AA92B4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AA92B8: 486FEF04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA92C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA92C0 size=128
    let mut pc: u32 = 0x82AA92C0;
    'dispatch: loop {
        match pc {
            0x82AA92C0 => {
    //   block [0x82AA92C0..0x82AA9340)
	// 82AA92C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA92C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AA92C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AA92CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA92D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA92D4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82AA92D8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA92DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA92E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AA92E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AA92E8: 419A0024  beq cr6, 0x82aa930c
	if ctx.cr[6].eq {
	pc = 0x82AA930C; continue 'dispatch;
	}
	// 82AA92EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA92F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA92F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA92F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA92FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA9300: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA9304: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA9308: 4082FFE8  bne 0x82aa92f0
	if !ctx.cr[0].eq {
	pc = 0x82AA92F0; continue 'dispatch;
	}
	// 82AA930C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA9310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9314: 386BE494  addi r3, r11, -0x1b6c
	ctx.r[3].s64 = ctx.r[11].s64 + -7020;
	// 82AA9318: 4BFFFBD9  bl 0x82aa8ef0
	ctx.lr = 0x82AA931C;
	sub_82AA8EF0(ctx, base);
	// 82AA931C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9324: 419A0008  beq cr6, 0x82aa932c
	if ctx.cr[6].eq {
	pc = 0x82AA932C; continue 'dispatch;
	}
	// 82AA9328: 4B817569  bl 0x822c0890
	ctx.lr = 0x82AA932C;
	sub_822C0890(ctx, base);
	// 82AA932C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA9330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AA9334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AA9338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AA933C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9340 size=112
    let mut pc: u32 = 0x82AA9340;
    'dispatch: loop {
        match pc {
            0x82AA9340 => {
    //   block [0x82AA9340..0x82AA93B0)
	// 82AA9340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9344: 486FEE29  bl 0x831a816c
	ctx.lr = 0x82AA9348;
	sub_831A8130(ctx, base);
	// 82AA9348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA934C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9350: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA9354: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA9358: 388B6EF0  addi r4, r11, 0x6ef0
	ctx.r[4].s64 = ctx.r[11].s64 + 28400;
	// 82AA935C: 38A000C0  li r5, 0xc0
	ctx.r[5].s64 = 192;
	// 82AA9360: 386000A4  li r3, 0xa4
	ctx.r[3].s64 = 164;
	// 82AA9364: 48349085  bl 0x82df23e8
	ctx.lr = 0x82AA9368;
	sub_82DF23E8(ctx, base);
	// 82AA9368: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA936C: 41820010  beq 0x82aa937c
	if ctx.cr[0].eq {
	pc = 0x82AA937C; continue 'dispatch;
	}
	// 82AA9370: 4BFFF649  bl 0x82aa89b8
	ctx.lr = 0x82AA9374;
	sub_82AA89B8(ctx, base);
	// 82AA9374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA9378: 48000008  b 0x82aa9380
	pc = 0x82AA9380; continue 'dispatch;
	// 82AA937C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AA9380: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA9384: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AA9388: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA938C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9390: 4BFFF519  bl 0x82aa88a8
	ctx.lr = 0x82AA9394;
	sub_82AA88A8(ctx, base);
	// 82AA9394: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AA9398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA939C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA93A0: 4B816C61  bl 0x822c0000
	ctx.lr = 0x82AA93A4;
	sub_822C0000(ctx, base);
	// 82AA93A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AA93A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AA93AC: 486FEE10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA93B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA93B0 size=2576
    let mut pc: u32 = 0x82AA93B0;
    'dispatch: loop {
        match pc {
            0x82AA93B0 => {
    //   block [0x82AA93B0..0x82AA9DC0)
	// 82AA93B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA93B4: 486FEDA9  bl 0x831a815c
	ctx.lr = 0x82AA93B8;
	sub_831A8130(ctx, base);
	// 82AA93B8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82AA93BC: 486FF6BD  bl 0x831a8a78
	ctx.lr = 0x82AA93C0;
	sub_831A8A40(ctx, base);
	// 82AA93C0: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA93C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AA93C8: 486AB239  bl 0x83154600
	ctx.lr = 0x82AA93CC;
	sub_83154600(ctx, base);
	// 82AA93CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA93D0: 4BE0F919  bl 0x828b8ce8
	ctx.lr = 0x82AA93D4;
	sub_828B8CE8(ctx, base);
	// 82AA93D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA93D8: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA93DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AA93E0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82AA93E4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA93E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AA93EC: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA93F0: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA93F4: C3A81A38  lfs f29, 0x1a38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6712 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AA93F8: 419806C4  blt cr6, 0x82aa9abc
	if ctx.cr[6].lt {
	pc = 0x82AA9ABC; continue 'dispatch;
	}
	// 82AA93FC: 419A0430  beq cr6, 0x82aa982c
	if ctx.cr[6].eq {
	pc = 0x82AA982C; continue 'dispatch;
	}
	// 82AA9400: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AA9404: 41980120  blt cr6, 0x82aa9524
	if ctx.cr[6].lt {
	pc = 0x82AA9524; continue 'dispatch;
	}
	// 82AA9408: 419A0040  beq cr6, 0x82aa9448
	if ctx.cr[6].eq {
	pc = 0x82AA9448; continue 'dispatch;
	}
	// 82AA940C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82AA9410: 40980810  bge cr6, 0x82aa9c20
	if !ctx.cr[6].lt {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9414: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA941C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA9420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9424: 4E800421  bctrl
	ctx.lr = 0x82AA9428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9428: 4BD40EE9  bl 0x827ea310
	ctx.lr = 0x82AA942C;
	sub_827EA310(ctx, base);
	// 82AA942C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA9430: 418207F0  beq 0x82aa9c20
	if ctx.cr[0].eq {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9434: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA9438: 4BDEED61  bl 0x82898198
	ctx.lr = 0x82AA943C;
	sub_82898198(ctx, base);
	// 82AA943C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AA9440: 4BFE3059  bl 0x82a8c498
	ctx.lr = 0x82AA9444;
	sub_82A8C498(ctx, base);
	// 82AA9444: 4800096C  b 0x82aa9db0
	pc = 0x82AA9DB0; continue 'dispatch;
	// 82AA9448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA944C: 483B032D  bl 0x82e59778
	ctx.lr = 0x82AA9450;
	sub_82E59778(ctx, base);
	// 82AA9450: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9454: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA9458: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA945C: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA9460: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA9464: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA9468: 409907B8  ble cr6, 0x82aa9c20
	if !ctx.cr[6].gt {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA946C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA9470: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA9474: 808B9F44  lwz r4, -0x60bc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24764 as u32) ) } as u64;
	// 82AA9478: 4834A591  bl 0x82df3a08
	ctx.lr = 0x82AA947C;
	sub_82DF3A08(ctx, base);
	// 82AA947C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9480: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AA9484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9488: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA948C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9490: 4E800421  bctrl
	ctx.lr = 0x82AA9494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9494: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AA9498: 48349F91  bl 0x82df3428
	ctx.lr = 0x82AA949C;
	sub_82DF3428(ctx, base);
	// 82AA949C: 3BD90010  addi r30, r25, 0x10
	ctx.r[30].s64 = ctx.r[25].s64 + 16;
	// 82AA94A0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA94A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA94A8: 4BA66021  bl 0x8250f4c8
	ctx.lr = 0x82AA94AC;
	sub_8250F4C8(ctx, base);
	// 82AA94AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA94B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA94B4: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82AA94B8: 409A0008  bne cr6, 0x82aa94c0
	if !ctx.cr[6].eq {
	pc = 0x82AA94C0; continue 'dispatch;
	}
	// 82AA94BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA94C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA94C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA94C8: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82AA94CC: 3B8B1FD8  addi r28, r11, 0x1fd8
	ctx.r[28].s64 = ctx.r[11].s64 + 8152;
	// 82AA94D0: 4BD430F9  bl 0x827ec5c8
	ctx.lr = 0x82AA94D4;
	sub_827EC5C8(ctx, base);
	// 82AA94D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA94D8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA94DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA94E0: 3BCB5A2C  addi r30, r11, 0x5a2c
	ctx.r[30].s64 = ctx.r[11].s64 + 23084;
	// 82AA94E4: 4BE60F4D  bl 0x8290a430
	ctx.lr = 0x82AA94E8;
	sub_8290A430(ctx, base);
	// 82AA94E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA94EC: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AA94F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AA94F4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AA94F8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AA94FC: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AA9500: 4809C699  bl 0x82b45b98
	ctx.lr = 0x82AA9504;
	sub_82B45B98(ctx, base);
	// 82AA9504: 80610124  lwz r3, 0x124(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82AA9508: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA950C: 419A0008  beq cr6, 0x82aa9514
	if ctx.cr[6].eq {
	pc = 0x82AA9514; continue 'dispatch;
	}
	// 82AA9510: 4B817381  bl 0x822c0890
	ctx.lr = 0x82AA9514;
	sub_822C0890(ctx, base);
	// 82AA9514: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AA9518: 48348779  bl 0x82df1c90
	ctx.lr = 0x82AA951C;
	sub_82DF1C90(ctx, base);
	// 82AA951C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AA9520: 480006FC  b 0x82aa9c1c
	pc = 0x82AA9C1C; continue 'dispatch;
	// 82AA9524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9528: 483B0251  bl 0x82e59778
	ctx.lr = 0x82AA952C;
	sub_82E59778(ctx, base);
	// 82AA952C: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9530: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA9534: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA9538: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA953C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA9540: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AA9544: 41990250  bgt cr6, 0x82aa9794
	if ctx.cr[6].gt {
	pc = 0x82AA9794; continue 'dispatch;
	}
	// 82AA9548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA954C: 483B022D  bl 0x82e59778
	ctx.lr = 0x82AA9550;
	sub_82E59778(ctx, base);
	// 82AA9550: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9554: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AA9558: D1BF0088  stfs f13, 0x88(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA955C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA9560: 396BE494  addi r11, r11, -0x1b6c
	ctx.r[11].s64 = ctx.r[11].s64 + -7020;
	// 82AA9564: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9568: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA956C: 419806B4  blt cr6, 0x82aa9c20
	if ctx.cr[6].lt {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9570: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9574: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AA9578: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AA957C: 394ACDF4  addi r10, r10, -0x320c
	ctx.r[10].s64 = ctx.r[10].s64 + -12812;
	// 82AA9580: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AA9584: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82AA9588: 4834A481  bl 0x82df3a08
	ctx.lr = 0x82AA958C;
	sub_82DF3A08(ctx, base);
	// 82AA958C: 3B990010  addi r28, r25, 0x10
	ctx.r[28].s64 = ctx.r[25].s64 + 16;
	// 82AA9590: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AA9594: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA9598: 4BD43031  bl 0x827ec5c8
	ctx.lr = 0x82AA959C;
	sub_827EC5C8(ctx, base);
	// 82AA959C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AA95A0: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82AA95A4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82AA95A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA95AC: 4836BA85  bl 0x82e15030
	ctx.lr = 0x82AA95B0;
	sub_82E15030(ctx, base);
	// 82AA95B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA95B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA95B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AA95BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA95C0: 4E800421  bctrl
	ctx.lr = 0x82AA95C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA95C4: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 82AA95C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA95CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA95D0: 419A000C  beq cr6, 0x82aa95dc
	if ctx.cr[6].eq {
	pc = 0x82AA95DC; continue 'dispatch;
	}
	// 82AA95D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AA95D8: 4B8172B9  bl 0x822c0890
	ctx.lr = 0x82AA95DC;
	sub_822C0890(ctx, base);
	// 82AA95DC: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82AA95E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA95E4: 419A0008  beq cr6, 0x82aa95ec
	if ctx.cr[6].eq {
	pc = 0x82AA95EC; continue 'dispatch;
	}
	// 82AA95E8: 4B8172A9  bl 0x822c0890
	ctx.lr = 0x82AA95EC;
	sub_822C0890(ctx, base);
	// 82AA95EC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82AA95F0: 48349E39  bl 0x82df3428
	ctx.lr = 0x82AA95F4;
	sub_82DF3428(ctx, base);
	// 82AA95F4: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 82AA95F8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82AA95FC: 483D33ED  bl 0x82e7c9e8
	ctx.lr = 0x82AA9600;
	sub_82E7C9E8(ctx, base);
	// 82AA9600: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AA9604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA9608: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 82AA960C: 4B81B2F5  bl 0x822c4900
	ctx.lr = 0x82AA9610;
	sub_822C4900(ctx, base);
	// 82AA9610: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9614: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AA9618: 388B6EF0  addi r4, r11, 0x6ef0
	ctx.r[4].s64 = ctx.r[11].s64 + 28400;
	// 82AA961C: 38A00175  li r5, 0x175
	ctx.r[5].s64 = 373;
	// 82AA9620: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82AA9624: 48348DC5  bl 0x82df23e8
	ctx.lr = 0x82AA9628;
	sub_82DF23E8(ctx, base);
	// 82AA9628: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA962C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA9630: 41820068  beq 0x82aa9698
	if ctx.cr[0].eq {
	pc = 0x82AA9698; continue 'dispatch;
	}
	// 82AA9634: C1810224  lfs f12, 0x224(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AA9638: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AA963C: C0010220  lfs f0, 0x220(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9640: 388101F0  addi r4, r1, 0x1f0
	ctx.r[4].s64 = ctx.r[1].s64 + 496;
	// 82AA9644: C1A1022C  lfs f13, 0x22c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA9648: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 82AA964C: C1610228  lfs f11, 0x228(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(552 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AA9650: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AA9654: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AA9658: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AA965C: D1610098  stfs f11, 0x98(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AA9660: C38B0010  lfs f28, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82AA9664: 483D37A5  bl 0x82e7ce08
	ctx.lr = 0x82AA9668;
	sub_82E7CE08(ctx, base);
	// 82AA9668: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA966C: 38790038  addi r3, r25, 0x38
	ctx.r[3].s64 = ctx.r[25].s64 + 56;
	// 82AA9670: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 82AA9674: 4855F945  bl 0x83008fb8
	ctx.lr = 0x82AA9678;
	sub_83008FB8(ctx, base);
	// 82AA9678: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA967C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9680: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82AA9684: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AA9688: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA968C: 4BFEF245  bl 0x82a988d0
	ctx.lr = 0x82AA9690;
	sub_82A988D0(ctx, base);
	// 82AA9690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA9694: 48000008  b 0x82aa969c
	pc = 0x82AA969C; continue 'dispatch;
	// 82AA9698: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82AA969C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82AA96A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA96A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA96A8: 4BFF7811  bl 0x82aa0eb8
	ctx.lr = 0x82AA96AC;
	sub_82AA0EB8(ctx, base);
	// 82AA96AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AA96B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA96B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AA96B8: 4B816949  bl 0x822c0000
	ctx.lr = 0x82AA96BC;
	sub_822C0000(ctx, base);
	// 82AA96BC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AA96C0: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA96C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA96C8: 419A0098  beq cr6, 0x82aa9760
	if ctx.cr[6].eq {
	pc = 0x82AA9760; continue 'dispatch;
	}
	// 82AA96CC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AA96D0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82AA96D4: 409A0008  bne cr6, 0x82aa96dc
	if !ctx.cr[6].eq {
	pc = 0x82AA96DC; continue 'dispatch;
	}
	// 82AA96D8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82AA96DC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82AA96E0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AA96E4: 9361008C  stw r27, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	// 82AA96E8: 419A0024  beq cr6, 0x82aa970c
	if ctx.cr[6].eq {
	pc = 0x82AA970C; continue 'dispatch;
	}
	// 82AA96EC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82AA96F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA96F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA96F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA96FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA9700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA9704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA9708: 4082FFE8  bne 0x82aa96f0
	if !ctx.cr[0].eq {
	pc = 0x82AA96F0; continue 'dispatch;
	}
	// 82AA970C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA9710: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA9714: 4BA65DB5  bl 0x8250f4c8
	ctx.lr = 0x82AA9718;
	sub_8250F4C8(ctx, base);
	// 82AA9718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA971C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9720: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82AA9724: 409A0008  bne cr6, 0x82aa972c
	if !ctx.cr[6].eq {
	pc = 0x82AA972C; continue 'dispatch;
	}
	// 82AA9728: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82AA972C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AA9730: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA9734: 3B810088  addi r28, r1, 0x88
	ctx.r[28].s64 = ctx.r[1].s64 + 136;
	// 82AA9738: 4BA65DE1  bl 0x8250f518
	ctx.lr = 0x82AA973C;
	sub_8250F518(ctx, base);
	// 82AA973C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9744: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AA9748: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA974C: 4BA63DBD  bl 0x8250d508
	ctx.lr = 0x82AA9750;
	sub_8250D508(ctx, base);
	// 82AA9750: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AA9754: 4834853D  bl 0x82df1c90
	ctx.lr = 0x82AA9758;
	sub_82DF1C90(ctx, base);
	// 82AA9758: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AA975C: 48348535  bl 0x82df1c90
	ctx.lr = 0x82AA9760;
	sub_82DF1C90(ctx, base);
	// 82AA9760: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AA9768: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AA976C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82AA9770: 41980008  blt cr6, 0x82aa9778
	if ctx.cr[6].lt {
	pc = 0x82AA9778; continue 'dispatch;
	}
	// 82AA9774: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82AA9778: D3FF0088  stfs f31, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA977C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AA9780: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AA9784: 419A049C  beq cr6, 0x82aa9c20
	if ctx.cr[6].eq {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9788: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AA978C: 4B817105  bl 0x822c0890
	ctx.lr = 0x82AA9790;
	sub_822C0890(ctx, base);
	// 82AA9790: 48000490  b 0x82aa9c20
	pc = 0x82AA9C20; continue 'dispatch;
	// 82AA9794: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AA9798: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AA979C: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA97A0: 4BD25E71  bl 0x827cf610
	ctx.lr = 0x82AA97A4;
	sub_827CF610(ctx, base);
	// 82AA97A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA97A8: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA97AC: 809F0098  lwz r4, 0x98(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA97B0: 4BD25E61  bl 0x827cf610
	ctx.lr = 0x82AA97B4;
	sub_827CF610(ctx, base);
	// 82AA97B4: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 82AA97B8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA97BC: 4BA65D0D  bl 0x8250f4c8
	ctx.lr = 0x82AA97C0;
	sub_8250F4C8(ctx, base);
	// 82AA97C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA97C4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA97C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA97CC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA97D0: 409A0008  bne cr6, 0x82aa97d8
	if !ctx.cr[6].eq {
	pc = 0x82AA97D8; continue 'dispatch;
	}
	// 82AA97D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA97D8: 80BF0098  lwz r5, 0x98(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82AA97DC: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA97E0: 4BD265C1  bl 0x827cfda0
	ctx.lr = 0x82AA97E4;
	sub_827CFDA0(ctx, base);
	// 82AA97E4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AA97E8: 483484A9  bl 0x82df1c90
	ctx.lr = 0x82AA97EC;
	sub_82DF1C90(ctx, base);
	// 82AA97EC: 935F0098  stw r26, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 82AA97F0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA97F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA97F8: 808B9F3C  lwz r4, -0x60c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24772 as u32) ) } as u64;
	// 82AA97FC: 4834A20D  bl 0x82df3a08
	ctx.lr = 0x82AA9800;
	sub_82DF3A08(ctx, base);
	// 82AA9800: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9804: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9808: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AA980C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9814: 4E800421  bctrl
	ctx.lr = 0x82AA9818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9818: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AA981C: 48349C0D  bl 0x82df3428
	ctx.lr = 0x82AA9820;
	sub_82DF3428(ctx, base);
	// 82AA9820: D3FF0084  stfs f31, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA9824: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AA9828: 480003F4  b 0x82aa9c1c
	pc = 0x82AA9C1C; continue 'dispatch;
	// 82AA982C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9830: 483AFF49  bl 0x82e59778
	ctx.lr = 0x82AA9834;
	sub_82E59778(ctx, base);
	// 82AA9834: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9838: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AA983C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA9840: D1BF0084  stfs f13, 0x84(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA9844: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82AA9848: C00BA9F0  lfs f0, -0x5610(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA984C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AA9850: 409800FC  bge cr6, 0x82aa994c
	if !ctx.cr[6].lt {
	pc = 0x82AA994C; continue 'dispatch;
	}
	// 82AA9854: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82AA9858: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA985C: 408200F0  bne 0x82aa994c
	if !ctx.cr[0].eq {
	pc = 0x82AA994C; continue 'dispatch;
	}
	// 82AA9860: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82AA9864: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9868: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 82AA986C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82AA9870: 388B6F64  addi r4, r11, 0x6f64
	ctx.r[4].s64 = ctx.r[11].s64 + 28516;
	// 82AA9874: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AA9878: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82AA987C: 4BFCA34D  bl 0x82a73bc8
	ctx.lr = 0x82AA9880;
	sub_82A73BC8(ctx, base);
	// 82AA9880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9884: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82AA9888: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AA988C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA9890: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AA9894: 419A0024  beq cr6, 0x82aa98b8
	if ctx.cr[6].eq {
	pc = 0x82AA98B8; continue 'dispatch;
	}
	// 82AA9898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AA989C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AA98A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA98A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AA98A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AA98AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AA98B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AA98B4: 4082FFE8  bne 0x82aa989c
	if !ctx.cr[0].eq {
	pc = 0x82AA989C; continue 'dispatch;
	}
	// 82AA98B8: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 82AA98BC: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA98C0: 4BA65C09  bl 0x8250f4c8
	ctx.lr = 0x82AA98C4;
	sub_8250F4C8(ctx, base);
	// 82AA98C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA98C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA98CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AA98D0: 409A0008  bne cr6, 0x82aa98d8
	if !ctx.cr[6].eq {
	pc = 0x82AA98D8; continue 'dispatch;
	}
	// 82AA98D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AA98D8: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 82AA98DC: 4BA5ED3D  bl 0x82508618
	ctx.lr = 0x82AA98E0;
	sub_82508618(ctx, base);
	// 82AA98E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA98E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AA98E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AA98EC: 388B6EF0  addi r4, r11, 0x6ef0
	ctx.r[4].s64 = ctx.r[11].s64 + 28400;
	// 82AA98F0: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 82AA98F4: 38790038  addi r3, r25, 0x38
	ctx.r[3].s64 = ctx.r[25].s64 + 56;
	// 82AA98F8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82AA98FC: 483AF145  bl 0x82e58a40
	ctx.lr = 0x82AA9900;
	sub_82E58A40(ctx, base);
	// 82AA9900: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AA9904: 4834838D  bl 0x82df1c90
	ctx.lr = 0x82AA9908;
	sub_82DF1C90(ctx, base);
	// 82AA9908: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AA990C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9910: 419A0008  beq cr6, 0x82aa9918
	if ctx.cr[6].eq {
	pc = 0x82AA9918; continue 'dispatch;
	}
	// 82AA9914: 4B816F7D  bl 0x822c0890
	ctx.lr = 0x82AA9918;
	sub_822C0890(ctx, base);
	// 82AA9918: 80610154  lwz r3, 0x154(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AA991C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AA9920: 419A0008  beq cr6, 0x82aa9928
	if ctx.cr[6].eq {
	pc = 0x82AA9928; continue 'dispatch;
	}
	// 82AA9924: 4B816F6D  bl 0x822c0890
	ctx.lr = 0x82AA9928;
	sub_822C0890(ctx, base);
	// 82AA9928: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA992C: 4BFD82ED  bl 0x82a81c18
	ctx.lr = 0x82AA9930;
	sub_82A81C18(ctx, base);
	// 82AA9930: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AA9934: 41820010  beq 0x82aa9944
	if ctx.cr[0].eq {
	pc = 0x82AA9944; continue 'dispatch;
	}
	// 82AA9938: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA993C: 808BA070  lwz r4, -0x5f90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24464 as u32) ) } as u64;
	// 82AA9940: 4BFDEF41  bl 0x82a88880
	ctx.lr = 0x82AA9944;
	sub_82A88880(ctx, base);
	// 82AA9944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AA9948: 997F00A0  stb r11, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 82AA994C: C01F0084  lfs f0, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9950: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82AA9954: 409802CC  bge cr6, 0x82aa9c20
	if !ctx.cr[6].lt {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9958: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA995C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA9960: 808B9F40  lwz r4, -0x60c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24768 as u32) ) } as u64;
	// 82AA9964: 4834A0A5  bl 0x82df3a08
	ctx.lr = 0x82AA9968;
	sub_82DF3A08(ctx, base);
	// 82AA9968: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA996C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82AA9970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9974: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA997C: 4E800421  bctrl
	ctx.lr = 0x82AA9980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9980: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AA9984: 48349AA5  bl 0x82df3428
	ctx.lr = 0x82AA9988;
	sub_82DF3428(ctx, base);
	// 82AA9988: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA998C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82AA9990: D3FF0084  stfs f31, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AA9994: 396BE494  addi r11, r11, -0x1b6c
	ctx.r[11].s64 = ctx.r[11].s64 + -7020;
	// 82AA9998: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA999C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AA99A0: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA99A4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA99A8: 935F008C  stw r26, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[26].u32 ) };
	// 82AA99AC: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AA99B0: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82AA99B4: 4BD25C5D  bl 0x827cf610
	ctx.lr = 0x82AA99B8;
	sub_827CF610(ctx, base);
	// 82AA99B8: 3BD90010  addi r30, r25, 0x10
	ctx.r[30].s64 = ctx.r[25].s64 + 16;
	// 82AA99BC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA99C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA99C4: 4BA65B05  bl 0x8250f4c8
	ctx.lr = 0x82AA99C8;
	sub_8250F4C8(ctx, base);
	// 82AA99C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA99CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AA99D0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AA99D4: 409A0008  bne cr6, 0x82aa99dc
	if !ctx.cr[6].eq {
	pc = 0x82AA99DC; continue 'dispatch;
	}
	// 82AA99D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA99DC: 80BF0090  lwz r5, 0x90(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82AA99E0: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA99E4: 4BD263BD  bl 0x827cfda0
	ctx.lr = 0x82AA99E8;
	sub_827CFDA0(ctx, base);
	// 82AA99E8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AA99EC: 483482A5  bl 0x82df1c90
	ctx.lr = 0x82AA99F0;
	sub_82DF1C90(ctx, base);
	// 82AA99F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA99F4: 83BF009C  lwz r29, 0x9c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AA99F8: 4BE60A39  bl 0x8290a430
	ctx.lr = 0x82AA99FC;
	sub_8290A430(ctx, base);
	// 82AA99FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AA9A00: 4809C329  bl 0x82b45d28
	ctx.lr = 0x82AA9A04;
	sub_82B45D28(ctx, base);
	// 82AA9A04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA9A08: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA9A0C: 388B1EBC  addi r4, r11, 0x1ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 7868;
	// 82AA9A10: 48349FF9  bl 0x82df3a08
	ctx.lr = 0x82AA9A14;
	sub_82DF3A08(ctx, base);
	// 82AA9A14: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9A18: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82AA9A1C: 388B638C  addi r4, r11, 0x638c
	ctx.r[4].s64 = ctx.r[11].s64 + 25484;
	// 82AA9A20: 48349FE9  bl 0x82df3a08
	ctx.lr = 0x82AA9A24;
	sub_82DF3A08(ctx, base);
	// 82AA9A24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9A28: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AA9A2C: D3E100C0  stfs f31, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82AA9A30: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82AA9A34: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AA9A38: D3E100C8  stfs f31, 0xc8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AA9A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA9A40: D3E100D0  stfs f31, 0xd0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82AA9A44: 912100B8  stw r9, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82AA9A48: C00B6388  lfs f0, 0x6388(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9A4C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82AA9A50: C1AA7218  lfs f13, 0x7218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA9A54: 3BA100B0  addi r29, r1, 0xb0
	ctx.r[29].s64 = ctx.r[1].s64 + 176;
	// 82AA9A58: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AA9A5C: D1A100CC  stfs f13, 0xcc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AA9A60: D3C100D4  stfs f30, 0xd4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AA9A64: D3C100D8  stfs f30, 0xd8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82AA9A68: D3C100DC  stfs f30, 0xdc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82AA9A6C: 839F0074  lwz r28, 0x74(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AA9A70: 4BD42B59  bl 0x827ec5c8
	ctx.lr = 0x82AA9A74;
	sub_827EC5C8(ctx, base);
	// 82AA9A74: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AA9A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AA9A7C: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82AA9A80: 4BA65A49  bl 0x8250f4c8
	ctx.lr = 0x82AA9A84;
	sub_8250F4C8(ctx, base);
	// 82AA9A84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AA9A88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA9A8C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AA9A90: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AA9A94: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82AA9A98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AA9A9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AA9AA0: 4BD26621  bl 0x827d00c0
	ctx.lr = 0x82AA9AA4;
	sub_827D00C0(ctx, base);
	// 82AA9AA4: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82AA9AA8: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82AA9AAC: 4834997D  bl 0x82df3428
	ctx.lr = 0x82AA9AB0;
	sub_82DF3428(ctx, base);
	// 82AA9AB0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AA9AB4: 48349975  bl 0x82df3428
	ctx.lr = 0x82AA9AB8;
	sub_82DF3428(ctx, base);
	// 82AA9AB8: 48000168  b 0x82aa9c20
	pc = 0x82AA9C20; continue 'dispatch;
	// 82AA9ABC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9AC4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA9AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9ACC: 4E800421  bctrl
	ctx.lr = 0x82AA9AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9AD0: 4BD40841  bl 0x827ea310
	ctx.lr = 0x82AA9AD4;
	sub_827EA310(ctx, base);
	// 82AA9AD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA9AD8: 41820148  beq 0x82aa9c20
	if ctx.cr[0].eq {
	pc = 0x82AA9C20; continue 'dispatch;
	}
	// 82AA9ADC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA9AE0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AA9AE4: 808B9F3C  lwz r4, -0x60c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24772 as u32) ) } as u64;
	// 82AA9AE8: 48349F21  bl 0x82df3a08
	ctx.lr = 0x82AA9AEC;
	sub_82DF3A08(ctx, base);
	// 82AA9AEC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9AF0: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82AA9AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9AF8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9AFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9B00: 4E800421  bctrl
	ctx.lr = 0x82AA9B04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9B04: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AA9B08: 48349921  bl 0x82df3428
	ctx.lr = 0x82AA9B0C;
	sub_82DF3428(ctx, base);
	// 82AA9B0C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA9B10: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82AA9B14: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 82AA9B18: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82AA9B1C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82AA9B20: 38E10230  addi r7, r1, 0x230
	ctx.r[7].s64 = ctx.r[1].s64 + 560;
	// 82AA9B24: 38C10240  addi r6, r1, 0x240
	ctx.r[6].s64 = ctx.r[1].s64 + 576;
	// 82AA9B28: 38A10250  addi r5, r1, 0x250
	ctx.r[5].s64 = ctx.r[1].s64 + 592;
	// 82AA9B2C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA9B30: 3BC10260  addi r30, r1, 0x260
	ctx.r[30].s64 = ctx.r[1].s64 + 608;
	// 82AA9B34: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA9B38: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA9B3C: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 82AA9B40: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AA9B44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AA9DC0 size=128
    let mut pc: u32 = 0x82AA9DC0;
    'dispatch: loop {
        match pc {
            0x82AA9DC0 => {
    //   block [0x82AA9DC0..0x82AA9E40)
	// 82AA9DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9DC4: 486FE3A9  bl 0x831a816c
	ctx.lr = 0x82AA9DC8;
	sub_831A8130(ctx, base);
	// 82AA9DC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9DCC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AA9DD0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA9DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA9DD8: 3BEBE484  addi r31, r11, -0x1b7c
	ctx.r[31].s64 = ctx.r[11].s64 + -7036;
	// 82AA9DDC: 816AE48C  lwz r11, -0x1b74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7028 as u32) ) } as u64;
	// 82AA9DE0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AA9DE4: 40820024  bne 0x82aa9e08
	if !ctx.cr[0].eq {
	pc = 0x82AA9E08; continue 'dispatch;
	}
	// 82AA9DE8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82AA9DEC: 3D0082AB  lis r8, -0x7d55
	ctx.r[8].s64 = -2102722560;
	// 82AA9DF0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AA9DF4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82AA9DF8: 39088970  addi r8, r8, -0x7690
	ctx.r[8].s64 = ctx.r[8].s64 + -30352;
	// 82AA9DFC: 916AE48C  stw r11, -0x1b74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7028 as u32), ctx.r[11].u32 ) };
	// 82AA9E00: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AA9E04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AA9E08: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AA9E0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AA9E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AA9E14: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82AA9E18: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82AA9E1C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AA9E20: 4BBAA7A1  bl 0x826545c0
	ctx.lr = 0x82AA9E24;
	sub_826545C0(ctx, base);
	// 82AA9E24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AA9E28: 4182000C  beq 0x82aa9e34
	if ctx.cr[0].eq {
	pc = 0x82AA9E34; continue 'dispatch;
	}
	// 82AA9E2C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AA9E30: 48000008  b 0x82aa9e38
	pc = 0x82AA9E38; continue 'dispatch;
	// 82AA9E34: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AA9E38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AA9E3C: 486FE380  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AA9E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AA9E40 size=1608
    let mut pc: u32 = 0x82AA9E40;
    'dispatch: loop {
        match pc {
            0x82AA9E40 => {
    //   block [0x82AA9E40..0x82AAA488)
	// 82AA9E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AA9E44: 486FE305  bl 0x831a8148
	ctx.lr = 0x82AA9E48;
	sub_831A8130(ctx, base);
	// 82AA9E48: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82AA9E4C: 486FEC2D  bl 0x831a8a78
	ctx.lr = 0x82AA9E50;
	sub_831A8A40(ctx, base);
	// 82AA9E50: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AA9E54: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82AA9E58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AA9E5C: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 82AA9E60: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82AA9E64: 486AA79D  bl 0x83154600
	ctx.lr = 0x82AA9E68;
	sub_83154600(ctx, base);
	// 82AA9E68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AA9E6C: 4BE0EE7D  bl 0x828b8ce8
	ctx.lr = 0x82AA9E70;
	sub_828B8CE8(ctx, base);
	// 82AA9E70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9E74: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AA9E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9E7C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AA9E80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9E84: 4E800421  bctrl
	ctx.lr = 0x82AA9E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9E88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AA9E8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9E90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AA9E94: 4BFDE7FD  bl 0x82a88690
	ctx.lr = 0x82AA9E98;
	sub_82A88690(ctx, base);
	// 82AA9E98: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA9E9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9EA0: 808BCA1C  lwz r4, -0x35e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13796 as u32) ) } as u64;
	// 82AA9EA4: 48349B65  bl 0x82df3a08
	ctx.lr = 0x82AA9EA8;
	sub_82DF3A08(ctx, base);
	// 82AA9EA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9EAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9EB0: 4BD458C1  bl 0x827ef770
	ctx.lr = 0x82AA9EB4;
	sub_827EF770(ctx, base);
	// 82AA9EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9EB8: 48349571  bl 0x82df3428
	ctx.lr = 0x82AA9EBC;
	sub_82DF3428(ctx, base);
	// 82AA9EBC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AA9EC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9EC4: 808B9F38  lwz r4, -0x60c8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24776 as u32) ) } as u64;
	// 82AA9EC8: 48349B41  bl 0x82df3a08
	ctx.lr = 0x82AA9ECC;
	sub_82DF3A08(ctx, base);
	// 82AA9ECC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9ED4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9ED8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AA9EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9EE0: 4E800421  bctrl
	ctx.lr = 0x82AA9EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9EE8: 48349541  bl 0x82df3428
	ctx.lr = 0x82AA9EEC;
	sub_82DF3428(ctx, base);
	// 82AA9EEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA9EF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AA9EF4: 4BFDAA75  bl 0x82a84968
	ctx.lr = 0x82AA9EF8;
	sub_82A84968(ctx, base);
	// 82AA9EF8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AA9EFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA9F00: 3BEBE494  addi r31, r11, -0x1b6c
	ctx.r[31].s64 = ctx.r[11].s64 + -7020;
	// 82AA9F04: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82AA9F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9F0C: C00BE494  lfs f0, -0x1b6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AA9F10: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AA9F14: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AA9F18: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AA9F1C: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82AA9F20: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82AA9F24: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82AA9F28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9F2C: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AA9F30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9F34: 4E800421  bctrl
	ctx.lr = 0x82AA9F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9F38: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AA9F3C: 4BFD777D  bl 0x82a816b8
	ctx.lr = 0x82AA9F40;
	sub_82A816B8(ctx, base);
	// 82AA9F40: 1D430014  mulli r10, r3, 0x14
	ctx.r[10].s64 = ctx.r[3].s64 * 20;
	// 82AA9F44: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82AA9F48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AA9F4C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AA9F50: 917D0060  stw r11, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AA9F54: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9F58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AA9F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AA9F60: 4E800421  bctrl
	ctx.lr = 0x82AA9F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AA9F64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AA9F68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9F6C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AA9F70: C3CA08A8  lfs f30, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AA9F74: 3B0B6EF0  addi r24, r11, 0x6ef0
	ctx.r[24].s64 = ctx.r[11].s64 + 28400;
	// 82AA9F78: 41820220  beq 0x82aaa198
	if ctx.cr[0].eq {
	pc = 0x82AAA198; continue 'dispatch;
	}
	// 82AA9F7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA9F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9F84: 3B6B1EBC  addi r27, r11, 0x1ebc
	ctx.r[27].s64 = ctx.r[11].s64 + 7868;
	// 82AA9F88: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AA9F8C: 48349A7D  bl 0x82df3a08
	ctx.lr = 0x82AA9F90;
	sub_82DF3A08(ctx, base);
	// 82AA9F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9F98: 48103CC9  bl 0x82badc60
	ctx.lr = 0x82AA9F9C;
	sub_82BADC60(ctx, base);
	// 82AA9F9C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82AA9FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9FA4: 48349485  bl 0x82df3428
	ctx.lr = 0x82AA9FA8;
	sub_82DF3428(ctx, base);
	// 82AA9FA8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AA9FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9FB0: 3B4B5A18  addi r26, r11, 0x5a18
	ctx.r[26].s64 = ctx.r[11].s64 + 23064;
	// 82AA9FB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AA9FB8: 48349A51  bl 0x82df3a08
	ctx.lr = 0x82AA9FBC;
	sub_82DF3A08(ctx, base);
	// 82AA9FBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AA9FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AA9FC4: 48103C9D  bl 0x82badc60
	ctx.lr = 0x82AA9FC8;
	sub_82BADC60(ctx, base);
	// 82AA9FC8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82AA9FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AA9FD0: 48349459  bl 0x82df3428
	ctx.lr = 0x82AA9FD4;
	sub_82DF3428(ctx, base);
	// 82AA9FD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AA9FD8: D3E100D0  stfs f31, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82AA9FDC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AA9FE0: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AA9FE4: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82AA9FE8: D3C100D8  stfs f30, 0xd8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82AA9FEC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 82AA9FF0: D3E100DC  stfs f31, 0xdc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82AA9FF4: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82AA9FF8: C3AB9534  lfs f29, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AA9FFC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82AAA000: D3A100B0  stfs f29, 0xb0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82AAA004: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAA008: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82AAA00C: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82AAA010: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AAA014: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA018: C38ACEE4  lfs f28, -0x311c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82AAA01C: EC200732  fmuls f1, f0, f28
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82AAA020: 4BED31D1  bl 0x8297d1f0
	ctx.lr = 0x82AAA024;
	sub_8297D1F0(ctx, base);
	// 82AAA024: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AAA028: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAA02C: 38A000F5  li r5, 0xf5
	ctx.r[5].s64 = 245;
	// 82AAA030: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82AAA034: 4B8163A5  bl 0x822c03d8
	ctx.lr = 0x82AAA038;
	sub_822C03D8(ctx, base);
	// 82AAA038: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA03C: 41820020  beq 0x82aaa05c
	if ctx.cr[0].eq {
	pc = 0x82AAA05C; continue 'dispatch;
	}
	// 82AAA040: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AAA044: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AAA048: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAA04C: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAA050: 4BED31E9  bl 0x8297d238
	ctx.lr = 0x82AAA054;
	sub_8297D238(ctx, base);
	// 82AAA054: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA058: 48000008  b 0x82aaa060
	pc = 0x82AAA060; continue 'dispatch;
	// 82AAA05C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82AAA060: 387D0064  addi r3, r29, 0x64
	ctx.r[3].s64 = ctx.r[29].s64 + 100;
	// 82AAA064: 4BFF72AD  bl 0x82aa1310
	ctx.lr = 0x82AAA068;
	sub_82AA1310(ctx, base);
	// 82AAA068: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AAA06C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA070: 48349999  bl 0x82df3a08
	ctx.lr = 0x82AAA074;
	sub_82DF3A08(ctx, base);
	// 82AAA074: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAA078: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA07C: 48103BE5  bl 0x82badc60
	ctx.lr = 0x82AAA080;
	sub_82BADC60(ctx, base);
	// 82AAA080: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AAA084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA088: 483493A1  bl 0x82df3428
	ctx.lr = 0x82AAA08C;
	sub_82DF3428(ctx, base);
	// 82AAA08C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AAA090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA094: 48349975  bl 0x82df3a08
	ctx.lr = 0x82AAA098;
	sub_82DF3A08(ctx, base);
	// 82AAA098: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAA09C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA0A0: 48103BC1  bl 0x82badc60
	ctx.lr = 0x82AAA0A4;
	sub_82BADC60(ctx, base);
	// 82AAA0A4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AAA0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA0AC: 4834937D  bl 0x82df3428
	ctx.lr = 0x82AAA0B0;
	sub_82DF3428(ctx, base);
	// 82AAA0B0: D3E100C0  stfs f31, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82AAA0B4: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AAA0B8: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 82AAA0BC: D3E100C8  stfs f31, 0xc8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AAA0C0: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 82AAA0C4: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AAA0C8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82AAA0CC: D3A100E0  stfs f29, 0xe0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82AAA0D0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AAA0D4: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82AAA0D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAA0DC: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82AAA0E0: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82AAA0E4: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA0E8: EC200732  fmuls f1, f0, f28
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82AAA0EC: 4BED3105  bl 0x8297d1f0
	ctx.lr = 0x82AAA0F0;
	sub_8297D1F0(ctx, base);
	// 82AAA0F0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AAA0F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAA0F8: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 82AAA0FC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82AAA100: 4B8162D9  bl 0x822c03d8
	ctx.lr = 0x82AAA104;
	sub_822C03D8(ctx, base);
	// 82AAA104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA108: 41820020  beq 0x82aaa128
	if ctx.cr[0].eq {
	pc = 0x82AAA128; continue 'dispatch;
	}
	// 82AAA10C: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AAA110: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AAA114: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAA118: C02B000C  lfs f1, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAA11C: 4BED311D  bl 0x8297d238
	ctx.lr = 0x82AAA120;
	sub_8297D238(ctx, base);
	// 82AAA120: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA124: 48000008  b 0x82aaa12c
	pc = 0x82AAA12C; continue 'dispatch;
	// 82AAA128: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82AAA12C: 387D006C  addi r3, r29, 0x6c
	ctx.r[3].s64 = ctx.r[29].s64 + 108;
	// 82AAA130: 4BFF71E1  bl 0x82aa1310
	ctx.lr = 0x82AAA134;
	sub_82AA1310(ctx, base);
	// 82AAA134: 3D6082AB  lis r11, -0x7d55
	ctx.r[11].s64 = -2102722560;
	// 82AAA138: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AAA13C: 93A10128  stw r29, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[29].u32 ) };
	// 82AAA140: 396B8800  addi r11, r11, -0x7800
	ctx.r[11].s64 = ctx.r[11].s64 + -30720;
	// 82AAA144: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 82AAA148: E8A10128  ld r5, 0x128(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) };
	// 82AAA14C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAA150: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AAA154: 92C10140  stw r22, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[22].u32 ) };
	// 82AAA158: 4BFFFC69  bl 0x82aa9dc0
	ctx.lr = 0x82AAA15C;
	sub_82AA9DC0(ctx, base);
	// 82AAA15C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAA160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA164: 808BCDF0  lwz r4, -0x3210(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12816 as u32) ) } as u64;
	// 82AAA168: 483498A1  bl 0x82df3a08
	ctx.lr = 0x82AAA16C;
	sub_82DF3A08(ctx, base);
	// 82AAA16C: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 82AAA170: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AAA174: 4BAE1D9D  bl 0x8258bf10
	ctx.lr = 0x82AAA178;
	sub_8258BF10(ctx, base);
	// 82AAA178: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAA17C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAA180: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAA184: 4BD40685  bl 0x827ea808
	ctx.lr = 0x82AAA188;
	sub_827EA808(ctx, base);
	// 82AAA188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA18C: 4834929D  bl 0x82df3428
	ctx.lr = 0x82AAA190;
	sub_82DF3428(ctx, base);
	// 82AAA190: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AAA194: 4B81EB25  bl 0x822c8cb8
	ctx.lr = 0x82AAA198;
	sub_822C8CB8(ctx, base);
	// 82AAA198: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AAA19C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAA1A0: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 82AAA1A4: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82AAA1A8: 48348241  bl 0x82df23e8
	ctx.lr = 0x82AAA1AC;
	sub_82DF23E8(ctx, base);
	// 82AAA1AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAA1B0: 41820034  beq 0x82aaa1e4
	if ctx.cr[0].eq {
	pc = 0x82AAA1E4; continue 'dispatch;
	}
	// 82AAA1B4: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 82AAA1B8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AAA1BC: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82AAA1C0: 4BA65309  bl 0x8250f4c8
	ctx.lr = 0x82AAA1C4;
	sub_8250F4C8(ctx, base);
	// 82AAA1C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA1CC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AAA1D0: 409A0008  bne cr6, 0x82aaa1d8
	if !ctx.cr[6].eq {
	pc = 0x82AAA1D8; continue 'dispatch;
	}
	// 82AAA1D4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82AAA1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA1DC: 4BD26375  bl 0x827d0550
	ctx.lr = 0x82AAA1E0;
	sub_827D0550(ctx, base);
	// 82AAA1E0: 48000008  b 0x82aaa1e8
	pc = 0x82AAA1E8; continue 'dispatch;
	// 82AAA1E4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82AAA1E8: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AAA1EC: 3BFD0074  addi r31, r29, 0x74
	ctx.r[31].s64 = ctx.r[29].s64 + 116;
	// 82AAA1F0: 907D0074  stw r3, 0x74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82AAA1F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA1F8: 419A001C  beq cr6, 0x82aaa214
	if ctx.cr[6].eq {
	pc = 0x82AAA214; continue 'dispatch;
	}
	// 82AAA1FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA200: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AAA204: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAA208: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA20C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA210: 4E800421  bctrl
	ctx.lr = 0x82AAA214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAA214: 56EB07FF  clrlwi. r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAA218: 41820010  beq 0x82aaa228
	if ctx.cr[0].eq {
	pc = 0x82AAA228; continue 'dispatch;
	}
	// 82AAA21C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AAA220: 56F7003C  rlwinm r23, r23, 0, 0, 0x1e
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 82AAA224: 48347A6D  bl 0x82df1c90
	ctx.lr = 0x82AAA228;
	sub_82DF1C90(ctx, base);
	// 82AAA228: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AAA22C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAA230: 388BC77C  addi r4, r11, -0x3884
	ctx.r[4].s64 = ctx.r[11].s64 + -14468;
	// 82AAA234: 483497D5  bl 0x82df3a08
	ctx.lr = 0x82AAA238;
	sub_82DF3A08(ctx, base);
	// 82AAA238: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA23C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAA240: 388B63CC  addi r4, r11, 0x63cc
	ctx.r[4].s64 = ctx.r[11].s64 + 25548;
	// 82AAA244: 483497C5  bl 0x82df3a08
	ctx.lr = 0x82AAA248;
	sub_82DF3A08(ctx, base);
	// 82AAA248: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAA24C: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82AAA250: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AAA254: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AAA258: 3BD90010  addi r30, r25, 0x10
	ctx.r[30].s64 = ctx.r[25].s64 + 16;
	// 82AAA25C: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AAA260: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AAA264: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AAA268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA26C: C00B95A0  lfs f0, -0x6a60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA274: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AAA278: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 82AAA27C: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AAA280: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AAA284: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AAA288: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AAA28C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA290: 4BD42339  bl 0x827ec5c8
	ctx.lr = 0x82AAA294;
	sub_827EC5C8(ctx, base);
	// 82AAA294: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AAA298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA29C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AAA2A0: 4BA65229  bl 0x8250f4c8
	ctx.lr = 0x82AAA2A4;
	sub_8250F4C8(ctx, base);
	// 82AAA2A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA2AC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AAA2B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AAA2B4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82AAA2B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AAA2BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAA2C0: 4BD25E01  bl 0x827d00c0
	ctx.lr = 0x82AAA2C4;
	sub_827D00C0(ctx, base);
	// 82AAA2C4: 907D0090  stw r3, 0x90(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82AAA2C8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAA2CC: 4834915D  bl 0x82df3428
	ctx.lr = 0x82AAA2D0;
	sub_82DF3428(ctx, base);
	// 82AAA2D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAA2D4: 48349155  bl 0x82df3428
	ctx.lr = 0x82AAA2D8;
	sub_82DF3428(ctx, base);
	// 82AAA2D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA2DC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AAA2E0: 4BA651E9  bl 0x8250f4c8
	ctx.lr = 0x82AAA2E4;
	sub_8250F4C8(ctx, base);
	// 82AAA2E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA2EC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AAA2F0: 409A0008  bne cr6, 0x82aaa2f8
	if !ctx.cr[6].eq {
	pc = 0x82AAA2F8; continue 'dispatch;
	}
	// 82AAA2F4: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 82AAA2F8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA2FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA300: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82AAA304: 3B8B1FD8  addi r28, r11, 0x1fd8
	ctx.r[28].s64 = ctx.r[11].s64 + 8152;
	// 82AAA308: 4BD422C1  bl 0x827ec5c8
	ctx.lr = 0x82AAA30C;
	sub_827EC5C8(ctx, base);
	// 82AAA30C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AAA310: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA318: 3B4B6F70  addi r26, r11, 0x6f70
	ctx.r[26].s64 = ctx.r[11].s64 + 28528;
	// 82AAA31C: 4BE60115  bl 0x8290a430
	ctx.lr = 0x82AAA320;
	sub_8290A430(ctx, base);
	// 82AAA320: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA324: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AAA328: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAA32C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82AAA330: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82AAA334: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82AAA338: 4809B861  bl 0x82b45b98
	ctx.lr = 0x82AAA33C;
	sub_82B45B98(ctx, base);
	// 82AAA33C: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AAA340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA344: 419A0008  beq cr6, 0x82aaa34c
	if ctx.cr[6].eq {
	pc = 0x82AAA34C; continue 'dispatch;
	}
	// 82AAA348: 4B816549  bl 0x822c0890
	ctx.lr = 0x82AAA34C;
	sub_822C0890(ctx, base);
	// 82AAA34C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82AAA350: 48347941  bl 0x82df1c90
	ctx.lr = 0x82AAA354;
	sub_82DF1C90(ctx, base);
	// 82AAA354: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82AAA358: 9AC10058  stb r22, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u8 ) };
	// 82AAA35C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AAA360: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AAA364: 388BFE78  addi r4, r11, -0x188
	ctx.r[4].s64 = ctx.r[11].s64 + -392;
	// 82AAA368: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AAA36C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82AAA370: 4BFC9859  bl 0x82a73bc8
	ctx.lr = 0x82AAA374;
	sub_82A73BC8(ctx, base);
	// 82AAA374: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA378: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AAA37C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA384: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AAA388: 419A0024  beq cr6, 0x82aaa3ac
	if ctx.cr[6].eq {
	pc = 0x82AAA3AC; continue 'dispatch;
	}
	// 82AAA38C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AAA390: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAA394: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAA398: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAA39C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAA3A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAA3A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAA3A8: 4082FFE8  bne 0x82aaa390
	if !ctx.cr[0].eq {
	pc = 0x82AAA390; continue 'dispatch;
	}
	// 82AAA3AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA3B0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AAA3B4: 4BA65115  bl 0x8250f4c8
	ctx.lr = 0x82AAA3B8;
	sub_8250F4C8(ctx, base);
	// 82AAA3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA3C0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AAA3C4: 409A0008  bne cr6, 0x82aaa3cc
	if !ctx.cr[6].eq {
	pc = 0x82AAA3CC; continue 'dispatch;
	}
	// 82AAA3C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82AAA3CC: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82AAA3D0: 4BA5E249  bl 0x82508618
	ctx.lr = 0x82AAA3D4;
	sub_82508618(ctx, base);
	// 82AAA3D4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAA3D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAA3DC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AAA3E0: 38A00115  li r5, 0x115
	ctx.r[5].s64 = 277;
	// 82AAA3E4: 38790038  addi r3, r25, 0x38
	ctx.r[3].s64 = ctx.r[25].s64 + 56;
	// 82AAA3E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AAA3EC: 483AE655  bl 0x82e58a40
	ctx.lr = 0x82AAA3F0;
	sub_82E58A40(ctx, base);
	// 82AAA3F0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AAA3F4: 4834789D  bl 0x82df1c90
	ctx.lr = 0x82AAA3F8;
	sub_82DF1C90(ctx, base);
	// 82AAA3F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AAA3FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA400: 419A0008  beq cr6, 0x82aaa408
	if ctx.cr[6].eq {
	pc = 0x82AAA408; continue 'dispatch;
	}
	// 82AAA404: 4B81648D  bl 0x822c0890
	ctx.lr = 0x82AAA408;
	sub_822C0890(ctx, base);
	// 82AAA408: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82AAA40C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA410: 419A0008  beq cr6, 0x82aaa418
	if ctx.cr[6].eq {
	pc = 0x82AAA418; continue 'dispatch;
	}
	// 82AAA414: 4B81647D  bl 0x822c0890
	ctx.lr = 0x82AAA418;
	sub_822C0890(ctx, base);
	// 82AAA418: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82AAA41C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAA420: 38A00118  li r5, 0x118
	ctx.r[5].s64 = 280;
	// 82AAA424: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82AAA428: 4B815FB1  bl 0x822c03d8
	ctx.lr = 0x82AAA42C;
	sub_822C03D8(ctx, base);
	// 82AAA42C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAA430: 41820028  beq 0x82aaa458
	if ctx.cr[0].eq {
	pc = 0x82AAA458; continue 'dispatch;
	}
	// 82AAA434: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAA438: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AAA43C: 62F70002  ori r23, r23, 2
	ctx.r[23].u64 = ctx.r[23].u64 | 2;
	// 82AAA440: 4BA650D9  bl 0x8250f518
	ctx.lr = 0x82AAA444;
	sub_8250F518(ctx, base);
	// 82AAA444: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA44C: 4B9E6CA5  bl 0x824910f0
	ctx.lr = 0x82AAA450;
	sub_824910F0(ctx, base);
	// 82AAA450: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAA454: 48000008  b 0x82aaa45c
	pc = 0x82AAA45C; continue 'dispatch;
	// 82AAA458: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82AAA45C: 387D0078  addi r3, r29, 0x78
	ctx.r[3].s64 = ctx.r[29].s64 + 120;
	// 82AAA460: 4B860281  bl 0x8230a6e0
	ctx.lr = 0x82AAA464;
	sub_8230A6E0(ctx, base);
	// 82AAA464: 56EB07BD  rlwinm. r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAA468: 4182000C  beq 0x82aaa474
	if ctx.cr[0].eq {
	pc = 0x82AAA474; continue 'dispatch;
	}
	// 82AAA46C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AAA470: 48347821  bl 0x82df1c90
	ctx.lr = 0x82AAA474;
	sub_82DF1C90(ctx, base);
	// 82AAA474: 92DD0080  stw r22, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 82AAA478: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82AAA47C: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82AAA480: 486FE645  bl 0x831a8ac4
	ctx.lr = 0x82AAA484;
	sub_831A8A8C(ctx, base);
	// 82AAA484: 486FDD14  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAA488 size=20
    let mut pc: u32 = 0x82AAA488;
    'dispatch: loop {
        match pc {
            0x82AAA488 => {
    //   block [0x82AAA488..0x82AAA49C)
	// 82AAA488: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA48C: D0230004  stfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAA490: 396B6FA4  addi r11, r11, 0x6fa4
	ctx.r[11].s64 = ctx.r[11].s64 + 28580;
	// 82AAA494: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA4A0 size=100
    let mut pc: u32 = 0x82AAA4A0;
    'dispatch: loop {
        match pc {
            0x82AAA4A0 => {
    //   block [0x82AAA4A0..0x82AAA504)
	// 82AAA4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA4A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA4A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA4AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAA4B8: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAA4BC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA4C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AAA4C4: 4099002C  ble cr6, 0x82aaa4f0
	if !ctx.cr[6].gt {
	pc = 0x82AAA4F0; continue 'dispatch;
	}
	// 82AAA4C8: 483AF299  bl 0x82e59760
	ctx.lr = 0x82AAA4CC;
	sub_82E59760(ctx, base);
	// 82AAA4CC: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA4D0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AAA4D4: 4099001C  ble cr6, 0x82aaa4f0
	if !ctx.cr[6].gt {
	pc = 0x82AAA4F0; continue 'dispatch;
	}
	// 82AAA4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA4DC: 486AA125  bl 0x83154600
	ctx.lr = 0x82AAA4E0;
	sub_83154600(ctx, base);
	// 82AAA4E0: 4BE0E809  bl 0x828b8ce8
	ctx.lr = 0x82AAA4E4;
	sub_828B8CE8(ctx, base);
	// 82AAA4E4: 4BDEDCB5  bl 0x82898198
	ctx.lr = 0x82AAA4E8;
	sub_82898198(ctx, base);
	// 82AAA4E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA4EC: 4BFE1FAD  bl 0x82a8c498
	ctx.lr = 0x82AAA4F0;
	sub_82A8C498(ctx, base);
	// 82AAA4F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAA4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA4FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA508 size=124
    let mut pc: u32 = 0x82AAA508;
    'dispatch: loop {
        match pc {
            0x82AAA508 => {
    //   block [0x82AAA508..0x82AAA584)
	// 82AAA508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA514: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA51C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAA520: 419A004C  beq cr6, 0x82aaa56c
	if ctx.cr[6].eq {
	pc = 0x82AAA56C; continue 'dispatch;
	}
	// 82AAA524: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA52C: 419A0018  beq cr6, 0x82aaa544
	if ctx.cr[6].eq {
	pc = 0x82AAA544; continue 'dispatch;
	}
	// 82AAA530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA53C: 4E800421  bctrl
	ctx.lr = 0x82AAA540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAA540: 4800000C  b 0x82aaa54c
	pc = 0x82AAA54C; continue 'dispatch;
	// 82AAA544: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AAA548: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AAA54C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAA550: 388BCFA4  addi r4, r11, -0x305c
	ctx.r[4].s64 = ctx.r[11].s64 + -12380;
	// 82AAA554: 486FDBA5  bl 0x831a80f8
	ctx.lr = 0x82AAA558;
	sub_831A80F8(ctx, base);
	// 82AAA558: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAA55C: 41820010  beq 0x82aaa56c
	if ctx.cr[0].eq {
	pc = 0x82AAA56C; continue 'dispatch;
	}
	// 82AAA560: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA564: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AAA568: 48000008  b 0x82aaa570
	pc = 0x82AAA570; continue 'dispatch;
	// 82AAA56C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAA570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAA574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA57C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAA588 size=12
    let mut pc: u32 = 0x82AAA588;
    'dispatch: loop {
        match pc {
            0x82AAA588 => {
    //   block [0x82AAA588..0x82AAA594)
	// 82AAA588: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAA58C: 386BCFA4  addi r3, r11, -0x305c
	ctx.r[3].s64 = ctx.r[11].s64 + -12380;
	// 82AAA590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA598 size=96
    let mut pc: u32 = 0x82AAA598;
    'dispatch: loop {
        match pc {
            0x82AAA598 => {
    //   block [0x82AAA598..0x82AAA5F8)
	// 82AAA598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA5A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA5AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AAA5B0: 4B816389  bl 0x822c0938
	ctx.lr = 0x82AAA5B4;
	sub_822C0938(ctx, base);
	// 82AAA5B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA5B8: 41820028  beq 0x82aaa5e0
	if ctx.cr[0].eq {
	pc = 0x82AAA5E0; continue 'dispatch;
	}
	// 82AAA5BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA5C0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAA5C4: 396B6FC0  addi r11, r11, 0x6fc0
	ctx.r[11].s64 = ctx.r[11].s64 + 28608;
	// 82AAA5C8: 394A6FA4  addi r10, r10, 0x6fa4
	ctx.r[10].s64 = ctx.r[10].s64 + 28580;
	// 82AAA5CC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA5D0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAA5D4: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA5D8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAA5DC: 48000008  b 0x82aaa5e4
	pc = 0x82AAA5E4; continue 'dispatch;
	// 82AAA5E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAA5E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAA5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA5F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA5F8 size=108
    let mut pc: u32 = 0x82AAA5F8;
    'dispatch: loop {
        match pc {
            0x82AAA5F8 => {
    //   block [0x82AAA5F8..0x82AAA664)
	// 82AAA5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA604: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA60C: 4BFEF88D  bl 0x82a99e98
	ctx.lr = 0x82AAA610;
	sub_82A99E98(ctx, base);
	// 82AAA610: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAA614: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAA618: 3D20832F  lis r9, -0x7cd1
	ctx.r[9].s64 = -2094071808;
	// 82AAA61C: 394A6FD0  addi r10, r10, 0x6fd0
	ctx.r[10].s64 = ctx.r[10].s64 + 28624;
	// 82AAA620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA624: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA628: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAA62C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AAA630: 8089C9E0  lwz r4, -0x3620(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-13856 as u32) ) } as u64;
	// 82AAA634: 483493D5  bl 0x82df3a08
	ctx.lr = 0x82AAA638;
	sub_82DF3A08(ctx, base);
	// 82AAA638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA63C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAA640: 483AF0A9  bl 0x82e596e8
	ctx.lr = 0x82AAA644;
	sub_82E596E8(ctx, base);
	// 82AAA644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA648: 48348DE1  bl 0x82df3428
	ctx.lr = 0x82AAA64C;
	sub_82DF3428(ctx, base);
	// 82AAA64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA650: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA668 size=132
    let mut pc: u32 = 0x82AAA668;
    'dispatch: loop {
        match pc {
            0x82AAA668 => {
    //   block [0x82AAA668..0x82AAA6EC)
	// 82AAA668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA670: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAA674: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA680: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AAA684: 4BFFFE85  bl 0x82aaa508
	ctx.lr = 0x82AAA688;
	sub_82AAA508(ctx, base);
	// 82AAA688: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAA68C: 40820030  bne 0x82aaa6bc
	if !ctx.cr[0].eq {
	pc = 0x82AAA6BC; continue 'dispatch;
	}
	// 82AAA690: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAA694: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AAA698: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82AAA69C: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82AAA6A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAA6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA6A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AAA6AC: 4B815955  bl 0x822c0000
	ctx.lr = 0x82AAA6B0;
	sub_822C0000(ctx, base);
	// 82AAA6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAA6B4: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82AAA6B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAA6BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA6C0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA6C4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAA6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA6CC: 396B6FA4  addi r11, r11, 0x6fa4
	ctx.r[11].s64 = ctx.r[11].s64 + 28580;
	// 82AAA6D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA6D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA6D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA6DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA6E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAA6E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA6E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA6F0 size=196
    let mut pc: u32 = 0x82AAA6F0;
    'dispatch: loop {
        match pc {
            0x82AAA6F0 => {
    //   block [0x82AAA6F0..0x82AAA7B4)
	// 82AAA6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA6F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA6F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAA6FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA704: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAA708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAA70C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AAA710: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAA714: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA718: 4B816221  bl 0x822c0938
	ctx.lr = 0x82AAA71C;
	sub_822C0938(ctx, base);
	// 82AAA71C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA720: 41820028  beq 0x82aaa748
	if ctx.cr[0].eq {
	pc = 0x82AAA748; continue 'dispatch;
	}
	// 82AAA724: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA728: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AAA72C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AAA730: 392B6FAC  addi r9, r11, 0x6fac
	ctx.r[9].s64 = ctx.r[11].s64 + 28588;
	// 82AAA734: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAA738: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAA73C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAA740: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAA744: 48000008  b 0x82aaa74c
	pc = 0x82AAA74C; continue 'dispatch;
	// 82AAA748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAA74C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAA754: 409A0044  bne cr6, 0x82aaa798
	if !ctx.cr[6].eq {
	pc = 0x82AAA798; continue 'dispatch;
	}
	// 82AAA758: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAA75C: 419A001C  beq cr6, 0x82aaa778
	if ctx.cr[6].eq {
	pc = 0x82AAA778; continue 'dispatch;
	}
	// 82AAA760: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA764: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAA768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA76C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA774: 4E800421  bctrl
	ctx.lr = 0x82AAA778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAA778: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAA77C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AAA780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA784: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AAA788: 816BCFA0  lwz r11, -0x3060(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12384 as u32) ) } as u64;
	// 82AAA78C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AAA790: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAA794: 4B81586D  bl 0x822c0000
	ctx.lr = 0x82AAA798;
	sub_822C0000(ctx, base);
	// 82AAA798: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA79C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA7A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAA7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA7B8 size=120
    let mut pc: u32 = 0x82AAA7B8;
    'dispatch: loop {
        match pc {
            0x82AAA7B8 => {
    //   block [0x82AAA7B8..0x82AAA830)
	// 82AAA7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAA7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA7C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA7CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAA7D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AAA7D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAA7D8: 4B816161  bl 0x822c0938
	ctx.lr = 0x82AAA7DC;
	sub_822C0938(ctx, base);
	// 82AAA7DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA7E0: 4182002C  beq 0x82aaa80c
	if ctx.cr[0].eq {
	pc = 0x82AAA80C; continue 'dispatch;
	}
	// 82AAA7E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA7E8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAA7EC: 396B6FC0  addi r11, r11, 0x6fc0
	ctx.r[11].s64 = ctx.r[11].s64 + 28608;
	// 82AAA7F0: 394A6FA4  addi r10, r10, 0x6fa4
	ctx.r[10].s64 = ctx.r[10].s64 + 28580;
	// 82AAA7F4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA7F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAA7FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAA800: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA804: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAA808: 48000008  b 0x82aaa810
	pc = 0x82AAA810; continue 'dispatch;
	// 82AAA80C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAA810: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA81C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA824: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAA828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA830 size=100
    let mut pc: u32 = 0x82AAA830;
    'dispatch: loop {
        match pc {
            0x82AAA830 => {
    //   block [0x82AAA830..0x82AAA894)
	// 82AAA830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA83C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA848: 4BFFFF71  bl 0x82aaa7b8
	ctx.lr = 0x82AAA84C;
	sub_82AAA7B8(ctx, base);
	// 82AAA84C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA850: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA854: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAA858: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAA85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA860: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAA864: 419A0018  beq cr6, 0x82aaa87c
	if ctx.cr[6].eq {
	pc = 0x82AAA87C; continue 'dispatch;
	}
	// 82AAA868: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA86C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAA870: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA878: 4E800421  bctrl
	ctx.lr = 0x82AAA87C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAA87C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA880: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAA898 size=112
    let mut pc: u32 = 0x82AAA898;
    'dispatch: loop {
        match pc {
            0x82AAA898 => {
    //   block [0x82AAA898..0x82AAA908)
	// 82AAA898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA89C: 486FD8D1  bl 0x831a816c
	ctx.lr = 0x82AAA8A0;
	sub_831A8130(ctx, base);
	// 82AAA8A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA8A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAA8A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAA8AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAA8B0: 388B6FF8  addi r4, r11, 0x6ff8
	ctx.r[4].s64 = ctx.r[11].s64 + 28664;
	// 82AAA8B4: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 82AAA8B8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82AAA8BC: 48347B2D  bl 0x82df23e8
	ctx.lr = 0x82AAA8C0;
	sub_82DF23E8(ctx, base);
	// 82AAA8C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAA8C4: 41820010  beq 0x82aaa8d4
	if ctx.cr[0].eq {
	pc = 0x82AAA8D4; continue 'dispatch;
	}
	// 82AAA8C8: 4BFFFD31  bl 0x82aaa5f8
	ctx.lr = 0x82AAA8CC;
	sub_82AAA5F8(ctx, base);
	// 82AAA8CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA8D0: 48000008  b 0x82aaa8d8
	pc = 0x82AAA8D8; continue 'dispatch;
	// 82AAA8D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAA8D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AAA8DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AAA8E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA8E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA8E8: 4BFFFE09  bl 0x82aaa6f0
	ctx.lr = 0x82AAA8EC;
	sub_82AAA6F0(ctx, base);
	// 82AAA8EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAA8F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA8F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAA8F8: 4B815709  bl 0x822c0000
	ctx.lr = 0x82AAA8FC;
	sub_822C0000(ctx, base);
	// 82AAA8FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAA900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA904: 486FD8B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA908 size=184
    let mut pc: u32 = 0x82AAA908;
    'dispatch: loop {
        match pc {
            0x82AAA908 => {
    //   block [0x82AAA908..0x82AAA9C0)
	// 82AAA908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA90C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAA910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAA914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAA918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA91C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA920: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AAA924: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82AAA928: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82AAA92C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA930: 4B9E79D9  bl 0x82492308
	ctx.lr = 0x82AAA934;
	sub_82492308(ctx, base);
	// 82AAA934: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAA938: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82AAA93C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AAA940: 419A0064  beq cr6, 0x82aaa9a4
	if ctx.cr[6].eq {
	pc = 0x82AAA9A4; continue 'dispatch;
	}
	// 82AAA944: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAA948: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82AAA94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAA950: 419A0018  beq cr6, 0x82aaa968
	if ctx.cr[6].eq {
	pc = 0x82AAA968; continue 'dispatch;
	}
	// 82AAA954: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA958: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAA95C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA960: 4E800421  bctrl
	ctx.lr = 0x82AAA964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAA964: 4800000C  b 0x82aaa970
	pc = 0x82AAA970; continue 'dispatch;
	// 82AAA968: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82AAA96C: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82AAA970: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAA974: 388BCFA4  addi r4, r11, -0x305c
	ctx.r[4].s64 = ctx.r[11].s64 + -12380;
	// 82AAA978: 486FD781  bl 0x831a80f8
	ctx.lr = 0x82AAA97C;
	sub_831A80F8(ctx, base);
	// 82AAA97C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAA980: 41820024  beq 0x82aaa9a4
	if ctx.cr[0].eq {
	pc = 0x82AAA9A4; continue 'dispatch;
	}
	// 82AAA984: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAA988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAA98C: 4BFFFCDD  bl 0x82aaa668
	ctx.lr = 0x82AAA990;
	sub_82AAA668(ctx, base);
	// 82AAA990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAA994: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAA998: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAA99C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAA9A0: 48000008  b 0x82aaa9a8
	pc = 0x82AAA9A8; continue 'dispatch;
	// 82AAA9A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAA9A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAA9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAA9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAA9B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAA9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAA9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAA9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAA9C0 size=944
    let mut pc: u32 = 0x82AAA9C0;
    'dispatch: loop {
        match pc {
            0x82AAA9C0 => {
    //   block [0x82AAA9C0..0x82AAAD70)
	// 82AAA9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAA9C4: 486FD7A1  bl 0x831a8164
	ctx.lr = 0x82AAA9C8;
	sub_831A8130(ctx, base);
	// 82AAA9C8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82AAA9CC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82AAA9D0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82AAA9D4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAA9D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAA9DC: 486A9C25  bl 0x83154600
	ctx.lr = 0x82AAA9E0;
	sub_83154600(ctx, base);
	// 82AAA9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAA9E4: 4BE0E305  bl 0x828b8ce8
	ctx.lr = 0x82AAA9E8;
	sub_828B8CE8(ctx, base);
	// 82AAA9E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAA9EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AAA9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAA9F4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82AAA9F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAA9FC: 4E800421  bctrl
	ctx.lr = 0x82AAAA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAAA00: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AAAA04: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAAA08: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AAAA0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAAA10: 39296FA4  addi r9, r9, 0x6fa4
	ctx.r[9].s64 = ctx.r[9].s64 + 28580;
	// 82AAAA14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAA18: C00AA2EC  lfs f0, -0x5d14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAAA1C: 808BCF9C  lwz r4, -0x3064(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12388 as u32) ) } as u64;
	// 82AAAA20: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82AAAA24: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82AAAA28: 48348FE1  bl 0x82df3a08
	ctx.lr = 0x82AAAA2C;
	sub_82DF3A08(ctx, base);
	// 82AAAA2C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AAAA30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAAA34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAAA38: 4BFFFED1  bl 0x82aaa908
	ctx.lr = 0x82AAAA3C;
	sub_82AAA908(ctx, base);
	// 82AAAA3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AAAA40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAA44: 483489E5  bl 0x82df3428
	ctx.lr = 0x82AAAA48;
	sub_82DF3428(ctx, base);
	// 82AAAA48: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAAA4C: 4182000C  beq 0x82aaaa58
	if ctx.cr[0].eq {
	pc = 0x82AAAA58; continue 'dispatch;
	}
	// 82AAAA50: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAAA54: 4800000C  b 0x82aaaa60
	pc = 0x82AAAA60; continue 'dispatch;
	// 82AAAA58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAAA5C: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAAA60: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82AAAA64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAAA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAA6C: 4BFDDC25  bl 0x82a88690
	ctx.lr = 0x82AAAA70;
	sub_82A88690(ctx, base);
	// 82AAAA70: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAAA74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAA78: 808BCA18  lwz r4, -0x35e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AAAA7C: 48348F8D  bl 0x82df3a08
	ctx.lr = 0x82AAAA80;
	sub_82DF3A08(ctx, base);
	// 82AAAA80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAAA84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAA88: 4BD44CE9  bl 0x827ef770
	ctx.lr = 0x82AAAA8C;
	sub_827EF770(ctx, base);
	// 82AAAA8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAA90: 48348999  bl 0x82df3428
	ctx.lr = 0x82AAAA94;
	sub_82DF3428(ctx, base);
	// 82AAAA94: 3FC0832F  lis r30, -0x7cd1
	ctx.r[30].s64 = -2094071808;
	// 82AAAA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAA9C: 809E9F10  lwz r4, -0x60f0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82AAAAA0: 48348F69  bl 0x82df3a08
	ctx.lr = 0x82AAAAA4;
	sub_82DF3A08(ctx, base);
	// 82AAAAA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAAAA8: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82AAAAAC: 4BD3F7FD  bl 0x827ea2a8
	ctx.lr = 0x82AAAAB0;
	sub_827EA2A8(ctx, base);
	// 82AAAAB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AAAAB4: 483487ED  bl 0x82df32a0
	ctx.lr = 0x82AAAAB8;
	sub_82DF32A0(ctx, base);
	// 82AAAAB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAAABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAAC0: 48348969  bl 0x82df3428
	ctx.lr = 0x82AAAAC4;
	sub_82DF3428(ctx, base);
	// 82AAAAC4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAAAC8: 41820030  beq 0x82aaaaf8
	if ctx.cr[0].eq {
	pc = 0x82AAAAF8; continue 'dispatch;
	}
	// 82AAAACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAAD0: 809E9F10  lwz r4, -0x60f0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82AAAAD4: 48348F35  bl 0x82df3a08
	ctx.lr = 0x82AAAAD8;
	sub_82DF3A08(ctx, base);
	// 82AAAAD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAAAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAAE4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AAAAE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAAAEC: 4E800421  bctrl
	ctx.lr = 0x82AAAAF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAAAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAAF4: 48348935  bl 0x82df3428
	ctx.lr = 0x82AAAAF8;
	sub_82DF3428(ctx, base);
	// 82AAAAF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAAFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAAB00: 388B2338  addi r4, r11, 0x2338
	ctx.r[4].s64 = ctx.r[11].s64 + 9016;
	// 82AAAB04: 48348F05  bl 0x82df3a08
	ctx.lr = 0x82AAAB08;
	sub_82DF3A08(ctx, base);
	// 82AAAB08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAB0C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82AAAB10: 3BCB7058  addi r30, r11, 0x7058
	ctx.r[30].s64 = ctx.r[11].s64 + 28760;
	// 82AAAB14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAAB18: 48348EF1  bl 0x82df3a08
	ctx.lr = 0x82AAAB1C;
	sub_82DF3A08(ctx, base);
	// 82AAAB1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAAB20: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AAAB24: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AAAB28: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82AAAB2C: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	// 82AAAB30: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AAAB34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAB38: C3AABC10  lfs f29, -0x43f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AAAB3C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82AAAB40: C009F524  lfs f0, -0xadc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-2780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAAB44: 388B2314  addi r4, r11, 0x2314
	ctx.r[4].s64 = ctx.r[11].s64 + 8980;
	// 82AAAB48: C3C808A8  lfs f30, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AAAB4C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AAAB50: D3C10094  stfs f30, 0x94(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AAAB54: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82AAAB58: D3C1009C  stfs f30, 0x9c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82AAAB5C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82AAAB60: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82AAAB64: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82AAAB68: D3A10088  stfs f29, 0x88(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82AAAB6C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82AAAB70: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AAAB74: 48348E95  bl 0x82df3a08
	ctx.lr = 0x82AAAB78;
	sub_82DF3A08(ctx, base);
	// 82AAAB78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAAB7C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82AAAB80: 48348E89  bl 0x82df3a08
	ctx.lr = 0x82AAAB84;
	sub_82DF3A08(ctx, base);
	// 82AAAB84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAAB88: D3C100C4  stfs f30, 0xc4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AAAB8C: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82AAAB90: D3C100C8  stfs f30, 0xc8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AAAB94: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82AAAB98: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AAAB9C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82AAABA0: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82AAABA4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AAABA8: C00B093C  lfs f0, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAABAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAABB0: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82AAABB4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AAABB8: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82AAABBC: D3A100B8  stfs f29, 0xb8(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82AAABC0: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AAABC4: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82AAABC8: 4BD41A41  bl 0x827ec608
	ctx.lr = 0x82AAABCC;
	sub_827EC608(ctx, base);
	// 82AAABCC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82AAABD0: 3BE100D0  addi r31, r1, 0xd0
	ctx.r[31].s64 = ctx.r[1].s64 + 208;
	// 82AAABD4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82AAABD8: 3BFFFFD0  addi r31, r31, -0x30
	ctx.r[31].s64 = ctx.r[31].s64 + -48;
	// 82AAABDC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82AAABE0: 48348849  bl 0x82df3428
	ctx.lr = 0x82AAABE4;
	sub_82DF3428(ctx, base);
	// 82AAABE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAABE8: 48348841  bl 0x82df3428
	ctx.lr = 0x82AAABEC;
	sub_82DF3428(ctx, base);
	// 82AAABEC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAABF0: 4080FFE8  bge 0x82aaabd8
	if !ctx.cr[0].lt {
	pc = 0x82AAABD8; continue 'dispatch;
	}
	// 82AAABF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAABF8: 4BFD6AB1  bl 0x82a816a8
	ctx.lr = 0x82AAABFC;
	sub_82A816A8(ctx, base);
	// 82AAABFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAC00: 556BC7FF  rlwinm. r11, r11, 0x18, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAAC04: 4082014C  bne 0x82aaad50
	if !ctx.cr[0].eq {
	pc = 0x82AAAD50; continue 'dispatch;
	}
	// 82AAAC08: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AAAC0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAAC10: 4BFD6F51  bl 0x82a81b60
	ctx.lr = 0x82AAAC14;
	sub_82A81B60(ctx, base);
	// 82AAAC14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAAC18: 40820138  bne 0x82aaad50
	if !ctx.cr[0].eq {
	pc = 0x82AAAD50; continue 'dispatch;
	}
	// 82AAAC1C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AAAC20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAAC24: 4BFD6F3D  bl 0x82a81b60
	ctx.lr = 0x82AAAC28;
	sub_82A81B60(ctx, base);
	// 82AAAC28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAAC2C: 40820124  bne 0x82aaad50
	if !ctx.cr[0].eq {
	pc = 0x82AAAD50; continue 'dispatch;
	}
	// 82AAAC30: 4BFD69E1  bl 0x82a81610
	ctx.lr = 0x82AAAC34;
	sub_82A81610(ctx, base);
	// 82AAAC34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAAC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAAC3C: 4BE5E21D  bl 0x82908e58
	ctx.lr = 0x82AAAC40;
	sub_82908E58(ctx, base);
	// 82AAAC40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAAC44: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82AAAC48: 4BE5E219  bl 0x82908e60
	ctx.lr = 0x82AAAC4C;
	sub_82908E60(ctx, base);
	// 82AAAC4C: EC1E0824  fdivs f0, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[1].f64) as f32) as f64;
	// 82AAAC50: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAAC54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AAAC58: 409900F8  ble cr6, 0x82aaad50
	if !ctx.cr[6].gt {
	pc = 0x82AAAD50; continue 'dispatch;
	}
	// 82AAAC5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAAC60: 4BDED539  bl 0x82898198
	ctx.lr = 0x82AAAC64;
	sub_82898198(ctx, base);
	// 82AAAC64: 4BFE0695  bl 0x82a8b2f8
	ctx.lr = 0x82AAAC68;
	sub_82A8B2F8(ctx, base);
	// 82AAAC68: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAAC6C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AAAC70: 409900E0  ble cr6, 0x82aaad50
	if !ctx.cr[6].gt {
	pc = 0x82AAAD50; continue 'dispatch;
	}
	// 82AAAC74: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82AAAC78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAC7C: 9B610054  stb r27, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u8 ) };
	// 82AAAC80: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AAAC84: 388B704C  addi r4, r11, 0x704c
	ctx.r[4].s64 = ctx.r[11].s64 + 28748;
	// 82AAAC88: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AAAC8C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AAAC90: 4BFC8F39  bl 0x82a73bc8
	ctx.lr = 0x82AAAC94;
	sub_82A73BC8(ctx, base);
	// 82AAAC94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAC98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AAAC9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAACA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAACA4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AAACA8: 419A0024  beq cr6, 0x82aaaccc
	if ctx.cr[6].eq {
	pc = 0x82AAACCC; continue 'dispatch;
	}
	// 82AAACAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AAACB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAACB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAACB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAACBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAACC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAACC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAACC8: 4082FFE8  bne 0x82aaacb0
	if !ctx.cr[0].eq {
	pc = 0x82AAACB0; continue 'dispatch;
	}
	// 82AAACCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AAACD0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AAACD4: 4BA647F5  bl 0x8250f4c8
	ctx.lr = 0x82AAACD8;
	sub_8250F4C8(ctx, base);
	// 82AAACD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAACDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAACE0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AAACE4: 409A0008  bne cr6, 0x82aaacec
	if !ctx.cr[6].eq {
	pc = 0x82AAACEC; continue 'dispatch;
	}
	// 82AAACE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAACEC: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82AAACF0: 4BA5D929  bl 0x82508618
	ctx.lr = 0x82AAACF4;
	sub_82508618(ctx, base);
	// 82AAACF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAACF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAACFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAAD00: 388B6FF8  addi r4, r11, 0x6ff8
	ctx.r[4].s64 = ctx.r[11].s64 + 28664;
	// 82AAAD04: 38A00081  li r5, 0x81
	ctx.r[5].s64 = 129;
	// 82AAAD08: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82AAAD0C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82AAAD10: 483ADD31  bl 0x82e58a40
	ctx.lr = 0x82AAAD14;
	sub_82E58A40(ctx, base);
	// 82AAAD14: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AAAD18: 48346F79  bl 0x82df1c90
	ctx.lr = 0x82AAAD1C;
	sub_82DF1C90(ctx, base);
	// 82AAAD1C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AAAD20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAAD24: 419A0008  beq cr6, 0x82aaad2c
	if ctx.cr[6].eq {
	pc = 0x82AAAD2C; continue 'dispatch;
	}
	// 82AAAD28: 4B815B69  bl 0x822c0890
	ctx.lr = 0x82AAAD2C;
	sub_822C0890(ctx, base);
	// 82AAAD2C: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AAAD30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAAD34: 419A0008  beq cr6, 0x82aaad3c
	if ctx.cr[6].eq {
	pc = 0x82AAAD3C; continue 'dispatch;
	}
	// 82AAAD38: 4B815B59  bl 0x822c0890
	ctx.lr = 0x82AAAD3C;
	sub_822C0890(ctx, base);
	// 82AAAD3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAAD40: 4BFD6969  bl 0x82a816a8
	ctx.lr = 0x82AAAD44;
	sub_82A816A8(ctx, base);
	// 82AAAD44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAD48: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 82AAAD4C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAAD50: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AAAD54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAAD58: 4BFD9C11  bl 0x82a84968
	ctx.lr = 0x82AAAD5C;
	sub_82A84968(ctx, base);
	// 82AAAD5C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82AAAD60: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AAAD64: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AAAD68: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AAAD6C: 486FD448  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAAD70 size=96
    let mut pc: u32 = 0x82AAAD70;
    'dispatch: loop {
        match pc {
            0x82AAAD70 => {
    //   block [0x82AAAD70..0x82AAADD0)
	// 82AAAD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAD74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAAD78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAAD7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAAD80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAD84: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAAD88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAAD8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAD90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAAD94: 808BCF9C  lwz r4, -0x3064(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12388 as u32) ) } as u64;
	// 82AAAD98: 48348C71  bl 0x82df3a08
	ctx.lr = 0x82AAAD9C;
	sub_82DF3A08(ctx, base);
	// 82AAAD9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAADA0: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82AAADA4: 4B881A9D  bl 0x8232c840
	ctx.lr = 0x82AAADA8;
	sub_8232C840(ctx, base);
	// 82AAADA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAADAC: 4BFFFA85  bl 0x82aaa830
	ctx.lr = 0x82AAADB0;
	sub_82AAA830(ctx, base);
	// 82AAADB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAADB4: 48348675  bl 0x82df3428
	ctx.lr = 0x82AAADB8;
	sub_82DF3428(ctx, base);
	// 82AAADB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAADBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAADC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAADC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAADC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAADCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAADD0 size=196
    let mut pc: u32 = 0x82AAADD0;
    'dispatch: loop {
        match pc {
            0x82AAADD0 => {
    //   block [0x82AAADD0..0x82AAAE94)
	// 82AAADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAADD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAADD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAADDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAADE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAADE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAADE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAADEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AAADF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAADF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAADF8: 4B815B41  bl 0x822c0938
	ctx.lr = 0x82AAADFC;
	sub_822C0938(ctx, base);
	// 82AAADFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAAE00: 41820028  beq 0x82aaae28
	if ctx.cr[0].eq {
	pc = 0x82AAAE28; continue 'dispatch;
	}
	// 82AAAE04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAE08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AAAE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AAAE10: 392B7074  addi r9, r11, 0x7074
	ctx.r[9].s64 = ctx.r[11].s64 + 28788;
	// 82AAAE14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAAE18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAAE1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAAE20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAAE24: 48000008  b 0x82aaae2c
	pc = 0x82AAAE2C; continue 'dispatch;
	// 82AAAE28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAAE2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAAE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAAE34: 409A0044  bne cr6, 0x82aaae78
	if !ctx.cr[6].eq {
	pc = 0x82AAAE78; continue 'dispatch;
	}
	// 82AAAE38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAAE3C: 419A001C  beq cr6, 0x82aaae58
	if ctx.cr[6].eq {
	pc = 0x82AAAE58; continue 'dispatch;
	}
	// 82AAAE40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAAE44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAAE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAE4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAAE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAAE54: 4E800421  bctrl
	ctx.lr = 0x82AAAE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAAE58: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAAE5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AAAE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAE64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AAAE68: 816BD0B4  lwz r11, -0x2f4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12108 as u32) ) } as u64;
	// 82AAAE6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AAAE70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAAE74: 4B81518D  bl 0x822c0000
	ctx.lr = 0x82AAAE78;
	sub_822C0000(ctx, base);
	// 82AAAE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAAE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAAE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAAE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAAE88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAAE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAAE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAAE98 size=96
    let mut pc: u32 = 0x82AAAE98;
    'dispatch: loop {
        match pc {
            0x82AAAE98 => {
    //   block [0x82AAAE98..0x82AAAEF8)
	// 82AAAE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAAEA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAAEA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAEA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAAEAC: 4BE91E85  bl 0x8293cd30
	ctx.lr = 0x82AAAEB0;
	sub_8293CD30(ctx, base);
	// 82AAAEB0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAEB4: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AAAEB8: 396B7088  addi r11, r11, 0x7088
	ctx.r[11].s64 = ctx.r[11].s64 + 28808;
	// 82AAAEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAEC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAAEC4: 808ACA1C  lwz r4, -0x35e4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13796 as u32) ) } as u64;
	// 82AAAEC8: 48348B41  bl 0x82df3a08
	ctx.lr = 0x82AAAECC;
	sub_82DF3A08(ctx, base);
	// 82AAAECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAED0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAAED4: 483AE815  bl 0x82e596e8
	ctx.lr = 0x82AAAED8;
	sub_82E596E8(ctx, base);
	// 82AAAED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAAEDC: 4834854D  bl 0x82df3428
	ctx.lr = 0x82AAAEE0;
	sub_82DF3428(ctx, base);
	// 82AAAEE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAAEE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAAEE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAAEEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAAEF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAAEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAAEF8 size=112
    let mut pc: u32 = 0x82AAAEF8;
    'dispatch: loop {
        match pc {
            0x82AAAEF8 => {
    //   block [0x82AAAEF8..0x82AAAF68)
	// 82AAAEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAEFC: 486FD271  bl 0x831a816c
	ctx.lr = 0x82AAAF00;
	sub_831A8130(ctx, base);
	// 82AAAF00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAAF04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAAF08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAAF0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAAF10: 388B70C0  addi r4, r11, 0x70c0
	ctx.r[4].s64 = ctx.r[11].s64 + 28864;
	// 82AAAF14: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 82AAAF18: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82AAAF1C: 483474CD  bl 0x82df23e8
	ctx.lr = 0x82AAAF20;
	sub_82DF23E8(ctx, base);
	// 82AAAF20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAAF24: 41820010  beq 0x82aaaf34
	if ctx.cr[0].eq {
	pc = 0x82AAAF34; continue 'dispatch;
	}
	// 82AAAF28: 4BFFFF71  bl 0x82aaae98
	ctx.lr = 0x82AAAF2C;
	sub_82AAAE98(ctx, base);
	// 82AAAF2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAAF30: 48000008  b 0x82aaaf38
	pc = 0x82AAAF38; continue 'dispatch;
	// 82AAAF34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAAF38: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AAAF3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AAAF40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAAF44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAAF48: 4BFFFE89  bl 0x82aaadd0
	ctx.lr = 0x82AAAF4C;
	sub_82AAADD0(ctx, base);
	// 82AAAF4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAAF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAAF54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAAF58: 4B8150A9  bl 0x822c0000
	ctx.lr = 0x82AAAF5C;
	sub_822C0000(ctx, base);
	// 82AAAF5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAAF60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAAF64: 486FD258  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAAF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAAF68 size=432
    let mut pc: u32 = 0x82AAAF68;
    'dispatch: loop {
        match pc {
            0x82AAAF68 => {
    //   block [0x82AAAF68..0x82AAB118)
	// 82AAAF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAAF6C: 486FD1F5  bl 0x831a8160
	ctx.lr = 0x82AAAF70;
	sub_831A8130(ctx, base);
	// 82AAAF70: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AAAF74: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB118 size=96
    let mut pc: u32 = 0x82AAB118;
    'dispatch: loop {
        match pc {
            0x82AAB118 => {
    //   block [0x82AAB118..0x82AAB178)
	// 82AAB118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAB120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAB124: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB12C: 4BFEED6D  bl 0x82a99e98
	ctx.lr = 0x82AAB130;
	sub_82A99E98(ctx, base);
	// 82AAB130: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB134: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82AAB138: 396B7138  addi r11, r11, 0x7138
	ctx.r[11].s64 = ctx.r[11].s64 + 28984;
	// 82AAB13C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB140: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB144: 808ACA18  lwz r4, -0x35e8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13800 as u32) ) } as u64;
	// 82AAB148: 483488C1  bl 0x82df3a08
	ctx.lr = 0x82AAB14C;
	sub_82DF3A08(ctx, base);
	// 82AAB14C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAB154: 483AE595  bl 0x82e596e8
	ctx.lr = 0x82AAB158;
	sub_82E596E8(ctx, base);
	// 82AAB158: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB15C: 483482CD  bl 0x82df3428
	ctx.lr = 0x82AAB160;
	sub_82DF3428(ctx, base);
	// 82AAB160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB164: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAB168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAB16C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAB170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAB174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAB178 size=484
    let mut pc: u32 = 0x82AAB178;
    'dispatch: loop {
        match pc {
            0x82AAB178 => {
    //   block [0x82AAB178..0x82AAB35C)
	// 82AAB178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB17C: 486FCFF1  bl 0x831a816c
	ctx.lr = 0x82AAB180;
	sub_831A8130(ctx, base);
	// 82AAB180: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82AAB184: 486FD8F5  bl 0x831a8a78
	ctx.lr = 0x82AAB188;
	sub_831A8A40(ctx, base);
	// 82AAB188: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB18C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAB190: 486A9471  bl 0x83154600
	ctx.lr = 0x82AAB194;
	sub_83154600(ctx, base);
	// 82AAB194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB198: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAB19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB1A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB1A4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82AAB1A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAB1AC: 4E800421  bctrl
	ctx.lr = 0x82AAB1B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAB1B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAB1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB1B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB1BC: 4BD44735  bl 0x827ef8f0
	ctx.lr = 0x82AAB1C0;
	sub_827EF8F0(ctx, base);
	// 82AAB1C0: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AAB1C4: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AAB1C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB360 size=196
    let mut pc: u32 = 0x82AAB360;
    'dispatch: loop {
        match pc {
            0x82AAB360 => {
    //   block [0x82AAB360..0x82AAB424)
	// 82AAB360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAB368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAB36C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAB370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAB378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAB37C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AAB380: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAB384: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB388: 4B8155B1  bl 0x822c0938
	ctx.lr = 0x82AAB38C;
	sub_822C0938(ctx, base);
	// 82AAB38C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB390: 41820028  beq 0x82aab3b8
	if ctx.cr[0].eq {
	pc = 0x82AAB3B8; continue 'dispatch;
	}
	// 82AAB394: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB398: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AAB39C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AAB3A0: 392B7124  addi r9, r11, 0x7124
	ctx.r[9].s64 = ctx.r[11].s64 + 28964;
	// 82AAB3A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AAB3A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAB3AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AAB3B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AAB3B4: 48000008  b 0x82aab3bc
	pc = 0x82AAB3BC; continue 'dispatch;
	// 82AAB3B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAB3BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB3C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB3C4: 409A0044  bne cr6, 0x82aab408
	if !ctx.cr[6].eq {
	pc = 0x82AAB408; continue 'dispatch;
	}
	// 82AAB3C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAB3CC: 419A001C  beq cr6, 0x82aab3e8
	if ctx.cr[6].eq {
	pc = 0x82AAB3E8; continue 'dispatch;
	}
	// 82AAB3D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB3D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAB3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB3DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAB3E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AAB3E4: 4E800421  bctrl
	ctx.lr = 0x82AAB3E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AAB3E8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AAB3EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AAB3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB3F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AAB3F8: 816BD144  lwz r11, -0x2ebc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11964 as u32) ) } as u64;
	// 82AAB3FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AAB400: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAB404: 4B814BFD  bl 0x822c0000
	ctx.lr = 0x82AAB408;
	sub_822C0000(ctx, base);
	// 82AAB408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB40C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAB410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAB414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAB418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAB41C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAB420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB428 size=112
    let mut pc: u32 = 0x82AAB428;
    'dispatch: loop {
        match pc {
            0x82AAB428 => {
    //   block [0x82AAB428..0x82AAB498)
	// 82AAB428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB42C: 486FCD41  bl 0x831a816c
	ctx.lr = 0x82AAB430;
	sub_831A8130(ctx, base);
	// 82AAB430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB434: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB438: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAB43C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAB440: 388B7160  addi r4, r11, 0x7160
	ctx.r[4].s64 = ctx.r[11].s64 + 29024;
	// 82AAB444: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82AAB448: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82AAB44C: 48346F9D  bl 0x82df23e8
	ctx.lr = 0x82AAB450;
	sub_82DF23E8(ctx, base);
	// 82AAB450: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB454: 41820010  beq 0x82aab464
	if ctx.cr[0].eq {
	pc = 0x82AAB464; continue 'dispatch;
	}
	// 82AAB458: 4BFFFCC1  bl 0x82aab118
	ctx.lr = 0x82AAB45C;
	sub_82AAB118(ctx, base);
	// 82AAB45C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB460: 48000008  b 0x82aab468
	pc = 0x82AAB468; continue 'dispatch;
	// 82AAB464: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAB468: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AAB46C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AAB470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB478: 4BFFFEE9  bl 0x82aab360
	ctx.lr = 0x82AAB47C;
	sub_82AAB360(ctx, base);
	// 82AAB47C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAB480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB488: 4B814B79  bl 0x822c0000
	ctx.lr = 0x82AAB48C;
	sub_822C0000(ctx, base);
	// 82AAB48C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAB490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAB494: 486FCD28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB498 size=8
    let mut pc: u32 = 0x82AAB498;
    'dispatch: loop {
        match pc {
            0x82AAB498 => {
    //   block [0x82AAB498..0x82AAB4A0)
	// 82AAB498: 88630124  lbz r3, 0x124(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) } as u64;
	// 82AAB49C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4A0 size=12
    let mut pc: u32 = 0x82AAB4A0;
    'dispatch: loop {
        match pc {
            0x82AAB4A0 => {
    //   block [0x82AAB4A0..0x82AAB4AC)
	// 82AAB4A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAB4A4: 99630118  stb r11, 0x118(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[11].u8 ) };
	// 82AAB4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAB4B0 size=8
    let mut pc: u32 = 0x82AAB4B0;
    'dispatch: loop {
        match pc {
            0x82AAB4B0 => {
    //   block [0x82AAB4B0..0x82AAB4B8)
	// 82AAB4B0: D023014C  stfs f1, 0x14c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 82AAB4B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4B8 size=8
    let mut pc: u32 = 0x82AAB4B8;
    'dispatch: loop {
        match pc {
            0x82AAB4B8 => {
    //   block [0x82AAB4B8..0x82AAB4C0)
	// 82AAB4B8: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AAB4BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4C0 size=8
    let mut pc: u32 = 0x82AAB4C0;
    'dispatch: loop {
        match pc {
            0x82AAB4C0 => {
    //   block [0x82AAB4C0..0x82AAB4C8)
	// 82AAB4C0: 8063012C  lwz r3, 0x12c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 82AAB4C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4C8 size=8
    let mut pc: u32 = 0x82AAB4C8;
    'dispatch: loop {
        match pc {
            0x82AAB4C8 => {
    //   block [0x82AAB4C8..0x82AAB4D0)
	// 82AAB4C8: 38630130  addi r3, r3, 0x130
	ctx.r[3].s64 = ctx.r[3].s64 + 304;
	// 82AAB4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAB4D0 size=8
    let mut pc: u32 = 0x82AAB4D0;
    'dispatch: loop {
        match pc {
            0x82AAB4D0 => {
    //   block [0x82AAB4D0..0x82AAB4D8)
	// 82AAB4D0: C0230114  lfs f1, 0x114(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAB4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4D8 size=4
    let mut pc: u32 = 0x82AAB4D8;
    'dispatch: loop {
        match pc {
            0x82AAB4D8 => {
    //   block [0x82AAB4D8..0x82AAB4DC)
	// 82AAB4D8: 4BA66618  b 0x82511af0
	sub_82511AF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4E0 size=4
    let mut pc: u32 = 0x82AAB4E0;
    'dispatch: loop {
        match pc {
            0x82AAB4E0 => {
    //   block [0x82AAB4E0..0x82AAB4E4)
	// 82AAB4E0: 4BA667C0  b 0x82511ca0
	sub_82511CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4E8 size=12
    let mut pc: u32 = 0x82AAB4E8;
    'dispatch: loop {
        match pc {
            0x82AAB4E8 => {
    //   block [0x82AAB4E8..0x82AAB4F4)
	// 82AAB4E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAB4EC: 99630074  stb r11, 0x74(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82AAB4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB4F8 size=12
    let mut pc: u32 = 0x82AAB4F8;
    'dispatch: loop {
        match pc {
            0x82AAB4F8 => {
    //   block [0x82AAB4F8..0x82AAB504)
	// 82AAB4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAB4FC: 99630074  stb r11, 0x74(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82AAB500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB508 size=12
    let mut pc: u32 = 0x82AAB508;
    'dispatch: loop {
        match pc {
            0x82AAB508 => {
    //   block [0x82AAB508..0x82AAB514)
	// 82AAB508: 89630159  lbz r11, 0x159(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(345 as u32) ) } as u64;
	// 82AAB50C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB510: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB514(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB514 size=8
    let mut pc: u32 = 0x82AAB514;
    'dispatch: loop {
        match pc {
            0x82AAB514 => {
    //   block [0x82AAB514..0x82AAB51C)
	// 82AAB514: 38830160  addi r4, r3, 0x160
	ctx.r[4].s64 = ctx.r[3].s64 + 352;
	// 82AAB518: 4BA66568  b 0x82511a80
	sub_82511A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB51C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB51C size=4
    let mut pc: u32 = 0x82AAB51C;
    'dispatch: loop {
        match pc {
            0x82AAB51C => {
    //   block [0x82AAB51C..0x82AAB520)
	// 82AAB51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB520 size=500
    let mut pc: u32 = 0x82AAB520;
    'dispatch: loop {
        match pc {
            0x82AAB520 => {
    //   block [0x82AAB520..0x82AAB714)
	// 82AAB520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB524: 486FCC3D  bl 0x831a8160
	ctx.lr = 0x82AAB528;
	sub_831A8130(ctx, base);
	// 82AAB528: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB52C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AAB530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB534: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AAB538: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82AAB53C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AAB540: 4BA66499  bl 0x825119d8
	ctx.lr = 0x82AAB544;
	sub_825119D8(ctx, base);
	// 82AAB544: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AAB548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB54C: 4BA63E25  bl 0x8250f370
	ctx.lr = 0x82AAB550;
	sub_8250F370(ctx, base);
	// 82AAB550: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AAB554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB558: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82AAB55C: 483484AD  bl 0x82df3a08
	ctx.lr = 0x82AAB560;
	sub_82DF3A08(ctx, base);
	// 82AAB560: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB564: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAB568: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAB56C: 4BA5D215  bl 0x82508780
	ctx.lr = 0x82AAB570;
	sub_82508780(ctx, base);
	// 82AAB570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB574: 48347EB5  bl 0x82df3428
	ctx.lr = 0x82AAB578;
	sub_82DF3428(ctx, base);
	// 82AAB578: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AAB57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB580: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 82AAB584: 48348485  bl 0x82df3a08
	ctx.lr = 0x82AAB588;
	sub_82DF3A08(ctx, base);
	// 82AAB588: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAB58C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAB590: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB594: 4BA5D1ED  bl 0x82508780
	ctx.lr = 0x82AAB598;
	sub_82508780(ctx, base);
	// 82AAB598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB59C: 48347E8D  bl 0x82df3428
	ctx.lr = 0x82AAB5A0;
	sub_82DF3428(ctx, base);
	// 82AAB5A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAB5A4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AAB5A8: 409A0008  bne cr6, 0x82aab5b0
	if !ctx.cr[6].eq {
	pc = 0x82AAB5B0; continue 'dispatch;
	}
	// 82AAB5AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAB5B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB5B4: 4BA5D1ED  bl 0x825087a0
	ctx.lr = 0x82AAB5B8;
	sub_825087A0(ctx, base);
	// 82AAB5B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB5BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAB5C0: 3B4B7310  addi r26, r11, 0x7310
	ctx.r[26].s64 = ctx.r[11].s64 + 29456;
	// 82AAB5C4: 38A000FB  li r5, 0xfb
	ctx.r[5].s64 = 251;
	// 82AAB5C8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AAB5CC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82AAB5D0: 4B814E09  bl 0x822c03d8
	ctx.lr = 0x82AAB5D4;
	sub_822C03D8(ctx, base);
	// 82AAB5D4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AAB5D8: 4182002C  beq 0x82aab604
	if ctx.cr[0].eq {
	pc = 0x82AAB604; continue 'dispatch;
	}
	// 82AAB5DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB5E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAB5E4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82AAB5E8: 4BA63EE1  bl 0x8250f4c8
	ctx.lr = 0x82AAB5EC;
	sub_8250F4C8(ctx, base);
	// 82AAB5EC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAB5F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AAB5F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB5F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB5FC: 48002715  bl 0x82aadd10
	ctx.lr = 0x82AAB600;
	sub_82AADD10(ctx, base);
	// 82AAB600: 48000008  b 0x82aab608
	pc = 0x82AAB608; continue 'dispatch;
	// 82AAB604: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAB608: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB60C: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 82AAB610: 4182000C  beq 0x82aab61c
	if ctx.cr[0].eq {
	pc = 0x82AAB61C; continue 'dispatch;
	}
	// 82AAB614: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAB618: 48346679  bl 0x82df1c90
	ctx.lr = 0x82AAB61C;
	sub_82DF1C90(ctx, base);
	// 82AAB61C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AAB620: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAB624: 38A000FE  li r5, 0xfe
	ctx.r[5].s64 = 254;
	// 82AAB628: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82AAB62C: 4B814DAD  bl 0x822c03d8
	ctx.lr = 0x82AAB630;
	sub_822C03D8(ctx, base);
	// 82AAB630: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB634: 41820010  beq 0x82aab644
	if ctx.cr[0].eq {
	pc = 0x82AAB644; continue 'dispatch;
	}
	// 82AAB638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB63C: 4800275D  bl 0x82aadd98
	ctx.lr = 0x82AAB640;
	sub_82AADD98(ctx, base);
	// 82AAB640: 48000008  b 0x82aab648
	pc = 0x82AAB648; continue 'dispatch;
	// 82AAB644: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAB648: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 82AAB64C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AAB650: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAB654: 38A00101  li r5, 0x101
	ctx.r[5].s64 = 257;
	// 82AAB658: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82AAB65C: 48346D8D  bl 0x82df23e8
	ctx.lr = 0x82AAB660;
	sub_82DF23E8(ctx, base);
	// 82AAB660: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB664: 41820010  beq 0x82aab674
	if ctx.cr[0].eq {
	pc = 0x82AAB674; continue 'dispatch;
	}
	// 82AAB668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAB66C: 48003C15  bl 0x82aaf280
	ctx.lr = 0x82AAB670;
	sub_82AAF280(ctx, base);
	// 82AAB670: 48000008  b 0x82aab678
	pc = 0x82AAB678; continue 'dispatch;
	// 82AAB674: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAB678: 907F00E8  stw r3, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[3].u32 ) };
	// 82AAB67C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB680: 4BA5CEC9  bl 0x82508548
	ctx.lr = 0x82AAB684;
	sub_82508548(ctx, base);
	// 82AAB684: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB68C: 386BE670  addi r3, r11, -0x1990
	ctx.r[3].s64 = ctx.r[11].s64 + -6544;
	// 82AAB690: 48348139  bl 0x82df37c8
	ctx.lr = 0x82AAB694;
	sub_82DF37C8(ctx, base);
	// 82AAB694: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB698: 4082006C  bne 0x82aab704
	if !ctx.cr[0].eq {
	pc = 0x82AAB704; continue 'dispatch;
	}
	// 82AAB69C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB6A0: 4BA5CEA9  bl 0x82508548
	ctx.lr = 0x82AAB6A4;
	sub_82508548(ctx, base);
	// 82AAB6A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB6A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB6AC: 386BE648  addi r3, r11, -0x19b8
	ctx.r[3].s64 = ctx.r[11].s64 + -6584;
	// 82AAB6B0: 48348119  bl 0x82df37c8
	ctx.lr = 0x82AAB6B4;
	sub_82DF37C8(ctx, base);
	// 82AAB6B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB6B8: 4082004C  bne 0x82aab704
	if !ctx.cr[0].eq {
	pc = 0x82AAB704; continue 'dispatch;
	}
	// 82AAB6BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB6C0: 4BA5CE89  bl 0x82508548
	ctx.lr = 0x82AAB6C4;
	sub_82508548(ctx, base);
	// 82AAB6C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB6CC: 386BE620  addi r3, r11, -0x19e0
	ctx.r[3].s64 = ctx.r[11].s64 + -6624;
	// 82AAB6D0: 483480F9  bl 0x82df37c8
	ctx.lr = 0x82AAB6D4;
	sub_82DF37C8(ctx, base);
	// 82AAB6D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB6D8: 4082002C  bne 0x82aab704
	if !ctx.cr[0].eq {
	pc = 0x82AAB704; continue 'dispatch;
	}
	// 82AAB6DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAB6E0: 4BA5CE69  bl 0x82508548
	ctx.lr = 0x82AAB6E4;
	sub_82508548(ctx, base);
	// 82AAB6E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAB6E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB6EC: 386B72FC  addi r3, r11, 0x72fc
	ctx.r[3].s64 = ctx.r[11].s64 + 29436;
	// 82AAB6F0: 483480D9  bl 0x82df37c8
	ctx.lr = 0x82AAB6F4;
	sub_82DF37C8(ctx, base);
	// 82AAB6F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB6F8: 41820014  beq 0x82aab70c
	if ctx.cr[0].eq {
	pc = 0x82AAB70C; continue 'dispatch;
	}
	// 82AAB6FC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AAB700: 48000008  b 0x82aab708
	pc = 0x82AAB708; continue 'dispatch;
	// 82AAB704: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAB708: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AAB70C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AAB710: 486FCAA0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB718 size=24
    let mut pc: u32 = 0x82AAB718;
    'dispatch: loop {
        match pc {
            0x82AAB718 => {
    //   block [0x82AAB718..0x82AAB730)
	// 82AAB718: 3964002E  addi r11, r4, 0x2e
	ctx.r[11].s64 = ctx.r[4].s64 + 46;
	// 82AAB71C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAB720: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82AAB724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAB728: 419A0008  beq cr6, 0x82aab730
	if ctx.cr[6].eq {
		sub_82AAB730(ctx, base);
		return;
	}
	// 82AAB72C: 483D6864  b 0x82e81f90
	sub_82E81F90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAB730 size=8
    let mut pc: u32 = 0x82AAB730;
    'dispatch: loop {
        match pc {
            0x82AAB730 => {
    //   block [0x82AAB730..0x82AAB738)
	// 82AAB730: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAB734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAB738 size=332
    let mut pc: u32 = 0x82AAB738;
    'dispatch: loop {
        match pc {
            0x82AAB738 => {
    //   block [0x82AAB738..0x82AAB884)
	// 82AAB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB73C: 486FCA2D  bl 0x831a8168
	ctx.lr = 0x82AAB740;
	sub_831A8130(ctx, base);
	// 82AAB740: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB748: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AAB74C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB750: 419A0014  beq cr6, 0x82aab764
	if ctx.cr[6].eq {
	pc = 0x82AAB764; continue 'dispatch;
	}
	// 82AAB754: 4BA66395  bl 0x82511ae8
	ctx.lr = 0x82AAB758;
	sub_82511AE8(ctx, base);
	// 82AAB758: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 82AAB75C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB888 size=76
    let mut pc: u32 = 0x82AAB888;
    'dispatch: loop {
        match pc {
            0x82AAB888 => {
    //   block [0x82AAB888..0x82AAB8D4)
	// 82AAB888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAB890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAB894: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB898: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAB89C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAB8A0: 483AAB29  bl 0x82e563c8
	ctx.lr = 0x82AAB8A4;
	sub_82E563C8(ctx, base);
	// 82AAB8A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAB8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB8AC: 4BA64295  bl 0x8250fb40
	ctx.lr = 0x82AAB8B0;
	sub_8250FB40(ctx, base);
	// 82AAB8B0: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAB8B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAB8B8: 419A0008  beq cr6, 0x82aab8c0
	if ctx.cr[6].eq {
	pc = 0x82AAB8C0; continue 'dispatch;
	}
	// 82AAB8BC: 4802F19D  bl 0x82adaa58
	ctx.lr = 0x82AAB8C0;
	sub_82ADAA58(ctx, base);
	// 82AAB8C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAB8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAB8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAB8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAB8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB8D8 size=236
    let mut pc: u32 = 0x82AAB8D8;
    'dispatch: loop {
        match pc {
            0x82AAB8D8 => {
    //   block [0x82AAB8D8..0x82AAB9C4)
	// 82AAB8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAB8E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAB8E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAB8E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB8EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAB8F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAB8F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAB8F8: 4BA63A39  bl 0x8250f330
	ctx.lr = 0x82AAB8FC;
	sub_8250F330(ctx, base);
	// 82AAB8FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAB900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAB904: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAB908: 4BA3F851  bl 0x824eb158
	ctx.lr = 0x82AAB90C;
	sub_824EB158(ctx, base);
	// 82AAB90C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAB910: 48346381  bl 0x82df1c90
	ctx.lr = 0x82AAB914;
	sub_82DF1C90(ctx, base);
	// 82AAB914: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AAB918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB91C: 388B57F4  addi r4, r11, 0x57f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22516;
	// 82AAB920: 483480E9  bl 0x82df3a08
	ctx.lr = 0x82AAB924;
	sub_82DF3A08(ctx, base);
	// 82AAB924: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAB928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAB92C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AAB930: 409A000C  bne cr6, 0x82aab93c
	if !ctx.cr[6].eq {
	pc = 0x82AAB93C; continue 'dispatch;
	}
	// 82AAB934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAB938: 419A000C  beq cr6, 0x82aab944
	if ctx.cr[6].eq {
	pc = 0x82AAB944; continue 'dispatch;
	}
	// 82AAB93C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AAB940: 48000008  b 0x82aab948
	pc = 0x82AAB948; continue 'dispatch;
	// 82AAB944: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAB948: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAB94C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAB950: 4BA55B29  bl 0x82501478
	ctx.lr = 0x82AAB954;
	sub_82501478(ctx, base);
	// 82AAB954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAB958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB95C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AAB960: 4BA54589  bl 0x824ffee8
	ctx.lr = 0x82AAB964;
	sub_824FFEE8(ctx, base);
	// 82AAB964: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AAB968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAB96C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AAB970: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AAB974: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AAB978: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82AAB97C: 48347AAD  bl 0x82df3428
	ctx.lr = 0x82AAB980;
	sub_82DF3428(ctx, base);
	// 82AAB980: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAB984: 41820038  beq 0x82aab9bc
	if ctx.cr[0].eq {
	pc = 0x82AAB9BC; continue 'dispatch;
	}
	// 82AAB988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAB98C: 4BFFFEFD  bl 0x82aab888
	ctx.lr = 0x82AAB990;
	sub_82AAB888(ctx, base);
	// 82AAB990: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AAB994: 9BFE0151  stb r31, 0x151(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(337 as u32), ctx.r[31].u8 ) };
	// 82AAB998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAB99C: 483462F5  bl 0x82df1c90
	ctx.lr = 0x82AAB9A0;
	sub_82DF1C90(ctx, base);
	// 82AAB9A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAB9A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAB9A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAB9AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAB9B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAB9B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAB9B8: 4E800020  blr
	return;
	// 82AAB9BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAB9C0: 4BFFFFD8  b 0x82aab998
	pc = 0x82AAB998; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAB9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAB9C8 size=196
    let mut pc: u32 = 0x82AAB9C8;
    'dispatch: loop {
        match pc {
            0x82AAB9C8 => {
    //   block [0x82AAB9C8..0x82AABA8C)
	// 82AAB9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAB9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAB9D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAB9D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAB9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAB9DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAB9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAB9E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AAB9E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAB9EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAB9F0: 4B814F49  bl 0x822c0938
	ctx.lr = 0x82AAB9F4;
	sub_822C0938(ctx, base);
	// 82AAB9F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAB9F8: 41820028  beq 0x82aaba20
	if ctx.cr[0].eq {
	pc = 0x82AABA20; continue 'dispatch;
	}
	// 82AAB9FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABA00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AABA04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AABA08: 392B72B0  addi r9, r11, 0x72b0
	ctx.r[9].s64 = ctx.r[11].s64 + 29360;
	// 82AABA0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AABA10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AABA14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AABA18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AABA1C: 48000008  b 0x82aaba24
	pc = 0x82AABA24; continue 'dispatch;
	// 82AABA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABA24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABA2C: 409A0044  bne cr6, 0x82aaba70
	if !ctx.cr[6].eq {
	pc = 0x82AABA70; continue 'dispatch;
	}
	// 82AABA30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AABA34: 419A001C  beq cr6, 0x82aaba50
	if ctx.cr[6].eq {
	pc = 0x82AABA50; continue 'dispatch;
	}
	// 82AABA38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABA3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABA44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABA48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABA4C: 4E800421  bctrl
	ctx.lr = 0x82AABA50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABA50: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AABA54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AABA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABA5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AABA60: 816BD1D4  lwz r11, -0x2e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11820 as u32) ) } as u64;
	// 82AABA64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AABA68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AABA6C: 4B814595  bl 0x822c0000
	ctx.lr = 0x82AABA70;
	sub_822C0000(ctx, base);
	// 82AABA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABA74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABA80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABA84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABA90 size=196
    let mut pc: u32 = 0x82AABA90;
    'dispatch: loop {
        match pc {
            0x82AABA90 => {
    //   block [0x82AABA90..0x82AABB54)
	// 82AABA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABAA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AABAA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABAAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AABAB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AABAB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABAB8: 4B814E81  bl 0x822c0938
	ctx.lr = 0x82AABABC;
	sub_822C0938(ctx, base);
	// 82AABABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AABAC0: 41820028  beq 0x82aabae8
	if ctx.cr[0].eq {
	pc = 0x82AABAE8; continue 'dispatch;
	}
	// 82AABAC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABAC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AABACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AABAD0: 392B72C4  addi r9, r11, 0x72c4
	ctx.r[9].s64 = ctx.r[11].s64 + 29380;
	// 82AABAD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AABAD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AABADC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AABAE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AABAE4: 48000008  b 0x82aabaec
	pc = 0x82AABAEC; continue 'dispatch;
	// 82AABAE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABAEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABAF4: 409A0044  bne cr6, 0x82aabb38
	if !ctx.cr[6].eq {
	pc = 0x82AABB38; continue 'dispatch;
	}
	// 82AABAF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AABAFC: 419A001C  beq cr6, 0x82aabb18
	if ctx.cr[6].eq {
	pc = 0x82AABB18; continue 'dispatch;
	}
	// 82AABB00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABB04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABB0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABB10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABB14: 4E800421  bctrl
	ctx.lr = 0x82AABB18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABB18: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AABB1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AABB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABB24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AABB28: 816BD1D4  lwz r11, -0x2e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11820 as u32) ) } as u64;
	// 82AABB2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AABB30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AABB34: 4B8144CD  bl 0x822c0000
	ctx.lr = 0x82AABB38;
	sub_822C0000(ctx, base);
	// 82AABB38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABB3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABB40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABB44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABB48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABB4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABB50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABB58 size=196
    let mut pc: u32 = 0x82AABB58;
    'dispatch: loop {
        match pc {
            0x82AABB58 => {
    //   block [0x82AABB58..0x82AABC1C)
	// 82AABB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABB6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AABB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABB74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AABB78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AABB7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABB80: 4B814DB9  bl 0x822c0938
	ctx.lr = 0x82AABB84;
	sub_822C0938(ctx, base);
	// 82AABB84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AABB88: 41820028  beq 0x82aabbb0
	if ctx.cr[0].eq {
	pc = 0x82AABBB0; continue 'dispatch;
	}
	// 82AABB8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABB90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AABB94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AABB98: 392B72D8  addi r9, r11, 0x72d8
	ctx.r[9].s64 = ctx.r[11].s64 + 29400;
	// 82AABB9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AABBA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AABBA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AABBA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AABBAC: 48000008  b 0x82aabbb4
	pc = 0x82AABBB4; continue 'dispatch;
	// 82AABBB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABBB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABBBC: 409A0044  bne cr6, 0x82aabc00
	if !ctx.cr[6].eq {
	pc = 0x82AABC00; continue 'dispatch;
	}
	// 82AABBC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AABBC4: 419A001C  beq cr6, 0x82aabbe0
	if ctx.cr[6].eq {
	pc = 0x82AABBE0; continue 'dispatch;
	}
	// 82AABBC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABBCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABBD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABBD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABBDC: 4E800421  bctrl
	ctx.lr = 0x82AABBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABBE0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AABBE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AABBE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABBEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AABBF0: 816BD1D4  lwz r11, -0x2e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11820 as u32) ) } as u64;
	// 82AABBF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AABBF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AABBFC: 4B814405  bl 0x822c0000
	ctx.lr = 0x82AABC00;
	sub_822C0000(ctx, base);
	// 82AABC00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABC04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABC08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABC0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABC10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABC14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABC18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABC20 size=196
    let mut pc: u32 = 0x82AABC20;
    'dispatch: loop {
        match pc {
            0x82AABC20 => {
    //   block [0x82AABC20..0x82AABCE4)
	// 82AABC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABC30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABC34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AABC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABC3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AABC40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AABC44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABC48: 4B814CF1  bl 0x822c0938
	ctx.lr = 0x82AABC4C;
	sub_822C0938(ctx, base);
	// 82AABC4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AABC50: 41820028  beq 0x82aabc78
	if ctx.cr[0].eq {
	pc = 0x82AABC78; continue 'dispatch;
	}
	// 82AABC54: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABC58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AABC5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AABC60: 392B72EC  addi r9, r11, 0x72ec
	ctx.r[9].s64 = ctx.r[11].s64 + 29420;
	// 82AABC64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AABC68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AABC6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AABC70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AABC74: 48000008  b 0x82aabc7c
	pc = 0x82AABC7C; continue 'dispatch;
	// 82AABC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AABC7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABC84: 409A0044  bne cr6, 0x82aabcc8
	if !ctx.cr[6].eq {
	pc = 0x82AABCC8; continue 'dispatch;
	}
	// 82AABC88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AABC8C: 419A001C  beq cr6, 0x82aabca8
	if ctx.cr[6].eq {
	pc = 0x82AABCA8; continue 'dispatch;
	}
	// 82AABC90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABC94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABC9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABCA4: 4E800421  bctrl
	ctx.lr = 0x82AABCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABCA8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AABCAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AABCB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABCB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AABCB8: 816BD1D4  lwz r11, -0x2e2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11820 as u32) ) } as u64;
	// 82AABCBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AABCC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AABCC4: 4B81433D  bl 0x822c0000
	ctx.lr = 0x82AABCC8;
	sub_822C0000(ctx, base);
	// 82AABCC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABCCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABCD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABCD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABCD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABCDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABCE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABCE8 size=48
    let mut pc: u32 = 0x82AABCE8;
    'dispatch: loop {
        match pc {
            0x82AABCE8 => {
    //   block [0x82AABCE8..0x82AABD18)
	// 82AABCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABCF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABCF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABCF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABCFC: 4BA6641D  bl 0x82512118
	ctx.lr = 0x82AABD00;
	sub_82512118(ctx, base);
	// 82AABD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABD04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AABD08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABD0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABD10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABD14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AABD18 size=12
    let mut pc: u32 = 0x82AABD18;
    'dispatch: loop {
        match pc {
            0x82AABD18 => {
    //   block [0x82AABD18..0x82AABD24)
	// 82AABD18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AABD1C: 99630151  stb r11, 0x151(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(337 as u32), ctx.r[11].u8 ) };
	// 82AABD20: 4BFFFB68  b 0x82aab888
	sub_82AAB888(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABD28 size=224
    let mut pc: u32 = 0x82AABD28;
    'dispatch: loop {
        match pc {
            0x82AABD28 => {
    //   block [0x82AABD28..0x82AABE08)
	// 82AABD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABD30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABD34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABD38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABD3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABD40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABD44: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AABD48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AABD4C: 396B73B4  addi r11, r11, 0x73b4
	ctx.r[11].s64 = ctx.r[11].s64 + 29620;
	// 82AABD50: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AABD54: 394A73A0  addi r10, r10, 0x73a0
	ctx.r[10].s64 = ctx.r[10].s64 + 29600;
	// 82AABD58: 39297354  addi r9, r9, 0x7354
	ctx.r[9].s64 = ctx.r[9].s64 + 29524;
	// 82AABD5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABD60: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82AABD64: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AABD68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABD6C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82AABD70: 419A0018  beq cr6, 0x82aabd88
	if ctx.cr[6].eq {
	pc = 0x82AABD88; continue 'dispatch;
	}
	// 82AABD74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABD78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABD7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AABD80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABD84: 4E800421  bctrl
	ctx.lr = 0x82AABD88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABD88: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AABD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABD90: 419A0018  beq cr6, 0x82aabda8
	if ctx.cr[6].eq {
	pc = 0x82AABDA8; continue 'dispatch;
	}
	// 82AABD94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABD98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABD9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABDA4: 4E800421  bctrl
	ctx.lr = 0x82AABDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABDA8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AABDAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABDB0: 419A0018  beq cr6, 0x82aabdc8
	if ctx.cr[6].eq {
	pc = 0x82AABDC8; continue 'dispatch;
	}
	// 82AABDB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABDB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AABDBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABDC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AABDC4: 4E800421  bctrl
	ctx.lr = 0x82AABDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AABDC8: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82AABDCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABDD0: 419A0008  beq cr6, 0x82aabdd8
	if ctx.cr[6].eq {
	pc = 0x82AABDD8; continue 'dispatch;
	}
	// 82AABDD4: 4B814ABD  bl 0x822c0890
	ctx.lr = 0x82AABDD8;
	sub_822C0890(ctx, base);
	// 82AABDD8: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82AABDDC: 4BF8110D  bl 0x82a2cee8
	ctx.lr = 0x82AABDE0;
	sub_82A2CEE8(ctx, base);
	// 82AABDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABDE4: 4BCFB875  bl 0x827a7658
	ctx.lr = 0x82AABDE8;
	sub_827A7658(ctx, base);
	// 82AABDE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AABDEC: 4B8A3565  bl 0x8234f350
	ctx.lr = 0x82AABDF0;
	sub_8234F350(ctx, base);
	// 82AABDF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABDFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABE00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABE04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AABE08 size=8
    let mut pc: u32 = 0x82AABE08;
    'dispatch: loop {
        match pc {
            0x82AABE08 => {
    //   block [0x82AABE08..0x82AABE10)
	// 82AABE08: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AABE0C: 48000E9C  b 0x82aacca8
	sub_82AACCA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AABE10 size=8
    let mut pc: u32 = 0x82AABE10;
    'dispatch: loop {
        match pc {
            0x82AABE10 => {
    //   block [0x82AABE10..0x82AABE18)
	// 82AABE10: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82AABE14: 48000E94  b 0x82aacca8
	sub_82AACCA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABE18 size=152
    let mut pc: u32 = 0x82AABE18;
    'dispatch: loop {
        match pc {
            0x82AABE18 => {
    //   block [0x82AABE18..0x82AABEB0)
	// 82AABE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABE1C: 486FC351  bl 0x831a816c
	ctx.lr = 0x82AABE20;
	sub_831A8130(ctx, base);
	// 82AABE20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABE28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AABE2C: 4BA6623D  bl 0x82512068
	ctx.lr = 0x82AABE30;
	sub_82512068(ctx, base);
	// 82AABE30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AABE34: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AABE38: 4B8141C9  bl 0x822c0000
	ctx.lr = 0x82AABE3C;
	sub_822C0000(ctx, base);
	// 82AABE3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AABE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABE44: 4BA5EB0D  bl 0x8250a950
	ctx.lr = 0x82AABE48;
	sub_8250A950(ctx, base);
	// 82AABE48: 3BFF0170  addi r31, r31, 0x170
	ctx.r[31].s64 = ctx.r[31].s64 + 368;
	// 82AABE4C: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82AABE50: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AABE54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AABE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABE5C: 419A0038  beq cr6, 0x82aabe94
	if ctx.cr[6].eq {
	pc = 0x82AABE94; continue 'dispatch;
	}
	// 82AABE60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AABE64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABE68: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AABE6C: 409A0008  bne cr6, 0x82aabe74
	if !ctx.cr[6].eq {
	pc = 0x82AABE74; continue 'dispatch;
	}
	// 82AABE70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AABE74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AABE78: 4BD27B89  bl 0x827d3a00
	ctx.lr = 0x82AABE7C;
	sub_827D3A00(ctx, base);
	// 82AABE7C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AABE80: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AABE84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABE88: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AABE8C: 419A0008  beq cr6, 0x82aabe94
	if ctx.cr[6].eq {
	pc = 0x82AABE94; continue 'dispatch;
	}
	// 82AABE90: 4B814A01  bl 0x822c0890
	ctx.lr = 0x82AABE94;
	sub_822C0890(ctx, base);
	// 82AABE94: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AABE98: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AABE9C: 4082FFB8  bne 0x82aabe54
	if !ctx.cr[0].eq {
	pc = 0x82AABE54; continue 'dispatch;
	}
	// 82AABEA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABEA4: 48345DED  bl 0x82df1c90
	ctx.lr = 0x82AABEA8;
	sub_82DF1C90(ctx, base);
	// 82AABEA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AABEAC: 486FC310  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AABEB0 size=228
    let mut pc: u32 = 0x82AABEB0;
    'dispatch: loop {
        match pc {
            0x82AABEB0 => {
    //   block [0x82AABEB0..0x82AABF94)
	// 82AABEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABEB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AABEB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AABEBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AABEC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABEC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABEC8: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 82AABECC: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AABED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AABED4: 409A00A4  bne cr6, 0x82aabf78
	if !ctx.cr[6].eq {
	pc = 0x82AABF78; continue 'dispatch;
	}
	// 82AABED8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AABEDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AABEE0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82AABEE4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AABEE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABEEC: 388B7310  addi r4, r11, 0x7310
	ctx.r[4].s64 = ctx.r[11].s64 + 29456;
	// 82AABEF0: 419A001C  beq cr6, 0x82aabf0c
	if ctx.cr[6].eq {
	pc = 0x82AABF0C; continue 'dispatch;
	}
	// 82AABEF4: 38A00143  li r5, 0x143
	ctx.r[5].s64 = 323;
	// 82AABEF8: 4B8144E1  bl 0x822c03d8
	ctx.lr = 0x82AABEFC;
	sub_822C03D8(ctx, base);
	// 82AABEFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AABF00: 41820030  beq 0x82aabf30
	if ctx.cr[0].eq {
	pc = 0x82AABF30; continue 'dispatch;
	}
	// 82AABF04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AABF08: 48000018  b 0x82aabf20
	pc = 0x82AABF20; continue 'dispatch;
	// 82AABF0C: 38A0013F  li r5, 0x13f
	ctx.r[5].s64 = 319;
	// 82AABF10: 4B8144C9  bl 0x822c03d8
	ctx.lr = 0x82AABF14;
	sub_822C03D8(ctx, base);
	// 82AABF14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AABF18: 41820018  beq 0x82aabf30
	if ctx.cr[0].eq {
	pc = 0x82AABF30; continue 'dispatch;
	}
	// 82AABF1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AABF20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AABF24: 4802F045  bl 0x82adaf68
	ctx.lr = 0x82AABF28;
	sub_82ADAF68(ctx, base);
	// 82AABF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AABF2C: 48000008  b 0x82aabf34
	pc = 0x82AABF34; continue 'dispatch;
	// 82AABF30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AABF34: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AABF38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AABF3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABF40: 4BFFFB51  bl 0x82aaba90
	ctx.lr = 0x82AABF44;
	sub_82AABA90(ctx, base);
	// 82AABF44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AABF48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AABF4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AABF50: 4B8140B1  bl 0x822c0000
	ctx.lr = 0x82AABF54;
	sub_822C0000(ctx, base);
	// 82AABF54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AABF58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AABF5C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82AABF60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AABF64: 4B8184FD  bl 0x822c4460
	ctx.lr = 0x82AABF68;
	sub_822C4460(ctx, base);
	// 82AABF68: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AABF6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AABF70: 419A0008  beq cr6, 0x82aabf78
	if ctx.cr[6].eq {
	pc = 0x82AABF78; continue 'dispatch;
	}
	// 82AABF74: 4B81491D  bl 0x822c0890
	ctx.lr = 0x82AABF78;
	sub_822C0890(ctx, base);
	// 82AABF78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AABF7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AABF80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AABF84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AABF88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AABF8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AABF90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AABF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AABF98 size=1624
    let mut pc: u32 = 0x82AABF98;
    'dispatch: loop {
        match pc {
            0x82AABF98 => {
    //   block [0x82AABF98..0x82AAC5F0)
	// 82AABF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AABF9C: 486FC1C5  bl 0x831a8160
	ctx.lr = 0x82AABFA0;
	sub_831A8130(ctx, base);
	// 82AABFA0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82AABFA4: 486FCAD1  bl 0x831a8a74
	ctx.lr = 0x82AABFA8;
	sub_831A8A40(ctx, base);
	// 82AABFA8: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AABFAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AABFB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AABFB4: 3B6B7310  addi r27, r11, 0x7310
	ctx.r[27].s64 = ctx.r[11].s64 + 29456;
	// 82AABFB8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AABFBC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AABFC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AABFC4: 38A001B2  li r5, 0x1b2
	ctx.r[5].s64 = 434;
	// 82AABFC8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82AABFCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AABFD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AABFD4: 4B814405  bl 0x822c03d8
	ctx.lr = 0x82AABFD8;
	sub_822C03D8(ctx, base);
	// 82AABFD8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AABFDC: 41820034  beq 0x82aac010
	if ctx.cr[0].eq {
	pc = 0x82AAC010; continue 'dispatch;
	}
	// 82AABFE0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AABFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AABFE8: 388BCAD4  addi r4, r11, -0x352c
	ctx.r[4].s64 = ctx.r[11].s64 + -13612;
	// 82AABFEC: 48347A1D  bl 0x82df3a08
	ctx.lr = 0x82AABFF0;
	sub_82DF3A08(ctx, base);
	// 82AABFF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AABFF4: 38BD0044  addi r5, r29, 0x44
	ctx.r[5].s64 = ctx.r[29].s64 + 68;
	// 82AABFF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AABFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC000: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AAC004: 4BB0040D  bl 0x825ac410
	ctx.lr = 0x82AAC008;
	sub_825AC410(ctx, base);
	// 82AAC008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAC00C: 48000008  b 0x82aac014
	pc = 0x82AAC014; continue 'dispatch;
	// 82AAC010: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAC014: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AAC018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC01C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAC020: 4BA47399  bl 0x824f33b8
	ctx.lr = 0x82AAC024;
	sub_824F33B8(ctx, base);
	// 82AAC024: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAC028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC02C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAC030: 4B813FD1  bl 0x822c0000
	ctx.lr = 0x82AAC034;
	sub_822C0000(ctx, base);
	// 82AAC034: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAC038: 41820010  beq 0x82aac048
	if ctx.cr[0].eq {
	pc = 0x82AAC048; continue 'dispatch;
	}
	// 82AAC03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC040: 57DE003C  rlwinm r30, r30, 0, 0, 0x1e
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82AAC044: 483473E5  bl 0x82df3428
	ctx.lr = 0x82AAC048;
	sub_82DF3428(ctx, base);
	// 82AAC048: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC050: 388BF9A0  addi r4, r11, -0x660
	ctx.r[4].s64 = ctx.r[11].s64 + -1632;
	// 82AAC054: 483479B5  bl 0x82df3a08
	ctx.lr = 0x82AAC058;
	sub_82DF3A08(ctx, base);
	// 82AAC058: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAC05C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAC060: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAC064: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAC068: 4BAFFD59  bl 0x825abdc0
	ctx.lr = 0x82AAC06C;
	sub_825ABDC0(ctx, base);
	// 82AAC06C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC070: 483473B9  bl 0x82df3428
	ctx.lr = 0x82AAC074;
	sub_82DF3428(ctx, base);
	// 82AAC074: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC07C: 388BF9A8  addi r4, r11, -0x658
	ctx.r[4].s64 = ctx.r[11].s64 + -1624;
	// 82AAC080: 48347989  bl 0x82df3a08
	ctx.lr = 0x82AAC084;
	sub_82DF3A08(ctx, base);
	// 82AAC084: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAC088: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AAC08C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAC090: 4BAFFD31  bl 0x825abdc0
	ctx.lr = 0x82AAC094;
	sub_825ABDC0(ctx, base);
	// 82AAC094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC098: 48347391  bl 0x82df3428
	ctx.lr = 0x82AAC09C;
	sub_82DF3428(ctx, base);
	// 82AAC09C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AAC0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC0A4: 388B1614  addi r4, r11, 0x1614
	ctx.r[4].s64 = ctx.r[11].s64 + 5652;
	// 82AAC0A8: 48347961  bl 0x82df3a08
	ctx.lr = 0x82AAC0AC;
	sub_82DF3A08(ctx, base);
	// 82AAC0AC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AAC0B0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82AAC0B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAC0B8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AAC0BC: 419A0024  beq cr6, 0x82aac0e0
	if ctx.cr[6].eq {
	pc = 0x82AAC0E0; continue 'dispatch;
	}
	// 82AAC0C0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AAC0C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC0C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC0CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC0D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC0D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC0D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC0DC: 4082FFE8  bne 0x82aac0c4
	if !ctx.cr[0].eq {
	pc = 0x82AAC0C4; continue 'dispatch;
	}
	// 82AAC0E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AAC0E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC0E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC0EC: 4BAF6025  bl 0x825a2110
	ctx.lr = 0x82AAC0F0;
	sub_825A2110(ctx, base);
	// 82AAC0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC0F4: 48347335  bl 0x82df3428
	ctx.lr = 0x82AAC0F8;
	sub_82DF3428(ctx, base);
	// 82AAC0F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAC0FC: 419A000C  beq cr6, 0x82aac108
	if ctx.cr[6].eq {
	pc = 0x82AAC108; continue 'dispatch;
	}
	// 82AAC100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC104: 4B81478D  bl 0x822c0890
	ctx.lr = 0x82AAC108;
	sub_822C0890(ctx, base);
	// 82AAC108: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AAC10C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAC110: 38A001BA  li r5, 0x1ba
	ctx.r[5].s64 = 442;
	// 82AAC114: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AAC118: 4B8142C1  bl 0x822c03d8
	ctx.lr = 0x82AAC11C;
	sub_822C03D8(ctx, base);
	// 82AAC11C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAC120: 41820034  beq 0x82aac154
	if ctx.cr[0].eq {
	pc = 0x82AAC154; continue 'dispatch;
	}
	// 82AAC124: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AAC128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC12C: 388BADD0  addi r4, r11, -0x5230
	ctx.r[4].s64 = ctx.r[11].s64 + -21040;
	// 82AAC130: 483478D9  bl 0x82df3a08
	ctx.lr = 0x82AAC134;
	sub_82DF3A08(ctx, base);
	// 82AAC134: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAC138: 38BD0048  addi r5, r29, 0x48
	ctx.r[5].s64 = ctx.r[29].s64 + 72;
	// 82AAC13C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC144: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	// 82AAC148: 4BB002C9  bl 0x825ac410
	ctx.lr = 0x82AAC14C;
	sub_825AC410(ctx, base);
	// 82AAC14C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAC150: 48000008  b 0x82aac158
	pc = 0x82AAC158; continue 'dispatch;
	// 82AAC154: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAC158: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AAC15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC160: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAC164: 4BA47255  bl 0x824f33b8
	ctx.lr = 0x82AAC168;
	sub_824F33B8(ctx, base);
	// 82AAC168: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAC16C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC170: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AAC174: 4B813E8D  bl 0x822c0000
	ctx.lr = 0x82AAC178;
	sub_822C0000(ctx, base);
	// 82AAC178: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAC17C: 4182000C  beq 0x82aac188
	if ctx.cr[0].eq {
	pc = 0x82AAC188; continue 'dispatch;
	}
	// 82AAC180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC184: 483472A5  bl 0x82df3428
	ctx.lr = 0x82AAC188;
	sub_82DF3428(ctx, base);
	// 82AAC188: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAC18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC190: 388BD6B0  addi r4, r11, -0x2950
	ctx.r[4].s64 = ctx.r[11].s64 + -10576;
	// 82AAC194: 48347875  bl 0x82df3a08
	ctx.lr = 0x82AAC198;
	sub_82DF3A08(ctx, base);
	// 82AAC198: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAC19C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAC1A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAC1A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAC1A8: 4BAFFC19  bl 0x825abdc0
	ctx.lr = 0x82AAC1AC;
	sub_825ABDC0(ctx, base);
	// 82AAC1AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC1B0: 48347279  bl 0x82df3428
	ctx.lr = 0x82AAC1B4;
	sub_82DF3428(ctx, base);
	// 82AAC1B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AAC1B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC1BC: 388B8D4C  addi r4, r11, -0x72b4
	ctx.r[4].s64 = ctx.r[11].s64 + -29364;
	// 82AAC1C0: 48347849  bl 0x82df3a08
	ctx.lr = 0x82AAC1C4;
	sub_82DF3A08(ctx, base);
	// 82AAC1C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAC1C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AAC1CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAC1D0: 4BAFFBF1  bl 0x825abdc0
	ctx.lr = 0x82AAC1D4;
	sub_825ABDC0(ctx, base);
	// 82AAC1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC1D8: 48347251  bl 0x82df3428
	ctx.lr = 0x82AAC1DC;
	sub_82DF3428(ctx, base);
	// 82AAC1DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC1E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC1E4: 388B7488  addi r4, r11, 0x7488
	ctx.r[4].s64 = ctx.r[11].s64 + 29832;
	// 82AAC1E8: 48347821  bl 0x82df3a08
	ctx.lr = 0x82AAC1EC;
	sub_82DF3A08(ctx, base);
	// 82AAC1EC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AAC1F0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82AAC1F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAC1F8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AAC1FC: 419A0024  beq cr6, 0x82aac220
	if ctx.cr[6].eq {
	pc = 0x82AAC220; continue 'dispatch;
	}
	// 82AAC200: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AAC204: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC208: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC20C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC210: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC214: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC218: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC21C: 4082FFE8  bne 0x82aac204
	if !ctx.cr[0].eq {
	pc = 0x82AAC204; continue 'dispatch;
	}
	// 82AAC220: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AAC224: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC228: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC22C: 4BAF5EE5  bl 0x825a2110
	ctx.lr = 0x82AAC230;
	sub_825A2110(ctx, base);
	// 82AAC230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC234: 483471F5  bl 0x82df3428
	ctx.lr = 0x82AAC238;
	sub_82DF3428(ctx, base);
	// 82AAC238: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AAC23C: 419A000C  beq cr6, 0x82aac248
	if ctx.cr[6].eq {
	pc = 0x82AAC248; continue 'dispatch;
	}
	// 82AAC240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC244: 4B81464D  bl 0x822c0890
	ctx.lr = 0x82AAC248;
	sub_822C0890(ctx, base);
	// 82AAC248: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82AAC24C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC250: 3BEB4640  addi r31, r11, 0x4640
	ctx.r[31].s64 = ctx.r[11].s64 + 17984;
	// 82AAC254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC258: 483477B1  bl 0x82df3a08
	ctx.lr = 0x82AAC25C;
	sub_82DF3A08(ctx, base);
	// 82AAC25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC264: 483477A5  bl 0x82df3a08
	ctx.lr = 0x82AAC268;
	sub_82DF3A08(ctx, base);
	// 82AAC268: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AAC26C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAC270: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AAC274: 38BD005C  addi r5, r29, 0x5c
	ctx.r[5].s64 = ctx.r[29].s64 + 92;
	// 82AAC278: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC27C: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AAC280: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 82AAC284: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AAC288: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC28C: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC290: 4BAF7019  bl 0x825a32a8
	ctx.lr = 0x82AAC294;
	sub_825A32A8(ctx, base);
	// 82AAC294: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC298: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC29C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC2A0: 4BAF54D1  bl 0x825a1770
	ctx.lr = 0x82AAC2A4;
	sub_825A1770(ctx, base);
	// 82AAC2A4: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 82AAC2A8: 48347181  bl 0x82df3428
	ctx.lr = 0x82AAC2AC;
	sub_82DF3428(ctx, base);
	// 82AAC2AC: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 82AAC2B0: 4B81CA09  bl 0x822c8cb8
	ctx.lr = 0x82AAC2B4;
	sub_822C8CB8(ctx, base);
	// 82AAC2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC2B8: 48347171  bl 0x82df3428
	ctx.lr = 0x82AAC2BC;
	sub_82DF3428(ctx, base);
	// 82AAC2BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC2C0: 48347169  bl 0x82df3428
	ctx.lr = 0x82AAC2C4;
	sub_82DF3428(ctx, base);
	// 82AAC2C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC2CC: 3BEB747C  addi r31, r11, 0x747c
	ctx.r[31].s64 = ctx.r[11].s64 + 29820;
	// 82AAC2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC2D4: 48347735  bl 0x82df3a08
	ctx.lr = 0x82AAC2D8;
	sub_82DF3A08(ctx, base);
	// 82AAC2D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC2DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC2E0: 48347729  bl 0x82df3a08
	ctx.lr = 0x82AAC2E4;
	sub_82DF3A08(ctx, base);
	// 82AAC2E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AAC2E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82AAC2EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC2F0: 38BD0060  addi r5, r29, 0x60
	ctx.r[5].s64 = ctx.r[29].s64 + 96;
	// 82AAC2F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC2F8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AAC2FC: C3AB89AC  lfs f29, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82AAC300: C3CA9A8C  lfs f30, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AAC304: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82AAC308: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AAC30C: 4BAF6F9D  bl 0x825a32a8
	ctx.lr = 0x82AAC310;
	sub_825A32A8(ctx, base);
	// 82AAC310: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC314: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC318: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC31C: 4BAF5455  bl 0x825a1770
	ctx.lr = 0x82AAC320;
	sub_825A1770(ctx, base);
	// 82AAC320: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AAC324: 48347105  bl 0x82df3428
	ctx.lr = 0x82AAC328;
	sub_82DF3428(ctx, base);
	// 82AAC328: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AAC32C: 4B81C98D  bl 0x822c8cb8
	ctx.lr = 0x82AAC330;
	sub_822C8CB8(ctx, base);
	// 82AAC330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC334: 483470F5  bl 0x82df3428
	ctx.lr = 0x82AAC338;
	sub_82DF3428(ctx, base);
	// 82AAC338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC33C: 483470ED  bl 0x82df3428
	ctx.lr = 0x82AAC340;
	sub_82DF3428(ctx, base);
	// 82AAC340: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC348: 388B7470  addi r4, r11, 0x7470
	ctx.r[4].s64 = ctx.r[11].s64 + 29808;
	// 82AAC34C: 483476BD  bl 0x82df3a08
	ctx.lr = 0x82AAC350;
	sub_82DF3A08(ctx, base);
	// 82AAC350: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC354: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC358: 388B745C  addi r4, r11, 0x745c
	ctx.r[4].s64 = ctx.r[11].s64 + 29788;
	// 82AAC35C: 483476AD  bl 0x82df3a08
	ctx.lr = 0x82AAC360;
	sub_82DF3A08(ctx, base);
	// 82AAC360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAC364: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AAC368: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AAC36C: 38BD004C  addi r5, r29, 0x4c
	ctx.r[5].s64 = ctx.r[29].s64 + 76;
	// 82AAC370: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC374: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC378: C38B08A8  lfs f28, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82AAC37C: C36A2B60  lfs f27, 0x2b60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11104 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82AAC380: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82AAC384: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82AAC388: 4BAF6F21  bl 0x825a32a8
	ctx.lr = 0x82AAC38C;
	sub_825A32A8(ctx, base);
	// 82AAC38C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC390: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC394: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC398: 4BAF53D9  bl 0x825a1770
	ctx.lr = 0x82AAC39C;
	sub_825A1770(ctx, base);
	// 82AAC39C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AAC3A0: 48347089  bl 0x82df3428
	ctx.lr = 0x82AAC3A4;
	sub_82DF3428(ctx, base);
	// 82AAC3A4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAC3A8: 4B81C911  bl 0x822c8cb8
	ctx.lr = 0x82AAC3AC;
	sub_822C8CB8(ctx, base);
	// 82AAC3AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC3B0: 48347079  bl 0x82df3428
	ctx.lr = 0x82AAC3B4;
	sub_82DF3428(ctx, base);
	// 82AAC3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC3B8: 48347071  bl 0x82df3428
	ctx.lr = 0x82AAC3BC;
	sub_82DF3428(ctx, base);
	// 82AAC3BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC3C4: 388B7450  addi r4, r11, 0x7450
	ctx.r[4].s64 = ctx.r[11].s64 + 29776;
	// 82AAC3C8: 48347641  bl 0x82df3a08
	ctx.lr = 0x82AAC3CC;
	sub_82DF3A08(ctx, base);
	// 82AAC3CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC3D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC3D4: 388B743C  addi r4, r11, 0x743c
	ctx.r[4].s64 = ctx.r[11].s64 + 29756;
	// 82AAC3D8: 48347631  bl 0x82df3a08
	ctx.lr = 0x82AAC3DC;
	sub_82DF3A08(ctx, base);
	// 82AAC3DC: 38BD0050  addi r5, r29, 0x50
	ctx.r[5].s64 = ctx.r[29].s64 + 80;
	// 82AAC3E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC3E4: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82AAC3E8: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82AAC3EC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AAC3F0: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82AAC3F4: 4BAF6EB5  bl 0x825a32a8
	ctx.lr = 0x82AAC3F8;
	sub_825A32A8(ctx, base);
	// 82AAC3F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC3FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC400: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC404: 4BAF536D  bl 0x825a1770
	ctx.lr = 0x82AAC408;
	sub_825A1770(ctx, base);
	// 82AAC408: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82AAC40C: 4834701D  bl 0x82df3428
	ctx.lr = 0x82AAC410;
	sub_82DF3428(ctx, base);
	// 82AAC410: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82AAC414: 4B81C8A5  bl 0x822c8cb8
	ctx.lr = 0x82AAC418;
	sub_822C8CB8(ctx, base);
	// 82AAC418: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC41C: 4834700D  bl 0x82df3428
	ctx.lr = 0x82AAC420;
	sub_82DF3428(ctx, base);
	// 82AAC420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC424: 48347005  bl 0x82df3428
	ctx.lr = 0x82AAC428;
	sub_82DF3428(ctx, base);
	// 82AAC428: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC42C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC430: 388B7430  addi r4, r11, 0x7430
	ctx.r[4].s64 = ctx.r[11].s64 + 29744;
	// 82AAC434: 483475D5  bl 0x82df3a08
	ctx.lr = 0x82AAC438;
	sub_82DF3A08(ctx, base);
	// 82AAC438: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC43C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC440: 388B741C  addi r4, r11, 0x741c
	ctx.r[4].s64 = ctx.r[11].s64 + 29724;
	// 82AAC444: 483475C5  bl 0x82df3a08
	ctx.lr = 0x82AAC448;
	sub_82DF3A08(ctx, base);
	// 82AAC448: 38BD0054  addi r5, r29, 0x54
	ctx.r[5].s64 = ctx.r[29].s64 + 84;
	// 82AAC44C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC450: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82AAC454: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AAC458: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AAC45C: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82AAC460: 4BAF6E49  bl 0x825a32a8
	ctx.lr = 0x82AAC464;
	sub_825A32A8(ctx, base);
	// 82AAC464: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC468: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC46C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC470: 4BAF5301  bl 0x825a1770
	ctx.lr = 0x82AAC474;
	sub_825A1770(ctx, base);
	// 82AAC474: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AAC478: 48346FB1  bl 0x82df3428
	ctx.lr = 0x82AAC47C;
	sub_82DF3428(ctx, base);
	// 82AAC47C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AAC480: 4B81C839  bl 0x822c8cb8
	ctx.lr = 0x82AAC484;
	sub_822C8CB8(ctx, base);
	// 82AAC484: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC488: 48346FA1  bl 0x82df3428
	ctx.lr = 0x82AAC48C;
	sub_82DF3428(ctx, base);
	// 82AAC48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC490: 48346F99  bl 0x82df3428
	ctx.lr = 0x82AAC494;
	sub_82DF3428(ctx, base);
	// 82AAC494: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC49C: 388B7410  addi r4, r11, 0x7410
	ctx.r[4].s64 = ctx.r[11].s64 + 29712;
	// 82AAC4A0: 48347569  bl 0x82df3a08
	ctx.lr = 0x82AAC4A4;
	sub_82DF3A08(ctx, base);
	// 82AAC4A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC4A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC4AC: 388B7400  addi r4, r11, 0x7400
	ctx.r[4].s64 = ctx.r[11].s64 + 29696;
	// 82AAC4B0: 48347559  bl 0x82df3a08
	ctx.lr = 0x82AAC4B4;
	sub_82DF3A08(ctx, base);
	// 82AAC4B4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AAC4B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AAC4BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAC4C0: 38BD0070  addi r5, r29, 0x70
	ctx.r[5].s64 = ctx.r[29].s64 + 112;
	// 82AAC4C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC4C8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82AAC4CC: 4BAF6F4D  bl 0x825a3418
	ctx.lr = 0x82AAC4D0;
	sub_825A3418(ctx, base);
	// 82AAC4D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC4D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC4D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC4DC: 4BAF59FD  bl 0x825a1ed8
	ctx.lr = 0x82AAC4E0;
	sub_825A1ED8(ctx, base);
	// 82AAC4E0: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82AAC4E4: 48346F45  bl 0x82df3428
	ctx.lr = 0x82AAC4E8;
	sub_82DF3428(ctx, base);
	// 82AAC4E8: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AAC4EC: 4B81C7CD  bl 0x822c8cb8
	ctx.lr = 0x82AAC4F0;
	sub_822C8CB8(ctx, base);
	// 82AAC4F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC4F4: 48346F35  bl 0x82df3428
	ctx.lr = 0x82AAC4F8;
	sub_82DF3428(ctx, base);
	// 82AAC4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC4FC: 48346F2D  bl 0x82df3428
	ctx.lr = 0x82AAC500;
	sub_82DF3428(ctx, base);
	// 82AAC500: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AAC504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC508: 3BEBDBBC  addi r31, r11, -0x2444
	ctx.r[31].s64 = ctx.r[11].s64 + -9284;
	// 82AAC50C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC510: 483474F9  bl 0x82df3a08
	ctx.lr = 0x82AAC514;
	sub_82DF3A08(ctx, base);
	// 82AAC514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC518: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC51C: 483474ED  bl 0x82df3a08
	ctx.lr = 0x82AAC520;
	sub_82DF3A08(ctx, base);
	// 82AAC520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AAC524: 38BD002C  addi r5, r29, 0x2c
	ctx.r[5].s64 = ctx.r[29].s64 + 44;
	// 82AAC528: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82AAC52C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC530: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC534: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82AAC538: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC53C: 4BAF6D6D  bl 0x825a32a8
	ctx.lr = 0x82AAC540;
	sub_825A32A8(ctx, base);
	// 82AAC540: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC544: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC548: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC54C: 4BAF5225  bl 0x825a1770
	ctx.lr = 0x82AAC550;
	sub_825A1770(ctx, base);
	// 82AAC550: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 82AAC554: 48346ED5  bl 0x82df3428
	ctx.lr = 0x82AAC558;
	sub_82DF3428(ctx, base);
	// 82AAC558: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 82AAC55C: 4B81C75D  bl 0x822c8cb8
	ctx.lr = 0x82AAC560;
	sub_822C8CB8(ctx, base);
	// 82AAC560: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC564: 48346EC5  bl 0x82df3428
	ctx.lr = 0x82AAC568;
	sub_82DF3428(ctx, base);
	// 82AAC568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC56C: 48346EBD  bl 0x82df3428
	ctx.lr = 0x82AAC570;
	sub_82DF3428(ctx, base);
	// 82AAC570: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC578: 3BEB73F0  addi r31, r11, 0x73f0
	ctx.r[31].s64 = ctx.r[11].s64 + 29680;
	// 82AAC57C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC580: 48347489  bl 0x82df3a08
	ctx.lr = 0x82AAC584;
	sub_82DF3A08(ctx, base);
	// 82AAC584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC588: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC58C: 4834747D  bl 0x82df3a08
	ctx.lr = 0x82AAC590;
	sub_82DF3A08(ctx, base);
	// 82AAC590: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AAC594: 38BD0064  addi r5, r29, 0x64
	ctx.r[5].s64 = ctx.r[29].s64 + 100;
	// 82AAC598: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82AAC59C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAC5A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAC5A4: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82AAC5A8: C04BC350  lfs f2, -0x3cb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC5AC: 4BAF6CFD  bl 0x825a32a8
	ctx.lr = 0x82AAC5B0;
	sub_825A32A8(ctx, base);
	// 82AAC5B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC5B4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAC5B8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AAC5BC: 4BAF51B5  bl 0x825a1770
	ctx.lr = 0x82AAC5C0;
	sub_825A1770(ctx, base);
	// 82AAC5C0: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 82AAC5C4: 48346E65  bl 0x82df3428
	ctx.lr = 0x82AAC5C8;
	sub_82DF3428(ctx, base);
	// 82AAC5C8: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 82AAC5CC: 4B81C6ED  bl 0x822c8cb8
	ctx.lr = 0x82AAC5D0;
	sub_822C8CB8(ctx, base);
	// 82AAC5D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC5D4: 48346E55  bl 0x82df3428
	ctx.lr = 0x82AAC5D8;
	sub_82DF3428(ctx, base);
	// 82AAC5D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC5DC: 48346E4D  bl 0x82df3428
	ctx.lr = 0x82AAC5E0;
	sub_82DF3428(ctx, base);
	// 82AAC5E0: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82AAC5E4: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82AAC5E8: 486FC4D9  bl 0x831a8ac0
	ctx.lr = 0x82AAC5EC;
	sub_831A8A8C(ctx, base);
	// 82AAC5EC: 486FBBC4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAC5F0 size=776
    let mut pc: u32 = 0x82AAC5F0;
    'dispatch: loop {
        match pc {
            0x82AAC5F0 => {
    //   block [0x82AAC5F0..0x82AAC8F8)
	// 82AAC5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC5F4: 486FBB71  bl 0x831a8164
	ctx.lr = 0x82AAC5F8;
	sub_831A8130(ctx, base);
	// 82AAC5F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC5FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAC600: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82AAC604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC608: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAC60C: 4BA62EBD  bl 0x8250f4c8
	ctx.lr = 0x82AAC610;
	sub_8250F4C8(ctx, base);
	// 82AAC610: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC614: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AAC618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC61C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AAC620: 409A0008  bne cr6, 0x82aac628
	if !ctx.cr[6].eq {
	pc = 0x82AAC628; continue 'dispatch;
	}
	// 82AAC624: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AAC628: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC62C: 4BA5E325  bl 0x8250a950
	ctx.lr = 0x82AAC630;
	sub_8250A950(ctx, base);
	// 82AAC630: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAC634: 4834565D  bl 0x82df1c90
	ctx.lr = 0x82AAC638;
	sub_82DF1C90(ctx, base);
	// 82AAC638: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82AAC63C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82AAC640: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82AAC644: 419A0154  beq cr6, 0x82aac798
	if ctx.cr[6].eq {
	pc = 0x82AAC798; continue 'dispatch;
	}
	// 82AAC648: 2F1B0002  cmpwi cr6, r27, 2
	ctx.cr[6].compare_i32(ctx.r[27].s32, 2, &mut ctx.xer);
	// 82AAC64C: 419A006C  beq cr6, 0x82aac6b8
	if ctx.cr[6].eq {
	pc = 0x82AAC6B8; continue 'dispatch;
	}
	// 82AAC650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC654: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAC658: 4BA65AC1  bl 0x82512118
	ctx.lr = 0x82AAC65C;
	sub_82512118(ctx, base);
	// 82AAC65C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AAC660: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82AAC664: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AAC668: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AAC66C: 4B817DF5  bl 0x822c4460
	ctx.lr = 0x82AAC670;
	sub_822C4460(ctx, base);
	// 82AAC670: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AAC674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC678: 419A0008  beq cr6, 0x82aac680
	if ctx.cr[6].eq {
	pc = 0x82AAC680; continue 'dispatch;
	}
	// 82AAC67C: 4B814215  bl 0x822c0890
	ctx.lr = 0x82AAC680;
	sub_822C0890(ctx, base);
	// 82AAC680: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82AAC684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC688: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC68C: 4BA6545D  bl 0x82511ae8
	ctx.lr = 0x82AAC690;
	sub_82511AE8(ctx, base);
	// 82AAC690: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AAC694: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AAC698: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC69C: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAC6A0: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82AAC6A4: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 82AAC6A8: C04B6218  lfs f2, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC6AC: C02ADD6C  lfs f1, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAC6B0: 4802E541  bl 0x82adabf0
	ctx.lr = 0x82AAC6B4;
	sub_82ADABF0(ctx, base);
	// 82AAC6B4: 480001B8  b 0x82aac86c
	pc = 0x82AAC86C; continue 'dispatch;
	// 82AAC6B8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AAC6BC: 4BD65DBD  bl 0x82812478
	ctx.lr = 0x82AAC6C0;
	sub_82812478(ctx, base);
	// 82AAC6C0: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC6C4: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC6C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AAC6CC: 419A0024  beq cr6, 0x82aac6f0
	if ctx.cr[6].eq {
	pc = 0x82AAC6F0; continue 'dispatch;
	}
	// 82AAC6D0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AAC6D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC6D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC6DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC6E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC6E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC6E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC6EC: 4082FFE8  bne 0x82aac6d4
	if !ctx.cr[0].eq {
	pc = 0x82AAC6D4; continue 'dispatch;
	}
	// 82AAC6F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC6F8: 388B7494  addi r4, r11, 0x7494
	ctx.r[4].s64 = ctx.r[11].s64 + 29844;
	// 82AAC6FC: 4834730D  bl 0x82df3a08
	ctx.lr = 0x82AAC700;
	sub_82DF3A08(ctx, base);
	// 82AAC700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAC704: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AAC708: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAC70C: 48368925  bl 0x82e15030
	ctx.lr = 0x82AAC710;
	sub_82E15030(ctx, base);
	// 82AAC710: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAC714: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AAC718: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AAC71C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC720: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AAC724: 4B817D3D  bl 0x822c4460
	ctx.lr = 0x82AAC728;
	sub_822C4460(ctx, base);
	// 82AAC728: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AAC72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC730: 419A0008  beq cr6, 0x82aac738
	if ctx.cr[6].eq {
	pc = 0x82AAC738; continue 'dispatch;
	}
	// 82AAC734: 4B81415D  bl 0x822c0890
	ctx.lr = 0x82AAC738;
	sub_822C0890(ctx, base);
	// 82AAC738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC73C: 48346CED  bl 0x82df3428
	ctx.lr = 0x82AAC740;
	sub_82DF3428(ctx, base);
	// 82AAC740: 809F0190  lwz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82AAC744: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAC748: 4802E379  bl 0x82adaac0
	ctx.lr = 0x82AAC74C;
	sub_82ADAAC0(ctx, base);
	// 82AAC74C: 939F0190  stw r28, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[28].u32 ) };
	// 82AAC750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC754: 4BA65395  bl 0x82511ae8
	ctx.lr = 0x82AAC758;
	sub_82511AE8(ctx, base);
	// 82AAC758: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AAC75C: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AAC760: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC764: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAC768: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AAC76C: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 82AAC770: C04B6218  lfs f2, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC774: C02A4430  lfs f1, 0x4430(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAC778: 4802E479  bl 0x82adabf0
	ctx.lr = 0x82AAC77C;
	sub_82ADABF0(ctx, base);
	// 82AAC77C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AAC780: 419A000C  beq cr6, 0x82aac78c
	if ctx.cr[6].eq {
	pc = 0x82AAC78C; continue 'dispatch;
	}
	// 82AAC784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAC788: 4B814109  bl 0x822c0890
	ctx.lr = 0x82AAC78C;
	sub_822C0890(ctx, base);
	// 82AAC78C: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82AAC790: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAC794: 480000D8  b 0x82aac86c
	pc = 0x82AAC86C; continue 'dispatch;
	// 82AAC798: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AAC79C: 4BD65CDD  bl 0x82812478
	ctx.lr = 0x82AAC7A0;
	sub_82812478(ctx, base);
	// 82AAC7A0: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC7A4: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC7A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AAC7AC: 419A0024  beq cr6, 0x82aac7d0
	if ctx.cr[6].eq {
	pc = 0x82AAC7D0; continue 'dispatch;
	}
	// 82AAC7B0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82AAC7B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC7B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC7BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC7C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC7C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC7C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC7CC: 4082FFE8  bne 0x82aac7b4
	if !ctx.cr[0].eq {
	pc = 0x82AAC7B4; continue 'dispatch;
	}
	// 82AAC7D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAC7D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC7D8: 388B7494  addi r4, r11, 0x7494
	ctx.r[4].s64 = ctx.r[11].s64 + 29844;
	// 82AAC7DC: 4834722D  bl 0x82df3a08
	ctx.lr = 0x82AAC7E0;
	sub_82DF3A08(ctx, base);
	// 82AAC7E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AAC7E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AAC7E8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAC7EC: 48368845  bl 0x82e15030
	ctx.lr = 0x82AAC7F0;
	sub_82E15030(ctx, base);
	// 82AAC7F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AAC7F4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82AAC7F8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AAC7FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC800: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AAC804: 4B817C5D  bl 0x822c4460
	ctx.lr = 0x82AAC808;
	sub_822C4460(ctx, base);
	// 82AAC808: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AAC80C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC810: 419A0008  beq cr6, 0x82aac818
	if ctx.cr[6].eq {
	pc = 0x82AAC818; continue 'dispatch;
	}
	// 82AAC814: 4B81407D  bl 0x822c0890
	ctx.lr = 0x82AAC818;
	sub_822C0890(ctx, base);
	// 82AAC818: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAC81C: 48346C0D  bl 0x82df3428
	ctx.lr = 0x82AAC820;
	sub_82DF3428(ctx, base);
	// 82AAC820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAC824: 4BA652C5  bl 0x82511ae8
	ctx.lr = 0x82AAC828;
	sub_82511AE8(ctx, base);
	// 82AAC828: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AAC82C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AAC830: 813F0188  lwz r9, 0x188(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAC834: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AAC838: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82AAC83C: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 82AAC840: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82AAC844: C04B6218  lfs f2, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AAC848: C02ADD6C  lfs f1, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAC84C: 4802E3A5  bl 0x82adabf0
	ctx.lr = 0x82AAC850;
	sub_82ADABF0(ctx, base);
	// 82AAC850: 907F0190  stw r3, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82AAC854: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82AAC858: 419A000C  beq cr6, 0x82aac864
	if ctx.cr[6].eq {
	pc = 0x82AAC864; continue 'dispatch;
	}
	// 82AAC85C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAC860: 4B814031  bl 0x822c0890
	ctx.lr = 0x82AAC864;
	sub_822C0890(ctx, base);
	// 82AAC864: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82AAC868: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC86C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC870: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC874: 48347195  bl 0x82df3a08
	ctx.lr = 0x82AAC878;
	sub_82DF3A08(ctx, base);
	// 82AAC878: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AAC87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC880: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AAC884: 409A0008  bne cr6, 0x82aac88c
	if !ctx.cr[6].eq {
	pc = 0x82AAC88C; continue 'dispatch;
	}
	// 82AAC888: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AAC88C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82AAC890: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82AAC894: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AAC898: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAC89C: 4BD28415  bl 0x827d4cb0
	ctx.lr = 0x82AAC8A0;
	sub_827D4CB0(ctx, base);
	// 82AAC8A0: 397B002E  addi r11, r27, 0x2e
	ctx.r[11].s64 = ctx.r[27].s64 + 46;
	// 82AAC8A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC8A8: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82AAC8AC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAC8B0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AAC8B4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82AAC8B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AAC8BC: 4B817BA5  bl 0x822c4460
	ctx.lr = 0x82AAC8C0;
	sub_822C4460(ctx, base);
	// 82AAC8C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AAC8C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC8C8: 419A0008  beq cr6, 0x82aac8d0
	if ctx.cr[6].eq {
	pc = 0x82AAC8D0; continue 'dispatch;
	}
	// 82AAC8CC: 4B813FC5  bl 0x822c0890
	ctx.lr = 0x82AAC8D0;
	sub_822C0890(ctx, base);
	// 82AAC8D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC8D4: 48346B55  bl 0x82df3428
	ctx.lr = 0x82AAC8D8;
	sub_82DF3428(ctx, base);
	// 82AAC8D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AAC8DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC8E0: 419A0008  beq cr6, 0x82aac8e8
	if ctx.cr[6].eq {
	pc = 0x82AAC8E8; continue 'dispatch;
	}
	// 82AAC8E4: 4B813FAD  bl 0x822c0890
	ctx.lr = 0x82AAC8E8;
	sub_822C0890(ctx, base);
	// 82AAC8E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAC8EC: 483453A5  bl 0x82df1c90
	ctx.lr = 0x82AAC8F0;
	sub_82DF1C90(ctx, base);
	// 82AAC8F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AAC8F4: 486FB8C0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC8F8 size=180
    let mut pc: u32 = 0x82AAC8F8;
    'dispatch: loop {
        match pc {
            0x82AAC8F8 => {
    //   block [0x82AAC8F8..0x82AAC9AC)
	// 82AAC8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAC904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAC908: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC90C: 3964002E  addi r11, r4, 0x2e
	ctx.r[11].s64 = ctx.r[4].s64 + 46;
	// 82AAC910: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AAC914: 7FEB1A14  add r31, r11, r3
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82AAC918: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82AAC91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC920: 419A0074  beq cr6, 0x82aac994
	if ctx.cr[6].eq {
	pc = 0x82AAC994; continue 'dispatch;
	}
	// 82AAC924: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAC928: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC92C: 4BA62B9D  bl 0x8250f4c8
	ctx.lr = 0x82AAC930;
	sub_8250F4C8(ctx, base);
	// 82AAC930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC934: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AAC938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC93C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AAC940: 409A0008  bne cr6, 0x82aac948
	if !ctx.cr[6].eq {
	pc = 0x82AAC948; continue 'dispatch;
	}
	// 82AAC944: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAC948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC94C: 4BA5E005  bl 0x8250a950
	ctx.lr = 0x82AAC950;
	sub_8250A950(ctx, base);
	// 82AAC950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAC954: 4834533D  bl 0x82df1c90
	ctx.lr = 0x82AAC958;
	sub_82DF1C90(ctx, base);
	// 82AAC958: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAC95C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC960: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AAC964: 409A0008  bne cr6, 0x82aac96c
	if !ctx.cr[6].eq {
	pc = 0x82AAC96C; continue 'dispatch;
	}
	// 82AAC968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAC96C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAC970: 4BD27091  bl 0x827d3a00
	ctx.lr = 0x82AAC974;
	sub_827D3A00(ctx, base);
	// 82AAC974: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AAC978: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC97C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAC980: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AAC984: 419A0008  beq cr6, 0x82aac98c
	if ctx.cr[6].eq {
	pc = 0x82AAC98C; continue 'dispatch;
	}
	// 82AAC988: 4B813F09  bl 0x822c0890
	ctx.lr = 0x82AAC98C;
	sub_822C0890(ctx, base);
	// 82AAC98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAC990: 48345301  bl 0x82df1c90
	ctx.lr = 0x82AAC994;
	sub_82DF1C90(ctx, base);
	// 82AAC994: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAC998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAC99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAC9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAC9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAC9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAC9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAC9B0 size=92
    let mut pc: u32 = 0x82AAC9B0;
    'dispatch: loop {
        match pc {
            0x82AAC9B0 => {
    //   block [0x82AAC9B0..0x82AACA0C)
	// 82AAC9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAC9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAC9B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAC9BC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAC9C0: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAC9C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAC9C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAC9CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AAC9D0: 419A0024  beq cr6, 0x82aac9f4
	if ctx.cr[6].eq {
	pc = 0x82AAC9F4; continue 'dispatch;
	}
	// 82AAC9D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AAC9D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAC9DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC9E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAC9E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAC9E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAC9EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAC9F0: 4082FFE8  bne 0x82aac9d8
	if !ctx.cr[0].eq {
	pc = 0x82AAC9D8; continue 'dispatch;
	}
	// 82AAC9F4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AAC9F8: 4BA66701  bl 0x825130f8
	ctx.lr = 0x82AAC9FC;
	sub_825130F8(ctx, base);
	// 82AAC9FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AACA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACA08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACA10 size=124
    let mut pc: u32 = 0x82AACA10;
    'dispatch: loop {
        match pc {
            0x82AACA10 => {
    //   block [0x82AACA10..0x82AACA8C)
	// 82AACA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACA14: 486FB759  bl 0x831a816c
	ctx.lr = 0x82AACA18;
	sub_831A8130(ctx, base);
	// 82AACA18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACA1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AACA20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AACA24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AACA28: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AACA2C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AACA30: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AACA34: 483459B5  bl 0x82df23e8
	ctx.lr = 0x82AACA38;
	sub_82DF23E8(ctx, base);
	// 82AACA38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AACA3C: 4182001C  beq 0x82aaca58
	if ctx.cr[0].eq {
	pc = 0x82AACA58; continue 'dispatch;
	}
	// 82AACA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACA44: 483ACC3D  bl 0x82e59680
	ctx.lr = 0x82AACA48;
	sub_82E59680(ctx, base);
	// 82AACA48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AACA4C: 396B72A0  addi r11, r11, 0x72a0
	ctx.r[11].s64 = ctx.r[11].s64 + 29344;
	// 82AACA50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AACA54: 48000008  b 0x82aaca5c
	pc = 0x82AACA5C; continue 'dispatch;
	// 82AACA58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AACA5C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AACA60: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AACA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACA68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACA6C: 4BFFF0ED  bl 0x82aabb58
	ctx.lr = 0x82AACA70;
	sub_82AABB58(ctx, base);
	// 82AACA70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AACA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACA7C: 4B813585  bl 0x822c0000
	ctx.lr = 0x82AACA80;
	sub_822C0000(ctx, base);
	// 82AACA80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AACA84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACA88: 486FB734  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACA90 size=124
    let mut pc: u32 = 0x82AACA90;
    'dispatch: loop {
        match pc {
            0x82AACA90 => {
    //   block [0x82AACA90..0x82AACB0C)
	// 82AACA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACA94: 486FB6D9  bl 0x831a816c
	ctx.lr = 0x82AACA98;
	sub_831A8130(ctx, base);
	// 82AACA98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACA9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AACAA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AACAA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AACAA8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AACAAC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AACAB0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AACAB4: 48345935  bl 0x82df23e8
	ctx.lr = 0x82AACAB8;
	sub_82DF23E8(ctx, base);
	// 82AACAB8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AACABC: 4182001C  beq 0x82aacad8
	if ctx.cr[0].eq {
	pc = 0x82AACAD8; continue 'dispatch;
	}
	// 82AACAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACAC4: 483ACBBD  bl 0x82e59680
	ctx.lr = 0x82AACAC8;
	sub_82E59680(ctx, base);
	// 82AACAC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AACACC: 396B72A8  addi r11, r11, 0x72a8
	ctx.r[11].s64 = ctx.r[11].s64 + 29352;
	// 82AACAD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AACAD4: 48000008  b 0x82aacadc
	pc = 0x82AACADC; continue 'dispatch;
	// 82AACAD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AACADC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AACAE0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AACAE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACAE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACAEC: 4BFFF135  bl 0x82aabc20
	ctx.lr = 0x82AACAF0;
	sub_82AABC20(ctx, base);
	// 82AACAF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AACAF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACAF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACAFC: 4B813505  bl 0x822c0000
	ctx.lr = 0x82AACB00;
	sub_822C0000(ctx, base);
	// 82AACB00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AACB04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACB08: 486FB6B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AACB10 size=408
    let mut pc: u32 = 0x82AACB10;
    'dispatch: loop {
        match pc {
            0x82AACB10 => {
    //   block [0x82AACB10..0x82AACCA8)
	// 82AACB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACB14: 486FB659  bl 0x831a816c
	ctx.lr = 0x82AACB18;
	sub_831A8130(ctx, base);
	// 82AACB18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACB1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACB20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AACB24: 4BA6580D  bl 0x82512330
	ctx.lr = 0x82AACB28;
	sub_82512330(ctx, base);
	// 82AACB28: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AACB2C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82AACB30: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 82AACB34: 3969A214  addi r11, r9, -0x5dec
	ctx.r[11].s64 = ctx.r[9].s64 + -24044;
	// 82AACB38: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82AACB3C: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82AACB40: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82AACB44: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82AACB48: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AACB4C: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 82AACB50: 3C808202  lis r4, -0x7dfe
	ctx.r[4].s64 = -2113798144;
	// 82AACB54: 3C608200  lis r3, -0x7e00
	ctx.r[3].s64 = -2113929216;
	// 82AACB58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AACB5C: 390873B4  addi r8, r8, 0x73b4
	ctx.r[8].s64 = ctx.r[8].s64 + 29620;
	// 82AACB60: C00A726C  lfs f0, 0x726c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(29292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AACB64: 38E773A0  addi r7, r7, 0x73a0
	ctx.r[7].s64 = ctx.r[7].s64 + 29600;
	// 82AACB68: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82AACB6C: 3BA67354  addi r29, r6, 0x7354
	ctx.r[29].s64 = ctx.r[6].s64 + 29524;
	// 82AACB70: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AACB74: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82AACB78: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AACB7C: 93BF00E4  stw r29, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 82AACB80: C1A46218  lfs f13, 0x6218(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AACB84: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82AACB88: C18308A4  lfs f12, 0x8a4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AACB8C: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82AACB90: 39000130  li r8, 0x130
	ctx.r[8].s64 = 304;
	// 82AACB94: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AACB98: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACCA8 size=76
    let mut pc: u32 = 0x82AACCA8;
    'dispatch: loop {
        match pc {
            0x82AACCA8 => {
    //   block [0x82AACCA8..0x82AACCF4)
	// 82AACCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACCB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AACCB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AACCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACCBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACCC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AACCC4: 4BFFF065  bl 0x82aabd28
	ctx.lr = 0x82AACCC8;
	sub_82AABD28(ctx, base);
	// 82AACCC8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AACCCC: 4182000C  beq 0x82aaccd8
	if ctx.cr[0].eq {
	pc = 0x82AACCD8; continue 'dispatch;
	}
	// 82AACCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACCD4: 48345705  bl 0x82df23d8
	ctx.lr = 0x82AACCD8;
	sub_82DF23D8(ctx, base);
	// 82AACCD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACCDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACCE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AACCEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AACCF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AACCF8 size=120
    let mut pc: u32 = 0x82AACCF8;
    'dispatch: loop {
        match pc {
            0x82AACCF8 => {
    //   block [0x82AACCF8..0x82AACD70)
	// 82AACCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACCFC: 486FB471  bl 0x831a816c
	ctx.lr = 0x82AACD00;
	sub_831A8130(ctx, base);
	// 82AACD00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACD04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AACD08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AACD0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AACD10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AACD14: 388B7310  addi r4, r11, 0x7310
	ctx.r[4].s64 = ctx.r[11].s64 + 29456;
	// 82AACD18: 38A000BA  li r5, 0xba
	ctx.r[5].s64 = 186;
	// 82AACD1C: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 82AACD20: 483456C9  bl 0x82df23e8
	ctx.lr = 0x82AACD24;
	sub_82DF23E8(ctx, base);
	// 82AACD24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AACD28: 41820014  beq 0x82aacd3c
	if ctx.cr[0].eq {
	pc = 0x82AACD3C; continue 'dispatch;
	}
	// 82AACD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACD30: 4BFFFDE1  bl 0x82aacb10
	ctx.lr = 0x82AACD34;
	sub_82AACB10(ctx, base);
	// 82AACD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACD38: 48000008  b 0x82aacd40
	pc = 0x82AACD40; continue 'dispatch;
	// 82AACD3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AACD40: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AACD44: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AACD48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACD4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACD50: 4BFFEC79  bl 0x82aab9c8
	ctx.lr = 0x82AACD54;
	sub_82AAB9C8(ctx, base);
	// 82AACD54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AACD58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AACD5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AACD60: 4B8132A1  bl 0x822c0000
	ctx.lr = 0x82AACD64;
	sub_822C0000(ctx, base);
	// 82AACD64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AACD68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACD6C: 486FB450  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AACD70 size=228
    let mut pc: u32 = 0x82AACD70;
    'dispatch: loop {
        match pc {
            0x82AACD70 => {
    //   block [0x82AACD70..0x82AACE54)
	// 82AACD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACD74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACD78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AACD7C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACD80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACD84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AACD88: 419A00B8  beq cr6, 0x82aace40
	if ctx.cr[6].eq {
	pc = 0x82AACE40; continue 'dispatch;
	}
	// 82AACD8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AACD90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AACD94: 388B74B4  addi r4, r11, 0x74b4
	ctx.r[4].s64 = ctx.r[11].s64 + 29876;
	// 82AACD98: 48346C71  bl 0x82df3a08
	ctx.lr = 0x82AACD9C;
	sub_82DF3A08(ctx, base);
	// 82AACD9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AACDA0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82AACDA4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AACDA8: 3D00832F  lis r8, -0x7cd1
	ctx.r[8].s64 = -2094071808;
	// 82AACDAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AACDB0: 3888D404  addi r4, r8, -0x2bfc
	ctx.r[4].s64 = ctx.r[8].s64 + -11260;
	// 82AACDB4: C06B89AC  lfs f3, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AACDB8: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AACDBC: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AACDC0: 4BAF63F1  bl 0x825a31b0
	ctx.lr = 0x82AACDC4;
	sub_825A31B0(ctx, base);
	// 82AACDC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AACDC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AACDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACDD0: 4BAF49A1  bl 0x825a1770
	ctx.lr = 0x82AACDD4;
	sub_825A1770(ctx, base);
	// 82AACDD4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AACDD8: 48346651  bl 0x82df3428
	ctx.lr = 0x82AACDDC;
	sub_82DF3428(ctx, base);
	// 82AACDDC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AACDE0: 4B81BED9  bl 0x822c8cb8
	ctx.lr = 0x82AACDE4;
	sub_822C8CB8(ctx, base);
	// 82AACDE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AACDE8: 48346641  bl 0x82df3428
	ctx.lr = 0x82AACDEC;
	sub_82DF3428(ctx, base);
	// 82AACDEC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AACDF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AACDF4: 388B74A8  addi r4, r11, 0x74a8
	ctx.r[4].s64 = ctx.r[11].s64 + 29864;
	// 82AACDF8: 48346C11  bl 0x82df3a08
	ctx.lr = 0x82AACDFC;
	sub_82DF3A08(ctx, base);
	// 82AACDFC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AACE00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82AACE04: 388BD408  addi r4, r11, -0x2bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -11256;
	// 82AACE08: 38C003E8  li r6, 0x3e8
	ctx.r[6].s64 = 1000;
	// 82AACE0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AACE10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AACE14: 4BAF6595  bl 0x825a33a8
	ctx.lr = 0x82AACE18;
	sub_825A33A8(ctx, base);
	// 82AACE18: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AACE1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AACE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACE24: 4BAF50B5  bl 0x825a1ed8
	ctx.lr = 0x82AACE28;
	sub_825A1ED8(ctx, base);
	// 82AACE28: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AACE2C: 483465FD  bl 0x82df3428
	ctx.lr = 0x82AACE30;
	sub_82DF3428(ctx, base);
	// 82AACE30: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AACE34: 4B81BE85  bl 0x822c8cb8
	ctx.lr = 0x82AACE38;
	sub_822C8CB8(ctx, base);
	// 82AACE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AACE3C: 483465ED  bl 0x82df3428
	ctx.lr = 0x82AACE40;
	sub_82DF3428(ctx, base);
	// 82AACE40: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82AACE44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACE48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AACE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AACE58 size=136
    let mut pc: u32 = 0x82AACE58;
    'dispatch: loop {
        match pc {
            0x82AACE58 => {
    //   block [0x82AACE58..0x82AACEE0)
	// 82AACE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACE60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AACE64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACE68: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AACE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AACE74: 388B60C8  addi r4, r11, 0x60c8
	ctx.r[4].s64 = ctx.r[11].s64 + 24776;
	// 82AACE78: 48346B91  bl 0x82df3a08
	ctx.lr = 0x82AACE7C;
	sub_82DF3A08(ctx, base);
	// 82AACE7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AACE80: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AACE84: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AACE88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AACE8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AACE90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AACE94: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AACE98: 483B1AC9  bl 0x82e5e960
	ctx.lr = 0x82AACE9C;
	sub_82E5E960(ctx, base);
	// 82AACE9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AACEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AACEA4: 419A0008  beq cr6, 0x82aaceac
	if ctx.cr[6].eq {
	pc = 0x82AACEAC; continue 'dispatch;
	}
	// 82AACEA8: 4B8139E9  bl 0x822c0890
	ctx.lr = 0x82AACEAC;
	sub_822C0890(ctx, base);
	// 82AACEAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AACEB0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AACEB4: 997F0118  stb r11, 0x118(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u8 ) };
	// 82AACEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACEBC: 4BFFF735  bl 0x82aac5f0
	ctx.lr = 0x82AACEC0;
	sub_82AAC5F0(ctx, base);
	// 82AACEC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AACEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACEC8: 4BFFFA31  bl 0x82aac8f8
	ctx.lr = 0x82AACECC;
	sub_82AAC8F8(ctx, base);
	// 82AACECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AACED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AACED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AACED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AACEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AACEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AACEE0 size=324
    let mut pc: u32 = 0x82AACEE0;
    'dispatch: loop {
        match pc {
            0x82AACEE0 => {
    //   block [0x82AACEE0..0x82AAD024)
	// 82AACEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AACEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AACEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AACEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AACEF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AACEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AACEF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AACEFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AACF00: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AACF04: 48000EFD  bl 0x82aade00
	ctx.lr = 0x82AACF08;
	sub_82AADE00(ctx, base);
	// 82AACF08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AACF0C: 41820100  beq 0x82aad00c
	if ctx.cr[0].eq {
	pc = 0x82AAD00C; continue 'dispatch;
	}
	// 82AACF10: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AACF14: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AACF18: 48109531  bl 0x82bb6448
	ctx.lr = 0x82AACF1C;
	sub_82BB6448(ctx, base);
	// 82AACF1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AACF20: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AACF24: 409A00C8  bne cr6, 0x82aacfec
	if !ctx.cr[6].eq {
	pc = 0x82AACFEC; continue 'dispatch;
	}
	// 82AACF28: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 82AACF2C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82AACF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AACF34: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD028 size=408
    let mut pc: u32 = 0x82AAD028;
    'dispatch: loop {
        match pc {
            0x82AAD028 => {
    //   block [0x82AAD028..0x82AAD1C0)
	// 82AAD028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD038: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD03C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAD040: 817E012C  lwz r11, 0x12c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 82AAD044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAD048: 409A015C  bne cr6, 0x82aad1a4
	if !ctx.cr[6].eq {
	pc = 0x82AAD1A4; continue 'dispatch;
	}
	// 82AAD04C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AAD050: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82AAD054: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AAD058: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82AAD05C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AAD060: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82AAD064: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAD068: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD1C0 size=224
    let mut pc: u32 = 0x82AAD1C0;
    'dispatch: loop {
        match pc {
            0x82AAD1C0 => {
    //   block [0x82AAD1C0..0x82AAD2A0)
	// 82AAD1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD1D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAD1D8: 897E0150  lbz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82AAD1DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAD1E0: 408200A8  bne 0x82aad288
	if !ctx.cr[0].eq {
	pc = 0x82AAD288; continue 'dispatch;
	}
	// 82AAD1E4: 4BFAF055  bl 0x82a5c238
	ctx.lr = 0x82AAD1E8;
	sub_82A5C238(ctx, base);
	// 82AAD1E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAD1EC: 40820010  bne 0x82aad1fc
	if !ctx.cr[0].eq {
	pc = 0x82AAD1FC; continue 'dispatch;
	}
	// 82AAD1F0: 480037D9  bl 0x82ab09c8
	ctx.lr = 0x82AAD1F4;
	sub_82AB09C8(ctx, base);
	// 82AAD1F4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAD1F8: 41820090  beq 0x82aad288
	if ctx.cr[0].eq {
	pc = 0x82AAD288; continue 'dispatch;
	}
	// 82AAD1FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAD200: 4BFFF811  bl 0x82aaca10
	ctx.lr = 0x82AAD204;
	sub_82AACA10(ctx, base);
	// 82AAD204: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD208: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAD20C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAD210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAD214: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAD218: 419A0024  beq cr6, 0x82aad23c
	if ctx.cr[6].eq {
	pc = 0x82AAD23C; continue 'dispatch;
	}
	// 82AAD21C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AAD220: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAD224: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD228: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAD22C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAD230: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD234: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD238: 4082FFE8  bne 0x82aad220
	if !ctx.cr[0].eq {
	pc = 0x82AAD220; continue 'dispatch;
	}
	// 82AAD23C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAD240: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAD244: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AAD248: 388A7310  addi r4, r10, 0x7310
	ctx.r[4].s64 = ctx.r[10].s64 + 29456;
	// 82AAD24C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AAD250: 38A00308  li r5, 0x308
	ctx.r[5].s64 = 776;
	// 82AAD254: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD258: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AAD25C: 483AB7E5  bl 0x82e58a40
	ctx.lr = 0x82AAD260;
	sub_82E58A40(ctx, base);
	// 82AAD260: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AAD264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD268: 419A0008  beq cr6, 0x82aad270
	if ctx.cr[6].eq {
	pc = 0x82AAD270; continue 'dispatch;
	}
	// 82AAD26C: 4B813625  bl 0x822c0890
	ctx.lr = 0x82AAD270;
	sub_822C0890(ctx, base);
	// 82AAD270: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AAD274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD278: 419A0008  beq cr6, 0x82aad280
	if ctx.cr[6].eq {
	pc = 0x82AAD280; continue 'dispatch;
	}
	// 82AAD27C: 4B813615  bl 0x822c0890
	ctx.lr = 0x82AAD280;
	sub_822C0890(ctx, base);
	// 82AAD280: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAD284: 997E0150  stb r11, 0x150(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(336 as u32), ctx.r[11].u8 ) };
	// 82AAD288: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAD28C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD290: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD294: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAD298: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD2A0 size=204
    let mut pc: u32 = 0x82AAD2A0;
    'dispatch: loop {
        match pc {
            0x82AAD2A0 => {
    //   block [0x82AAD2A0..0x82AAD36C)
	// 82AAD2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD2A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD2AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD2B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD2B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAD2B8: 4BFAEF81  bl 0x82a5c238
	ctx.lr = 0x82AAD2BC;
	sub_82A5C238(ctx, base);
	// 82AAD2BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAD2C0: 40820010  bne 0x82aad2d0
	if !ctx.cr[0].eq {
	pc = 0x82AAD2D0; continue 'dispatch;
	}
	// 82AAD2C4: 48003705  bl 0x82ab09c8
	ctx.lr = 0x82AAD2C8;
	sub_82AB09C8(ctx, base);
	// 82AAD2C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AAD2CC: 41820088  beq 0x82aad354
	if ctx.cr[0].eq {
	pc = 0x82AAD354; continue 'dispatch;
	}
	// 82AAD2D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAD2D4: 4BFFF7BD  bl 0x82aaca90
	ctx.lr = 0x82AAD2D8;
	sub_82AACA90(ctx, base);
	// 82AAD2D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD2DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAD2E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAD2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAD2E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AAD2EC: 419A0024  beq cr6, 0x82aad310
	if ctx.cr[6].eq {
	pc = 0x82AAD310; continue 'dispatch;
	}
	// 82AAD2F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AAD2F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAD2F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD2FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAD300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAD304: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD308: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD30C: 4082FFE8  bne 0x82aad2f4
	if !ctx.cr[0].eq {
	pc = 0x82AAD2F4; continue 'dispatch;
	}
	// 82AAD310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAD314: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAD318: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AAD31C: 388A7310  addi r4, r10, 0x7310
	ctx.r[4].s64 = ctx.r[10].s64 + 29456;
	// 82AAD320: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82AAD324: 38A00318  li r5, 0x318
	ctx.r[5].s64 = 792;
	// 82AAD328: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD32C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82AAD330: 483AB711  bl 0x82e58a40
	ctx.lr = 0x82AAD334;
	sub_82E58A40(ctx, base);
	// 82AAD334: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AAD338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD33C: 419A0008  beq cr6, 0x82aad344
	if ctx.cr[6].eq {
	pc = 0x82AAD344; continue 'dispatch;
	}
	// 82AAD340: 4B813551  bl 0x822c0890
	ctx.lr = 0x82AAD344;
	sub_822C0890(ctx, base);
	// 82AAD344: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AAD348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD34C: 419A0008  beq cr6, 0x82aad354
	if ctx.cr[6].eq {
	pc = 0x82AAD354; continue 'dispatch;
	}
	// 82AAD350: 4B813541  bl 0x822c0890
	ctx.lr = 0x82AAD354;
	sub_822C0890(ctx, base);
	// 82AAD354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAD358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD35C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD360: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAD364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD370 size=52
    let mut pc: u32 = 0x82AAD370;
    'dispatch: loop {
        match pc {
            0x82AAD370 => {
    //   block [0x82AAD370..0x82AAD3A4)
	// 82AAD370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD378: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD37C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD380: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD384: 4BFFFF1D  bl 0x82aad2a0
	ctx.lr = 0x82AAD388;
	sub_82AAD2A0(ctx, base);
	// 82AAD388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD38C: 4BA63245  bl 0x825105d0
	ctx.lr = 0x82AAD390;
	sub_825105D0(ctx, base);
	// 82AAD390: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAD394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD3A8 size=220
    let mut pc: u32 = 0x82AAD3A8;
    'dispatch: loop {
        match pc {
            0x82AAD3A8 => {
    //   block [0x82AAD3A8..0x82AAD484)
	// 82AAD3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD3AC: 486FADBD  bl 0x831a8168
	ctx.lr = 0x82AAD3B0;
	sub_831A8130(ctx, base);
	// 82AAD3B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD3B4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AAD3B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAD3BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAD3C0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AAD3C4: 41820038  beq 0x82aad3fc
	if ctx.cr[0].eq {
	pc = 0x82AAD3FC; continue 'dispatch;
	}
	// 82AAD3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD3CC: 486FC5BD  bl 0x831a9988
	ctx.lr = 0x82AAD3D0;
	sub_831A9988(ctx, base);
	// 82AAD3D0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82AAD3D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD3D8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82AAD3DC: 486FAD1D  bl 0x831a80f8
	ctx.lr = 0x82AAD3E0;
	sub_831A80F8(ctx, base);
	// 82AAD3E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD3E4: 41820018  beq 0x82aad3fc
	if ctx.cr[0].eq {
	pc = 0x82AAD3FC; continue 'dispatch;
	}
	// 82AAD3E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD3EC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AAD3F0: 4BFFFAF1  bl 0x82aacee0
	ctx.lr = 0x82AAD3F4;
	sub_82AACEE0(ctx, base);
	// 82AAD3F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAD3F8: 48000084  b 0x82aad47c
	pc = 0x82AAD47C; continue 'dispatch;
	// 82AAD3FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAD400: 419A006C  beq cr6, 0x82aad46c
	if ctx.cr[6].eq {
	pc = 0x82AAD46C; continue 'dispatch;
	}
	// 82AAD404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD408: 486FC581  bl 0x831a9988
	ctx.lr = 0x82AAD40C;
	sub_831A9988(ctx, base);
	// 82AAD40C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82AAD410: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD414: 386B50B0  addi r3, r11, 0x50b0
	ctx.r[3].s64 = ctx.r[11].s64 + 20656;
	// 82AAD418: 486FACE1  bl 0x831a80f8
	ctx.lr = 0x82AAD41C;
	sub_831A80F8(ctx, base);
	// 82AAD41C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD420: 41820014  beq 0x82aad434
	if ctx.cr[0].eq {
	pc = 0x82AAD434; continue 'dispatch;
	}
	// 82AAD424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD428: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AAD42C: 4BFFFF45  bl 0x82aad370
	ctx.lr = 0x82AAD430;
	sub_82AAD370(ctx, base);
	// 82AAD430: 4BFFFFC4  b 0x82aad3f4
	pc = 0x82AAD3F4; continue 'dispatch;
	// 82AAD434: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAD438: 419A0034  beq cr6, 0x82aad46c
	if ctx.cr[6].eq {
	pc = 0x82AAD46C; continue 'dispatch;
	}
	// 82AAD43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD440: 486FC549  bl 0x831a9988
	ctx.lr = 0x82AAD444;
	sub_831A9988(ctx, base);
	// 82AAD444: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82AAD448: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AAD44C: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82AAD450: 486FACA9  bl 0x831a80f8
	ctx.lr = 0x82AAD454;
	sub_831A80F8(ctx, base);
	// 82AAD454: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD458: 41820014  beq 0x82aad46c
	if ctx.cr[0].eq {
	pc = 0x82AAD46C; continue 'dispatch;
	}
	// 82AAD45C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD460: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82AAD464: 4BFFE8B5  bl 0x82aabd18
	ctx.lr = 0x82AAD468;
	sub_82AABD18(ctx, base);
	// 82AAD468: 4BFFFF8C  b 0x82aad3f4
	pc = 0x82AAD3F4; continue 'dispatch;
	// 82AAD46C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82AAD470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAD478: 4BA651A1  bl 0x82512618
	ctx.lr = 0x82AAD47C;
	sub_82512618(ctx, base);
	// 82AAD47C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAD480: 486FAD38  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAD488 size=336
    let mut pc: u32 = 0x82AAD488;
    'dispatch: loop {
        match pc {
            0x82AAD488 => {
    //   block [0x82AAD488..0x82AAD5D8)
	// 82AAD488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD498: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD5D8 size=220
    let mut pc: u32 = 0x82AAD5D8;
    'dispatch: loop {
        match pc {
            0x82AAD5D8 => {
    //   block [0x82AAD5D8..0x82AAD6B4)
	// 82AAD5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD5E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD5E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD5E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD5F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAD5F4: 897F0158  lbz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82AAD5F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AAD5FC: 409A000C  bne cr6, 0x82aad608
	if !ctx.cr[6].eq {
	pc = 0x82AAD608; continue 'dispatch;
	}
	// 82AAD600: 4BFFE139  bl 0x82aab738
	ctx.lr = 0x82AAD604;
	sub_82AAB738(ctx, base);
	// 82AAD604: 48000098  b 0x82aad69c
	pc = 0x82AAD69C; continue 'dispatch;
	// 82AAD608: 897F0151  lbz r11, 0x151(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(337 as u32) ) } as u64;
	// 82AAD60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD610: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAD614: 4182000C  beq 0x82aad620
	if ctx.cr[0].eq {
	pc = 0x82AAD620; continue 'dispatch;
	}
	// 82AAD618: 4BFFE271  bl 0x82aab888
	ctx.lr = 0x82AAD61C;
	sub_82AAB888(ctx, base);
	// 82AAD61C: 48000080  b 0x82aad69c
	pc = 0x82AAD69C; continue 'dispatch;
	// 82AAD620: 4BFFE2B9  bl 0x82aab8d8
	ctx.lr = 0x82AAD624;
	sub_82AAB8D8(ctx, base);
	// 82AAD624: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD628: 40820074  bne 0x82aad69c
	if !ctx.cr[0].eq {
	pc = 0x82AAD69C; continue 'dispatch;
	}
	// 82AAD62C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AAD630: 4BD64E49  bl 0x82812478
	ctx.lr = 0x82AAD634;
	sub_82812478(ctx, base);
	// 82AAD634: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAD638: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAD63C: 483511A5  bl 0x82dfe7e0
	ctx.lr = 0x82AAD640;
	sub_82DFE7E0(ctx, base);
	// 82AAD640: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD644: 41820058  beq 0x82aad69c
	if ctx.cr[0].eq {
	pc = 0x82AAD69C; continue 'dispatch;
	}
	// 82AAD648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD64C: 4BFFE865  bl 0x82aabeb0
	ctx.lr = 0x82AAD650;
	sub_82AABEB0(ctx, base);
	// 82AAD650: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD654: 41820048  beq 0x82aad69c
	if ctx.cr[0].eq {
	pc = 0x82AAD69C; continue 'dispatch;
	}
	// 82AAD658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD65C: 4BFFFB65  bl 0x82aad1c0
	ctx.lr = 0x82AAD660;
	sub_82AAD1C0(ctx, base);
	// 82AAD660: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD664: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AAD668: 4800FF59  bl 0x82abd5c0
	ctx.lr = 0x82AAD66C;
	sub_82ABD5C0(ctx, base);
	// 82AAD66C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD670: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AAD674: 480001F5  bl 0x82aad868
	ctx.lr = 0x82AAD678;
	sub_82AAD868(ctx, base);
	// 82AAD678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD67C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AAD680: 48000AB1  bl 0x82aae130
	ctx.lr = 0x82AAD684;
	sub_82AAE130(ctx, base);
	// 82AAD684: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD688: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82AAD68C: 4802D775  bl 0x82adae00
	ctx.lr = 0x82AAD690;
	sub_82ADAE00(ctx, base);
	// 82AAD690: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD698: 4BFFFDF1  bl 0x82aad488
	ctx.lr = 0x82AAD69C;
	sub_82AAD488(ctx, base);
	// 82AAD69C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAD6A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD6A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD6A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAD6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD6B8 size=428
    let mut pc: u32 = 0x82AAD6B8;
    'dispatch: loop {
        match pc {
            0x82AAD6B8 => {
    //   block [0x82AAD6B8..0x82AAD864)
	// 82AAD6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD6BC: 486FAAAD  bl 0x831a8168
	ctx.lr = 0x82AAD6C0;
	sub_831A8130(ctx, base);
	// 82AAD6C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD6C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAD6C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AAD6CC: 3BCB7310  addi r30, r11, 0x7310
	ctx.r[30].s64 = ctx.r[11].s64 + 29456;
	// 82AAD6D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAD6D4: 38A000AC  li r5, 0xac
	ctx.r[5].s64 = 172;
	// 82AAD6D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD6DC: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 82AAD6E0: 48344D09  bl 0x82df23e8
	ctx.lr = 0x82AAD6E4;
	sub_82DF23E8(ctx, base);
	// 82AAD6E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAD6E8: 41820014  beq 0x82aad6fc
	if ctx.cr[0].eq {
	pc = 0x82AAD6FC; continue 'dispatch;
	}
	// 82AAD6EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AAD6F0: 4BFFF421  bl 0x82aacb10
	ctx.lr = 0x82AAD6F4;
	sub_82AACB10(ctx, base);
	// 82AAD6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD6F8: 48000008  b 0x82aad700
	pc = 0x82AAD700; continue 'dispatch;
	// 82AAD6FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAD700: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AAD704: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD708: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD70C: 4BFFE2BD  bl 0x82aab9c8
	ctx.lr = 0x82AAD710;
	sub_82AAB9C8(ctx, base);
	// 82AAD710: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAD714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD718: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAD71C: 4B8128E5  bl 0x822c0000
	ctx.lr = 0x82AAD720;
	sub_822C0000(ctx, base);
	// 82AAD720: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAD724: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82AAD728: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82AAD72C: 409A0008  bne cr6, 0x82aad734
	if !ctx.cr[6].eq {
	pc = 0x82AAD734; continue 'dispatch;
	}
	// 82AAD730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AAD734: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AAD738: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AAD73C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAD740: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82AAD744: 419A0024  beq cr6, 0x82aad768
	if ctx.cr[6].eq {
	pc = 0x82AAD768; continue 'dispatch;
	}
	// 82AAD748: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AAD74C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82AAD750: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD754: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82AAD758: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AAD75C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD760: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD764: 4082FFE8  bne 0x82aad74c
	if !ctx.cr[0].eq {
	pc = 0x82AAD74C; continue 'dispatch;
	}
	// 82AAD768: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AAD76C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAD770: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82AAD774: 419A0024  beq cr6, 0x82aad798
	if ctx.cr[6].eq {
	pc = 0x82AAD798; continue 'dispatch;
	}
	// 82AAD778: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82AAD77C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AAD780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD784: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AAD788: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AAD78C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AAD790: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AAD794: 4082FFE8  bne 0x82aad77c
	if !ctx.cr[0].eq {
	pc = 0x82AAD77C; continue 'dispatch;
	}
	// 82AAD798: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAD79C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82AAD7A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AAD7A4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82AAD7A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AAD7AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AAD7B0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD7B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAD7B8: 4BCEB779  bl 0x82798f30
	ctx.lr = 0x82AAD7BC;
	sub_82798F30(ctx, base);
	// 82AAD7BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82AAD7C0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AAD7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AAD7C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AAD7CC: 38A000B2  li r5, 0xb2
	ctx.r[5].s64 = 178;
	// 82AAD7D0: C00B9A8C  lfs f0, -0x6574(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAD7D4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AAD7D8: C1AAC350  lfs f13, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAD7DC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82AAD7E0: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82AAD7E4: 4B812BF5  bl 0x822c03d8
	ctx.lr = 0x82AAD7E8;
	sub_822C03D8(ctx, base);
	// 82AAD7E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAD7EC: 41820014  beq 0x82aad800
	if ctx.cr[0].eq {
	pc = 0x82AAD800; continue 'dispatch;
	}
	// 82AAD7F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AAD7F4: 4BCEDE75  bl 0x8279b668
	ctx.lr = 0x82AAD7F8;
	sub_8279B668(ctx, base);
	// 82AAD7F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD7FC: 48000008  b 0x82aad804
	pc = 0x82AAD804; continue 'dispatch;
	// 82AAD800: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAD804: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AAD808: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82AAD80C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAD814: 4BAEA43D  bl 0x82597c50
	ctx.lr = 0x82AAD818;
	sub_82597C50(ctx, base);
	// 82AAD818: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AAD81C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AAD820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AAD824: 4B8127DD  bl 0x822c0000
	ctx.lr = 0x82AAD828;
	sub_822C0000(ctx, base);
	// 82AAD828: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AAD82C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD830: 419A0008  beq cr6, 0x82aad838
	if ctx.cr[6].eq {
	pc = 0x82AAD838; continue 'dispatch;
	}
	// 82AAD834: 4B81305D  bl 0x822c0890
	ctx.lr = 0x82AAD838;
	sub_822C0890(ctx, base);
	// 82AAD838: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AAD83C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD840: 419A0008  beq cr6, 0x82aad848
	if ctx.cr[6].eq {
	pc = 0x82AAD848; continue 'dispatch;
	}
	// 82AAD844: 4B81304D  bl 0x822c0890
	ctx.lr = 0x82AAD848;
	sub_822C0890(ctx, base);
	// 82AAD848: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAD84C: 419A000C  beq cr6, 0x82aad858
	if ctx.cr[6].eq {
	pc = 0x82AAD858; continue 'dispatch;
	}
	// 82AAD850: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAD854: 4B81303D  bl 0x822c0890
	ctx.lr = 0x82AAD858;
	sub_822C0890(ctx, base);
	// 82AAD858: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AAD85C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82AAD860: 486FA958  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD868 size=120
    let mut pc: u32 = 0x82AAD868;
    'dispatch: loop {
        match pc {
            0x82AAD868 => {
    //   block [0x82AAD868..0x82AAD8E0)
	// 82AAD868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD87C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD880: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAD884: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAD888: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAD88C: 48350F55  bl 0x82dfe7e0
	ctx.lr = 0x82AAD890;
	sub_82DFE7E0(ctx, base);
	// 82AAD890: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD894: 41820028  beq 0x82aad8bc
	if ctx.cr[0].eq {
	pc = 0x82AAD8BC; continue 'dispatch;
	}
	// 82AAD898: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD8A0: 419A001C  beq cr6, 0x82aad8bc
	if ctx.cr[6].eq {
	pc = 0x82AAD8BC; continue 'dispatch;
	}
	// 82AAD8A4: 48106F75  bl 0x82bb4818
	ctx.lr = 0x82AAD8A8;
	sub_82BB4818(ctx, base);
	// 82AAD8A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD8AC: 41820010  beq 0x82aad8bc
	if ctx.cr[0].eq {
	pc = 0x82AAD8BC; continue 'dispatch;
	}
	// 82AAD8B0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAD8B4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AAD8B8: 48107C39  bl 0x82bb54f0
	ctx.lr = 0x82AAD8BC;
	sub_82BB54F0(ctx, base);
	// 82AAD8BC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AAD8C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AAD8C4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82AAD8C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAD8CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD8D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD8D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAD8D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD8E0 size=132
    let mut pc: u32 = 0x82AAD8E0;
    'dispatch: loop {
        match pc {
            0x82AAD8E0 => {
    //   block [0x82AAD8E0..0x82AAD964)
	// 82AAD8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD8E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD8EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD8F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD8F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAD8F8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82AAD8FC: 396B7508  addi r11, r11, 0x7508
	ctx.r[11].s64 = ctx.r[11].s64 + 29960;
	// 82AAD900: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AAD904: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAD908: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82AAD90C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AAD910: 808A7058  lwz r4, 0x7058(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82AAD914: 4BA628DD  bl 0x825101f0
	ctx.lr = 0x82AAD918;
	sub_825101F0(ctx, base);
	// 82AAD918: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82AAD91C: 48345B0D  bl 0x82df3428
	ctx.lr = 0x82AAD920;
	sub_82DF3428(ctx, base);
	// 82AAD920: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AAD924: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD928: 419A0008  beq cr6, 0x82aad930
	if ctx.cr[6].eq {
	pc = 0x82AAD930; continue 'dispatch;
	}
	// 82AAD92C: 4B812F65  bl 0x822c0890
	ctx.lr = 0x82AAD930;
	sub_822C0890(ctx, base);
	// 82AAD930: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AAD934: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD938: 419A0008  beq cr6, 0x82aad940
	if ctx.cr[6].eq {
	pc = 0x82AAD940; continue 'dispatch;
	}
	// 82AAD93C: 4B812F55  bl 0x822c0890
	ctx.lr = 0x82AAD940;
	sub_822C0890(ctx, base);
	// 82AAD940: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAD944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAD948: 419A0008  beq cr6, 0x82aad950
	if ctx.cr[6].eq {
	pc = 0x82AAD950; continue 'dispatch;
	}
	// 82AAD94C: 4B812F45  bl 0x822c0890
	ctx.lr = 0x82AAD950;
	sub_822C0890(ctx, base);
	// 82AAD950: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAD954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD95C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAD968 size=76
    let mut pc: u32 = 0x82AAD968;
    'dispatch: loop {
        match pc {
            0x82AAD968 => {
    //   block [0x82AAD968..0x82AAD9B4)
	// 82AAD968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD96C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD97C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD980: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAD984: 4BFFFF5D  bl 0x82aad8e0
	ctx.lr = 0x82AAD988;
	sub_82AAD8E0(ctx, base);
	// 82AAD988: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAD98C: 4182000C  beq 0x82aad998
	if ctx.cr[0].eq {
	pc = 0x82AAD998; continue 'dispatch;
	}
	// 82AAD990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD994: 4B8128D5  bl 0x822c0268
	ctx.lr = 0x82AAD998;
	sub_822C0268(ctx, base);
	// 82AAD998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAD99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AAD9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAD9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAD9A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAD9AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAD9B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAD9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAD9B8 size=172
    let mut pc: u32 = 0x82AAD9B8;
    'dispatch: loop {
        match pc {
            0x82AAD9B8 => {
    //   block [0x82AAD9B8..0x82AADA64)
	// 82AAD9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAD9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAD9C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAD9C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAD9C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAD9CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAD9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAD9D4: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AAD9D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAD9DC: 41820070  beq 0x82aada4c
	if ctx.cr[0].eq {
	pc = 0x82AADA4C; continue 'dispatch;
	}
	// 82AAD9E0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AAD9E4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82AAD9E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82AAD9EC: 419A0060  beq cr6, 0x82aada4c
	if ctx.cr[6].eq {
	pc = 0x82AADA4C; continue 'dispatch;
	}
	// 82AAD9F0: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82AAD9F4: 483461DD  bl 0x82df3bd0
	ctx.lr = 0x82AAD9F8;
	sub_82DF3BD0(ctx, base);
	// 82AAD9F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AAD9FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADA00: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AADA04: 4810590D  bl 0x82bb3310
	ctx.lr = 0x82AADA08;
	sub_82BB3310(ctx, base);
	// 82AADA08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AADA0C: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82AADA10: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AADA14: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82AADA18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADA1C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AADA20: 4B816A41  bl 0x822c4460
	ctx.lr = 0x82AADA24;
	sub_822C4460(ctx, base);
	// 82AADA24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AADA28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AADA2C: 419A0008  beq cr6, 0x82aada34
	if ctx.cr[6].eq {
	pc = 0x82AADA34; continue 'dispatch;
	}
	// 82AADA30: 4B812E61  bl 0x822c0890
	ctx.lr = 0x82AADA34;
	sub_822C0890(ctx, base);
	// 82AADA34: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82AADA38: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AADA3C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADA40: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82AADA44: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AADA48: 4810B029  bl 0x82bb8a70
	ctx.lr = 0x82AADA4C;
	sub_82BB8A70(ctx, base);
	// 82AADA4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AADA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADA58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AADA5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADA60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADA68 size=96
    let mut pc: u32 = 0x82AADA68;
    'dispatch: loop {
        match pc {
            0x82AADA68 => {
    //   block [0x82AADA68..0x82AADAC8)
	// 82AADA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AADA70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AADA74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AADA7C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82AADA80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AADA84: 41820030  beq 0x82aadab4
	if ctx.cr[0].eq {
	pc = 0x82AADAB4; continue 'dispatch;
	}
	// 82AADA88: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AADA8C: 1D440030  mulli r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 * 48;
	// 82AADA90: 396BD370  addi r11, r11, -0x2c90
	ctx.r[11].s64 = ctx.r[11].s64 + -11408;
	// 82AADA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADA98: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AADA9C: 48345F6D  bl 0x82df3a08
	ctx.lr = 0x82AADAA0;
	sub_82DF3A08(ctx, base);
	// 82AADAA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AADAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADAA8: 4BFFFF11  bl 0x82aad9b8
	ctx.lr = 0x82AADAAC;
	sub_82AAD9B8(ctx, base);
	// 82AADAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADAB0: 48345979  bl 0x82df3428
	ctx.lr = 0x82AADAB4;
	sub_82DF3428(ctx, base);
	// 82AADAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AADAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADAC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADAC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AADAC8 size=300
    let mut pc: u32 = 0x82AADAC8;
    'dispatch: loop {
        match pc {
            0x82AADAC8 => {
    //   block [0x82AADAC8..0x82AADBF4)
	// 82AADAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADACC: 486FA6A1  bl 0x831a816c
	ctx.lr = 0x82AADAD0;
	sub_831A8130(ctx, base);
	// 82AADAD0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AADAD8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AADAE0: 4837D009  bl 0x82e2aae8
	ctx.lr = 0x82AADAE4;
	sub_82E2AAE8(ctx, base);
	// 82AADAE4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AADAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADAEC: 808BD364  lwz r4, -0x2c9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11420 as u32) ) } as u64;
	// 82AADAF0: 48345F19  bl 0x82df3a08
	ctx.lr = 0x82AADAF4;
	sub_82DF3A08(ctx, base);
	// 82AADAF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AADAF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AADAFC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AADB00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AADB04: 4838136D  bl 0x82e2ee70
	ctx.lr = 0x82AADB08;
	sub_82E2EE70(ctx, base);
	// 82AADB08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADB0C: 4834591D  bl 0x82df3428
	ctx.lr = 0x82AADB10;
	sub_82DF3428(ctx, base);
	// 82AADB10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AADB14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AADB18: 388B7510  addi r4, r11, 0x7510
	ctx.r[4].s64 = ctx.r[11].s64 + 29968;
	// 82AADB1C: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 82AADB20: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82AADB24: 483448C5  bl 0x82df23e8
	ctx.lr = 0x82AADB28;
	sub_82DF23E8(ctx, base);
	// 82AADB28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AADB2C: 41820014  beq 0x82aadb40
	if ctx.cr[0].eq {
	pc = 0x82AADB40; continue 'dispatch;
	}
	// 82AADB30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AADB34: 48368D5D  bl 0x82e16890
	ctx.lr = 0x82AADB38;
	sub_82E16890(ctx, base);
	// 82AADB38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AADB3C: 48000008  b 0x82aadb44
	pc = 0x82AADB44; continue 'dispatch;
	// 82AADB40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AADB44: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82AADB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AADB4C: 4B8AF825  bl 0x8235d370
	ctx.lr = 0x82AADB50;
	sub_8235D370(ctx, base);
	// 82AADB50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AADB54: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AADB58: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADB5C: 4802550D  bl 0x82ad3068
	ctx.lr = 0x82AADB60;
	sub_82AD3068(ctx, base);
	// 82AADB60: 815D0084  lwz r10, 0x84(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AADB64: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AADB68: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82AADB6C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82AADB70: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82AADB74: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82AADB78: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AADB7C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82AADB80: 13C73407  vcmpneb. (lvlx128) v30, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AADB84: 13A83407  vcmpneb. (lvlx128) v29, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AADB88: 13893407  vcmpneb. (lvlx128) v28, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADBF8 size=276
    let mut pc: u32 = 0x82AADBF8;
    'dispatch: loop {
        match pc {
            0x82AADBF8 => {
    //   block [0x82AADBF8..0x82AADD0C)
	// 82AADBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADBFC: 486FA56D  bl 0x831a8168
	ctx.lr = 0x82AADC00;
	sub_831A8130(ctx, base);
	// 82AADC00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADC04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AADC08: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AADC0C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82AADC10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AADC14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AADC18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AADC1C: 388B7510  addi r4, r11, 0x7510
	ctx.r[4].s64 = ctx.r[11].s64 + 29968;
	// 82AADC20: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 82AADC24: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82AADC28: 483447C1  bl 0x82df23e8
	ctx.lr = 0x82AADC2C;
	sub_82DF23E8(ctx, base);
	// 82AADC2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AADC30: 41820030  beq 0x82aadc60
	if ctx.cr[0].eq {
	pc = 0x82AADC60; continue 'dispatch;
	}
	// 82AADC34: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AADC38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADC3C: 808BD368  lwz r4, -0x2c98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11416 as u32) ) } as u64;
	// 82AADC40: 48345DC9  bl 0x82df3a08
	ctx.lr = 0x82AADC44;
	sub_82DF3A08(ctx, base);
	// 82AADC44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AADC48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AADC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADC50: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AADC54: 48105FAD  bl 0x82bb3c00
	ctx.lr = 0x82AADC58;
	sub_82BB3C00(ctx, base);
	// 82AADC58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AADC5C: 48000008  b 0x82aadc64
	pc = 0x82AADC64; continue 'dispatch;
	// 82AADC60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AADC64: 3BFC000C  addi r31, r28, 0xc
	ctx.r[31].s64 = ctx.r[28].s64 + 12;
	// 82AADC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADC6C: 4B8AF775  bl 0x8235d3e0
	ctx.lr = 0x82AADC70;
	sub_8235D3E0(ctx, base);
	// 82AADC70: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AADC74: 4182000C  beq 0x82aadc80
	if ctx.cr[0].eq {
	pc = 0x82AADC80; continue 'dispatch;
	}
	// 82AADC78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AADC7C: 483457AD  bl 0x82df3428
	ctx.lr = 0x82AADC80;
	sub_82DF3428(ctx, base);
	// 82AADC80: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADC84: 807C0020  lwz r3, 0x20(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AADC88: 4BFFD849  bl 0x82aab4d0
	ctx.lr = 0x82AADC8C;
	sub_82AAB4D0(ctx, base);
	// 82AADC8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AADC90: 480FFCA9  bl 0x82bad938
	ctx.lr = 0x82AADC94;
	sub_82BAD938(ctx, base);
	// 82AADC94: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AADC98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AADC9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADCA0: 388BD370  addi r4, r11, -0x2c90
	ctx.r[4].s64 = ctx.r[11].s64 + -11408;
	// 82AADCA4: 481072BD  bl 0x82bb4f60
	ctx.lr = 0x82AADCA8;
	sub_82BB4F60(ctx, base);
	// 82AADCA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADCAC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADCB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AADCB4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AADCB8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AADCBC: 419A0024  beq cr6, 0x82aadce0
	if ctx.cr[6].eq {
	pc = 0x82AADCE0; continue 'dispatch;
	}
	// 82AADCC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AADCC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AADCC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AADCCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AADCD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AADCD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AADCD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AADCDC: 4082FFE8  bne 0x82aadcc4
	if !ctx.cr[0].eq {
	pc = 0x82AADCC4; continue 'dispatch;
	}
	// 82AADCE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AADCE4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADCE8: 48367289  bl 0x82e14f70
	ctx.lr = 0x82AADCEC;
	sub_82E14F70(ctx, base);
	// 82AADCEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AADCF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AADCF4: 419A0008  beq cr6, 0x82aadcfc
	if ctx.cr[6].eq {
	pc = 0x82AADCFC; continue 'dispatch;
	}
	// 82AADCF8: 4B812B99  bl 0x822c0890
	ctx.lr = 0x82AADCFC;
	sub_822C0890(ctx, base);
	// 82AADCFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AADD00: 997C002C  stb r11, 0x2c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 82AADD04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AADD08: 486FA4B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADD10 size=132
    let mut pc: u32 = 0x82AADD10;
    'dispatch: loop {
        match pc {
            0x82AADD10 => {
    //   block [0x82AADD10..0x82AADD94)
	// 82AADD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADD14: 486FA451  bl 0x831a8164
	ctx.lr = 0x82AADD18;
	sub_831A8130(ctx, base);
	// 82AADD18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADD1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AADD20: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AADD24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AADD28: 396B7508  addi r11, r11, 0x7508
	ctx.r[11].s64 = ctx.r[11].s64 + 29960;
	// 82AADD2C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82AADD30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADD34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AADD38: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AADD3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82AADD40: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82AADD44: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82AADD48: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82AADD4C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82AADD50: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82AADD54: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82AADD58: 48345399  bl 0x82df30f0
	ctx.lr = 0x82AADD5C;
	sub_82DF30F0(ctx, base);
	// 82AADD5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82AADD60: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82AADD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADD68: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82AADD6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AADD70: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82AADD74: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82AADD78: 4BFFFD51  bl 0x82aadac8
	ctx.lr = 0x82AADD7C;
	sub_82AADAC8(ctx, base);
	// 82AADD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADD80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AADD84: 4BFFFE75  bl 0x82aadbf8
	ctx.lr = 0x82AADD88;
	sub_82AADBF8(ctx, base);
	// 82AADD88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADD8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AADD90: 486FA424  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AADD98 size=28
    let mut pc: u32 = 0x82AADD98;
    'dispatch: loop {
        match pc {
            0x82AADD98 => {
    //   block [0x82AADD98..0x82AADDB4)
	// 82AADD98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AADD9C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82AADDA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AADDA4: 396B7568  addi r11, r11, 0x7568
	ctx.r[11].s64 = ctx.r[11].s64 + 30056;
	// 82AADDA8: 9943001C  stb r10, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82AADDAC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADDB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADDB8 size=68
    let mut pc: u32 = 0x82AADDB8;
    'dispatch: loop {
        match pc {
            0x82AADDB8 => {
    //   block [0x82AADDB8..0x82AADDFC)
	// 82AADDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AADDC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AADDC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADDC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AADDCC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AADDD0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AADDD4: 396B7568  addi r11, r11, 0x7568
	ctx.r[11].s64 = ctx.r[11].s64 + 30056;
	// 82AADDD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADDDC: 41820008  beq 0x82aadde4
	if ctx.cr[0].eq {
	pc = 0x82AADDE4; continue 'dispatch;
	}
	// 82AADDE0: 4B812489  bl 0x822c0268
	ctx.lr = 0x82AADDE4;
	sub_822C0268(ctx, base);
	// 82AADDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AADDE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AADDEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AADDF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AADDF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AADDF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AADE00 size=64
    let mut pc: u32 = 0x82AADE00;
    'dispatch: loop {
        match pc {
            0x82AADE00 => {
    //   block [0x82AADE00..0x82AADE40)
	// 82AADE00: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AADE04: 81040018  lwz r8, 0x18(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AADE08: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82AADE0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AADE10: 396BE4D0  addi r11, r11, -0x1b30
	ctx.r[11].s64 = ctx.r[11].s64 + -6960;
	// 82AADE14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AADE18: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADE1C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82AADE20: 419A0020  beq cr6, 0x82aade40
	if ctx.cr[6].eq {
		sub_82AADE40(ctx, base);
		return;
	}
	// 82AADE24: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82AADE28: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82AADE2C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82AADE30: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 82AADE34: 4198FFE4  blt cr6, 0x82aade18
	if ctx.cr[6].lt {
	pc = 0x82AADE18; continue 'dispatch;
	}
	// 82AADE38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AADE3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AADE40 size=24
    let mut pc: u32 = 0x82AADE40;
    'dispatch: loop {
        match pc {
            0x82AADE40 => {
    //   block [0x82AADE40..0x82AADE58)
	// 82AADE40: 39690002  addi r11, r9, 2
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	// 82AADE44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AADE48: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AADE4C: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82AADE50: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AADE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AADE58 size=12
    let mut pc: u32 = 0x82AADE58;
    'dispatch: loop {
        match pc {
            0x82AADE58 => {
    //   block [0x82AADE58..0x82AADE64)
	// 82AADE58: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AADE5C: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADE60: 4BFBB4E0  b 0x82a69340
	sub_82A69340(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADE68 size=68
    let mut pc: u32 = 0x82AADE68;
    'dispatch: loop {
        match pc {
            0x82AADE68 => {
    //   block [0x82AADE68..0x82AADEAC)
	// 82AADE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADE6C: 486FA301  bl 0x831a816c
	ctx.lr = 0x82AADE70;
	sub_831A8130(ctx, base);
	// 82AADE70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADE74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AADE78: 897D001C  lbz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AADE7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AADE80: 41820024  beq 0x82aadea4
	if ctx.cr[0].eq {
	pc = 0x82AADEA4; continue 'dispatch;
	}
	// 82AADE84: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 82AADE88: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 82AADE8C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADE90: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADE94: 4BFFD64D  bl 0x82aab4e0
	ctx.lr = 0x82AADE98;
	sub_82AAB4E0(ctx, base);
	// 82AADE98: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AADE9C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AADEA0: 4082FFEC  bne 0x82aade8c
	if !ctx.cr[0].eq {
	pc = 0x82AADE8C; continue 'dispatch;
	}
	// 82AADEA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AADEA8: 486FA314  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AADEB0 size=68
    let mut pc: u32 = 0x82AADEB0;
    'dispatch: loop {
        match pc {
            0x82AADEB0 => {
    //   block [0x82AADEB0..0x82AADEF4)
	// 82AADEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADEB4: 486FA2B9  bl 0x831a816c
	ctx.lr = 0x82AADEB8;
	sub_831A8130(ctx, base);
	// 82AADEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADEBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AADEC0: 897D001C  lbz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AADEC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AADEC8: 41820024  beq 0x82aadeec
	if ctx.cr[0].eq {
	pc = 0x82AADEEC; continue 'dispatch;
	}
	// 82AADECC: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 82AADED0: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 82AADED4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADED8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADEDC: 4BFBB465  bl 0x82a69340
	ctx.lr = 0x82AADEE0;
	sub_82A69340(ctx, base);
	// 82AADEE0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AADEE4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82AADEE8: 4082FFEC  bne 0x82aaded4
	if !ctx.cr[0].eq {
	pc = 0x82AADED4; continue 'dispatch;
	}
	// 82AADEEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AADEF0: 486FA2CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AADEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AADEF8 size=564
    let mut pc: u32 = 0x82AADEF8;
    'dispatch: loop {
        match pc {
            0x82AADEF8 => {
    //   block [0x82AADEF8..0x82AAE12C)
	// 82AADEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AADEFC: 486FA251  bl 0x831a814c
	ctx.lr = 0x82AADF00;
	sub_831A8130(ctx, base);
	// 82AADF00: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82AADF04: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AADF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AADF0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADF10: 4BF65789  bl 0x82a13698
	ctx.lr = 0x82AADF14;
	sub_82A13698(ctx, base);
	// 82AADF14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADF18: 4BD3E2C1  bl 0x827ec1d8
	ctx.lr = 0x82AADF1C;
	sub_827EC1D8(ctx, base);
	// 82AADF1C: 4BD6455D  bl 0x82812478
	ctx.lr = 0x82AADF20;
	sub_82812478(ctx, base);
	// 82AADF20: 82C30004  lwz r22, 4(r3)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADF24: 82E30000  lwz r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADF28: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82AADF2C: 419A0024  beq cr6, 0x82aadf50
	if ctx.cr[6].eq {
	pc = 0x82AADF50; continue 'dispatch;
	}
	// 82AADF30: 39760004  addi r11, r22, 4
	ctx.r[11].s64 = ctx.r[22].s64 + 4;
	// 82AADF34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AADF38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AADF3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AADF40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AADF44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AADF48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AADF4C: 4082FFE8  bne 0x82aadf34
	if !ctx.cr[0].eq {
	pc = 0x82AADF34; continue 'dispatch;
	}
	// 82AADF50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADF54: 4BFFD57D  bl 0x82aab4d0
	ctx.lr = 0x82AADF58;
	sub_82AAB4D0(ctx, base);
	// 82AADF58: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AADF5C: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AADF60: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 82AADF64: 3BCBE4D0  addi r30, r11, -0x1b30
	ctx.r[30].s64 = ctx.r[11].s64 + -6960;
	// 82AADF68: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82AADF6C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82AADF70: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82AADF74: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AADF78: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AADF7C: 483F27B5  bl 0x82ea0730
	ctx.lr = 0x82AADF80;
	sub_82EA0730(ctx, base);
	// 82AADF80: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 82AADF84: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AADF88: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 82AADF8C: 4846C265  bl 0x82f1a1f0
	ctx.lr = 0x82AADF90;
	sub_82F1A1F0(ctx, base);
	// 82AADF90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AADF94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AADF98: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADF9C: 48345A6D  bl 0x82df3a08
	ctx.lr = 0x82AADFA0;
	sub_82DF3A08(ctx, base);
	// 82AADFA0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AADFA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AADFA8: 419A000C  beq cr6, 0x82aadfb4
	if ctx.cr[6].eq {
	pc = 0x82AADFB4; continue 'dispatch;
	}
	// 82AADFAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AADFB0: 4B83A299  bl 0x822e8248
	ctx.lr = 0x82AADFB4;
	sub_822E8248(ctx, base);
	// 82AADFB4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AADFB8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82AADFBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AADFC0: 48367071  bl 0x82e15030
	ctx.lr = 0x82AADFC4;
	sub_82E15030(ctx, base);
	// 82AADFC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AADFC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AADFCC: 48000ACD  bl 0x82aaea98
	ctx.lr = 0x82AADFD0;
	sub_82AAEA98(ctx, base);
	// 82AADFD0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AADFD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AADFD8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AADFDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AADFE0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82AADFE4: 4BFFE9CD  bl 0x82aac9b0
	ctx.lr = 0x82AADFE8;
	sub_82AAC9B0(ctx, base);
	// 82AADFE8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AADFEC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AADFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AADFF4: 419A000C  beq cr6, 0x82aae000
	if ctx.cr[6].eq {
	pc = 0x82AAE000; continue 'dispatch;
	}
	// 82AADFF8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AADFFC: 4B812895  bl 0x822c0890
	ctx.lr = 0x82AAE000;
	sub_822C0890(ctx, base);
	// 82AAE000: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AAE004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAE008: 419A0008  beq cr6, 0x82aae010
	if ctx.cr[6].eq {
	pc = 0x82AAE010; continue 'dispatch;
	}
	// 82AAE00C: 4B83A25D  bl 0x822e8268
	ctx.lr = 0x82AAE010;
	sub_822E8268(ctx, base);
	// 82AAE010: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAE014: 48345415  bl 0x82df3428
	ctx.lr = 0x82AAE018;
	sub_82DF3428(ctx, base);
	// 82AAE018: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE01C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE020: 4BFFD4C1  bl 0x82aab4e0
	ctx.lr = 0x82AAE024;
	sub_82AAB4E0(ctx, base);
	// 82AAE024: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAE028: 419A000C  beq cr6, 0x82aae034
	if ctx.cr[6].eq {
	pc = 0x82AAE034; continue 'dispatch;
	}
	// 82AAE02C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAE030: 4B83A239  bl 0x822e8268
	ctx.lr = 0x82AAE034;
	sub_822E8268(ctx, base);
	// 82AAE034: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 82AAE038: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 82AAE03C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82AAE040: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE044: 4BFFD48D  bl 0x82aab4d0
	ctx.lr = 0x82AAE048;
	sub_82AAB4D0(ctx, base);
	// 82AAE048: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE04C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82AAE050: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82AAE054: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82AAE058: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE05C: 483F26D5  bl 0x82ea0730
	ctx.lr = 0x82AAE060;
	sub_82EA0730(ctx, base);
	// 82AAE060: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 82AAE064: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AAE068: 4846C189  bl 0x82f1a1f0
	ctx.lr = 0x82AAE06C;
	sub_82F1A1F0(ctx, base);
	// 82AAE06C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AAE070: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAE074: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE078: 48345991  bl 0x82df3a08
	ctx.lr = 0x82AAE07C;
	sub_82DF3A08(ctx, base);
	// 82AAE07C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82AAE080: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAE084: 419A000C  beq cr6, 0x82aae090
	if ctx.cr[6].eq {
	pc = 0x82AAE090; continue 'dispatch;
	}
	// 82AAE088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAE08C: 4B83A1BD  bl 0x822e8248
	ctx.lr = 0x82AAE090;
	sub_822E8248(ctx, base);
	// 82AAE090: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82AAE094: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82AAE098: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAE09C: 48366F95  bl 0x82e15030
	ctx.lr = 0x82AAE0A0;
	sub_82E15030(ctx, base);
	// 82AAE0A0: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82AAE0A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAE0A8: 480009F1  bl 0x82aaea98
	ctx.lr = 0x82AAE0AC;
	sub_82AAEA98(ctx, base);
	// 82AAE0AC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAE0B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AAE0B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE0B8: 389EFFFC  addi r4, r30, -4
	ctx.r[4].s64 = ctx.r[30].s64 + -4;
	// 82AAE0BC: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82AAE0C0: 4BFFE8F1  bl 0x82aac9b0
	ctx.lr = 0x82AAE0C4;
	sub_82AAC9B0(ctx, base);
	// 82AAE0C4: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82AAE0C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AAE0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAE0D0: 419A0008  beq cr6, 0x82aae0d8
	if ctx.cr[6].eq {
	pc = 0x82AAE0D8; continue 'dispatch;
	}
	// 82AAE0D4: 4B8127BD  bl 0x822c0890
	ctx.lr = 0x82AAE0D8;
	sub_822C0890(ctx, base);
	// 82AAE0D8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AAE0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AAE0E0: 419A0008  beq cr6, 0x82aae0e8
	if ctx.cr[6].eq {
	pc = 0x82AAE0E8; continue 'dispatch;
	}
	// 82AAE0E4: 4B83A185  bl 0x822e8268
	ctx.lr = 0x82AAE0E8;
	sub_822E8268(ctx, base);
	// 82AAE0E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AAE0EC: 4834533D  bl 0x82df3428
	ctx.lr = 0x82AAE0F0;
	sub_82DF3428(ctx, base);
	// 82AAE0F0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82AAE0F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AAE0F8: 419A000C  beq cr6, 0x82aae104
	if ctx.cr[6].eq {
	pc = 0x82AAE104; continue 'dispatch;
	}
	// 82AAE0FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AAE100: 4B83A169  bl 0x822e8268
	ctx.lr = 0x82AAE104;
	sub_822E8268(ctx, base);
	// 82AAE104: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82AAE108: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82AAE10C: 4082FF34  bne 0x82aae040
	if !ctx.cr[0].eq {
	pc = 0x82AAE040; continue 'dispatch;
	}
	// 82AAE110: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82AAE114: 419A000C  beq cr6, 0x82aae120
	if ctx.cr[6].eq {
	pc = 0x82AAE120; continue 'dispatch;
	}
	// 82AAE118: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82AAE11C: 4B812775  bl 0x822c0890
	ctx.lr = 0x82AAE120;
	sub_822C0890(ctx, base);
	// 82AAE120: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82AAE124: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82AAE128: 486FA074  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AAE130 size=120
    let mut pc: u32 = 0x82AAE130;
    'dispatch: loop {
        match pc {
            0x82AAE130 => {
    //   block [0x82AAE130..0x82AAE1A8)
	// 82AAE130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE13C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAE144: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82AAE148: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AAE14C: 40820048  bne 0x82aae194
	if !ctx.cr[0].eq {
	pc = 0x82AAE194; continue 'dispatch;
	}
	// 82AAE150: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE154: 4BD3E085  bl 0x827ec1d8
	ctx.lr = 0x82AAE158;
	sub_827EC1D8(ctx, base);
	// 82AAE158: 4BD3C021  bl 0x827ea178
	ctx.lr = 0x82AAE15C;
	sub_827EA178(ctx, base);
	// 82AAE15C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AAE164: 419A0030  beq cr6, 0x82aae194
	if ctx.cr[6].eq {
	pc = 0x82AAE194; continue 'dispatch;
	}
	// 82AAE168: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE16C: 4BD3E06D  bl 0x827ec1d8
	ctx.lr = 0x82AAE170;
	sub_827EC1D8(ctx, base);
	// 82AAE170: 4BD3C009  bl 0x827ea178
	ctx.lr = 0x82AAE174;
	sub_827EA178(ctx, base);
	// 82AAE174: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE178: 481066A1  bl 0x82bb4818
	ctx.lr = 0x82AAE17C;
	sub_82BB4818(ctx, base);
	// 82AAE17C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE180: 41820014  beq 0x82aae194
	if ctx.cr[0].eq {
	pc = 0x82AAE194; continue 'dispatch;
	}
	// 82AAE184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AAE188: 4BFFFD71  bl 0x82aadef8
	ctx.lr = 0x82AAE18C;
	sub_82AADEF8(ctx, base);
	// 82AAE18C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAE190: 997F001C  stb r11, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82AAE194: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAE198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAE19C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAE1A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE1A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE1A8 size=216
    let mut pc: u32 = 0x82AAE1A8;
    'dispatch: loop {
        match pc {
            0x82AAE1A8 => {
    //   block [0x82AAE1A8..0x82AAE280)
	// 82AAE1A8: 54AB043E  clrlwi r11, r5, 0x10
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 82AAE1AC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82AAE1B0: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82AAE1B4: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE1B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82AAE1BC: 396975DC  addi r11, r9, 0x75dc
	ctx.r[11].s64 = ctx.r[9].s64 + 30172;
	// 82AAE1C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82AAE1C4: 7CAA6E70  srawi r10, r5, 0xd
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 13) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[5].s32 >> 13) as i64;
	// 82AAE1C8: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82AAE1CC: 554816F8  rlwinm r8, r10, 2, 0x1b, 0x1c
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82AAE1D0: 3CE0832F  lis r7, -0x7cd1
	ctx.r[7].s64 = -2094071808;
	// 82AAE1D4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82AAE1D8: 394A75BC  addi r10, r10, 0x75bc
	ctx.r[10].s64 = ctx.r[10].s64 + 30140;
	// 82AAE1DC: 7D884C2E  lfsx f12, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE1E0: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE1E4: 8167D414  lwz r11, -0x2bec(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11244 as u32) ) } as u64;
	// 82AAE1E8: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 82AAE1EC: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE1F0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE1F4: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE1F8: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AAE1FC: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AAE200: ED0D0372  fmuls f8, f13, f13
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE204: ECE80372  fmuls f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE208: ECC80232  fmuls f6, f8, f8
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[8].f64) as f32) as f64);
	// 82AAE20C: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82AAE210: ECA601F2  fmuls f5, f6, f7
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[7].f64) as f32) as f64);
	// 82AAE214: ECC801B2  fmuls f6, f8, f6
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[6].f64) as f32) as f64);
	// 82AAE218: ED850332  fmuls f12, f5, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[12].f64) as f32) as f64);
	// 82AAE21C: ED8662FA  fmadds f12, f6, f11, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE220: ED8A623A  fmadds f12, f10, f8, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE224: ED8961FA  fmadds f12, f9, f7, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[7].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE228: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AAE22C: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE230: 7DA8542E  lfsx f13, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE234: 7D884C2E  lfsx f12, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE238: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE23C: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE240: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE244: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE248: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AAE24C: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AAE250: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE254: ECED0372  fmuls f7, f13, f13
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE258: EDA80372  fmuls f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE25C: ECC70232  fmuls f6, f7, f8
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82AAE260: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82AAE264: ED260272  fmuls f9, f6, f9
	ctx.f[9].f64 = (((ctx.f[6].f64 * ctx.f[9].f64) as f32) as f64);
	// 82AAE268: ED874B3A  fmadds f12, f7, f12, f9
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82AAE26C: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE270: EDAA6A3A  fmadds f13, f10, f8, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82AAE274: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AAE278: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE280 size=192
    let mut pc: u32 = 0x82AAE280;
    'dispatch: loop {
        match pc {
            0x82AAE280 => {
    //   block [0x82AAE280..0x82AAE340)
	// 82AAE280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE28C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAE294: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAE298: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AAE29C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAE2A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE2A4: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE2A8: 4BFFFF01  bl 0x82aae1a8
	ctx.lr = 0x82AAE2AC;
	sub_82AAE1A8(ctx, base);
	// 82AAE2AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE2B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AAE2B4: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE2B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE2BC: 4BFFFEED  bl 0x82aae1a8
	ctx.lr = 0x82AAE2C0;
	sub_82AAE1A8(ctx, base);
	// 82AAE2C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE2C4: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AAE2C8: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE2CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAE2D0: 4BFFFED9  bl 0x82aae1a8
	ctx.lr = 0x82AAE2D4;
	sub_82AAE1A8(ctx, base);
	// 82AAE2D4: C1610050  lfs f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE2D8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE2DC: ED0C02F2  fmuls f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82AAE2E0: C1410054  lfs f10, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AAE2E4: C121005C  lfs f9, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AAE2E8: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82AAE2EC: ED6902F2  fmuls f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82AAE2F0: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE2F4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE2F8: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82AAE2FC: ED280032  fmuls f9, f8, f0
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE300: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE304: ECEC0032  fmuls f7, f12, f0
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE308: ECCB0032  fmuls f6, f11, f0
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE30C: ED2A4B7A  fmadds f9, f10, f13, f9
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82AAE310: D126000C  stfs f9, 0xc(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AAE314: EC0A4038  fmsubs f0, f10, f0, f8
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82AAE318: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE31C: EC0B3B7A  fmadds f0, f11, f13, f7
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82AAE320: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE324: EC0C3378  fmsubs f0, f12, f13, f6
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[6].f64) as f32) as f64);
	// 82AAE328: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAE32C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAE330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAE334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAE338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE340 size=192
    let mut pc: u32 = 0x82AAE340;
    'dispatch: loop {
        match pc {
            0x82AAE340 => {
    //   block [0x82AAE340..0x82AAE400)
	// 82AAE340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE34C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAE354: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AAE358: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82AAE35C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAE360: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE364: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE368: 4BFFFE41  bl 0x82aae1a8
	ctx.lr = 0x82AAE36C;
	sub_82AAE1A8(ctx, base);
	// 82AAE36C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AAE370: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82AAE374: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE37C: 4BFFFE2D  bl 0x82aae1a8
	ctx.lr = 0x82AAE380;
	sub_82AAE1A8(ctx, base);
	// 82AAE380: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AAE384: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82AAE388: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82AAE38C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAE390: 4BFFFE19  bl 0x82aae1a8
	ctx.lr = 0x82AAE394;
	sub_82AAE1A8(ctx, base);
	// 82AAE394: C1610050  lfs f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE398: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE39C: ED0C02F2  fmuls f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82AAE3A0: C1210054  lfs f9, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AAE3A4: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82AAE3A8: ED8C0272  fmuls f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82AAE3AC: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82AAE3B0: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE3B4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE3B8: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82AAE3BC: ED280032  fmuls f9, f8, f0
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE3C0: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AAE3C4: ECEC0032  fmuls f7, f12, f0
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE3C8: ECCB0032  fmuls f6, f11, f0
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE3CC: ED2A4B7A  fmadds f9, f10, f13, f9
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82AAE3D0: D126000C  stfs f9, 0xc(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82AAE3D4: EC0A403A  fmadds f0, f10, f0, f8
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82AAE3D8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE3DC: EC0B3B78  fmsubs f0, f11, f13, f7
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[7].f64) as f32) as f64);
	// 82AAE3E0: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE3E4: EC0C3378  fmsubs f0, f12, f13, f6
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[6].f64) as f32) as f64);
	// 82AAE3E8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAE3EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAE3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAE3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAE3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE400 size=20
    let mut pc: u32 = 0x82AAE400;
    'dispatch: loop {
        match pc {
            0x82AAE400 => {
    //   block [0x82AAE400..0x82AAE414)
	// 82AAE400: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAE404: C00B760C  lfs f0, 0x760c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE408: EC020032  fmuls f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE40C: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82AAE410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE418 size=68
    let mut pc: u32 = 0x82AAE418;
    'dispatch: loop {
        match pc {
            0x82AAE418 => {
    //   block [0x82AAE418..0x82AAE45C)
	// 82AAE418: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAE41C: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE420: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE424: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82AAE428: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE42C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82AAE430: C00BF774  lfs f0, -0x88c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE434: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE438: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE43C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE440: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82AAE444: 7DA01FAE  stfiwx f13, 0, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32, tmp.u32) };
	// 82AAE448: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82AAE44C: 7DA357AE  stfiwx f13, r3, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82AAE450: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AAE454: 7C034FAE  stfiwx f0, r3, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82AAE458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE460 size=120
    let mut pc: u32 = 0x82AAE460;
    'dispatch: loop {
        match pc {
            0x82AAE460 => {
    //   block [0x82AAE460..0x82AAE4D8)
	// 82AAE460: C0060008  lfs f0, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE464: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE468: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE46C: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE470: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82AAE474: ED4C0332  fmuls f10, f12, f12
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82AAE478: C1260000  lfs f9, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82AAE47C: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82AAE480: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82AAE484: C0C50004  lfs f6, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82AAE488: C0A50008  lfs f5, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82AAE48C: EDAB6B3A  fmadds f13, f11, f12, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82AAE490: ED69527A  fmadds f11, f9, f9, f10
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64);
	// 82AAE494: EDA86A7A  fmadds f13, f8, f9, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82AAE498: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82AAE49C: EDA76A7C  fnmsubs f13, f7, f9, f13
	ctx.f[13].f64 = -(((ctx.f[7].f64 * ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE4A0: EDAC69BC  fnmsubs f13, f12, f6, f13
	ctx.f[13].f64 = -(((ctx.f[12].f64 * ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE4A4: EC05683C  fnmsubs f0, f5, f0, f13
	ctx.f[0].f64 = -(((ctx.f[5].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE4A8: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82AAE4AC: EDA9383A  fmadds f13, f9, f0, f7
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82AAE4B0: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE4B4: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE4B8: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE4BC: EDA0637A  fmadds f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE4C0: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE4C4: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE4C8: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE4CC: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AAE4D0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAE4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE4D8 size=348
    let mut pc: u32 = 0x82AAE4D8;
    'dispatch: loop {
        match pc {
            0x82AAE4D8 => {
    //   block [0x82AAE4D8..0x82AAE634)
	// 82AAE4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE4DC: 486F9C8D  bl 0x831a8168
	ctx.lr = 0x82AAE4E0;
	sub_831A8130(ctx, base);
	// 82AAE4E0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82AAE4E4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AAE4E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE4EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AAE4F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82AAE4F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AAE4F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAE4FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AAE500: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE504: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE508: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE50C: C3EBB59C  lfs f31, -0x4a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19044 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AAE510: C3CA9F7C  lfs f30, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AAE514: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82AAE518: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82AAE51C: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 82AAE520: 40990010  ble cr6, 0x82aae530
	if !ctx.cr[6].gt {
	pc = 0x82AAE530; continue 'dispatch;
	}
	// 82AAE524: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 82AAE528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAE52C: 41980008  blt cr6, 0x82aae534
	if ctx.cr[6].lt {
	pc = 0x82AAE534; continue 'dispatch;
	}
	// 82AAE530: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82AAE534: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE538: 41820010  beq 0x82aae548
	if ctx.cr[0].eq {
	pc = 0x82AAE548; continue 'dispatch;
	}
	// 82AAE53C: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAE540: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82AAE544: 480000DC  b 0x82aae620
	pc = 0x82AAE620; continue 'dispatch;
	// 82AAE548: C03F0004  lfs f1, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAE54C: 486FCA6D  bl 0x831aafb8
	ctx.lr = 0x82AAE550;
	sub_831AAFB8(ctx, base);
	// 82AAE550: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AAE554: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAE558: 3FA00001  lis r29, 1
	ctx.r[29].s64 = 65536;
	// 82AAE55C: C00B7614  lfs f0, 0x7614(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE560: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE564: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AAE568: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82AAE56C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AAE570: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82AAE574: 4099000C  ble cr6, 0x82aae580
	if !ctx.cr[6].gt {
	pc = 0x82AAE580; continue 'dispatch;
	}
	// 82AAE578: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82AAE57C: 48000010  b 0x82aae58c
	pc = 0x82AAE58C; continue 'dispatch;
	// 82AAE580: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82AAE584: 40980008  bge cr6, 0x82aae58c
	if !ctx.cr[6].lt {
	pc = 0x82AAE58C; continue 'dispatch;
	}
	// 82AAE588: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AAE58C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AAE590: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAE594: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82AAE598: 40990010  ble cr6, 0x82aae5a8
	if !ctx.cr[6].gt {
	pc = 0x82AAE5A8; continue 'dispatch;
	}
	// 82AAE59C: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82AAE5A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AAE5A4: 41980008  blt cr6, 0x82aae5ac
	if ctx.cr[6].lt {
	pc = 0x82AAE5AC; continue 'dispatch;
	}
	// 82AAE5A8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82AAE5AC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE5B0: 41820028  beq 0x82aae5d8
	if ctx.cr[0].eq {
	pc = 0x82AAE5D8; continue 'dispatch;
	}
	// 82AAE5B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAE5B8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82AAE5BC: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE5C0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE5C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AAE5C8: 40990058  ble cr6, 0x82aae620
	if !ctx.cr[6].gt {
	pc = 0x82AAE620; continue 'dispatch;
	}
	// 82AAE5CC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82AAE5D0: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 82AAE5D4: 48000048  b 0x82aae61c
	pc = 0x82AAE61C; continue 'dispatch;
	// 82AAE5D8: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE5DC: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82AAE5E0: 486FC9D9  bl 0x831aafb8
	ctx.lr = 0x82AAE5E4;
	sub_831AAFB8(ctx, base);
	// 82AAE5E4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AAE5E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAE5EC: C00B7610  lfs f0, 0x7610(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE5F0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE5F4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AAE5F8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82AAE5FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AAE600: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 82AAE604: 4099000C  ble cr6, 0x82aae610
	if !ctx.cr[6].gt {
	pc = 0x82AAE610; continue 'dispatch;
	}
	// 82AAE608: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82AAE60C: 48000010  b 0x82aae61c
	pc = 0x82AAE61C; continue 'dispatch;
	// 82AAE610: 2F0B8000  cmpwi cr6, r11, -0x8000
	ctx.cr[6].compare_i32(ctx.r[11].s32, -32768, &mut ctx.xer);
	// 82AAE614: 40980008  bge cr6, 0x82aae61c
	if !ctx.cr[6].lt {
	pc = 0x82AAE61C; continue 'dispatch;
	}
	// 82AAE618: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82AAE61C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AAE620: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82AAE624: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AAE628: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82AAE62C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82AAE630: 486F9B88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAE638 size=24
    let mut pc: u32 = 0x82AAE638;
    'dispatch: loop {
        match pc {
            0x82AAE638 => {
    //   block [0x82AAE638..0x82AAE650)
	// 82AAE638: EC011028  fsubs f0, f1, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[2].f64) as f32) as f64);
	// 82AAE63C: EC2000F2  fmuls f1, f0, f3
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[3].f64) as f32) as f64);
	// 82AAE640: FC002210  fabs f0, f4
	ctx.f[0].u64 = ctx.f[4].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE644: FDA00A10  fabs f13, f1
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE648: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AAE64C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE650 size=24
    let mut pc: u32 = 0x82AAE650;
    'dispatch: loop {
        match pc {
            0x82AAE650 => {
    //   block [0x82AAE650..0x82AAE668)
	// 82AAE650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAE654: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE658: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AAE65C: 4098000C  bge cr6, 0x82aae668
	if !ctx.cr[6].lt {
		sub_82AAE668(ctx, base);
		return;
	}
	// 82AAE660: FC202110  fnabs f1, f4
	ctx.f[1].u64 = ctx.f[4].u64 | 0x8000_0000_0000_0000u64;
	// 82AAE664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAE668 size=8
    let mut pc: u32 = 0x82AAE668;
    'dispatch: loop {
        match pc {
            0x82AAE668 => {
    //   block [0x82AAE668..0x82AAE670)
	// 82AAE668: FC202210  fabs f1, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = ctx.f[4].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE66C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE670 size=52
    let mut pc: u32 = 0x82AAE670;
    'dispatch: loop {
        match pc {
            0x82AAE670 => {
    //   block [0x82AAE670..0x82AAE6A4)
	// 82AAE670: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE674: FD801A10  fabs f12, f3
	ctx.f[12].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE678: EC016828  fsubs f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE67C: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82AAE680: FD600210  fabs f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE684: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 82AAE688: 40980020  bge cr6, 0x82aae6a8
	if !ctx.cr[6].lt {
		sub_82AAE6A4(ctx, base);
		return;
	}
	// 82AAE68C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAE690: C18B08A4  lfs f12, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AAE694: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82AAE698: 4098000C  bge cr6, 0x82aae6a4
	if !ctx.cr[6].lt {
		sub_82AAE6A4(ctx, base);
		return;
	}
	// 82AAE69C: FC001910  fnabs f0, f3
	ctx.f[0].u64 = ctx.f[3].u64 | 0x8000_0000_0000_0000u64;
	// 82AAE6A0: 48000008  b 0x82aae6a8
	sub_82AAE6A4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE6A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE6A4 size=36
    let mut pc: u32 = 0x82AAE6A4;
    'dispatch: loop {
        match pc {
            0x82AAE6A4 => {
    //   block [0x82AAE6A4..0x82AAE6C8)
	// 82AAE6A4: FC001A10  fabs f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE6A8: ED816828  fsubs f12, f1, f13
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE6AC: FD600210  fabs f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE6B0: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE6B4: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82AAE6B8: 40980010  bge cr6, 0x82aae6c8
	if !ctx.cr[6].lt {
		sub_82AAE6C8(ctx, base);
		return;
	}
	// 82AAE6BC: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE6C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAE6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE6C8 size=16
    let mut pc: u32 = 0x82AAE6C8;
    'dispatch: loop {
        match pc {
            0x82AAE6C8 => {
    //   block [0x82AAE6C8..0x82AAE6D8)
	// 82AAE6C8: EC0D002A  fadds f0, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AAE6CC: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE6D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAE6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE6D8 size=76
    let mut pc: u32 = 0x82AAE6D8;
    'dispatch: loop {
        match pc {
            0x82AAE6D8 => {
    //   block [0x82AAE6D8..0x82AAE724)
	// 82AAE6D8: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82AAE6DC: FD601210  fabs f11, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE6E0: 7C8A07B4  extsw r10, r4
	ctx.r[10].s64 = ctx.r[4].s32 as i64;
	// 82AAE6E4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82AAE6E8: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE6EC: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82AAE6F0: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE6F4: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 82AAE6F8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AAE6FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82AAE700: C00BF770  lfs f0, -0x890(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE704: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82AAE708: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82AAE70C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE710: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82AAE714: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82AAE718: FC000A10  fabs f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE71C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82AAE720: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AAE724 size=24
    let mut pc: u32 = 0x82AAE724;
    'dispatch: loop {
        match pc {
            0x82AAE724 => {
    //   block [0x82AAE724..0x82AAE73C)
	// 82AAE724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAE728: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE72C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82AAE730: 4098000C  bge cr6, 0x82aae73c
	if !ctx.cr[6].lt {
		sub_82AAE73C(ctx, base);
		return;
	}
	// 82AAE734: FC201110  fnabs f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 | 0x8000_0000_0000_0000u64;
	// 82AAE738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE73C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AAE73C size=8
    let mut pc: u32 = 0x82AAE73C;
    'dispatch: loop {
        match pc {
            0x82AAE73C => {
    //   block [0x82AAE73C..0x82AAE744)
	// 82AAE73C: FC201210  fabs f1, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 82AAE740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE748 size=424
    let mut pc: u32 = 0x82AAE748;
    'dispatch: loop {
        match pc {
            0x82AAE748 => {
    //   block [0x82AAE748..0x82AAE8F0)
	// 82AAE748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAE754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE758: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AAE75C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AAE760: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AAE768: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AAE76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE770: 4BA3C319  bl 0x824eaa88
	ctx.lr = 0x82AAE774;
	sub_824EAA88(ctx, base);
	// 82AAE774: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE778: 4BA3B0D9  bl 0x824e9850
	ctx.lr = 0x82AAE77C;
	sub_824E9850(ctx, base);
	// 82AAE77C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAE780: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AAE784: C3CB9450  lfs f30, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AAE788: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82AAE78C: 41990008  bgt cr6, 0x82aae794
	if ctx.cr[6].gt {
	pc = 0x82AAE794; continue 'dispatch;
	}
	// 82AAE790: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAE794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AAE798: 483434F9  bl 0x82df1c90
	ctx.lr = 0x82AAE79C;
	sub_82DF1C90(ctx, base);
	// 82AAE79C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE7A0: 41820024  beq 0x82aae7c4
	if ctx.cr[0].eq {
	pc = 0x82AAE7C4; continue 'dispatch;
	}
	// 82AAE7A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAE7A8: 4BA3C2E1  bl 0x824eaa88
	ctx.lr = 0x82AAE7AC;
	sub_824EAA88(ctx, base);
	// 82AAE7AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE7B0: 4BA3B0A1  bl 0x824e9850
	ctx.lr = 0x82AAE7B4;
	sub_824E9850(ctx, base);
	// 82AAE7B4: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE7B8: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82AAE7BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AAE7C0: 48000020  b 0x82aae7e0
	pc = 0x82AAE7E0; continue 'dispatch;
	// 82AAE7C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAE7C8: 4BA3C2C1  bl 0x824eaa88
	ctx.lr = 0x82AAE7CC;
	sub_824EAA88(ctx, base);
	// 82AAE7CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE7D0: 4BA3B081  bl 0x824e9850
	ctx.lr = 0x82AAE7D4;
	sub_824E9850(ctx, base);
	// 82AAE7D4: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE7D8: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AAE7DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AAE7E0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE7E4: 483434AD  bl 0x82df1c90
	ctx.lr = 0x82AAE7E8;
	sub_82DF1C90(ctx, base);
	// 82AAE7E8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAE7EC: 4BA3C29D  bl 0x824eaa88
	ctx.lr = 0x82AAE7F0;
	sub_824EAA88(ctx, base);
	// 82AAE7F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE7F4: 4BA3B05D  bl 0x824e9850
	ctx.lr = 0x82AAE7F8;
	sub_824E9850(ctx, base);
	// 82AAE7F8: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82AAE7FC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AAE800: 41990008  bgt cr6, 0x82aae808
	if ctx.cr[6].gt {
	pc = 0x82AAE808; continue 'dispatch;
	}
	// 82AAE804: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAE808: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AAE80C: 48343485  bl 0x82df1c90
	ctx.lr = 0x82AAE810;
	sub_82DF1C90(ctx, base);
	// 82AAE810: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE814: 41820024  beq 0x82aae838
	if ctx.cr[0].eq {
	pc = 0x82AAE838; continue 'dispatch;
	}
	// 82AAE818: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAE81C: 4BA3C26D  bl 0x824eaa88
	ctx.lr = 0x82AAE820;
	sub_824EAA88(ctx, base);
	// 82AAE820: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE824: 4BA3B02D  bl 0x824e9850
	ctx.lr = 0x82AAE828;
	sub_824E9850(ctx, base);
	// 82AAE828: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE82C: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82AAE830: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AAE834: 48000020  b 0x82aae854
	pc = 0x82AAE854; continue 'dispatch;
	// 82AAE838: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAE83C: 4BA3C24D  bl 0x824eaa88
	ctx.lr = 0x82AAE840;
	sub_824EAA88(ctx, base);
	// 82AAE840: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE844: 4BA3B00D  bl 0x824e9850
	ctx.lr = 0x82AAE848;
	sub_824E9850(ctx, base);
	// 82AAE848: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE84C: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AAE850: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AAE854: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE858: 48343439  bl 0x82df1c90
	ctx.lr = 0x82AAE85C;
	sub_82DF1C90(ctx, base);
	// 82AAE85C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAE860: 4BA3C229  bl 0x824eaa88
	ctx.lr = 0x82AAE864;
	sub_824EAA88(ctx, base);
	// 82AAE864: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE868: 4BA3AFE9  bl 0x824e9850
	ctx.lr = 0x82AAE86C;
	sub_824E9850(ctx, base);
	// 82AAE86C: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82AAE870: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82AAE874: 41990008  bgt cr6, 0x82aae87c
	if ctx.cr[6].gt {
	pc = 0x82AAE87C; continue 'dispatch;
	}
	// 82AAE878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AAE87C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AAE880: 48343411  bl 0x82df1c90
	ctx.lr = 0x82AAE884;
	sub_82DF1C90(ctx, base);
	// 82AAE884: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAE888: 41820024  beq 0x82aae8ac
	if ctx.cr[0].eq {
	pc = 0x82AAE8AC; continue 'dispatch;
	}
	// 82AAE88C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAE890: 4BA3C1F9  bl 0x824eaa88
	ctx.lr = 0x82AAE894;
	sub_824EAA88(ctx, base);
	// 82AAE894: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE898: 4BA3AFB9  bl 0x824e9850
	ctx.lr = 0x82AAE89C;
	sub_824E9850(ctx, base);
	// 82AAE89C: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE8A0: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82AAE8A4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82AAE8A8: 48000020  b 0x82aae8c8
	pc = 0x82AAE8C8; continue 'dispatch;
	// 82AAE8AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAE8B0: 4BA3C1D9  bl 0x824eaa88
	ctx.lr = 0x82AAE8B4;
	sub_824EAA88(ctx, base);
	// 82AAE8B4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AAE8B8: 4BA3AF99  bl 0x824e9850
	ctx.lr = 0x82AAE8BC;
	sub_824E9850(ctx, base);
	// 82AAE8BC: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE8C0: EC0107FC  fnmsubs f0, f1, f31, f0
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82AAE8C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AAE8C8: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAE8CC: 483433C5  bl 0x82df1c90
	ctx.lr = 0x82AAE8D0;
	sub_82DF1C90(ctx, base);
	// 82AAE8D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AAE8D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAE8D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAE8DC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AAE8E0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AAE8E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAE8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE8F0 size=152
    let mut pc: u32 = 0x82AAE8F0;
    'dispatch: loop {
        match pc {
            0x82AAE8F0 => {
    //   block [0x82AAE8F0..0x82AAE988)
	// 82AAE8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAE8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE900: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AAE904: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AAE908: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE90C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AAE910: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82AAE914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAE918: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AAE91C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAE920: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE924: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE928: C00ACEE4  lfs f0, -0x311c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE92C: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE930: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AAE934: 486FA575  bl 0x831a8ea8
	ctx.lr = 0x82AAE938;
	sub_831A8EA8(ctx, base);
	// 82AAE938: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AAE93C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AAE940: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82AAE944: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAE948: 486FA481  bl 0x831a8dc8
	ctx.lr = 0x82AAE94C;
	sub_831A8DC8(ctx, base);
	// 82AAE94C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AAE950: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82AAE954: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAE958: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AAE95C: 13C0F8C7  vcmpequd (lvx128) v30, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAE988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAE988 size=116
    let mut pc: u32 = 0x82AAE988;
    'dispatch: loop {
        match pc {
            0x82AAE988 => {
    //   block [0x82AAE988..0x82AAE9FC)
	// 82AAE988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAE98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAE990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AAE994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AAE998: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82AAE99C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82AAE9A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAE9A4: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 82AAE9A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AAE9AC: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82AAE9B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AAE9B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82AAE9B8: 4BFFFF39  bl 0x82aae8f0
	ctx.lr = 0x82AAE9BC;
	sub_82AAE8F0(ctx, base);
	// 82AAE9BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AAE9C0: C00BCEE4  lfs f0, -0x311c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAE9C4: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AAE9C8: 486FA401  bl 0x831a8dc8
	ctx.lr = 0x82AAE9CC;
	sub_831A8DC8(ctx, base);
	// 82AAE9CC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AAE9D0: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AAE9D4: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82AAE9D8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAE9DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AAE9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAE9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAE9E8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AAE9EC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82AAE9F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AAE9F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AAE9F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AAEA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AAEA00 size=152
    let mut pc: u32 = 0x82AAEA00;
    'dispatch: loop {
        match pc {
            0x82AAEA00 => {
    //   block [0x82AAEA00..0x82AAEA98)
	// 82AAEA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AAEA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AAEA08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AAEA0C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AAEA10: C0050000  lfs f0, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAEA14: FD400890  fmr f10, f1
	ctx.f[10].f64 = ctx.f[1].f64;
	// 82AAEA18: FD201090  fmr f9, f2
	ctx.f[9].f64 = ctx.f[2].f64;
	// 82AAEA1C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82AAEA20: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAEA24: FC405090  fmr f2, f10
	ctx.f[2].f64 = ctx.f[10].f64;
	// 82AAEA28: FC604890  fmr f3, f9
	ctx.f[3].f64 = ctx.f[9].f64;
	// 82AAEA2C: 4BFFFC45  bl 0x82aae670
	ctx.lr = 0x82AAEA30;
	sub_82AAE670(ctx, base);
	// 82AAEA30: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAEA34: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82AAEA38: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82AAEA3C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82AAEA40: C0240004  lfs f1, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAEA44: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AAEA48: 4BFFFC29  bl 0x82aae670
	ctx.lr = 0x82AAEA4C;
	sub_82AAE670(ctx, base);
	// 82AAEA4C: C0050008  lfs f0, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AAEA50: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82AAEA54: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 82AAEA58: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AAEA5C: C0240008  lfs f1, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AAEA60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AAEA64: 4BFFFC0D  bl 0x82aae670
	ctx.lr = 0x82AAEA68;
	sub_82AAE670(ctx, base);
	// 82AAEA68: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAEA6C: 41820018  beq 0x82aaea84
	if ctx.cr[0].eq {
	pc = 0x82AAEA84; continue 'dispatch;
	}
	// 82AAEA70: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAEA74: 41820010  beq 0x82aaea84
	if ctx.cr[0].eq {
	pc = 0x82AAEA84; continue 'dispatch;
	}
	// 82AAEA78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AAEA7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AAEA80: 40820008  bne 0x82aaea88
	if !ctx.cr[0].eq {
	pc = 0x82AAEA88; continue 'dispatch;
	}
	// 82AAEA84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AAEA88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AAEA8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AAEA90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AAEA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


