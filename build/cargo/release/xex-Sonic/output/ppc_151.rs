pub fn sub_82B89C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B89C50 size=88
    let mut pc: u32 = 0x82B89C50;
    'dispatch: loop {
        match pc {
            0x82B89C50 => {
    //   block [0x82B89C50..0x82B89CA8)
	// 82B89C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B89C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89C68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B89C6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B89C70: 396B859C  addi r11, r11, -0x7a64
	ctx.r[11].s64 = ctx.r[11].s64 + -31332;
	// 82B89C74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B89C78: 4BFFE4C1  bl 0x82b88138
	ctx.lr = 0x82B89C7C;
	sub_82B88138(ctx, base);
	// 82B89C7C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89C80: 4182000C  beq 0x82b89c8c
	if ctx.cr[0].eq {
	pc = 0x82B89C8C; continue 'dispatch;
	}
	// 82B89C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B89C88: 48268751  bl 0x82df23d8
	ctx.lr = 0x82B89C8C;
	sub_82DF23D8(ctx, base);
	// 82B89C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B89C90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B89C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B89C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B89C9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B89CA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B89CA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B89CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B89CA8 size=172
    let mut pc: u32 = 0x82B89CA8;
    'dispatch: loop {
        match pc {
            0x82B89CA8 => {
    //   block [0x82B89CA8..0x82B89D54)
	// 82B89CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B89CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89CC0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B89CC4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89CC8: 48004A71  bl 0x82b8e738
	ctx.lr = 0x82B89CCC;
	sub_82B8E738(ctx, base);
	// 82B89CCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89CD0: 41820064  beq 0x82b89d34
	if ctx.cr[0].eq {
	pc = 0x82B89D34; continue 'dispatch;
	}
	// 82B89CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B89CD8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89CDC: 4B9857ED  bl 0x8250f4c8
	ctx.lr = 0x82B89CE0;
	sub_8250F4C8(ctx, base);
	// 82B89CE0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B89CE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B89CE8: 396AFFFC  addi r11, r10, -4
	ctx.r[11].s64 = ctx.r[10].s64 + -4;
	// 82B89CEC: 409A0008  bne cr6, 0x82b89cf4
	if !ctx.cr[6].eq {
	pc = 0x82B89CF4; continue 'dispatch;
	}
	// 82B89CF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B89CF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B89CF8: 419A0034  beq cr6, 0x82b89d2c
	if ctx.cr[6].eq {
	pc = 0x82B89D2C; continue 'dispatch;
	}
	// 82B89CFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B89D00: 386AFFFC  addi r3, r10, -4
	ctx.r[3].s64 = ctx.r[10].s64 + -4;
	// 82B89D04: 409A0008  bne cr6, 0x82b89d0c
	if !ctx.cr[6].eq {
	pc = 0x82B89D0C; continue 'dispatch;
	}
	// 82B89D08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B89D0C: 4B97E82D  bl 0x82508538
	ctx.lr = 0x82B89D10;
	sub_82508538(ctx, base);
	// 82B89D10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B89D14: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89D18: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B89D1C: 48004A45  bl 0x82b8e760
	ctx.lr = 0x82B89D20;
	sub_82B8E760(ctx, base);
	// 82B89D20: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 82B89D24: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B89D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B89D58 size=328
    let mut pc: u32 = 0x82B89D58;
    'dispatch: loop {
        match pc {
            0x82B89D58 => {
    //   block [0x82B89D58..0x82B89EA0)
	// 82B89D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89D64: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B89D68: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B89D6C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89D70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89D74: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B89D78: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89D7C: 480049BD  bl 0x82b8e738
	ctx.lr = 0x82B89D80;
	sub_82B8E738(ctx, base);
	// 82B89D80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89D84: 41820100  beq 0x82b89e84
	if ctx.cr[0].eq {
	pc = 0x82B89E84; continue 'dispatch;
	}
	// 82B89D88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B89D8C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B89D90: 409A00F4  bne cr6, 0x82b89e84
	if !ctx.cr[6].eq {
	pc = 0x82B89E84; continue 'dispatch;
	}
	// 82B89D94: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89D98: 48004929  bl 0x82b8e6c0
	ctx.lr = 0x82B89D9C;
	sub_82B8E6C0(ctx, base);
	// 82B89D9C: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B89DA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89DA4: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B89DA8: 480049B9  bl 0x82b8e760
	ctx.lr = 0x82B89DAC;
	sub_82B8E760(ctx, base);
	// 82B89DAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B89DB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B89DB4: 4BFF577D  bl 0x82b7f530
	ctx.lr = 0x82B89DB8;
	sub_82B7F530(ctx, base);
	// 82B89DB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B89DBC: C3CB94AC  lfs f30, -0x6b54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82B89DC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89DC4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B89DCC: 419A0014  beq cr6, 0x82b89de0
	if ctx.cr[6].eq {
	pc = 0x82B89DE0; continue 'dispatch;
	}
	// 82B89DD0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B89DD4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B89DD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B89DDC: 4BFF5525  bl 0x82b7f300
	ctx.lr = 0x82B89DE0;
	sub_82B7F300(ctx, base);
	// 82B89DE0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89DE4: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B89DE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B89DEC: 419A0014  beq cr6, 0x82b89e00
	if ctx.cr[6].eq {
	pc = 0x82B89E00; continue 'dispatch;
	}
	// 82B89DF0: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82B89DF4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B89DF8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B89DFC: 4BFF5505  bl 0x82b7f300
	ctx.lr = 0x82B89E00;
	sub_82B7F300(ctx, base);
	// 82B89E00: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89E04: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B89E08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B89E0C: 419A0014  beq cr6, 0x82b89e20
	if ctx.cr[6].eq {
	pc = 0x82B89E20; continue 'dispatch;
	}
	// 82B89E10: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B89E14: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B89E18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B89E1C: 4BFF54E5  bl 0x82b7f300
	ctx.lr = 0x82B89E20;
	sub_82B7F300(ctx, base);
	// 82B89E20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B89E24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B89E28: 4BFF5809  bl 0x82b7f630
	ctx.lr = 0x82B89E2C;
	sub_82B7F630(ctx, base);
	// 82B89E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B89E30: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89E34: 4B985695  bl 0x8250f4c8
	ctx.lr = 0x82B89E38;
	sub_8250F4C8(ctx, base);
	// 82B89E38: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B89E3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B89E40: 396AFFFC  addi r11, r10, -4
	ctx.r[11].s64 = ctx.r[10].s64 + -4;
	// 82B89E44: 409A0008  bne cr6, 0x82b89e4c
	if !ctx.cr[6].eq {
	pc = 0x82B89E4C; continue 'dispatch;
	}
	// 82B89E48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B89E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B89E50: 419A002C  beq cr6, 0x82b89e7c
	if ctx.cr[6].eq {
	pc = 0x82B89E7C; continue 'dispatch;
	}
	// 82B89E54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B89E58: 386AFFFC  addi r3, r10, -4
	ctx.r[3].s64 = ctx.r[10].s64 + -4;
	// 82B89E5C: 409A0008  bne cr6, 0x82b89e64
	if !ctx.cr[6].eq {
	pc = 0x82B89E64; continue 'dispatch;
	}
	// 82B89E60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B89E64: 4B97E6D5  bl 0x82508538
	ctx.lr = 0x82B89E68;
	sub_82508538(ctx, base);
	// 82B89E68: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82B89E6C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B89E70: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82B89E74: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B89EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B89EA0 size=88
    let mut pc: u32 = 0x82B89EA0;
    'dispatch: loop {
        match pc {
            0x82B89EA0 => {
    //   block [0x82B89EA0..0x82B89EF8)
	// 82B89EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B89EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89EB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B89EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B89EC0: 396B85C8  addi r11, r11, -0x7a38
	ctx.r[11].s64 = ctx.r[11].s64 + -31288;
	// 82B89EC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B89EC8: 4BFFE271  bl 0x82b88138
	ctx.lr = 0x82B89ECC;
	sub_82B88138(ctx, base);
	// 82B89ECC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89ED0: 4182000C  beq 0x82b89edc
	if ctx.cr[0].eq {
	pc = 0x82B89EDC; continue 'dispatch;
	}
	// 82B89ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B89ED8: 48268501  bl 0x82df23d8
	ctx.lr = 0x82B89EDC;
	sub_82DF23D8(ctx, base);
	// 82B89EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B89EE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B89EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B89EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B89EEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B89EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B89EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B89EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B89EF8 size=92
    let mut pc: u32 = 0x82B89EF8;
    'dispatch: loop {
        match pc {
            0x82B89EF8 => {
    //   block [0x82B89EF8..0x82B89F54)
	// 82B89EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89F00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89F04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89F0C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B89F10: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89F14: 48004825  bl 0x82b8e738
	ctx.lr = 0x82B89F18;
	sub_82B8E738(ctx, base);
	// 82B89F18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89F1C: 4182001C  beq 0x82b89f38
	if ctx.cr[0].eq {
	pc = 0x82B89F38; continue 'dispatch;
	}
	// 82B89F20: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89F24: 4800484D  bl 0x82b8e770
	ctx.lr = 0x82B89F28;
	sub_82B8E770(ctx, base);
	// 82B89F28: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82B89F2C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82B89F30: 396B5670  addi r11, r11, 0x5670
	ctx.r[11].s64 = ctx.r[11].s64 + 22128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B89F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B89F58 size=260
    let mut pc: u32 = 0x82B89F58;
    'dispatch: loop {
        match pc {
            0x82B89F58 => {
    //   block [0x82B89F58..0x82B8A05C)
	// 82B89F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B89F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B89F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B89F64: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B89F68: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B89F6C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B89F70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B89F74: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B89F78: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89F7C: 480047BD  bl 0x82b8e738
	ctx.lr = 0x82B89F80;
	sub_82B8E738(ctx, base);
	// 82B89F80: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B89F84: 418200BC  beq 0x82b8a040
	if ctx.cr[0].eq {
	pc = 0x82B8A040; continue 'dispatch;
	}
	// 82B89F88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B89F8C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B89F90: 409A00B0  bne cr6, 0x82b8a040
	if !ctx.cr[6].eq {
	pc = 0x82B8A040; continue 'dispatch;
	}
	// 82B89F94: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89F98: 48004729  bl 0x82b8e6c0
	ctx.lr = 0x82B89F9C;
	sub_82B8E6C0(ctx, base);
	// 82B89F9C: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B89FA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B89FA4: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B89FA8: 480047C9  bl 0x82b8e770
	ctx.lr = 0x82B89FAC;
	sub_82B8E770(ctx, base);
	// 82B89FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B89FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B89FB4: 4BFF557D  bl 0x82b7f530
	ctx.lr = 0x82B89FB8;
	sub_82B7F530(ctx, base);
	// 82B89FB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B89FBC: C3CB94AC  lfs f30, -0x6b54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82B89FC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89FC4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B89FCC: 419A0014  beq cr6, 0x82b89fe0
	if ctx.cr[6].eq {
	pc = 0x82B89FE0; continue 'dispatch;
	}
	// 82B89FD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B89FD4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B89FD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B89FDC: 4BFF5325  bl 0x82b7f300
	ctx.lr = 0x82B89FE0;
	sub_82B7F300(ctx, base);
	// 82B89FE0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B89FE4: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B89FE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B89FEC: 419A0014  beq cr6, 0x82b8a000
	if ctx.cr[6].eq {
	pc = 0x82B8A000; continue 'dispatch;
	}
	// 82B89FF0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B89FF4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B89FF8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B89FFC: 4BFF5305  bl 0x82b7f300
	ctx.lr = 0x82B8A000;
	sub_82B7F300(ctx, base);
	// 82B8A000: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A004: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8A008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A00C: 419A0014  beq cr6, 0x82b8a020
	if ctx.cr[6].eq {
	pc = 0x82B8A020; continue 'dispatch;
	}
	// 82B8A010: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8A014: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B8A018: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8A01C: 4BFF52E5  bl 0x82b7f300
	ctx.lr = 0x82B8A020;
	sub_82B7F300(ctx, base);
	// 82B8A020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8A024: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8A028: 4BFF5609  bl 0x82b7f630
	ctx.lr = 0x82B8A02C;
	sub_82B7F630(ctx, base);
	// 82B8A02C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82B8A030: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82B8A034: 396B5670  addi r11, r11, 0x5670
	ctx.r[11].s64 = ctx.r[11].s64 + 22128;
	// 82B8A038: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A060 size=88
    let mut pc: u32 = 0x82B8A060;
    'dispatch: loop {
        match pc {
            0x82B8A060 => {
    //   block [0x82B8A060..0x82B8A0B8)
	// 82B8A060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A078: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A07C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A080: 396B85F4  addi r11, r11, -0x7a0c
	ctx.r[11].s64 = ctx.r[11].s64 + -31244;
	// 82B8A084: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A088: 4BFFE0B1  bl 0x82b88138
	ctx.lr = 0x82B8A08C;
	sub_82B88138(ctx, base);
	// 82B8A08C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A090: 4182000C  beq 0x82b8a09c
	if ctx.cr[0].eq {
	pc = 0x82B8A09C; continue 'dispatch;
	}
	// 82B8A094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A098: 48268341  bl 0x82df23d8
	ctx.lr = 0x82B8A09C;
	sub_82DF23D8(ctx, base);
	// 82B8A09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A0A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A0AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A0B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A0B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A0B8 size=92
    let mut pc: u32 = 0x82B8A0B8;
    'dispatch: loop {
        match pc {
            0x82B8A0B8 => {
    //   block [0x82B8A0B8..0x82B8A114)
	// 82B8A0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A0C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A0C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A0C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A0CC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A0D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A0D4: 48004665  bl 0x82b8e738
	ctx.lr = 0x82B8A0D8;
	sub_82B8E738(ctx, base);
	// 82B8A0D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A0DC: 4182001C  beq 0x82b8a0f8
	if ctx.cr[0].eq {
	pc = 0x82B8A0F8; continue 'dispatch;
	}
	// 82B8A0E0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A0E4: 4800469D  bl 0x82b8e780
	ctx.lr = 0x82B8A0E8;
	sub_82B8E780(ctx, base);
	// 82B8A0E8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82B8A0EC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82B8A0F0: 396B5680  addi r11, r11, 0x5680
	ctx.r[11].s64 = ctx.r[11].s64 + 22144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A118 size=260
    let mut pc: u32 = 0x82B8A118;
    'dispatch: loop {
        match pc {
            0x82B8A118 => {
    //   block [0x82B8A118..0x82B8A21C)
	// 82B8A118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A124: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B8A128: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8A12C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A134: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A138: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A13C: 480045FD  bl 0x82b8e738
	ctx.lr = 0x82B8A140;
	sub_82B8E738(ctx, base);
	// 82B8A140: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A144: 418200BC  beq 0x82b8a200
	if ctx.cr[0].eq {
	pc = 0x82B8A200; continue 'dispatch;
	}
	// 82B8A148: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A14C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8A150: 409A00B0  bne cr6, 0x82b8a200
	if !ctx.cr[6].eq {
	pc = 0x82B8A200; continue 'dispatch;
	}
	// 82B8A154: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A158: 48004569  bl 0x82b8e6c0
	ctx.lr = 0x82B8A15C;
	sub_82B8E6C0(ctx, base);
	// 82B8A15C: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A160: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A164: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8A168: 48004619  bl 0x82b8e780
	ctx.lr = 0x82B8A16C;
	sub_82B8E780(ctx, base);
	// 82B8A16C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8A170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8A174: 4BFF53BD  bl 0x82b7f530
	ctx.lr = 0x82B8A178;
	sub_82B7F530(ctx, base);
	// 82B8A178: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8A17C: C3CB94AC  lfs f30, -0x6b54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82B8A180: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A184: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A18C: 419A0014  beq cr6, 0x82b8a1a0
	if ctx.cr[6].eq {
	pc = 0x82B8A1A0; continue 'dispatch;
	}
	// 82B8A190: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8A194: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B8A198: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8A19C: 4BFF5165  bl 0x82b7f300
	ctx.lr = 0x82B8A1A0;
	sub_82B7F300(ctx, base);
	// 82B8A1A0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A1A4: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8A1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A1AC: 419A0014  beq cr6, 0x82b8a1c0
	if ctx.cr[6].eq {
	pc = 0x82B8A1C0; continue 'dispatch;
	}
	// 82B8A1B0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8A1B4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B8A1B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8A1BC: 4BFF5145  bl 0x82b7f300
	ctx.lr = 0x82B8A1C0;
	sub_82B7F300(ctx, base);
	// 82B8A1C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A1C4: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8A1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A1CC: 419A0014  beq cr6, 0x82b8a1e0
	if ctx.cr[6].eq {
	pc = 0x82B8A1E0; continue 'dispatch;
	}
	// 82B8A1D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8A1D4: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82B8A1D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8A1DC: 4BFF5125  bl 0x82b7f300
	ctx.lr = 0x82B8A1E0;
	sub_82B7F300(ctx, base);
	// 82B8A1E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8A1E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8A1E8: 4BFF5449  bl 0x82b7f630
	ctx.lr = 0x82B8A1EC;
	sub_82B7F630(ctx, base);
	// 82B8A1EC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82B8A1F0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82B8A1F4: 396B5680  addi r11, r11, 0x5680
	ctx.r[11].s64 = ctx.r[11].s64 + 22144;
	// 82B8A1F8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A220 size=88
    let mut pc: u32 = 0x82B8A220;
    'dispatch: loop {
        match pc {
            0x82B8A220 => {
    //   block [0x82B8A220..0x82B8A278)
	// 82B8A220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A22C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A238: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A23C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A240: 396B8620  addi r11, r11, -0x79e0
	ctx.r[11].s64 = ctx.r[11].s64 + -31200;
	// 82B8A244: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A248: 4BFFDEF1  bl 0x82b88138
	ctx.lr = 0x82B8A24C;
	sub_82B88138(ctx, base);
	// 82B8A24C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A250: 4182000C  beq 0x82b8a25c
	if ctx.cr[0].eq {
	pc = 0x82B8A25C; continue 'dispatch;
	}
	// 82B8A254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A258: 48268181  bl 0x82df23d8
	ctx.lr = 0x82B8A25C;
	sub_82DF23D8(ctx, base);
	// 82B8A25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A26C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A278 size=272
    let mut pc: u32 = 0x82B8A278;
    'dispatch: loop {
        match pc {
            0x82B8A278 => {
    //   block [0x82B8A278..0x82B8A388)
	// 82B8A278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A284: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B8A288: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8A28C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A294: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A298: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A29C: 4800449D  bl 0x82b8e738
	ctx.lr = 0x82B8A2A0;
	sub_82B8E738(ctx, base);
	// 82B8A2A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A2A4: 418200C8  beq 0x82b8a36c
	if ctx.cr[0].eq {
	pc = 0x82B8A36C; continue 'dispatch;
	}
	// 82B8A2A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A2AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8A2B0: 409A00BC  bne cr6, 0x82b8a36c
	if !ctx.cr[6].eq {
	pc = 0x82B8A36C; continue 'dispatch;
	}
	// 82B8A2B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A2B8: 48004409  bl 0x82b8e6c0
	ctx.lr = 0x82B8A2BC;
	sub_82B8E6C0(ctx, base);
	// 82B8A2BC: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A2C0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A2C4: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8A2C8: 480044C9  bl 0x82b8e790
	ctx.lr = 0x82B8A2CC;
	sub_82B8E790(ctx, base);
	// 82B8A2CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8A2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8A2D4: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82B8A2D8: 4861E239  bl 0x831a8510
	ctx.lr = 0x82B8A2DC;
	sub_831A8510(ctx, base);
	// 82B8A2DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8A2E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8A2E4: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A2E8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82B8A2EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8A2F0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A2F4: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8A2F8: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A2FC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A300: 4BFF5001  bl 0x82b7f300
	ctx.lr = 0x82B8A304;
	sub_82B7F300(ctx, base);
	// 82B8A304: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A308: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82B8A30C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8A310: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A314: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A318: 4BFF4FE9  bl 0x82b7f300
	ctx.lr = 0x82B8A31C;
	sub_82B7F300(ctx, base);
	// 82B8A31C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A320: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B8A324: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A328: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A32C: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8A330: 4BFF4FD1  bl 0x82b7f300
	ctx.lr = 0x82B8A334;
	sub_82B7F300(ctx, base);
	// 82B8A334: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A338: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82B8A33C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A340: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A344: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8A348: 4BFF4FB9  bl 0x82b7f300
	ctx.lr = 0x82B8A34C;
	sub_82B7F300(ctx, base);
	// 82B8A34C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A350: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B8A354: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A358: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A35C: 806B0030  lwz r3, 0x30(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82B8A360: 4BFF4FA1  bl 0x82b7f300
	ctx.lr = 0x82B8A364;
	sub_82B7F300(ctx, base);
	// 82B8A364: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8A368: 48012721  bl 0x82b9ca88
	ctx.lr = 0x82B8A36C;
	sub_82B9CA88(ctx, base);
	// 82B8A36C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8A370: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A374: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A378: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8A37C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A380: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A388 size=88
    let mut pc: u32 = 0x82B8A388;
    'dispatch: loop {
        match pc {
            0x82B8A388 => {
    //   block [0x82B8A388..0x82B8A3E0)
	// 82B8A388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A390: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A394: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A3A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A3A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A3A8: 396B864C  addi r11, r11, -0x79b4
	ctx.r[11].s64 = ctx.r[11].s64 + -31156;
	// 82B8A3AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A3B0: 4BFFDD89  bl 0x82b88138
	ctx.lr = 0x82B8A3B4;
	sub_82B88138(ctx, base);
	// 82B8A3B4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A3B8: 4182000C  beq 0x82b8a3c4
	if ctx.cr[0].eq {
	pc = 0x82B8A3C4; continue 'dispatch;
	}
	// 82B8A3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A3C0: 48268019  bl 0x82df23d8
	ctx.lr = 0x82B8A3C4;
	sub_82DF23D8(ctx, base);
	// 82B8A3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A3C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A3D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A3D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A3DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A3E0 size=268
    let mut pc: u32 = 0x82B8A3E0;
    'dispatch: loop {
        match pc {
            0x82B8A3E0 => {
    //   block [0x82B8A3E0..0x82B8A4EC)
	// 82B8A3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A3E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A3EC: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B8A3F0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8A3F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A3F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A3FC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A400: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A404: 48004335  bl 0x82b8e738
	ctx.lr = 0x82B8A408;
	sub_82B8E738(ctx, base);
	// 82B8A408: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A40C: 418200C4  beq 0x82b8a4d0
	if ctx.cr[0].eq {
	pc = 0x82B8A4D0; continue 'dispatch;
	}
	// 82B8A410: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A414: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8A418: 409A00B8  bne cr6, 0x82b8a4d0
	if !ctx.cr[6].eq {
	pc = 0x82B8A4D0; continue 'dispatch;
	}
	// 82B8A41C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A420: 480042A1  bl 0x82b8e6c0
	ctx.lr = 0x82B8A424;
	sub_82B8E6C0(ctx, base);
	// 82B8A424: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A428: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A42C: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8A430: 48004371  bl 0x82b8e7a0
	ctx.lr = 0x82B8A434;
	sub_82B8E7A0(ctx, base);
	// 82B8A434: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8A438: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82B8A43C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82B8A440: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82B8A444: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8A448: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8A44C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8A450: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82B8A454: 4200FFF0  bdnz 0x82b8a444
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82B8A444; continue 'dispatch;
	}
	// 82B8A458: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8A45C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A460: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82B8A464: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A468: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82B8A46C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8A470: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A474: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8A478: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A47C: 4BFF4E85  bl 0x82b7f300
	ctx.lr = 0x82B8A480;
	sub_82B7F300(ctx, base);
	// 82B8A480: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A484: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8A488: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8A48C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A490: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A494: 4BFF4E6D  bl 0x82b7f300
	ctx.lr = 0x82B8A498;
	sub_82B7F300(ctx, base);
	// 82B8A498: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A49C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82B8A4A0: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A4A4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A4A8: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8A4AC: 4BFF4E55  bl 0x82b7f300
	ctx.lr = 0x82B8A4B0;
	sub_82B7F300(ctx, base);
	// 82B8A4B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A4B4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B8A4B8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A4BC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A4C0: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8A4C4: 4BFF4E3D  bl 0x82b7f300
	ctx.lr = 0x82B8A4C8;
	sub_82B7F300(ctx, base);
	// 82B8A4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8A4CC: 48016035  bl 0x82ba0500
	ctx.lr = 0x82B8A4D0;
	sub_82BA0500(ctx, base);
	// 82B8A4D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8A4D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A4D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A4DC: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8A4E0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A4E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A4E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A4F0 size=88
    let mut pc: u32 = 0x82B8A4F0;
    'dispatch: loop {
        match pc {
            0x82B8A4F0 => {
    //   block [0x82B8A4F0..0x82B8A548)
	// 82B8A4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A4F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A4F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A4FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A50C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A510: 396B8678  addi r11, r11, -0x7988
	ctx.r[11].s64 = ctx.r[11].s64 + -31112;
	// 82B8A514: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A518: 4BFFDC21  bl 0x82b88138
	ctx.lr = 0x82B8A51C;
	sub_82B88138(ctx, base);
	// 82B8A51C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A520: 4182000C  beq 0x82b8a52c
	if ctx.cr[0].eq {
	pc = 0x82B8A52C; continue 'dispatch;
	}
	// 82B8A524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A528: 48267EB1  bl 0x82df23d8
	ctx.lr = 0x82B8A52C;
	sub_82DF23D8(ctx, base);
	// 82B8A52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A530: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A53C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A548 size=88
    let mut pc: u32 = 0x82B8A548;
    'dispatch: loop {
        match pc {
            0x82B8A548 => {
    //   block [0x82B8A548..0x82B8A5A0)
	// 82B8A548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A550: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A554: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A558: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A55C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A560: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A564: 480041D5  bl 0x82b8e738
	ctx.lr = 0x82B8A568;
	sub_82B8E738(ctx, base);
	// 82B8A568: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A56C: 41820018  beq 0x82b8a584
	if ctx.cr[0].eq {
	pc = 0x82B8A584; continue 'dispatch;
	}
	// 82B8A570: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A574: 4800423D  bl 0x82b8e7b0
	ctx.lr = 0x82B8A578;
	sub_82B8E7B0(ctx, base);
	// 82B8A578: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82B8A57C: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82B8A580: F96AAD48  std r11, -0x52b8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-21176 as u32), ctx.r[11].u64 ) };
	// 82B8A584: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8A588: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8A58C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8A590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A59C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A5A0 size=160
    let mut pc: u32 = 0x82B8A5A0;
    'dispatch: loop {
        match pc {
            0x82B8A5A0 => {
    //   block [0x82B8A5A0..0x82B8A640)
	// 82B8A5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A5A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A5AC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8A5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A5B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A5B8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A5BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A5C0: 48004179  bl 0x82b8e738
	ctx.lr = 0x82B8A5C4;
	sub_82B8E738(ctx, base);
	// 82B8A5C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A5C8: 41820060  beq 0x82b8a628
	if ctx.cr[0].eq {
	pc = 0x82B8A628; continue 'dispatch;
	}
	// 82B8A5CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A5D0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8A5D4: 409A0054  bne cr6, 0x82b8a628
	if !ctx.cr[6].eq {
	pc = 0x82B8A628; continue 'dispatch;
	}
	// 82B8A5D8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A5DC: 480040E5  bl 0x82b8e6c0
	ctx.lr = 0x82B8A5E0;
	sub_82B8E6C0(ctx, base);
	// 82B8A5E0: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A5E4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A5E8: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8A5EC: 480041C5  bl 0x82b8e7b0
	ctx.lr = 0x82B8A5F0;
	sub_82B8E7B0(ctx, base);
	// 82B8A5F0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82B8A5F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8A5F8: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A5FC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82B8A600: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8A604: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8A608: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82B8A60C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82B8A610: C04994AC  lfs f2, -0x6b54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82B8A614: 80680010  lwz r3, 0x10(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A618: 4BFF4CE9  bl 0x82b7f300
	ctx.lr = 0x82B8A61C;
	sub_82B7F300(ctx, base);
	// 82B8A61C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82B8A620: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82B8A624: F96AAD48  std r11, -0x52b8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-21176 as u32), ctx.r[11].u64 ) };
	// 82B8A628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A62C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A634: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A640 size=88
    let mut pc: u32 = 0x82B8A640;
    'dispatch: loop {
        match pc {
            0x82B8A640 => {
    //   block [0x82B8A640..0x82B8A698)
	// 82B8A640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A64C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A658: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A65C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A660: 396B86A4  addi r11, r11, -0x795c
	ctx.r[11].s64 = ctx.r[11].s64 + -31068;
	// 82B8A664: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A668: 4BFFDAD1  bl 0x82b88138
	ctx.lr = 0x82B8A66C;
	sub_82B88138(ctx, base);
	// 82B8A66C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A670: 4182000C  beq 0x82b8a67c
	if ctx.cr[0].eq {
	pc = 0x82B8A67C; continue 'dispatch;
	}
	// 82B8A674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A678: 48267D61  bl 0x82df23d8
	ctx.lr = 0x82B8A67C;
	sub_82DF23D8(ctx, base);
	// 82B8A67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A68C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A698 size=88
    let mut pc: u32 = 0x82B8A698;
    'dispatch: loop {
        match pc {
            0x82B8A698 => {
    //   block [0x82B8A698..0x82B8A6F0)
	// 82B8A698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A6A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A6B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8A6B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8A6B8: 396B86D0  addi r11, r11, -0x7930
	ctx.r[11].s64 = ctx.r[11].s64 + -31024;
	// 82B8A6BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8A6C0: 4BFFDA79  bl 0x82b88138
	ctx.lr = 0x82B8A6C4;
	sub_82B88138(ctx, base);
	// 82B8A6C4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A6C8: 4182000C  beq 0x82b8a6d4
	if ctx.cr[0].eq {
	pc = 0x82B8A6D4; continue 'dispatch;
	}
	// 82B8A6CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A6D0: 48267D09  bl 0x82df23d8
	ctx.lr = 0x82B8A6D4;
	sub_82DF23D8(ctx, base);
	// 82B8A6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8A6D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8A6DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A6E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A6E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A6E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A6EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8A6F0 size=116
    let mut pc: u32 = 0x82B8A6F0;
    'dispatch: loop {
        match pc {
            0x82B8A6F0 => {
    //   block [0x82B8A6F0..0x82B8A764)
	// 82B8A6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A6F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A6F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A6FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A704: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A708: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A70C: 4800402D  bl 0x82b8e738
	ctx.lr = 0x82B8A710;
	sub_82B8E738(ctx, base);
	// 82B8A710: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A714: 41820034  beq 0x82b8a748
	if ctx.cr[0].eq {
	pc = 0x82B8A748; continue 'dispatch;
	}
	// 82B8A718: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A71C: 480040A5  bl 0x82b8e7c0
	ctx.lr = 0x82B8A720;
	sub_82B8E7C0(ctx, base);
	// 82B8A720: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82B8A724: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8A728: 394AAD50  addi r10, r10, -0x52b0
	ctx.r[10].s64 = ctx.r[10].s64 + -21168;
	// 82B8A72C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82B8A730: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82B8A734: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8A738: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8A73C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8A740: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82B8A744: 4200FFF0  bdnz 0x82b8a734
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82B8A734; continue 'dispatch;
	}
	// 82B8A748: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8A74C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8A750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8A754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A768 size=300
    let mut pc: u32 = 0x82B8A768;
    'dispatch: loop {
        match pc {
            0x82B8A768 => {
    //   block [0x82B8A768..0x82B8A894)
	// 82B8A768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A770: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A774: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82B8A778: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8A77C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A784: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A788: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A78C: 48003FAD  bl 0x82b8e738
	ctx.lr = 0x82B8A790;
	sub_82B8E738(ctx, base);
	// 82B8A790: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A794: 418200E4  beq 0x82b8a878
	if ctx.cr[0].eq {
	pc = 0x82B8A878; continue 'dispatch;
	}
	// 82B8A798: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A79C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8A7A0: 409A00D8  bne cr6, 0x82b8a878
	if !ctx.cr[6].eq {
	pc = 0x82B8A878; continue 'dispatch;
	}
	// 82B8A7A4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A7A8: 48003F19  bl 0x82b8e6c0
	ctx.lr = 0x82B8A7AC;
	sub_82B8E6C0(ctx, base);
	// 82B8A7AC: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A7B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A7B4: EFC10028  fsubs f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8A7B8: 48004009  bl 0x82b8e7c0
	ctx.lr = 0x82B8A7BC;
	sub_82B8E7C0(ctx, base);
	// 82B8A7BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8A7C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82B8A7C4: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82B8A7C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82B8A7CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8A7D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8A7D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8A7D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82B8A7DC: 4200FFF0  bdnz 0x82b8a7cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82B8A7CC; continue 'dispatch;
	}
	// 82B8A7E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8A7E4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A7E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82B8A7EC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A7F0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82B8A7F4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8A7F8: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A7FC: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8A800: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A804: 4BFF4AFD  bl 0x82b7f300
	ctx.lr = 0x82B8A808;
	sub_82B7F300(ctx, base);
	// 82B8A808: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A80C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8A810: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8A814: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A818: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A81C: 4BFF4AE5  bl 0x82b7f300
	ctx.lr = 0x82B8A820;
	sub_82B7F300(ctx, base);
	// 82B8A820: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A824: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82B8A828: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A82C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A830: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8A834: 4BFF4ACD  bl 0x82b7f300
	ctx.lr = 0x82B8A838;
	sub_82B7F300(ctx, base);
	// 82B8A838: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8A83C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B8A840: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8A844: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8A848: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8A84C: 4BFF4AB5  bl 0x82b7f300
	ctx.lr = 0x82B8A850;
	sub_82B7F300(ctx, base);
	// 82B8A850: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82B8A854: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82B8A858: 394AAD50  addi r10, r10, -0x52b0
	ctx.r[10].s64 = ctx.r[10].s64 + -21168;
	// 82B8A85C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82B8A860: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82B8A864: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8A868: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8A86C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8A870: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82B8A874: 4200FFF0  bdnz 0x82b8a864
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82B8A864; continue 'dispatch;
	}
	// 82B8A878: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8A87C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A880: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A884: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8A888: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A898 size=260
    let mut pc: u32 = 0x82B8A898;
    'dispatch: loop {
        match pc {
            0x82B8A898 => {
    //   block [0x82B8A898..0x82B8A99C)
	// 82B8A898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8A8A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8A8A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8A8A8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82B8A8AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A8B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8A8B4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8A8B8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A8BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A8C0: 48003E79  bl 0x82b8e738
	ctx.lr = 0x82B8A8C4;
	sub_82B8E738(ctx, base);
	// 82B8A8C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A8C8: 418200B0  beq 0x82b8a978
	if ctx.cr[0].eq {
	pc = 0x82B8A978; continue 'dispatch;
	}
	// 82B8A8CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8A8D0: 4B9601B9  bl 0x824eaa88
	ctx.lr = 0x82B8A8D4;
	sub_824EAA88(ctx, base);
	// 82B8A8D4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82B8A8D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8A8DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8A8E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8A8E4: 4BFF92A5  bl 0x82b83b88
	ctx.lr = 0x82B8A8E8;
	sub_82B83B88(ctx, base);
	// 82B8A8E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8A8EC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82B8A8F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8A8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8A8F8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82B8A8FC: 419A0024  beq cr6, 0x82b8a920
	if ctx.cr[6].eq {
	pc = 0x82B8A920; continue 'dispatch;
	}
	// 82B8A900: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8A904: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8A908: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8A90C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8A910: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8A914: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8A918: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8A91C: 4082FFE8  bne 0x82b8a904
	if !ctx.cr[0].eq {
	pc = 0x82B8A904; continue 'dispatch;
	}
	// 82B8A920: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82B8A924: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82B8A928: 4B95EF49  bl 0x824e9870
	ctx.lr = 0x82B8A92C;
	sub_824E9870(ctx, base);
	// 82B8A92C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A930: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8A934: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8A938: 388A86F8  addi r4, r10, -0x7908
	ctx.r[4].s64 = ctx.r[10].s64 + -30984;
	// 82B8A93C: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 82B8A940: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82B8A944: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82B8A948: 482CC6A1  bl 0x82e56fe8
	ctx.lr = 0x82B8A94C;
	sub_82E56FE8(ctx, base);
	// 82B8A94C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8A950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A954: 419A0008  beq cr6, 0x82b8a95c
	if ctx.cr[6].eq {
	pc = 0x82B8A95C; continue 'dispatch;
	}
	// 82B8A958: 4B735F39  bl 0x822c0890
	ctx.lr = 0x82B8A95C;
	sub_822C0890(ctx, base);
	// 82B8A95C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82B8A960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8A964: 419A0008  beq cr6, 0x82b8a96c
	if ctx.cr[6].eq {
	pc = 0x82B8A96C; continue 'dispatch;
	}
	// 82B8A968: 4B735F29  bl 0x822c0890
	ctx.lr = 0x82B8A96C;
	sub_822C0890(ctx, base);
	// 82B8A96C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8A970: 48267321  bl 0x82df1c90
	ctx.lr = 0x82B8A974;
	sub_82DF1C90(ctx, base);
	// 82B8A974: D3FF0014  stfs f31, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82B8A978: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8A97C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8A980: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8A984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8A988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8A98C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8A990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8A994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8A998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8A9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8A9A0 size=424
    let mut pc: u32 = 0x82B8A9A0;
    'dispatch: loop {
        match pc {
            0x82B8A9A0 => {
    //   block [0x82B8A9A0..0x82B8AB48)
	// 82B8A9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8A9A4: 4861D7C5  bl 0x831a8168
	ctx.lr = 0x82B8A9A8;
	sub_831A8130(ctx, base);
	// 82B8A9A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8A9AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8A9B0: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8A9B4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8A9B8: 48003D81  bl 0x82b8e738
	ctx.lr = 0x82B8A9BC;
	sub_82B8E738(ctx, base);
	// 82B8A9BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8A9C0: 41820178  beq 0x82b8ab38
	if ctx.cr[0].eq {
	pc = 0x82B8AB38; continue 'dispatch;
	}
	// 82B8A9C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8A9C8: 4B9600C1  bl 0x824eaa88
	ctx.lr = 0x82B8A9CC;
	sub_824EAA88(ctx, base);
	// 82B8A9CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8A9D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8A9D4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82B8A9D8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82B8A9DC: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82B8A9E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82B8A9E4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82B8A9E8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8A9EC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B8A9F0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82B8A9F4: 38A99FA0  addi r5, r9, -0x6060
	ctx.r[5].s64 = ctx.r[9].s64 + -24672;
	// 82B8A9F8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82B8A9FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8AA00: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B8AA04: 4BFF91FD  bl 0x82b83c00
	ctx.lr = 0x82B8AA08;
	sub_82B83C00(ctx, base);
	// 82B8AA08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AA0C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82B8AA10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8AA18: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82B8AA1C: 419A0024  beq cr6, 0x82b8aa40
	if ctx.cr[6].eq {
	pc = 0x82B8AA40; continue 'dispatch;
	}
	// 82B8AA20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8AA24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8AA28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AA2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8AA30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8AA34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8AA38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AA3C: 4082FFE8  bne 0x82b8aa24
	if !ctx.cr[0].eq {
	pc = 0x82B8AA24; continue 'dispatch;
	}
	// 82B8AA40: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82B8AA44: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82B8AA48: 4B95EE29  bl 0x824e9870
	ctx.lr = 0x82B8AA4C;
	sub_824E9870(ctx, base);
	// 82B8AA4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8AA50: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AA54: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8AA58: 3BEB86F8  addi r31, r11, -0x7908
	ctx.r[31].s64 = ctx.r[11].s64 + -30984;
	// 82B8AA5C: 38A001A0  li r5, 0x1a0
	ctx.r[5].s64 = 416;
	// 82B8AA60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8AA64: 386A0028  addi r3, r10, 0x28
	ctx.r[3].s64 = ctx.r[10].s64 + 40;
	// 82B8AA68: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82B8AA6C: 482CC57D  bl 0x82e56fe8
	ctx.lr = 0x82B8AA70;
	sub_82E56FE8(ctx, base);
	// 82B8AA70: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8AA74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AA78: 419A0008  beq cr6, 0x82b8aa80
	if ctx.cr[6].eq {
	pc = 0x82B8AA80; continue 'dispatch;
	}
	// 82B8AA7C: 4B735E15  bl 0x822c0890
	ctx.lr = 0x82B8AA80;
	sub_822C0890(ctx, base);
	// 82B8AA80: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8AA84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AA88: 419A0008  beq cr6, 0x82b8aa90
	if ctx.cr[6].eq {
	pc = 0x82B8AA90; continue 'dispatch;
	}
	// 82B8AA8C: 4B735E05  bl 0x822c0890
	ctx.lr = 0x82B8AA90;
	sub_822C0890(ctx, base);
	// 82B8AA90: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8AA94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AA98: 419A0008  beq cr6, 0x82b8aaa0
	if ctx.cr[6].eq {
	pc = 0x82B8AAA0; continue 'dispatch;
	}
	// 82B8AA9C: 4B735DF5  bl 0x822c0890
	ctx.lr = 0x82B8AAA0;
	sub_822C0890(ctx, base);
	// 82B8AAA0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82B8AAA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8AAA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8AAAC: 4BFF91E5  bl 0x82b83c90
	ctx.lr = 0x82B8AAB0;
	sub_82B83C90(ctx, base);
	// 82B8AAB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AAB4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82B8AAB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8AAC0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82B8AAC4: 419A0024  beq cr6, 0x82b8aae8
	if ctx.cr[6].eq {
	pc = 0x82B8AAE8; continue 'dispatch;
	}
	// 82B8AAC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8AACC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8AAD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AAD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8AAD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8AADC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8AAE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AAE4: 4082FFE8  bne 0x82b8aacc
	if !ctx.cr[0].eq {
	pc = 0x82B8AACC; continue 'dispatch;
	}
	// 82B8AAE8: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82B8AAEC: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82B8AAF0: 4B95ED81  bl 0x824e9870
	ctx.lr = 0x82B8AAF4;
	sub_824E9870(ctx, base);
	// 82B8AAF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AAF8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8AAFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8AB00: 38A001A1  li r5, 0x1a1
	ctx.r[5].s64 = 417;
	// 82B8AB04: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82B8AB08: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82B8AB0C: 482CC4DD  bl 0x82e56fe8
	ctx.lr = 0x82B8AB10;
	sub_82E56FE8(ctx, base);
	// 82B8AB10: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82B8AB14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AB18: 419A0008  beq cr6, 0x82b8ab20
	if ctx.cr[6].eq {
	pc = 0x82B8AB20; continue 'dispatch;
	}
	// 82B8AB1C: 4B735D75  bl 0x822c0890
	ctx.lr = 0x82B8AB20;
	sub_822C0890(ctx, base);
	// 82B8AB20: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82B8AB24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AB28: 419A0008  beq cr6, 0x82b8ab30
	if ctx.cr[6].eq {
	pc = 0x82B8AB30; continue 'dispatch;
	}
	// 82B8AB2C: 4B735D65  bl 0x822c0890
	ctx.lr = 0x82B8AB30;
	sub_822C0890(ctx, base);
	// 82B8AB30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8AB34: 4826715D  bl 0x82df1c90
	ctx.lr = 0x82B8AB38;
	sub_82DF1C90(ctx, base);
	// 82B8AB38: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8AB3C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8AB40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B8AB44: 4861D674  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8AB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8AB48 size=644
    let mut pc: u32 = 0x82B8AB48;
    'dispatch: loop {
        match pc {
            0x82B8AB48 => {
    //   block [0x82B8AB48..0x82B8ADCC)
	// 82B8AB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8AB4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8AB50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8AB54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8AB58: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82B8AB5C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82B8AB60: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82B8AB64: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8AB68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8AB6C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8AB70: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AB74: 48003BC5  bl 0x82b8e738
	ctx.lr = 0x82B8AB78;
	sub_82B8E738(ctx, base);
	// 82B8AB78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8AB7C: 4182022C  beq 0x82b8ada8
	if ctx.cr[0].eq {
	pc = 0x82B8ADA8; continue 'dispatch;
	}
	// 82B8AB80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AB84: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8AB88: 409A0220  bne cr6, 0x82b8ada8
	if !ctx.cr[6].eq {
	pc = 0x82B8ADA8; continue 'dispatch;
	}
	// 82B8AB8C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AB90: 48003B31  bl 0x82b8e6c0
	ctx.lr = 0x82B8AB94;
	sub_82B8E6C0(ctx, base);
	// 82B8AB94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8AB98: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8AB9C: EFA10028  fsubs f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8ABA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82B8ABA4: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8ABA8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8ABAC: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82B8ABB0: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82B8ABB4: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82B8ABB8: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82B8ABBC: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82B8ABC0: 80690010  lwz r3, 0x10(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8ABC4: C3EA94AC  lfs f31, -0x6b54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27476 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8ABC8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8ABCC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82B8ABD0: 4BFF4731  bl 0x82b7f300
	ctx.lr = 0x82B8ABD4;
	sub_82B7F300(ctx, base);
	// 82B8ABD4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8ABD8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8ABDC: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8ABE0: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82B8ABE4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8ABE8: 4BFF4719  bl 0x82b7f300
	ctx.lr = 0x82B8ABEC;
	sub_82B7F300(ctx, base);
	// 82B8ABEC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8ABF0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82B8ABF4: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82B8ABF8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8ABFC: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8AC00: 4BFF4701  bl 0x82b7f300
	ctx.lr = 0x82B8AC04;
	sub_82B7F300(ctx, base);
	// 82B8AC04: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8AC08: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B8AC0C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8AC10: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82B8AC14: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8AC18: 4BFF46E9  bl 0x82b7f300
	ctx.lr = 0x82B8AC1C;
	sub_82B7F300(ctx, base);
	// 82B8AC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8AC20: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8AC24: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82B8AC28: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82B8AC2C: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8AC30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82B8AC34: 4099000C  ble cr6, 0x82b8ac40
	if !ctx.cr[6].gt {
	pc = 0x82B8AC40; continue 'dispatch;
	}
	// 82B8AC38: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82B8AC3C: 48000014  b 0x82b8ac50
	pc = 0x82B8AC50; continue 'dispatch;
	// 82B8AC40: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82B8AC44: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82B8AC48: 40980008  bge cr6, 0x82b8ac50
	if !ctx.cr[6].lt {
	pc = 0x82B8AC50; continue 'dispatch;
	}
	// 82B8AC4C: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	// 82B8AC50: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8AC54: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8AC58: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82B8AC5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82B8AC60: C16BC3C8  lfs f11, -0x3c38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15416 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82B8AC64: C14A9450  lfs f10, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82B8AC68: ED8C52FA  fmadds f12, f12, f11, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82B8AC6C: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82B8AC70: D9810068  stfd f12, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[12].u64 ) };
	// 82B8AC74: 8961006F  lbz r11, 0x6f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82B8AC78: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82B8AC7C: 4099000C  ble cr6, 0x82b8ac88
	if !ctx.cr[6].gt {
	pc = 0x82B8AC88; continue 'dispatch;
	}
	// 82B8AC80: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82B8AC84: 48000010  b 0x82b8ac94
	pc = 0x82B8AC94; continue 'dispatch;
	// 82B8AC88: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82B8AC8C: 40980008  bge cr6, 0x82b8ac94
	if !ctx.cr[6].lt {
	pc = 0x82B8AC94; continue 'dispatch;
	}
	// 82B8AC90: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82B8AC94: ED8052FA  fmadds f12, f0, f11, f10
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82B8AC98: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8AC9C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82B8ACA0: FD80665E  fctidz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82B8ACA4: D9810068  stfd f12, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[12].u64 ) };
	// 82B8ACA8: 8961006F  lbz r11, 0x6f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82B8ACAC: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82B8ACB0: 41990010  bgt cr6, 0x82b8acc0
	if ctx.cr[6].gt {
	pc = 0x82B8ACC0; continue 'dispatch;
	}
	// 82B8ACB4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82B8ACB8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82B8ACBC: 41980008  blt cr6, 0x82b8acc4
	if ctx.cr[6].lt {
	pc = 0x82B8ACC4; continue 'dispatch;
	}
	// 82B8ACC0: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 82B8ACC4: EC1E52FA  fmadds f0, f30, f11, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82B8ACC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8ACCC: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82B8ACD0: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 82B8ACD4: 8961006F  lbz r11, 0x6f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82B8ACD8: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82B8ACDC: 4B95FDAD  bl 0x824eaa88
	ctx.lr = 0x82B8ACE0;
	sub_824EAA88(ctx, base);
	// 82B8ACE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8ACE4: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82B8ACE8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82B8ACEC: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82B8ACF0: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82B8ACF4: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 82B8ACF8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82B8ACFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8AD00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B8AD04: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82B8AD08: 4BFF8EF9  bl 0x82b83c00
	ctx.lr = 0x82B8AD0C;
	sub_82B83C00(ctx, base);
	// 82B8AD0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AD10: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B8AD14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8AD1C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82B8AD20: 419A0024  beq cr6, 0x82b8ad44
	if ctx.cr[6].eq {
	pc = 0x82B8AD44; continue 'dispatch;
	}
	// 82B8AD24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8AD28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8AD2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AD30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8AD34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8AD38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8AD3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AD40: 4082FFE8  bne 0x82b8ad28
	if !ctx.cr[0].eq {
	pc = 0x82B8AD28; continue 'dispatch;
	}
	// 82B8AD44: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B8AD48: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82B8AD4C: 4B95EB25  bl 0x824e9870
	ctx.lr = 0x82B8AD50;
	sub_824E9870(ctx, base);
	// 82B8AD50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AD54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8AD58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8AD5C: 388A86F8  addi r4, r10, -0x7908
	ctx.r[4].s64 = ctx.r[10].s64 + -30984;
	// 82B8AD60: 38A001BD  li r5, 0x1bd
	ctx.r[5].s64 = 445;
	// 82B8AD64: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82B8AD68: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82B8AD6C: 482CC27D  bl 0x82e56fe8
	ctx.lr = 0x82B8AD70;
	sub_82E56FE8(ctx, base);
	// 82B8AD70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8AD74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AD78: 419A0008  beq cr6, 0x82b8ad80
	if ctx.cr[6].eq {
	pc = 0x82B8AD80; continue 'dispatch;
	}
	// 82B8AD7C: 4B735B15  bl 0x822c0890
	ctx.lr = 0x82B8AD80;
	sub_822C0890(ctx, base);
	// 82B8AD80: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82B8AD84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AD88: 419A0008  beq cr6, 0x82b8ad90
	if ctx.cr[6].eq {
	pc = 0x82B8AD90; continue 'dispatch;
	}
	// 82B8AD8C: 4B735B05  bl 0x822c0890
	ctx.lr = 0x82B8AD90;
	sub_822C0890(ctx, base);
	// 82B8AD90: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8AD94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AD98: 419A0008  beq cr6, 0x82b8ada0
	if ctx.cr[6].eq {
	pc = 0x82B8ADA0; continue 'dispatch;
	}
	// 82B8AD9C: 4B735AF5  bl 0x822c0890
	ctx.lr = 0x82B8ADA0;
	sub_822C0890(ctx, base);
	// 82B8ADA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8ADA4: 48266EED  bl 0x82df1c90
	ctx.lr = 0x82B8ADA8;
	sub_82DF1C90(ctx, base);
	// 82B8ADA8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82B8ADAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8ADB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8ADB4: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82B8ADB8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82B8ADBC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8ADC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8ADC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8ADC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8ADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8ADD0 size=60
    let mut pc: u32 = 0x82B8ADD0;
    'dispatch: loop {
        match pc {
            0x82B8ADD0 => {
    //   block [0x82B8ADD0..0x82B8AE0C)
	// 82B8ADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8ADD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8ADD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8ADDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8ADE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8ADE4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8ADE8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8ADEC: 4800394D  bl 0x82b8e738
	ctx.lr = 0x82B8ADF0;
	sub_82B8E738(ctx, base);
	// 82B8ADF0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8ADF4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8ADF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8ADFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8AE00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8AE04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8AE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8AE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8AE10 size=96
    let mut pc: u32 = 0x82B8AE10;
    'dispatch: loop {
        match pc {
            0x82B8AE10 => {
    //   block [0x82B8AE10..0x82B8AE70)
	// 82B8AE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8AE14: 4861D359  bl 0x831a816c
	ctx.lr = 0x82B8AE18;
	sub_831A8130(ctx, base);
	// 82B8AE18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8AE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8AE20: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8AE24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AE28: 48003911  bl 0x82b8e738
	ctx.lr = 0x82B8AE2C;
	sub_82B8E738(ctx, base);
	// 82B8AE2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8AE30: 41820038  beq 0x82b8ae68
	if ctx.cr[0].eq {
	pc = 0x82B8AE68; continue 'dispatch;
	}
	// 82B8AE34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AE38: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8AE3C: 409A002C  bne cr6, 0x82b8ae68
	if !ctx.cr[6].eq {
	pc = 0x82B8AE68; continue 'dispatch;
	}
	// 82B8AE40: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8AE44: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82B8AE48: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AE4C: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8AE50: 48003871  bl 0x82b8e6c0
	ctx.lr = 0x82B8AE54;
	sub_82B8E6C0(ctx, base);
	// 82B8AE54: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8AE58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8AE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8AE60: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8AE64: 482B3B85  bl 0x82e3e9e8
	ctx.lr = 0x82B8AE68;
	sub_82E3E9E8(ctx, base);
	// 82B8AE68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8AE6C: 4861D350  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8AE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8AE70 size=80
    let mut pc: u32 = 0x82B8AE70;
    'dispatch: loop {
        match pc {
            0x82B8AE70 => {
    //   block [0x82B8AE70..0x82B8AEC0)
	// 82B8AE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8AE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8AE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8AE7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8AE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8AE84: 4BFFD28D  bl 0x82b88110
	ctx.lr = 0x82B8AE88;
	sub_82B88110(ctx, base);
	// 82B8AE88: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8AE8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8AE90: 394A874C  addi r10, r10, -0x78b4
	ctx.r[10].s64 = ctx.r[10].s64 + -30900;
	// 82B8AE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8AE98: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8AE9C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8AEA0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8AEA4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82B8AEA8: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82B8AEAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8AEB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8AEB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8AEB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8AEBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8AEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8AEC0 size=108
    let mut pc: u32 = 0x82B8AEC0;
    'dispatch: loop {
        match pc {
            0x82B8AEC0 => {
    //   block [0x82B8AEC0..0x82B8AF2C)
	// 82B8AEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8AEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8AEC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8AECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8AED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8AED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8AED8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8AEDC: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82B8AEE0: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82B8AEE4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8AEE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AEEC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82B8AEF0: 419A0008  beq cr6, 0x82b8aef8
	if ctx.cr[6].eq {
	pc = 0x82B8AEF8; continue 'dispatch;
	}
	// 82B8AEF4: 4B73599D  bl 0x822c0890
	ctx.lr = 0x82B8AEF8;
	sub_822C0890(ctx, base);
	// 82B8AEF8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82B8AEFC: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82B8AF00: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8AF04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AF08: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82B8AF0C: 419A0008  beq cr6, 0x82b8af14
	if ctx.cr[6].eq {
	pc = 0x82B8AF14; continue 'dispatch;
	}
	// 82B8AF10: 4B735981  bl 0x822c0890
	ctx.lr = 0x82B8AF14;
	sub_822C0890(ctx, base);
	// 82B8AF14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8AF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8AF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8AF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8AF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8AF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8AF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8AF30 size=212
    let mut pc: u32 = 0x82B8AF30;
    'dispatch: loop {
        match pc {
            0x82B8AF30 => {
    //   block [0x82B8AF30..0x82B8B004)
	// 82B8AF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8AF34: 4861D239  bl 0x831a816c
	ctx.lr = 0x82B8AF38;
	sub_831A8130(ctx, base);
	// 82B8AF38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8AF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8AF40: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8AF44: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8AF48: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8AF4C: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8AF50: 48003699  bl 0x82b8e5e8
	ctx.lr = 0x82B8AF54;
	sub_82B8E5E8(ctx, base);
	// 82B8AF54: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8AF58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AF5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8AF60: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82B8AF64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8AF68: 419A0024  beq cr6, 0x82b8af8c
	if ctx.cr[6].eq {
	pc = 0x82B8AF8C; continue 'dispatch;
	}
	// 82B8AF6C: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 82B8AF70: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82B8AF74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AF78: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82B8AF7C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82B8AF80: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8AF84: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8AF88: 4082FFE8  bne 0x82b8af70
	if !ctx.cr[0].eq {
	pc = 0x82B8AF70; continue 'dispatch;
	}
	// 82B8AF8C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8AF90: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82B8AF94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8AF98: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B8AF9C: 4B7394C5  bl 0x822c4460
	ctx.lr = 0x82B8AFA0;
	sub_822C4460(ctx, base);
	// 82B8AFA0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8AFA4: 419A000C  beq cr6, 0x82b8afb0
	if ctx.cr[6].eq {
	pc = 0x82B8AFB0; continue 'dispatch;
	}
	// 82B8AFA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8AFAC: 4B7358E5  bl 0x822c0890
	ctx.lr = 0x82B8AFB0;
	sub_822C0890(ctx, base);
	// 82B8AFB0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8AFB4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8AFB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8AFBC: 419A0040  beq cr6, 0x82b8affc
	if ctx.cr[6].eq {
	pc = 0x82B8AFFC; continue 'dispatch;
	}
	// 82B8AFC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8AFC4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AFC8: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82B8AFCC: 480015E5  bl 0x82b8c5b0
	ctx.lr = 0x82B8AFD0;
	sub_82B8C5B0(ctx, base);
	// 82B8AFD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8AFD4: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 82B8AFD8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B8AFDC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82B8AFE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8AFE4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82B8AFE8: 4B739479  bl 0x822c4460
	ctx.lr = 0x82B8AFEC;
	sub_822C4460(ctx, base);
	// 82B8AFEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8AFF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8AFF4: 419A0008  beq cr6, 0x82b8affc
	if ctx.cr[6].eq {
	pc = 0x82B8AFFC; continue 'dispatch;
	}
	// 82B8AFF8: 4B735899  bl 0x822c0890
	ctx.lr = 0x82B8AFFC;
	sub_822C0890(ctx, base);
	// 82B8AFFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8B000: 4861D1BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B008 size=76
    let mut pc: u32 = 0x82B8B008;
    'dispatch: loop {
        match pc {
            0x82B8B008 => {
    //   block [0x82B8B008..0x82B8B054)
	// 82B8B008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B01C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8B024: 4829E425  bl 0x82e29448
	ctx.lr = 0x82B8B028;
	sub_82E29448(ctx, base);
	// 82B8B028: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8B02C: 4182000C  beq 0x82b8b038
	if ctx.cr[0].eq {
	pc = 0x82B8B038; continue 'dispatch;
	}
	// 82B8B030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B034: 482673A5  bl 0x82df23d8
	ctx.lr = 0x82B8B038;
	sub_82DF23D8(ctx, base);
	// 82B8B038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B03C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B048: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B04C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B058 size=112
    let mut pc: u32 = 0x82B8B058;
    'dispatch: loop {
        match pc {
            0x82B8B058 => {
    //   block [0x82B8B058..0x82B8B0C8)
	// 82B8B058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B05C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B064: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8B068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B06C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B070: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8B074: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8B078: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8B07C: 480036BD  bl 0x82b8e738
	ctx.lr = 0x82B8B080;
	sub_82B8E738(ctx, base);
	// 82B8B080: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8B084: 4182002C  beq 0x82b8b0b0
	if ctx.cr[0].eq {
	pc = 0x82B8B0B0; continue 'dispatch;
	}
	// 82B8B088: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8B08C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8B090: 409A0020  bne cr6, 0x82b8b0b0
	if !ctx.cr[6].eq {
	pc = 0x82B8B0B0; continue 'dispatch;
	}
	// 82B8B094: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8B098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B09C: 419A0014  beq cr6, 0x82b8b0b0
	if ctx.cr[6].eq {
	pc = 0x82B8B0B0; continue 'dispatch;
	}
	// 82B8B0A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8B0A4: 48037AA5  bl 0x82bc2b48
	ctx.lr = 0x82B8B0A8;
	sub_82BC2B48(ctx, base);
	// 82B8B0A8: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8B0AC: 480375B5  bl 0x82bc2660
	ctx.lr = 0x82B8B0B0;
	sub_82BC2660(ctx, base);
	// 82B8B0B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B0BC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B0C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8B0C8 size=12
    let mut pc: u32 = 0x82B8B0C8;
    'dispatch: loop {
        match pc {
            0x82B8B0C8 => {
    //   block [0x82B8B0C8..0x82B8B0D4)
	// 82B8B0C8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B0CC: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82B8B0D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B0D8 size=172
    let mut pc: u32 = 0x82B8B0D8;
    'dispatch: loop {
        match pc {
            0x82B8B0D8 => {
    //   block [0x82B8B0D8..0x82B8B184)
	// 82B8B0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B0E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B0EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8B0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B0F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8B0F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8B0FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B100: 4B735839  bl 0x822c0938
	ctx.lr = 0x82B8B104;
	sub_822C0938(ctx, base);
	// 82B8B104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B108: 41820028  beq 0x82b8b130
	if ctx.cr[0].eq {
	pc = 0x82B8B130; continue 'dispatch;
	}
	// 82B8B10C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8B110: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8B114: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8B118: 392B8784  addi r9, r11, -0x787c
	ctx.r[9].s64 = ctx.r[11].s64 + -30844;
	// 82B8B11C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B120: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8B124: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8B128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8B12C: 48000008  b 0x82b8b134
	pc = 0x82B8B134; continue 'dispatch;
	// 82B8B130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B134: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B13C: 409A002C  bne cr6, 0x82b8b168
	if !ctx.cr[6].eq {
	pc = 0x82B8B168; continue 'dispatch;
	}
	// 82B8B140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B144: 4B735125  bl 0x822c0268
	ctx.lr = 0x82B8B148;
	sub_822C0268(ctx, base);
	// 82B8B148: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B14C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8B150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8B154: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8B158: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B15C: 816BADA4  lwz r11, -0x525c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21084 as u32) ) } as u64;
	// 82B8B160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B164: 4B734E9D  bl 0x822c0000
	ctx.lr = 0x82B8B168;
	sub_822C0000(ctx, base);
	// 82B8B168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8B16C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B17C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B188 size=196
    let mut pc: u32 = 0x82B8B188;
    'dispatch: loop {
        match pc {
            0x82B8B188 => {
    //   block [0x82B8B188..0x82B8B24C)
	// 82B8B188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B19C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8B1A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B1A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8B1A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8B1AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B1B0: 4B735789  bl 0x822c0938
	ctx.lr = 0x82B8B1B4;
	sub_822C0938(ctx, base);
	// 82B8B1B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B1B8: 41820028  beq 0x82b8b1e0
	if ctx.cr[0].eq {
	pc = 0x82B8B1E0; continue 'dispatch;
	}
	// 82B8B1BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8B1C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8B1C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8B1C8: 392B8798  addi r9, r11, -0x7868
	ctx.r[9].s64 = ctx.r[11].s64 + -30824;
	// 82B8B1CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B1D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8B1D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8B1D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8B1DC: 48000008  b 0x82b8b1e4
	pc = 0x82B8B1E4; continue 'dispatch;
	// 82B8B1E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B1E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B1EC: 409A0044  bne cr6, 0x82b8b230
	if !ctx.cr[6].eq {
	pc = 0x82B8B230; continue 'dispatch;
	}
	// 82B8B1F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8B1F4: 419A001C  beq cr6, 0x82b8b210
	if ctx.cr[6].eq {
	pc = 0x82B8B210; continue 'dispatch;
	}
	// 82B8B1F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B1FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8B200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B204: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8B20C: 4E800421  bctrl
	ctx.lr = 0x82B8B210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8B210: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B214: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8B218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8B21C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8B220: 816BADA4  lwz r11, -0x525c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21084 as u32) ) } as u64;
	// 82B8B224: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B228: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B22C: 4B734DD5  bl 0x822c0000
	ctx.lr = 0x82B8B230;
	sub_822C0000(ctx, base);
	// 82B8B230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8B234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B240: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B250 size=196
    let mut pc: u32 = 0x82B8B250;
    'dispatch: loop {
        match pc {
            0x82B8B250 => {
    //   block [0x82B8B250..0x82B8B314)
	// 82B8B250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B25C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8B268: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B26C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8B270: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8B274: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B278: 4B7356C1  bl 0x822c0938
	ctx.lr = 0x82B8B27C;
	sub_822C0938(ctx, base);
	// 82B8B27C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B280: 41820028  beq 0x82b8b2a8
	if ctx.cr[0].eq {
	pc = 0x82B8B2A8; continue 'dispatch;
	}
	// 82B8B284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8B288: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8B28C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8B290: 392B87AC  addi r9, r11, -0x7854
	ctx.r[9].s64 = ctx.r[11].s64 + -30804;
	// 82B8B294: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8B29C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8B2A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8B2A4: 48000008  b 0x82b8b2ac
	pc = 0x82B8B2AC; continue 'dispatch;
	// 82B8B2A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B2AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B2B4: 409A0044  bne cr6, 0x82b8b2f8
	if !ctx.cr[6].eq {
	pc = 0x82B8B2F8; continue 'dispatch;
	}
	// 82B8B2B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8B2BC: 419A001C  beq cr6, 0x82b8b2d8
	if ctx.cr[6].eq {
	pc = 0x82B8B2D8; continue 'dispatch;
	}
	// 82B8B2C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B2C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8B2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B2CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8B2D4: 4E800421  bctrl
	ctx.lr = 0x82B8B2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8B2D8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B2DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8B2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8B2E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8B2E8: 816BADA4  lwz r11, -0x525c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21084 as u32) ) } as u64;
	// 82B8B2EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B2F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B2F4: 4B734D0D  bl 0x822c0000
	ctx.lr = 0x82B8B2F8;
	sub_822C0000(ctx, base);
	// 82B8B2F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8B2FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B30C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B318 size=196
    let mut pc: u32 = 0x82B8B318;
    'dispatch: loop {
        match pc {
            0x82B8B318 => {
    //   block [0x82B8B318..0x82B8B3DC)
	// 82B8B318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B31C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B32C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8B330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B334: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8B338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8B33C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B340: 4B7355F9  bl 0x822c0938
	ctx.lr = 0x82B8B344;
	sub_822C0938(ctx, base);
	// 82B8B344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B348: 41820028  beq 0x82b8b370
	if ctx.cr[0].eq {
	pc = 0x82B8B370; continue 'dispatch;
	}
	// 82B8B34C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8B350: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8B354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8B358: 392B87C0  addi r9, r11, -0x7840
	ctx.r[9].s64 = ctx.r[11].s64 + -30784;
	// 82B8B35C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8B364: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8B368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8B36C: 48000008  b 0x82b8b374
	pc = 0x82B8B374; continue 'dispatch;
	// 82B8B370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B374: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B37C: 409A0044  bne cr6, 0x82b8b3c0
	if !ctx.cr[6].eq {
	pc = 0x82B8B3C0; continue 'dispatch;
	}
	// 82B8B380: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8B384: 419A001C  beq cr6, 0x82b8b3a0
	if ctx.cr[6].eq {
	pc = 0x82B8B3A0; continue 'dispatch;
	}
	// 82B8B388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B38C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8B390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B394: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8B39C: 4E800421  bctrl
	ctx.lr = 0x82B8B3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8B3A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B3A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8B3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8B3AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8B3B0: 816BADA4  lwz r11, -0x525c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21084 as u32) ) } as u64;
	// 82B8B3B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B3B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B3BC: 4B734C45  bl 0x822c0000
	ctx.lr = 0x82B8B3C0;
	sub_822C0000(ctx, base);
	// 82B8B3C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8B3C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B3D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B3E0 size=196
    let mut pc: u32 = 0x82B8B3E0;
    'dispatch: loop {
        match pc {
            0x82B8B3E0 => {
    //   block [0x82B8B3E0..0x82B8B4A4)
	// 82B8B3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B3F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8B3F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B3FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8B400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8B404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B408: 4B735531  bl 0x822c0938
	ctx.lr = 0x82B8B40C;
	sub_822C0938(ctx, base);
	// 82B8B40C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B410: 41820028  beq 0x82b8b438
	if ctx.cr[0].eq {
	pc = 0x82B8B438; continue 'dispatch;
	}
	// 82B8B414: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8B418: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8B41C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8B420: 392B87D4  addi r9, r11, -0x782c
	ctx.r[9].s64 = ctx.r[11].s64 + -30764;
	// 82B8B424: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8B42C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8B430: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8B434: 48000008  b 0x82b8b43c
	pc = 0x82B8B43C; continue 'dispatch;
	// 82B8B438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8B43C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B444: 409A0044  bne cr6, 0x82b8b488
	if !ctx.cr[6].eq {
	pc = 0x82B8B488; continue 'dispatch;
	}
	// 82B8B448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8B44C: 419A001C  beq cr6, 0x82b8b468
	if ctx.cr[6].eq {
	pc = 0x82B8B468; continue 'dispatch;
	}
	// 82B8B450: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8B458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8B460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8B464: 4E800421  bctrl
	ctx.lr = 0x82B8B468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8B468: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B46C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8B470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8B474: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8B478: 816BADA4  lwz r11, -0x525c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21084 as u32) ) } as u64;
	// 82B8B47C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B480: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B484: 4B734B7D  bl 0x822c0000
	ctx.lr = 0x82B8B488;
	sub_822C0000(ctx, base);
	// 82B8B488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8B48C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8B4A8 size=480
    let mut pc: u32 = 0x82B8B4A8;
    'dispatch: loop {
        match pc {
            0x82B8B4A8 => {
    //   block [0x82B8B4A8..0x82B8B688)
	// 82B8B4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B4B8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82B8B4BC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82B8B4C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B4C8: 4B985241  bl 0x82510708
	ctx.lr = 0x82B8B4CC;
	sub_82510708(ctx, base);
	// 82B8B4CC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8B4D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B4D4: 419A0194  beq cr6, 0x82b8b668
	if ctx.cr[6].eq {
	pc = 0x82B8B668; continue 'dispatch;
	}
	// 82B8B4D8: 48029341  bl 0x82bb4818
	ctx.lr = 0x82B8B4DC;
	sub_82BB4818(ctx, base);
	// 82B8B4DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8B4E0: 41820188  beq 0x82b8b668
	if ctx.cr[0].eq {
	pc = 0x82B8B668; continue 'dispatch;
	}
	// 82B8B4E4: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8B4E8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8B4EC: 480031D5  bl 0x82b8e6c0
	ctx.lr = 0x82B8B4F0;
	sub_82B8E6C0(ctx, base);
	// 82B8B4F0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8B4F4: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8B4F8: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8B4FC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8B500: EFDF0028  fsubs f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8B504: 480031CD  bl 0x82b8e6d0
	ctx.lr = 0x82B8B508;
	sub_82B8E6D0(ctx, base);
	// 82B8B508: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8B50C: EC3E0824  fdivs f1, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ((ctx.f[30].f64 / ctx.f[1].f64) as f32) as f64;
	// 82B8B510: 48029FE1  bl 0x82bb54f0
	ctx.lr = 0x82B8B514;
	sub_82BB54F0(ctx, base);
	// 82B8B514: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82B8B518: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82B8B51C: D3FF010C  stfs f31, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82B8B520: 396B4BC0  addi r11, r11, 0x4bc0
	ctx.r[11].s64 = ctx.r[11].s64 + 19392;
	// 82B8B524: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B688 size=56
    let mut pc: u32 = 0x82B8B688;
    'dispatch: loop {
        match pc {
            0x82B8B688 => {
    //   block [0x82B8B688..0x82B8B6C0)
	// 82B8B688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B694: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B698: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B69C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B6A0: 808B00E4  lwz r4, 0xe4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 82B8B6A4: 4828998D  bl 0x82e15030
	ctx.lr = 0x82B8B6A8;
	sub_82E15030(ctx, base);
	// 82B8B6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8B6AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8B6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B6C0 size=68
    let mut pc: u32 = 0x82B8B6C0;
    'dispatch: loop {
        match pc {
            0x82B8B6C0 => {
    //   block [0x82B8B6C0..0x82B8B704)
	// 82B8B6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B6C4: 4861CAA9  bl 0x831a816c
	ctx.lr = 0x82B8B6C8;
	sub_831A8130(ctx, base);
	// 82B8B6C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B6CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B6D0: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 82B8B6D4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B6D8: 4B984EF9  bl 0x825105d0
	ctx.lr = 0x82B8B6DC;
	sub_825105D0(ctx, base);
	// 82B8B6DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8B6E0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82B8B6E4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8B6E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B6EC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82B8B6F0: 419A0008  beq cr6, 0x82b8b6f8
	if ctx.cr[6].eq {
	pc = 0x82B8B6F8; continue 'dispatch;
	}
	// 82B8B6F4: 4B73519D  bl 0x822c0890
	ctx.lr = 0x82B8B6F8;
	sub_822C0890(ctx, base);
	// 82B8B6F8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82B8B6FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B700: 4861CABC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B708 size=308
    let mut pc: u32 = 0x82B8B708;
    'dispatch: loop {
        match pc {
            0x82B8B708 => {
    //   block [0x82B8B708..0x82B8B83C)
	// 82B8B708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B720: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8B724: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8B728: 48003011  bl 0x82b8e738
	ctx.lr = 0x82B8B72C;
	sub_82B8E738(ctx, base);
	// 82B8B72C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8B730: 418200EC  beq 0x82b8b81c
	if ctx.cr[0].eq {
	pc = 0x82B8B81C; continue 'dispatch;
	}
	// 82B8B734: 897F0028  lbz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8B738: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B73C: 408200E0  bne 0x82b8b81c
	if !ctx.cr[0].eq {
	pc = 0x82B8B81C; continue 'dispatch;
	}
	// 82B8B740: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8B744: 895F002D  lbz r10, 0x2d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82B8B748: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82B8B74C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B750: 83CB7058  lwz r30, 0x7058(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82B8B754: 4182001C  beq 0x82b8b770
	if ctx.cr[0].eq {
	pc = 0x82B8B770; continue 'dispatch;
	}
	// 82B8B758: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8B75C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82B8B760: 390B9D84  addi r8, r11, -0x627c
	ctx.r[8].s64 = ctx.r[11].s64 + -25212;
	// 82B8B764: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82B8B768: 83CA706C  lwz r30, 0x706c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28780 as u32) ) } as u64;
	// 82B8B76C: 99680004  stb r11, 4(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82B8B770: 897F002A  lbz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 82B8B774: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B778: 40820028  bne 0x82b8b7a0
	if !ctx.cr[0].eq {
	pc = 0x82B8B7A0; continue 'dispatch;
	}
	// 82B8B77C: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 82B8B780: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B784: 4082001C  bne 0x82b8b7a0
	if !ctx.cr[0].eq {
	pc = 0x82B8B7A0; continue 'dispatch;
	}
	// 82B8B788: 897F002B  lbz r11, 0x2b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(43 as u32) ) } as u64;
	// 82B8B78C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B790: 40820010  bne 0x82b8b7a0
	if !ctx.cr[0].eq {
	pc = 0x82B8B7A0; continue 'dispatch;
	}
	// 82B8B794: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82B8B798: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8B79C: 41820020  beq 0x82b8b7bc
	if ctx.cr[0].eq {
	pc = 0x82B8B7BC; continue 'dispatch;
	}
	// 82B8B7A0: 913F0034  stw r9, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82B8B7A4: 397F0034  addi r11, r31, 0x34
	ctx.r[11].s64 = ctx.r[31].s64 + 52;
	// 82B8B7A8: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82B8B7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B7B0: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82B8B7B4: 419A0008  beq cr6, 0x82b8b7bc
	if ctx.cr[6].eq {
	pc = 0x82B8B7BC; continue 'dispatch;
	}
	// 82B8B7B8: 4B7350D9  bl 0x822c0890
	ctx.lr = 0x82B8B7BC;
	sub_822C0890(ctx, base);
	// 82B8B7BC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B7C0: 814B00E4  lwz r10, 0xe4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 82B8B7C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8B7C8: 816B00E8  lwz r11, 0xe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 82B8B7CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B7D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8B7D4: 419A0024  beq cr6, 0x82b8b7f8
	if ctx.cr[6].eq {
	pc = 0x82B8B7F8; continue 'dispatch;
	}
	// 82B8B7D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8B7DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8B7E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8B7E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8B7E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8B7EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8B7F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8B7F4: 4082FFE8  bne 0x82b8b7dc
	if !ctx.cr[0].eq {
	pc = 0x82B8B7DC; continue 'dispatch;
	}
	// 82B8B7F8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82B8B7FC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B800: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8B804: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8B808: 4B9848B9  bl 0x825100c0
	ctx.lr = 0x82B8B80C;
	sub_825100C0(ctx, base);
	// 82B8B80C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8B810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B814: 419A0008  beq cr6, 0x82b8b81c
	if ctx.cr[6].eq {
	pc = 0x82B8B81C; continue 'dispatch;
	}
	// 82B8B818: 4B735079  bl 0x822c0890
	ctx.lr = 0x82B8B81C;
	sub_822C0890(ctx, base);
	// 82B8B81C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8B820: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8B824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B82C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B830: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8B840 size=28
    let mut pc: u32 = 0x82B8B840;
    'dispatch: loop {
        match pc {
            0x82B8B840 => {
    //   block [0x82B8B840..0x82B8B85C)
	// 82B8B840: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8B844: 814B00EC  lwz r10, 0xec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8B848: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8B84C: 816B00F0  lwz r11, 0xf0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 82B8B850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8B854: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8B858: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B85C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8B85C size=36
    let mut pc: u32 = 0x82B8B85C;
    'dispatch: loop {
        match pc {
            0x82B8B85C => {
    //   block [0x82B8B85C..0x82B8B880)
	// 82B8B85C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8B860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8B864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8B868: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8B86C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8B870: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8B874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8B878: 4082FFE8  bne 0x82b8b860
	if !ctx.cr[0].eq {
	pc = 0x82B8B860; continue 'dispatch;
	}
	// 82B8B87C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B880 size=112
    let mut pc: u32 = 0x82B8B880;
    'dispatch: loop {
        match pc {
            0x82B8B880 => {
    //   block [0x82B8B880..0x82B8B8F0)
	// 82B8B880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B88C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8B898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B89C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8B8A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B8A4: 4BFFF835  bl 0x82b8b0d8
	ctx.lr = 0x82B8B8A8;
	sub_82B8B0D8(ctx, base);
	// 82B8B8A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8B8AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8B8B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B8B4: 4B73474D  bl 0x822c0000
	ctx.lr = 0x82B8B8B8;
	sub_822C0000(ctx, base);
	// 82B8B8B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8B8BC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8B8C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B8C4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8B8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B8CC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B8D0: 419A0008  beq cr6, 0x82b8b8d8
	if ctx.cr[6].eq {
	pc = 0x82B8B8D8; continue 'dispatch;
	}
	// 82B8B8D4: 4B734FBD  bl 0x822c0890
	ctx.lr = 0x82B8B8D8;
	sub_822C0890(ctx, base);
	// 82B8B8D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B8DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B8E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B8E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B8F0 size=112
    let mut pc: u32 = 0x82B8B8F0;
    'dispatch: loop {
        match pc {
            0x82B8B8F0 => {
    //   block [0x82B8B8F0..0x82B8B960)
	// 82B8B8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B904: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8B908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B90C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8B910: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B914: 4BFFF875  bl 0x82b8b188
	ctx.lr = 0x82B8B918;
	sub_82B8B188(ctx, base);
	// 82B8B918: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8B91C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8B920: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B924: 4B7346DD  bl 0x822c0000
	ctx.lr = 0x82B8B928;
	sub_822C0000(ctx, base);
	// 82B8B928: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8B92C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8B930: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B934: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8B938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B93C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B940: 419A0008  beq cr6, 0x82b8b948
	if ctx.cr[6].eq {
	pc = 0x82B8B948; continue 'dispatch;
	}
	// 82B8B944: 4B734F4D  bl 0x822c0890
	ctx.lr = 0x82B8B948;
	sub_822C0890(ctx, base);
	// 82B8B948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B960 size=112
    let mut pc: u32 = 0x82B8B960;
    'dispatch: loop {
        match pc {
            0x82B8B960 => {
    //   block [0x82B8B960..0x82B8B9D0)
	// 82B8B960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B96C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B974: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8B978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B97C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8B980: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B984: 4BFFF8CD  bl 0x82b8b250
	ctx.lr = 0x82B8B988;
	sub_82B8B250(ctx, base);
	// 82B8B988: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8B98C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8B990: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B994: 4B73466D  bl 0x822c0000
	ctx.lr = 0x82B8B998;
	sub_822C0000(ctx, base);
	// 82B8B998: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8B99C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8B9A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8B9A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8B9A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8B9AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8B9B0: 419A0008  beq cr6, 0x82b8b9b8
	if ctx.cr[6].eq {
	pc = 0x82B8B9B8; continue 'dispatch;
	}
	// 82B8B9B4: 4B734EDD  bl 0x822c0890
	ctx.lr = 0x82B8B9B8;
	sub_822C0890(ctx, base);
	// 82B8B9B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8B9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8B9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8B9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8B9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8B9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8B9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8B9D0 size=112
    let mut pc: u32 = 0x82B8B9D0;
    'dispatch: loop {
        match pc {
            0x82B8B9D0 => {
    //   block [0x82B8B9D0..0x82B8BA40)
	// 82B8B9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8B9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8B9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8B9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8B9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8B9E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8B9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8B9EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8B9F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8B9F4: 4BFFF925  bl 0x82b8b318
	ctx.lr = 0x82B8B9F8;
	sub_82B8B318(ctx, base);
	// 82B8B9F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8B9FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8BA00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8BA04: 4B7345FD  bl 0x822c0000
	ctx.lr = 0x82B8BA08;
	sub_822C0000(ctx, base);
	// 82B8BA08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8BA0C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8BA10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8BA14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8BA18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BA1C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8BA20: 419A0008  beq cr6, 0x82b8ba28
	if ctx.cr[6].eq {
	pc = 0x82B8BA28; continue 'dispatch;
	}
	// 82B8BA24: 4B734E6D  bl 0x822c0890
	ctx.lr = 0x82B8BA28;
	sub_822C0890(ctx, base);
	// 82B8BA28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8BA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8BA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8BA34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8BA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8BA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8BA40 size=112
    let mut pc: u32 = 0x82B8BA40;
    'dispatch: loop {
        match pc {
            0x82B8BA40 => {
    //   block [0x82B8BA40..0x82B8BAB0)
	// 82B8BA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8BA48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8BA4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8BA50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BA54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8BA58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8BA5C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8BA60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8BA64: 4B82A68D  bl 0x823b60f0
	ctx.lr = 0x82B8BA68;
	sub_823B60F0(ctx, base);
	// 82B8BA68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8BA6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8BA70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8BA74: 4B73458D  bl 0x822c0000
	ctx.lr = 0x82B8BA78;
	sub_822C0000(ctx, base);
	// 82B8BA78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8BA7C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8BA80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8BA84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8BA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BA8C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8BA90: 419A0008  beq cr6, 0x82b8ba98
	if ctx.cr[6].eq {
	pc = 0x82B8BA98; continue 'dispatch;
	}
	// 82B8BA94: 4B734DFD  bl 0x822c0890
	ctx.lr = 0x82B8BA98;
	sub_822C0890(ctx, base);
	// 82B8BA98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8BA9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8BAA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8BAA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8BAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8BAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8BAB0 size=112
    let mut pc: u32 = 0x82B8BAB0;
    'dispatch: loop {
        match pc {
            0x82B8BAB0 => {
    //   block [0x82B8BAB0..0x82B8BB20)
	// 82B8BAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8BAB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8BABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8BAC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BAC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8BAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8BACC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8BAD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8BAD4: 4BDD5755  bl 0x82961228
	ctx.lr = 0x82B8BAD8;
	sub_82961228(ctx, base);
	// 82B8BAD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8BADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8BAE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8BAE4: 4B73451D  bl 0x822c0000
	ctx.lr = 0x82B8BAE8;
	sub_822C0000(ctx, base);
	// 82B8BAE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8BAEC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8BAF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8BAF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8BAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BAFC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8BB00: 419A0008  beq cr6, 0x82b8bb08
	if ctx.cr[6].eq {
	pc = 0x82B8BB08; continue 'dispatch;
	}
	// 82B8BB04: 4B734D8D  bl 0x822c0890
	ctx.lr = 0x82B8BB08;
	sub_822C0890(ctx, base);
	// 82B8BB08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8BB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8BB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8BB14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8BB18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8BB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8BB20 size=124
    let mut pc: u32 = 0x82B8BB20;
    'dispatch: loop {
        match pc {
            0x82B8BB20 => {
    //   block [0x82B8BB20..0x82B8BB9C)
	// 82B8BB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BB24: 4861C63D  bl 0x831a8160
	ctx.lr = 0x82B8BB28;
	sub_831A8130(ctx, base);
	// 82B8BB28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BB2C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82B8BB30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8BB34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82B8BB38: 396B87E8  addi r11, r11, -0x7818
	ctx.r[11].s64 = ctx.r[11].s64 + -30744;
	// 82B8BB3C: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82B8BB40: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8BB44: 3B5B0004  addi r26, r27, 4
	ctx.r[26].s64 = ctx.r[27].s64 + 4;
	// 82B8BB48: 939B0004  stw r28, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B8BB4C: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B8BB50: 4B734DE9  bl 0x822c0938
	ctx.lr = 0x82B8BB54;
	sub_822C0938(ctx, base);
	// 82B8BB54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8BB58: 4182002C  beq 0x82b8bb84
	if ctx.cr[0].eq {
	pc = 0x82B8BB84; continue 'dispatch;
	}
	// 82B8BB5C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82B8BB60: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82B8BB64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8BB68: 4860FD19  bl 0x8319b880
	ctx.lr = 0x82B8BB6C;
	sub_8319B880(ctx, base);
	// 82B8BB6C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8BB70: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B8BB74: 4080FFF0  bge 0x82b8bb64
	if !ctx.cr[0].lt {
	pc = 0x82B8BB64; continue 'dispatch;
	}
	// 82B8BB78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8BB7C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B8BB80: 48000008  b 0x82b8bb88
	pc = 0x82B8BB88; continue 'dispatch;
	// 82B8BB84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82B8BB88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B8BB8C: 4BFFFCF5  bl 0x82b8b880
	ctx.lr = 0x82B8BB90;
	sub_82B8B880(ctx, base);
	// 82B8BB90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8BB94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8BB98: 4861C618  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8BBA0 size=96
    let mut pc: u32 = 0x82B8BBA0;
    'dispatch: loop {
        match pc {
            0x82B8BBA0 => {
    //   block [0x82B8BBA0..0x82B8BC00)
	// 82B8BBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BBA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8BBA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8BBAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8BBB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8BBB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8BBBC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BBC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BBC4: 419A0008  beq cr6, 0x82b8bbcc
	if ctx.cr[6].eq {
	pc = 0x82B8BBCC; continue 'dispatch;
	}
	// 82B8BBC8: 4B734CC9  bl 0x822c0890
	ctx.lr = 0x82B8BBCC;
	sub_822C0890(ctx, base);
	// 82B8BBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8BBD0: 4829D879  bl 0x82e29448
	ctx.lr = 0x82B8BBD4;
	sub_82E29448(ctx, base);
	// 82B8BBD4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8BBD8: 4182000C  beq 0x82b8bbe4
	if ctx.cr[0].eq {
	pc = 0x82B8BBE4; continue 'dispatch;
	}
	// 82B8BBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8BBE0: 482667F9  bl 0x82df23d8
	ctx.lr = 0x82B8BBE4;
	sub_82DF23D8(ctx, base);
	// 82B8BBE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8BBE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8BBEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8BBF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8BBF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8BBF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8BBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8BC00 size=716
    let mut pc: u32 = 0x82B8BC00;
    'dispatch: loop {
        match pc {
            0x82B8BC00 => {
    //   block [0x82B8BC00..0x82B8BECC)
	// 82B8BC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BC04: 4861C55D  bl 0x831a8160
	ctx.lr = 0x82B8BC08;
	sub_831A8130(ctx, base);
	// 82B8BC08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BC0C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82B8BC10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8BC14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B8BC18: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82B8BC1C: 4B985DBD  bl 0x825119d8
	ctx.lr = 0x82B8BC20;
	sub_825119D8(ctx, base);
	// 82B8BC20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82B8BC24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8BC28: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82B8BC2C: 48267DDD  bl 0x82df3a08
	ctx.lr = 0x82B8BC30;
	sub_82DF3A08(ctx, base);
	// 82B8BC30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B8BC34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8BC38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8BC3C: 4B97CB45  bl 0x82508780
	ctx.lr = 0x82B8BC40;
	sub_82508780(ctx, base);
	// 82B8BC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8BC44: 482677E5  bl 0x82df3428
	ctx.lr = 0x82B8BC48;
	sub_82DF3428(ctx, base);
	// 82B8BC48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8BC4C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82B8BC50: 409A0008  bne cr6, 0x82b8bc58
	if !ctx.cr[6].eq {
	pc = 0x82B8BC58; continue 'dispatch;
	}
	// 82B8BC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BC58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8BC5C: 4B97CB45  bl 0x825087a0
	ctx.lr = 0x82B8BC60;
	sub_825087A0(ctx, base);
	// 82B8BC60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8BC64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8BC68: 3BAB87F0  addi r29, r11, -0x7810
	ctx.r[29].s64 = ctx.r[11].s64 + -30736;
	// 82B8BC6C: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 82B8BC70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8BC74: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82B8BC78: 48266771  bl 0x82df23e8
	ctx.lr = 0x82B8BC7C;
	sub_82DF23E8(ctx, base);
	// 82B8BC7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BC80: 4182001C  beq 0x82b8bc9c
	if ctx.cr[0].eq {
	pc = 0x82B8BC9C; continue 'dispatch;
	}
	// 82B8BC84: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8BC88: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8BC8C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82B8BC90: 4829DE99  bl 0x82e29b28
	ctx.lr = 0x82B8BC94;
	sub_82E29B28(ctx, base);
	// 82B8BC94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8BC98: 48000008  b 0x82b8bca0
	pc = 0x82B8BCA0; continue 'dispatch;
	// 82B8BC9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BCA0: 3B7F00E4  addi r27, r31, 0xe4
	ctx.r[27].s64 = ctx.r[31].s64 + 228;
	// 82B8BCA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8BCA8: 4BFFFC49  bl 0x82b8b8f0
	ctx.lr = 0x82B8BCAC;
	sub_82B8B8F0(ctx, base);
	// 82B8BCAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8BCB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8BCB4: 4B986465  bl 0x82512118
	ctx.lr = 0x82B8BCB8;
	sub_82512118(ctx, base);
	// 82B8BCB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8BCBC: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82B8BCC0: 482893F1  bl 0x82e150b0
	ctx.lr = 0x82B8BCC4;
	sub_82E150B0(ctx, base);
	// 82B8BCC4: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8BCC8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8BCCC: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82B8BCD0: 48267DC1  bl 0x82df3a90
	ctx.lr = 0x82B8BCD4;
	sub_82DF3A90(ctx, base);
	// 82B8BCD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82B8BCD8: 408100E8  ble 0x82b8bdc0
	if !ctx.cr[0].gt {
	pc = 0x82B8BDC0; continue 'dispatch;
	}
	// 82B8BCDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8BCE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8BCE4: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 82B8BCE8: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82B8BCEC: 482666FD  bl 0x82df23e8
	ctx.lr = 0x82B8BCF0;
	sub_82DF23E8(ctx, base);
	// 82B8BCF0: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82B8BCF4: 41820058  beq 0x82b8bd4c
	if ctx.cr[0].eq {
	pc = 0x82B8BD4C; continue 'dispatch;
	}
	// 82B8BCF8: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8BCFC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82B8BD00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8BD04: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82B8BD08: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8BD0C: 409A0008  bne cr6, 0x82b8bd14
	if !ctx.cr[6].eq {
	pc = 0x82B8BD14; continue 'dispatch;
	}
	// 82B8BD10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BD14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B8BD18: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8BD1C: 48265EDD  bl 0x82df1bf8
	ctx.lr = 0x82B8BD20;
	sub_82DF1BF8(ctx, base);
	// 82B8BD20: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8BD24: 3BDD0018  addi r30, r29, 0x18
	ctx.r[30].s64 = ctx.r[29].s64 + 24;
	// 82B8BD28: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BD2C: 480028F5  bl 0x82b8e620
	ctx.lr = 0x82B8BD30;
	sub_82B8E620(ctx, base);
	// 82B8BD30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82B8BD34: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82B8BD38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B8BD3C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82B8BD40: 480279C9  bl 0x82bb3708
	ctx.lr = 0x82B8BD44;
	sub_82BB3708(ctx, base);
	// 82B8BD44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8BD48: 48000008  b 0x82b8bd50
	pc = 0x82B8BD50; continue 'dispatch;
	// 82B8BD4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BD50: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 82B8BD54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8BD58: 4B7D1689  bl 0x8235d3e0
	ctx.lr = 0x82B8BD5C;
	sub_8235D3E0(ctx, base);
	// 82B8BD5C: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8BD60: 4182000C  beq 0x82b8bd6c
	if ctx.cr[0].eq {
	pc = 0x82B8BD6C; continue 'dispatch;
	}
	// 82B8BD64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8BD68: 48265F29  bl 0x82df1c90
	ctx.lr = 0x82B8BD6C;
	sub_82DF1C90(ctx, base);
	// 82B8BD6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8BD70: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8BD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8BD78: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B8BD7C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82B8BD80: 419A0024  beq cr6, 0x82b8bda4
	if ctx.cr[6].eq {
	pc = 0x82B8BDA4; continue 'dispatch;
	}
	// 82B8BD84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8BD88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8BD8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8BD90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8BD94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8BD98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8BD9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8BDA0: 4082FFE8  bne 0x82b8bd88
	if !ctx.cr[0].eq {
	pc = 0x82B8BD88; continue 'dispatch;
	}
	// 82B8BDA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B8BDA8: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8BDAC: 482891C5  bl 0x82e14f70
	ctx.lr = 0x82B8BDB0;
	sub_82E14F70(ctx, base);
	// 82B8BDB0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8BDB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BDB8: 419A0008  beq cr6, 0x82b8bdc0
	if ctx.cr[6].eq {
	pc = 0x82B8BDC0; continue 'dispatch;
	}
	// 82B8BDBC: 4B734AD5  bl 0x822c0890
	ctx.lr = 0x82B8BDC0;
	sub_822C0890(ctx, base);
	// 82B8BDC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82B8BDC4: 482665FD  bl 0x82df23c0
	ctx.lr = 0x82B8BDC8;
	sub_82DF23C0(ctx, base);
	// 82B8BDC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BDCC: 41820010  beq 0x82b8bddc
	if ctx.cr[0].eq {
	pc = 0x82B8BDDC; continue 'dispatch;
	}
	// 82B8BDD0: 4BFFFD51  bl 0x82b8bb20
	ctx.lr = 0x82B8BDD4;
	sub_82B8BB20(ctx, base);
	// 82B8BDD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8BDD8: 48000008  b 0x82b8bde0
	pc = 0x82B8BDE0; continue 'dispatch;
	// 82B8BDDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BDE0: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82B8BDE4: 4BFFFB7D  bl 0x82b8b960
	ctx.lr = 0x82B8BDE8;
	sub_82B8B960(ctx, base);
	// 82B8BDE8: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82B8BDEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8BDF0: 83DF00F8  lwz r30, 0xf8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82B8BDF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8BDF8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82B8BDFC: 419A0024  beq cr6, 0x82b8be20
	if ctx.cr[6].eq {
	pc = 0x82B8BE20; continue 'dispatch;
	}
	// 82B8BE00: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82B8BE04: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82B8BE08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8BE0C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82B8BE10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82B8BE14: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8BE18: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8BE1C: 4082FFE8  bne 0x82b8be04
	if !ctx.cr[0].eq {
	pc = 0x82B8BE04; continue 'dispatch;
	}
	// 82B8BE20: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8BE24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8BE28: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82B8BE2C: 396B019C  addi r11, r11, 0x19c
	ctx.r[11].s64 = ctx.r[11].s64 + 412;
	// 82B8BE30: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B8BE34: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8BE38: 4B738629  bl 0x822c4460
	ctx.lr = 0x82B8BE3C;
	sub_822C4460(ctx, base);
	// 82B8BE3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8BE40: 419A000C  beq cr6, 0x82b8be4c
	if ctx.cr[6].eq {
	pc = 0x82B8BE4C; continue 'dispatch;
	}
	// 82B8BE44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8BE48: 4B734A49  bl 0x822c0890
	ctx.lr = 0x82B8BE4C;
	sub_822C0890(ctx, base);
	// 82B8BE4C: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8BE50: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8BE54: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BE58: 480027B1  bl 0x82b8e608
	ctx.lr = 0x82B8BE5C;
	sub_82B8E608(ctx, base);
	// 82B8BE5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8BE60: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82B8BE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8BE68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8BE6C: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 82B8BE70: C00B006C  lfs f0, 0x6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8BE74: C1AB0068  lfs f13, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8BE78: C18B0064  lfs f12, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82B8BE7C: C16B0060  lfs f11, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82B8BE80: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82B8BE84: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82B8BE88: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82B8BE8C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82B8BE90: 4B985BF1  bl 0x82511a80
	ctx.lr = 0x82B8BE94;
	sub_82511A80(ctx, base);
	// 82B8BE94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8BE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8BE9C: 482F0F6D  bl 0x82e7ce08
	ctx.lr = 0x82B8BEA0;
	sub_82E7CE08(ctx, base);
	// 82B8BEA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8BEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8BEA8: 4B985C49  bl 0x82511af0
	ctx.lr = 0x82B8BEAC;
	sub_82511AF0(ctx, base);
	// 82B8BEAC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8BEB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8BEB4: 419A0010  beq cr6, 0x82b8bec4
	if ctx.cr[6].eq {
	pc = 0x82B8BEC4; continue 'dispatch;
	}
	// 82B8BEB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8BEBC: C02BCC2C  lfs f1, -0x33d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8BEC0: 48029631  bl 0x82bb54f0
	ctx.lr = 0x82B8BEC4;
	sub_82BB54F0(ctx, base);
	// 82B8BEC4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82B8BEC8: 4861C2E8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8BED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8BED0 size=1516
    let mut pc: u32 = 0x82B8BED0;
    'dispatch: loop {
        match pc {
            0x82B8BED0 => {
    //   block [0x82B8BED0..0x82B8C4BC)
	// 82B8BED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8BED4: 4861C27D  bl 0x831a8150
	ctx.lr = 0x82B8BED8;
	sub_831A8130(ctx, base);
	// 82B8BED8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8BEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8BEE0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8BEE4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BEE8: 48002851  bl 0x82b8e738
	ctx.lr = 0x82B8BEEC;
	sub_82B8E738(ctx, base);
	// 82B8BEEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8BEF0: 418205BC  beq 0x82b8c4ac
	if ctx.cr[0].eq {
	pc = 0x82B8C4AC; continue 'dispatch;
	}
	// 82B8BEF4: 897F0028  lbz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8BEF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BEFC: 408205B0  bne 0x82b8c4ac
	if !ctx.cr[0].eq {
	pc = 0x82B8C4AC; continue 'dispatch;
	}
	// 82B8BF00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8BF04: 895F002E  lbz r10, 0x2e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 82B8BF08: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BF0C: 834B7058  lwz r26, 0x7058(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82B8BF10: 4182000C  beq 0x82b8bf1c
	if ctx.cr[0].eq {
	pc = 0x82B8BF1C; continue 'dispatch;
	}
	// 82B8BF14: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8BF18: 834B7080  lwz r26, 0x7080(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28800 as u32) ) } as u64;
	// 82B8BF1C: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82B8BF20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BF24: 4182001C  beq 0x82b8bf40
	if ctx.cr[0].eq {
	pc = 0x82B8BF40; continue 'dispatch;
	}
	// 82B8BF28: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8BF2C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82B8BF30: 392B9D84  addi r9, r11, -0x627c
	ctx.r[9].s64 = ctx.r[11].s64 + -25212;
	// 82B8BF34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8BF38: 834A706C  lwz r26, 0x706c(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28780 as u32) ) } as u64;
	// 82B8BF3C: 99690004  stb r11, 4(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82B8BF40: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 82B8BF44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8BF48: 41820148  beq 0x82b8c090
	if ctx.cr[0].eq {
	pc = 0x82B8C090; continue 'dispatch;
	}
	// 82B8BF4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8BF50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8BF54: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8BF58: 38A0011C  li r5, 0x11c
	ctx.r[5].s64 = 284;
	// 82B8BF5C: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82B8BF60: 48266489  bl 0x82df23e8
	ctx.lr = 0x82B8BF64;
	sub_82DF23E8(ctx, base);
	// 82B8BF64: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8BF68: 41820020  beq 0x82b8bf88
	if ctx.cr[0].eq {
	pc = 0x82B8BF88; continue 'dispatch;
	}
	// 82B8BF6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8BF70: 48037791  bl 0x82bc3700
	ctx.lr = 0x82B8BF74;
	sub_82BC3700(ctx, base);
	// 82B8BF74: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8BF78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8BF7C: 396BF130  addi r11, r11, -0xed0
	ctx.r[11].s64 = ctx.r[11].s64 + -3792;
	// 82B8BF80: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8BF84: 48000008  b 0x82b8bf8c
	pc = 0x82B8BF8C; continue 'dispatch;
	// 82B8BF88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8BF8C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82B8BF90: 4BFFFAB1  bl 0x82b8ba40
	ctx.lr = 0x82B8BF94;
	sub_82B8BA40(ctx, base);
	// 82B8BF94: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8BF98: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BF9C: 4B98352D  bl 0x8250f4c8
	ctx.lr = 0x82B8BFA0;
	sub_8250F4C8(ctx, base);
	// 82B8BFA0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8BFA4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8BFA8: 388B0668  addi r4, r11, 0x668
	ctx.r[4].s64 = ctx.r[11].s64 + 1640;
	// 82B8BFAC: 48267A5D  bl 0x82df3a08
	ctx.lr = 0x82B8BFB0;
	sub_82DF3A08(ctx, base);
	// 82B8BFB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8BFB4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8BFB8: 388B8850  addi r4, r11, -0x77b0
	ctx.r[4].s64 = ctx.r[11].s64 + -30640;
	// 82B8BFBC: 48267A4D  bl 0x82df3a08
	ctx.lr = 0x82B8BFC0;
	sub_82DF3A08(ctx, base);
	// 82B8BFC0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8BFC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8BFC8: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82B8BFCC: 48267A3D  bl 0x82df3a08
	ctx.lr = 0x82B8BFD0;
	sub_82DF3A08(ctx, base);
	// 82B8BFD0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B8BFD4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8BFD8: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8BFDC: 4B98613D  bl 0x82512118
	ctx.lr = 0x82B8BFE0;
	sub_82512118(ctx, base);
	// 82B8BFE0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8BFE4: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8BFE8: 48002639  bl 0x82b8e620
	ctx.lr = 0x82B8BFEC;
	sub_82B8E620(ctx, base);
	// 82B8BFEC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B8BFF0: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8BFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8BFF8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8BFFC: 409A0008  bne cr6, 0x82b8c004
	if !ctx.cr[6].eq {
	pc = 0x82B8C004; continue 'dispatch;
	}
	// 82B8C000: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C004: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82B8C008: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C00C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82B8C010: 833F0014  lwz r25, 0x14(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C014: 3B010078  addi r24, r1, 0x78
	ctx.r[24].s64 = ctx.r[1].s64 + 120;
	// 82B8C018: 3B9C00EC  addi r28, r28, 0xec
	ctx.r[28].s64 = ctx.r[28].s64 + 236;
	// 82B8C01C: 3AE10068  addi r23, r1, 0x68
	ctx.r[23].s64 = ctx.r[1].s64 + 104;
	// 82B8C020: 3AC10064  addi r22, r1, 0x64
	ctx.r[22].s64 = ctx.r[1].s64 + 100;
	// 82B8C024: 4B97F62D  bl 0x8250b650
	ctx.lr = 0x82B8C028;
	sub_8250B650(ctx, base);
	// 82B8C028: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82B8C02C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8C030: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B8C034: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82B8C038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C03C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B8C040: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82B8C044: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82B8C048: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82B8C04C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82B8C050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8C054: 4E800421  bctrl
	ctx.lr = 0x82B8C058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8C058: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82B8C05C: 48265C35  bl 0x82df1c90
	ctx.lr = 0x82B8C060;
	sub_82DF1C90(ctx, base);
	// 82B8C060: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8C064: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C068: 419A0008  beq cr6, 0x82b8c070
	if ctx.cr[6].eq {
	pc = 0x82B8C070; continue 'dispatch;
	}
	// 82B8C06C: 4B734825  bl 0x822c0890
	ctx.lr = 0x82B8C070;
	sub_822C0890(ctx, base);
	// 82B8C070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C074: 482673B5  bl 0x82df3428
	ctx.lr = 0x82B8C078;
	sub_82DF3428(ctx, base);
	// 82B8C078: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C07C: 482673AD  bl 0x82df3428
	ctx.lr = 0x82B8C080;
	sub_82DF3428(ctx, base);
	// 82B8C080: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C084: 482673A5  bl 0x82df3428
	ctx.lr = 0x82B8C088;
	sub_82DF3428(ctx, base);
	// 82B8C088: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8C08C: 480003BC  b 0x82b8c448
	pc = 0x82B8C448; continue 'dispatch;
	// 82B8C090: 897F002A  lbz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 82B8C094: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C098: 41820148  beq 0x82b8c1e0
	if ctx.cr[0].eq {
	pc = 0x82B8C1E0; continue 'dispatch;
	}
	// 82B8C09C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C0A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8C0A4: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8C0A8: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 82B8C0AC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82B8C0B0: 48266339  bl 0x82df23e8
	ctx.lr = 0x82B8C0B4;
	sub_82DF23E8(ctx, base);
	// 82B8C0B4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8C0B8: 41820020  beq 0x82b8c0d8
	if ctx.cr[0].eq {
	pc = 0x82B8C0D8; continue 'dispatch;
	}
	// 82B8C0BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C0C0: 48037641  bl 0x82bc3700
	ctx.lr = 0x82B8C0C4;
	sub_82BC3700(ctx, base);
	// 82B8C0C4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C0C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8C0CC: 396BF130  addi r11, r11, -0xed0
	ctx.r[11].s64 = ctx.r[11].s64 + -3792;
	// 82B8C0D0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8C0D4: 48000008  b 0x82b8c0dc
	pc = 0x82B8C0DC; continue 'dispatch;
	// 82B8C0D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C0DC: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82B8C0E0: 4BFFF961  bl 0x82b8ba40
	ctx.lr = 0x82B8C0E4;
	sub_82B8BA40(ctx, base);
	// 82B8C0E4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82B8C0E8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C0EC: 4B9833DD  bl 0x8250f4c8
	ctx.lr = 0x82B8C0F0;
	sub_8250F4C8(ctx, base);
	// 82B8C0F0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C0F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C0F8: 388B0668  addi r4, r11, 0x668
	ctx.r[4].s64 = ctx.r[11].s64 + 1640;
	// 82B8C0FC: 4826790D  bl 0x82df3a08
	ctx.lr = 0x82B8C100;
	sub_82DF3A08(ctx, base);
	// 82B8C100: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C104: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C108: 388B0658  addi r4, r11, 0x658
	ctx.r[4].s64 = ctx.r[11].s64 + 1624;
	// 82B8C10C: 482678FD  bl 0x82df3a08
	ctx.lr = 0x82B8C110;
	sub_82DF3A08(ctx, base);
	// 82B8C110: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C114: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C118: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82B8C11C: 482678ED  bl 0x82df3a08
	ctx.lr = 0x82B8C120;
	sub_82DF3A08(ctx, base);
	// 82B8C120: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82B8C124: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C128: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8C12C: 4B985FED  bl 0x82512118
	ctx.lr = 0x82B8C130;
	sub_82512118(ctx, base);
	// 82B8C130: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C134: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C138: 480024E9  bl 0x82b8e620
	ctx.lr = 0x82B8C13C;
	sub_82B8E620(ctx, base);
	// 82B8C13C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B8C140: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C148: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8C14C: 409A0008  bne cr6, 0x82b8c154
	if !ctx.cr[6].eq {
	pc = 0x82B8C154; continue 'dispatch;
	}
	// 82B8C150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C154: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B8C158: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C15C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82B8C160: 833F0014  lwz r25, 0x14(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C164: 3B010088  addi r24, r1, 0x88
	ctx.r[24].s64 = ctx.r[1].s64 + 136;
	// 82B8C168: 3B9C00EC  addi r28, r28, 0xec
	ctx.r[28].s64 = ctx.r[28].s64 + 236;
	// 82B8C16C: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 82B8C170: 3AC10064  addi r22, r1, 0x64
	ctx.r[22].s64 = ctx.r[1].s64 + 100;
	// 82B8C174: 4B97F4DD  bl 0x8250b650
	ctx.lr = 0x82B8C178;
	sub_8250B650(ctx, base);
	// 82B8C178: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82B8C17C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8C180: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B8C184: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82B8C188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C18C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B8C190: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82B8C194: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82B8C198: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82B8C19C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82B8C1A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8C1A4: 4E800421  bctrl
	ctx.lr = 0x82B8C1A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8C1A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82B8C1AC: 48265AE5  bl 0x82df1c90
	ctx.lr = 0x82B8C1B0;
	sub_82DF1C90(ctx, base);
	// 82B8C1B0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82B8C1B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C1B8: 419A0008  beq cr6, 0x82b8c1c0
	if ctx.cr[6].eq {
	pc = 0x82B8C1C0; continue 'dispatch;
	}
	// 82B8C1BC: 4B7346D5  bl 0x822c0890
	ctx.lr = 0x82B8C1C0;
	sub_822C0890(ctx, base);
	// 82B8C1C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C1C4: 48267265  bl 0x82df3428
	ctx.lr = 0x82B8C1C8;
	sub_82DF3428(ctx, base);
	// 82B8C1C8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C1CC: 4826725D  bl 0x82df3428
	ctx.lr = 0x82B8C1D0;
	sub_82DF3428(ctx, base);
	// 82B8C1D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C1D4: 48267255  bl 0x82df3428
	ctx.lr = 0x82B8C1D8;
	sub_82DF3428(ctx, base);
	// 82B8C1D8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82B8C1DC: 4800026C  b 0x82b8c448
	pc = 0x82B8C448; continue 'dispatch;
	// 82B8C1E0: 897F002B  lbz r11, 0x2b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(43 as u32) ) } as u64;
	// 82B8C1E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C1E8: 41820138  beq 0x82b8c320
	if ctx.cr[0].eq {
	pc = 0x82B8C320; continue 'dispatch;
	}
	// 82B8C1EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C1F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8C1F4: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8C1F8: 38A00124  li r5, 0x124
	ctx.r[5].s64 = 292;
	// 82B8C1FC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82B8C200: 482661E9  bl 0x82df23e8
	ctx.lr = 0x82B8C204;
	sub_82DF23E8(ctx, base);
	// 82B8C204: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C208: 41820010  beq 0x82b8c218
	if ctx.cr[0].eq {
	pc = 0x82B8C218; continue 'dispatch;
	}
	// 82B8C20C: 4803D60D  bl 0x82bc9818
	ctx.lr = 0x82B8C210;
	sub_82BC9818(ctx, base);
	// 82B8C210: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8C214: 48000008  b 0x82b8c21c
	pc = 0x82B8C21C; continue 'dispatch;
	// 82B8C218: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C21C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82B8C220: 48037E49  bl 0x82bc4068
	ctx.lr = 0x82B8C224;
	sub_82BC4068(ctx, base);
	// 82B8C224: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82B8C228: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C22C: 4B98329D  bl 0x8250f4c8
	ctx.lr = 0x82B8C230;
	sub_8250F4C8(ctx, base);
	// 82B8C230: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C234: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C238: 388B8848  addi r4, r11, -0x77b8
	ctx.r[4].s64 = ctx.r[11].s64 + -30648;
	// 82B8C23C: 482677CD  bl 0x82df3a08
	ctx.lr = 0x82B8C240;
	sub_82DF3A08(ctx, base);
	// 82B8C240: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C244: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C248: 388B8838  addi r4, r11, -0x77c8
	ctx.r[4].s64 = ctx.r[11].s64 + -30664;
	// 82B8C24C: 482677BD  bl 0x82df3a08
	ctx.lr = 0x82B8C250;
	sub_82DF3A08(ctx, base);
	// 82B8C250: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C254: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C258: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82B8C25C: 482677AD  bl 0x82df3a08
	ctx.lr = 0x82B8C260;
	sub_82DF3A08(ctx, base);
	// 82B8C260: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82B8C264: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C268: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8C26C: 4B985EAD  bl 0x82512118
	ctx.lr = 0x82B8C270;
	sub_82512118(ctx, base);
	// 82B8C270: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C274: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C278: 480023A9  bl 0x82b8e620
	ctx.lr = 0x82B8C27C;
	sub_82B8E620(ctx, base);
	// 82B8C27C: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82B8C280: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C288: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8C28C: 409A0008  bne cr6, 0x82b8c294
	if !ctx.cr[6].eq {
	pc = 0x82B8C294; continue 'dispatch;
	}
	// 82B8C290: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C294: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B8C298: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C29C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82B8C2A0: 833F0014  lwz r25, 0x14(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C2A4: 3B010098  addi r24, r1, 0x98
	ctx.r[24].s64 = ctx.r[1].s64 + 152;
	// 82B8C2A8: 3B9C00EC  addi r28, r28, 0xec
	ctx.r[28].s64 = ctx.r[28].s64 + 236;
	// 82B8C2AC: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 82B8C2B0: 3AC10064  addi r22, r1, 0x64
	ctx.r[22].s64 = ctx.r[1].s64 + 100;
	// 82B8C2B4: 4B97F39D  bl 0x8250b650
	ctx.lr = 0x82B8C2B8;
	sub_8250B650(ctx, base);
	// 82B8C2B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82B8C2BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8C2C0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B8C2C4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82B8C2C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C2CC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B8C2D0: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82B8C2D4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82B8C2D8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82B8C2DC: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82B8C2E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8C2E4: 4E800421  bctrl
	ctx.lr = 0x82B8C2E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8C2E8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82B8C2EC: 482659A5  bl 0x82df1c90
	ctx.lr = 0x82B8C2F0;
	sub_82DF1C90(ctx, base);
	// 82B8C2F0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82B8C2F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C2F8: 419A0008  beq cr6, 0x82b8c300
	if ctx.cr[6].eq {
	pc = 0x82B8C300; continue 'dispatch;
	}
	// 82B8C2FC: 4B734595  bl 0x822c0890
	ctx.lr = 0x82B8C300;
	sub_822C0890(ctx, base);
	// 82B8C300: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C304: 48267125  bl 0x82df3428
	ctx.lr = 0x82B8C308;
	sub_82DF3428(ctx, base);
	// 82B8C308: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C30C: 4826711D  bl 0x82df3428
	ctx.lr = 0x82B8C310;
	sub_82DF3428(ctx, base);
	// 82B8C310: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C314: 48267115  bl 0x82df3428
	ctx.lr = 0x82B8C318;
	sub_82DF3428(ctx, base);
	// 82B8C318: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82B8C31C: 4800012C  b 0x82b8c448
	pc = 0x82B8C448; continue 'dispatch;
	// 82B8C320: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82B8C324: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C328: 41820124  beq 0x82b8c44c
	if ctx.cr[0].eq {
	pc = 0x82B8C44C; continue 'dispatch;
	}
	// 82B8C32C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C330: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8C334: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8C338: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 82B8C33C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82B8C340: 482660A9  bl 0x82df23e8
	ctx.lr = 0x82B8C344;
	sub_82DF23E8(ctx, base);
	// 82B8C344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C348: 41820014  beq 0x82b8c35c
	if ctx.cr[0].eq {
	pc = 0x82B8C35C; continue 'dispatch;
	}
	// 82B8C34C: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 82B8C350: 4BDEB281  bl 0x829775d0
	ctx.lr = 0x82B8C354;
	sub_829775D0(ctx, base);
	// 82B8C354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8C358: 48000008  b 0x82b8c360
	pc = 0x82B8C360; continue 'dispatch;
	// 82B8C35C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C360: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82B8C364: 4BFFF74D  bl 0x82b8bab0
	ctx.lr = 0x82B8C368;
	sub_82B8BAB0(ctx, base);
	// 82B8C368: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82B8C36C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C370: 4B983159  bl 0x8250f4c8
	ctx.lr = 0x82B8C374;
	sub_8250F4C8(ctx, base);
	// 82B8C374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82B8C378: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C37C: 388BD48C  addi r4, r11, -0x2b74
	ctx.r[4].s64 = ctx.r[11].s64 + -11124;
	// 82B8C380: 48267689  bl 0x82df3a08
	ctx.lr = 0x82B8C384;
	sub_82DF3A08(ctx, base);
	// 82B8C384: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C388: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C38C: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82B8C390: 48267679  bl 0x82df3a08
	ctx.lr = 0x82B8C394;
	sub_82DF3A08(ctx, base);
	// 82B8C394: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82B8C398: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C39C: 83DF0034  lwz r30, 0x34(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8C3A0: 4B985D79  bl 0x82512118
	ctx.lr = 0x82B8C3A4;
	sub_82512118(ctx, base);
	// 82B8C3A4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C3A8: 839F0014  lwz r28, 0x14(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C3AC: 48002275  bl 0x82b8e620
	ctx.lr = 0x82B8C3B0;
	sub_82B8E620(ctx, base);
	// 82B8C3B0: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82B8C3B4: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C3B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C3BC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8C3C0: 409A0008  bne cr6, 0x82b8c3c8
	if !ctx.cr[6].eq {
	pc = 0x82B8C3C8; continue 'dispatch;
	}
	// 82B8C3C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8C3C8: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B8C3CC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C3D0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82B8C3D4: 833F0014  lwz r25, 0x14(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C3D8: 3B0100A8  addi r24, r1, 0xa8
	ctx.r[24].s64 = ctx.r[1].s64 + 168;
	// 82B8C3DC: 3B9C00EC  addi r28, r28, 0xec
	ctx.r[28].s64 = ctx.r[28].s64 + 236;
	// 82B8C3E0: 3AE10064  addi r23, r1, 0x64
	ctx.r[23].s64 = ctx.r[1].s64 + 100;
	// 82B8C3E4: 3ADF0040  addi r22, r31, 0x40
	ctx.r[22].s64 = ctx.r[31].s64 + 64;
	// 82B8C3E8: 4B97F269  bl 0x8250b650
	ctx.lr = 0x82B8C3EC;
	sub_8250B650(ctx, base);
	// 82B8C3EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82B8C3F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8C3F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B8C3F8: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82B8C3FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C400: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B8C404: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82B8C408: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 82B8C40C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82B8C410: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82B8C414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8C418: 4E800421  bctrl
	ctx.lr = 0x82B8C41C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8C41C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82B8C420: 48265871  bl 0x82df1c90
	ctx.lr = 0x82B8C424;
	sub_82DF1C90(ctx, base);
	// 82B8C424: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82B8C428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C42C: 419A0008  beq cr6, 0x82b8c434
	if ctx.cr[6].eq {
	pc = 0x82B8C434; continue 'dispatch;
	}
	// 82B8C430: 4B734461  bl 0x822c0890
	ctx.lr = 0x82B8C434;
	sub_822C0890(ctx, base);
	// 82B8C434: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C438: 48266FF1  bl 0x82df3428
	ctx.lr = 0x82B8C43C;
	sub_82DF3428(ctx, base);
	// 82B8C43C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B8C440: 48266FE9  bl 0x82df3428
	ctx.lr = 0x82B8C444;
	sub_82DF3428(ctx, base);
	// 82B8C444: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82B8C448: 48265849  bl 0x82df1c90
	ctx.lr = 0x82B8C44C;
	sub_82DF1C90(ctx, base);
	// 82B8C44C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C450: 814B00E4  lwz r10, 0xe4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	// 82B8C454: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82B8C458: 816B00E8  lwz r11, 0xe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 82B8C45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C460: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82B8C464: 419A0024  beq cr6, 0x82b8c488
	if ctx.cr[6].eq {
	pc = 0x82B8C488; continue 'dispatch;
	}
	// 82B8C468: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8C46C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8C470: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C474: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8C478: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8C47C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8C480: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C484: 4082FFE8  bne 0x82b8c46c
	if !ctx.cr[0].eq {
	pc = 0x82B8C46C; continue 'dispatch;
	}
	// 82B8C488: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82B8C48C: 88DF002F  lbz r6, 0x2f(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(47 as u32) ) } as u64;
	// 82B8C490: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B8C494: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C498: 4B984561  bl 0x825109f8
	ctx.lr = 0x82B8C49C;
	sub_825109F8(ctx, base);
	// 82B8C49C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8C4A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C4A4: 419A0008  beq cr6, 0x82b8c4ac
	if ctx.cr[6].eq {
	pc = 0x82B8C4AC; continue 'dispatch;
	}
	// 82B8C4A8: 4B7343E9  bl 0x822c0890
	ctx.lr = 0x82B8C4AC;
	sub_822C0890(ctx, base);
	// 82B8C4AC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8C4B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8C4B4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82B8C4B8: 4861BCE8  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8C4C0 size=228
    let mut pc: u32 = 0x82B8C4C0;
    'dispatch: loop {
        match pc {
            0x82B8C4C0 => {
    //   block [0x82B8C4C0..0x82B8C5A4)
	// 82B8C4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C4C4: 4861BCA5  bl 0x831a8168
	ctx.lr = 0x82B8C4C8;
	sub_831A8130(ctx, base);
	// 82B8C4C8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82B8C4CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C4D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C4D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8C4D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8C4DC: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 82B8C4E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8C4E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8C4E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C4EC: 839F0104  lwz r28, 0x104(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82B8C4F0: 4B73F319  bl 0x822cb808
	ctx.lr = 0x82B8C4F4;
	sub_822CB808(ctx, base);
	// 82B8C4F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C4F8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82B8C4FC: 409A0030  bne cr6, 0x82b8c52c
	if !ctx.cr[6].eq {
	pc = 0x82B8C52C; continue 'dispatch;
	}
	// 82B8C500: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8C504: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8C508: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8C50C: 4B740CB5  bl 0x822cd1c0
	ctx.lr = 0x82B8C510;
	sub_822CD1C0(ctx, base);
	// 82B8C510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8C514: 48266C9D  bl 0x82df31b0
	ctx.lr = 0x82B8C518;
	sub_82DF31B0(ctx, base);
	// 82B8C518: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82B8C51C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B8C520: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8C524: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C528: 48027C09  bl 0x82bb4130
	ctx.lr = 0x82B8C52C;
	sub_82BB4130(ctx, base);
	// 82B8C52C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8C530: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8C534: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8C538: 48026DD9  bl 0x82bb3310
	ctx.lr = 0x82B8C53C;
	sub_82BB3310(ctx, base);
	// 82B8C53C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8C540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C544: 419A0008  beq cr6, 0x82b8c54c
	if ctx.cr[6].eq {
	pc = 0x82B8C54C; continue 'dispatch;
	}
	// 82B8C548: 4B734349  bl 0x822c0890
	ctx.lr = 0x82B8C54C;
	sub_822C0890(ctx, base);
	// 82B8C54C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8C550: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8C554: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8C558: 48026671  bl 0x82bb2bc8
	ctx.lr = 0x82B8C55C;
	sub_82BB2BC8(ctx, base);
	// 82B8C55C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8C560: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8C564: 4802CECD  bl 0x82bb9430
	ctx.lr = 0x82B8C568;
	sub_82BB9430(ctx, base);
	// 82B8C568: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8C56C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82B8C570: C02BCC2C  lfs f1, -0x33d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8C574: 48028F7D  bl 0x82bb54f0
	ctx.lr = 0x82B8C578;
	sub_82BB54F0(ctx, base);
	// 82B8C578: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82B8C57C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8C580: 48002141  bl 0x82b8e6c0
	ctx.lr = 0x82B8C584;
	sub_82B8E6C0(ctx, base);
	// 82B8C584: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8C588: D03F010C  stfs f1, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82B8C58C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C590: 419A0008  beq cr6, 0x82b8c598
	if ctx.cr[6].eq {
	pc = 0x82B8C598; continue 'dispatch;
	}
	// 82B8C594: 4B7342FD  bl 0x822c0890
	ctx.lr = 0x82B8C598;
	sub_822C0890(ctx, base);
	// 82B8C598: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B8C59C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82B8C5A0: 4861BC18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8C5A8 size=8
    let mut pc: u32 = 0x82B8C5A8;
    'dispatch: loop {
        match pc {
            0x82B8C5A8 => {
    //   block [0x82B8C5A8..0x82B8C5B0)
	// 82B8C5A8: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C5AC: 4BFFFF14  b 0x82b8c4c0
	sub_82B8C4C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8C5B0 size=340
    let mut pc: u32 = 0x82B8C5B0;
    'dispatch: loop {
        match pc {
            0x82B8C5B0 => {
    //   block [0x82B8C5B0..0x82B8C704)
	// 82B8C5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C5B4: 4861BBB1  bl 0x831a8164
	ctx.lr = 0x82B8C5B8;
	sub_831A8130(ctx, base);
	// 82B8C5B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C5BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B8C5C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8C5C4: 93C100C4  stw r30, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 82B8C5C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82B8C5CC: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 82B8C5D0: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 82B8C5D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82B8C5D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C5DC: 4BD928ED  bl 0x8291eec8
	ctx.lr = 0x82B8C5E0;
	sub_8291EEC8(ctx, base);
	// 82B8C5E0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8C5E4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8C5E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8C5EC: 409A00D4  bne cr6, 0x82b8c6c0
	if !ctx.cr[6].eq {
	pc = 0x82B8C6C0; continue 'dispatch;
	}
	// 82B8C5F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C5F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8C5F8: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8C5FC: 38A00166  li r5, 0x166
	ctx.r[5].s64 = 358;
	// 82B8C600: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82B8C604: 48265DE5  bl 0x82df23e8
	ctx.lr = 0x82B8C608;
	sub_82DF23E8(ctx, base);
	// 82B8C608: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8C60C: 41820010  beq 0x82b8c61c
	if ctx.cr[0].eq {
	pc = 0x82B8C61C; continue 'dispatch;
	}
	// 82B8C610: 4BA70961  bl 0x825fcf70
	ctx.lr = 0x82B8C614;
	sub_825FCF70(ctx, base);
	// 82B8C614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C618: 48000008  b 0x82b8c620
	pc = 0x82B8C620; continue 'dispatch;
	// 82B8C61C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8C620: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82B8C624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8C628: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8C62C: 4BA6E6CD  bl 0x825facf8
	ctx.lr = 0x82B8C630;
	sub_825FACF8(ctx, base);
	// 82B8C630: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B8C634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8C638: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8C63C: 4B7339C5  bl 0x822c0000
	ctx.lr = 0x82B8C640;
	sub_822C0000(ctx, base);
	// 82B8C640: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8C644: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8C648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8C64C: 4828AD15  bl 0x82e17360
	ctx.lr = 0x82B8C650;
	sub_82E17360(ctx, base);
	// 82B8C650: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8C654: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82B8C658: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82B8C65C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8C660: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82B8C664: 419A0024  beq cr6, 0x82b8c688
	if ctx.cr[6].eq {
	pc = 0x82B8C688; continue 'dispatch;
	}
	// 82B8C668: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82B8C66C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8C670: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C674: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8C678: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8C67C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8C680: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C684: 4082FFE8  bne 0x82b8c66c
	if !ctx.cr[0].eq {
	pc = 0x82B8C66C; continue 'dispatch;
	}
	// 82B8C688: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8C68C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82B8C690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C694: 4BC4384D  bl 0x827cfee0
	ctx.lr = 0x82B8C698;
	sub_827CFEE0(ctx, base);
	// 82B8C698: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82B8C69C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8C6A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C6A4: 419A000C  beq cr6, 0x82b8c6b0
	if ctx.cr[6].eq {
	pc = 0x82B8C6B0; continue 'dispatch;
	}
	// 82B8C6A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82B8C6AC: 4B7341E5  bl 0x822c0890
	ctx.lr = 0x82B8C6B0;
	sub_822C0890(ctx, base);
	// 82B8C6B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8C6B4: 419A000C  beq cr6, 0x82b8c6c0
	if ctx.cr[6].eq {
	pc = 0x82B8C6C0; continue 'dispatch;
	}
	// 82B8C6B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C6BC: 4B7341D5  bl 0x822c0890
	ctx.lr = 0x82B8C6C0;
	sub_822C0890(ctx, base);
	// 82B8C6C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8C6C4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8C6C8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8C6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8C6D0: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8C6D4: 419A0024  beq cr6, 0x82b8c6f8
	if ctx.cr[6].eq {
	pc = 0x82B8C6F8; continue 'dispatch;
	}
	// 82B8C6D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8C6DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8C6E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C6E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8C6E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8C6EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8C6F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8C6F4: 4082FFE8  bne 0x82b8c6dc
	if !ctx.cr[0].eq {
	pc = 0x82B8C6DC; continue 'dispatch;
	}
	// 82B8C6F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8C6FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B8C700: 4861BAB4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8C708 size=124
    let mut pc: u32 = 0x82B8C708;
    'dispatch: loop {
        match pc {
            0x82B8C708 => {
    //   block [0x82B8C708..0x82B8C784)
	// 82B8C708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8C710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8C714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8C718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C720: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8C724: 4B985C0D  bl 0x82512330
	ctx.lr = 0x82B8C728;
	sub_82512330(ctx, base);
	// 82B8C728: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C72C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8C730: 392B887C  addi r9, r11, -0x7784
	ctx.r[9].s64 = ctx.r[11].s64 + -30596;
	// 82B8C734: 394A8864  addi r10, r10, -0x779c
	ctx.r[10].s64 = ctx.r[10].s64 + -30620;
	// 82B8C738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8C73C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8C740: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82B8C744: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 82B8C748: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82B8C74C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82B8C750: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82B8C754: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82B8C758: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82B8C75C: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82B8C760: 4B8A88B1  bl 0x82435010
	ctx.lr = 0x82B8C764;
	sub_82435010(ctx, base);
	// 82B8C764: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 82B8C768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8C76C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8C770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8C774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8C778: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8C77C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8C780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8C788 size=8
    let mut pc: u32 = 0x82B8C788;
    'dispatch: loop {
        match pc {
            0x82B8C788 => {
    //   block [0x82B8C788..0x82B8C790)
	// 82B8C788: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82B8C78C: 4800006C  b 0x82b8c7f8
	sub_82B8C7F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8C790 size=104
    let mut pc: u32 = 0x82B8C790;
    'dispatch: loop {
        match pc {
            0x82B8C790 => {
    //   block [0x82B8C790..0x82B8C7F8)
	// 82B8C790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8C798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8C79C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C7A4: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 82B8C7A8: 4B740F91  bl 0x822cd738
	ctx.lr = 0x82B8C7AC;
	sub_822CD738(ctx, base);
	// 82B8C7AC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82B8C7B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C7B4: 419A0008  beq cr6, 0x82b8c7bc
	if ctx.cr[6].eq {
	pc = 0x82B8C7BC; continue 'dispatch;
	}
	// 82B8C7B8: 4B7340D9  bl 0x822c0890
	ctx.lr = 0x82B8C7BC;
	sub_822C0890(ctx, base);
	// 82B8C7BC: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82B8C7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C7C4: 419A0008  beq cr6, 0x82b8c7cc
	if ctx.cr[6].eq {
	pc = 0x82B8C7CC; continue 'dispatch;
	}
	// 82B8C7C8: 4B7340C9  bl 0x822c0890
	ctx.lr = 0x82B8C7CC;
	sub_822C0890(ctx, base);
	// 82B8C7CC: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82B8C7D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8C7D4: 419A0008  beq cr6, 0x82b8c7dc
	if ctx.cr[6].eq {
	pc = 0x82B8C7DC; continue 'dispatch;
	}
	// 82B8C7D8: 4B7340B9  bl 0x822c0890
	ctx.lr = 0x82B8C7DC;
	sub_822C0890(ctx, base);
	// 82B8C7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8C7E0: 4B7C2B71  bl 0x8234f350
	ctx.lr = 0x82B8C7E4;
	sub_8234F350(ctx, base);
	// 82B8C7E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8C7E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8C7EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8C7F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8C7F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8C7F8 size=76
    let mut pc: u32 = 0x82B8C7F8;
    'dispatch: loop {
        match pc {
            0x82B8C7F8 => {
    //   block [0x82B8C7F8..0x82B8C844)
	// 82B8C7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8C800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8C804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8C808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8C814: 4BFFFF7D  bl 0x82b8c790
	ctx.lr = 0x82B8C818;
	sub_82B8C790(ctx, base);
	// 82B8C818: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C81C: 4182000C  beq 0x82b8c828
	if ctx.cr[0].eq {
	pc = 0x82B8C828; continue 'dispatch;
	}
	// 82B8C820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8C824: 48265BB5  bl 0x82df23d8
	ctx.lr = 0x82B8C828;
	sub_82DF23D8(ctx, base);
	// 82B8C828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8C82C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8C830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8C834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8C838: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8C83C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8C840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8C848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8C848 size=740
    let mut pc: u32 = 0x82B8C848;
    'dispatch: loop {
        match pc {
            0x82B8C848 => {
    //   block [0x82B8C848..0x82B8CB2C)
	// 82B8C848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8C84C: 4861B911  bl 0x831a815c
	ctx.lr = 0x82B8C850;
	sub_831A8130(ctx, base);
	// 82B8C850: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8C854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8C858: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82B8C85C: 4BFFB8B5  bl 0x82b88110
	ctx.lr = 0x82B8C860;
	sub_82B88110(ctx, base);
	// 82B8C860: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C864: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8C868: 396B893C  addi r11, r11, -0x76c4
	ctx.r[11].s64 = ctx.r[11].s64 + -30404;
	// 82B8C86C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82B8C870: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8C874: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82B8C878: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82B8C87C: 4BC0F37D  bl 0x8279bbf8
	ctx.lr = 0x82B8C880;
	sub_8279BBF8(ctx, base);
	// 82B8C880: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82B8C884: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82B8C888: 3B9F003C  addi r28, r31, 0x3c
	ctx.r[28].s64 = ctx.r[31].s64 + 60;
	// 82B8C88C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B8C890: 48266861  bl 0x82df30f0
	ctx.lr = 0x82B8C894;
	sub_82DF30F0(ctx, base);
	// 82B8C894: 3B7F0040  addi r27, r31, 0x40
	ctx.r[27].s64 = ctx.r[31].s64 + 64;
	// 82B8C898: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8C89C: 48266855  bl 0x82df30f0
	ctx.lr = 0x82B8C8A0;
	sub_82DF30F0(ctx, base);
	// 82B8C8A0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82B8C8A4: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82B8C8A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C8AC: 9BDF0029  stb r30, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[30].u8 ) };
	// 82B8C8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C8B4: 9BDF002A  stb r30, 0x2a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[30].u8 ) };
	// 82B8C8B8: 388B892C  addi r4, r11, -0x76d4
	ctx.r[4].s64 = ctx.r[11].s64 + -30420;
	// 82B8C8BC: 9BDF002B  stb r30, 0x2b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(43 as u32), ctx.r[30].u8 ) };
	// 82B8C8C0: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 82B8C8C4: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82B8C8C8: 9B5F002F  stb r26, 0x2f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(47 as u32), ctx.r[26].u8 ) };
	// 82B8C8CC: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82B8C8D0: 48267139  bl 0x82df3a08
	ctx.lr = 0x82B8C8D4;
	sub_82DF3A08(ctx, base);
	// 82B8C8D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C8DC: 48266A2D  bl 0x82df3308
	ctx.lr = 0x82B8C8E0;
	sub_82DF3308(ctx, base);
	// 82B8C8E0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8C8E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C8E8: 48266B41  bl 0x82df3428
	ctx.lr = 0x82B8C8EC;
	sub_82DF3428(ctx, base);
	// 82B8C8EC: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C8F0: 4182000C  beq 0x82b8c8fc
	if ctx.cr[0].eq {
	pc = 0x82B8C8FC; continue 'dispatch;
	}
	// 82B8C8F4: 9B5F0029  stb r26, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[26].u8 ) };
	// 82B8C8F8: 48000208  b 0x82b8cb00
	pc = 0x82B8CB00; continue 'dispatch;
	// 82B8C8FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8C900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C904: 388B0790  addi r4, r11, 0x790
	ctx.r[4].s64 = ctx.r[11].s64 + 1936;
	// 82B8C908: 48267101  bl 0x82df3a08
	ctx.lr = 0x82B8C90C;
	sub_82DF3A08(ctx, base);
	// 82B8C90C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C914: 482669F5  bl 0x82df3308
	ctx.lr = 0x82B8C918;
	sub_82DF3308(ctx, base);
	// 82B8C918: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8C91C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C920: 48266B09  bl 0x82df3428
	ctx.lr = 0x82B8C924;
	sub_82DF3428(ctx, base);
	// 82B8C924: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C928: 4182000C  beq 0x82b8c934
	if ctx.cr[0].eq {
	pc = 0x82B8C934; continue 'dispatch;
	}
	// 82B8C92C: 9B5F002A  stb r26, 0x2a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[26].u8 ) };
	// 82B8C930: 480001D0  b 0x82b8cb00
	pc = 0x82B8CB00; continue 'dispatch;
	// 82B8C934: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C93C: 388B8920  addi r4, r11, -0x76e0
	ctx.r[4].s64 = ctx.r[11].s64 + -30432;
	// 82B8C940: 482670C9  bl 0x82df3a08
	ctx.lr = 0x82B8C944;
	sub_82DF3A08(ctx, base);
	// 82B8C944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C94C: 482669BD  bl 0x82df3308
	ctx.lr = 0x82B8C950;
	sub_82DF3308(ctx, base);
	// 82B8C950: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8C954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C958: 48266AD1  bl 0x82df3428
	ctx.lr = 0x82B8C95C;
	sub_82DF3428(ctx, base);
	// 82B8C95C: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C960: 4182000C  beq 0x82b8c96c
	if ctx.cr[0].eq {
	pc = 0x82B8C96C; continue 'dispatch;
	}
	// 82B8C964: 9B5F002B  stb r26, 0x2b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(43 as u32), ctx.r[26].u8 ) };
	// 82B8C968: 48000198  b 0x82b8cb00
	pc = 0x82B8CB00; continue 'dispatch;
	// 82B8C96C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C974: 388B8910  addi r4, r11, -0x76f0
	ctx.r[4].s64 = ctx.r[11].s64 + -30448;
	// 82B8C978: 48267091  bl 0x82df3a08
	ctx.lr = 0x82B8C97C;
	sub_82DF3A08(ctx, base);
	// 82B8C97C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C980: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C984: 48266985  bl 0x82df3308
	ctx.lr = 0x82B8C988;
	sub_82DF3308(ctx, base);
	// 82B8C988: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8C98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C990: 48266A99  bl 0x82df3428
	ctx.lr = 0x82B8C994;
	sub_82DF3428(ctx, base);
	// 82B8C994: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C998: 41820010  beq 0x82b8c9a8
	if ctx.cr[0].eq {
	pc = 0x82B8C9A8; continue 'dispatch;
	}
	// 82B8C99C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82B8C9A0: 388BE268  addi r4, r11, -0x1d98
	ctx.r[4].s64 = ctx.r[11].s64 + -7576;
	// 82B8C9A4: 480000F0  b 0x82b8ca94
	pc = 0x82B8CA94; continue 'dispatch;
	// 82B8C9A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C9AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C9B0: 388B8900  addi r4, r11, -0x7700
	ctx.r[4].s64 = ctx.r[11].s64 + -30464;
	// 82B8C9B4: 48267055  bl 0x82df3a08
	ctx.lr = 0x82B8C9B8;
	sub_82DF3A08(ctx, base);
	// 82B8C9B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C9BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C9C0: 48266949  bl 0x82df3308
	ctx.lr = 0x82B8C9C4;
	sub_82DF3308(ctx, base);
	// 82B8C9C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8C9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C9CC: 48266A5D  bl 0x82df3428
	ctx.lr = 0x82B8C9D0;
	sub_82DF3428(ctx, base);
	// 82B8C9D0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8C9D4: 41820010  beq 0x82b8c9e4
	if ctx.cr[0].eq {
	pc = 0x82B8C9E4; continue 'dispatch;
	}
	// 82B8C9D8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82B8C9DC: 388BE270  addi r4, r11, -0x1d90
	ctx.r[4].s64 = ctx.r[11].s64 + -7568;
	// 82B8C9E0: 480000B4  b 0x82b8ca94
	pc = 0x82B8CA94; continue 'dispatch;
	// 82B8C9E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8C9E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8C9EC: 388B88F0  addi r4, r11, -0x7710
	ctx.r[4].s64 = ctx.r[11].s64 + -30480;
	// 82B8C9F0: 48267019  bl 0x82df3a08
	ctx.lr = 0x82B8C9F4;
	sub_82DF3A08(ctx, base);
	// 82B8C9F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8C9F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8C9FC: 4826690D  bl 0x82df3308
	ctx.lr = 0x82B8CA00;
	sub_82DF3308(ctx, base);
	// 82B8CA00: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8CA04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CA08: 48266A21  bl 0x82df3428
	ctx.lr = 0x82B8CA0C;
	sub_82DF3428(ctx, base);
	// 82B8CA0C: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CA10: 41820010  beq 0x82b8ca20
	if ctx.cr[0].eq {
	pc = 0x82B8CA20; continue 'dispatch;
	}
	// 82B8CA14: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82B8CA18: 388BE288  addi r4, r11, -0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + -7544;
	// 82B8CA1C: 48000078  b 0x82b8ca94
	pc = 0x82B8CA94; continue 'dispatch;
	// 82B8CA20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CA24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CA28: 388B88E0  addi r4, r11, -0x7720
	ctx.r[4].s64 = ctx.r[11].s64 + -30496;
	// 82B8CA2C: 48266FDD  bl 0x82df3a08
	ctx.lr = 0x82B8CA30;
	sub_82DF3A08(ctx, base);
	// 82B8CA30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8CA34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8CA38: 482668D1  bl 0x82df3308
	ctx.lr = 0x82B8CA3C;
	sub_82DF3308(ctx, base);
	// 82B8CA3C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8CA40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CA44: 482669E5  bl 0x82df3428
	ctx.lr = 0x82B8CA48;
	sub_82DF3428(ctx, base);
	// 82B8CA48: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CA4C: 41820010  beq 0x82b8ca5c
	if ctx.cr[0].eq {
	pc = 0x82B8CA5C; continue 'dispatch;
	}
	// 82B8CA50: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82B8CA54: 388BE290  addi r4, r11, -0x1d70
	ctx.r[4].s64 = ctx.r[11].s64 + -7536;
	// 82B8CA58: 4800003C  b 0x82b8ca94
	pc = 0x82B8CA94; continue 'dispatch;
	// 82B8CA5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CA64: 388B88D0  addi r4, r11, -0x7730
	ctx.r[4].s64 = ctx.r[11].s64 + -30512;
	// 82B8CA68: 48266FA1  bl 0x82df3a08
	ctx.lr = 0x82B8CA6C;
	sub_82DF3A08(ctx, base);
	// 82B8CA6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8CA70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8CA74: 48266895  bl 0x82df3308
	ctx.lr = 0x82B8CA78;
	sub_82DF3308(ctx, base);
	// 82B8CA78: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8CA7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CA80: 482669A9  bl 0x82df3428
	ctx.lr = 0x82B8CA84;
	sub_82DF3428(ctx, base);
	// 82B8CA84: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CA88: 41820044  beq 0x82b8cacc
	if ctx.cr[0].eq {
	pc = 0x82B8CACC; continue 'dispatch;
	}
	// 82B8CA8C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82B8CA90: 388BE27C  addi r4, r11, -0x1d84
	ctx.r[4].s64 = ctx.r[11].s64 + -7556;
	// 82B8CA94: 9B5F002C  stb r26, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 82B8CA98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B8CA9C: 48266DDD  bl 0x82df3878
	ctx.lr = 0x82B8CAA0;
	sub_82DF3878(ctx, base);
	// 82B8CAA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82B8CAA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8CAA8: 38ABD484  addi r5, r11, -0x2b7c
	ctx.r[5].s64 = ctx.r[11].s64 + -11132;
	// 82B8CAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CAB0: 48267249  bl 0x82df3cf8
	ctx.lr = 0x82B8CAB4;
	sub_82DF3CF8(ctx, base);
	// 82B8CAB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8CAB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8CABC: 48267115  bl 0x82df3bd0
	ctx.lr = 0x82B8CAC0;
	sub_82DF3BD0(ctx, base);
	// 82B8CAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CAC4: 48266965  bl 0x82df3428
	ctx.lr = 0x82B8CAC8;
	sub_82DF3428(ctx, base);
	// 82B8CAC8: 48000038  b 0x82b8cb00
	pc = 0x82B8CB00; continue 'dispatch;
	// 82B8CACC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CAD4: 388B88B8  addi r4, r11, -0x7748
	ctx.r[4].s64 = ctx.r[11].s64 + -30536;
	// 82B8CAD8: 48266F31  bl 0x82df3a08
	ctx.lr = 0x82B8CADC;
	sub_82DF3A08(ctx, base);
	// 82B8CADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8CAE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8CAE4: 48266825  bl 0x82df3308
	ctx.lr = 0x82B8CAE8;
	sub_82DF3308(ctx, base);
	// 82B8CAE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B8CAEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CAF0: 48266939  bl 0x82df3428
	ctx.lr = 0x82B8CAF4;
	sub_82DF3428(ctx, base);
	// 82B8CAF4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CAF8: 41820008  beq 0x82b8cb00
	if ctx.cr[0].eq {
	pc = 0x82B8CB00; continue 'dispatch;
	}
	// 82B8CAFC: 9BDF002F  stb r30, 0x2f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(47 as u32), ctx.r[30].u8 ) };
	// 82B8CB00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8CB04: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CB08: 48002D49  bl 0x82b8f850
	ctx.lr = 0x82B8CB0C;
	sub_82B8F850(ctx, base);
	// 82B8CB0C: 987F002D  stb r3, 0x2d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(45 as u32), ctx.r[3].u8 ) };
	// 82B8CB10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8CB14: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CB18: 48002D89  bl 0x82b8f8a0
	ctx.lr = 0x82B8CB1C;
	sub_82B8F8A0(ctx, base);
	// 82B8CB1C: 987F002E  stb r3, 0x2e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(46 as u32), ctx.r[3].u8 ) };
	// 82B8CB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8CB24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B8CB28: 4861B684  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8CB30 size=104
    let mut pc: u32 = 0x82B8CB30;
    'dispatch: loop {
        match pc {
            0x82B8CB30 => {
    //   block [0x82B8CB30..0x82B8CB98)
	// 82B8CB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CB3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CB40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CB44: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82B8CB48: 482668E1  bl 0x82df3428
	ctx.lr = 0x82B8CB4C;
	sub_82DF3428(ctx, base);
	// 82B8CB4C: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82B8CB50: 482668D9  bl 0x82df3428
	ctx.lr = 0x82B8CB54;
	sub_82DF3428(ctx, base);
	// 82B8CB54: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82B8CB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8CB5C: 419A0008  beq cr6, 0x82b8cb64
	if ctx.cr[6].eq {
	pc = 0x82B8CB64; continue 'dispatch;
	}
	// 82B8CB60: 4B733D31  bl 0x822c0890
	ctx.lr = 0x82B8CB64;
	sub_822C0890(ctx, base);
	// 82B8CB64: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82B8CB68: 4BF60791  bl 0x82aed2f8
	ctx.lr = 0x82B8CB6C;
	sub_82AED2F8(ctx, base);
	// 82B8CB6C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8CB70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8CB74: 419A0008  beq cr6, 0x82b8cb7c
	if ctx.cr[6].eq {
	pc = 0x82B8CB7C; continue 'dispatch;
	}
	// 82B8CB78: 4B733D19  bl 0x822c0890
	ctx.lr = 0x82B8CB7C;
	sub_822C0890(ctx, base);
	// 82B8CB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8CB80: 4BFFB5B9  bl 0x82b88138
	ctx.lr = 0x82B8CB84;
	sub_82B88138(ctx, base);
	// 82B8CB84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8CB88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8CB8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8CB90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8CB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8CB98 size=76
    let mut pc: u32 = 0x82B8CB98;
    'dispatch: loop {
        match pc {
            0x82B8CB98 => {
    //   block [0x82B8CB98..0x82B8CBE4)
	// 82B8CB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CBA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8CBA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CBA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CBB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8CBB4: 4BFFFF7D  bl 0x82b8cb30
	ctx.lr = 0x82B8CBB8;
	sub_82B8CB30(ctx, base);
	// 82B8CBB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CBBC: 4182000C  beq 0x82b8cbc8
	if ctx.cr[0].eq {
	pc = 0x82B8CBC8; continue 'dispatch;
	}
	// 82B8CBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8CBC4: 48265815  bl 0x82df23d8
	ctx.lr = 0x82B8CBC8;
	sub_82DF23D8(ctx, base);
	// 82B8CBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8CBCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8CBD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8CBD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8CBD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8CBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8CBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8CBE8 size=668
    let mut pc: u32 = 0x82B8CBE8;
    'dispatch: loop {
        match pc {
            0x82B8CBE8 => {
    //   block [0x82B8CBE8..0x82B8CE84)
	// 82B8CBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CBEC: 4861B579  bl 0x831a8164
	ctx.lr = 0x82B8CBF0;
	sub_831A8130(ctx, base);
	// 82B8CBF0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CBF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CBF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CBFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8CC00: 388B87F0  addi r4, r11, -0x7810
	ctx.r[4].s64 = ctx.r[11].s64 + -30736;
	// 82B8CC04: 38A000EB  li r5, 0xeb
	ctx.r[5].s64 = 235;
	// 82B8CC08: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 82B8CC0C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82B8CC10: 482657D9  bl 0x82df23e8
	ctx.lr = 0x82B8CC14;
	sub_82DF23E8(ctx, base);
	// 82B8CC14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8CC18: 41820014  beq 0x82b8cc2c
	if ctx.cr[0].eq {
	pc = 0x82B8CC2C; continue 'dispatch;
	}
	// 82B8CC1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8CC20: 4BFFFAE9  bl 0x82b8c708
	ctx.lr = 0x82B8CC24;
	sub_82B8C708(ctx, base);
	// 82B8CC24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8CC28: 48000008  b 0x82b8cc30
	pc = 0x82B8CC30; continue 'dispatch;
	// 82B8CC2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B8CC30: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 82B8CC34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8CC38: 4BFFED99  bl 0x82b8b9d0
	ctx.lr = 0x82B8CC3C;
	sub_82B8B9D0(ctx, base);
	// 82B8CC3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8CC40: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CC44: 4B982885  bl 0x8250f4c8
	ctx.lr = 0x82B8CC48;
	sub_8250F4C8(ctx, base);
	// 82B8CC48: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82B8CC4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8CC50: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82B8CC54: 48266DB5  bl 0x82df3a08
	ctx.lr = 0x82B8CC58;
	sub_82DF3A08(ctx, base);
	// 82B8CC58: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8CC5C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8CC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8CC64: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B8CC68: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82B8CC6C: 419A0024  beq cr6, 0x82b8cc90
	if ctx.cr[6].eq {
	pc = 0x82B8CC90; continue 'dispatch;
	}
	// 82B8CC70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8CC74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8CC78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8CC7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8CC80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8CC84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8CC88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8CC8C: 4082FFE8  bne 0x82b8cc74
	if !ctx.cr[0].eq {
	pc = 0x82B8CC74; continue 'dispatch;
	}
	// 82B8CC90: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8CC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8CC98: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8CC9C: 409A000C  bne cr6, 0x82b8cca8
	if !ctx.cr[6].eq {
	pc = 0x82B8CCA8; continue 'dispatch;
	}
	// 82B8CCA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B8CCA4: 419A000C  beq cr6, 0x82b8ccb0
	if ctx.cr[6].eq {
	pc = 0x82B8CCB0; continue 'dispatch;
	}
	// 82B8CCA8: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82B8CCAC: 48000008  b 0x82b8ccb4
	pc = 0x82B8CCB4; continue 'dispatch;
	// 82B8CCB0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82B8CCB4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82B8CCB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8CCBC: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 82B8CCC0: 4B97E991  bl 0x8250b650
	ctx.lr = 0x82B8CCC4;
	sub_8250B650(ctx, base);
	// 82B8CCC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8CCC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8CCCC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82B8CCD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8CCD4: 4B980835  bl 0x8250d508
	ctx.lr = 0x82B8CCD8;
	sub_8250D508(ctx, base);
	// 82B8CCD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8CCDC: 48264FB5  bl 0x82df1c90
	ctx.lr = 0x82B8CCE0;
	sub_82DF1C90(ctx, base);
	// 82B8CCE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8CCE4: 48266745  bl 0x82df3428
	ctx.lr = 0x82B8CCE8;
	sub_82DF3428(ctx, base);
	// 82B8CCE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8CCEC: 48264FA5  bl 0x82df1c90
	ctx.lr = 0x82B8CCF0;
	sub_82DF1C90(ctx, base);
	// 82B8CCF0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8CCF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8CCF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8CCFC: 48000028  b 0x82b8cd24
	pc = 0x82B8CD24; continue 'dispatch;
	// 82B8CD00: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8CD04: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 82B8CD08: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8CD0C: 806A00E4  lwz r3, 0xe4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(228 as u32) ) } as u64;
	// 82B8CD10: 48289B31  bl 0x82e16840
	ctx.lr = 0x82B8CD14;
	sub_82E16840(ctx, base);
	// 82B8CD14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8CD18: 4B814971  bl 0x823a1688
	ctx.lr = 0x82B8CD1C;
	sub_823A1688(ctx, base);
	// 82B8CD1C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8CD20: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8CD24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B8CD28: 409AFFD8  bne cr6, 0x82b8cd00
	if !ctx.cr[6].eq {
	pc = 0x82B8CD00; continue 'dispatch;
	}
	// 82B8CD2C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8CD30: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CD34: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82B8CD38: 48002A81  bl 0x82b8f7b8
	ctx.lr = 0x82B8CD3C;
	sub_82B8F7B8(ctx, base);
	// 82B8CD3C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82B8CD40: 987F0028  stb r3, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u8 ) };
	// 82B8CD44: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B8CD48: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8CD4C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CD50: 480018B9  bl 0x82b8e608
	ctx.lr = 0x82B8CD54;
	sub_82B8E608(ctx, base);
	// 82B8CD54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8CD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CD5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8CD60: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 82B8CD64: 48266E9D  bl 0x82df3c00
	ctx.lr = 0x82B8CD68;
	sub_82DF3C00(ctx, base);
	// 82B8CD68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CD6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8CD70: 388B8988  addi r4, r11, -0x7678
	ctx.r[4].s64 = ctx.r[11].s64 + -30328;
	// 82B8CD74: 48266C95  bl 0x82df3a08
	ctx.lr = 0x82B8CD78;
	sub_82DF3A08(ctx, base);
	// 82B8CD78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B8CD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CD80: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82B8CD84: 48266585  bl 0x82df3308
	ctx.lr = 0x82B8CD88;
	sub_82DF3308(ctx, base);
	// 82B8CD88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CD8C: 40820080  bne 0x82b8ce0c
	if !ctx.cr[0].eq {
	pc = 0x82B8CE0C; continue 'dispatch;
	}
	// 82B8CD90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CD94: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82B8CD98: 388B897C  addi r4, r11, -0x7684
	ctx.r[4].s64 = ctx.r[11].s64 + -30340;
	// 82B8CD9C: 48266C6D  bl 0x82df3a08
	ctx.lr = 0x82B8CDA0;
	sub_82DF3A08(ctx, base);
	// 82B8CDA0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82B8CDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CDA8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82B8CDAC: 4826655D  bl 0x82df3308
	ctx.lr = 0x82B8CDB0;
	sub_82DF3308(ctx, base);
	// 82B8CDB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CDB4: 40820058  bne 0x82b8ce0c
	if !ctx.cr[0].eq {
	pc = 0x82B8CE0C; continue 'dispatch;
	}
	// 82B8CDB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CDBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8CDC0: 388B8970  addi r4, r11, -0x7690
	ctx.r[4].s64 = ctx.r[11].s64 + -30352;
	// 82B8CDC4: 48266C45  bl 0x82df3a08
	ctx.lr = 0x82B8CDC8;
	sub_82DF3A08(ctx, base);
	// 82B8CDC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82B8CDCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CDD0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82B8CDD4: 48266535  bl 0x82df3308
	ctx.lr = 0x82B8CDD8;
	sub_82DF3308(ctx, base);
	// 82B8CDD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CDDC: 40820030  bne 0x82b8ce0c
	if !ctx.cr[0].eq {
	pc = 0x82B8CE0C; continue 'dispatch;
	}
	// 82B8CDE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CDE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8CDE8: 388B8964  addi r4, r11, -0x769c
	ctx.r[4].s64 = ctx.r[11].s64 + -30364;
	// 82B8CDEC: 48266C1D  bl 0x82df3a08
	ctx.lr = 0x82B8CDF0;
	sub_82DF3A08(ctx, base);
	// 82B8CDF0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8CDF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CDF8: 3BC0000F  li r30, 0xf
	ctx.r[30].s64 = 15;
	// 82B8CDFC: 4826650D  bl 0x82df3308
	ctx.lr = 0x82B8CE00;
	sub_82DF3308(ctx, base);
	// 82B8CE00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CE04: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82B8CE08: 41820008  beq 0x82b8ce10
	if ctx.cr[0].eq {
	pc = 0x82B8CE10; continue 'dispatch;
	}
	// 82B8CE0C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82B8CE10: 57CA0739  rlwinm. r10, r30, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82B8CE14: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82B8CE18: 41820010  beq 0x82b8ce28
	if ctx.cr[0].eq {
	pc = 0x82B8CE28; continue 'dispatch;
	}
	// 82B8CE1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8CE20: 57DE0776  rlwinm r30, r30, 0, 0x1d, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82B8CE24: 48266605  bl 0x82df3428
	ctx.lr = 0x82B8CE28;
	sub_82DF3428(ctx, base);
	// 82B8CE28: 57CB077B  rlwinm. r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CE2C: 41820010  beq 0x82b8ce3c
	if ctx.cr[0].eq {
	pc = 0x82B8CE3C; continue 'dispatch;
	}
	// 82B8CE30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8CE34: 57DE07B8  rlwinm r30, r30, 0, 0x1e, 0x1c
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82B8CE38: 482665F1  bl 0x82df3428
	ctx.lr = 0x82B8CE3C;
	sub_82DF3428(ctx, base);
	// 82B8CE3C: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CE40: 41820010  beq 0x82b8ce50
	if ctx.cr[0].eq {
	pc = 0x82B8CE50; continue 'dispatch;
	}
	// 82B8CE44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82B8CE48: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82B8CE4C: 482665DD  bl 0x82df3428
	ctx.lr = 0x82B8CE50;
	sub_82DF3428(ctx, base);
	// 82B8CE50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CE54: 4182000C  beq 0x82b8ce60
	if ctx.cr[0].eq {
	pc = 0x82B8CE60; continue 'dispatch;
	}
	// 82B8CE58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8CE5C: 482665CD  bl 0x82df3428
	ctx.lr = 0x82B8CE60;
	sub_82DF3428(ctx, base);
	// 82B8CE60: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CE64: 4182000C  beq 0x82b8ce70
	if ctx.cr[0].eq {
	pc = 0x82B8CE70; continue 'dispatch;
	}
	// 82B8CE68: 9B9F0030  stb r28, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[28].u8 ) };
	// 82B8CE6C: 48000008  b 0x82b8ce74
	pc = 0x82B8CE74; continue 'dispatch;
	// 82B8CE70: 9B7F0030  stb r27, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 82B8CE74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8CE78: 482665B1  bl 0x82df3428
	ctx.lr = 0x82B8CE7C;
	sub_82DF3428(ctx, base);
	// 82B8CE7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B8CE80: 4861B334  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8CE88 size=88
    let mut pc: u32 = 0x82B8CE88;
    'dispatch: loop {
        match pc {
            0x82B8CE88 => {
    //   block [0x82B8CE88..0x82B8CEE0)
	// 82B8CE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CE90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CE94: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8CE98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CE9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CEA0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8CEA4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8CEA8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CEAC: 4800188D  bl 0x82b8e738
	ctx.lr = 0x82B8CEB0;
	sub_82B8E738(ctx, base);
	// 82B8CEB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CEB4: 41820008  beq 0x82b8cebc
	if ctx.cr[0].eq {
	pc = 0x82B8CEBC; continue 'dispatch;
	}
	// 82B8CEB8: D3FF001C  stfs f31, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82B8CEBC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8CEC0: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82B8CEC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8CEC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8CECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8CED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8CED4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8CED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8CEDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8CEE0 size=168
    let mut pc: u32 = 0x82B8CEE0;
    'dispatch: loop {
        match pc {
            0x82B8CEE0 => {
    //   block [0x82B8CEE0..0x82B8CF88)
	// 82B8CEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8CEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CEF0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82B8CEF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CEFC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8CF00: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CF04: 48001835  bl 0x82b8e738
	ctx.lr = 0x82B8CF08;
	sub_82B8E738(ctx, base);
	// 82B8CF08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8CF0C: 41820060  beq 0x82b8cf6c
	if ctx.cr[0].eq {
	pc = 0x82B8CF6C; continue 'dispatch;
	}
	// 82B8CF10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8CF14: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8CF18: 409A0054  bne cr6, 0x82b8cf6c
	if !ctx.cr[6].eq {
	pc = 0x82B8CF6C; continue 'dispatch;
	}
	// 82B8CF1C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8CF20: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8CF24: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8CF28: 48001799  bl 0x82b8e6c0
	ctx.lr = 0x82B8CF2C;
	sub_82B8E6C0(ctx, base);
	// 82B8CF2C: C01F001C  lfs f0, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8CF30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8CF34: EFE10028  fsubs f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8CF38: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8CF3C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82B8CF40: 40980008  bge cr6, 0x82b8cf48
	if !ctx.cr[6].lt {
	pc = 0x82B8CF48; continue 'dispatch;
	}
	// 82B8CF44: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82B8CF48: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8CF4C: 4BFFE17D  bl 0x82b8b0c8
	ctx.lr = 0x82B8CF50;
	sub_82B8B0C8(ctx, base);
	// 82B8CF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8CF54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8CF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8CF5C: 4E800421  bctrl
	ctx.lr = 0x82B8CF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8CF60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8CF64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8CF68: 482B2E91  bl 0x82e3fdf8
	ctx.lr = 0x82B8CF6C;
	sub_82E3FDF8(ctx, base);
	// 82B8CF6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8CF70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8CF74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8CF78: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82B8CF7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8CF80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8CF84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8CF88 size=84
    let mut pc: u32 = 0x82B8CF88;
    'dispatch: loop {
        match pc {
            0x82B8CF88 => {
    //   block [0x82B8CF88..0x82B8CFDC)
	// 82B8CF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CF8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CF90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CF94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CF98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CF9C: 4BFFB175  bl 0x82b88110
	ctx.lr = 0x82B8CFA0;
	sub_82B88110(ctx, base);
	// 82B8CFA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8CFA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8CFA8: 392B8998  addi r9, r11, -0x7668
	ctx.r[9].s64 = ctx.r[11].s64 + -30312;
	// 82B8CFAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8CFB0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8CFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8CFB8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8CFBC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8CFC0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8CFC4: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82B8CFC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8CFCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8CFD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8CFD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8CFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8CFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8CFE0 size=160
    let mut pc: u32 = 0x82B8CFE0;
    'dispatch: loop {
        match pc {
            0x82B8CFE0 => {
    //   block [0x82B8CFE0..0x82B8D080)
	// 82B8CFE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8CFE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8CFE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8CFEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8CFF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8CFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8CFF8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8CFFC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D000: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D004: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8D008: 480015E1  bl 0x82b8e5e8
	ctx.lr = 0x82B8D00C;
	sub_82B8E5E8(ctx, base);
	// 82B8D00C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8D010: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D014: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8D018: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82B8D01C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8D020: 419A0024  beq cr6, 0x82b8d044
	if ctx.cr[6].eq {
	pc = 0x82B8D044; continue 'dispatch;
	}
	// 82B8D024: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 82B8D028: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82B8D02C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D030: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82B8D034: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82B8D038: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8D03C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D040: 4082FFE8  bne 0x82b8d028
	if !ctx.cr[0].eq {
	pc = 0x82B8D028; continue 'dispatch;
	}
	// 82B8D044: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D048: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82B8D04C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8D050: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B8D054: 4B73740D  bl 0x822c4460
	ctx.lr = 0x82B8D058;
	sub_822C4460(ctx, base);
	// 82B8D058: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8D05C: 419A000C  beq cr6, 0x82b8d068
	if ctx.cr[6].eq {
	pc = 0x82B8D068; continue 'dispatch;
	}
	// 82B8D060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8D064: 4B73382D  bl 0x822c0890
	ctx.lr = 0x82B8D068;
	sub_822C0890(ctx, base);
	// 82B8D068: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D06C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D074: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8D080 size=128
    let mut pc: u32 = 0x82B8D080;
    'dispatch: loop {
        match pc {
            0x82B8D080 => {
    //   block [0x82B8D080..0x82B8D100)
	// 82B8D080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D08C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8D090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D098: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8D09C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D0A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D0A4: 48001695  bl 0x82b8e738
	ctx.lr = 0x82B8D0A8;
	sub_82B8E738(ctx, base);
	// 82B8D0A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D0AC: 41820034  beq 0x82b8d0e0
	if ctx.cr[0].eq {
	pc = 0x82B8D0E0; continue 'dispatch;
	}
	// 82B8D0B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D0B4: 4800160D  bl 0x82b8e6c0
	ctx.lr = 0x82B8D0B8;
	sub_82B8E6C0(ctx, base);
	// 82B8D0B8: EC21F828  fsubs f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[31].f64) as f32) as f64);
	// 82B8D0BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8D0C0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8D0C4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82B8D0C8: 40980008  bge cr6, 0x82b8d0d0
	if !ctx.cr[6].lt {
	pc = 0x82B8D0D0; continue 'dispatch;
	}
	// 82B8D0CC: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82B8D0D0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D0D4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8D0D8: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82B8D0DC: 4BFFF4CD  bl 0x82b8c5a8
	ctx.lr = 0x82B8D0E0;
	sub_82B8C5A8(ctx, base);
	// 82B8D0E0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8D0E4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8D0E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D0EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D0F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D0F4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D0F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D100 size=72
    let mut pc: u32 = 0x82B8D100;
    'dispatch: loop {
        match pc {
            0x82B8D100 => {
    //   block [0x82B8D100..0x82B8D148)
	// 82B8D100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D108: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D10C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D114: 4BFFAFFD  bl 0x82b88110
	ctx.lr = 0x82B8D118;
	sub_82B88110(ctx, base);
	// 82B8D118: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8D11C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8D120: 394A89C4  addi r10, r10, -0x763c
	ctx.r[10].s64 = ctx.r[10].s64 + -30268;
	// 82B8D124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D128: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8D12C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D130: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8D134: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8D138: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D13C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8D148 size=32
    let mut pc: u32 = 0x82B8D148;
    'dispatch: loop {
        match pc {
            0x82B8D148 => {
    //   block [0x82B8D148..0x82B8D168)
	// 82B8D148: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8D14C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82B8D150: 394B0014  addi r10, r11, 0x14
	ctx.r[10].s64 = ctx.r[11].s64 + 20;
	// 82B8D154: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82B8D158: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8D15C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D160: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82B8D164: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8D168 size=8
    let mut pc: u32 = 0x82B8D168;
    'dispatch: loop {
        match pc {
            0x82B8D168 => {
    //   block [0x82B8D168..0x82B8D170)
	// 82B8D168: 4B733728  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 82B8D16C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D170 size=160
    let mut pc: u32 = 0x82B8D170;
    'dispatch: loop {
        match pc {
            0x82B8D170 => {
    //   block [0x82B8D170..0x82B8D210)
	// 82B8D170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8D17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D188: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D18C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D190: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D194: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D198: 48001451  bl 0x82b8e5e8
	ctx.lr = 0x82B8D19C;
	sub_82B8E5E8(ctx, base);
	// 82B8D19C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8D1A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D1A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8D1A8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82B8D1AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8D1B0: 419A0024  beq cr6, 0x82b8d1d4
	if ctx.cr[6].eq {
	pc = 0x82B8D1D4; continue 'dispatch;
	}
	// 82B8D1B4: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 82B8D1B8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82B8D1BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D1C0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82B8D1C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82B8D1C8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8D1CC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D1D0: 4082FFE8  bne 0x82b8d1b8
	if !ctx.cr[0].eq {
	pc = 0x82B8D1B8; continue 'dispatch;
	}
	// 82B8D1D4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D1D8: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82B8D1DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8D1E0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B8D1E4: 4B73727D  bl 0x822c4460
	ctx.lr = 0x82B8D1E8;
	sub_822C4460(ctx, base);
	// 82B8D1E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8D1EC: 419A000C  beq cr6, 0x82b8d1f8
	if ctx.cr[6].eq {
	pc = 0x82B8D1F8; continue 'dispatch;
	}
	// 82B8D1F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8D1F4: 4B73369D  bl 0x822c0890
	ctx.lr = 0x82B8D1F8;
	sub_822C0890(ctx, base);
	// 82B8D1F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D1FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D204: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D20C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D210 size=60
    let mut pc: u32 = 0x82B8D210;
    'dispatch: loop {
        match pc {
            0x82B8D210 => {
    //   block [0x82B8D210..0x82B8D24C)
	// 82B8D210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D21C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D224: 4BFFAEED  bl 0x82b88110
	ctx.lr = 0x82B8D228;
	sub_82B88110(ctx, base);
	// 82B8D228: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8D22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D230: 396B89F0  addi r11, r11, -0x7610
	ctx.r[11].s64 = ctx.r[11].s64 + -30224;
	// 82B8D234: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8D238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8D23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D250 size=76
    let mut pc: u32 = 0x82B8D250;
    'dispatch: loop {
        match pc {
            0x82B8D250 => {
    //   block [0x82B8D250..0x82B8D29C)
	// 82B8D250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8D25C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D268: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8D26C: 4BFFAECD  bl 0x82b88138
	ctx.lr = 0x82B8D270;
	sub_82B88138(ctx, base);
	// 82B8D270: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D274: 4182000C  beq 0x82b8d280
	if ctx.cr[0].eq {
	pc = 0x82B8D280; continue 'dispatch;
	}
	// 82B8D278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D27C: 4826515D  bl 0x82df23d8
	ctx.lr = 0x82B8D280;
	sub_82DF23D8(ctx, base);
	// 82B8D280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D284: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D28C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D290: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D294: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D2A0 size=108
    let mut pc: u32 = 0x82B8D2A0;
    'dispatch: loop {
        match pc {
            0x82B8D2A0 => {
    //   block [0x82B8D2A0..0x82B8D30C)
	// 82B8D2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D2AC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8D2B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D2B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D2B8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8D2BC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D2C0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D2C4: 48001475  bl 0x82b8e738
	ctx.lr = 0x82B8D2C8;
	sub_82B8E738(ctx, base);
	// 82B8D2C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D2CC: 41820020  beq 0x82b8d2ec
	if ctx.cr[0].eq {
	pc = 0x82B8D2EC; continue 'dispatch;
	}
	// 82B8D2D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D2D4: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8D2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D2DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8D2E0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8D2E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8D2E8: 4E800421  bctrl
	ctx.lr = 0x82B8D2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8D2EC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8D2F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8D2F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D2F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D2FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D300: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D310 size=108
    let mut pc: u32 = 0x82B8D310;
    'dispatch: loop {
        match pc {
            0x82B8D310 => {
    //   block [0x82B8D310..0x82B8D37C)
	// 82B8D310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8D31C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8D328: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D32C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D330: 48001409  bl 0x82b8e738
	ctx.lr = 0x82B8D334;
	sub_82B8E738(ctx, base);
	// 82B8D334: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D338: 41820024  beq 0x82b8d35c
	if ctx.cr[0].eq {
	pc = 0x82B8D35C; continue 'dispatch;
	}
	// 82B8D33C: 83FE0014  lwz r31, 0x14(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8D340: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8D344: 419A0018  beq cr6, 0x82b8d35c
	if ctx.cr[6].eq {
	pc = 0x82B8D35C; continue 'dispatch;
	}
	// 82B8D348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D34C: 482F2055  bl 0x82e7f3a0
	ctx.lr = 0x82B8D350;
	sub_82E7F3A0(ctx, base);
	// 82B8D350: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8D354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D358: 482F43E9  bl 0x82e81740
	ctx.lr = 0x82B8D35C;
	sub_82E81740(ctx, base);
	// 82B8D35C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8D360: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8D364: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D36C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D370: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D374: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D380 size=72
    let mut pc: u32 = 0x82B8D380;
    'dispatch: loop {
        match pc {
            0x82B8D380 => {
    //   block [0x82B8D380..0x82B8D3C8)
	// 82B8D380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D38C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D394: 4BFFAD7D  bl 0x82b88110
	ctx.lr = 0x82B8D398;
	sub_82B88110(ctx, base);
	// 82B8D398: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8D39C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8D3A0: 394A8A1C  addi r10, r10, -0x75e4
	ctx.r[10].s64 = ctx.r[10].s64 + -30180;
	// 82B8D3A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D3A8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8D3AC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D3B0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8D3B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8D3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D3C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D3C8 size=96
    let mut pc: u32 = 0x82B8D3C8;
    'dispatch: loop {
        match pc {
            0x82B8D3C8 => {
    //   block [0x82B8D3C8..0x82B8D428)
	// 82B8D3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D3D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8D3D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D3E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8D3E4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8D3E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D3EC: 419A0008  beq cr6, 0x82b8d3f4
	if ctx.cr[6].eq {
	pc = 0x82B8D3F4; continue 'dispatch;
	}
	// 82B8D3F0: 4B7334A1  bl 0x822c0890
	ctx.lr = 0x82B8D3F4;
	sub_822C0890(ctx, base);
	// 82B8D3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D3F8: 4BFFAD41  bl 0x82b88138
	ctx.lr = 0x82B8D3FC;
	sub_82B88138(ctx, base);
	// 82B8D3FC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D400: 4182000C  beq 0x82b8d40c
	if ctx.cr[0].eq {
	pc = 0x82B8D40C; continue 'dispatch;
	}
	// 82B8D404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D408: 48264FD1  bl 0x82df23d8
	ctx.lr = 0x82B8D40C;
	sub_82DF23D8(ctx, base);
	// 82B8D40C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8D414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8D418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8D41C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8D420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8D424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D428 size=180
    let mut pc: u32 = 0x82B8D428;
    'dispatch: loop {
        match pc {
            0x82B8D428 => {
    //   block [0x82B8D428..0x82B8D4DC)
	// 82B8D428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D42C: 4861AD3D  bl 0x831a8168
	ctx.lr = 0x82B8D430;
	sub_831A8130(ctx, base);
	// 82B8D430: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D434: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B8D438: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B8D43C: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 82B8D440: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8D444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D448: 419A0088  beq cr6, 0x82b8d4d0
	if ctx.cr[6].eq {
	pc = 0x82B8D4D0; continue 'dispatch;
	}
	// 82B8D44C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D450: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D454: 4B982075  bl 0x8250f4c8
	ctx.lr = 0x82B8D458;
	sub_8250F4C8(ctx, base);
	// 82B8D458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D460: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82B8D464: 409A0008  bne cr6, 0x82b8d46c
	if !ctx.cr[6].eq {
	pc = 0x82B8D46C; continue 'dispatch;
	}
	// 82B8D468: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82B8D46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D470: 48264821  bl 0x82df1c90
	ctx.lr = 0x82B8D474;
	sub_82DF1C90(ctx, base);
	// 82B8D474: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8D478: 419A0040  beq cr6, 0x82b8d4b8
	if ctx.cr[6].eq {
	pc = 0x82B8D4B8; continue 'dispatch;
	}
	// 82B8D47C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8D480: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8D484: 4B97D4CD  bl 0x8250a950
	ctx.lr = 0x82B8D488;
	sub_8250A950(ctx, base);
	// 82B8D488: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D48C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D490: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82B8D494: 409A0008  bne cr6, 0x82b8d49c
	if !ctx.cr[6].eq {
	pc = 0x82B8D49C; continue 'dispatch;
	}
	// 82B8D498: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82B8D49C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8D4A0: 482647F1  bl 0x82df1c90
	ctx.lr = 0x82B8D4A4;
	sub_82DF1C90(ctx, base);
	// 82B8D4A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8D4A8: 419A0010  beq cr6, 0x82b8d4b8
	if ctx.cr[6].eq {
	pc = 0x82B8D4B8; continue 'dispatch;
	}
	// 82B8D4AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D4B4: 4BC4654D  bl 0x827d3a00
	ctx.lr = 0x82B8D4B8;
	sub_827D3A00(ctx, base);
	// 82B8D4B8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82B8D4BC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8D4C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D4C4: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82B8D4C8: 419A0008  beq cr6, 0x82b8d4d0
	if ctx.cr[6].eq {
	pc = 0x82B8D4D0; continue 'dispatch;
	}
	// 82B8D4CC: 4B7333C5  bl 0x822c0890
	ctx.lr = 0x82B8D4D0;
	sub_822C0890(ctx, base);
	// 82B8D4D0: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82B8D4D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8D4D8: 4861ACE0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8D4E0 size=840
    let mut pc: u32 = 0x82B8D4E0;
    'dispatch: loop {
        match pc {
            0x82B8D4E0 => {
    //   block [0x82B8D4E0..0x82B8D828)
	// 82B8D4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D4E4: 4861AC85  bl 0x831a8168
	ctx.lr = 0x82B8D4E8;
	sub_831A8130(ctx, base);
	// 82B8D4E8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D4EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D4F0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D4F4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D4F8: 48001241  bl 0x82b8e738
	ctx.lr = 0x82B8D4FC;
	sub_82B8E738(ctx, base);
	// 82B8D4FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D500: 41820318  beq 0x82b8d818
	if ctx.cr[0].eq {
	pc = 0x82B8D818; continue 'dispatch;
	}
	// 82B8D504: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D508: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D50C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8D510: 419A00F0  beq cr6, 0x82b8d600
	if ctx.cr[6].eq {
	pc = 0x82B8D600; continue 'dispatch;
	}
	// 82B8D514: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82B8D518: 409A0300  bne cr6, 0x82b8d818
	if !ctx.cr[6].eq {
	pc = 0x82B8D818; continue 'dispatch;
	}
	// 82B8D51C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D520: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D524: 480010E5  bl 0x82b8e608
	ctx.lr = 0x82B8D528;
	sub_82B8E608(ctx, base);
	// 82B8D528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8D52C: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 82B8D530: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82B8D534: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D538: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 82B8D53C: 4B7373C5  bl 0x822c4900
	ctx.lr = 0x82B8D540;
	sub_822C4900(ctx, base);
	// 82B8D540: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8D544: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D548: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D54C: 4B981F7D  bl 0x8250f4c8
	ctx.lr = 0x82B8D550;
	sub_8250F4C8(ctx, base);
	// 82B8D550: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D558: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8D55C: 409A0008  bne cr6, 0x82b8d564
	if !ctx.cr[6].eq {
	pc = 0x82B8D564; continue 'dispatch;
	}
	// 82B8D560: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8D564: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8D568: 4B97D3E9  bl 0x8250a950
	ctx.lr = 0x82B8D56C;
	sub_8250A950(ctx, base);
	// 82B8D56C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D574: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82B8D578: 409A0008  bne cr6, 0x82b8d580
	if !ctx.cr[6].eq {
	pc = 0x82B8D580; continue 'dispatch;
	}
	// 82B8D57C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8D580: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D584: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82B8D588: 48001099  bl 0x82b8e620
	ctx.lr = 0x82B8D58C;
	sub_82B8E620(ctx, base);
	// 82B8D58C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8D590: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82B8D594: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D598: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8D59C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82B8D5A0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82B8D5A4: 4BC46DDD  bl 0x827d4380
	ctx.lr = 0x82B8D5A8;
	sub_827D4380(ctx, base);
	// 82B8D5A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8D5AC: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82B8D5B0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B8D5B4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B8D5B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D5BC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D5C0: 4B736EA1  bl 0x822c4460
	ctx.lr = 0x82B8D5C4;
	sub_822C4460(ctx, base);
	// 82B8D5C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8D5C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D5CC: 419A0008  beq cr6, 0x82b8d5d4
	if ctx.cr[6].eq {
	pc = 0x82B8D5D4; continue 'dispatch;
	}
	// 82B8D5D0: 4B7332C1  bl 0x822c0890
	ctx.lr = 0x82B8D5D4;
	sub_822C0890(ctx, base);
	// 82B8D5D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8D5D8: 482646B9  bl 0x82df1c90
	ctx.lr = 0x82B8D5DC;
	sub_82DF1C90(ctx, base);
	// 82B8D5DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8D5E0: 482646B1  bl 0x82df1c90
	ctx.lr = 0x82B8D5E4;
	sub_82DF1C90(ctx, base);
	// 82B8D5E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D5EC: 419A022C  beq cr6, 0x82b8d818
	if ctx.cr[6].eq {
	pc = 0x82B8D818; continue 'dispatch;
	}
	// 82B8D5F0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D5F4: C02B0060  lfs f1, 0x60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8D5F8: 482F3EF9  bl 0x82e814f0
	ctx.lr = 0x82B8D5FC;
	sub_82E814F0(ctx, base);
	// 82B8D5FC: 4800021C  b 0x82b8d818
	pc = 0x82B8D818; continue 'dispatch;
	// 82B8D600: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8D604: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8D608: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D60C: 48000FDD  bl 0x82b8e5e8
	ctx.lr = 0x82B8D610;
	sub_82B8E5E8(ctx, base);
	// 82B8D610: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8D614: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D618: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82B8D61C: 419A0024  beq cr6, 0x82b8d640
	if ctx.cr[6].eq {
	pc = 0x82B8D640; continue 'dispatch;
	}
	// 82B8D620: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82B8D624: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8D628: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D62C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8D630: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8D634: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8D638: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8D63C: 4082FFE8  bne 0x82b8d624
	if !ctx.cr[0].eq {
	pc = 0x82B8D624; continue 'dispatch;
	}
	// 82B8D640: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D644: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8D648: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82B8D64C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8D650: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8D654: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82B8D658: 896B001D  lbz r11, 0x1d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82B8D65C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8D660: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8D664: 388B8A48  addi r4, r11, -0x75b8
	ctx.r[4].s64 = ctx.r[11].s64 + -30136;
	// 82B8D668: 41820040  beq 0x82b8d6a8
	if ctx.cr[0].eq {
	pc = 0x82B8D6A8; continue 'dispatch;
	}
	// 82B8D66C: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 82B8D670: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82B8D674: 48264D75  bl 0x82df23e8
	ctx.lr = 0x82B8D678;
	sub_82DF23E8(ctx, base);
	// 82B8D678: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8D67C: 4182001C  beq 0x82b8d698
	if ctx.cr[0].eq {
	pc = 0x82B8D698; continue 'dispatch;
	}
	// 82B8D680: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D684: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B8D688: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82B8D68C: 4B9FD3D5  bl 0x8258aa60
	ctx.lr = 0x82B8D690;
	sub_8258AA60(ctx, base);
	// 82B8D690: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8D694: 48000008  b 0x82b8d69c
	pc = 0x82B8D69C; continue 'dispatch;
	// 82B8D698: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8D69C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D6A0: 4BD7F381  bl 0x8290ca20
	ctx.lr = 0x82B8D6A4;
	sub_8290CA20(ctx, base);
	// 82B8D6A4: 48000038  b 0x82b8d6dc
	pc = 0x82B8D6DC; continue 'dispatch;
	// 82B8D6A8: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82B8D6AC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82B8D6B0: 48264D39  bl 0x82df23e8
	ctx.lr = 0x82B8D6B4;
	sub_82DF23E8(ctx, base);
	// 82B8D6B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8D6B8: 41820018  beq 0x82b8d6d0
	if ctx.cr[0].eq {
	pc = 0x82B8D6D0; continue 'dispatch;
	}
	// 82B8D6BC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D6C0: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82B8D6C4: 4B9FD24D  bl 0x8258a910
	ctx.lr = 0x82B8D6C8;
	sub_8258A910(ctx, base);
	// 82B8D6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8D6CC: 48000008  b 0x82b8d6d4
	pc = 0x82B8D6D4; continue 'dispatch;
	// 82B8D6D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8D6D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D6D8: 4BFFB1A1  bl 0x82b88878
	ctx.lr = 0x82B8D6DC;
	sub_82B88878(ctx, base);
	// 82B8D6DC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D6E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D6E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8D6E8: 38AB0018  addi r5, r11, 0x18
	ctx.r[5].s64 = ctx.r[11].s64 + 24;
	// 82B8D6EC: 4BFFDF9D  bl 0x82b8b688
	ctx.lr = 0x82B8D6F0;
	sub_82B8B688(ctx, base);
	// 82B8D6F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8D6F4: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D6F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D6FC: 419A000C  beq cr6, 0x82b8d708
	if ctx.cr[6].eq {
	pc = 0x82B8D708; continue 'dispatch;
	}
	// 82B8D700: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82B8D704: 4B73318D  bl 0x822c0890
	ctx.lr = 0x82B8D708;
	sub_822C0890(ctx, base);
	// 82B8D708: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8D70C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D710: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D714: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8D718: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8D71C: 4E800421  bctrl
	ctx.lr = 0x82B8D720;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8D720: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D724: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82B8D728: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8D72C: 41820010  beq 0x82b8d73c
	if ctx.cr[0].eq {
	pc = 0x82B8D73C; continue 'dispatch;
	}
	// 82B8D730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8D734: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8D738: 482856F9  bl 0x82e12e30
	ctx.lr = 0x82B8D73C;
	sub_82E12E30(ctx, base);
	// 82B8D73C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82B8D740: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D744: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D748: 4B981D81  bl 0x8250f4c8
	ctx.lr = 0x82B8D74C;
	sub_8250F4C8(ctx, base);
	// 82B8D74C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D754: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82B8D758: 409A0008  bne cr6, 0x82b8d760
	if !ctx.cr[6].eq {
	pc = 0x82B8D760; continue 'dispatch;
	}
	// 82B8D75C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8D760: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8D764: 4B97D1ED  bl 0x8250a950
	ctx.lr = 0x82B8D768;
	sub_8250A950(ctx, base);
	// 82B8D768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D770: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82B8D774: 409A0008  bne cr6, 0x82b8d77c
	if !ctx.cr[6].eq {
	pc = 0x82B8D77C; continue 'dispatch;
	}
	// 82B8D778: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8D77C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D780: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82B8D784: 48000E9D  bl 0x82b8e620
	ctx.lr = 0x82B8D788;
	sub_82B8E620(ctx, base);
	// 82B8D788: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82B8D78C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8D790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D794: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B8D798: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82B8D79C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82B8D7A0: 4BC46B51  bl 0x827d42f0
	ctx.lr = 0x82B8D7A4;
	sub_827D42F0(ctx, base);
	// 82B8D7A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8D7A8: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82B8D7AC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B8D7B0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B8D7B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D7B8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8D7BC: 4B736CA5  bl 0x822c4460
	ctx.lr = 0x82B8D7C0;
	sub_822C4460(ctx, base);
	// 82B8D7C0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8D7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D7C8: 419A0008  beq cr6, 0x82b8d7d0
	if ctx.cr[6].eq {
	pc = 0x82B8D7D0; continue 'dispatch;
	}
	// 82B8D7CC: 4B7330C5  bl 0x822c0890
	ctx.lr = 0x82B8D7D0;
	sub_822C0890(ctx, base);
	// 82B8D7D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8D7D4: 482644BD  bl 0x82df1c90
	ctx.lr = 0x82B8D7D8;
	sub_82DF1C90(ctx, base);
	// 82B8D7D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82B8D7DC: 482644B5  bl 0x82df1c90
	ctx.lr = 0x82B8D7E0;
	sub_82DF1C90(ctx, base);
	// 82B8D7E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D7E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D7E8: 419A0010  beq cr6, 0x82b8d7f8
	if ctx.cr[6].eq {
	pc = 0x82B8D7F8; continue 'dispatch;
	}
	// 82B8D7EC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D7F0: C02B0060  lfs f1, 0x60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8D7F4: 482F3CFD  bl 0x82e814f0
	ctx.lr = 0x82B8D7F8;
	sub_82E814F0(ctx, base);
	// 82B8D7F8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8D7FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8D800: 419A0008  beq cr6, 0x82b8d808
	if ctx.cr[6].eq {
	pc = 0x82B8D808; continue 'dispatch;
	}
	// 82B8D804: 4B73308D  bl 0x822c0890
	ctx.lr = 0x82B8D808;
	sub_822C0890(ctx, base);
	// 82B8D808: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82B8D80C: 419A000C  beq cr6, 0x82b8d818
	if ctx.cr[6].eq {
	pc = 0x82B8D818; continue 'dispatch;
	}
	// 82B8D810: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B8D814: 4B73307D  bl 0x822c0890
	ctx.lr = 0x82B8D818;
	sub_822C0890(ctx, base);
	// 82B8D818: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8D81C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8D820: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82B8D824: 4861A994  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8D828 size=296
    let mut pc: u32 = 0x82B8D828;
    'dispatch: loop {
        match pc {
            0x82B8D828 => {
    //   block [0x82B8D828..0x82B8D950)
	// 82B8D828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D82C: 4861A93D  bl 0x831a8168
	ctx.lr = 0x82B8D830;
	sub_831A8130(ctx, base);
	// 82B8D830: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82B8D834: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D838: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8D83C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8D840: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82B8D844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D848: 388B9428  addi r4, r11, -0x6bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -27608;
	// 82B8D84C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B8D850: 4826BCE1  bl 0x82df9530
	ctx.lr = 0x82B8D854;
	sub_82DF9530(ctx, base);
	// 82B8D854: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8D858: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8D85C: 409A00E8  bne cr6, 0x82b8d944
	if !ctx.cr[6].eq {
	pc = 0x82B8D944; continue 'dispatch;
	}
	// 82B8D860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8D864: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D868: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8D86C: 482BD515  bl 0x82e4ad80
	ctx.lr = 0x82B8D870;
	sub_82E4AD80(ctx, base);
	// 82B8D870: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82B8D874: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8D878: 4081002C  ble 0x82b8d8a4
	if !ctx.cr[0].gt {
	pc = 0x82B8D8A4; continue 'dispatch;
	}
	// 82B8D87C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8D880: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D884: 482BD525  bl 0x82e4ada8
	ctx.lr = 0x82B8D888;
	sub_82E4ADA8(ctx, base);
	// 82B8D888: 482BD5D9  bl 0x82e4ae60
	ctx.lr = 0x82B8D88C;
	sub_82E4AE60(ctx, base);
	// 82B8D88C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82B8D890: 40980008  bge cr6, 0x82b8d898
	if !ctx.cr[6].lt {
	pc = 0x82B8D898; continue 'dispatch;
	}
	// 82B8D894: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8D898: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82B8D89C: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82B8D8A0: 4198FFDC  blt cr6, 0x82b8d87c
	if ctx.cr[6].lt {
	pc = 0x82B8D87C; continue 'dispatch;
	}
	// 82B8D8A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8D8A8: 4B95D1E1  bl 0x824eaa88
	ctx.lr = 0x82B8D8AC;
	sub_824EAA88(ctx, base);
	// 82B8D8AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D8B0: 4B95B399  bl 0x824e8c48
	ctx.lr = 0x82B8D8B4;
	sub_824E8C48(ctx, base);
	// 82B8D8B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D8B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82B8D8BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8D8C0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8D8C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8D8C8: 4E800421  bctrl
	ctx.lr = 0x82B8D8CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8D8CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8D8D0: 482643C1  bl 0x82df1c90
	ctx.lr = 0x82B8D8D4;
	sub_82DF1C90(ctx, base);
	// 82B8D8D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8D8D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8D8DC: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8D8E0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8D8E4: ED9F0032  fmuls f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82B8D8E8: EC3F682A  fadds f1, f31, f13
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64;
	// 82B8D8EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8D8F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D8F4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82B8D8F8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82B8D8FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82B8D900: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82B8D904: EC0D6038  fmsubs f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82B8D908: D00A0038  stfs f0, 0x38(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82B8D90C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D910: 482BDBD1  bl 0x82e4b4e0
	ctx.lr = 0x82B8D914;
	sub_82E4B4E0(ctx, base);
	// 82B8D914: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D918: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D91C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D920: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8D924: 4E800421  bctrl
	ctx.lr = 0x82B8D928;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8D928: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82B8D92C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8D930: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D934: 4853E09D  bl 0x830cb9d0
	ctx.lr = 0x82B8D938;
	sub_830CB9D0(ctx, base);
	// 82B8D938: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8D93C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8D940: 996A0059  stb r11, 0x59(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 82B8D944: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B8D948: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82B8D94C: 4861A86C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8D950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8D950 size=196
    let mut pc: u32 = 0x82B8D950;
    'dispatch: loop {
        match pc {
            0x82B8D950 => {
    //   block [0x82B8D950..0x82B8DA14)
	// 82B8D950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8D954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8D958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8D95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8D960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8D964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8D968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8D96C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8D970: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8D974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8D978: 4B732FC1  bl 0x822c0938
	ctx.lr = 0x82B8D97C;
	sub_822C0938(ctx, base);
	// 82B8D97C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8D980: 41820028  beq 0x82b8d9a8
	if ctx.cr[0].eq {
	pc = 0x82B8D9A8; continue 'dispatch;
	}
	// 82B8D984: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8D988: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8D98C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8D990: 392B8A98  addi r9, r11, -0x7568
	ctx.r[9].s64 = ctx.r[11].s64 + -30056;
	// 82B8D994: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8D998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8D99C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8D9A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8D9A4: 48000008  b 0x82b8d9ac
	pc = 0x82B8D9AC; continue 'dispatch;
	// 82B8D9A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8D9AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8D9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8D9B4: 409A0044  bne cr6, 0x82b8d9f8
	if !ctx.cr[6].eq {
	pc = 0x82B8D9F8; continue 'dispatch;
	}
	// 82B8D9B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8D9BC: 419A001C  beq cr6, 0x82b8d9d8
	if ctx.cr[6].eq {
	pc = 0x82B8D9D8; continue 'dispatch;
	}
	// 82B8D9C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D9C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8D9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8D9CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8D9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8D9D4: 4E800421  bctrl
	ctx.lr = 0x82B8D9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8D9D8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8D9DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8D9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8D9E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8D9E8: 816BB0F4  lwz r11, -0x4f0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20236 as u32) ) } as u64;
	// 82B8D9EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8D9F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8D9F4: 4B73260D  bl 0x822c0000
	ctx.lr = 0x82B8D9F8;
	sub_822C0000(ctx, base);
	// 82B8D9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8D9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8DA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8DA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8DA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8DA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8DA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8DA18 size=72
    let mut pc: u32 = 0x82B8DA18;
    'dispatch: loop {
        match pc {
            0x82B8DA18 => {
    //   block [0x82B8DA18..0x82B8DA60)
	// 82B8DA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8DA20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8DA24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DA28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8DA2C: 4BFFA6E5  bl 0x82b88110
	ctx.lr = 0x82B8DA30;
	sub_82B88110(ctx, base);
	// 82B8DA30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8DA34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8DA38: 394A8AAC  addi r10, r10, -0x7554
	ctx.r[10].s64 = ctx.r[10].s64 + -30036;
	// 82B8DA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8DA40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8DA44: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8DA48: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8DA4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8DA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8DA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8DA58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8DA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8DA60 size=144
    let mut pc: u32 = 0x82B8DA60;
    'dispatch: loop {
        match pc {
            0x82B8DA60 => {
    //   block [0x82B8DA60..0x82B8DAF0)
	// 82B8DA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8DA68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8DA6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8DA74: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8DA78: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8DA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DA80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8DA84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8DA88: 419A0024  beq cr6, 0x82b8daac
	if ctx.cr[6].eq {
	pc = 0x82B8DAAC; continue 'dispatch;
	}
	// 82B8DA8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DA90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DA94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DA98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DA9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DAA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DAA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DAA8: 4082FFE8  bne 0x82b8da90
	if !ctx.cr[0].eq {
	pc = 0x82B8DA90; continue 'dispatch;
	}
	// 82B8DAAC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8DAB0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8DAB4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82B8DAB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8DABC: 808B7090  lwz r4, 0x7090(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28816 as u32) ) } as u64;
	// 82B8DAC0: 4B982F39  bl 0x825109f8
	ctx.lr = 0x82B8DAC4;
	sub_825109F8(ctx, base);
	// 82B8DAC4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8DAC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DACC: 419A0008  beq cr6, 0x82b8dad4
	if ctx.cr[6].eq {
	pc = 0x82B8DAD4; continue 'dispatch;
	}
	// 82B8DAD0: 4B732DC1  bl 0x822c0890
	ctx.lr = 0x82B8DAD4;
	sub_822C0890(ctx, base);
	// 82B8DAD4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8DAD8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8DADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8DAE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8DAE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8DAE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8DAEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8DAF0 size=144
    let mut pc: u32 = 0x82B8DAF0;
    'dispatch: loop {
        match pc {
            0x82B8DAF0 => {
    //   block [0x82B8DAF0..0x82B8DB80)
	// 82B8DAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8DAF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8DAFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DB00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8DB04: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8DB08: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8DB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DB10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8DB14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8DB18: 419A0024  beq cr6, 0x82b8db3c
	if ctx.cr[6].eq {
	pc = 0x82B8DB3C; continue 'dispatch;
	}
	// 82B8DB1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DB20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DB24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DB28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DB2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DB30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DB34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DB38: 4082FFE8  bne 0x82b8db20
	if !ctx.cr[0].eq {
	pc = 0x82B8DB20; continue 'dispatch;
	}
	// 82B8DB3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8DB40: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8DB44: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82B8DB48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8DB4C: 808B7090  lwz r4, 0x7090(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28816 as u32) ) } as u64;
	// 82B8DB50: 4B982571  bl 0x825100c0
	ctx.lr = 0x82B8DB54;
	sub_825100C0(ctx, base);
	// 82B8DB54: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8DB58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DB5C: 419A0008  beq cr6, 0x82b8db64
	if ctx.cr[6].eq {
	pc = 0x82B8DB64; continue 'dispatch;
	}
	// 82B8DB60: 4B732D31  bl 0x822c0890
	ctx.lr = 0x82B8DB64;
	sub_822C0890(ctx, base);
	// 82B8DB64: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82B8DB68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8DB6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8DB70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8DB74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8DB78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8DB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8DB80 size=112
    let mut pc: u32 = 0x82B8DB80;
    'dispatch: loop {
        match pc {
            0x82B8DB80 => {
    //   block [0x82B8DB80..0x82B8DBF0)
	// 82B8DB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8DB88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8DB8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8DB90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DB94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8DB98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8DB9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8DBA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8DBA4: 4BFFFDAD  bl 0x82b8d950
	ctx.lr = 0x82B8DBA8;
	sub_82B8D950(ctx, base);
	// 82B8DBA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8DBAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8DBB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8DBB4: 4B73244D  bl 0x822c0000
	ctx.lr = 0x82B8DBB8;
	sub_822C0000(ctx, base);
	// 82B8DBB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8DBBC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8DBC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8DBC4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8DBC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DBCC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8DBD0: 419A0008  beq cr6, 0x82b8dbd8
	if ctx.cr[6].eq {
	pc = 0x82B8DBD8; continue 'dispatch;
	}
	// 82B8DBD4: 4B732CBD  bl 0x822c0890
	ctx.lr = 0x82B8DBD8;
	sub_822C0890(ctx, base);
	// 82B8DBD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8DBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8DBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8DBE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8DBE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8DBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8DBF0 size=964
    let mut pc: u32 = 0x82B8DBF0;
    'dispatch: loop {
        match pc {
            0x82B8DBF0 => {
    //   block [0x82B8DBF0..0x82B8DFB4)
	// 82B8DBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DBF4: 4861A565  bl 0x831a8158
	ctx.lr = 0x82B8DBF8;
	sub_831A8130(ctx, base);
	// 82B8DBF8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DBFC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82B8DC00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B8DC04: 482842D5  bl 0x82e11ed8
	ctx.lr = 0x82B8DC08;
	sub_82E11ED8(ctx, base);
	// 82B8DC08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8DC0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82B8DC10: 396B8B30  addi r11, r11, -0x74d0
	ctx.r[11].s64 = ctx.r[11].s64 + -29904;
	// 82B8DC14: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	// 82B8DC18: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8DC1C: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B8DC20: 939B000C  stw r28, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82B8DC24: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8DC28: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8DC2C: 480009F5  bl 0x82b8e620
	ctx.lr = 0x82B8DC30;
	sub_82B8E620(ctx, base);
	// 82B8DC30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8DC34: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82B8DC38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DC3C: 4829CEAD  bl 0x82e2aae8
	ctx.lr = 0x82B8DC40;
	sub_82E2AAE8(ctx, base);
	// 82B8DC40: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82B8DC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8DC48: 388BD294  addi r4, r11, -0x2d6c
	ctx.r[4].s64 = ctx.r[11].s64 + -11628;
	// 82B8DC4C: 48265DBD  bl 0x82df3a08
	ctx.lr = 0x82B8DC50;
	sub_82DF3A08(ctx, base);
	// 82B8DC50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8DC54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B8DC58: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82B8DC5C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82B8DC60: 4829DFF1  bl 0x82e2bc50
	ctx.lr = 0x82B8DC64;
	sub_82E2BC50(ctx, base);
	// 82B8DC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8DC68: 482657C1  bl 0x82df3428
	ctx.lr = 0x82B8DC6C;
	sub_82DF3428(ctx, base);
	// 82B8DC6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8DC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8DC74: 388BCE10  addi r4, r11, -0x31f0
	ctx.r[4].s64 = ctx.r[11].s64 + -12784;
	// 82B8DC78: 83410088  lwz r26, 0x88(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82B8DC7C: 4826B8B5  bl 0x82df9530
	ctx.lr = 0x82B8DC80;
	sub_82DF9530(ctx, base);
	// 82B8DC80: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82B8DC84: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82B8DC88: 3B0BD28C  addi r24, r11, -0x2d74
	ctx.r[24].s64 = ctx.r[11].s64 + -11636;
	// 82B8DC8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8DC90: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82B8DC94: 4826B89D  bl 0x82df9530
	ctx.lr = 0x82B8DC98;
	sub_82DF9530(ctx, base);
	// 82B8DC98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8DC9C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82B8DCA0: 80D90000  lwz r6, 0(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DCA4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B8DCA8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82B8DCAC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DCB0: 4828A419  bl 0x82e180c8
	ctx.lr = 0x82B8DCB4;
	sub_82E180C8(ctx, base);
	// 82B8DCB4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82B8DCB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8DCBC: 83410088  lwz r26, 0x88(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82B8DCC0: 4826B871  bl 0x82df9530
	ctx.lr = 0x82B8DCC4;
	sub_82DF9530(ctx, base);
	// 82B8DCC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8DCC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8DCCC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B8DCD0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B8DCD4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DCD8: 4828A2F1  bl 0x82e17fc8
	ctx.lr = 0x82B8DCDC;
	sub_82E17FC8(ctx, base);
	// 82B8DCDC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8DCE0: 48000941  bl 0x82b8e620
	ctx.lr = 0x82B8DCE4;
	sub_82B8E620(ctx, base);
	// 82B8DCE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8DCE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8DCEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DCF0: 482B2219  bl 0x82e3ff08
	ctx.lr = 0x82B8DCF4;
	sub_82E3FF08(ctx, base);
	// 82B8DCF4: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82B8DCF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8DCFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82B8DD00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82B8DD04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B8DD08: 482C0659  bl 0x82e4e360
	ctx.lr = 0x82B8DD0C;
	sub_82E4E360(ctx, base);
	// 82B8DD0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8DD10: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82B8DD14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82B8DD18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B8DD1C: 482C075D  bl 0x82e4e478
	ctx.lr = 0x82B8DD20;
	sub_82E4E478(ctx, base);
	// 82B8DD20: 38DE0014  addi r6, r30, 0x14
	ctx.r[6].s64 = ctx.r[30].s64 + 20;
	// 82B8DD24: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 82B8DD28: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8DD2C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82B8DD30: 482C01B9  bl 0x82e4dee8
	ctx.lr = 0x82B8DD34;
	sub_82E4DEE8(ctx, base);
	// 82B8DD34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8DD38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8DD3C: 388B8AE0  addi r4, r11, -0x7520
	ctx.r[4].s64 = ctx.r[11].s64 + -29984;
	// 82B8DD40: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 82B8DD44: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 82B8DD48: 4B732691  bl 0x822c03d8
	ctx.lr = 0x82B8DD4C;
	sub_822C03D8(ctx, base);
	// 82B8DD4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8DD50: 41820010  beq 0x82b8dd60
	if ctx.cr[0].eq {
	pc = 0x82B8DD60; continue 'dispatch;
	}
	// 82B8DD54: 482BF0A5  bl 0x82e4cdf8
	ctx.lr = 0x82B8DD58;
	sub_82E4CDF8(ctx, base);
	// 82B8DD58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8DD5C: 48000008  b 0x82b8dd64
	pc = 0x82B8DD64; continue 'dispatch;
	// 82B8DD60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82B8DD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8DD68: 4B9185B1  bl 0x824a6318
	ctx.lr = 0x82B8DD6C;
	sub_824A6318(ctx, base);
	// 82B8DD6C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8DD70: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B8DD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DD78: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B8DD7C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82B8DD80: 419A0024  beq cr6, 0x82b8dda4
	if ctx.cr[6].eq {
	pc = 0x82B8DDA4; continue 'dispatch;
	}
	// 82B8DD84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DD88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DD8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DD90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DD94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DD98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DD9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DDA0: 4082FFE8  bne 0x82b8dd88
	if !ctx.cr[0].eq {
	pc = 0x82B8DD88; continue 'dispatch;
	}
	// 82B8DDA4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82B8DDA8: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B8DDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DDB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8DDB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8DDB8: 419A0024  beq cr6, 0x82b8dddc
	if ctx.cr[6].eq {
	pc = 0x82B8DDDC; continue 'dispatch;
	}
	// 82B8DDBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DDC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DDC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DDC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DDCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DDD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DDD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DDD8: 4082FFE8  bne 0x82b8ddc0
	if !ctx.cr[0].eq {
	pc = 0x82B8DDC0; continue 'dispatch;
	}
	// 82B8DDDC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8DDE0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82B8DDE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DDE8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82B8DDEC: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82B8DDF0: 419A0024  beq cr6, 0x82b8de14
	if ctx.cr[6].eq {
	pc = 0x82B8DE14; continue 'dispatch;
	}
	// 82B8DDF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DDF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DDFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DE00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DE04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DE08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DE0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DE10: 4082FFE8  bne 0x82b8ddf8
	if !ctx.cr[0].eq {
	pc = 0x82B8DDF8; continue 'dispatch;
	}
	// 82B8DE14: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82B8DE18: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8DE1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8DE20: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82B8DE24: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82B8DE28: 419A0024  beq cr6, 0x82b8de4c
	if ctx.cr[6].eq {
	pc = 0x82B8DE4C; continue 'dispatch;
	}
	// 82B8DE2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8DE30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8DE34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DE38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8DE3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8DE40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8DE44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8DE48: 4082FFE8  bne 0x82b8de30
	if !ctx.cr[0].eq {
	pc = 0x82B8DE30; continue 'dispatch;
	}
	// 82B8DE4C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82B8DE50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DE54: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82B8DE58: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82B8DE5C: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82B8DE60: 482BD759  bl 0x82e4b5b8
	ctx.lr = 0x82B8DE64;
	sub_82E4B5B8(ctx, base);
	// 82B8DE64: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82B8DE68: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82B8DE6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DE70: 482BFAE9  bl 0x82e4d958
	ctx.lr = 0x82B8DE74;
	sub_82E4D958(ctx, base);
	// 82B8DE74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8DE78: C00B8AD8  lfs f0, -0x7528(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29992 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8DE7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DE80: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82B8DE84: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DE88: 482BCDE9  bl 0x82e4ac70
	ctx.lr = 0x82B8DE8C;
	sub_82E4AC70(ctx, base);
	// 82B8DE8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8DE90: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82B8DE94: C00B8AD4  lfs f0, -0x752c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29996 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8DE98: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82B8DE9C: D01E003C  stfs f0, 0x3c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82B8DEA0: 4B95CBE9  bl 0x824eaa88
	ctx.lr = 0x82B8DEA4;
	sub_824EAA88(ctx, base);
	// 82B8DEA4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DEA8: 4B95ADA1  bl 0x824e8c48
	ctx.lr = 0x82B8DEAC;
	sub_824E8C48(ctx, base);
	// 82B8DEAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DEB0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8DEB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8DEB8: 4E800421  bctrl
	ctx.lr = 0x82B8DEBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8DEBC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82B8DEC0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82B8DEC4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82B8DEC8: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82B8DECC: 48263DC5  bl 0x82df1c90
	ctx.lr = 0x82B8DED0;
	sub_82DF1C90(ctx, base);
	// 82B8DED0: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8DED4: 4182001C  beq 0x82b8def0
	if ctx.cr[0].eq {
	pc = 0x82B8DEF0; continue 'dispatch;
	}
	// 82B8DED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DEDC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82B8DEE0: C1AB003C  lfs f13, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8DEE4: C00A9584  lfs f0, -0x6a7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8DEE8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8DEEC: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82B8DEF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82B8DEF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DEF8: C02BDD6C  lfs f1, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8DEFC: 482BD5E5  bl 0x82e4b4e0
	ctx.lr = 0x82B8DF00;
	sub_82E4B4E0(ctx, base);
	// 82B8DF00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82B8DF04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF08: C02BBC10  lfs f1, -0x43f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8DF0C: 482BCD3D  bl 0x82e4ac48
	ctx.lr = 0x82B8DF10;
	sub_82E4AC48(ctx, base);
	// 82B8DF10: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF14: 482BCD5D  bl 0x82e4ac70
	ctx.lr = 0x82B8DF18;
	sub_82E4AC70(ctx, base);
	// 82B8DF18: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8DF1C: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82B8DF20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8DF24: C00A08AC  lfs f0, 0x8ac(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8DF28: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82B8DF2C: D01E0048  stfs f0, 0x48(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82B8DF30: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF34: 9B8A0059  stb r28, 0x59(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(89 as u32), ctx.r[28].u8 ) };
	// 82B8DF38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF3C: 912A0070  stw r9, 0x70(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82B8DF40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF44: 996A0068  stb r11, 0x68(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82B8DF48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8DF4C: 996A0069  stb r11, 0x69(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82B8DF50: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8DF54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DF58: 419A0008  beq cr6, 0x82b8df60
	if ctx.cr[6].eq {
	pc = 0x82B8DF60; continue 'dispatch;
	}
	// 82B8DF5C: 4B732935  bl 0x822c0890
	ctx.lr = 0x82B8DF60;
	sub_822C0890(ctx, base);
	// 82B8DF60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82B8DF64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DF68: 419A0008  beq cr6, 0x82b8df70
	if ctx.cr[6].eq {
	pc = 0x82B8DF70; continue 'dispatch;
	}
	// 82B8DF6C: 4B732925  bl 0x822c0890
	ctx.lr = 0x82B8DF70;
	sub_822C0890(ctx, base);
	// 82B8DF70: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B8DF74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DF78: 419A0008  beq cr6, 0x82b8df80
	if ctx.cr[6].eq {
	pc = 0x82B8DF80; continue 'dispatch;
	}
	// 82B8DF7C: 4B732915  bl 0x822c0890
	ctx.lr = 0x82B8DF80;
	sub_822C0890(ctx, base);
	// 82B8DF80: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82B8DF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DF88: 419A0008  beq cr6, 0x82b8df90
	if ctx.cr[6].eq {
	pc = 0x82B8DF90; continue 'dispatch;
	}
	// 82B8DF8C: 4B732905  bl 0x822c0890
	ctx.lr = 0x82B8DF90;
	sub_822C0890(ctx, base);
	// 82B8DF90: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82B8DF94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DF98: 419A0008  beq cr6, 0x82b8dfa0
	if ctx.cr[6].eq {
	pc = 0x82B8DFA0; continue 'dispatch;
	}
	// 82B8DF9C: 4B7328F5  bl 0x822c0890
	ctx.lr = 0x82B8DFA0;
	sub_822C0890(ctx, base);
	// 82B8DFA0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82B8DFA4: 4829CB5D  bl 0x82e2ab00
	ctx.lr = 0x82B8DFA8;
	sub_82E2AB00(ctx, base);
	// 82B8DFA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8DFAC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82B8DFB0: 4861A1F8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8DFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8DFB8 size=96
    let mut pc: u32 = 0x82B8DFB8;
    'dispatch: loop {
        match pc {
            0x82B8DFB8 => {
    //   block [0x82B8DFB8..0x82B8E018)
	// 82B8DFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8DFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8DFC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8DFC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8DFC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8DFCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8DFD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8DFD4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8DFD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8DFDC: 419A0008  beq cr6, 0x82b8dfe4
	if ctx.cr[6].eq {
	pc = 0x82B8DFE4; continue 'dispatch;
	}
	// 82B8DFE0: 4B7328B1  bl 0x822c0890
	ctx.lr = 0x82B8DFE4;
	sub_822C0890(ctx, base);
	// 82B8DFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8DFE8: 48283F09  bl 0x82e11ef0
	ctx.lr = 0x82B8DFEC;
	sub_82E11EF0(ctx, base);
	// 82B8DFEC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8DFF0: 4182000C  beq 0x82b8dffc
	if ctx.cr[0].eq {
	pc = 0x82B8DFFC; continue 'dispatch;
	}
	// 82B8DFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8DFF8: 482643E1  bl 0x82df23d8
	ctx.lr = 0x82B8DFFC;
	sub_82DF23D8(ctx, base);
	// 82B8DFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E000: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E00C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E018 size=108
    let mut pc: u32 = 0x82B8E018;
    'dispatch: loop {
        match pc {
            0x82B8E018 => {
    //   block [0x82B8E018..0x82B8E084)
	// 82B8E018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E024: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E028: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8E02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B8E034: 388B8AE0  addi r4, r11, -0x7520
	ctx.r[4].s64 = ctx.r[11].s64 + -29984;
	// 82B8E038: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 82B8E03C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8E040: 482643A9  bl 0x82df23e8
	ctx.lr = 0x82B8E044;
	sub_82DF23E8(ctx, base);
	// 82B8E044: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E048: 41820014  beq 0x82b8e05c
	if ctx.cr[0].eq {
	pc = 0x82B8E05C; continue 'dispatch;
	}
	// 82B8E04C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8E050: 4BFFFBA1  bl 0x82b8dbf0
	ctx.lr = 0x82B8E054;
	sub_82B8DBF0(ctx, base);
	// 82B8E054: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8E058: 48000008  b 0x82b8e060
	pc = 0x82B8E060; continue 'dispatch;
	// 82B8E05C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8E060: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B8E064: 4BFFFB1D  bl 0x82b8db80
	ctx.lr = 0x82B8E068;
	sub_82B8DB80(ctx, base);
	// 82B8E068: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8E06C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8E070: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8E074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E07C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8E088 size=88
    let mut pc: u32 = 0x82B8E088;
    'dispatch: loop {
        match pc {
            0x82B8E088 => {
    //   block [0x82B8E088..0x82B8E0E0)
	// 82B8E088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E094: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82B8E098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E0A0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B8E0A4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8E0A8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E0AC: 4800068D  bl 0x82b8e738
	ctx.lr = 0x82B8E0B0;
	sub_82B8E738(ctx, base);
	// 82B8E0B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8E0B4: 41820008  beq 0x82b8e0bc
	if ctx.cr[0].eq {
	pc = 0x82B8E0BC; continue 'dispatch;
	}
	// 82B8E0B8: D3FF0024  stfs f31, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82B8E0BC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82B8E0C0: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82B8E0C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8E0C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E0CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E0D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E0D4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E0D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8E0E0 size=132
    let mut pc: u32 = 0x82B8E0E0;
    'dispatch: loop {
        match pc {
            0x82B8E0E0 => {
    //   block [0x82B8E0E0..0x82B8E164)
	// 82B8E0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E0E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E0EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E0F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E0F4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8E0F8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E0FC: 4800063D  bl 0x82b8e738
	ctx.lr = 0x82B8E100;
	sub_82B8E738(ctx, base);
	// 82B8E100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8E104: 4182004C  beq 0x82b8e150
	if ctx.cr[0].eq {
	pc = 0x82B8E150; continue 'dispatch;
	}
	// 82B8E108: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E10C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82B8E110: 409A0040  bne cr6, 0x82b8e150
	if !ctx.cr[6].eq {
	pc = 0x82B8E150; continue 'dispatch;
	}
	// 82B8E114: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E118: 480005A9  bl 0x82b8e6c0
	ctx.lr = 0x82B8E11C;
	sub_82B8E6C0(ctx, base);
	// 82B8E11C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E120: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8E124: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8E128: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E12C: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8E130: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8E134: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82B8E138: 48000008  b 0x82b8e140
	pc = 0x82B8E140; continue 'dispatch;
	// 82B8E13C: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82B8E140: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82B8E144: 4199FFF8  bgt cr6, 0x82b8e13c
	if ctx.cr[6].gt {
	pc = 0x82B8E13C; continue 'dispatch;
	}
	// 82B8E148: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82B8E14C: 482B06ED  bl 0x82e3e838
	ctx.lr = 0x82B8E150;
	sub_82E3E838(ctx, base);
	// 82B8E150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8E154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E15C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E168 size=80
    let mut pc: u32 = 0x82B8E168;
    'dispatch: loop {
        match pc {
            0x82B8E168 => {
    //   block [0x82B8E168..0x82B8E1B8)
	// 82B8E168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E17C: 4BFF9F95  bl 0x82b88110
	ctx.lr = 0x82B8E180;
	sub_82B88110(ctx, base);
	// 82B8E180: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B8E184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E188: 394A8B40  addi r10, r10, -0x74c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29888;
	// 82B8E18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E190: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8E194: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8E198: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82B8E19C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82B8E1A0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82B8E1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8E1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E1B8 size=80
    let mut pc: u32 = 0x82B8E1B8;
    'dispatch: loop {
        match pc {
            0x82B8E1B8 => {
    //   block [0x82B8E1B8..0x82B8E208)
	// 82B8E1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E1C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E1C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E1C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E1CC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8E1D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8E1D4: 419A0008  beq cr6, 0x82b8e1dc
	if ctx.cr[6].eq {
	pc = 0x82B8E1DC; continue 'dispatch;
	}
	// 82B8E1D8: 4B7326B9  bl 0x822c0890
	ctx.lr = 0x82B8E1DC;
	sub_822C0890(ctx, base);
	// 82B8E1DC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8E1E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8E1E4: 419A0008  beq cr6, 0x82b8e1ec
	if ctx.cr[6].eq {
	pc = 0x82B8E1EC; continue 'dispatch;
	}
	// 82B8E1E8: 4B7326A9  bl 0x822c0890
	ctx.lr = 0x82B8E1EC;
	sub_822C0890(ctx, base);
	// 82B8E1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E1F0: 4BFF9F49  bl 0x82b88138
	ctx.lr = 0x82B8E1F4;
	sub_82B88138(ctx, base);
	// 82B8E1F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8E1F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E1FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E208 size=76
    let mut pc: u32 = 0x82B8E208;
    'dispatch: loop {
        match pc {
            0x82B8E208 => {
    //   block [0x82B8E208..0x82B8E254)
	// 82B8E208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8E214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E21C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8E224: 4BFFFF95  bl 0x82b8e1b8
	ctx.lr = 0x82B8E228;
	sub_82B8E1B8(ctx, base);
	// 82B8E228: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8E22C: 4182000C  beq 0x82b8e238
	if ctx.cr[0].eq {
	pc = 0x82B8E238; continue 'dispatch;
	}
	// 82B8E230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E234: 482641A5  bl 0x82df23d8
	ctx.lr = 0x82B8E238;
	sub_82DF23D8(ctx, base);
	// 82B8E238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E23C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E248: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E24C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E258 size=252
    let mut pc: u32 = 0x82B8E258;
    'dispatch: loop {
        match pc {
            0x82B8E258 => {
    //   block [0x82B8E258..0x82B8E354)
	// 82B8E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E25C: 48619F11  bl 0x831a816c
	ctx.lr = 0x82B8E260;
	sub_831A8130(ctx, base);
	// 82B8E260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E268: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E26C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8E270: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E274: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8E278: 48000371  bl 0x82b8e5e8
	ctx.lr = 0x82B8E27C;
	sub_82B8E5E8(ctx, base);
	// 82B8E27C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E284: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8E288: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82B8E28C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8E290: 419A0024  beq cr6, 0x82b8e2b4
	if ctx.cr[6].eq {
	pc = 0x82B8E2B4; continue 'dispatch;
	}
	// 82B8E294: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 82B8E298: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82B8E29C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8E2A0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82B8E2A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82B8E2A8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8E2AC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8E2B0: 4082FFE8  bne 0x82b8e298
	if !ctx.cr[0].eq {
	pc = 0x82B8E298; continue 'dispatch;
	}
	// 82B8E2B4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82B8E2B8: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82B8E2BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82B8E2C0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B8E2C4: 4B73619D  bl 0x822c4460
	ctx.lr = 0x82B8E2C8;
	sub_822C4460(ctx, base);
	// 82B8E2C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B8E2CC: 419A000C  beq cr6, 0x82b8e2d8
	if ctx.cr[6].eq {
	pc = 0x82B8E2D8; continue 'dispatch;
	}
	// 82B8E2D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8E2D4: 4B7325BD  bl 0x822c0890
	ctx.lr = 0x82B8E2D8;
	sub_822C0890(ctx, base);
	// 82B8E2D8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E2DC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82B8E2E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8E2E4: 419A0068  beq cr6, 0x82b8e34c
	if ctx.cr[6].eq {
	pc = 0x82B8E34C; continue 'dispatch;
	}
	// 82B8E2E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8E2EC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E2F0: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82B8E2F4: 4BFFE2BD  bl 0x82b8c5b0
	ctx.lr = 0x82B8E2F8;
	sub_82B8C5B0(ctx, base);
	// 82B8E2F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8E2FC: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82B8E300: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B8E304: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B8E308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E30C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E310: 4B736151  bl 0x822c4460
	ctx.lr = 0x82B8E314;
	sub_822C4460(ctx, base);
	// 82B8E314: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8E318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8E31C: 419A0008  beq cr6, 0x82b8e324
	if ctx.cr[6].eq {
	pc = 0x82B8E324; continue 'dispatch;
	}
	// 82B8E320: 4B732571  bl 0x822c0890
	ctx.lr = 0x82B8E324;
	sub_822C0890(ctx, base);
	// 82B8E324: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B8E328: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E32C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8E330: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82B8E334: 4826B1FD  bl 0x82df9530
	ctx.lr = 0x82B8E338;
	sub_82DF9530(ctx, base);
	// 82B8E338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8E33C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82B8E340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E344: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E348: 48289401  bl 0x82e17748
	ctx.lr = 0x82B8E34C;
	sub_82E17748(ctx, base);
	// 82B8E34C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8E350: 48619E6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E358 size=24
    let mut pc: u32 = 0x82B8E358;
    'dispatch: loop {
        match pc {
            0x82B8E358 => {
    //   block [0x82B8E358..0x82B8E370)
	// 82B8E358: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E35C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E360: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8E364: 419A000C  beq cr6, 0x82b8e370
	if ctx.cr[6].eq {
		sub_82B8E370(ctx, base);
		return;
	}
	// 82B8E368: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E36C: 48000070  b 0x82b8e3dc
	sub_82B8E3DC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E370 size=24
    let mut pc: u32 = 0x82B8E370;
    'dispatch: loop {
        match pc {
            0x82B8E370 => {
    //   block [0x82B8E370..0x82B8E388)
	// 82B8E370: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E374: 892A0021  lbz r9, 0x21(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E378: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B8E37C: 409A0040  bne cr6, 0x82b8e3bc
	if !ctx.cr[6].eq {
		sub_82B8E3A4(ctx, base);
		return;
	}
	// 82B8E380: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E384: 4800000C  b 0x82b8e390
	sub_82B8E388(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E388 size=28
    let mut pc: u32 = 0x82B8E388;
    'dispatch: loop {
        match pc {
            0x82B8E388 => {
    //   block [0x82B8E388..0x82B8E3A4)
	// 82B8E388: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B8E38C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E390: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E394: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B8E398: 419AFFF0  beq cr6, 0x82b8e388
	if ctx.cr[6].eq {
	pc = 0x82B8E388; continue 'dispatch;
	}
	// 82B8E39C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8E3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E3A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E3A4 size=56
    let mut pc: u32 = 0x82B8E3A4;
    'dispatch: loop {
        match pc {
            0x82B8E3A4 => {
    //   block [0x82B8E3A4..0x82B8E3DC)
	// 82B8E3A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E3A8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E3AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B8E3B0: 409A001C  bne cr6, 0x82b8e3cc
	if !ctx.cr[6].eq {
	pc = 0x82B8E3CC; continue 'dispatch;
	}
	// 82B8E3B4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E3B8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B8E3BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E3C0: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E3C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8E3C8: 419AFFDC  beq cr6, 0x82b8e3a4
	if ctx.cr[6].eq {
	pc = 0x82B8E3A4; continue 'dispatch;
	}
	// 82B8E3CC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E3D0: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E3D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8E3D8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E3DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E3DC size=8
    let mut pc: u32 = 0x82B8E3DC;
    'dispatch: loop {
        match pc {
            0x82B8E3DC => {
    //   block [0x82B8E3DC..0x82B8E3E4)
	// 82B8E3DC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E3E8 size=104
    let mut pc: u32 = 0x82B8E3E8;
    'dispatch: loop {
        match pc {
            0x82B8E3E8 => {
    //   block [0x82B8E3E8..0x82B8E450)
	// 82B8E3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E3EC: 48619D81  bl 0x831a816c
	ctx.lr = 0x82B8E3F0;
	sub_831A8130(ctx, base);
	// 82B8E3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E3F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8E3F8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E3FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E400: 409A000C  bne cr6, 0x82b8e40c
	if !ctx.cr[6].eq {
	pc = 0x82B8E40C; continue 'dispatch;
	}
	// 82B8E404: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8E408: 48000010  b 0x82b8e418
	pc = 0x82B8E418; continue 'dispatch;
	// 82B8E40C: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8E410: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8E414: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8E418: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8E41C: 419A002C  beq cr6, 0x82b8e448
	if ctx.cr[6].eq {
	pc = 0x82B8E448; continue 'dispatch;
	}
	// 82B8E420: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8E424: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E428: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8E42C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8E438: 4E800421  bctrl
	ctx.lr = 0x82B8E43C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8E43C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8E440: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8E444: 4082FFE0  bne 0x82b8e424
	if !ctx.cr[0].eq {
	pc = 0x82B8E424; continue 'dispatch;
	}
	// 82B8E448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E44C: 48619D70  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E450 size=104
    let mut pc: u32 = 0x82B8E450;
    'dispatch: loop {
        match pc {
            0x82B8E450 => {
    //   block [0x82B8E450..0x82B8E4B8)
	// 82B8E450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E454: 48619D19  bl 0x831a816c
	ctx.lr = 0x82B8E458;
	sub_831A8130(ctx, base);
	// 82B8E458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E45C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8E460: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E468: 409A000C  bne cr6, 0x82b8e474
	if !ctx.cr[6].eq {
	pc = 0x82B8E474; continue 'dispatch;
	}
	// 82B8E46C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8E470: 48000010  b 0x82b8e480
	pc = 0x82B8E480; continue 'dispatch;
	// 82B8E474: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8E478: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8E47C: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8E480: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8E484: 419A002C  beq cr6, 0x82b8e4b0
	if ctx.cr[6].eq {
	pc = 0x82B8E4B0; continue 'dispatch;
	}
	// 82B8E488: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8E48C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E490: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8E494: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E498: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E49C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8E4A0: 4E800421  bctrl
	ctx.lr = 0x82B8E4A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8E4A4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8E4A8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8E4AC: 4082FFE0  bne 0x82b8e48c
	if !ctx.cr[0].eq {
	pc = 0x82B8E48C; continue 'dispatch;
	}
	// 82B8E4B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E4B4: 48619D08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E4B8 size=104
    let mut pc: u32 = 0x82B8E4B8;
    'dispatch: loop {
        match pc {
            0x82B8E4B8 => {
    //   block [0x82B8E4B8..0x82B8E520)
	// 82B8E4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E4BC: 48619CB1  bl 0x831a816c
	ctx.lr = 0x82B8E4C0;
	sub_831A8130(ctx, base);
	// 82B8E4C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E4C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8E4C8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E4CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E4D0: 409A000C  bne cr6, 0x82b8e4dc
	if !ctx.cr[6].eq {
	pc = 0x82B8E4DC; continue 'dispatch;
	}
	// 82B8E4D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8E4D8: 48000010  b 0x82b8e4e8
	pc = 0x82B8E4E8; continue 'dispatch;
	// 82B8E4DC: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8E4E0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8E4E4: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8E4E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8E4EC: 419A002C  beq cr6, 0x82b8e518
	if ctx.cr[6].eq {
	pc = 0x82B8E518; continue 'dispatch;
	}
	// 82B8E4F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8E4F4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E4F8: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8E4FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E500: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8E504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8E508: 4E800421  bctrl
	ctx.lr = 0x82B8E50C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8E50C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8E510: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8E514: 4082FFE0  bne 0x82b8e4f4
	if !ctx.cr[0].eq {
	pc = 0x82B8E4F4; continue 'dispatch;
	}
	// 82B8E518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E51C: 48619CA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E520 size=16
    let mut pc: u32 = 0x82B8E520;
    'dispatch: loop {
        match pc {
            0x82B8E520 => {
    //   block [0x82B8E520..0x82B8E530)
	// 82B8E520: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E524: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E528: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E52C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E530 size=12
    let mut pc: u32 = 0x82B8E530;
    'dispatch: loop {
        match pc {
            0x82B8E530 => {
    //   block [0x82B8E530..0x82B8E53C)
	// 82B8E530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E534: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82B8E538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E540 size=44
    let mut pc: u32 = 0x82B8E540;
    'dispatch: loop {
        match pc {
            0x82B8E540 => {
    //   block [0x82B8E540..0x82B8E56C)
	// 82B8E540: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E544: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E548: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E54C: 41820014  beq 0x82b8e560
	if ctx.cr[0].eq {
	pc = 0x82B8E560; continue 'dispatch;
	}
	// 82B8E550: 896B0010  lbz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E554: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E558: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8E55C: 41820008  beq 0x82b8e564
	if ctx.cr[0].eq {
	pc = 0x82B8E564; continue 'dispatch;
	}
	// 82B8E560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E564: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82B8E568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E570 size=12
    let mut pc: u32 = 0x82B8E570;
    'dispatch: loop {
        match pc {
            0x82B8E570 => {
    //   block [0x82B8E570..0x82B8E57C)
	// 82B8E570: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E574: 886B0009  lbz r3, 9(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 82B8E578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E580 size=104
    let mut pc: u32 = 0x82B8E580;
    'dispatch: loop {
        match pc {
            0x82B8E580 => {
    //   block [0x82B8E580..0x82B8E5E8)
	// 82B8E580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8E58C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8E59C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B8E5A0: 4B95C4E9  bl 0x824eaa88
	ctx.lr = 0x82B8E5A4;
	sub_824EAA88(ctx, base);
	// 82B8E5A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8E5A8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E5AC: 4B95FC75  bl 0x824ee220
	ctx.lr = 0x82B8E5B0;
	sub_824EE220(ctx, base);
	// 82B8E5B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8E5B4: 482636DD  bl 0x82df1c90
	ctx.lr = 0x82B8E5B8;
	sub_82DF1C90(ctx, base);
	// 82B8E5B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8E5BC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82B8E5C0: 409A0008  bne cr6, 0x82b8e5c8
	if !ctx.cr[6].eq {
	pc = 0x82B8E5C8; continue 'dispatch;
	}
	// 82B8E5C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8E5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8E5CC: 4B97A1D5  bl 0x825087a0
	ctx.lr = 0x82B8E5D0;
	sub_825087A0(ctx, base);
	// 82B8E5D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E5D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E5D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E5DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E5E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E5E8 size=32
    let mut pc: u32 = 0x82B8E5E8;
    'dispatch: loop {
        match pc {
            0x82B8E5E8 => {
    //   block [0x82B8E5E8..0x82B8E608)
	// 82B8E5E8: 814300C0  lwz r10, 0xc0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E5EC: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82B8E5F0: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B8E5F4: 814A0044  lwz r10, 0x44(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E5F8: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82B8E5FC: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8E600: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82B8E604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E608 size=24
    let mut pc: u32 = 0x82B8E608;
    'dispatch: loop {
        match pc {
            0x82B8E608 => {
    //   block [0x82B8E608..0x82B8E620)
	// 82B8E608: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E60C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82B8E610: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E614: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82B8E618: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B8E61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E620 size=12
    let mut pc: u32 = 0x82B8E620;
    'dispatch: loop {
        match pc {
            0x82B8E620 => {
    //   block [0x82B8E620..0x82B8E62C)
	// 82B8E620: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E624: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 82B8E628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E630 size=12
    let mut pc: u32 = 0x82B8E630;
    'dispatch: loop {
        match pc {
            0x82B8E630 => {
    //   block [0x82B8E630..0x82B8E63C)
	// 82B8E630: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E634: 988B0012  stb r4, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[4].u8 ) };
	// 82B8E638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E640 size=16
    let mut pc: u32 = 0x82B8E640;
    'dispatch: loop {
        match pc {
            0x82B8E640 => {
    //   block [0x82B8E640..0x82B8E650)
	// 82B8E640: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E648: 994B0013  stb r10, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[10].u8 ) };
	// 82B8E64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E650 size=16
    let mut pc: u32 = 0x82B8E650;
    'dispatch: loop {
        match pc {
            0x82B8E650 => {
    //   block [0x82B8E650..0x82B8E660)
	// 82B8E650: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E654: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E658: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82B8E65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82B8E660 size=12
    let mut pc: u32 = 0x82B8E660;
    'dispatch: loop {
        match pc {
            0x82B8E660 => {
    //   block [0x82B8E660..0x82B8E66C)
	// 82B8E660: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E664: D02B0018  stfs f1, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82B8E668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82B8E670 size=12
    let mut pc: u32 = 0x82B8E670;
    'dispatch: loop {
        match pc {
            0x82B8E670 => {
    //   block [0x82B8E670..0x82B8E67C)
	// 82B8E670: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E674: C02B0018  lfs f1, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8E678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E680 size=16
    let mut pc: u32 = 0x82B8E680;
    'dispatch: loop {
        match pc {
            0x82B8E680 => {
    //   block [0x82B8E680..0x82B8E690)
	// 82B8E680: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E684: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E688: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 82B8E68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E690 size=12
    let mut pc: u32 = 0x82B8E690;
    'dispatch: loop {
        match pc {
            0x82B8E690 => {
    //   block [0x82B8E690..0x82B8E69C)
	// 82B8E690: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E694: 988B0016  stb r4, 0x16(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[4].u8 ) };
	// 82B8E698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E6A0 size=12
    let mut pc: u32 = 0x82B8E6A0;
    'dispatch: loop {
        match pc {
            0x82B8E6A0 => {
    //   block [0x82B8E6A0..0x82B8E6AC)
	// 82B8E6A0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E6A4: 886B0016  lbz r3, 0x16(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 82B8E6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E6B0 size=12
    let mut pc: u32 = 0x82B8E6B0;
    'dispatch: loop {
        match pc {
            0x82B8E6B0 => {
    //   block [0x82B8E6B0..0x82B8E6BC)
	// 82B8E6B0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E6B4: 886B0013  lbz r3, 0x13(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 82B8E6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82B8E6C0 size=12
    let mut pc: u32 = 0x82B8E6C0;
    'dispatch: loop {
        match pc {
            0x82B8E6C0 => {
    //   block [0x82B8E6C0..0x82B8E6CC)
	// 82B8E6C0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E6C4: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8E6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82B8E6D0 size=24
    let mut pc: u32 = 0x82B8E6D0;
    'dispatch: loop {
        match pc {
            0x82B8E6D0 => {
    //   block [0x82B8E6D0..0x82B8E6E8)
	// 82B8E6D0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E6D4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82B8E6D8: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E6DC: C02908A4  lfs f1, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8E6E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8E6E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E6E8 size=16
    let mut pc: u32 = 0x82B8E6E8;
    'dispatch: loop {
        match pc {
            0x82B8E6E8 => {
    //   block [0x82B8E6E8..0x82B8E6F8)
	// 82B8E6E8: 812B0048  lwz r9, 0x48(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8E6EC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82B8E6F0: 7D4A1E71  srawi. r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82B8E6F4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82B8E6F8 size=20
    let mut pc: u32 = 0x82B8E6F8;
    'dispatch: loop {
        match pc {
            0x82B8E6F8 => {
    //   block [0x82B8E6F8..0x82B8E70C)
	// 82B8E6F8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E6FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E704: C02B0024  lfs f1, 0x24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8E708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E710 size=24
    let mut pc: u32 = 0x82B8E710;
    'dispatch: loop {
        match pc {
            0x82B8E710 => {
    //   block [0x82B8E710..0x82B8E728)
	// 82B8E710: 814300C0  lwz r10, 0xc0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E714: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E71C: 409A000C  bne cr6, 0x82b8e728
	if !ctx.cr[6].eq {
		sub_82B8E728(ctx, base);
		return;
	}
	// 82B8E720: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B8E724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E728 size=16
    let mut pc: u32 = 0x82B8E728;
    'dispatch: loop {
        match pc {
            0x82B8E728 => {
    //   block [0x82B8E728..0x82B8E738)
	// 82B8E728: 814A0048  lwz r10, 0x48(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8E72C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8E730: 7D631E70  srawi r3, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8E734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E738 size=24
    let mut pc: u32 = 0x82B8E738;
    'dispatch: loop {
        match pc {
            0x82B8E738 => {
    //   block [0x82B8E738..0x82B8E750)
	// 82B8E738: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E73C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82B8E740: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8E744: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82B8E748: 886B0040  lbz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82B8E74C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E750 size=12
    let mut pc: u32 = 0x82B8E750;
    'dispatch: loop {
        match pc {
            0x82B8E750 => {
    //   block [0x82B8E750..0x82B8E75C)
	// 82B8E750: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E754: 386B00E0  addi r3, r11, 0xe0
	ctx.r[3].s64 = ctx.r[11].s64 + 224;
	// 82B8E758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E760 size=12
    let mut pc: u32 = 0x82B8E760;
    'dispatch: loop {
        match pc {
            0x82B8E760 => {
    //   block [0x82B8E760..0x82B8E76C)
	// 82B8E760: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E764: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 82B8E768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E770 size=12
    let mut pc: u32 = 0x82B8E770;
    'dispatch: loop {
        match pc {
            0x82B8E770 => {
    //   block [0x82B8E770..0x82B8E77C)
	// 82B8E770: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E774: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 82B8E778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E780 size=12
    let mut pc: u32 = 0x82B8E780;
    'dispatch: loop {
        match pc {
            0x82B8E780 => {
    //   block [0x82B8E780..0x82B8E78C)
	// 82B8E780: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E784: 386B0110  addi r3, r11, 0x110
	ctx.r[3].s64 = ctx.r[11].s64 + 272;
	// 82B8E788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E790 size=12
    let mut pc: u32 = 0x82B8E790;
    'dispatch: loop {
        match pc {
            0x82B8E790 => {
    //   block [0x82B8E790..0x82B8E79C)
	// 82B8E790: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E794: 386B0120  addi r3, r11, 0x120
	ctx.r[3].s64 = ctx.r[11].s64 + 288;
	// 82B8E798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E7A0 size=12
    let mut pc: u32 = 0x82B8E7A0;
    'dispatch: loop {
        match pc {
            0x82B8E7A0 => {
    //   block [0x82B8E7A0..0x82B8E7AC)
	// 82B8E7A0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E7A4: 386B013C  addi r3, r11, 0x13c
	ctx.r[3].s64 = ctx.r[11].s64 + 316;
	// 82B8E7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E7B0 size=12
    let mut pc: u32 = 0x82B8E7B0;
    'dispatch: loop {
        match pc {
            0x82B8E7B0 => {
    //   block [0x82B8E7B0..0x82B8E7BC)
	// 82B8E7B0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E7B4: 386B0150  addi r3, r11, 0x150
	ctx.r[3].s64 = ctx.r[11].s64 + 336;
	// 82B8E7B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8E7C0 size=12
    let mut pc: u32 = 0x82B8E7C0;
    'dispatch: loop {
        match pc {
            0x82B8E7C0 => {
    //   block [0x82B8E7C0..0x82B8E7CC)
	// 82B8E7C0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8E7C4: 386B0158  addi r3, r11, 0x158
	ctx.r[3].s64 = ctx.r[11].s64 + 344;
	// 82B8E7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E7D0 size=88
    let mut pc: u32 = 0x82B8E7D0;
    'dispatch: loop {
        match pc {
            0x82B8E7D0 => {
    //   block [0x82B8E7D0..0x82B8E828)
	// 82B8E7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E7D4: 48619999  bl 0x831a816c
	ctx.lr = 0x82B8E7D8;
	sub_831A8130(ctx, base);
	// 82B8E7D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E7DC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E7E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B8E7E4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E7E8: 48000028  b 0x82b8e810
	pc = 0x82B8E810; continue 'dispatch;
	// 82B8E7EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B8E7F0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82B8E7F4: 48264A45  bl 0x82df3238
	ctx.lr = 0x82B8E7F8;
	sub_82DF3238(ctx, base);
	// 82B8E7F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8E7FC: 4182000C  beq 0x82b8e808
	if ctx.cr[0].eq {
	pc = 0x82B8E808; continue 'dispatch;
	}
	// 82B8E800: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8E804: 4800000C  b 0x82b8e810
	pc = 0x82B8E810; continue 'dispatch;
	// 82B8E808: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B8E80C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E810: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8E814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E818: 419AFFD4  beq cr6, 0x82b8e7ec
	if ctx.cr[6].eq {
	pc = 0x82B8E7EC; continue 'dispatch;
	}
	// 82B8E81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8E820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E824: 48619998  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E828 size=168
    let mut pc: u32 = 0x82B8E828;
    'dispatch: loop {
        match pc {
            0x82B8E828 => {
    //   block [0x82B8E828..0x82B8E8D0)
	// 82B8E828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8E834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E83C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8E840: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8E844: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82B8E848: 38CBAFEC  addi r6, r11, -0x5014
	ctx.r[6].s64 = ctx.r[11].s64 + -20500;
	// 82B8E84C: 38AAA918  addi r5, r10, -0x56e8
	ctx.r[5].s64 = ctx.r[10].s64 + -22248;
	// 82B8E850: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82B8E854: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82B8E858: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8E85C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E860: 4861B6E9  bl 0x831a9f48
	ctx.lr = 0x82B8E864;
	sub_831A9F48(ctx, base);
	// 82B8E864: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82B8E868: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8E86C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B8E870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E874: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8E878: 419A0024  beq cr6, 0x82b8e89c
	if ctx.cr[6].eq {
	pc = 0x82B8E89C; continue 'dispatch;
	}
	// 82B8E87C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82B8E880: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8E884: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8E888: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8E88C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8E890: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8E894: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8E898: 4082FFE8  bne 0x82b8e880
	if !ctx.cr[0].eq {
	pc = 0x82B8E880; continue 'dispatch;
	}
	// 82B8E89C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E8A4: 409A0010  bne cr6, 0x82b8e8b4
	if !ctx.cr[6].eq {
	pc = 0x82B8E8B4; continue 'dispatch;
	}
	// 82B8E8A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82B8E8AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B8E8B0: 4B735BB1  bl 0x822c4460
	ctx.lr = 0x82B8E8B4;
	sub_822C4460(ctx, base);
	// 82B8E8B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E8B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E8C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E8C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E8CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E8D0 size=196
    let mut pc: u32 = 0x82B8E8D0;
    'dispatch: loop {
        match pc {
            0x82B8E8D0 => {
    //   block [0x82B8E8D0..0x82B8E994)
	// 82B8E8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E8D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8E8DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E8E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E8E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8E8E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E8EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8E8F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8E8F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E8F8: 4B732041  bl 0x822c0938
	ctx.lr = 0x82B8E8FC;
	sub_822C0938(ctx, base);
	// 82B8E8FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E900: 41820028  beq 0x82b8e928
	if ctx.cr[0].eq {
	pc = 0x82B8E928; continue 'dispatch;
	}
	// 82B8E904: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8E908: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8E90C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E910: 392B8B94  addi r9, r11, -0x746c
	ctx.r[9].s64 = ctx.r[11].s64 + -29804;
	// 82B8E914: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8E918: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8E91C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8E920: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8E924: 48000008  b 0x82b8e92c
	pc = 0x82B8E92C; continue 'dispatch;
	// 82B8E928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E92C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E934: 409A0044  bne cr6, 0x82b8e978
	if !ctx.cr[6].eq {
	pc = 0x82B8E978; continue 'dispatch;
	}
	// 82B8E938: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8E93C: 419A001C  beq cr6, 0x82b8e958
	if ctx.cr[6].eq {
	pc = 0x82B8E958; continue 'dispatch;
	}
	// 82B8E940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E944: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8E948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8E94C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8E950: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8E954: 4E800421  bctrl
	ctx.lr = 0x82B8E958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8E958: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8E95C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8E960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8E964: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8E968: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8E96C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8E970: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8E974: 4B73168D  bl 0x822c0000
	ctx.lr = 0x82B8E978;
	sub_822C0000(ctx, base);
	// 82B8E978: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8E97C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8E980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8E984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8E988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8E98C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8E990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8E998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8E998 size=196
    let mut pc: u32 = 0x82B8E998;
    'dispatch: loop {
        match pc {
            0x82B8E998 => {
    //   block [0x82B8E998..0x82B8EA5C)
	// 82B8E998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8E99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8E9A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8E9A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8E9A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8E9AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8E9B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E9B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8E9B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8E9BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E9C0: 4B731F79  bl 0x822c0938
	ctx.lr = 0x82B8E9C4;
	sub_822C0938(ctx, base);
	// 82B8E9C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8E9C8: 41820028  beq 0x82b8e9f0
	if ctx.cr[0].eq {
	pc = 0x82B8E9F0; continue 'dispatch;
	}
	// 82B8E9CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8E9D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8E9D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8E9D8: 392B8BA8  addi r9, r11, -0x7458
	ctx.r[9].s64 = ctx.r[11].s64 + -29784;
	// 82B8E9DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8E9E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8E9E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8E9E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8E9EC: 48000008  b 0x82b8e9f4
	pc = 0x82B8E9F4; continue 'dispatch;
	// 82B8E9F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8E9F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8E9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8E9FC: 409A0044  bne cr6, 0x82b8ea40
	if !ctx.cr[6].eq {
	pc = 0x82B8EA40; continue 'dispatch;
	}
	// 82B8EA00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EA04: 419A001C  beq cr6, 0x82b8ea20
	if ctx.cr[6].eq {
	pc = 0x82B8EA20; continue 'dispatch;
	}
	// 82B8EA08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EA0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8EA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EA14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EA18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8EA1C: 4E800421  bctrl
	ctx.lr = 0x82B8EA20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8EA20: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8EA24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8EA28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8EA2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8EA30: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8EA34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8EA38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8EA3C: 4B7315C5  bl 0x822c0000
	ctx.lr = 0x82B8EA40;
	sub_822C0000(ctx, base);
	// 82B8EA40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8EA44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8EA48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8EA4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8EA50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8EA54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8EA58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8EA60 size=196
    let mut pc: u32 = 0x82B8EA60;
    'dispatch: loop {
        match pc {
            0x82B8EA60 => {
    //   block [0x82B8EA60..0x82B8EB24)
	// 82B8EA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EA64: 48619709  bl 0x831a816c
	ctx.lr = 0x82B8EA68;
	sub_831A8130(ctx, base);
	// 82B8EA68: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82B8EA6C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EA70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8EA74: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EA78: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8EA7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EA80: 814A00C0  lwz r10, 0xc0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8EA84: C3EA0000  lfs f31, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8EA88: 409A000C  bne cr6, 0x82b8ea94
	if !ctx.cr[6].eq {
	pc = 0x82B8EA94; continue 'dispatch;
	}
	// 82B8EA8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8EA90: 48000010  b 0x82b8eaa0
	pc = 0x82B8EAA0; continue 'dispatch;
	// 82B8EA94: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82B8EA98: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8EA9C: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8EAA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EAA4: 419A0024  beq cr6, 0x82b8eac8
	if ctx.cr[6].eq {
	pc = 0x82B8EAC8; continue 'dispatch;
	}
	// 82B8EAA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8EAAC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8EAB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8EAB4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8EAB8: 48007D71  bl 0x82b96828
	ctx.lr = 0x82B8EABC;
	sub_82B96828(ctx, base);
	// 82B8EABC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8EAC0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8EAC4: 4082FFE8  bne 0x82b8eaac
	if !ctx.cr[0].eq {
	pc = 0x82B8EAAC; continue 'dispatch;
	}
	// 82B8EAC8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8EACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EAD0: 409A000C  bne cr6, 0x82b8eadc
	if !ctx.cr[6].eq {
	pc = 0x82B8EADC; continue 'dispatch;
	}
	// 82B8EAD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8EAD8: 48000010  b 0x82b8eae8
	pc = 0x82B8EAE8; continue 'dispatch;
	// 82B8EADC: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8EAE0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8EAE4: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8EAE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EAEC: 419A002C  beq cr6, 0x82b8eb18
	if ctx.cr[6].eq {
	pc = 0x82B8EB18; continue 'dispatch;
	}
	// 82B8EAF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8EAF4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8EAF8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8EAFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EB00: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8EB04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8EB08: 4E800421  bctrl
	ctx.lr = 0x82B8EB0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8EB0C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8EB10: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8EB14: 4082FFE0  bne 0x82b8eaf4
	if !ctx.cr[0].eq {
	pc = 0x82B8EAF4; continue 'dispatch;
	}
	// 82B8EB18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8EB1C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82B8EB20: 4861969C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8EB28 size=288
    let mut pc: u32 = 0x82B8EB28;
    'dispatch: loop {
        match pc {
            0x82B8EB28 => {
    //   block [0x82B8EB28..0x82B8EC48)
	// 82B8EB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EB2C: 48619641  bl 0x831a816c
	ctx.lr = 0x82B8EB30;
	sub_831A8130(ctx, base);
	// 82B8EB30: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82B8EB34: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82B8EB38: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82B8EB3C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EB40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8EB44: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82B8EB48: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EB4C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8EB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EB54: 814A00C0  lwz r10, 0xc0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8EB58: C3CA0000  lfs f30, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82B8EB5C: 409A000C  bne cr6, 0x82b8eb68
	if !ctx.cr[6].eq {
	pc = 0x82B8EB68; continue 'dispatch;
	}
	// 82B8EB60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8EB64: 48000010  b 0x82b8eb74
	pc = 0x82B8EB74; continue 'dispatch;
	// 82B8EB68: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82B8EB6C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8EB70: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8EB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EB78: 419A0068  beq cr6, 0x82b8ebe0
	if ctx.cr[6].eq {
	pc = 0x82B8EBE0; continue 'dispatch;
	}
	// 82B8EB7C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82B8EB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B8EB84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8EB88: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8EB8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EB90: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82B8EB94: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8EB98: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8EB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8EBA0: 419A0024  beq cr6, 0x82b8ebc4
	if ctx.cr[6].eq {
	pc = 0x82B8EBC4; continue 'dispatch;
	}
	// 82B8EBA4: 812B0048  lwz r9, 0x48(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8EBA8: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82B8EBAC: 7D4A1E71  srawi. r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82B8EBB0: 41820014  beq 0x82b8ebc4
	if ctx.cr[0].eq {
	pc = 0x82B8EBC4; continue 'dispatch;
	}
	// 82B8EBB4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8EBB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EBBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8EBC0: C04B0024  lfs f2, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82B8EBC4: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8EBC8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8EBCC: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8EBD0: 48007A61  bl 0x82b96630
	ctx.lr = 0x82B8EBD4;
	sub_82B96630(ctx, base);
	// 82B8EBD4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8EBD8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8EBDC: 4082FFB0  bne 0x82b8eb8c
	if !ctx.cr[0].eq {
	pc = 0x82B8EB8C; continue 'dispatch;
	}
	// 82B8EBE0: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8EBE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EBE8: 409A000C  bne cr6, 0x82b8ebf4
	if !ctx.cr[6].eq {
	pc = 0x82B8EBF4; continue 'dispatch;
	}
	// 82B8EBEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8EBF0: 48000010  b 0x82b8ec00
	pc = 0x82B8EC00; continue 'dispatch;
	// 82B8EBF4: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8EBF8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8EBFC: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8EC00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EC04: 419A0030  beq cr6, 0x82b8ec34
	if ctx.cr[6].eq {
	pc = 0x82B8EC34; continue 'dispatch;
	}
	// 82B8EC08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8EC0C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8EC10: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82B8EC14: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8EC18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8EC1C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82B8EC20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8EC24: 4E800421  bctrl
	ctx.lr = 0x82B8EC28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8EC28: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8EC2C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8EC30: 4082FFDC  bne 0x82b8ec0c
	if !ctx.cr[0].eq {
	pc = 0x82B8EC0C; continue 'dispatch;
	}
	// 82B8EC34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8EC38: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82B8EC3C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82B8EC40: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82B8EC44: 48619578  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8EC48 size=380
    let mut pc: u32 = 0x82B8EC48;
    'dispatch: loop {
        match pc {
            0x82B8EC48 => {
    //   block [0x82B8EC48..0x82B8EDC4)
	// 82B8EC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8EC50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8EC54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8EC58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EC5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8EC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8EC64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8EC68: 83FE00C0  lwz r31, 0xc0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8EC6C: 4B98085D  bl 0x8250f4c8
	ctx.lr = 0x82B8EC70;
	sub_8250F4C8(ctx, base);
	// 82B8EC70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8EC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EC78: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 82B8EC7C: 409A0008  bne cr6, 0x82b8ec84
	if !ctx.cr[6].eq {
	pc = 0x82B8EC84; continue 'dispatch;
	}
	// 82B8EC80: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8EC84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8EC88: 419A0058  beq cr6, 0x82b8ece0
	if ctx.cr[6].eq {
	pc = 0x82B8ECE0; continue 'dispatch;
	}
	// 82B8EC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EC90: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82B8EC94: 409A0008  bne cr6, 0x82b8ec9c
	if !ctx.cr[6].eq {
	pc = 0x82B8EC9C; continue 'dispatch;
	}
	// 82B8EC98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B8EC9C: 4B97989D  bl 0x82508538
	ctx.lr = 0x82B8ECA0;
	sub_82508538(ctx, base);
	// 82B8ECA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8ECA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8ECA8: 419A0038  beq cr6, 0x82b8ece0
	if ctx.cr[6].eq {
	pc = 0x82B8ECE0; continue 'dispatch;
	}
	// 82B8ECAC: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 82B8ECB0: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82B8ECB4: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 82B8ECB8: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 82B8ECBC: 38C00120  li r6, 0x120
	ctx.r[6].s64 = 288;
	// 82B8ECC0: 13FF40C7  vcmpequd (lvx128) v31, v31, v8
	tmp.u32 = ctx.r[31].u32 + ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8EDC8 size=108
    let mut pc: u32 = 0x82B8EDC8;
    'dispatch: loop {
        match pc {
            0x82B8EDC8 => {
    //   block [0x82B8EDC8..0x82B8EE34)
	// 82B8EDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8EDD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EDD4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B8EDD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8EDDC: 38C00024  li r6, 0x24
	ctx.r[6].s64 = 36;
	// 82B8EDE0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82B8EDE4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82B8EDE8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B8EDEC: 482632DD  bl 0x82df20c8
	ctx.lr = 0x82B8EDF0;
	sub_82DF20C8(ctx, base);
	// 82B8EDF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8EDF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8EDF8: 41820008  beq 0x82b8ee00
	if ctx.cr[0].eq {
	pc = 0x82B8EE00; continue 'dispatch;
	}
	// 82B8EDFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8EE00: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8EE04: 41820008  beq 0x82b8ee0c
	if ctx.cr[0].eq {
	pc = 0x82B8EE0C; continue 'dispatch;
	}
	// 82B8EE08: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8EE0C: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8EE10: 41820008  beq 0x82b8ee18
	if ctx.cr[0].eq {
	pc = 0x82B8EE18; continue 'dispatch;
	}
	// 82B8EE14: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8EE18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8EE1C: 99430021  stb r10, 0x21(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(33 as u32), ctx.r[10].u8 ) };
	// 82B8EE20: 99630020  stb r11, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82B8EE24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8EE28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8EE2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8EE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8EE38 size=188
    let mut pc: u32 = 0x82B8EE38;
    'dispatch: loop {
        match pc {
            0x82B8EE38 => {
    //   block [0x82B8EE38..0x82B8EEF4)
	// 82B8EE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8EE40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8EE44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8EE48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EE4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8EE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8EE54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8EE58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8EE5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8EE60: 4B731AD9  bl 0x822c0938
	ctx.lr = 0x82B8EE64;
	sub_822C0938(ctx, base);
	// 82B8EE64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8EE68: 41820028  beq 0x82b8ee90
	if ctx.cr[0].eq {
	pc = 0x82B8EE90; continue 'dispatch;
	}
	// 82B8EE6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8EE70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8EE74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8EE78: 392B8BBC  addi r9, r11, -0x7444
	ctx.r[9].s64 = ctx.r[11].s64 + -29764;
	// 82B8EE7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8EE80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8EE84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8EE88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8EE8C: 48000008  b 0x82b8ee94
	pc = 0x82B8EE94; continue 'dispatch;
	// 82B8EE90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8EE94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8EE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EE9C: 409A003C  bne cr6, 0x82b8eed8
	if !ctx.cr[6].eq {
	pc = 0x82B8EED8; continue 'dispatch;
	}
	// 82B8EEA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EEA4: 419A0014  beq cr6, 0x82b8eeb8
	if ctx.cr[6].eq {
	pc = 0x82B8EEB8; continue 'dispatch;
	}
	// 82B8EEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EEAC: 4BFF496D  bl 0x82b83818
	ctx.lr = 0x82B8EEB0;
	sub_82B83818(ctx, base);
	// 82B8EEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EEB4: 48263525  bl 0x82df23d8
	ctx.lr = 0x82B8EEB8;
	sub_82DF23D8(ctx, base);
	// 82B8EEB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8EEBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8EEC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8EEC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8EEC8: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8EECC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8EED0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8EED4: 4B73112D  bl 0x822c0000
	ctx.lr = 0x82B8EED8;
	sub_822C0000(ctx, base);
	// 82B8EED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8EEDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8EEE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8EEE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8EEE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8EEEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8EEF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8EEF8 size=64
    let mut pc: u32 = 0x82B8EEF8;
    'dispatch: loop {
        match pc {
            0x82B8EEF8 => {
    //   block [0x82B8EEF8..0x82B8EF38)
	// 82B8EEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8EF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8EF04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EF08: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8EF0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EF10: 419A0014  beq cr6, 0x82b8ef24
	if ctx.cr[6].eq {
	pc = 0x82B8EF24; continue 'dispatch;
	}
	// 82B8EF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EF18: 4BFF4901  bl 0x82b83818
	ctx.lr = 0x82B8EF1C;
	sub_82B83818(ctx, base);
	// 82B8EF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EF20: 482634B9  bl 0x82df23d8
	ctx.lr = 0x82B8EF24;
	sub_82DF23D8(ctx, base);
	// 82B8EF24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8EF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8EF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8EF30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8EF34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8EF38 size=188
    let mut pc: u32 = 0x82B8EF38;
    'dispatch: loop {
        match pc {
            0x82B8EF38 => {
    //   block [0x82B8EF38..0x82B8EFF4)
	// 82B8EF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8EF40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8EF44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8EF48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8EF4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8EF50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8EF54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8EF58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8EF5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8EF60: 4B7319D9  bl 0x822c0938
	ctx.lr = 0x82B8EF64;
	sub_822C0938(ctx, base);
	// 82B8EF64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8EF68: 41820028  beq 0x82b8ef90
	if ctx.cr[0].eq {
	pc = 0x82B8EF90; continue 'dispatch;
	}
	// 82B8EF6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8EF70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8EF74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8EF78: 392B8BD0  addi r9, r11, -0x7430
	ctx.r[9].s64 = ctx.r[11].s64 + -29744;
	// 82B8EF7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8EF80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8EF84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8EF88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8EF8C: 48000008  b 0x82b8ef94
	pc = 0x82B8EF94; continue 'dispatch;
	// 82B8EF90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8EF94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8EF98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8EF9C: 409A003C  bne cr6, 0x82b8efd8
	if !ctx.cr[6].eq {
	pc = 0x82B8EFD8; continue 'dispatch;
	}
	// 82B8EFA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8EFA4: 419A0014  beq cr6, 0x82b8efb8
	if ctx.cr[6].eq {
	pc = 0x82B8EFB8; continue 'dispatch;
	}
	// 82B8EFA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EFAC: 4BFF555D  bl 0x82b84508
	ctx.lr = 0x82B8EFB0;
	sub_82B84508(ctx, base);
	// 82B8EFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8EFB4: 48263425  bl 0x82df23d8
	ctx.lr = 0x82B8EFB8;
	sub_82DF23D8(ctx, base);
	// 82B8EFB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8EFBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8EFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8EFC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8EFC8: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8EFCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8EFD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8EFD4: 4B73102D  bl 0x822c0000
	ctx.lr = 0x82B8EFD8;
	sub_822C0000(ctx, base);
	// 82B8EFD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8EFDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8EFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8EFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8EFE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8EFEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8EFF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8EFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8EFF8 size=188
    let mut pc: u32 = 0x82B8EFF8;
    'dispatch: loop {
        match pc {
            0x82B8EFF8 => {
    //   block [0x82B8EFF8..0x82B8F0B4)
	// 82B8EFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8EFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F000: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F004: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F00C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8F010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8F014: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8F018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8F01C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F020: 4B731919  bl 0x822c0938
	ctx.lr = 0x82B8F024;
	sub_822C0938(ctx, base);
	// 82B8F024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8F028: 41820028  beq 0x82b8f050
	if ctx.cr[0].eq {
	pc = 0x82B8F050; continue 'dispatch;
	}
	// 82B8F02C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8F030: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8F034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8F038: 392B8BE4  addi r9, r11, -0x741c
	ctx.r[9].s64 = ctx.r[11].s64 + -29724;
	// 82B8F03C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8F040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8F044: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8F048: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8F04C: 48000008  b 0x82b8f054
	pc = 0x82B8F054; continue 'dispatch;
	// 82B8F050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8F054: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F05C: 409A003C  bne cr6, 0x82b8f098
	if !ctx.cr[6].eq {
	pc = 0x82B8F098; continue 'dispatch;
	}
	// 82B8F060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8F064: 419A0014  beq cr6, 0x82b8f078
	if ctx.cr[6].eq {
	pc = 0x82B8F078; continue 'dispatch;
	}
	// 82B8F068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F06C: 4B730F95  bl 0x822c0000
	ctx.lr = 0x82B8F070;
	sub_822C0000(ctx, base);
	// 82B8F070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F074: 48263365  bl 0x82df23d8
	ctx.lr = 0x82B8F078;
	sub_82DF23D8(ctx, base);
	// 82B8F078: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8F07C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8F080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F084: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8F088: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8F08C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8F090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8F094: 4B730F6D  bl 0x822c0000
	ctx.lr = 0x82B8F098;
	sub_822C0000(ctx, base);
	// 82B8F098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8F09C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F0A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F0A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F0A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8F0AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F0B8 size=64
    let mut pc: u32 = 0x82B8F0B8;
    'dispatch: loop {
        match pc {
            0x82B8F0B8 => {
    //   block [0x82B8F0B8..0x82B8F0F8)
	// 82B8F0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F0C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F0C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F0C8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8F0CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8F0D0: 419A0014  beq cr6, 0x82b8f0e4
	if ctx.cr[6].eq {
	pc = 0x82B8F0E4; continue 'dispatch;
	}
	// 82B8F0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F0D8: 4BFF5431  bl 0x82b84508
	ctx.lr = 0x82B8F0DC;
	sub_82B84508(ctx, base);
	// 82B8F0DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F0E0: 482632F9  bl 0x82df23d8
	ctx.lr = 0x82B8F0E4;
	sub_82DF23D8(ctx, base);
	// 82B8F0E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8F0E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F0EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F0F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F0F8 size=64
    let mut pc: u32 = 0x82B8F0F8;
    'dispatch: loop {
        match pc {
            0x82B8F0F8 => {
    //   block [0x82B8F0F8..0x82B8F138)
	// 82B8F0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F108: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8F10C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8F110: 419A0014  beq cr6, 0x82b8f124
	if ctx.cr[6].eq {
	pc = 0x82B8F124; continue 'dispatch;
	}
	// 82B8F114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F118: 4B730EE9  bl 0x822c0000
	ctx.lr = 0x82B8F11C;
	sub_822C0000(ctx, base);
	// 82B8F11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F120: 482632B9  bl 0x82df23d8
	ctx.lr = 0x82B8F124;
	sub_82DF23D8(ctx, base);
	// 82B8F124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8F128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F138 size=288
    let mut pc: u32 = 0x82B8F138;
    'dispatch: loop {
        match pc {
            0x82B8F138 => {
    //   block [0x82B8F138..0x82B8F258)
	// 82B8F138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F13C: 4861901D  bl 0x831a8158
	ctx.lr = 0x82B8F140;
	sub_831A8130(ctx, base);
	// 82B8F140: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F144: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8F148: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82B8F14C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8F150: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B8F154: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82B8F158: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82B8F15C: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8F160: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82B8F164: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8F168: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 82B8F16C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82B8F170: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8F174: 419A0088  beq cr6, 0x82b8f1fc
	if ctx.cr[6].eq {
	pc = 0x82B8F1FC; continue 'dispatch;
	}
	// 82B8F178: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82B8F17C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8F180: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B8F184: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82B8F188: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8F18C: 4BFFF69D  bl 0x82b8e828
	ctx.lr = 0x82B8F190;
	sub_82B8E828(ctx, base);
	// 82B8F190: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82B8F194: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82B8F198: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82B8F19C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82B8F1A0: 4B7352C1  bl 0x822c4460
	ctx.lr = 0x82B8F1A4;
	sub_822C4460(ctx, base);
	// 82B8F1A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8F1A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F1AC: 419A0008  beq cr6, 0x82b8f1b4
	if ctx.cr[6].eq {
	pc = 0x82B8F1B4; continue 'dispatch;
	}
	// 82B8F1B0: 4B7316E1  bl 0x822c0890
	ctx.lr = 0x82B8F1B4;
	sub_822C0890(ctx, base);
	// 82B8F1B4: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8F1B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82B8F1BC: 419A002C  beq cr6, 0x82b8f1e8
	if ctx.cr[6].eq {
	pc = 0x82B8F1E8; continue 'dispatch;
	}
	// 82B8F1C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B8F1C4: 4B981E1D  bl 0x82510fe0
	ctx.lr = 0x82B8F1C8;
	sub_82510FE0(ctx, base);
	// 82B8F1C8: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82B8F1CC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B8F1D0: 48264139  bl 0x82df3308
	ctx.lr = 0x82B8F1D4;
	sub_82DF3308(ctx, base);
	// 82B8F1D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8F1D8: 41820010  beq 0x82b8f1e8
	if ctx.cr[0].eq {
	pc = 0x82B8F1E8; continue 'dispatch;
	}
	// 82B8F1DC: 7F18D800  cmpw cr6, r24, r27
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82B8F1E0: 419A003C  beq cr6, 0x82b8f21c
	if ctx.cr[6].eq {
	pc = 0x82B8F21C; continue 'dispatch;
	}
	// 82B8F1E4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82B8F1E8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8F1EC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82B8F1F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8F1F4: 409AFF84  bne cr6, 0x82b8f178
	if !ctx.cr[6].eq {
	pc = 0x82B8F178; continue 'dispatch;
	}
	// 82B8F1F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8F1FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F200: 419A0008  beq cr6, 0x82b8f208
	if ctx.cr[6].eq {
	pc = 0x82B8F208; continue 'dispatch;
	}
	// 82B8F204: 4B73168D  bl 0x822c0890
	ctx.lr = 0x82B8F208;
	sub_822C0890(ctx, base);
	// 82B8F208: 935D0000  stw r26, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82B8F20C: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82B8F210: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8F214: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B8F218: 48618F90  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
	// 82B8F21C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B8F220: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B8F224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F228: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82B8F22C: 419AFFE4  beq cr6, 0x82b8f210
	if ctx.cr[6].eq {
	pc = 0x82B8F210; continue 'dispatch;
	}
	// 82B8F230: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82B8F234: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82B8F238: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8F23C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82B8F240: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B8F244: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82B8F248: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82B8F24C: 4082FFE8  bne 0x82b8f234
	if !ctx.cr[0].eq {
	pc = 0x82B8F234; continue 'dispatch;
	}
	// 82B8F250: 4B731641  bl 0x822c0890
	ctx.lr = 0x82B8F254;
	sub_822C0890(ctx, base);
	// 82B8F254: 4BFFFFBC  b 0x82b8f210
	pc = 0x82B8F210; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F258 size=76
    let mut pc: u32 = 0x82B8F258;
    'dispatch: loop {
        match pc {
            0x82B8F258 => {
    //   block [0x82B8F258..0x82B8F2A4)
	// 82B8F258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F264: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F268: 814400C0  lwz r10, 0xc0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F26C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82B8F270: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82B8F274: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82B8F278: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82B8F27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8F280: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F284: 7C8B482E  lwzx r4, r11, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82B8F288: 4BFFFEB1  bl 0x82b8f138
	ctx.lr = 0x82B8F28C;
	sub_82B8F138(ctx, base);
	// 82B8F28C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F290: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8F294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F29C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F2A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F2A8 size=252
    let mut pc: u32 = 0x82B8F2A8;
    'dispatch: loop {
        match pc {
            0x82B8F2A8 => {
    //   block [0x82B8F2A8..0x82B8F3A4)
	// 82B8F2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F2B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F2B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F2B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8F2C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8F2C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82B8F2C8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B8F2CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B8F2D0: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8F2D4: 83E400C0  lwz r31, 0xc0(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F2D8: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F2DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8F2E0: 419A0094  beq cr6, 0x82b8f374
	if ctx.cr[6].eq {
	pc = 0x82B8F374; continue 'dispatch;
	}
	// 82B8F2E4: 813F0048  lwz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8F2E8: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82B8F2EC: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82B8F2F0: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B8F2F4: 40980080  bge cr6, 0x82b8f374
	if !ctx.cr[6].lt {
	pc = 0x82B8F374; continue 'dispatch;
	}
	// 82B8F2F8: 811F00D4  lwz r8, 0xd4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82B8F2FC: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82B8F300: 419A0044  beq cr6, 0x82b8f344
	if ctx.cr[6].eq {
	pc = 0x82B8F344; continue 'dispatch;
	}
	// 82B8F304: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F308: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82B8F30C: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82B8F310: 812A0034  lwz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8F314: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B8F318: 419A0028  beq cr6, 0x82b8f340
	if ctx.cr[6].eq {
	pc = 0x82B8F340; continue 'dispatch;
	}
	// 82B8F31C: 80EA0038  lwz r7, 0x38(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82B8F320: 7D293850  subf r9, r9, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82B8F324: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82B8F328: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B8F32C: 40980014  bge cr6, 0x82b8f340
	if !ctx.cr[6].lt {
	pc = 0x82B8F340; continue 'dispatch;
	}
	// 82B8F330: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B8F334: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B8F338: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8F33C: 48000008  b 0x82b8f344
	pc = 0x82B8F344; continue 'dispatch;
	// 82B8F340: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82B8F344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8F348: 4198002C  blt cr6, 0x82b8f374
	if ctx.cr[6].lt {
	pc = 0x82B8F374; continue 'dispatch;
	}
	// 82B8F34C: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F350: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82B8F354: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B8F358: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82B8F35C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8F360: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82B8F364: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B8F368: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F36C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F370: 4B7350F1  bl 0x822c4460
	ctx.lr = 0x82B8F374;
	sub_822C4460(ctx, base);
	// 82B8F374: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F37C: 409A000C  bne cr6, 0x82b8f388
	if !ctx.cr[6].eq {
	pc = 0x82B8F388; continue 'dispatch;
	}
	// 82B8F380: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8F384: 997F00D8  stb r11, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u8 ) };
	// 82B8F388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8F38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F398: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8F39C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F3A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8F3A8 size=380
    let mut pc: u32 = 0x82B8F3A8;
    'dispatch: loop {
        match pc {
            0x82B8F3A8 => {
    //   block [0x82B8F3A8..0x82B8F524)
	// 82B8F3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F3B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F3B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F3B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F3BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8F3C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F3C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8F3C8: 83FE00C0  lwz r31, 0xc0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F3CC: 4B9800FD  bl 0x8250f4c8
	ctx.lr = 0x82B8F3D0;
	sub_8250F4C8(ctx, base);
	// 82B8F3D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8F3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F3D8: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 82B8F3DC: 409A0008  bne cr6, 0x82b8f3e4
	if !ctx.cr[6].eq {
	pc = 0x82B8F3E4; continue 'dispatch;
	}
	// 82B8F3E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8F3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B8F3E8: 419A0058  beq cr6, 0x82b8f440
	if ctx.cr[6].eq {
	pc = 0x82B8F440; continue 'dispatch;
	}
	// 82B8F3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F3F0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82B8F3F4: 409A0008  bne cr6, 0x82b8f3fc
	if !ctx.cr[6].eq {
	pc = 0x82B8F3FC; continue 'dispatch;
	}
	// 82B8F3F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B8F3FC: 4B97913D  bl 0x82508538
	ctx.lr = 0x82B8F400;
	sub_82508538(ctx, base);
	// 82B8F400: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F408: 419A0038  beq cr6, 0x82b8f440
	if ctx.cr[6].eq {
	pc = 0x82B8F440; continue 'dispatch;
	}
	// 82B8F40C: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 82B8F410: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82B8F414: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 82B8F418: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 82B8F41C: 38C00120  li r6, 0x120
	ctx.r[6].s64 = 288;
	// 82B8F420: 13EB40C7  vcmpequd (lvx128) v31, v11, v8
	tmp.u32 = ctx.r[11].u32 + ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F528 size=112
    let mut pc: u32 = 0x82B8F528;
    'dispatch: loop {
        match pc {
            0x82B8F528 => {
    //   block [0x82B8F528..0x82B8F598)
	// 82B8F528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F52C: 48618C41  bl 0x831a816c
	ctx.lr = 0x82B8F530;
	sub_831A8130(ctx, base);
	// 82B8F530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F534: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8F538: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B8F53C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B8F540: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8F544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8F548: 4BFFF289  bl 0x82b8e7d0
	ctx.lr = 0x82B8F54C;
	sub_82B8E7D0(ctx, base);
	// 82B8F54C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F550: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82B8F554: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8F558: 419A0020  beq cr6, 0x82b8f578
	if ctx.cr[6].eq {
	pc = 0x82B8F578; continue 'dispatch;
	}
	// 82B8F55C: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 82B8F560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8F564: 48263CD5  bl 0x82df3238
	ctx.lr = 0x82B8F568;
	sub_82DF3238(ctx, base);
	// 82B8F568: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8F56C: 4082000C  bne 0x82b8f578
	if !ctx.cr[0].eq {
	pc = 0x82B8F578; continue 'dispatch;
	}
	// 82B8F570: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82B8F574: 48000010  b 0x82b8f584
	pc = 0x82B8F584; continue 'dispatch;
	// 82B8F578: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F57C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82B8F580: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82B8F584: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F588: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8F58C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F590: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8F594: 48618C28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F598 size=88
    let mut pc: u32 = 0x82B8F598;
    'dispatch: loop {
        match pc {
            0x82B8F598 => {
    //   block [0x82B8F598..0x82B8F5F0)
	// 82B8F598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F5A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8F5AC: 4BFFF81D  bl 0x82b8edc8
	ctx.lr = 0x82B8F5B0;
	sub_82B8EDC8(ctx, base);
	// 82B8F5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8F5B4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82B8F5B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B8F5BC: 99630021  stb r11, 0x21(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(33 as u32), ctx.r[11].u8 ) };
	// 82B8F5C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F5C4: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B8F5C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F5CC: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F5D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F5D4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B8F5D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8F5DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B8F5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F5E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8F5F0 size=452
    let mut pc: u32 = 0x82B8F5F0;
    'dispatch: loop {
        match pc {
            0x82B8F5F0 => {
    //   block [0x82B8F5F0..0x82B8F7B4)
	// 82B8F5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F5F4: 48618B71  bl 0x831a8164
	ctx.lr = 0x82B8F5F8;
	sub_831A8130(ctx, base);
	// 82B8F5F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F5FC: 83E300C0  lwz r31, 0xc0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F600: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8F604: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8F608: 408201A4  bne 0x82b8f7ac
	if !ctx.cr[0].eq {
	pc = 0x82B8F7AC; continue 'dispatch;
	}
	// 82B8F60C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F614: 419A0198  beq cr6, 0x82b8f7ac
	if ctx.cr[6].eq {
	pc = 0x82B8F7AC; continue 'dispatch;
	}
	// 82B8F618: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8F61C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8F620: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8F624: 41820188  beq 0x82b8f7ac
	if ctx.cr[0].eq {
	pc = 0x82B8F7AC; continue 'dispatch;
	}
	// 82B8F628: 4BFFFD81  bl 0x82b8f3a8
	ctx.lr = 0x82B8F62C;
	sub_82B8F3A8(ctx, base);
	// 82B8F62C: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F630: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B8F634: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8F638: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F63C: 836A0004  lwz r27, 4(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F640: C01B001C  lfs f0, 0x1c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8F644: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82B8F648: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82B8F64C: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82B8F650: 9BBF0009  stb r29, 9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(9 as u32), ctx.r[29].u8 ) };
	// 82B8F654: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82B8F658: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82B8F65C: 9BBF00D8  stb r29, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[29].u8 ) };
	// 82B8F660: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8F664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F668: 409A000C  bne cr6, 0x82b8f674
	if !ctx.cr[6].eq {
	pc = 0x82B8F674; continue 'dispatch;
	}
	// 82B8F66C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B8F670: 48000010  b 0x82b8f680
	pc = 0x82B8F680; continue 'dispatch;
	// 82B8F674: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8F678: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8F67C: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8F680: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8F684: 419A002C  beq cr6, 0x82b8f6b0
	if ctx.cr[6].eq {
	pc = 0x82B8F6B0; continue 'dispatch;
	}
	// 82B8F688: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82B8F68C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8F690: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8F694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F698: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F69C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8F6A0: 4E800421  bctrl
	ctx.lr = 0x82B8F6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8F6A4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8F6A8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B8F6AC: 4082FFE0  bne 0x82b8f68c
	if !ctx.cr[0].eq {
	pc = 0x82B8F68C; continue 'dispatch;
	}
	// 82B8F6B0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8F6B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F6B8: 409A000C  bne cr6, 0x82b8f6c4
	if !ctx.cr[6].eq {
	pc = 0x82B8F6C4; continue 'dispatch;
	}
	// 82B8F6BC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B8F6C0: 48000010  b 0x82b8f6d0
	pc = 0x82B8F6D0; continue 'dispatch;
	// 82B8F6C4: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8F6C8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8F6CC: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8F6D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8F6D4: 419A002C  beq cr6, 0x82b8f700
	if ctx.cr[6].eq {
	pc = 0x82B8F700; continue 'dispatch;
	}
	// 82B8F6D8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82B8F6DC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8F6E0: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8F6E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F6E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F6EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8F6F0: 4E800421  bctrl
	ctx.lr = 0x82B8F6F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8F6F4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8F6F8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B8F6FC: 4082FFE0  bne 0x82b8f6dc
	if !ctx.cr[0].eq {
	pc = 0x82B8F6DC; continue 'dispatch;
	}
	// 82B8F700: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8F704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F708: 409A000C  bne cr6, 0x82b8f714
	if !ctx.cr[6].eq {
	pc = 0x82B8F714; continue 'dispatch;
	}
	// 82B8F70C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B8F710: 48000010  b 0x82b8f720
	pc = 0x82B8F720; continue 'dispatch;
	// 82B8F714: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B8F718: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8F71C: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8F720: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8F724: 419A0020  beq cr6, 0x82b8f744
	if ctx.cr[6].eq {
	pc = 0x82B8F744; continue 'dispatch;
	}
	// 82B8F728: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82B8F72C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8F730: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8F734: 4BFF45D5  bl 0x82b83d08
	ctx.lr = 0x82B8F738;
	sub_82B83D08(ctx, base);
	// 82B8F738: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8F73C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B8F740: 4082FFEC  bne 0x82b8f72c
	if !ctx.cr[0].eq {
	pc = 0x82B8F72C; continue 'dispatch;
	}
	// 82B8F744: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B8F748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F74C: 419A0008  beq cr6, 0x82b8f754
	if ctx.cr[6].eq {
	pc = 0x82B8F754; continue 'dispatch;
	}
	// 82B8F750: 4B7308B1  bl 0x822c0000
	ctx.lr = 0x82B8F754;
	sub_822C0000(ctx, base);
	// 82B8F754: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82B8F758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F75C: 419A0010  beq cr6, 0x82b8f76c
	if ctx.cr[6].eq {
	pc = 0x82B8F76C; continue 'dispatch;
	}
	// 82B8F760: C05B0020  lfs f2, 0x20(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82B8F764: C03B001C  lfs f1, 0x1c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8F768: 4BFF3DA9  bl 0x82b83510
	ctx.lr = 0x82B8F76C;
	sub_82B83510(ctx, base);
	// 82B8F76C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8F774: 409A000C  bne cr6, 0x82b8f780
	if !ctx.cr[6].eq {
	pc = 0x82B8F780; continue 'dispatch;
	}
	// 82B8F778: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B8F77C: 48000010  b 0x82b8f78c
	pc = 0x82B8F78C; continue 'dispatch;
	// 82B8F780: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8F784: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8F788: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8F78C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8F790: 419A001C  beq cr6, 0x82b8f7ac
	if ctx.cr[6].eq {
	pc = 0x82B8F7AC; continue 'dispatch;
	}
	// 82B8F794: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8F798: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82B8F79C: 4BFFED1D  bl 0x82b8e4b8
	ctx.lr = 0x82B8F7A0;
	sub_82B8E4B8(ctx, base);
	// 82B8F7A0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8F7A4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B8F7A8: 4082FFEC  bne 0x82b8f794
	if !ctx.cr[0].eq {
	pc = 0x82B8F794; continue 'dispatch;
	}
	// 82B8F7AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8F7B0: 48618A04  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F7B8 size=80
    let mut pc: u32 = 0x82B8F7B8;
    'dispatch: loop {
        match pc {
            0x82B8F7B8 => {
    //   block [0x82B8F7B8..0x82B8F808)
	// 82B8F7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F7C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F7C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F7C8: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F7CC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82B8F7D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F7D4: 388B00A4  addi r4, r11, 0xa4
	ctx.r[4].s64 = ctx.r[11].s64 + 164;
	// 82B8F7D8: 83EB00A8  lwz r31, 0xa8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 82B8F7DC: 4B73C02D  bl 0x822cb808
	ctx.lr = 0x82B8F7E0;
	sub_822CB808(ctx, base);
	// 82B8F7E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F7E4: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82B8F7E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82B8F7EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82B8F7F0: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82B8F7F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F7F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F7FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F808 size=72
    let mut pc: u32 = 0x82B8F808;
    'dispatch: loop {
        match pc {
            0x82B8F808 => {
    //   block [0x82B8F808..0x82B8F850)
	// 82B8F808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F814: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F818: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F820: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 82B8F824: 4B9FC6ED  bl 0x8258bf10
	ctx.lr = 0x82B8F828;
	sub_8258BF10(ctx, base);
	// 82B8F828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B8F82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F830: 4B9FC749  bl 0x8258bf78
	ctx.lr = 0x82B8F834;
	sub_8258BF78(ctx, base);
	// 82B8F834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F838: 4B739481  bl 0x822c8cb8
	ctx.lr = 0x82B8F83C;
	sub_822C8CB8(ctx, base);
	// 82B8F83C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B8F840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F850 size=80
    let mut pc: u32 = 0x82B8F850;
    'dispatch: loop {
        match pc {
            0x82B8F850 => {
    //   block [0x82B8F850..0x82B8F8A0)
	// 82B8F850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F858: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F85C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F860: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F864: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82B8F868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F86C: 388B00B0  addi r4, r11, 0xb0
	ctx.r[4].s64 = ctx.r[11].s64 + 176;
	// 82B8F870: 83EB00B4  lwz r31, 0xb4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 82B8F874: 4B73BF95  bl 0x822cb808
	ctx.lr = 0x82B8F878;
	sub_822CB808(ctx, base);
	// 82B8F878: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F87C: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82B8F880: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82B8F884: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82B8F888: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82B8F88C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F89C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F8A0 size=80
    let mut pc: u32 = 0x82B8F8A0;
    'dispatch: loop {
        match pc {
            0x82B8F8A0 => {
    //   block [0x82B8F8A0..0x82B8F8F0)
	// 82B8F8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F8AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F8B0: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F8B4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82B8F8B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8F8BC: 388B00BC  addi r4, r11, 0xbc
	ctx.r[4].s64 = ctx.r[11].s64 + 188;
	// 82B8F8C0: 83EB00C0  lwz r31, 0xc0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8F8C4: 4B73BF45  bl 0x822cb808
	ctx.lr = 0x82B8F8C8;
	sub_822CB808(ctx, base);
	// 82B8F8C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8F8CC: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82B8F8D0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82B8F8D4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82B8F8D8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82B8F8DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F8F0 size=112
    let mut pc: u32 = 0x82B8F8F0;
    'dispatch: loop {
        match pc {
            0x82B8F8F0 => {
    //   block [0x82B8F8F0..0x82B8F960)
	// 82B8F8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F904: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8F908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8F90C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8F910: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8F914: 4BFFF625  bl 0x82b8ef38
	ctx.lr = 0x82B8F918;
	sub_82B8EF38(ctx, base);
	// 82B8F918: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8F91C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8F920: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8F924: 4B7306DD  bl 0x822c0000
	ctx.lr = 0x82B8F928;
	sub_822C0000(ctx, base);
	// 82B8F928: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8F92C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8F930: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F934: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F93C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8F940: 419A0008  beq cr6, 0x82b8f948
	if ctx.cr[6].eq {
	pc = 0x82B8F948; continue 'dispatch;
	}
	// 82B8F944: 4B730F4D  bl 0x822c0890
	ctx.lr = 0x82B8F948;
	sub_822C0890(ctx, base);
	// 82B8F948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8F958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F960 size=112
    let mut pc: u32 = 0x82B8F960;
    'dispatch: loop {
        match pc {
            0x82B8F960 => {
    //   block [0x82B8F960..0x82B8F9D0)
	// 82B8F960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F96C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F974: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B8F978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B8F97C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B8F980: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8F984: 4BFFF675  bl 0x82b8eff8
	ctx.lr = 0x82B8F988;
	sub_82B8EFF8(ctx, base);
	// 82B8F988: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B8F98C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8F990: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8F994: 4B73066D  bl 0x822c0000
	ctx.lr = 0x82B8F998;
	sub_822C0000(ctx, base);
	// 82B8F998: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8F99C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8F9A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F9A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8F9A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8F9AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8F9B0: 419A0008  beq cr6, 0x82b8f9b8
	if ctx.cr[6].eq {
	pc = 0x82B8F9B8; continue 'dispatch;
	}
	// 82B8F9B4: 4B730EDD  bl 0x822c0890
	ctx.lr = 0x82B8F9B8;
	sub_822C0890(ctx, base);
	// 82B8F9B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8F9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8F9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8F9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8F9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8F9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8F9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B8F9D0 size=184
    let mut pc: u32 = 0x82B8F9D0;
    'dispatch: loop {
        match pc {
            0x82B8F9D0 => {
    //   block [0x82B8F9D0..0x82B8FA88)
	// 82B8F9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8F9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B8F9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B8F9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B8F9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8F9E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B8F9E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8F9EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B8F9F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B8F9F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8F9F8: 4B730F41  bl 0x822c0938
	ctx.lr = 0x82B8F9FC;
	sub_822C0938(ctx, base);
	// 82B8F9FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FA00: 41820028  beq 0x82b8fa28
	if ctx.cr[0].eq {
	pc = 0x82B8FA28; continue 'dispatch;
	}
	// 82B8FA04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B8FA08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B8FA0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B8FA10: 392B8B6C  addi r9, r11, -0x7494
	ctx.r[9].s64 = ctx.r[11].s64 + -29844;
	// 82B8FA14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B8FA18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B8FA1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B8FA20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B8FA24: 48000008  b 0x82b8fa2c
	pc = 0x82B8FA2C; continue 'dispatch;
	// 82B8FA28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8FA2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B8FA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FA34: 409A0038  bne cr6, 0x82b8fa6c
	if !ctx.cr[6].eq {
	pc = 0x82B8FA6C; continue 'dispatch;
	}
	// 82B8FA38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FA3C: 419A0010  beq cr6, 0x82b8fa4c
	if ctx.cr[6].eq {
	pc = 0x82B8FA4C; continue 'dispatch;
	}
	// 82B8FA40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B8FA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8FA48: 48005339  bl 0x82b94d80
	ctx.lr = 0x82B8FA4C;
	sub_82B94D80(ctx, base);
	// 82B8FA4C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B8FA50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B8FA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8FA58: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B8FA5C: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B8FA60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B8FA64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B8FA68: 4B730599  bl 0x822c0000
	ctx.lr = 0x82B8FA6C;
	sub_822C0000(ctx, base);
	// 82B8FA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B8FA70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B8FA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B8FA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B8FA7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B8FA80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B8FA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8FA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8FA88 size=680
    let mut pc: u32 = 0x82B8FA88;
    'dispatch: loop {
        match pc {
            0x82B8FA88 => {
    //   block [0x82B8FA88..0x82B8FD30)
	// 82B8FA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8FA8C: 486186D9  bl 0x831a8164
	ctx.lr = 0x82B8FA90;
	sub_831A8130(ctx, base);
	// 82B8FA90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8FA94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82B8FA98: 83BB00C0  lwz r29, 0xc0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8FA9C: 897D0008  lbz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8FAA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FAA4: 41820284  beq 0x82b8fd28
	if ctx.cr[0].eq {
	pc = 0x82B8FD28; continue 'dispatch;
	}
	// 82B8FAA8: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8FAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FAB0: 409A000C  bne cr6, 0x82b8fabc
	if !ctx.cr[6].eq {
	pc = 0x82B8FABC; continue 'dispatch;
	}
	// 82B8FAB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8FAB8: 48000010  b 0x82b8fac8
	pc = 0x82B8FAC8; continue 'dispatch;
	// 82B8FABC: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8FAC0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FAC4: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FAC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FACC: 419A0020  beq cr6, 0x82b8faec
	if ctx.cr[6].eq {
	pc = 0x82B8FAEC; continue 'dispatch;
	}
	// 82B8FAD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FAD4: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8FAD8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8FADC: 4BFFEF85  bl 0x82b8ea60
	ctx.lr = 0x82B8FAE0;
	sub_82B8EA60(ctx, base);
	// 82B8FAE0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8FAE4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FAE8: 4082FFEC  bne 0x82b8fad4
	if !ctx.cr[0].eq {
	pc = 0x82B8FAD4; continue 'dispatch;
	}
	// 82B8FAEC: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FAF4: 409A000C  bne cr6, 0x82b8fb00
	if !ctx.cr[6].eq {
	pc = 0x82B8FB00; continue 'dispatch;
	}
	// 82B8FAF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8FAFC: 48000010  b 0x82b8fb0c
	pc = 0x82B8FB0C; continue 'dispatch;
	// 82B8FB00: 815D0058  lwz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8FB04: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FB08: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FB0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FB10: 419A0074  beq cr6, 0x82b8fb84
	if ctx.cr[6].eq {
	pc = 0x82B8FB84; continue 'dispatch;
	}
	// 82B8FB14: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FB18: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82B8FB1C: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FB20: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8FB24: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8FB28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FB2C: 4182001C  beq 0x82b8fb48
	if ctx.cr[0].eq {
	pc = 0x82B8FB48; continue 'dispatch;
	}
	// 82B8FB30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FB34: 815B00C0  lwz r10, 0xc0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8FB38: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8FB3C: C02A0000  lfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8FB40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FB44: 4E800421  bctrl
	ctx.lr = 0x82B8FB48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FB48: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82B8FB4C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FB50: 4082FFCC  bne 0x82b8fb1c
	if !ctx.cr[0].eq {
	pc = 0x82B8FB1C; continue 'dispatch;
	}
	// 82B8FB54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FB58: 419A002C  beq cr6, 0x82b8fb84
	if ctx.cr[6].eq {
	pc = 0x82B8FB84; continue 'dispatch;
	}
	// 82B8FB5C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FB60: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FB64: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B8FB68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FB6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8FB70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FB74: 4E800421  bctrl
	ctx.lr = 0x82B8FB78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FB78: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8FB7C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FB80: 4082FFE0  bne 0x82b8fb60
	if !ctx.cr[0].eq {
	pc = 0x82B8FB60; continue 'dispatch;
	}
	// 82B8FB84: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8FB88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FB8C: 409A000C  bne cr6, 0x82b8fb98
	if !ctx.cr[6].eq {
	pc = 0x82B8FB98; continue 'dispatch;
	}
	// 82B8FB90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8FB94: 48000010  b 0x82b8fba4
	pc = 0x82B8FBA4; continue 'dispatch;
	// 82B8FB98: 815D0068  lwz r10, 0x68(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8FB9C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FBA0: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FBA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FBA8: 419A0074  beq cr6, 0x82b8fc1c
	if ctx.cr[6].eq {
	pc = 0x82B8FC1C; continue 'dispatch;
	}
	// 82B8FBAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FBB0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82B8FBB4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8FBB8: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FBBC: 89630018  lbz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8FBC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FBC4: 4182001C  beq 0x82b8fbe0
	if ctx.cr[0].eq {
	pc = 0x82B8FBE0; continue 'dispatch;
	}
	// 82B8FBC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FBCC: 815B00C0  lwz r10, 0xc0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8FBD0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8FBD4: C02A0000  lfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82B8FBD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FBDC: 4E800421  bctrl
	ctx.lr = 0x82B8FBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FBE0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82B8FBE4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FBE8: 4082FFCC  bne 0x82b8fbb4
	if !ctx.cr[0].eq {
	pc = 0x82B8FBB4; continue 'dispatch;
	}
	// 82B8FBEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FBF0: 419A002C  beq cr6, 0x82b8fc1c
	if ctx.cr[6].eq {
	pc = 0x82B8FC1C; continue 'dispatch;
	}
	// 82B8FBF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FBF8: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8FBFC: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FC00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FC04: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8FC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FC0C: 4E800421  bctrl
	ctx.lr = 0x82B8FC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FC10: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8FC14: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FC18: 4082FFE0  bne 0x82b8fbf8
	if !ctx.cr[0].eq {
	pc = 0x82B8FBF8; continue 'dispatch;
	}
	// 82B8FC1C: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8FC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FC24: 409A000C  bne cr6, 0x82b8fc30
	if !ctx.cr[6].eq {
	pc = 0x82B8FC30; continue 'dispatch;
	}
	// 82B8FC28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B8FC2C: 48000010  b 0x82b8fc3c
	pc = 0x82B8FC3C; continue 'dispatch;
	// 82B8FC30: 815D0078  lwz r10, 0x78(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B8FC34: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FC38: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FC3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B8FC40: 419A0020  beq cr6, 0x82b8fc60
	if ctx.cr[6].eq {
	pc = 0x82B8FC60; continue 'dispatch;
	}
	// 82B8FC44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FC48: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8FC4C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FC50: 4BFF4759  bl 0x82b843a8
	ctx.lr = 0x82B8FC54;
	sub_82B843A8(ctx, base);
	// 82B8FC54: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B8FC58: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B8FC5C: 4082FFEC  bne 0x82b8fc48
	if !ctx.cr[0].eq {
	pc = 0x82B8FC48; continue 'dispatch;
	}
	// 82B8FC60: 807D0080  lwz r3, 0x80(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B8FC64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8FC68: 419A0008  beq cr6, 0x82b8fc70
	if ctx.cr[6].eq {
	pc = 0x82B8FC70; continue 'dispatch;
	}
	// 82B8FC6C: 4B730395  bl 0x822c0000
	ctx.lr = 0x82B8FC70;
	sub_822C0000(ctx, base);
	// 82B8FC70: 807D0088  lwz r3, 0x88(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 82B8FC74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B8FC78: 419A0008  beq cr6, 0x82b8fc80
	if ctx.cr[6].eq {
	pc = 0x82B8FC80; continue 'dispatch;
	}
	// 82B8FC7C: 4B730385  bl 0x822c0000
	ctx.lr = 0x82B8FC80;
	sub_822C0000(ctx, base);
	// 82B8FC80: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82B8FC84: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FC88: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8FC8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82B8FC90: 419A006C  beq cr6, 0x82b8fcfc
	if ctx.cr[6].eq {
	pc = 0x82B8FCFC; continue 'dispatch;
	}
	// 82B8FC94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82B8FC98: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82B8FC9C: 3BCB8408  addi r30, r11, -0x7bf8
	ctx.r[30].s64 = ctx.r[11].s64 + -31736;
	// 82B8FCA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B8FCA4: 809C271C  lwz r4, 0x271c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(10012 as u32) ) } as u64;
	// 82B8FCA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8FCAC: 48261F4D  bl 0x82df1bf8
	ctx.lr = 0x82B8FCB0;
	sub_82DF1BF8(ctx, base);
	// 82B8FCB0: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82B8FCB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B8FCB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8FCBC: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8FCC0: 48263FE1  bl 0x82df3ca0
	ctx.lr = 0x82B8FCC4;
	sub_82DF3CA0(ctx, base);
	// 82B8FCC4: 482634ED  bl 0x82df31b0
	ctx.lr = 0x82B8FCC8;
	sub_82DF31B0(ctx, base);
	// 82B8FCC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B8FCCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B8FCD0: 482C0419  bl 0x82e500e8
	ctx.lr = 0x82B8FCD4;
	sub_82E500E8(ctx, base);
	// 82B8FCD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B8FCD8: 48261FB9  bl 0x82df1c90
	ctx.lr = 0x82B8FCDC;
	sub_82DF1C90(ctx, base);
	// 82B8FCDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B8FCE0: 48263749  bl 0x82df3428
	ctx.lr = 0x82B8FCE4;
	sub_82DF3428(ctx, base);
	// 82B8FCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B8FCE8: 4B9BEC01  bl 0x8254e8e8
	ctx.lr = 0x82B8FCEC;
	sub_8254E8E8(ctx, base);
	// 82B8FCEC: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82B8FCF0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B8FCF4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8FCF8: 409AFFA8  bne cr6, 0x82b8fca0
	if !ctx.cr[6].eq {
	pc = 0x82B8FCA0; continue 'dispatch;
	}
	// 82B8FCFC: 387D0098  addi r3, r29, 0x98
	ctx.r[3].s64 = ctx.r[29].s64 + 152;
	// 82B8FD00: 4B73C3C1  bl 0x822cc0c0
	ctx.lr = 0x82B8FD04;
	sub_822CC0C0(ctx, base);
	// 82B8FD04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8FD08: 4BFFEF41  bl 0x82b8ec48
	ctx.lr = 0x82B8FD0C;
	sub_82B8EC48(ctx, base);
	// 82B8FD0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B8FD10: 997D0008  stb r11, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82B8FD14: 897D0011  lbz r11, 0x11(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(17 as u32) ) } as u64;
	// 82B8FD18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FD1C: 4082000C  bne 0x82b8fd28
	if !ctx.cr[0].eq {
	pc = 0x82B8FD28; continue 'dispatch;
	}
	// 82B8FD20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B8FD24: 4B9808AD  bl 0x825105d0
	ctx.lr = 0x82B8FD28;
	sub_825105D0(ctx, base);
	// 82B8FD28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B8FD2C: 48618488  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8FD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B8FD30 size=4
    let mut pc: u32 = 0x82B8FD30;
    'dispatch: loop {
        match pc {
            0x82B8FD30 => {
    //   block [0x82B8FD30..0x82B8FD34)
	// 82B8FD30: 4BFFFD58  b 0x82b8fa88
	sub_82B8FA88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B8FD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B8FD38 size=1056
    let mut pc: u32 = 0x82B8FD38;
    'dispatch: loop {
        match pc {
            0x82B8FD38 => {
    //   block [0x82B8FD38..0x82B90158)
	// 82B8FD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B8FD3C: 48618429  bl 0x831a8164
	ctx.lr = 0x82B8FD40;
	sub_831A8130(ctx, base);
	// 82B8FD40: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82B8FD44: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82B8FD48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B8FD4C: 83E300C0  lwz r31, 0xc0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B8FD50: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82B8FD54: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8FD58: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FD5C: 41820014  beq 0x82b8fd70
	if ctx.cr[0].eq {
	pc = 0x82B8FD70; continue 'dispatch;
	}
	// 82B8FD60: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8FD64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FD68: 41820008  beq 0x82b8fd70
	if ctx.cr[0].eq {
	pc = 0x82B8FD70; continue 'dispatch;
	}
	// 82B8FD6C: 4BFFFD1D  bl 0x82b8fa88
	ctx.lr = 0x82B8FD70;
	sub_82B8FA88(ctx, base);
	// 82B8FD70: 88FF0008  lbz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B8FD74: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FD78: 418200FC  beq 0x82b8fe74
	if ctx.cr[0].eq {
	pc = 0x82B8FE74; continue 'dispatch;
	}
	// 82B8FD7C: 897F0009  lbz r11, 9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 82B8FD80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FD84: 408200F0  bne 0x82b8fe74
	if !ctx.cr[0].eq {
	pc = 0x82B8FE74; continue 'dispatch;
	}
	// 82B8FD88: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8FD8C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8FD90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B8FD94: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FD98: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8FD9C: 419A0010  beq cr6, 0x82b8fdac
	if ctx.cr[6].eq {
	pc = 0x82B8FDAC; continue 'dispatch;
	}
	// 82B8FDA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82B8FDA4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82B8FDA8: 48000014  b 0x82b8fdbc
	pc = 0x82B8FDBC; continue 'dispatch;
	// 82B8FDAC: C00A0024  lfs f0, 0x24(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8FDB0: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B8FDB4: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82B8FDB8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82B8FDBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8FDC0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B8FDC4: 812A0074  lwz r9, 0x74(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8FDC8: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82B8FDCC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82B8FDD0: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B8FDD4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82B8FDD8: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82B8FDDC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82B8FDE0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82B8FDE4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82B8FDE8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82B8FDEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82B8FDF0: 40990084  ble cr6, 0x82b8fe74
	if !ctx.cr[6].gt {
	pc = 0x82B8FE74; continue 'dispatch;
	}
	// 82B8FDF4: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82B8FDF8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82B8FDFC: 816A0074  lwz r11, 0x74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8FE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FE04: 419A0010  beq cr6, 0x82b8fe14
	if ctx.cr[6].eq {
	pc = 0x82B8FE14; continue 'dispatch;
	}
	// 82B8FE08: 810A0078  lwz r8, 0x78(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B8FE0C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82B8FE10: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FE14: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B8FE18: 409A003C  bne cr6, 0x82b8fe54
	if !ctx.cr[6].eq {
	pc = 0x82B8FE54; continue 'dispatch;
	}
	// 82B8FE1C: 897F0012  lbz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82B8FE20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FE24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B8FE28: 4182000C  beq 0x82b8fe34
	if ctx.cr[0].eq {
	pc = 0x82B8FE34; continue 'dispatch;
	}
	// 82B8FE2C: 997F0009  stb r11, 9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 82B8FE30: 48000008  b 0x82b8fe38
	pc = 0x82B8FE38; continue 'dispatch;
	// 82B8FE34: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82B8FE38: 816A0078  lwz r11, 0x78(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B8FE3C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82B8FE40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82B8FE44: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82B8FE48: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82B8FE4C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82B8FE50: 48000018  b 0x82b8fe68
	pc = 0x82B8FE68; continue 'dispatch;
	// 82B8FE54: 816A0074  lwz r11, 0x74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B8FE58: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82B8FE5C: 7D6A5AAA  lwax r11, r10, r11
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as i32) as i64;
	// 82B8FE60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82B8FE64: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82B8FE68: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82B8FE6C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82B8FE70: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82B8FE74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82B8FE78: 419A02D0  beq cr6, 0x82b90148
	if ctx.cr[6].eq {
	pc = 0x82B90148; continue 'dispatch;
	}
	// 82B8FE7C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8FE80: C3FF0000  lfs f31, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82B8FE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FE88: 409A000C  bne cr6, 0x82b8fe94
	if !ctx.cr[6].eq {
	pc = 0x82B8FE94; continue 'dispatch;
	}
	// 82B8FE8C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FE90: 48000010  b 0x82b8fea0
	pc = 0x82B8FEA0; continue 'dispatch;
	// 82B8FE94: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B8FE98: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FE9C: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FEA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8FEA4: 419A0024  beq cr6, 0x82b8fec8
	if ctx.cr[6].eq {
	pc = 0x82B8FEC8; continue 'dispatch;
	}
	// 82B8FEA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B8FEAC: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B8FEB0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82B8FEB4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FEB8: 4BFFEC71  bl 0x82b8eb28
	ctx.lr = 0x82B8FEBC;
	sub_82B8EB28(ctx, base);
	// 82B8FEBC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8FEC0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B8FEC4: 4082FFE8  bne 0x82b8feac
	if !ctx.cr[0].eq {
	pc = 0x82B8FEAC; continue 'dispatch;
	}
	// 82B8FEC8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FED0: 409A000C  bne cr6, 0x82b8fedc
	if !ctx.cr[6].eq {
	pc = 0x82B8FEDC; continue 'dispatch;
	}
	// 82B8FED4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FED8: 48000010  b 0x82b8fee8
	pc = 0x82B8FEE8; continue 'dispatch;
	// 82B8FEDC: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B8FEE0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FEE4: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FEE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8FEEC: 419A00D0  beq cr6, 0x82b8ffbc
	if ctx.cr[6].eq {
	pc = 0x82B8FFBC; continue 'dispatch;
	}
	// 82B8FEF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82B8FEF4: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82B8FEF8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FEFC: 7FBC582E  lwzx r29, r28, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FF00: 897D0020  lbz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8FF04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FF08: 40820038  bne 0x82b8ff40
	if !ctx.cr[0].eq {
	pc = 0x82B8FF40; continue 'dispatch;
	}
	// 82B8FF0C: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B8FF10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FF14: 4082002C  bne 0x82b8ff40
	if !ctx.cr[0].eq {
	pc = 0x82B8FF40; continue 'dispatch;
	}
	// 82B8FF18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8FF1C: 48004D4D  bl 0x82b94c68
	ctx.lr = 0x82B8FF20;
	sub_82B94C68(ctx, base);
	// 82B8FF20: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82B8FF24: 4198001C  blt cr6, 0x82b8ff40
	if ctx.cr[6].lt {
	pc = 0x82B8FF40; continue 'dispatch;
	}
	// 82B8FF28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FF2C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8FF30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8FF34: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B8FF38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FF3C: 4E800421  bctrl
	ctx.lr = 0x82B8FF40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FF40: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FF44: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FF48: 896B0020  lbz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B8FF4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FF50: 4182002C  beq 0x82b8ff7c
	if ctx.cr[0].eq {
	pc = 0x82B8FF7C; continue 'dispatch;
	}
	// 82B8FF54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8FF58: 48004D21  bl 0x82b94c78
	ctx.lr = 0x82B8FF5C;
	sub_82B94C78(ctx, base);
	// 82B8FF5C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82B8FF60: 4198001C  blt cr6, 0x82b8ff7c
	if ctx.cr[6].lt {
	pc = 0x82B8FF7C; continue 'dispatch;
	}
	// 82B8FF64: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FF68: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8FF6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B8FF70: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B8FF74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FF78: 4E800421  bctrl
	ctx.lr = 0x82B8FF7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FF7C: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82B8FF80: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B8FF84: 4082FF74  bne 0x82b8fef8
	if !ctx.cr[0].eq {
	pc = 0x82B8FEF8; continue 'dispatch;
	}
	// 82B8FF88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8FF8C: 419A0030  beq cr6, 0x82b8ffbc
	if ctx.cr[6].eq {
	pc = 0x82B8FFBC; continue 'dispatch;
	}
	// 82B8FF90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B8FF94: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B8FF98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B8FF9C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B8FFA4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B8FFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B8FFAC: 4E800421  bctrl
	ctx.lr = 0x82B8FFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B8FFB0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B8FFB4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B8FFB8: 4082FFDC  bne 0x82b8ff94
	if !ctx.cr[0].eq {
	pc = 0x82B8FF94; continue 'dispatch;
	}
	// 82B8FFBC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8FFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B8FFC4: 409A000C  bne cr6, 0x82b8ffd0
	if !ctx.cr[6].eq {
	pc = 0x82B8FFD0; continue 'dispatch;
	}
	// 82B8FFC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B8FFCC: 48000010  b 0x82b8ffdc
	pc = 0x82B8FFDC; continue 'dispatch;
	// 82B8FFD0: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B8FFD4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B8FFD8: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B8FFDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B8FFE0: 419A00F8  beq cr6, 0x82b900d8
	if ctx.cr[6].eq {
	pc = 0x82B900D8; continue 'dispatch;
	}
	// 82B8FFE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82B8FFE8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82B8FFEC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B8FFF0: 7FBC582E  lwzx r29, r28, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B8FFF4: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B8FFF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B8FFFC: 4082004C  bne 0x82b90048
	if !ctx.cr[0].eq {
	pc = 0x82B90048; continue 'dispatch;
	}
	// 82B90000: 897D0019  lbz r11, 0x19(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82B90004: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90008: 40820040  bne 0x82b90048
	if !ctx.cr[0].eq {
	pc = 0x82B90048; continue 'dispatch;
	}
	// 82B9000C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B90010: 480055C1  bl 0x82b955d0
	ctx.lr = 0x82B90014;
	sub_82B955D0(ctx, base);
	// 82B90014: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82B90018: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82B9001C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82B90020: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82B90024: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82B90028: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82B9002C: 4198001C  blt cr6, 0x82b90048
	if ctx.cr[6].lt {
	pc = 0x82B90048; continue 'dispatch;
	}
	// 82B90030: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90034: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B90038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9003C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B90040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B90044: 4E800421  bctrl
	ctx.lr = 0x82B90048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B90048: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B9004C: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B90050: 896B0018  lbz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82B90054: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90058: 41820040  beq 0x82b90098
	if ctx.cr[0].eq {
	pc = 0x82B90098; continue 'dispatch;
	}
	// 82B9005C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B90060: 48005581  bl 0x82b955e0
	ctx.lr = 0x82B90064;
	sub_82B955E0(ctx, base);
	// 82B90064: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82B90068: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82B9006C: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82B90070: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82B90074: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82B90078: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82B9007C: 4198001C  blt cr6, 0x82b90098
	if ctx.cr[6].lt {
	pc = 0x82B90098; continue 'dispatch;
	}
	// 82B90080: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90084: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B90088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9008C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B90090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B90094: 4E800421  bctrl
	ctx.lr = 0x82B90098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B90098: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82B9009C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B900A0: 4082FF4C  bne 0x82b8ffec
	if !ctx.cr[0].eq {
	pc = 0x82B8FFEC; continue 'dispatch;
	}
	// 82B900A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B900A8: 419A0030  beq cr6, 0x82b900d8
	if ctx.cr[6].eq {
	pc = 0x82B900D8; continue 'dispatch;
	}
	// 82B900AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B900B0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B900B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B900B8: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B900BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B900C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B900C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B900C8: 4E800421  bctrl
	ctx.lr = 0x82B900CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B900CC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B900D0: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B900D4: 4082FFDC  bne 0x82b900b0
	if !ctx.cr[0].eq {
	pc = 0x82B900B0; continue 'dispatch;
	}
	// 82B900D8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B900DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B900E0: 409A000C  bne cr6, 0x82b900ec
	if !ctx.cr[6].eq {
	pc = 0x82B900EC; continue 'dispatch;
	}
	// 82B900E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B900E8: 48000010  b 0x82b900f8
	pc = 0x82B900F8; continue 'dispatch;
	// 82B900EC: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82B900F0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B900F4: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B900F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B900FC: 419A0024  beq cr6, 0x82b90120
	if ctx.cr[6].eq {
	pc = 0x82B90120; continue 'dispatch;
	}
	// 82B90100: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B90104: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82B90108: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B9010C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82B90110: 4BFF40C9  bl 0x82b841d8
	ctx.lr = 0x82B90114;
	sub_82B841D8(ctx, base);
	// 82B90114: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82B90118: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82B9011C: 4082FFE8  bne 0x82b90104
	if !ctx.cr[0].eq {
	pc = 0x82B90104; continue 'dispatch;
	}
	// 82B90120: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82B90124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90128: 419A000C  beq cr6, 0x82b90134
	if ctx.cr[6].eq {
	pc = 0x82B90134; continue 'dispatch;
	}
	// 82B9012C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B90130: 4BFF42E1  bl 0x82b84410
	ctx.lr = 0x82B90134;
	sub_82B84410(ctx, base);
	// 82B90134: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82B90138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B9013C: 419A000C  beq cr6, 0x82b90148
	if ctx.cr[6].eq {
	pc = 0x82B90148; continue 'dispatch;
	}
	// 82B90140: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B90144: 4BFF3525  bl 0x82b83668
	ctx.lr = 0x82B90148;
	sub_82B83668(ctx, base);
	// 82B90148: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B9014C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82B90150: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82B90154: 48618060  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B90158 size=4
    let mut pc: u32 = 0x82B90158;
    'dispatch: loop {
        match pc {
            0x82B90158 => {
    //   block [0x82B90158..0x82B9015C)
	// 82B90158: 4BFFFBE0  b 0x82b8fd38
	sub_82B8FD38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90160 size=116
    let mut pc: u32 = 0x82B90160;
    'dispatch: loop {
        match pc {
            0x82B90160 => {
    //   block [0x82B90160..0x82B901D4)
	// 82B90160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90164: 48618005  bl 0x831a8168
	ctx.lr = 0x82B90168;
	sub_831A8130(ctx, base);
	// 82B90168: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82B9016C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90174: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82B90178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B9017C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82B90180: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82B90184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9018C: 409A0018  bne cr6, 0x82b901a4
	if !ctx.cr[6].eq {
	pc = 0x82B901A4; continue 'dispatch;
	}
	// 82B90190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90194: 4B743445  bl 0x822d35d8
	ctx.lr = 0x82B90198;
	sub_822D35D8(ctx, base);
	// 82B90198: 4B72FE69  bl 0x822c0000
	ctx.lr = 0x82B9019C;
	sub_822C0000(ctx, base);
	// 82B9019C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B901A0: 4B742671  bl 0x822d2810
	ctx.lr = 0x82B901A4;
	sub_822D2810(ctx, base);
	// 82B901A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B901A8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82B901AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82B901B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82B901B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B901B8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82B901BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B901C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B901C4: 4E800421  bctrl
	ctx.lr = 0x82B901C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B901C8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B901CC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82B901D0: 48617FE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B901D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B901D8 size=20
    let mut pc: u32 = 0x82B901D8;
    'dispatch: loop {
        match pc {
            0x82B901D8 => {
    //   block [0x82B901D8..0x82B901EC)
	// 82B901D8: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B901DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82B901E0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B901E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B901E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B901EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B901EC size=16
    let mut pc: u32 = 0x82B901EC;
    'dispatch: loop {
        match pc {
            0x82B901EC => {
    //   block [0x82B901EC..0x82B901FC)
	// 82B901EC: 3D40822C  lis r10, -0x7dd4
	ctx.r[10].s64 = -2111045632;
	// 82B901F0: 394A0000  addi r10, r10, 0
	ctx.r[10].s64 = ctx.r[10].s64 + 0;
	// 82B901F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B901F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B901FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B901FC size=8
    let mut pc: u32 = 0x82B901FC;
    'dispatch: loop {
        match pc {
            0x82B901FC => {
    //   block [0x82B901FC..0x82B90204)
	// 82B901FC: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 82B90200: 4BFFFF60  b 0x82b90160
	sub_82B90160(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90204(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B90204 size=4
    let mut pc: u32 = 0x82B90204;
    'dispatch: loop {
        match pc {
            0x82B90204 => {
    //   block [0x82B90204..0x82B90208)
	// 82B90204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90208 size=1036
    let mut pc: u32 = 0x82B90208;
    'dispatch: loop {
        match pc {
            0x82B90208 => {
    //   block [0x82B90208..0x82B90614)
	// 82B90208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9020C: 48617F4D  bl 0x831a8158
	ctx.lr = 0x82B90210;
	sub_831A8130(ctx, base);
	// 82B90210: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90214: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82B90218: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82B9021C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82B90220: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 82B90224: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9022C: 419A0048  beq cr6, 0x82b90274
	if ctx.cr[6].eq {
	pc = 0x82B90274; continue 'dispatch;
	}
	// 82B90230: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B90234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90238: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 82B9023C: 4B73568D  bl 0x822c58c8
	ctx.lr = 0x82B90240;
	sub_822C58C8(ctx, base);
	// 82B90240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90244: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B90248: 4B739C69  bl 0x822c9eb0
	ctx.lr = 0x82B9024C;
	sub_822C9EB0(ctx, base);
	// 82B9024C: 4B734065  bl 0x822c42b0
	ctx.lr = 0x82B90250;
	sub_822C42B0(ctx, base);
	// 82B90250: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B90254: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B90258: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 82B9025C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B90260: 4B735211  bl 0x822c5470
	ctx.lr = 0x82B90264;
	sub_822C5470(ctx, base);
	// 82B90264: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B90268: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B9026C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90270: 4B734A71  bl 0x822c4ce0
	ctx.lr = 0x82B90274;
	sub_822C4CE0(ctx, base);
	// 82B90274: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 82B90278: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82B9027C: 4BC38DB5  bl 0x827c9030
	ctx.lr = 0x82B90280;
	sub_827C9030(ctx, base);
	// 82B90280: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90284: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B9028C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82B90290: 419A000C  beq cr6, 0x82b9029c
	if ctx.cr[6].eq {
	pc = 0x82B9029C; continue 'dispatch;
	}
	// 82B90294: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90298: 48000028  b 0x82b902c0
	pc = 0x82B902C0; continue 'dispatch;
	// 82B9029C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B902A0: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B902A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B902A8: 419A000C  beq cr6, 0x82b902b4
	if ctx.cr[6].eq {
	pc = 0x82B902B4; continue 'dispatch;
	}
	// 82B902AC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82B902B0: 48000010  b 0x82b902c0
	pc = 0x82B902C0; continue 'dispatch;
	// 82B902B4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B902B8: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B902BC: 409A00DC  bne cr6, 0x82b90398
	if !ctx.cr[6].eq {
	pc = 0x82B90398; continue 'dispatch;
	}
	// 82B902C0: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B902C4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B902C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B902CC: 409A0008  bne cr6, 0x82b902d4
	if !ctx.cr[6].eq {
	pc = 0x82B902D4; continue 'dispatch;
	}
	// 82B902D0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B902D4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B902D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B902DC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B902E0: 409A000C  bne cr6, 0x82b902ec
	if !ctx.cr[6].eq {
	pc = 0x82B902EC; continue 'dispatch;
	}
	// 82B902E4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B902E8: 4800001C  b 0x82b90304
	pc = 0x82B90304; continue 'dispatch;
	// 82B902EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B902F0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B902F4: 409A000C  bne cr6, 0x82b90300
	if !ctx.cr[6].eq {
	pc = 0x82B90300; continue 'dispatch;
	}
	// 82B902F8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B902FC: 48000008  b 0x82b90304
	pc = 0x82B90304; continue 'dispatch;
	// 82B90300: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B90304: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90308: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9030C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B90310: 409A003C  bne cr6, 0x82b9034c
	if !ctx.cr[6].eq {
	pc = 0x82B9034C; continue 'dispatch;
	}
	// 82B90314: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9031C: 419A000C  beq cr6, 0x82b90328
	if ctx.cr[6].eq {
	pc = 0x82B90328; continue 'dispatch;
	}
	// 82B90320: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82B90324: 48000024  b 0x82b90348
	pc = 0x82B90348; continue 'dispatch;
	// 82B90328: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9032C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82B90330: 4800000C  b 0x82b9033c
	pc = 0x82B9033C; continue 'dispatch;
	// 82B90334: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B90338: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9033C: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90340: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82B90344: 419AFFF0  beq cr6, 0x82b90334
	if ctx.cr[6].eq {
	pc = 0x82B90334; continue 'dispatch;
	}
	// 82B90348: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B9034C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90350: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90354: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B90358: 409A00D4  bne cr6, 0x82b9042c
	if !ctx.cr[6].eq {
	pc = 0x82B9042C; continue 'dispatch;
	}
	// 82B9035C: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90364: 419A000C  beq cr6, 0x82b90370
	if ctx.cr[6].eq {
	pc = 0x82B90370; continue 'dispatch;
	}
	// 82B90368: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82B9036C: 48000024  b 0x82b90390
	pc = 0x82B90390; continue 'dispatch;
	// 82B90370: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90374: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82B90378: 4800000C  b 0x82b90384
	pc = 0x82B90384; continue 'dispatch;
	// 82B9037C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B90380: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90384: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90388: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82B9038C: 419AFFF0  beq cr6, 0x82b9037c
	if ctx.cr[6].eq {
	pc = 0x82B9037C; continue 'dispatch;
	}
	// 82B90390: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B90394: 48000098  b 0x82b9042c
	pc = 0x82B9042C; continue 'dispatch;
	// 82B90398: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B9039C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B903A0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B903A4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B903A8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B903AC: 409A000C  bne cr6, 0x82b903b8
	if !ctx.cr[6].eq {
	pc = 0x82B903B8; continue 'dispatch;
	}
	// 82B903B0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82B903B4: 4800002C  b 0x82b903e0
	pc = 0x82B903E0; continue 'dispatch;
	// 82B903B8: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B903BC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B903C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B903C4: 409A0008  bne cr6, 0x82b903cc
	if !ctx.cr[6].eq {
	pc = 0x82B903CC; continue 'dispatch;
	}
	// 82B903C8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B903CC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B903D0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B903D4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B903D8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B903DC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B903E0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B903E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B903E8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B903EC: 409A000C  bne cr6, 0x82b903f8
	if !ctx.cr[6].eq {
	pc = 0x82B903F8; continue 'dispatch;
	}
	// 82B903F0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B903F4: 48000020  b 0x82b90414
	pc = 0x82B90414; continue 'dispatch;
	// 82B903F8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B903FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90400: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B90404: 409A000C  bne cr6, 0x82b90410
	if !ctx.cr[6].eq {
	pc = 0x82B90410; continue 'dispatch;
	}
	// 82B90408: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82B9040C: 48000008  b 0x82b90414
	pc = 0x82B90414; continue 'dispatch;
	// 82B90410: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82B90414: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90418: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B9041C: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90420: 89590020  lbz r10, 0x20(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90424: 99790020  stb r11, 0x20(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82B90428: 995B0020  stb r10, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82B9042C: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90430: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82B90434: 409A0198  bne cr6, 0x82b905cc
	if !ctx.cr[6].eq {
	pc = 0x82B905CC; continue 'dispatch;
	}
	// 82B90438: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9043C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82B90440: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90444: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B90448: 419A0180  beq cr6, 0x82b905c8
	if ctx.cr[6].eq {
	pc = 0x82B905C8; continue 'dispatch;
	}
	// 82B9044C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B90450: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90454: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82B90458: 409A0170  bne cr6, 0x82b905c8
	if !ctx.cr[6].eq {
	pc = 0x82B905C8; continue 'dispatch;
	}
	// 82B9045C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90460: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B90464: 409A00A8  bne cr6, 0x82b9050c
	if !ctx.cr[6].eq {
	pc = 0x82B9050C; continue 'dispatch;
	}
	// 82B90468: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9046C: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90470: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B90474: 409A001C  bne cr6, 0x82b90490
	if !ctx.cr[6].eq {
	pc = 0x82B90490; continue 'dispatch;
	}
	// 82B90478: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B9047C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90480: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B90484: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B90488: 4B8C3C91  bl 0x82454118
	ctx.lr = 0x82B9048C;
	sub_82454118(ctx, base);
	// 82B9048C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90490: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90494: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B90498: 409A00C8  bne cr6, 0x82b90560
	if !ctx.cr[6].eq {
	pc = 0x82B90560; continue 'dispatch;
	}
	// 82B9049C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B904A0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B904A4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B904A8: 409A0014  bne cr6, 0x82b904bc
	if !ctx.cr[6].eq {
	pc = 0x82B904BC; continue 'dispatch;
	}
	// 82B904AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B904B0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B904B4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B904B8: 419A00A4  beq cr6, 0x82b9055c
	if ctx.cr[6].eq {
	pc = 0x82B9055C; continue 'dispatch;
	}
	// 82B904BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B904C0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B904C4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B904C8: 409A0020  bne cr6, 0x82b904e8
	if !ctx.cr[6].eq {
	pc = 0x82B904E8; continue 'dispatch;
	}
	// 82B904CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B904D0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82B904D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B904D8: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B904DC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B904E0: 4BC38BC9  bl 0x827c90a8
	ctx.lr = 0x82B904E4;
	sub_827C90A8(ctx, base);
	// 82B904E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B904E8: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B904EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B904F0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B904F4: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82B904F8: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B904FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90500: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B90504: 4B8C3C15  bl 0x82454118
	ctx.lr = 0x82B90508;
	sub_82454118(ctx, base);
	// 82B90508: 480000C0  b 0x82b905c8
	pc = 0x82B905C8; continue 'dispatch;
	// 82B9050C: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90510: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B90514: 409A001C  bne cr6, 0x82b90530
	if !ctx.cr[6].eq {
	pc = 0x82B90530; continue 'dispatch;
	}
	// 82B90518: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B9051C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90520: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B90524: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B90528: 4BC38B81  bl 0x827c90a8
	ctx.lr = 0x82B9052C;
	sub_827C90A8(ctx, base);
	// 82B9052C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90530: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90534: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B90538: 409A0028  bne cr6, 0x82b90560
	if !ctx.cr[6].eq {
	pc = 0x82B90560; continue 'dispatch;
	}
	// 82B9053C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90540: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90544: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B90548: 409A0034  bne cr6, 0x82b9057c
	if !ctx.cr[6].eq {
	pc = 0x82B9057C; continue 'dispatch;
	}
	// 82B9054C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90550: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90554: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B90558: 409A0024  bne cr6, 0x82b9057c
	if !ctx.cr[6].eq {
	pc = 0x82B9057C; continue 'dispatch;
	}
	// 82B9055C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B90560: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90564: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82B90568: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9056C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90570: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B90574: 409AFEDC  bne cr6, 0x82b90450
	if !ctx.cr[6].eq {
	pc = 0x82B90450; continue 'dispatch;
	}
	// 82B90578: 48000050  b 0x82b905c8
	pc = 0x82B905C8; continue 'dispatch;
	// 82B9057C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90580: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B90584: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B90588: 409A0020  bne cr6, 0x82b905a8
	if !ctx.cr[6].eq {
	pc = 0x82B905A8; continue 'dispatch;
	}
	// 82B9058C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90590: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82B90594: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B90598: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B9059C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B905A0: 4B8C3B79  bl 0x82454118
	ctx.lr = 0x82B905A4;
	sub_82454118(ctx, base);
	// 82B905A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B905A8: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B905AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B905B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B905B4: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82B905B8: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B905BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B905C0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B905C4: 4BC38AE5  bl 0x827c90a8
	ctx.lr = 0x82B905C8;
	sub_827C90A8(ctx, base);
	// 82B905C8: 9BDC0020  stb r30, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82B905CC: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 82B905D0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B905D4: 4B8D9A2D  bl 0x8246a000
	ctx.lr = 0x82B905D8;
	sub_8246A000(ctx, base);
	// 82B905D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B905DC: 48262E4D  bl 0x82df3428
	ctx.lr = 0x82B905E0;
	sub_82DF3428(ctx, base);
	// 82B905E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B905E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B905E8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B905EC: 48261B9D  bl 0x82df2188
	ctx.lr = 0x82B905F0;
	sub_82DF2188(ctx, base);
	// 82B905F0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B905F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B905F8: 419A000C  beq cr6, 0x82b90604
	if ctx.cr[6].eq {
	pc = 0x82B90604; continue 'dispatch;
	}
	// 82B905FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82B90600: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B90604: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82B90608: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82B9060C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82B90610: 48617B98  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90618 size=80
    let mut pc: u32 = 0x82B90618;
    'dispatch: loop {
        match pc {
            0x82B90618 => {
    //   block [0x82B90618..0x82B90668)
	// 82B90618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9061C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90624: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B9062C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82B90630: 4B8D99D1  bl 0x8246a000
	ctx.lr = 0x82B90634;
	sub_8246A000(ctx, base);
	// 82B90634: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82B90638: 4B920C69  bl 0x824b12a0
	ctx.lr = 0x82B9063C;
	sub_824B12A0(ctx, base);
	// 82B9063C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82B90640: 4B920C61  bl 0x824b12a0
	ctx.lr = 0x82B90644;
	sub_824B12A0(ctx, base);
	// 82B90644: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B9064C: 419A0008  beq cr6, 0x82b90654
	if ctx.cr[6].eq {
	pc = 0x82B90654; continue 'dispatch;
	}
	// 82B90650: 4B730241  bl 0x822c0890
	ctx.lr = 0x82B90654;
	sub_822C0890(ctx, base);
	// 82B90654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B90658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B9065C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90668 size=108
    let mut pc: u32 = 0x82B90668;
    'dispatch: loop {
        match pc {
            0x82B90668 => {
    //   block [0x82B90668..0x82B906D4)
	// 82B90668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9066C: 48617AFD  bl 0x831a8168
	ctx.lr = 0x82B90670;
	sub_831A8130(ctx, base);
	// 82B90670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90674: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B90678: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B9067C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90684: 409A000C  bne cr6, 0x82b90690
	if !ctx.cr[6].eq {
	pc = 0x82B90690; continue 'dispatch;
	}
	// 82B90688: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B9068C: 48000010  b 0x82b9069c
	pc = 0x82B9069C; continue 'dispatch;
	// 82B90690: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90694: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B90698: 7D7F1670  srawi r31, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82B9069C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B906A0: 419A002C  beq cr6, 0x82b906cc
	if ctx.cr[6].eq {
	pc = 0x82B906CC; continue 'dispatch;
	}
	// 82B906A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B906A8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B906AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B906B0: 817C00C0  lwz r11, 0xc0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B906B4: 7CBE5214  add r5, r30, r10
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82B906B8: 388B00B0  addi r4, r11, 0xb0
	ctx.r[4].s64 = ctx.r[11].s64 + 176;
	// 82B906BC: 4B73CB05  bl 0x822cd1c0
	ctx.lr = 0x82B906C0;
	sub_822CD1C0(ctx, base);
	// 82B906C0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B906C4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82B906C8: 4082FFE0  bne 0x82b906a8
	if !ctx.cr[0].eq {
	pc = 0x82B906A8; continue 'dispatch;
	}
	// 82B906CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B906D0: 48617AE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B906D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B906D8 size=108
    let mut pc: u32 = 0x82B906D8;
    'dispatch: loop {
        match pc {
            0x82B906D8 => {
    //   block [0x82B906D8..0x82B90744)
	// 82B906D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B906DC: 48617A8D  bl 0x831a8168
	ctx.lr = 0x82B906E0;
	sub_831A8130(ctx, base);
	// 82B906E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B906E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B906E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B906EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B906F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B906F4: 409A000C  bne cr6, 0x82b90700
	if !ctx.cr[6].eq {
	pc = 0x82B90700; continue 'dispatch;
	}
	// 82B906F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B906FC: 48000010  b 0x82b9070c
	pc = 0x82B9070C; continue 'dispatch;
	// 82B90700: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90704: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B90708: 7D7F1670  srawi r31, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82B9070C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B90710: 419A002C  beq cr6, 0x82b9073c
	if ctx.cr[6].eq {
	pc = 0x82B9073C; continue 'dispatch;
	}
	// 82B90714: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B90718: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9071C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90720: 817C00C0  lwz r11, 0xc0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90724: 7CBE5214  add r5, r30, r10
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82B90728: 388B00BC  addi r4, r11, 0xbc
	ctx.r[4].s64 = ctx.r[11].s64 + 188;
	// 82B9072C: 4B73CA95  bl 0x822cd1c0
	ctx.lr = 0x82B90730;
	sub_822CD1C0(ctx, base);
	// 82B90730: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B90734: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82B90738: 4082FFE0  bne 0x82b90718
	if !ctx.cr[0].eq {
	pc = 0x82B90718; continue 'dispatch;
	}
	// 82B9073C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B90740: 48617A78  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90748 size=172
    let mut pc: u32 = 0x82B90748;
    'dispatch: loop {
        match pc {
            0x82B90748 => {
    //   block [0x82B90748..0x82B907F4)
	// 82B90748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9074C: 48617A21  bl 0x831a816c
	ctx.lr = 0x82B90750;
	sub_831A8130(ctx, base);
	// 82B90750: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90754: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90758: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B9075C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82B90760: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90764: 40820088  bne 0x82b907ec
	if !ctx.cr[0].eq {
	pc = 0x82B907EC; continue 'dispatch;
	}
	// 82B90768: 3BCB0098  addi r30, r11, 0x98
	ctx.r[30].s64 = ctx.r[11].s64 + 152;
	// 82B9076C: 83AB009C  lwz r29, 0x9c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 82B90770: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B90774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9077C: 4B73B08D  bl 0x822cb808
	ctx.lr = 0x82B90780;
	sub_822CB808(ctx, base);
	// 82B90780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90784: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B90788: 409A0064  bne cr6, 0x82b907ec
	if !ctx.cr[6].eq {
	pc = 0x82B907EC; continue 'dispatch;
	}
	// 82B9078C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B90790: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B90794: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B90798: 808B271C  lwz r4, 0x271c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10012 as u32) ) } as u64;
	// 82B9079C: 4826145D  bl 0x82df1bf8
	ctx.lr = 0x82B907A0;
	sub_82DF1BF8(ctx, base);
	// 82B907A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82B907A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B907A8: 388B8408  addi r4, r11, -0x7bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -31736;
	// 82B907AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B907B0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82B907B4: 482634ED  bl 0x82df3ca0
	ctx.lr = 0x82B907B8;
	sub_82DF3CA0(ctx, base);
	// 82B907B8: 482629F9  bl 0x82df31b0
	ctx.lr = 0x82B907BC;
	sub_82DF31B0(ctx, base);
	// 82B907BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B907C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B907C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B907C8: 482BF8D9  bl 0x82e500a0
	ctx.lr = 0x82B907CC;
	sub_82E500A0(ctx, base);
	// 82B907CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B907D0: 482614C1  bl 0x82df1c90
	ctx.lr = 0x82B907D4;
	sub_82DF1C90(ctx, base);
	// 82B907D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B907D8: 48262C51  bl 0x82df3428
	ctx.lr = 0x82B907DC;
	sub_82DF3428(ctx, base);
	// 82B907DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B907E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B907E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B907E8: 4B73C9D9  bl 0x822cd1c0
	ctx.lr = 0x82B907EC;
	sub_822CD1C0(ctx, base);
	// 82B907EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B907F0: 486179CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B907F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B907F8 size=48
    let mut pc: u32 = 0x82B907F8;
    'dispatch: loop {
        match pc {
            0x82B907F8 => {
    //   block [0x82B907F8..0x82B90828)
	// 82B907F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B907FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90800: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90804: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90808: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82B9080C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90810: 388B00A4  addi r4, r11, 0xa4
	ctx.r[4].s64 = ctx.r[11].s64 + 164;
	// 82B90814: 4B73C9AD  bl 0x822cd1c0
	ctx.lr = 0x82B90818;
	sub_822CD1C0(ctx, base);
	// 82B90818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B9081C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90828 size=112
    let mut pc: u32 = 0x82B90828;
    'dispatch: loop {
        match pc {
            0x82B90828 => {
    //   block [0x82B90828..0x82B90898)
	// 82B90828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9082C: 48617939  bl 0x831a8164
	ctx.lr = 0x82B90830;
	sub_831A8130(ctx, base);
	// 82B90830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B90838: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B9083C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82B90840: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90848: 409A0048  bne cr6, 0x82b90890
	if !ctx.cr[6].eq {
	pc = 0x82B90890; continue 'dispatch;
	}
	// 82B9084C: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 82B90850: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B90854: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90858: 4BFFFFD1  bl 0x82b90828
	ctx.lr = 0x82B9085C;
	sub_82B90828(ctx, base);
	// 82B9085C: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 82B90860: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82B90864: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90868: 4B8D9799  bl 0x8246a000
	ctx.lr = 0x82B9086C;
	sub_8246A000(ctx, base);
	// 82B9086C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B90870: 48262BB9  bl 0x82df3428
	ctx.lr = 0x82B90874;
	sub_82DF3428(ctx, base);
	// 82B90874: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90878: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B9087C: 4826190D  bl 0x82df2188
	ctx.lr = 0x82B90880;
	sub_82DF2188(ctx, base);
	// 82B90880: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B90884: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B90888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9088C: 419AFFC4  beq cr6, 0x82b90850
	if ctx.cr[6].eq {
	pc = 0x82B90850; continue 'dispatch;
	}
	// 82B90890: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B90894: 48617920  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90898 size=84
    let mut pc: u32 = 0x82B90898;
    'dispatch: loop {
        match pc {
            0x82B90898 => {
    //   block [0x82B90898..0x82B908EC)
	// 82B90898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9089C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B908A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B908A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B908A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B908AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B908B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B908B4: 4BFFFF75  bl 0x82b90828
	ctx.lr = 0x82B908B8;
	sub_82B90828(ctx, base);
	// 82B908B8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B908BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B908C0: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B908C4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B908C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B908CC: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B908D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B908D4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B908D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B908DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B908E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B908E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B908E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B908F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B908F0 size=132
    let mut pc: u32 = 0x82B908F0;
    'dispatch: loop {
        match pc {
            0x82B908F0 => {
    //   block [0x82B908F0..0x82B90974)
	// 82B908F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B908F4: 48617875  bl 0x831a8168
	ctx.lr = 0x82B908F8;
	sub_831A8130(ctx, base);
	// 82B908F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B908FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B90900: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82B90904: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B90908: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82B9090C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90910: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90914: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B90918: 409A0044  bne cr6, 0x82b9095c
	if !ctx.cr[6].eq {
	pc = 0x82B9095C; continue 'dispatch;
	}
	// 82B9091C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B90920: 409A003C  bne cr6, 0x82b9095c
	if !ctx.cr[6].eq {
	pc = 0x82B9095C; continue 'dispatch;
	}
	// 82B90924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90928: 4BFFFF71  bl 0x82b90898
	ctx.lr = 0x82B9092C;
	sub_82B90898(ctx, base);
	// 82B9092C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90930: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90934: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B90938: 48000030  b 0x82b90968
	pc = 0x82B90968; continue 'dispatch;
	// 82B9093C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82B90940: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B90944: 4BC386ED  bl 0x827c9030
	ctx.lr = 0x82B90948;
	sub_827C9030(ctx, base);
	// 82B90948: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82B9094C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90954: 4BFFF8B5  bl 0x82b90208
	ctx.lr = 0x82B90958;
	sub_82B90208(ctx, base);
	// 82B90958: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82B9095C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82B90960: 409AFFDC  bne cr6, 0x82b9093c
	if !ctx.cr[6].eq {
	pc = 0x82B9093C; continue 'dispatch;
	}
	// 82B90964: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82B90968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9096C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B90970: 48617848  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90978 size=88
    let mut pc: u32 = 0x82B90978;
    'dispatch: loop {
        match pc {
            0x82B90978 => {
    //   block [0x82B90978..0x82B909D0)
	// 82B90978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9097C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90984: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B9098C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90994: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90998: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9099C: 4BFFFF55  bl 0x82b908f0
	ctx.lr = 0x82B909A0;
	sub_82B908F0(ctx, base);
	// 82B909A0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B909A4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B909A8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B909AC: 482617DD  bl 0x82df2188
	ctx.lr = 0x82B909B0;
	sub_82DF2188(ctx, base);
	// 82B909B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B909B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B909B8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B909BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B909C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B909C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B909C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B909CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B909D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B909D0 size=188
    let mut pc: u32 = 0x82B909D0;
    'dispatch: loop {
        match pc {
            0x82B909D0 => {
    //   block [0x82B909D0..0x82B90A8C)
	// 82B909D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B909D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B909D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B909DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B909E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B909E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B909E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B909EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B909F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B909F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B909F8: 4B72FF41  bl 0x822c0938
	ctx.lr = 0x82B909FC;
	sub_822C0938(ctx, base);
	// 82B909FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90A00: 41820028  beq 0x82b90a28
	if ctx.cr[0].eq {
	pc = 0x82B90A28; continue 'dispatch;
	}
	// 82B90A04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B90A08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B90A0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B90A10: 392B8B80  addi r9, r11, -0x7480
	ctx.r[9].s64 = ctx.r[11].s64 + -29824;
	// 82B90A14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B90A18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B90A1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B90A20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B90A24: 48000008  b 0x82b90a2c
	pc = 0x82B90A2C; continue 'dispatch;
	// 82B90A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B90A2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B90A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90A34: 409A003C  bne cr6, 0x82b90a70
	if !ctx.cr[6].eq {
	pc = 0x82B90A70; continue 'dispatch;
	}
	// 82B90A38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B90A3C: 419A0014  beq cr6, 0x82b90a50
	if ctx.cr[6].eq {
	pc = 0x82B90A50; continue 'dispatch;
	}
	// 82B90A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90A44: 4BFFFBD5  bl 0x82b90618
	ctx.lr = 0x82B90A48;
	sub_82B90618(ctx, base);
	// 82B90A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90A4C: 4826198D  bl 0x82df23d8
	ctx.lr = 0x82B90A50;
	sub_82DF23D8(ctx, base);
	// 82B90A50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B90A54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B90A58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B90A5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B90A60: 816BB214  lwz r11, -0x4dec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19948 as u32) ) } as u64;
	// 82B90A64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B90A68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B90A6C: 4B72F595  bl 0x822c0000
	ctx.lr = 0x82B90A70;
	sub_822C0000(ctx, base);
	// 82B90A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B90A74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B90A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90A80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B90A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90A90 size=64
    let mut pc: u32 = 0x82B90A90;
    'dispatch: loop {
        match pc {
            0x82B90A90 => {
    //   block [0x82B90A90..0x82B90AD0)
	// 82B90A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90A9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90AA0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B90AA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B90AA8: 419A0014  beq cr6, 0x82b90abc
	if ctx.cr[6].eq {
	pc = 0x82B90ABC; continue 'dispatch;
	}
	// 82B90AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90AB0: 4BFFFB69  bl 0x82b90618
	ctx.lr = 0x82B90AB4;
	sub_82B90618(ctx, base);
	// 82B90AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90AB8: 48261921  bl 0x82df23d8
	ctx.lr = 0x82B90ABC;
	sub_82DF23D8(ctx, base);
	// 82B90ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B90AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90AD0 size=568
    let mut pc: u32 = 0x82B90AD0;
    'dispatch: loop {
        match pc {
            0x82B90AD0 => {
    //   block [0x82B90AD0..0x82B90D08)
	// 82B90AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90AD4: 48617685  bl 0x831a8158
	ctx.lr = 0x82B90AD8;
	sub_831A8130(ctx, base);
	// 82B90AD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90ADC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B90AE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B90AE4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82B90AE8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82B90AEC: 38860004  addi r4, r6, 4
	ctx.r[4].s64 = ctx.r[6].s64 + 4;
	// 82B90AF0: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B90AF4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B90AF8: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82B90AFC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B90B00: 93FD0010  stw r31, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82B90B04: 3B9D000C  addi r28, r29, 0xc
	ctx.r[28].s64 = ctx.r[29].s64 + 12;
	// 82B90B08: 93FD0014  stw r31, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82B90B0C: 3B1D001C  addi r24, r29, 0x1c
	ctx.r[24].s64 = ctx.r[29].s64 + 28;
	// 82B90B10: 93FD0018  stw r31, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82B90B14: 93FD0020  stw r31, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82B90B18: 93FD0024  stw r31, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82B90B1C: 93FD0028  stw r31, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82B90B20: 93FD0034  stw r31, 0x34(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 82B90B24: 93FD0038  stw r31, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 82B90B28: 93FD003C  stw r31, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 82B90B2C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B90B30: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90B34: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B90B38: 4B733929  bl 0x822c4460
	ctx.lr = 0x82B90B3C;
	sub_822C4460(ctx, base);
	// 82B90B3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90B40: 937D002C  stw r27, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[27].u32 ) };
	// 82B90B44: 834B000C  lwz r26, 0xc(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B90B48: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90B50: 409A000C  bne cr6, 0x82b90b5c
	if !ctx.cr[6].eq {
	pc = 0x82B90B5C; continue 'dispatch;
	}
	// 82B90B54: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82B90B58: 48000010  b 0x82b90b68
	pc = 0x82B90B68; continue 'dispatch;
	// 82B90B5C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90B60: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B90B64: 7D7B1E70  srawi r27, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B90B68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B90B6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B90B70: 4B972151  bl 0x82502cc0
	ctx.lr = 0x82B90B74;
	sub_82502CC0(ctx, base);
	// 82B90B74: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82B90B78: 419A0054  beq cr6, 0x82b90bcc
	if ctx.cr[6].eq {
	pc = 0x82B90BCC; continue 'dispatch;
	}
	// 82B90B7C: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 82B90B80: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90B84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B90B88: 80DD002C  lwz r6, 0x2c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82B90B8C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90B90: 7C99582E  lwzx r4, r25, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B90B94: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90B98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90B9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82B90BA0: 4E800421  bctrl
	ctx.lr = 0x82B90BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82B90BA4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82B90BA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B90BAC: 4802255D  bl 0x82bb3108
	ctx.lr = 0x82B90BB0;
	sub_82BB3108(ctx, base);
	// 82B90BB0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82B90BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90BB8: 419A0008  beq cr6, 0x82b90bc0
	if ctx.cr[6].eq {
	pc = 0x82B90BC0; continue 'dispatch;
	}
	// 82B90BBC: 4B72FCD5  bl 0x822c0890
	ctx.lr = 0x82B90BC0;
	sub_822C0890(ctx, base);
	// 82B90BC0: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82B90BC4: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 82B90BC8: 4082FFB8  bne 0x82b90b80
	if !ctx.cr[0].eq {
	pc = 0x82B90B80; continue 'dispatch;
	}
	// 82B90BCC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90BD0: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B90BD4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90BDC: 409A000C  bne cr6, 0x82b90be8
	if !ctx.cr[6].eq {
	pc = 0x82B90BE8; continue 'dispatch;
	}
	// 82B90BE0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B90BE4: 48000010  b 0x82b90bf4
	pc = 0x82B90BF4; continue 'dispatch;
	// 82B90BE8: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90BEC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B90BF0: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B90BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90BF8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82B90BFC: 4B9720C5  bl 0x82502cc0
	ctx.lr = 0x82B90C00;
	sub_82502CC0(ctx, base);
	// 82B90C00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B90C04: 419A00F0  beq cr6, 0x82b90cf4
	if ctx.cr[6].eq {
	pc = 0x82B90CF4; continue 'dispatch;
	}
	// 82B90C08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B90C0C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82B90C10: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82B90C14: 3B2B8BF4  addi r25, r11, -0x740c
	ctx.r[25].s64 = ctx.r[11].s64 + -29708;
	// 82B90C18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B90C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B90C20: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 82B90C24: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82B90C28: 482617C1  bl 0x82df23e8
	ctx.lr = 0x82B90C2C;
	sub_82DF23E8(ctx, base);
	// 82B90C2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90C30: 4182001C  beq 0x82b90c4c
	if ctx.cr[0].eq {
	pc = 0x82B90C4C; continue 'dispatch;
	}
	// 82B90C34: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82B90C38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B90C3C: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B90C40: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82B90C44: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B90C48: 48000008  b 0x82b90c50
	pc = 0x82B90C50; continue 'dispatch;
	// 82B90C4C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B90C50: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B90C54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90C58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90C5C: 4BFFED75  bl 0x82b8f9d0
	ctx.lr = 0x82B90C60;
	sub_82B8F9D0(ctx, base);
	// 82B90C60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B90C64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90C68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90C6C: 4B72F395  bl 0x822c0000
	ctx.lr = 0x82B90C70;
	sub_822C0000(ctx, base);
	// 82B90C70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90C74: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82B90C78: 48022491  bl 0x82bb3108
	ctx.lr = 0x82B90C7C;
	sub_82BB3108(ctx, base);
	// 82B90C7C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90C80: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B90C84: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82B90C88: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B90C8C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B90C90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90C94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B90C98: 4B7337C9  bl 0x822c4460
	ctx.lr = 0x82B90C9C;
	sub_822C4460(ctx, base);
	// 82B90C9C: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 82B90CA0: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B90CA4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B90CA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90CAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B90CB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90CB4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B90CB8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82B90CBC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82B90CC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B90CC4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B90CC8: 4B733799  bl 0x822c4460
	ctx.lr = 0x82B90CCC;
	sub_822C4460(ctx, base);
	// 82B90CCC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B90CD0: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82B90CD4: 9BFE0014  stb r31, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u8 ) };
	// 82B90CD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90CDC: 9BFE0015  stb r31, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[31].u8 ) };
	// 82B90CE0: 419A0008  beq cr6, 0x82b90ce8
	if ctx.cr[6].eq {
	pc = 0x82B90CE8; continue 'dispatch;
	}
	// 82B90CE4: 4B72FBAD  bl 0x822c0890
	ctx.lr = 0x82B90CE8;
	sub_822C0890(ctx, base);
	// 82B90CE8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82B90CEC: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B90CF0: 4082FF28  bne 0x82b90c18
	if !ctx.cr[0].eq {
	pc = 0x82B90C18; continue 'dispatch;
	}
	// 82B90CF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B90CF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B90CFC: 997D0040  stb r11, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82B90D00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B90D04: 486174A4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90D08 size=128
    let mut pc: u32 = 0x82B90D08;
    'dispatch: loop {
        match pc {
            0x82B90D08 => {
    //   block [0x82B90D08..0x82B90D88)
	// 82B90D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B90D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90D20: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82B90D24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90D28: 48004669  bl 0x82b95390
	ctx.lr = 0x82B90D2C;
	sub_82B95390(ctx, base);
	// 82B90D2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B90D30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90D34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B90D38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90D3C: 4BFFDB95  bl 0x82b8e8d0
	ctx.lr = 0x82B90D40;
	sub_82B8E8D0(ctx, base);
	// 82B90D40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B90D44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90D48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90D4C: 4B72F2B5  bl 0x822c0000
	ctx.lr = 0x82B90D50;
	sub_822C0000(ctx, base);
	// 82B90D50: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90D54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90D58: 386B0050  addi r3, r11, 0x50
	ctx.r[3].s64 = ctx.r[11].s64 + 80;
	// 82B90D5C: 480223AD  bl 0x82bb3108
	ctx.lr = 0x82B90D60;
	sub_82BB3108(ctx, base);
	// 82B90D60: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B90D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90D68: 419A0008  beq cr6, 0x82b90d70
	if ctx.cr[6].eq {
	pc = 0x82B90D70; continue 'dispatch;
	}
	// 82B90D6C: 4B72FB25  bl 0x822c0890
	ctx.lr = 0x82B90D70;
	sub_822C0890(ctx, base);
	// 82B90D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B90D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B90D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90D88 size=128
    let mut pc: u32 = 0x82B90D88;
    'dispatch: loop {
        match pc {
            0x82B90D88 => {
    //   block [0x82B90D88..0x82B90E08)
	// 82B90D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B90D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90DA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82B90DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90DA8: 48004991  bl 0x82b95738
	ctx.lr = 0x82B90DAC;
	sub_82B95738(ctx, base);
	// 82B90DAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B90DB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90DB4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B90DB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90DBC: 4BFFDBDD  bl 0x82b8e998
	ctx.lr = 0x82B90DC0;
	sub_82B8E998(ctx, base);
	// 82B90DC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B90DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90DC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90DCC: 4B72F235  bl 0x822c0000
	ctx.lr = 0x82B90DD0;
	sub_822C0000(ctx, base);
	// 82B90DD0: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90DD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90DD8: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 82B90DDC: 4802232D  bl 0x82bb3108
	ctx.lr = 0x82B90DE0;
	sub_82BB3108(ctx, base);
	// 82B90DE0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B90DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90DE8: 419A0008  beq cr6, 0x82b90df0
	if ctx.cr[6].eq {
	pc = 0x82B90DF0; continue 'dispatch;
	}
	// 82B90DEC: 4B72FAA5  bl 0x822c0890
	ctx.lr = 0x82B90DF0;
	sub_822C0890(ctx, base);
	// 82B90DF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B90DF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90DF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90DFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B90E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90E08 size=128
    let mut pc: u32 = 0x82B90E08;
    'dispatch: loop {
        match pc {
            0x82B90E08 => {
    //   block [0x82B90E08..0x82B90E88)
	// 82B90E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B90E10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B90E14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B90E18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90E20: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82B90E24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90E28: 4BFF2CF9  bl 0x82b83b20
	ctx.lr = 0x82B90E2C;
	sub_82B83B20(ctx, base);
	// 82B90E2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B90E30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90E34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82B90E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90E3C: 4BFFDFFD  bl 0x82b8ee38
	ctx.lr = 0x82B90E40;
	sub_82B8EE38(ctx, base);
	// 82B90E40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B90E44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B90E48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90E4C: 4B72F1B5  bl 0x822c0000
	ctx.lr = 0x82B90E50;
	sub_822C0000(ctx, base);
	// 82B90E50: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90E54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90E58: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 82B90E5C: 480222AD  bl 0x82bb3108
	ctx.lr = 0x82B90E60;
	sub_82BB3108(ctx, base);
	// 82B90E60: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B90E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90E68: 419A0008  beq cr6, 0x82b90e70
	if ctx.cr[6].eq {
	pc = 0x82B90E70; continue 'dispatch;
	}
	// 82B90E6C: 4B72FA25  bl 0x822c0890
	ctx.lr = 0x82B90E70;
	sub_822C0890(ctx, base);
	// 82B90E70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B90E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B90E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B90E7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B90E80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B90E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90E88 size=132
    let mut pc: u32 = 0x82B90E88;
    'dispatch: loop {
        match pc {
            0x82B90E88 => {
    //   block [0x82B90E88..0x82B90F0C)
	// 82B90E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90E8C: 486172D5  bl 0x831a8160
	ctx.lr = 0x82B90E90;
	sub_831A8130(ctx, base);
	// 82B90E90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90E94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B90E98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B90E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B90EA0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B90EA4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82B90EA8: 38C00024  li r6, 0x24
	ctx.r[6].s64 = 36;
	// 82B90EAC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B90EB0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82B90EB4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82B90EB8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82B90EBC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82B90EC0: 48261209  bl 0x82df20c8
	ctx.lr = 0x82B90EC4;
	sub_82DF20C8(ctx, base);
	// 82B90EC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B90EC8: 41820038  beq 0x82b90f00
	if ctx.cr[0].eq {
	pc = 0x82B90F00; continue 'dispatch;
	}
	// 82B90ECC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82B90ED0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82B90ED4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B90ED8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B90EDC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82B90EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B90EE4: 48262D1D  bl 0x82df3c00
	ctx.lr = 0x82B90EE8;
	sub_82DF3C00(ctx, base);
	// 82B90EE8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82B90EEC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B90EF0: 4B780711  bl 0x82311600
	ctx.lr = 0x82B90EF4;
	sub_82311600(ctx, base);
	// 82B90EF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B90EF8: 9B5F0020  stb r26, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u8 ) };
	// 82B90EFC: 997F0021  stb r11, 0x21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(33 as u32), ctx.r[11].u8 ) };
	// 82B90F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B90F04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B90F08: 486172A8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90F10 size=204
    let mut pc: u32 = 0x82B90F10;
    'dispatch: loop {
        match pc {
            0x82B90F10 => {
    //   block [0x82B90F10..0x82B90FDC)
	// 82B90F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90F14: 48617251  bl 0x831a8164
	ctx.lr = 0x82B90F18;
	sub_831A8130(ctx, base);
	// 82B90F18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90F20: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82B90F24: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B90F28: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B90F2C: 3BCB0040  addi r30, r11, 0x40
	ctx.r[30].s64 = ctx.r[11].s64 + 64;
	// 82B90F30: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B90F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90F38: 409A000C  bne cr6, 0x82b90f44
	if !ctx.cr[6].eq {
	pc = 0x82B90F44; continue 'dispatch;
	}
	// 82B90F3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B90F40: 48000010  b 0x82b90f50
	pc = 0x82B90F50; continue 'dispatch;
	// 82B90F44: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B90F48: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B90F4C: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B90F50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B90F54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B90F58: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 82B90F5C: 38A00136  li r5, 0x136
	ctx.r[5].s64 = 310;
	// 82B90F60: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 82B90F64: 48261485  bl 0x82df23e8
	ctx.lr = 0x82B90F68;
	sub_82DF23E8(ctx, base);
	// 82B90F68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B90F6C: 4182001C  beq 0x82b90f88
	if ctx.cr[0].eq {
	pc = 0x82B90F88; continue 'dispatch;
	}
	// 82B90F70: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B90F74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82B90F78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90F7C: 4BFFFB55  bl 0x82b90ad0
	ctx.lr = 0x82B90F80;
	sub_82B90AD0(ctx, base);
	// 82B90F80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B90F84: 48000008  b 0x82b90f8c
	pc = 0x82B90F8C; continue 'dispatch;
	// 82B90F88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B90F8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82B90F90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90F98: 4BFFFA39  bl 0x82b909d0
	ctx.lr = 0x82B90F9C;
	sub_82B909D0(ctx, base);
	// 82B90F9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B90FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B90FA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B90FA8: 4B72F059  bl 0x822c0000
	ctx.lr = 0x82B90FAC;
	sub_822C0000(ctx, base);
	// 82B90FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B90FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B90FB4: 48022155  bl 0x82bb3108
	ctx.lr = 0x82B90FB8;
	sub_82BB3108(ctx, base);
	// 82B90FB8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B90FBC: 9B630040  stb r27, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 82B90FC0: 4BFFD429  bl 0x82b8e3e8
	ctx.lr = 0x82B90FC4;
	sub_82B8E3E8(ctx, base);
	// 82B90FC4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B90FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B90FCC: 419A0008  beq cr6, 0x82b90fd4
	if ctx.cr[6].eq {
	pc = 0x82B90FD4; continue 'dispatch;
	}
	// 82B90FD0: 4B72F8C1  bl 0x822c0890
	ctx.lr = 0x82B90FD4;
	sub_822C0890(ctx, base);
	// 82B90FD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B90FD8: 486171DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B90FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B90FE0 size=100
    let mut pc: u32 = 0x82B90FE0;
    'dispatch: loop {
        match pc {
            0x82B90FE0 => {
    //   block [0x82B90FE0..0x82B91044)
	// 82B90FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B90FE4: 48617185  bl 0x831a8168
	ctx.lr = 0x82B90FE8;
	sub_831A8130(ctx, base);
	// 82B90FE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B90FEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B90FF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B90FF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B90FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B90FFC: 409A000C  bne cr6, 0x82b91008
	if !ctx.cr[6].eq {
	pc = 0x82B91008; continue 'dispatch;
	}
	// 82B91000: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B91004: 48000010  b 0x82b91014
	pc = 0x82B91014; continue 'dispatch;
	// 82B91008: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9100C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91010: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B91014: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B91018: 419A0024  beq cr6, 0x82b9103c
	if ctx.cr[6].eq {
	pc = 0x82B9103C; continue 'dispatch;
	}
	// 82B9101C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B91020: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91024: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B91028: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82B9102C: 4BFFFCDD  bl 0x82b90d08
	ctx.lr = 0x82B91030;
	sub_82B90D08(ctx, base);
	// 82B91030: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B91034: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B91038: 4082FFE8  bne 0x82b91020
	if !ctx.cr[0].eq {
	pc = 0x82B91020; continue 'dispatch;
	}
	// 82B9103C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B91040: 48617178  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91048 size=100
    let mut pc: u32 = 0x82B91048;
    'dispatch: loop {
        match pc {
            0x82B91048 => {
    //   block [0x82B91048..0x82B910AC)
	// 82B91048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9104C: 4861711D  bl 0x831a8168
	ctx.lr = 0x82B91050;
	sub_831A8130(ctx, base);
	// 82B91050: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91054: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B91058: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B9105C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B91064: 409A000C  bne cr6, 0x82b91070
	if !ctx.cr[6].eq {
	pc = 0x82B91070; continue 'dispatch;
	}
	// 82B91068: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B9106C: 48000010  b 0x82b9107c
	pc = 0x82B9107C; continue 'dispatch;
	// 82B91070: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91074: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91078: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B9107C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B91080: 419A0024  beq cr6, 0x82b910a4
	if ctx.cr[6].eq {
	pc = 0x82B910A4; continue 'dispatch;
	}
	// 82B91084: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B91088: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9108C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B91090: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82B91094: 4BFFFCF5  bl 0x82b90d88
	ctx.lr = 0x82B91098;
	sub_82B90D88(ctx, base);
	// 82B91098: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B9109C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B910A0: 4082FFE8  bne 0x82b91088
	if !ctx.cr[0].eq {
	pc = 0x82B91088; continue 'dispatch;
	}
	// 82B910A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B910A8: 48617110  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B910B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B910B0 size=100
    let mut pc: u32 = 0x82B910B0;
    'dispatch: loop {
        match pc {
            0x82B910B0 => {
    //   block [0x82B910B0..0x82B91114)
	// 82B910B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B910B4: 486170B5  bl 0x831a8168
	ctx.lr = 0x82B910B8;
	sub_831A8130(ctx, base);
	// 82B910B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B910BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B910C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B910C4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B910C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B910CC: 409A000C  bne cr6, 0x82b910d8
	if !ctx.cr[6].eq {
	pc = 0x82B910D8; continue 'dispatch;
	}
	// 82B910D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B910D4: 48000010  b 0x82b910e4
	pc = 0x82B910E4; continue 'dispatch;
	// 82B910D8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B910DC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B910E0: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B910E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B910E8: 419A0024  beq cr6, 0x82b9110c
	if ctx.cr[6].eq {
	pc = 0x82B9110C; continue 'dispatch;
	}
	// 82B910EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B910F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B910F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B910F8: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82B910FC: 4BFFFD0D  bl 0x82b90e08
	ctx.lr = 0x82B91100;
	sub_82B90E08(ctx, base);
	// 82B91100: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B91104: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B91108: 4082FFE8  bne 0x82b910f0
	if !ctx.cr[0].eq {
	pc = 0x82B910F0; continue 'dispatch;
	}
	// 82B9110C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B91110: 486170A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91118 size=548
    let mut pc: u32 = 0x82B91118;
    'dispatch: loop {
        match pc {
            0x82B91118 => {
    //   block [0x82B91118..0x82B9133C)
	// 82B91118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9111C: 48617045  bl 0x831a8160
	ctx.lr = 0x82B91120;
	sub_831A8130(ctx, base);
	// 82B91120: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91124: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91128: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82B9112C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82B91130: 616BCCCB  ori r11, r11, 0xcccb
	ctx.r[11].u64 = ctx.r[11].u64 | 52427;
	// 82B91134: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B91138: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9113C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82B91140: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82B91144: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B91148: 41980048  blt cr6, 0x82b91190
	if ctx.cr[6].lt {
	pc = 0x82B91190; continue 'dispatch;
	}
	// 82B9114C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B91150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91154: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 82B91158: 4B734771  bl 0x822c58c8
	ctx.lr = 0x82B9115C;
	sub_822C58C8(ctx, base);
	// 82B9115C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B91160: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B91164: 4B7346B5  bl 0x822c5818
	ctx.lr = 0x82B91168;
	sub_822C5818(ctx, base);
	// 82B91168: 4B733149  bl 0x822c42b0
	ctx.lr = 0x82B9116C;
	sub_822C42B0(ctx, base);
	// 82B9116C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B91170: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B91174: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 82B91178: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B9117C: 4B7342F5  bl 0x822c5470
	ctx.lr = 0x82B91180;
	sub_822C5470(ctx, base);
	// 82B91180: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B91184: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B91188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9118C: 4B733B55  bl 0x822c4ce0
	ctx.lr = 0x82B91190;
	sub_822C4CE0(ctx, base);
	// 82B91190: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91194: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82B91198: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82B9119C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82B911A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B911A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B911A8: 4BFFFCE1  bl 0x82b90e88
	ctx.lr = 0x82B911AC;
	sub_82B90E88(ctx, base);
	// 82B911AC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B911B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B911B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B911B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B911BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B911C0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B911C4: 409A0018  bne cr6, 0x82b911dc
	if !ctx.cr[6].eq {
	pc = 0x82B911DC; continue 'dispatch;
	}
	// 82B911C8: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B911CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B911D0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B911D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B911D8: 4800003C  b 0x82b91214
	pc = 0x82B91214; continue 'dispatch;
	// 82B911DC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B911E0: 41820020  beq 0x82b91200
	if ctx.cr[0].eq {
	pc = 0x82B91200; continue 'dispatch;
	}
	// 82B911E4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B911E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B911EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B911F0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B911F4: 409A0024  bne cr6, 0x82b91218
	if !ctx.cr[6].eq {
	pc = 0x82B91218; continue 'dispatch;
	}
	// 82B911F8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B911FC: 4800001C  b 0x82b91218
	pc = 0x82B91218; continue 'dispatch;
	// 82B91200: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B91204: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91208: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9120C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B91210: 409A0008  bne cr6, 0x82b91218
	if !ctx.cr[6].eq {
	pc = 0x82B91218; continue 'dispatch;
	}
	// 82B91214: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B91218: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9121C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82B91220: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82B91224: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82B91228: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B9122C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91230: 409A00F0  bne cr6, 0x82b91320
	if !ctx.cr[6].eq {
	pc = 0x82B91320; continue 'dispatch;
	}
	// 82B91234: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82B91238: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9123C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91240: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91244: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91248: 409A0054  bne cr6, 0x82b9129c
	if !ctx.cr[6].eq {
	pc = 0x82B9129C; continue 'dispatch;
	}
	// 82B9124C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91250: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B91254: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91258: 419A0054  beq cr6, 0x82b912ac
	if ctx.cr[6].eq {
	pc = 0x82B912AC; continue 'dispatch;
	}
	// 82B9125C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91260: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B91264: 409A0010  bne cr6, 0x82b91274
	if !ctx.cr[6].eq {
	pc = 0x82B91274; continue 'dispatch;
	}
	// 82B91268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B9126C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B91270: 4B8C2EA9  bl 0x82454118
	ctx.lr = 0x82B91274;
	sub_82454118(ctx, base);
	// 82B91274: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B9127C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B91280: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91288: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 82B9128C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91290: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91294: 4BC37E15  bl 0x827c90a8
	ctx.lr = 0x82B91298;
	sub_827C90A8(ctx, base);
	// 82B91298: 48000074  b 0x82b9130c
	pc = 0x82B9130C; continue 'dispatch;
	// 82B9129C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B912A0: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B912A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B912A8: 409A0028  bne cr6, 0x82b912d0
	if !ctx.cr[6].eq {
	pc = 0x82B912D0; continue 'dispatch;
	}
	// 82B912AC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B912B0: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B912B4: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B912B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B912BC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B912C0: 9B6A0020  stb r27, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 82B912C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B912C8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B912CC: 48000040  b 0x82b9130c
	pc = 0x82B9130C; continue 'dispatch;
	// 82B912D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B912D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B912D8: 409A0010  bne cr6, 0x82b912e8
	if !ctx.cr[6].eq {
	pc = 0x82B912E8; continue 'dispatch;
	}
	// 82B912DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B912E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B912E4: 4BC37DC5  bl 0x827c90a8
	ctx.lr = 0x82B912E8;
	sub_827C90A8(ctx, base);
	// 82B912E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B912EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B912F0: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B912F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B912F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B912FC: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 82B91300: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91304: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91308: 4B8C2E11  bl 0x82454118
	ctx.lr = 0x82B9130C;
	sub_82454118(ctx, base);
	// 82B9130C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91310: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82B91314: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82B91318: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B9131C: 419AFF1C  beq cr6, 0x82b91238
	if ctx.cr[6].eq {
	pc = 0x82B91238; continue 'dispatch;
	}
	// 82B91320: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91324: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B91328: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B9132C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91330: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82B91334: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82B91338: 48616E78  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91340 size=372
    let mut pc: u32 = 0x82B91340;
    'dispatch: loop {
        match pc {
            0x82B91340 => {
    //   block [0x82B91340..0x82B914B4)
	// 82B91340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91344: 48616E15  bl 0x831a8158
	ctx.lr = 0x82B91348;
	sub_831A8130(ctx, base);
	// 82B91348: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B9134C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B91350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91354: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91358: 4BFFFBB9  bl 0x82b90f10
	ctx.lr = 0x82B9135C;
	sub_82B90F10(ctx, base);
	// 82B9135C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B91360: 4B7780C9  bl 0x82309428
	ctx.lr = 0x82B91364;
	sub_82309428(ctx, base);
	// 82B91364: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91368: 835F00C0  lwz r26, 0xc0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B9136C: 832B000C  lwz r25, 0xc(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B91370: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B91374: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9137C: 830AFFF8  lwz r24, -8(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B91380: 409A000C  bne cr6, 0x82b9138c
	if !ctx.cr[6].eq {
	pc = 0x82B9138C; continue 'dispatch;
	}
	// 82B91384: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B91388: 48000010  b 0x82b91398
	pc = 0x82B91398; continue 'dispatch;
	// 82B9138C: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91390: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91394: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B91398: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82B9139C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B913A0: 38780030  addi r3, r24, 0x30
	ctx.r[3].s64 = ctx.r[24].s64 + 48;
	// 82B913A4: 4B900885  bl 0x82491c28
	ctx.lr = 0x82B913A8;
	sub_82491C28(ctx, base);
	// 82B913A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B913AC: 419A00F8  beq cr6, 0x82b914a4
	if ctx.cr[6].eq {
	pc = 0x82B914A4; continue 'dispatch;
	}
	// 82B913B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B913B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82B913B8: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82B913BC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B913C0: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82B913C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B913C8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82B913CC: 409A00C8  bne cr6, 0x82b91494
	if !ctx.cr[6].eq {
	pc = 0x82B91494; continue 'dispatch;
	}
	// 82B913D0: 3BCB0014  addi r30, r11, 0x14
	ctx.r[30].s64 = ctx.r[11].s64 + 20;
	// 82B913D4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82B913D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B913DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B913E0: 4B900F29  bl 0x82492308
	ctx.lr = 0x82B913E4;
	sub_82492308(ctx, base);
	// 82B913E4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82B913E8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B913EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B913F0: 409A0070  bne cr6, 0x82b91460
	if !ctx.cr[6].eq {
	pc = 0x82B91460; continue 'dispatch;
	}
	// 82B913F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B913F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B913FC: 48262805  bl 0x82df3c00
	ctx.lr = 0x82B91400;
	sub_82DF3C00(ctx, base);
	// 82B91400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91404: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B91408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B9140C: 482627F5  bl 0x82df3c00
	ctx.lr = 0x82B91410;
	sub_82DF3C00(ctx, base);
	// 82B91410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B91414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91418: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B9141C: 4826200D  bl 0x82df3428
	ctx.lr = 0x82B91420;
	sub_82DF3428(ctx, base);
	// 82B91420: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B91424: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B91428: 482627D9  bl 0x82df3c00
	ctx.lr = 0x82B9142C;
	sub_82DF3C00(ctx, base);
	// 82B9142C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B91430: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82B91434: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82B91438: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B9143C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82B91440: 4BFED631  bl 0x82b7ea70
	ctx.lr = 0x82B91444;
	sub_82B7EA70(ctx, base);
	// 82B91444: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B91448: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82B9144C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91450: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82B91454: 48261FD5  bl 0x82df3428
	ctx.lr = 0x82B91458;
	sub_82DF3428(ctx, base);
	// 82B91458: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B9145C: 48261FCD  bl 0x82df3428
	ctx.lr = 0x82B91460;
	sub_82DF3428(ctx, base);
	// 82B91460: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82B91464: 389A00C8  addi r4, r26, 0xc8
	ctx.r[4].s64 = ctx.r[26].s64 + 200;
	// 82B91468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82B9146C: 4BFFE0BD  bl 0x82b8f528
	ctx.lr = 0x82B91470;
	sub_82B8F528(ctx, base);
	// 82B91470: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82B91474: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82B91478: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82B9147C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82B91480: 81380034  lwz r9, 0x34(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 82B91484: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82B91488: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82B9148C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82B91490: 7D69E92E  stwx r11, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 82B91494: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82B91498: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82B9149C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82B914A0: 4082FF1C  bne 0x82b913bc
	if !ctx.cr[0].eq {
	pc = 0x82B913BC; continue 'dispatch;
	}
	// 82B914A4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82B914A8: 4BC1BCE9  bl 0x827ad190
	ctx.lr = 0x82B914AC;
	sub_827AD190(ctx, base);
	// 82B914AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82B914B0: 48616CF8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B914B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B914B8 size=132
    let mut pc: u32 = 0x82B914B8;
    'dispatch: loop {
        match pc {
            0x82B914B8 => {
    //   block [0x82B914B8..0x82B9153C)
	// 82B914B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B914BC: 48616CB1  bl 0x831a816c
	ctx.lr = 0x82B914C0;
	sub_831A8130(ctx, base);
	// 82B914C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B914C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B914C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B914CC: 4BFFFB15  bl 0x82b90fe0
	ctx.lr = 0x82B914D0;
	sub_82B90FE0(ctx, base);
	// 82B914D0: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82B914D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B914D8: 4BFFFB71  bl 0x82b91048
	ctx.lr = 0x82B914DC;
	sub_82B91048(ctx, base);
	// 82B914DC: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82B914E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B914E4: 4BFFFBCD  bl 0x82b910b0
	ctx.lr = 0x82B914E8;
	sub_82B910B0(ctx, base);
	// 82B914E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B914EC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82B914F0: 83DD00C0  lwz r30, 0xc0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B914F4: 4BFF306D  bl 0x82b84560
	ctx.lr = 0x82B914F8;
	sub_82B84560(ctx, base);
	// 82B914F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B914FC: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 82B91500: 4BFFE3F1  bl 0x82b8f8f0
	ctx.lr = 0x82B91504;
	sub_82B8F8F0(ctx, base);
	// 82B91504: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 82B91508: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9150C: 4BFFF15D  bl 0x82b90668
	ctx.lr = 0x82B91510;
	sub_82B90668(ctx, base);
	// 82B91510: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82B91514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B91518: 4BFFF1C1  bl 0x82b906d8
	ctx.lr = 0x82B9151C;
	sub_82B906D8(ctx, base);
	// 82B9151C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82B91520: 83FD00C0  lwz r31, 0xc0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B91524: 4BFF20ED  bl 0x82b83610
	ctx.lr = 0x82B91528;
	sub_82B83610(ctx, base);
	// 82B91528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82B9152C: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 82B91530: 4BFFE431  bl 0x82b8f960
	ctx.lr = 0x82B91534;
	sub_82B8F960(ctx, base);
	// 82B91534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B91538: 48616C84  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91540 size=236
    let mut pc: u32 = 0x82B91540;
    'dispatch: loop {
        match pc {
            0x82B91540 => {
    //   block [0x82B91540..0x82B9162C)
	// 82B91540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91544: 48616C19  bl 0x831a815c
	ctx.lr = 0x82B91548;
	sub_831A8130(ctx, base);
	// 82B91548: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B9154C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82B91550: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82B91554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91558: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B9155C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82B91560: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91564: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91568: 4800002C  b 0x82b91594
	pc = 0x82B91594; continue 'dispatch;
	// 82B9156C: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82B91570: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B91574: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B91578: 48261CC1  bl 0x82df3238
	ctx.lr = 0x82B9157C;
	sub_82DF3238(ctx, base);
	// 82B9157C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B91580: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91584: 4182000C  beq 0x82b91590
	if ctx.cr[0].eq {
	pc = 0x82B91590; continue 'dispatch;
	}
	// 82B91588: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9158C: 48000008  b 0x82b91594
	pc = 0x82B91594; continue 'dispatch;
	// 82B91590: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91594: 897D0021  lbz r11, 0x21(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B91598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9159C: 419AFFD0  beq cr6, 0x82b9156c
	if ctx.cr[6].eq {
	pc = 0x82B9156C; continue 'dispatch;
	}
	// 82B915A0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82B915A4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B915A8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82B915AC: 41820048  beq 0x82b915f4
	if ctx.cr[0].eq {
	pc = 0x82B915F4; continue 'dispatch;
	}
	// 82B915B0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B915B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B915B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B915BC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B915C0: 409A002C  bne cr6, 0x82b915ec
	if !ctx.cr[6].eq {
	pc = 0x82B915EC; continue 'dispatch;
	}
	// 82B915C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B915C8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B915CC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82B915D0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82B915D4: 4BFFFB45  bl 0x82b91118
	ctx.lr = 0x82B915D8;
	sub_82B91118(ctx, base);
	// 82B915D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B915DC: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 82B915E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B915E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B915E8: 48000038  b 0x82b91620
	pc = 0x82B91620; continue 'dispatch;
	// 82B915EC: 4BFFCD6D  bl 0x82b8e358
	ctx.lr = 0x82B915F0;
	sub_82B8E358(ctx, base);
	// 82B915F0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B915F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B915F8: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82B915FC: 48261C3D  bl 0x82df3238
	ctx.lr = 0x82B91600;
	sub_82DF3238(ctx, base);
	// 82B91600: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91604: 41820010  beq 0x82b91614
	if ctx.cr[0].eq {
	pc = 0x82B91614; continue 'dispatch;
	}
	// 82B91608: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82B9160C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91610: 4BFFFFB8  b 0x82b915c8
	pc = 0x82B915C8; continue 'dispatch;
	// 82B91614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B91618: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82B9161C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82B91620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91624: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B91628: 48616B84  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91630 size=168
    let mut pc: u32 = 0x82B91630;
    'dispatch: loop {
        match pc {
            0x82B91630 => {
    //   block [0x82B91630..0x82B916D8)
	// 82B91630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B91638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B9163C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91644: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 82B91648: 4BFFF331  bl 0x82b90978
	ctx.lr = 0x82B9164C;
	sub_82B90978(ctx, base);
	// 82B9164C: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 82B91650: 4B73C0E9  bl 0x822cd738
	ctx.lr = 0x82B91654;
	sub_822CD738(ctx, base);
	// 82B91654: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 82B91658: 4B73C0E1  bl 0x822cd738
	ctx.lr = 0x82B9165C;
	sub_822CD738(ctx, base);
	// 82B9165C: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82B91660: 4B73C0D9  bl 0x822cd738
	ctx.lr = 0x82B91664;
	sub_822CD738(ctx, base);
	// 82B91664: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 82B91668: 4B73C0D1  bl 0x822cd738
	ctx.lr = 0x82B9166C;
	sub_822CD738(ctx, base);
	// 82B9166C: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82B91670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B91674: 419A0008  beq cr6, 0x82b9167c
	if ctx.cr[6].eq {
	pc = 0x82B9167C; continue 'dispatch;
	}
	// 82B91678: 4B72F219  bl 0x822c0890
	ctx.lr = 0x82B9167C;
	sub_822C0890(ctx, base);
	// 82B9167C: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82B91680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B91684: 419A0008  beq cr6, 0x82b9168c
	if ctx.cr[6].eq {
	pc = 0x82B9168C; continue 'dispatch;
	}
	// 82B91688: 4B72F209  bl 0x822c0890
	ctx.lr = 0x82B9168C;
	sub_822C0890(ctx, base);
	// 82B9168C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82B91690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B91694: 419A0008  beq cr6, 0x82b9169c
	if ctx.cr[6].eq {
	pc = 0x82B9169C; continue 'dispatch;
	}
	// 82B91698: 4B72F1F9  bl 0x822c0890
	ctx.lr = 0x82B9169C;
	sub_822C0890(ctx, base);
	// 82B9169C: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82B916A0: 4B91FC01  bl 0x824b12a0
	ctx.lr = 0x82B916A4;
	sub_824B12A0(ctx, base);
	// 82B916A4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82B916A8: 4B91FBF9  bl 0x824b12a0
	ctx.lr = 0x82B916AC;
	sub_824B12A0(ctx, base);
	// 82B916AC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82B916B0: 4B91FBF1  bl 0x824b12a0
	ctx.lr = 0x82B916B4;
	sub_824B12A0(ctx, base);
	// 82B916B4: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82B916B8: 4B91FBE9  bl 0x824b12a0
	ctx.lr = 0x82B916BC;
	sub_824B12A0(ctx, base);
	// 82B916BC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82B916C0: 4B7375F9  bl 0x822c8cb8
	ctx.lr = 0x82B916C4;
	sub_822C8CB8(ctx, base);
	// 82B916C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B916C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B916CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B916D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B916D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B916D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B916D8 size=216
    let mut pc: u32 = 0x82B916D8;
    'dispatch: loop {
        match pc {
            0x82B916D8 => {
    //   block [0x82B916D8..0x82B917B0)
	// 82B916D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B916DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B916E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B916E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B916E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B916EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B916F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B916F4: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 82B916F8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82B916FC: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82B91700: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82B91704: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82B91708: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82B9170C: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82B91710: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82B91714: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82B91718: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82B9171C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82B91720: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82B91724: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82B91728: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82B9172C: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82B91730: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82B91734: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82B91738: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82B9173C: 93DF0090  stw r30, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82B91740: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82B91744: 4B8A38CD  bl 0x82435010
	ctx.lr = 0x82B91748;
	sub_82435010(ctx, base);
	// 82B91748: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 82B9174C: 4B8A38C5  bl 0x82435010
	ctx.lr = 0x82B91750;
	sub_82435010(ctx, base);
	// 82B91750: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 82B91754: 4B8A38BD  bl 0x82435010
	ctx.lr = 0x82B91758;
	sub_82435010(ctx, base);
	// 82B91758: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 82B9175C: 4B8A38B5  bl 0x82435010
	ctx.lr = 0x82B91760;
	sub_82435010(ctx, base);
	// 82B91760: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 82B91764: 4BFFDE35  bl 0x82b8f598
	ctx.lr = 0x82B91768;
	sub_82B8F598(ctx, base);
	// 82B91768: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B9176C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B91770: 9BDF0150  stb r30, 0x150(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u8 ) };
	// 82B91774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91778: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B9177C: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82B91780: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82B91784: 9BDF0158  stb r30, 0x158(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u8 ) };
	// 82B91788: D1BF015C  stfs f13, 0x15c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82B9178C: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82B91790: D1BF0164  stfs f13, 0x164(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82B91794: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82B91798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B9179C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B917A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B917A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B917A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B917AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B917B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B917B0 size=424
    let mut pc: u32 = 0x82B917B0;
    'dispatch: loop {
        match pc {
            0x82B917B0 => {
    //   block [0x82B917B0..0x82B91958)
	// 82B917B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B917B4: 486169AD  bl 0x831a8160
	ctx.lr = 0x82B917B8;
	sub_831A8130(ctx, base);
	// 82B917B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B917BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B917C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B917C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B917C8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82B917CC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B917D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B917D4: 409A0020  bne cr6, 0x82b917f4
	if !ctx.cr[6].eq {
	pc = 0x82B917F4; continue 'dispatch;
	}
	// 82B917D8: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B917DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B917E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B917E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B917E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B917EC: 4BFFF92D  bl 0x82b91118
	ctx.lr = 0x82B917F0;
	sub_82B91118(ctx, base);
	// 82B917F0: 4800015C  b 0x82b9194c
	pc = 0x82B9194C; continue 'dispatch;
	// 82B917F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B917F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B917FC: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B91800: 409A0020  bne cr6, 0x82b91820
	if !ctx.cr[6].eq {
	pc = 0x82B91820; continue 'dispatch;
	}
	// 82B91804: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 82B91808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B9180C: 48261A2D  bl 0x82df3238
	ctx.lr = 0x82B91810;
	sub_82DF3238(ctx, base);
	// 82B91810: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91814: 4182011C  beq 0x82b91930
	if ctx.cr[0].eq {
	pc = 0x82B91930; continue 'dispatch;
	}
	// 82B91818: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B9181C: 4BFFFFC0  b 0x82b917dc
	pc = 0x82B917DC; continue 'dispatch;
	// 82B91820: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B91824: 409A002C  bne cr6, 0x82b91850
	if !ctx.cr[6].eq {
	pc = 0x82B91850; continue 'dispatch;
	}
	// 82B91828: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9182C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B91830: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82B91834: 48261A05  bl 0x82df3238
	ctx.lr = 0x82B91838;
	sub_82DF3238(ctx, base);
	// 82B91838: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B9183C: 418200F4  beq 0x82b91930
	if ctx.cr[0].eq {
	pc = 0x82B91930; continue 'dispatch;
	}
	// 82B91840: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91844: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B91848: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B9184C: 4BFFFF94  b 0x82b917e0
	pc = 0x82B917E0; continue 'dispatch;
	// 82B91850: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 82B91854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91858: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B9185C: 482619DD  bl 0x82df3238
	ctx.lr = 0x82B91860;
	sub_82DF3238(ctx, base);
	// 82B91860: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91864: 4182005C  beq 0x82b918c0
	if ctx.cr[0].eq {
	pc = 0x82B918C0; continue 'dispatch;
	}
	// 82B91868: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82B9186C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91870: 4BFFCAE9  bl 0x82b8e358
	ctx.lr = 0x82B91874;
	sub_82B8E358(ctx, base);
	// 82B91874: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B91878: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B9187C: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82B91880: 482619B9  bl 0x82df3238
	ctx.lr = 0x82B91884;
	sub_82DF3238(ctx, base);
	// 82B91884: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91888: 41820038  beq 0x82b918c0
	if ctx.cr[0].eq {
	pc = 0x82B918C0; continue 'dispatch;
	}
	// 82B9188C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91890: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B91894: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B9189C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B918A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B918A4: 419A0010  beq cr6, 0x82b918b4
	if ctx.cr[6].eq {
	pc = 0x82B918B4; continue 'dispatch;
	}
	// 82B918A8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B918AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B918B0: 4BFFFF3C  b 0x82b917ec
	pc = 0x82B917EC; continue 'dispatch;
	// 82B918B4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B918B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B918BC: 4BFFFF30  b 0x82b917ec
	pc = 0x82B917EC; continue 'dispatch;
	// 82B918C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B918C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B918C8: 48261971  bl 0x82df3238
	ctx.lr = 0x82B918CC;
	sub_82DF3238(ctx, base);
	// 82B918CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B918D0: 41820060  beq 0x82b91930
	if ctx.cr[0].eq {
	pc = 0x82B91930; continue 'dispatch;
	}
	// 82B918D4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82B918D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B918DC: 4BC37755  bl 0x827c9030
	ctx.lr = 0x82B918E0;
	sub_827C9030(ctx, base);
	// 82B918E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B918E4: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B918E8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B918EC: 419A0018  beq cr6, 0x82b91904
	if ctx.cr[6].eq {
	pc = 0x82B91904; continue 'dispatch;
	}
	// 82B918F0: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 82B918F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B918F8: 48261941  bl 0x82df3238
	ctx.lr = 0x82B918FC;
	sub_82DF3238(ctx, base);
	// 82B918FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91900: 41820030  beq 0x82b91930
	if ctx.cr[0].eq {
	pc = 0x82B91930; continue 'dispatch;
	}
	// 82B91904: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91908: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B9190C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B91914: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82B91918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9191C: 419A000C  beq cr6, 0x82b91928
	if ctx.cr[6].eq {
	pc = 0x82B91928; continue 'dispatch;
	}
	// 82B91920: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B91924: 4BFFFF88  b 0x82b918ac
	pc = 0x82B918AC; continue 'dispatch;
	// 82B91928: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B9192C: 4BFFFF8C  b 0x82b918b8
	pc = 0x82B918B8; continue 'dispatch;
	// 82B91930: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B91934: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9193C: 4BFFFC05  bl 0x82b91540
	ctx.lr = 0x82B91940;
	sub_82B91540(ctx, base);
	// 82B91940: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B91944: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91948: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B9194C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B91950: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B91954: 4861685C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91958 size=164
    let mut pc: u32 = 0x82B91958;
    'dispatch: loop {
        match pc {
            0x82B91958 => {
    //   block [0x82B91958..0x82B919FC)
	// 82B91958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9195C: 48616811  bl 0x831a816c
	ctx.lr = 0x82B91960;
	sub_831A8130(ctx, base);
	// 82B91960: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91964: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B91968: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B9196C: 4BFFCE65  bl 0x82b8e7d0
	ctx.lr = 0x82B91970;
	sub_82B8E7D0(ctx, base);
	// 82B91970: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91978: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B9197C: 419A0018  beq cr6, 0x82b91994
	if ctx.cr[6].eq {
	pc = 0x82B91994; continue 'dispatch;
	}
	// 82B91980: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82B91984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B91988: 482618B1  bl 0x82df3238
	ctx.lr = 0x82B9198C;
	sub_82DF3238(ctx, base);
	// 82B9198C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91990: 41820060  beq 0x82b919f0
	if ctx.cr[0].eq {
	pc = 0x82B919F0; continue 'dispatch;
	}
	// 82B91994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B91998: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B9199C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B919A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B919A4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82B919A8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82B919AC: 48262255  bl 0x82df3c00
	ctx.lr = 0x82B919B0;
	sub_82DF3C00(ctx, base);
	// 82B919B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B919B4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82B919B8: 4B77FC49  bl 0x82311600
	ctx.lr = 0x82B919BC;
	sub_82311600(ctx, base);
	// 82B919BC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82B919C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B919C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B919C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B919CC: 4BFFFDE5  bl 0x82b917b0
	ctx.lr = 0x82B919D0;
	sub_82B917B0(ctx, base);
	// 82B919D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B919D4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82B919D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B919DC: 4B8D8625  bl 0x8246a000
	ctx.lr = 0x82B919E0;
	sub_8246A000(ctx, base);
	// 82B919E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B919E4: 48261A45  bl 0x82df3428
	ctx.lr = 0x82B919E8;
	sub_82DF3428(ctx, base);
	// 82B919E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B919EC: 4B8D8615  bl 0x8246a000
	ctx.lr = 0x82B919F0;
	sub_8246A000(ctx, base);
	// 82B919F0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B919F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82B919F8: 486167C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91A00 size=204
    let mut pc: u32 = 0x82B91A00;
    'dispatch: loop {
        match pc {
            0x82B91A00 => {
    //   block [0x82B91A00..0x82B91ACC)
	// 82B91A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91A04: 48616759  bl 0x831a815c
	ctx.lr = 0x82B91A08;
	sub_831A8130(ctx, base);
	// 82B91A08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91A0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B91A10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91A14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91A18: 4BFFF4F9  bl 0x82b90f10
	ctx.lr = 0x82B91A1C;
	sub_82B90F10(ctx, base);
	// 82B91A1C: 835F00C0  lwz r26, 0xc0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B91A20: 3B7A00C8  addi r27, r26, 0xc8
	ctx.r[27].s64 = ctx.r[26].s64 + 200;
	// 82B91A24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B91A28: 4BFFEE71  bl 0x82b90898
	ctx.lr = 0x82B91A2C;
	sub_82B90898(ctx, base);
	// 82B91A2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91A30: 838B000C  lwz r28, 0xc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B91A34: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B91A3C: 409A000C  bne cr6, 0x82b91a48
	if !ctx.cr[6].eq {
	pc = 0x82B91A48; continue 'dispatch;
	}
	// 82B91A40: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B91A44: 48000010  b 0x82b91a54
	pc = 0x82B91A54; continue 'dispatch;
	// 82B91A48: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91A4C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91A50: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B91A54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B91A58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82B91A5C: 419A0048  beq cr6, 0x82b91aa4
	if ctx.cr[6].eq {
	pc = 0x82B91AA4; continue 'dispatch;
	}
	// 82B91A60: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B91A64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91A68: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B91A6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91A70: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82B91A74: 409A0020  bne cr6, 0x82b91a94
	if !ctx.cr[6].eq {
	pc = 0x82B91A94; continue 'dispatch;
	}
	// 82B91A78: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82B91A7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82B91A80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B91A84: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 82B91A88: 4BFFFED1  bl 0x82b91958
	ctx.lr = 0x82B91A8C;
	sub_82B91958(ctx, base);
	// 82B91A8C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82B91A90: 4B927681  bl 0x824b9110
	ctx.lr = 0x82B91A94;
	sub_824B9110(ctx, base);
	// 82B91A94: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82B91A98: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B91A9C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B91AA0: 4198FFC4  blt cr6, 0x82b91a64
	if ctx.cr[6].lt {
	pc = 0x82B91A64; continue 'dispatch;
	}
	// 82B91AA4: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B91AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B91AAC: 419A0010  beq cr6, 0x82b91abc
	if ctx.cr[6].eq {
	pc = 0x82B91ABC; continue 'dispatch;
	}
	// 82B91AB0: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B91AB4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91AB8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B91ABC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82B91AC0: 917A00D4  stw r11, 0xd4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82B91AC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B91AC8: 486166E4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91AD0 size=184
    let mut pc: u32 = 0x82B91AD0;
    'dispatch: loop {
        match pc {
            0x82B91AD0 => {
    //   block [0x82B91AD0..0x82B91B88)
	// 82B91AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91AD4: 48616695  bl 0x831a8168
	ctx.lr = 0x82B91AD8;
	sub_831A8130(ctx, base);
	// 82B91AD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91ADC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B91AE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B91AE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B91AE8: 396B8C48  addi r11, r11, -0x73b8
	ctx.r[11].s64 = ctx.r[11].s64 + -29624;
	// 82B91AEC: 394A8C34  addi r10, r10, -0x73cc
	ctx.r[10].s64 = ctx.r[10].s64 + -29644;
	// 82B91AF0: 839D00C0  lwz r28, 0xc0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B91AF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91AF8: 915D0028  stw r10, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82B91AFC: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B91B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B91B04: 409A000C  bne cr6, 0x82b91b10
	if !ctx.cr[6].eq {
	pc = 0x82B91B10; continue 'dispatch;
	}
	// 82B91B08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82B91B0C: 48000010  b 0x82b91b1c
	pc = 0x82B91B1C; continue 'dispatch;
	// 82B91B10: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82B91B14: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B91B18: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82B91B1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B91B20: 419A0020  beq cr6, 0x82b91b40
	if ctx.cr[6].eq {
	pc = 0x82B91B40; continue 'dispatch;
	}
	// 82B91B24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B91B28: 817C0044  lwz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82B91B2C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82B91B30: 4BFFC921  bl 0x82b8e450
	ctx.lr = 0x82B91B34;
	sub_82B8E450(ctx, base);
	// 82B91B34: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B91B38: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82B91B3C: 4082FFEC  bne 0x82b91b28
	if !ctx.cr[0].eq {
	pc = 0x82B91B28; continue 'dispatch;
	}
	// 82B91B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91B44: 4B958F45  bl 0x824eaa88
	ctx.lr = 0x82B91B48;
	sub_824EAA88(ctx, base);
	// 82B91B48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91B4C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91B50: 4B95AB11  bl 0x824ec660
	ctx.lr = 0x82B91B54;
	sub_824EC660(ctx, base);
	// 82B91B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91B58: 48260139  bl 0x82df1c90
	ctx.lr = 0x82B91B5C;
	sub_82DF1C90(ctx, base);
	// 82B91B5C: 83FD00C0  lwz r31, 0xc0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82B91B60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B91B64: 419A0014  beq cr6, 0x82b91b78
	if ctx.cr[6].eq {
	pc = 0x82B91B78; continue 'dispatch;
	}
	// 82B91B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91B6C: 4BFFFAC5  bl 0x82b91630
	ctx.lr = 0x82B91B70;
	sub_82B91630(ctx, base);
	// 82B91B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91B74: 48260865  bl 0x82df23d8
	ctx.lr = 0x82B91B78;
	sub_82DF23D8(ctx, base);
	// 82B91B78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B91B7C: 4B97F61D  bl 0x82511198
	ctx.lr = 0x82B91B80;
	sub_82511198(ctx, base);
	// 82B91B80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B91B84: 48616634  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91B88 size=8
    let mut pc: u32 = 0x82B91B88;
    'dispatch: loop {
        match pc {
            0x82B91B88 => {
    //   block [0x82B91B88..0x82B91B90)
	// 82B91B88: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82B91B8C: 48000164  b 0x82b91cf0
	sub_82B91CF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82B91B90 size=252
    let mut pc: u32 = 0x82B91B90;
    'dispatch: loop {
        match pc {
            0x82B91B90 => {
    //   block [0x82B91B90..0x82B91C8C)
	// 82B91B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91B94: 486165D1  bl 0x831a8164
	ctx.lr = 0x82B91B98;
	sub_831A8130(ctx, base);
	// 82B91B98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91B9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B91BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91BA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B91BA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82B91BAC: 388B8BF4  addi r4, r11, -0x740c
	ctx.r[4].s64 = ctx.r[11].s64 + -29708;
	// 82B91BB0: 38A00358  li r5, 0x358
	ctx.r[5].s64 = 856;
	// 82B91BB4: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 82B91BB8: 48260831  bl 0x82df23e8
	ctx.lr = 0x82B91BBC;
	sub_82DF23E8(ctx, base);
	// 82B91BBC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82B91BC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B91BC4: 4182000C  beq 0x82b91bd0
	if ctx.cr[0].eq {
	pc = 0x82B91BD0; continue 'dispatch;
	}
	// 82B91BC8: 4BFFFB11  bl 0x82b916d8
	ctx.lr = 0x82B91BCC;
	sub_82B916D8(ctx, base);
	// 82B91BCC: 48000008  b 0x82b91bd4
	pc = 0x82B91BD4; continue 'dispatch;
	// 82B91BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B91BD4: 3BFF00C0  addi r31, r31, 0xc0
	ctx.r[31].s64 = ctx.r[31].s64 + 192;
	// 82B91BD8: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91BDC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82B91BE0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82B91BE4: 419A0014  beq cr6, 0x82b91bf8
	if ctx.cr[6].eq {
	pc = 0x82B91BF8; continue 'dispatch;
	}
	// 82B91BE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B91BEC: 4BFFFA45  bl 0x82b91630
	ctx.lr = 0x82B91BF0;
	sub_82B91630(ctx, base);
	// 82B91BF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82B91BF4: 482607E5  bl 0x82df23d8
	ctx.lr = 0x82B91BF8;
	sub_82DF23D8(ctx, base);
	// 82B91BF8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91BFC: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82B91C00: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91C04: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	// 82B91C08: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82B91C0C: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82B91C10: 4B732851  bl 0x822c4460
	ctx.lr = 0x82B91C14;
	sub_822C4460(ctx, base);
	// 82B91C14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B91C18: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B91C1C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82B91C20: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 82B91C24: 3B7F00A4  addi r27, r31, 0xa4
	ctx.r[27].s64 = ctx.r[31].s64 + 164;
	// 82B91C28: 9BDF0011  stb r30, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[30].u8 ) };
	// 82B91C2C: 3B8BB468  addi r28, r11, -0x4b98
	ctx.r[28].s64 = ctx.r[11].s64 + -19352;
	// 82B91C30: 9BDF0012  stb r30, 0x12(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[30].u8 ) };
	// 82B91C34: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82B91C38: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82B91C3C: 9BDF0013  stb r30, 0x13(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(19 as u32), ctx.r[30].u8 ) };
	// 82B91C40: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82B91C44: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82B91C48: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82B91C4C: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 82B91C50: 9BDF0016  stb r30, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[30].u8 ) };
	// 82B91C54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91C58: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91C5C: 48261DAD  bl 0x82df3a08
	ctx.lr = 0x82B91C60;
	sub_82DF3A08(ctx, base);
	// 82B91C60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82B91C64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B91C68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82B91C6C: 4B73B555  bl 0x822cd1c0
	ctx.lr = 0x82B91C70;
	sub_822CD1C0(ctx, base);
	// 82B91C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B91C74: 482617B5  bl 0x82df3428
	ctx.lr = 0x82B91C78;
	sub_82DF3428(ctx, base);
	// 82B91C78: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82B91C7C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82B91C80: 4082FFD4  bne 0x82b91c54
	if !ctx.cr[0].eq {
	pc = 0x82B91C54; continue 'dispatch;
	}
	// 82B91C84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B91C88: 4861652C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91C90 size=96
    let mut pc: u32 = 0x82B91C90;
    'dispatch: loop {
        match pc {
            0x82B91C90 => {
    //   block [0x82B91C90..0x82B91CF0)
	// 82B91C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91C94: 486164D9  bl 0x831a816c
	ctx.lr = 0x82B91C98;
	sub_831A8130(ctx, base);
	// 82B91C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91CA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91CA4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82B91CA8: 4B97F449  bl 0x825110f0
	ctx.lr = 0x82B91CAC;
	sub_825110F0(ctx, base);
	// 82B91CAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B91CB0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B91CB4: 396B8C48  addi r11, r11, -0x73b8
	ctx.r[11].s64 = ctx.r[11].s64 + -29624;
	// 82B91CB8: 394A8C34  addi r10, r10, -0x73cc
	ctx.r[10].s64 = ctx.r[10].s64 + -29644;
	// 82B91CBC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82B91CC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91CC4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82B91CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91CCC: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 82B91CD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91CD4: 4BFFFEBD  bl 0x82b91b90
	ctx.lr = 0x82B91CD8;
	sub_82B91B90(ctx, base);
	// 82B91CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91CDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B91CE0: 4BFFFD21  bl 0x82b91a00
	ctx.lr = 0x82B91CE4;
	sub_82B91A00(ctx, base);
	// 82B91CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91CE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B91CEC: 486164D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91CF0 size=76
    let mut pc: u32 = 0x82B91CF0;
    'dispatch: loop {
        match pc {
            0x82B91CF0 => {
    //   block [0x82B91CF0..0x82B91D3C)
	// 82B91CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B91CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B91CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B91D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91D08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91D0C: 4BFFFDC5  bl 0x82b91ad0
	ctx.lr = 0x82B91D10;
	sub_82B91AD0(ctx, base);
	// 82B91D10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91D14: 4182000C  beq 0x82b91d20
	if ctx.cr[0].eq {
	pc = 0x82B91D20; continue 'dispatch;
	}
	// 82B91D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91D1C: 482606BD  bl 0x82df23d8
	ctx.lr = 0x82B91D20;
	sub_82DF23D8(ctx, base);
	// 82B91D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91D24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B91D28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B91D2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B91D30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B91D34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B91D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91D40 size=104
    let mut pc: u32 = 0x82B91D40;
    'dispatch: loop {
        match pc {
            0x82B91D40 => {
    //   block [0x82B91D40..0x82B91DA8)
	// 82B91D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B91D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B91D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B91D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91D54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B91D58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B91D5C: 4B97F395  bl 0x825110f0
	ctx.lr = 0x82B91D60;
	sub_825110F0(ctx, base);
	// 82B91D60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B91D64: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82B91D68: 396B8C48  addi r11, r11, -0x73b8
	ctx.r[11].s64 = ctx.r[11].s64 + -29624;
	// 82B91D6C: 394A8C34  addi r10, r10, -0x73cc
	ctx.r[10].s64 = ctx.r[10].s64 + -29644;
	// 82B91D70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82B91D74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91D78: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82B91D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91D80: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 82B91D84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B91D88: 4BFFFE09  bl 0x82b91b90
	ctx.lr = 0x82B91D8C;
	sub_82B91B90(ctx, base);
	// 82B91D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B91D90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B91D94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B91D98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B91D9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B91DA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B91DA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91DA8 size=64
    let mut pc: u32 = 0x82B91DA8;
    'dispatch: loop {
        match pc {
            0x82B91DA8 => {
    //   block [0x82B91DA8..0x82B91DE8)
	// 82B91DA8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91DAC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91DB0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B91DB4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91DB8: 892A0091  lbz r9, 0x91(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91DBC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91DC0: 409A0008  bne cr6, 0x82b91dc8
	if !ctx.cr[6].eq {
	pc = 0x82B91DC8; continue 'dispatch;
	}
	// 82B91DC4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82B91DC8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91DCC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B91DD0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91DD4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91DD8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91DDC: 409A000C  bne cr6, 0x82b91de8
	if !ctx.cr[6].eq {
		sub_82B91DE8(ctx, base);
		return;
	}
	// 82B91DE0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B91DE4: 48000020  b 0x82b91e04
	sub_82B91E00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91DE8 size=24
    let mut pc: u32 = 0x82B91DE8;
    'dispatch: loop {
        match pc {
            0x82B91DE8 => {
    //   block [0x82B91DE8..0x82B91E00)
	// 82B91DE8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91DEC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91DF0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91DF4: 409A000C  bne cr6, 0x82b91e00
	if !ctx.cr[6].eq {
		sub_82B91E00(ctx, base);
		return;
	}
	// 82B91DF8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B91DFC: 48000008  b 0x82b91e04
	sub_82B91E00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E00 size=16
    let mut pc: u32 = 0x82B91E00;
    'dispatch: loop {
        match pc {
            0x82B91E00 => {
    //   block [0x82B91E00..0x82B91E10)
	// 82B91E00: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91E04: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82B91E08: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B91E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E10 size=24
    let mut pc: u32 = 0x82B91E10;
    'dispatch: loop {
        match pc {
            0x82B91E10 => {
    //   block [0x82B91E10..0x82B91E28)
	// 82B91E10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91E14: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91E18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91E1C: 419A000C  beq cr6, 0x82b91e28
	if ctx.cr[6].eq {
		sub_82B91E28(ctx, base);
		return;
	}
	// 82B91E20: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91E24: 48000070  b 0x82b91e94
	sub_82B91E94(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E28 size=24
    let mut pc: u32 = 0x82B91E28;
    'dispatch: loop {
        match pc {
            0x82B91E28 => {
    //   block [0x82B91E28..0x82B91E40)
	// 82B91E28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91E2C: 892A0091  lbz r9, 0x91(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91E30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91E34: 409A0040  bne cr6, 0x82b91e74
	if !ctx.cr[6].eq {
		sub_82B91E5C(ctx, base);
		return;
	}
	// 82B91E38: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91E3C: 4800000C  b 0x82b91e48
	sub_82B91E40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E40 size=28
    let mut pc: u32 = 0x82B91E40;
    'dispatch: loop {
        match pc {
            0x82B91E40 => {
    //   block [0x82B91E40..0x82B91E5C)
	// 82B91E40: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B91E44: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91E48: 892B0091  lbz r9, 0x91(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91E4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91E50: 419AFFF0  beq cr6, 0x82b91e40
	if ctx.cr[6].eq {
	pc = 0x82B91E40; continue 'dispatch;
	}
	// 82B91E54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B91E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E5C size=56
    let mut pc: u32 = 0x82B91E5C;
    'dispatch: loop {
        match pc {
            0x82B91E5C => {
    //   block [0x82B91E5C..0x82B91E94)
	// 82B91E5C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91E60: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91E64: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91E68: 409A001C  bne cr6, 0x82b91e84
	if !ctx.cr[6].eq {
	pc = 0x82B91E84; continue 'dispatch;
	}
	// 82B91E6C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91E70: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B91E74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91E78: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91E7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91E80: 419AFFDC  beq cr6, 0x82b91e5c
	if ctx.cr[6].eq {
	pc = 0x82B91E5C; continue 'dispatch;
	}
	// 82B91E84: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91E88: 894A0091  lbz r10, 0x91(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91E8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91E90: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91E94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91E94 size=8
    let mut pc: u32 = 0x82B91E94;
    'dispatch: loop {
        match pc {
            0x82B91E94 => {
    //   block [0x82B91E94..0x82B91E9C)
	// 82B91E94: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91EA0 size=88
    let mut pc: u32 = 0x82B91EA0;
    'dispatch: loop {
        match pc {
            0x82B91EA0 => {
    //   block [0x82B91EA0..0x82B91EF8)
	// 82B91EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91EA4: 486162C9  bl 0x831a816c
	ctx.lr = 0x82B91EA8;
	sub_831A8130(ctx, base);
	// 82B91EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91EAC: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91EB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B91EB4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91EB8: 48000028  b 0x82b91ee0
	pc = 0x82B91EE0; continue 'dispatch;
	// 82B91EBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B91EC0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82B91EC4: 48261375  bl 0x82df3238
	ctx.lr = 0x82B91EC8;
	sub_82DF3238(ctx, base);
	// 82B91EC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B91ECC: 4182000C  beq 0x82b91ed8
	if ctx.cr[0].eq {
	pc = 0x82B91ED8; continue 'dispatch;
	}
	// 82B91ED0: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91ED4: 4800000C  b 0x82b91ee0
	pc = 0x82B91EE0; continue 'dispatch;
	// 82B91ED8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B91EDC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91EE0: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B91EE8: 419AFFD4  beq cr6, 0x82b91ebc
	if ctx.cr[6].eq {
	pc = 0x82B91EBC; continue 'dispatch;
	}
	// 82B91EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B91EF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B91EF4: 486162C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91EF8 size=16
    let mut pc: u32 = 0x82B91EF8;
    'dispatch: loop {
        match pc {
            0x82B91EF8 => {
    //   block [0x82B91EF8..0x82B91F08)
	// 82B91EF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91EFC: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91F00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91F04: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91F08 size=24
    let mut pc: u32 = 0x82B91F08;
    'dispatch: loop {
        match pc {
            0x82B91F08 => {
    //   block [0x82B91F08..0x82B91F20)
	// 82B91F08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91F0C: 892A0091  lbz r9, 0x91(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91F10: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91F14: 409A0040  bne cr6, 0x82b91f54
	if !ctx.cr[6].eq {
		sub_82B91F3C(ctx, base);
		return;
	}
	// 82B91F18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91F1C: 4800000C  b 0x82b91f28
	sub_82B91F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91F20 size=28
    let mut pc: u32 = 0x82B91F20;
    'dispatch: loop {
        match pc {
            0x82B91F20 => {
    //   block [0x82B91F20..0x82B91F3C)
	// 82B91F20: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B91F24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91F28: 892B0091  lbz r9, 0x91(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91F2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91F30: 419AFFF0  beq cr6, 0x82b91f20
	if ctx.cr[6].eq {
	pc = 0x82B91F20; continue 'dispatch;
	}
	// 82B91F34: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B91F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91F3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91F3C size=48
    let mut pc: u32 = 0x82B91F3C;
    'dispatch: loop {
        match pc {
            0x82B91F3C => {
    //   block [0x82B91F3C..0x82B91F6C)
	// 82B91F3C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91F40: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91F44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91F48: 409A001C  bne cr6, 0x82b91f64
	if !ctx.cr[6].eq {
	pc = 0x82B91F64; continue 'dispatch;
	}
	// 82B91F4C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91F50: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B91F54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91F58: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91F5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B91F60: 419AFFDC  beq cr6, 0x82b91f3c
	if ctx.cr[6].eq {
	pc = 0x82B91F3C; continue 'dispatch;
	}
	// 82B91F64: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91F70 size=64
    let mut pc: u32 = 0x82B91F70;
    'dispatch: loop {
        match pc {
            0x82B91F70 => {
    //   block [0x82B91F70..0x82B91FB0)
	// 82B91F70: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B91F74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91F78: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B91F7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91F80: 892A0091  lbz r9, 0x91(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B91F84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B91F88: 409A0008  bne cr6, 0x82b91f90
	if !ctx.cr[6].eq {
	pc = 0x82B91F90; continue 'dispatch;
	}
	// 82B91F8C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82B91F90: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91F94: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B91F98: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91F9C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91FA0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91FA4: 409A000C  bne cr6, 0x82b91fb0
	if !ctx.cr[6].eq {
		sub_82B91FB0(ctx, base);
		return;
	}
	// 82B91FA8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B91FAC: 48000020  b 0x82b91fcc
	sub_82B91FC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91FB0 size=24
    let mut pc: u32 = 0x82B91FB0;
    'dispatch: loop {
        match pc {
            0x82B91FB0 => {
    //   block [0x82B91FB0..0x82B91FC8)
	// 82B91FB0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B91FB4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B91FB8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B91FBC: 409A000C  bne cr6, 0x82b91fc8
	if !ctx.cr[6].eq {
		sub_82B91FC8(ctx, base);
		return;
	}
	// 82B91FC0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B91FC4: 48000008  b 0x82b91fcc
	sub_82B91FC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B91FC8 size=16
    let mut pc: u32 = 0x82B91FC8;
    'dispatch: loop {
        match pc {
            0x82B91FC8 => {
    //   block [0x82B91FC8..0x82B91FD8)
	// 82B91FC8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B91FCC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82B91FD0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B91FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B91FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B91FD8 size=172
    let mut pc: u32 = 0x82B91FD8;
    'dispatch: loop {
        match pc {
            0x82B91FD8 => {
    //   block [0x82B91FD8..0x82B92084)
	// 82B91FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B91FDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B91FE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B91FE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B91FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B91FEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B91FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B91FF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B91FF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B91FFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92000: 4B72E939  bl 0x822c0938
	ctx.lr = 0x82B92004;
	sub_822C0938(ctx, base);
	// 82B92004: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B92008: 41820028  beq 0x82b92030
	if ctx.cr[0].eq {
	pc = 0x82B92030; continue 'dispatch;
	}
	// 82B9200C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B92010: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B92014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B92018: 392B8CB0  addi r9, r11, -0x7350
	ctx.r[9].s64 = ctx.r[11].s64 + -29520;
	// 82B9201C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B92020: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B92024: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B92028: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B9202C: 48000008  b 0x82b92034
	pc = 0x82B92034; continue 'dispatch;
	// 82B92030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B92034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9203C: 409A002C  bne cr6, 0x82b92068
	if !ctx.cr[6].eq {
	pc = 0x82B92068; continue 'dispatch;
	}
	// 82B92040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92044: 48260395  bl 0x82df23d8
	ctx.lr = 0x82B92048;
	sub_82DF23D8(ctx, base);
	// 82B92048: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B9204C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B92050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92054: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B92058: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B9205C: 816BB470  lwz r11, -0x4b90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19344 as u32) ) } as u64;
	// 82B92060: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B92064: 4B72DF9D  bl 0x822c0000
	ctx.lr = 0x82B92068;
	sub_822C0000(ctx, base);
	// 82B92068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B9206C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B92070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B9207C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B92080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92088 size=108
    let mut pc: u32 = 0x82B92088;
    'dispatch: loop {
        match pc {
            0x82B92088 => {
    //   block [0x82B92088..0x82B920F4)
	// 82B92088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9208C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92090: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92094: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B92098: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B9209C: 38C00094  li r6, 0x94
	ctx.r[6].s64 = 148;
	// 82B920A0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82B920A4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82B920A8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B920AC: 4826001D  bl 0x82df20c8
	ctx.lr = 0x82B920B0;
	sub_82DF20C8(ctx, base);
	// 82B920B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B920B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B920B8: 41820008  beq 0x82b920c0
	if ctx.cr[0].eq {
	pc = 0x82B920C0; continue 'dispatch;
	}
	// 82B920BC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B920C0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B920C4: 41820008  beq 0x82b920cc
	if ctx.cr[0].eq {
	pc = 0x82B920CC; continue 'dispatch;
	}
	// 82B920C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B920CC: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B920D0: 41820008  beq 0x82b920d8
	if ctx.cr[0].eq {
	pc = 0x82B920D8; continue 'dispatch;
	}
	// 82B920D4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B920D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B920DC: 99430091  stb r10, 0x91(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(145 as u32), ctx.r[10].u8 ) };
	// 82B920E0: 99630090  stb r11, 0x90(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 82B920E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B920E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B920EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B920F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B920F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B920F8 size=112
    let mut pc: u32 = 0x82B920F8;
    'dispatch: loop {
        match pc {
            0x82B920F8 => {
    //   block [0x82B920F8..0x82B92168)
	// 82B920F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B920FC: 48616071  bl 0x831a816c
	ctx.lr = 0x82B92100;
	sub_831A8130(ctx, base);
	// 82B92100: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92104: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B92108: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82B9210C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B92110: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B92114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92118: 4BFFFD89  bl 0x82b91ea0
	ctx.lr = 0x82B9211C;
	sub_82B91EA0(ctx, base);
	// 82B9211C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92120: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82B92124: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92128: 419A0020  beq cr6, 0x82b92148
	if ctx.cr[6].eq {
	pc = 0x82B92148; continue 'dispatch;
	}
	// 82B9212C: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 82B92130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92134: 48261105  bl 0x82df3238
	ctx.lr = 0x82B92138;
	sub_82DF3238(ctx, base);
	// 82B92138: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B9213C: 4082000C  bne 0x82b92148
	if !ctx.cr[0].eq {
	pc = 0x82B92148; continue 'dispatch;
	}
	// 82B92140: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82B92144: 48000010  b 0x82b92154
	pc = 0x82B92154; continue 'dispatch;
	// 82B92148: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9214C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82B92150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82B92154: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92158: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9215C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92160: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B92164: 48616058  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92168 size=88
    let mut pc: u32 = 0x82B92168;
    'dispatch: loop {
        match pc {
            0x82B92168 => {
    //   block [0x82B92168..0x82B921C0)
	// 82B92168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9216C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B92174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B9217C: 4BFFFF0D  bl 0x82b92088
	ctx.lr = 0x82B92180;
	sub_82B92088(ctx, base);
	// 82B92180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82B92184: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82B92188: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82B9218C: 99630091  stb r11, 0x91(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 82B92190: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92194: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B92198: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9219C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B921A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B921A4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B921A8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B921AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B921B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B921B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B921B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B921BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B921C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B921C0 size=188
    let mut pc: u32 = 0x82B921C0;
    'dispatch: loop {
        match pc {
            0x82B921C0 => {
    //   block [0x82B921C0..0x82B9227C)
	// 82B921C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B921C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B921C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B921CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B921D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B921D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B921D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B921DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B921E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B921E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B921E8: 4B72E751  bl 0x822c0938
	ctx.lr = 0x82B921EC;
	sub_822C0938(ctx, base);
	// 82B921EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B921F0: 41820028  beq 0x82b92218
	if ctx.cr[0].eq {
	pc = 0x82B92218; continue 'dispatch;
	}
	// 82B921F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B921F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B921FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B92200: 392B8CD8  addi r9, r11, -0x7328
	ctx.r[9].s64 = ctx.r[11].s64 + -29480;
	// 82B92204: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B92208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B9220C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B92210: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B92214: 48000008  b 0x82b9221c
	pc = 0x82B9221C; continue 'dispatch;
	// 82B92218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B9221C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92224: 409A003C  bne cr6, 0x82b92260
	if !ctx.cr[6].eq {
	pc = 0x82B92260; continue 'dispatch;
	}
	// 82B92228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B9222C: 419A0014  beq cr6, 0x82b92240
	if ctx.cr[6].eq {
	pc = 0x82B92240; continue 'dispatch;
	}
	// 82B92230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92234: 482611F5  bl 0x82df3428
	ctx.lr = 0x82B92238;
	sub_82DF3428(ctx, base);
	// 82B92238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B9223C: 4826019D  bl 0x82df23d8
	ctx.lr = 0x82B92240;
	sub_82DF23D8(ctx, base);
	// 82B92240: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B92244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B92248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9224C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B92250: 816BB470  lwz r11, -0x4b90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19344 as u32) ) } as u64;
	// 82B92254: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B92258: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B9225C: 4B72DDA5  bl 0x822c0000
	ctx.lr = 0x82B92260;
	sub_822C0000(ctx, base);
	// 82B92260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B92268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B9226C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92270: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B92274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B92278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92280 size=288
    let mut pc: u32 = 0x82B92280;
    'dispatch: loop {
        match pc {
            0x82B92280 => {
    //   block [0x82B92280..0x82B923A0)
	// 82B92280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92284: 48615ED9  bl 0x831a815c
	ctx.lr = 0x82B92288;
	sub_831A8130(ctx, base);
	// 82B92288: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B9228C: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82B92290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B92294: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82B92298: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B9229C: 4099000C  ble cr6, 0x82b922a8
	if !ctx.cr[6].gt {
	pc = 0x82B922A8; continue 'dispatch;
	}
	// 82B922A0: 48025A81  bl 0x82bb7d20
	ctx.lr = 0x82B922A4;
	sub_82BB7D20(ctx, base);
	// 82B922A4: 480000F4  b 0x82b92398
	pc = 0x82B92398; continue 'dispatch;
	// 82B922A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B922AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B922B0: 419A0010  beq cr6, 0x82b922c0
	if ctx.cr[6].eq {
	pc = 0x82B922C0; continue 'dispatch;
	}
	// 82B922B4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B922B8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B922BC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82B922C0: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82B922C4: 409800D4  bge cr6, 0x82b92398
	if !ctx.cr[6].lt {
	pc = 0x82B92398; continue 'dispatch;
	}
	// 82B922C8: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82B922CC: 5499103A  slwi r25, r4, 2
	ctx.r[25].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82B922D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82B922D4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82B922D8: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 82B922DC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82B922E0: 807A110C  lwz r3, 0x110c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B922E4: 4825FDE5  bl 0x82df20c8
	ctx.lr = 0x82B922E8;
	sub_82DF20C8(ctx, base);
	// 82B922E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B922EC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B922F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B922F4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82B922F8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B922FC: 419A002C  beq cr6, 0x82b92328
	if ctx.cr[6].eq {
	pc = 0x82B92328; continue 'dispatch;
	}
	// 82B92300: 7F7C5850  subf r27, r28, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82B92304: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82B92308: 419A0010  beq cr6, 0x82b92318
	if ctx.cr[6].eq {
	pc = 0x82B92318; continue 'dispatch;
	}
	// 82B9230C: 7C9BF214  add r4, r27, r30
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 82B92310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92314: 482618ED  bl 0x82df3c00
	ctx.lr = 0x82B92318;
	sub_82DF3C00(ctx, base);
	// 82B92318: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82B9231C: 7D7BF214  add r11, r27, r30
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 82B92320: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B92324: 409AFFE0  bne cr6, 0x82b92304
	if !ctx.cr[6].eq {
	pc = 0x82B92304; continue 'dispatch;
	}
	// 82B92328: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9232C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92330: 409A000C  bne cr6, 0x82b9233c
	if !ctx.cr[6].eq {
	pc = 0x82B9233C; continue 'dispatch;
	}
	// 82B92334: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82B92338: 48000010  b 0x82b92348
	pc = 0x82B92348; continue 'dispatch;
	// 82B9233C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92340: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82B92344: 7D5B1670  srawi r27, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82B92348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B9234C: 419A0034  beq cr6, 0x82b92380
	if ctx.cr[6].eq {
	pc = 0x82B92380; continue 'dispatch;
	}
	// 82B92350: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92354: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82B92358: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B9235C: 419A0018  beq cr6, 0x82b92374
	if ctx.cr[6].eq {
	pc = 0x82B92374; continue 'dispatch;
	}
	// 82B92360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92364: 482610C5  bl 0x82df3428
	ctx.lr = 0x82B92368;
	sub_82DF3428(ctx, base);
	// 82B92368: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82B9236C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82B92370: 409AFFF0  bne cr6, 0x82b92360
	if !ctx.cr[6].eq {
	pc = 0x82B92360; continue 'dispatch;
	}
	// 82B92374: 807A110C  lwz r3, 0x110c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B92378: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9237C: 4825FE0D  bl 0x82df2188
	ctx.lr = 0x82B92380;
	sub_82DF2188(ctx, base);
	// 82B92380: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82B92384: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B92388: 7D59E214  add r10, r25, r28
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[28].u64;
	// 82B9238C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82B92390: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82B92394: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B92398: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B9239C: 48615E10  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B923A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B923A0 size=96
    let mut pc: u32 = 0x82B923A0;
    'dispatch: loop {
        match pc {
            0x82B923A0 => {
    //   block [0x82B923A0..0x82B92400)
	// 82B923A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B923A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B923A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B923AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B923B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B923B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B923B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B923BC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B923C0: 48261069  bl 0x82df3428
	ctx.lr = 0x82B923C4;
	sub_82DF3428(ctx, base);
	// 82B923C4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B923C8: 48261061  bl 0x82df3428
	ctx.lr = 0x82B923CC;
	sub_82DF3428(ctx, base);
	// 82B923CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B923D0: 4B840019  bl 0x823d23e8
	ctx.lr = 0x82B923D4;
	sub_823D23E8(ctx, base);
	// 82B923D4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B923D8: 4182000C  beq 0x82b923e4
	if ctx.cr[0].eq {
	pc = 0x82B923E4; continue 'dispatch;
	}
	// 82B923DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B923E0: 4825FFF9  bl 0x82df23d8
	ctx.lr = 0x82B923E4;
	sub_82DF23D8(ctx, base);
	// 82B923E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B923E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B923EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B923F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B923F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B923F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B923FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92400 size=144
    let mut pc: u32 = 0x82B92400;
    'dispatch: loop {
        match pc {
            0x82B92400 => {
    //   block [0x82B92400..0x82B92490)
	// 82B92400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B9240C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B92410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B92418: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B9241C: 4BE6016D  bl 0x829f2588
	ctx.lr = 0x82B92420;
	sub_829F2588(ctx, base);
	// 82B92420: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B92424: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82B92428: 4BE60161  bl 0x829f2588
	ctx.lr = 0x82B9242C;
	sub_829F2588(ctx, base);
	// 82B9242C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82B92430: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82B92434: 4BE60155  bl 0x829f2588
	ctx.lr = 0x82B92438;
	sub_829F2588(ctx, base);
	// 82B92438: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82B9243C: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 82B92440: 4BE60149  bl 0x829f2588
	ctx.lr = 0x82B92444;
	sub_829F2588(ctx, base);
	// 82B92444: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82B92448: 389E0040  addi r4, r30, 0x40
	ctx.r[4].s64 = ctx.r[30].s64 + 64;
	// 82B9244C: 4B9B8B55  bl 0x8254afa0
	ctx.lr = 0x82B92450;
	sub_8254AFA0(ctx, base);
	// 82B92450: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82B92454: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82B92458: 4B9B8B49  bl 0x8254afa0
	ctx.lr = 0x82B9245C;
	sub_8254AFA0(ctx, base);
	// 82B9245C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82B92460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92464: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82B92468: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B9246C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B92470: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B92474: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82B92478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B9247C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B92488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B9248C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92490 size=184
    let mut pc: u32 = 0x82B92490;
    'dispatch: loop {
        match pc {
            0x82B92490 => {
    //   block [0x82B92490..0x82B92548)
	// 82B92490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B9249C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B924A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B924A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B924A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B924AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82B924B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B924B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B924B8: 4B72E481  bl 0x822c0938
	ctx.lr = 0x82B924BC;
	sub_822C0938(ctx, base);
	// 82B924BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82B924C0: 41820028  beq 0x82b924e8
	if ctx.cr[0].eq {
	pc = 0x82B924E8; continue 'dispatch;
	}
	// 82B924C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82B924C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82B924CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82B924D0: 392B8CC4  addi r9, r11, -0x733c
	ctx.r[9].s64 = ctx.r[11].s64 + -29500;
	// 82B924D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B924D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B924DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82B924E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B924E4: 48000008  b 0x82b924ec
	pc = 0x82B924EC; continue 'dispatch;
	// 82B924E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B924EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B924F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B924F4: 409A0038  bne cr6, 0x82b9252c
	if !ctx.cr[6].eq {
	pc = 0x82B9252C; continue 'dispatch;
	}
	// 82B924F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82B924FC: 419A0010  beq cr6, 0x82b9250c
	if ctx.cr[6].eq {
	pc = 0x82B9250C; continue 'dispatch;
	}
	// 82B92500: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B92504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92508: 4BFFFE99  bl 0x82b923a0
	ctx.lr = 0x82B9250C;
	sub_82B923A0(ctx, base);
	// 82B9250C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82B92510: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B92514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92518: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82B9251C: 816BB470  lwz r11, -0x4b90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19344 as u32) ) } as u64;
	// 82B92520: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82B92524: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82B92528: 4B72DAD9  bl 0x822c0000
	ctx.lr = 0x82B9252C;
	sub_822C0000(ctx, base);
	// 82B9252C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92530: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B92534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B9253C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B92540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B92544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B92548 size=12
    let mut pc: u32 = 0x82B92548;
    'dispatch: loop {
        match pc {
            0x82B92548 => {
    //   block [0x82B92548..0x82B92554)
	// 82B92548: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82B9254C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82B92550: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92554(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B92554 size=8
    let mut pc: u32 = 0x82B92554;
    'dispatch: loop {
        match pc {
            0x82B92554 => {
    //   block [0x82B92554..0x82B9255C)
	// 82B92554: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B92558: 4BFFFE48  b 0x82b923a0
	sub_82B923A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B9255C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82B9255C size=4
    let mut pc: u32 = 0x82B9255C;
    'dispatch: loop {
        match pc {
            0x82B9255C => {
    //   block [0x82B9255C..0x82B92560)
	// 82B9255C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92560 size=76
    let mut pc: u32 = 0x82B92560;
    'dispatch: loop {
        match pc {
            0x82B92560 => {
    //   block [0x82B92560..0x82B925AC)
	// 82B92560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B9256C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B92574: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B92578: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B9257C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B92580: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B92584: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82B92588: 48260B69  bl 0x82df30f0
	ctx.lr = 0x82B9258C;
	sub_82DF30F0(ctx, base);
	// 82B9258C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B92590: 48260B61  bl 0x82df30f0
	ctx.lr = 0x82B92594;
	sub_82DF30F0(ctx, base);
	// 82B92594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92598: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B9259C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B925A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B925A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B925A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B925B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B925B0 size=144
    let mut pc: u32 = 0x82B925B0;
    'dispatch: loop {
        match pc {
            0x82B925B0 => {
    //   block [0x82B925B0..0x82B92640)
	// 82B925B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B925B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B925B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B925BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B925C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B925C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B925C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B925CC: 4B734AED  bl 0x822c70b8
	ctx.lr = 0x82B925D0;
	sub_822C70B8(ctx, base);
	// 82B925D0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B925D4: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82B925D8: 4B734AE1  bl 0x822c70b8
	ctx.lr = 0x82B925DC;
	sub_822C70B8(ctx, base);
	// 82B925DC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82B925E0: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82B925E4: 4B734AD5  bl 0x822c70b8
	ctx.lr = 0x82B925E8;
	sub_822C70B8(ctx, base);
	// 82B925E8: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82B925EC: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 82B925F0: 4B734AC9  bl 0x822c70b8
	ctx.lr = 0x82B925F4;
	sub_822C70B8(ctx, base);
	// 82B925F4: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82B925F8: 389E0040  addi r4, r30, 0x40
	ctx.r[4].s64 = ctx.r[30].s64 + 64;
	// 82B925FC: 4B9B845D  bl 0x8254aa58
	ctx.lr = 0x82B92600;
	sub_8254AA58(ctx, base);
	// 82B92600: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82B92604: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82B92608: 4B9B8451  bl 0x8254aa58
	ctx.lr = 0x82B9260C;
	sub_8254AA58(ctx, base);
	// 82B9260C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82B92610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92614: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82B92618: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82B9261C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82B92620: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82B92624: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82B92628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B9262C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92634: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B92638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B9263C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92640 size=84
    let mut pc: u32 = 0x82B92640;
    'dispatch: loop {
        match pc {
            0x82B92640 => {
    //   block [0x82B92640..0x82B92694)
	// 82B92640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B92648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B9264C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B92650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B92658: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82B9265C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B92660: 4B9E8351  bl 0x8257a9b0
	ctx.lr = 0x82B92664;
	sub_8257A9B0(ctx, base);
	// 82B92664: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B92668: 4B83FD81  bl 0x823d23e8
	ctx.lr = 0x82B9266C;
	sub_823D23E8(ctx, base);
	// 82B9266C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92670: 48260DB9  bl 0x82df3428
	ctx.lr = 0x82B92674;
	sub_82DF3428(ctx, base);
	// 82B92674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92678: 48260DB1  bl 0x82df3428
	ctx.lr = 0x82B9267C;
	sub_82DF3428(ctx, base);
	// 82B9267C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B92680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92688: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B9268C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B92690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92698 size=84
    let mut pc: u32 = 0x82B92698;
    'dispatch: loop {
        match pc {
            0x82B92698 => {
    //   block [0x82B92698..0x82B926EC)
	// 82B92698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9269C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B926A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B926A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B926A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B926AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B926B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B926B4: 4826154D  bl 0x82df3c00
	ctx.lr = 0x82B926B8;
	sub_82DF3C00(ctx, base);
	// 82B926B8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B926BC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82B926C0: 4B9B88E1  bl 0x8254afa0
	ctx.lr = 0x82B926C4;
	sub_8254AFA0(ctx, base);
	// 82B926C4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B926C8: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 82B926CC: 4BFFFD35  bl 0x82b92400
	ctx.lr = 0x82B926D0;
	sub_82B92400(ctx, base);
	// 82B926D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B926D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B926D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B926DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B926E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B926E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B926E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B926F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B926F0 size=84
    let mut pc: u32 = 0x82B926F0;
    'dispatch: loop {
        match pc {
            0x82B926F0 => {
    //   block [0x82B926F0..0x82B92744)
	// 82B926F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B926F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B926F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82B926FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B92700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B92708: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B9270C: 482614C5  bl 0x82df3bd0
	ctx.lr = 0x82B92710;
	sub_82DF3BD0(ctx, base);
	// 82B92710: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82B92714: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82B92718: 4B9B8341  bl 0x8254aa58
	ctx.lr = 0x82B9271C;
	sub_8254AA58(ctx, base);
	// 82B9271C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82B92720: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 82B92724: 4BFFFE8D  bl 0x82b925b0
	ctx.lr = 0x82B92728;
	sub_82B925B0(ctx, base);
	// 82B92728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B9272C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82B92730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B92734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B92738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82B9273C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B92740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92748 size=132
    let mut pc: u32 = 0x82B92748;
    'dispatch: loop {
        match pc {
            0x82B92748 => {
    //   block [0x82B92748..0x82B927CC)
	// 82B92748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B9274C: 48615A15  bl 0x831a8160
	ctx.lr = 0x82B92750;
	sub_831A8130(ctx, base);
	// 82B92750: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92754: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B92758: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82B9275C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B92760: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B92764: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82B92768: 38C00094  li r6, 0x94
	ctx.r[6].s64 = 148;
	// 82B9276C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B92770: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82B92774: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82B92778: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82B9277C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82B92780: 4825F949  bl 0x82df20c8
	ctx.lr = 0x82B92784;
	sub_82DF20C8(ctx, base);
	// 82B92784: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82B92788: 41820038  beq 0x82b927c0
	if ctx.cr[0].eq {
	pc = 0x82B927C0; continue 'dispatch;
	}
	// 82B9278C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82B92790: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82B92794: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B92798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B9279C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82B927A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B927A4: 4826145D  bl 0x82df3c00
	ctx.lr = 0x82B927A8;
	sub_82DF3C00(ctx, base);
	// 82B927A8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82B927AC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82B927B0: 4BFFFEE9  bl 0x82b92698
	ctx.lr = 0x82B927B4;
	sub_82B92698(ctx, base);
	// 82B927B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B927B8: 9B5F0090  stb r26, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[26].u8 ) };
	// 82B927BC: 997F0091  stb r11, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 82B927C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B927C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B927C8: 486159E8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B927D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B927D0 size=548
    let mut pc: u32 = 0x82B927D0;
    'dispatch: loop {
        match pc {
            0x82B927D0 => {
    //   block [0x82B927D0..0x82B929F4)
	// 82B927D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B927D4: 4861598D  bl 0x831a8160
	ctx.lr = 0x82B927D8;
	sub_831A8130(ctx, base);
	// 82B927D8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B927DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B927E0: 3D6001F0  lis r11, 0x1f0
	ctx.r[11].s64 = 32505856;
	// 82B927E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82B927E8: 616B7C1E  ori r11, r11, 0x7c1e
	ctx.r[11].u64 = ctx.r[11].u64 | 31774;
	// 82B927EC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B927F0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B927F4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82B927F8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82B927FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92800: 41980048  blt cr6, 0x82b92848
	if ctx.cr[6].lt {
	pc = 0x82B92848; continue 'dispatch;
	}
	// 82B92804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B92808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9280C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 82B92810: 4B7330B9  bl 0x822c58c8
	ctx.lr = 0x82B92814;
	sub_822C58C8(ctx, base);
	// 82B92814: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B92818: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B9281C: 4B732FFD  bl 0x822c5818
	ctx.lr = 0x82B92820;
	sub_822C5818(ctx, base);
	// 82B92820: 4B731A91  bl 0x822c42b0
	ctx.lr = 0x82B92824;
	sub_822C42B0(ctx, base);
	// 82B92824: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B92828: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B9282C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 82B92830: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B92834: 4B732C3D  bl 0x822c5470
	ctx.lr = 0x82B92838;
	sub_822C5470(ctx, base);
	// 82B92838: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B9283C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B92840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92844: 4B73249D  bl 0x822c4ce0
	ctx.lr = 0x82B92848;
	sub_822C4CE0(ctx, base);
	// 82B92848: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9284C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82B92850: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82B92854: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82B92858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B9285C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92860: 4BFFFEE9  bl 0x82b92748
	ctx.lr = 0x82B92864;
	sub_82B92748(ctx, base);
	// 82B92864: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92868: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9286C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B92870: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82B92874: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92878: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B9287C: 409A0018  bne cr6, 0x82b92894
	if !ctx.cr[6].eq {
	pc = 0x82B92894; continue 'dispatch;
	}
	// 82B92880: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B92884: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92888: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B9288C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92890: 4800003C  b 0x82b928cc
	pc = 0x82B928CC; continue 'dispatch;
	// 82B92894: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92898: 41820020  beq 0x82b928b8
	if ctx.cr[0].eq {
	pc = 0x82B928B8; continue 'dispatch;
	}
	// 82B9289C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B928A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B928A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B928A8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B928AC: 409A0024  bne cr6, 0x82b928d0
	if !ctx.cr[6].eq {
	pc = 0x82B928D0; continue 'dispatch;
	}
	// 82B928B0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B928B4: 4800001C  b 0x82b928d0
	pc = 0x82B928D0; continue 'dispatch;
	// 82B928B8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B928BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B928C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B928C4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B928C8: 409A0008  bne cr6, 0x82b928d0
	if !ctx.cr[6].eq {
	pc = 0x82B928D0; continue 'dispatch;
	}
	// 82B928CC: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B928D0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B928D4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82B928D8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82B928DC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82B928E0: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B928E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B928E8: 409A00F0  bne cr6, 0x82b929d8
	if !ctx.cr[6].eq {
	pc = 0x82B929D8; continue 'dispatch;
	}
	// 82B928EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82B928F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B928F4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B928F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B928FC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82B92900: 409A0054  bne cr6, 0x82b92954
	if !ctx.cr[6].eq {
	pc = 0x82B92954; continue 'dispatch;
	}
	// 82B92904: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92908: 892A0090  lbz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B9290C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B92910: 419A0054  beq cr6, 0x82b92964
	if ctx.cr[6].eq {
	pc = 0x82B92964; continue 'dispatch;
	}
	// 82B92914: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92918: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B9291C: 409A0010  bne cr6, 0x82b9292c
	if !ctx.cr[6].eq {
	pc = 0x82B9292C; continue 'dispatch;
	}
	// 82B92920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92924: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B92928: 4BFFF649  bl 0x82b91f70
	ctx.lr = 0x82B9292C;
	sub_82B91F70(ctx, base);
	// 82B9292C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92934: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92938: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9293C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92940: 9B6B0090  stb r27, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[27].u8 ) };
	// 82B92944: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92948: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9294C: 4BFFF45D  bl 0x82b91da8
	ctx.lr = 0x82B92950;
	sub_82B91DA8(ctx, base);
	// 82B92950: 48000074  b 0x82b929c4
	pc = 0x82B929C4; continue 'dispatch;
	// 82B92954: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92958: 892A0090  lbz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B9295C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82B92960: 409A0028  bne cr6, 0x82b92988
	if !ctx.cr[6].eq {
	pc = 0x82B92988; continue 'dispatch;
	}
	// 82B92964: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92968: 9BA90090  stb r29, 0x90(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B9296C: 9BAA0090  stb r29, 0x90(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92970: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92974: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92978: 9B6A0090  stb r27, 0x90(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[27].u8 ) };
	// 82B9297C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92980: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92984: 48000040  b 0x82b929c4
	pc = 0x82B929C4; continue 'dispatch;
	// 82B92988: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B9298C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92990: 409A0010  bne cr6, 0x82b929a0
	if !ctx.cr[6].eq {
	pc = 0x82B929A0; continue 'dispatch;
	}
	// 82B92994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92998: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B9299C: 4BFFF40D  bl 0x82b91da8
	ctx.lr = 0x82B929A0;
	sub_82B91DA8(ctx, base);
	// 82B929A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B929A8: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B929AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929B4: 9B6B0090  stb r27, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[27].u8 ) };
	// 82B929B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929BC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929C0: 4BFFF5B1  bl 0x82b91f70
	ctx.lr = 0x82B929C4;
	sub_82B91F70(ctx, base);
	// 82B929C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82B929CC: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B929D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B929D4: 419AFF1C  beq cr6, 0x82b928f0
	if ctx.cr[6].eq {
	pc = 0x82B928F0; continue 'dispatch;
	}
	// 82B929D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B929E0: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B929E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B929E8: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B929EC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82B929F0: 486157C0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B929F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B929F8 size=236
    let mut pc: u32 = 0x82B929F8;
    'dispatch: loop {
        match pc {
            0x82B929F8 => {
    //   block [0x82B929F8..0x82B92AE4)
	// 82B929F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B929FC: 48615761  bl 0x831a815c
	ctx.lr = 0x82B92A00;
	sub_831A8130(ctx, base);
	// 82B92A00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92A04: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82B92A08: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82B92A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B92A10: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82B92A14: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82B92A18: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92A1C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92A20: 4800002C  b 0x82b92a4c
	pc = 0x82B92A4C; continue 'dispatch;
	// 82B92A24: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82B92A28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82B92A2C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82B92A30: 48260809  bl 0x82df3238
	ctx.lr = 0x82B92A34;
	sub_82DF3238(ctx, base);
	// 82B92A34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82B92A38: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92A3C: 4182000C  beq 0x82b92a48
	if ctx.cr[0].eq {
	pc = 0x82B92A48; continue 'dispatch;
	}
	// 82B92A40: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92A44: 48000008  b 0x82b92a4c
	pc = 0x82B92A4C; continue 'dispatch;
	// 82B92A48: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92A4C: 897D0091  lbz r11, 0x91(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92A54: 419AFFD0  beq cr6, 0x82b92a24
	if ctx.cr[6].eq {
	pc = 0x82B92A24; continue 'dispatch;
	}
	// 82B92A58: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82B92A5C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92A60: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82B92A64: 41820048  beq 0x82b92aac
	if ctx.cr[0].eq {
	pc = 0x82B92AAC; continue 'dispatch;
	}
	// 82B92A68: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92A6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92A70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92A74: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92A78: 409A002C  bne cr6, 0x82b92aa4
	if !ctx.cr[6].eq {
	pc = 0x82B92AA4; continue 'dispatch;
	}
	// 82B92A7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B92A80: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B92A84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82B92A88: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82B92A8C: 4BFFFD45  bl 0x82b927d0
	ctx.lr = 0x82B92A90;
	sub_82B927D0(ctx, base);
	// 82B92A90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B92A94: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 82B92A98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92A9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92AA0: 48000038  b 0x82b92ad8
	pc = 0x82B92AD8; continue 'dispatch;
	// 82B92AA4: 4BFFF36D  bl 0x82b91e10
	ctx.lr = 0x82B92AA8;
	sub_82B91E10(ctx, base);
	// 82B92AA8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B92AAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B92AB0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82B92AB4: 48260785  bl 0x82df3238
	ctx.lr = 0x82B92AB8;
	sub_82DF3238(ctx, base);
	// 82B92AB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92ABC: 41820010  beq 0x82b92acc
	if ctx.cr[0].eq {
	pc = 0x82B92ACC; continue 'dispatch;
	}
	// 82B92AC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82B92AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92AC8: 4BFFFFB8  b 0x82b92a80
	pc = 0x82B92A80; continue 'dispatch;
	// 82B92ACC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B92AD0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82B92AD4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82B92AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92ADC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82B92AE0: 486156CC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92AE8 size=1024
    let mut pc: u32 = 0x82B92AE8;
    'dispatch: loop {
        match pc {
            0x82B92AE8 => {
    //   block [0x82B92AE8..0x82B92EE8)
	// 82B92AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92AEC: 4861566D  bl 0x831a8158
	ctx.lr = 0x82B92AF0;
	sub_831A8130(ctx, base);
	// 82B92AF0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92AF4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82B92AF8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82B92AFC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82B92B00: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 82B92B04: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92B08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92B0C: 419A0048  beq cr6, 0x82b92b54
	if ctx.cr[6].eq {
	pc = 0x82B92B54; continue 'dispatch;
	}
	// 82B92B10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B92B14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92B18: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 82B92B1C: 4B732DAD  bl 0x822c58c8
	ctx.lr = 0x82B92B20;
	sub_822C58C8(ctx, base);
	// 82B92B20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82B92B24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B92B28: 4B737389  bl 0x822c9eb0
	ctx.lr = 0x82B92B2C;
	sub_822C9EB0(ctx, base);
	// 82B92B2C: 4B731785  bl 0x822c42b0
	ctx.lr = 0x82B92B30;
	sub_822C42B0(ctx, base);
	// 82B92B30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82B92B34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82B92B38: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 82B92B3C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B92B40: 4B732931  bl 0x822c5470
	ctx.lr = 0x82B92B44;
	sub_822C5470(ctx, base);
	// 82B92B44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B92B48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82B92B4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B92B50: 4B732191  bl 0x822c4ce0
	ctx.lr = 0x82B92B54;
	sub_822C4CE0(ctx, base);
	// 82B92B54: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 82B92B58: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82B92B5C: 4BFFF39D  bl 0x82b91ef8
	ctx.lr = 0x82B92B60;
	sub_82B91EF8(ctx, base);
	// 82B92B60: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92B64: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92B6C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82B92B70: 419A000C  beq cr6, 0x82b92b7c
	if ctx.cr[6].eq {
	pc = 0x82B92B7C; continue 'dispatch;
	}
	// 82B92B74: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92B78: 48000028  b 0x82b92ba0
	pc = 0x82B92BA0; continue 'dispatch;
	// 82B92B7C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92B80: 894A0091  lbz r10, 0x91(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92B88: 419A000C  beq cr6, 0x82b92b94
	if ctx.cr[6].eq {
	pc = 0x82B92B94; continue 'dispatch;
	}
	// 82B92B8C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82B92B90: 48000010  b 0x82b92ba0
	pc = 0x82B92BA0; continue 'dispatch;
	// 82B92B94: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92B98: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92B9C: 409A00DC  bne cr6, 0x82b92c78
	if !ctx.cr[6].eq {
	pc = 0x82B92C78; continue 'dispatch;
	}
	// 82B92BA0: 897C0091  lbz r11, 0x91(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92BA4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92BAC: 409A0008  bne cr6, 0x82b92bb4
	if !ctx.cr[6].eq {
	pc = 0x82B92BB4; continue 'dispatch;
	}
	// 82B92BB0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B92BB4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92BB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92BBC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92BC0: 409A000C  bne cr6, 0x82b92bcc
	if !ctx.cr[6].eq {
	pc = 0x82B92BCC; continue 'dispatch;
	}
	// 82B92BC4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82B92BC8: 4800001C  b 0x82b92be4
	pc = 0x82B92BE4; continue 'dispatch;
	// 82B92BCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92BD0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92BD4: 409A000C  bne cr6, 0x82b92be0
	if !ctx.cr[6].eq {
	pc = 0x82B92BE0; continue 'dispatch;
	}
	// 82B92BD8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B92BDC: 48000008  b 0x82b92be4
	pc = 0x82B92BE4; continue 'dispatch;
	// 82B92BE0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82B92BE4: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92BE8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92BEC: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92BF0: 409A003C  bne cr6, 0x82b92c2c
	if !ctx.cr[6].eq {
	pc = 0x82B92C2C; continue 'dispatch;
	}
	// 82B92BF4: 897C0091  lbz r11, 0x91(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92BF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92BFC: 419A000C  beq cr6, 0x82b92c08
	if ctx.cr[6].eq {
	pc = 0x82B92C08; continue 'dispatch;
	}
	// 82B92C00: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82B92C04: 48000024  b 0x82b92c28
	pc = 0x82B92C28; continue 'dispatch;
	// 82B92C08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92C0C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82B92C10: 4800000C  b 0x82b92c1c
	pc = 0x82B92C1C; continue 'dispatch;
	// 82B92C14: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B92C18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92C1C: 890B0091  lbz r8, 0x91(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92C20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82B92C24: 419AFFF0  beq cr6, 0x82b92c14
	if ctx.cr[6].eq {
	pc = 0x82B92C14; continue 'dispatch;
	}
	// 82B92C28: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B92C2C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92C30: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92C34: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92C38: 409A00D4  bne cr6, 0x82b92d0c
	if !ctx.cr[6].eq {
	pc = 0x82B92D0C; continue 'dispatch;
	}
	// 82B92C3C: 897C0091  lbz r11, 0x91(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92C44: 419A000C  beq cr6, 0x82b92c50
	if ctx.cr[6].eq {
	pc = 0x82B92C50; continue 'dispatch;
	}
	// 82B92C48: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82B92C4C: 48000024  b 0x82b92c70
	pc = 0x82B92C70; continue 'dispatch;
	// 82B92C50: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92C54: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82B92C58: 4800000C  b 0x82b92c64
	pc = 0x82B92C64; continue 'dispatch;
	// 82B92C5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82B92C60: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92C64: 890B0091  lbz r8, 0x91(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92C68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82B92C6C: 419AFFF0  beq cr6, 0x82b92c5c
	if ctx.cr[6].eq {
	pc = 0x82B92C5C; continue 'dispatch;
	}
	// 82B92C70: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82B92C74: 48000098  b 0x82b92d0c
	pc = 0x82B92D0C; continue 'dispatch;
	// 82B92C78: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B92C7C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92C80: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B92C84: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92C88: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92C8C: 409A000C  bne cr6, 0x82b92c98
	if !ctx.cr[6].eq {
	pc = 0x82B92C98; continue 'dispatch;
	}
	// 82B92C90: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82B92C94: 4800002C  b 0x82b92cc0
	pc = 0x82B92CC0; continue 'dispatch;
	// 82B92C98: 897C0091  lbz r11, 0x91(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92C9C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92CA4: 409A0008  bne cr6, 0x82b92cac
	if !ctx.cr[6].eq {
	pc = 0x82B92CAC; continue 'dispatch;
	}
	// 82B92CA8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82B92CAC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82B92CB0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92CB4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B92CB8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92CBC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B92CC0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92CC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92CC8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92CCC: 409A000C  bne cr6, 0x82b92cd8
	if !ctx.cr[6].eq {
	pc = 0x82B92CD8; continue 'dispatch;
	}
	// 82B92CD0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82B92CD4: 48000020  b 0x82b92cf4
	pc = 0x82B92CF4; continue 'dispatch;
	// 82B92CD8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92CDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92CE0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82B92CE4: 409A000C  bne cr6, 0x82b92cf0
	if !ctx.cr[6].eq {
	pc = 0x82B92CF0; continue 'dispatch;
	}
	// 82B92CE8: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82B92CEC: 48000008  b 0x82b92cf4
	pc = 0x82B92CF4; continue 'dispatch;
	// 82B92CF0: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82B92CF4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92CF8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82B92CFC: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D00: 89590090  lbz r10, 0x90(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D04: 99790090  stb r11, 0x90(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 82B92D08: 995B0090  stb r10, 0x90(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82B92D0C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D10: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82B92D14: 409A0198  bne cr6, 0x82b92eac
	if !ctx.cr[6].eq {
	pc = 0x82B92EAC; continue 'dispatch;
	}
	// 82B92D18: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92D1C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82B92D20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92D24: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92D28: 419A0180  beq cr6, 0x82b92ea8
	if ctx.cr[6].eq {
	pc = 0x82B92EA8; continue 'dispatch;
	}
	// 82B92D2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82B92D30: 897C0090  lbz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82B92D38: 409A0170  bne cr6, 0x82b92ea8
	if !ctx.cr[6].eq {
	pc = 0x82B92EA8; continue 'dispatch;
	}
	// 82B92D3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92D40: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92D44: 409A00A8  bne cr6, 0x82b92dec
	if !ctx.cr[6].eq {
	pc = 0x82B92DEC; continue 'dispatch;
	}
	// 82B92D48: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92D4C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92D54: 409A001C  bne cr6, 0x82b92d70
	if !ctx.cr[6].eq {
	pc = 0x82B92D70; continue 'dispatch;
	}
	// 82B92D58: 9BCB0090  stb r30, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92D5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B92D60: 9BBF0090  stb r29, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92D64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92D68: 4BFFF209  bl 0x82b91f70
	ctx.lr = 0x82B92D6C;
	sub_82B91F70(ctx, base);
	// 82B92D6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92D70: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92D74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92D78: 409A00C8  bne cr6, 0x82b92e40
	if !ctx.cr[6].eq {
	pc = 0x82B92E40; continue 'dispatch;
	}
	// 82B92D7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92D80: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D84: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92D88: 409A0014  bne cr6, 0x82b92d9c
	if !ctx.cr[6].eq {
	pc = 0x82B92D9C; continue 'dispatch;
	}
	// 82B92D8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92D90: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92D94: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92D98: 419A00A4  beq cr6, 0x82b92e3c
	if ctx.cr[6].eq {
	pc = 0x82B92E3C; continue 'dispatch;
	}
	// 82B92D9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92DA0: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92DA4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92DA8: 409A0020  bne cr6, 0x82b92dc8
	if !ctx.cr[6].eq {
	pc = 0x82B92DC8; continue 'dispatch;
	}
	// 82B92DAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92DB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82B92DB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92DB8: 9BCA0090  stb r30, 0x90(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92DBC: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92DC0: 4BFFEFE9  bl 0x82b91da8
	ctx.lr = 0x82B92DC4;
	sub_82B91DA8(ctx, base);
	// 82B92DC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92DC8: 895F0090  lbz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92DCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B92DD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92DD4: 994B0090  stb r10, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82B92DD8: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92DDC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92DE0: 9BCB0090  stb r30, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92DE4: 4BFFF18D  bl 0x82b91f70
	ctx.lr = 0x82B92DE8;
	sub_82B91F70(ctx, base);
	// 82B92DE8: 480000C0  b 0x82b92ea8
	pc = 0x82B92EA8; continue 'dispatch;
	// 82B92DEC: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92DF4: 409A001C  bne cr6, 0x82b92e10
	if !ctx.cr[6].eq {
	pc = 0x82B92E10; continue 'dispatch;
	}
	// 82B92DF8: 9BCB0090  stb r30, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B92E00: 9BBF0090  stb r29, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92E04: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92E08: 4BFFEFA1  bl 0x82b91da8
	ctx.lr = 0x82B92E0C;
	sub_82B91DA8(ctx, base);
	// 82B92E0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92E10: 894B0091  lbz r10, 0x91(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92E14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82B92E18: 409A0028  bne cr6, 0x82b92e40
	if !ctx.cr[6].eq {
	pc = 0x82B92E40; continue 'dispatch;
	}
	// 82B92E1C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92E20: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92E24: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92E28: 409A0034  bne cr6, 0x82b92e5c
	if !ctx.cr[6].eq {
	pc = 0x82B92E5C; continue 'dispatch;
	}
	// 82B92E2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92E30: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92E34: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92E38: 409A0024  bne cr6, 0x82b92e5c
	if !ctx.cr[6].eq {
	pc = 0x82B92E5C; continue 'dispatch;
	}
	// 82B92E3C: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92E40: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92E44: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82B92E48: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92E4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92E50: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92E54: 409AFEDC  bne cr6, 0x82b92d30
	if !ctx.cr[6].eq {
	pc = 0x82B92D30; continue 'dispatch;
	}
	// 82B92E58: 48000050  b 0x82b92ea8
	pc = 0x82B92EA8; continue 'dispatch;
	// 82B92E5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92E60: 894A0090  lbz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92E64: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82B92E68: 409A0020  bne cr6, 0x82b92e88
	if !ctx.cr[6].eq {
	pc = 0x82B92E88; continue 'dispatch;
	}
	// 82B92E6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92E70: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82B92E74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92E78: 9BCA0090  stb r30, 0x90(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92E7C: 9BAB0090  stb r29, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[29].u8 ) };
	// 82B92E80: 4BFFF0F1  bl 0x82b91f70
	ctx.lr = 0x82B92E84;
	sub_82B91F70(ctx, base);
	// 82B92E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92E88: 895F0090  lbz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82B92E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B92E90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B92E94: 994B0090  stb r10, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82B92E98: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92E9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92EA0: 9BCB0090  stb r30, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92EA4: 4BFFEF05  bl 0x82b91da8
	ctx.lr = 0x82B92EA8;
	sub_82B91DA8(ctx, base);
	// 82B92EA8: 9BDC0090  stb r30, 0x90(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82B92EAC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82B92EB0: 4BFFF791  bl 0x82b92640
	ctx.lr = 0x82B92EB4;
	sub_82B92640(ctx, base);
	// 82B92EB4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82B92EB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82B92EBC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B92EC0: 4825F2C9  bl 0x82df2188
	ctx.lr = 0x82B92EC4;
	sub_82DF2188(ctx, base);
	// 82B92EC4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92ECC: 419A000C  beq cr6, 0x82b92ed8
	if ctx.cr[6].eq {
	pc = 0x82B92ED8; continue 'dispatch;
	}
	// 82B92ED0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82B92ED4: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B92ED8: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82B92EDC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82B92EE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82B92EE4: 486152C4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92EE8 size=100
    let mut pc: u32 = 0x82B92EE8;
    'dispatch: loop {
        match pc {
            0x82B92EE8 => {
    //   block [0x82B92EE8..0x82B92F4C)
	// 82B92EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92EEC: 4861527D  bl 0x831a8168
	ctx.lr = 0x82B92EF0;
	sub_831A8130(ctx, base);
	// 82B92EF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92EF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B92EF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B92EFC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82B92F00: 897E0091  lbz r11, 0x91(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92F08: 409A003C  bne cr6, 0x82b92f44
	if !ctx.cr[6].eq {
	pc = 0x82B92F44; continue 'dispatch;
	}
	// 82B92F0C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82B92F10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B92F14: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92F18: 4BFFFFD1  bl 0x82b92ee8
	ctx.lr = 0x82B92F1C;
	sub_82B92EE8(ctx, base);
	// 82B92F1C: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82B92F20: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92F24: 4BFFF71D  bl 0x82b92640
	ctx.lr = 0x82B92F28;
	sub_82B92640(ctx, base);
	// 82B92F28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B92F2C: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82B92F30: 4825F259  bl 0x82df2188
	ctx.lr = 0x82B92F34;
	sub_82DF2188(ctx, base);
	// 82B92F34: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B92F38: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82B92F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92F40: 419AFFD0  beq cr6, 0x82b92f10
	if ctx.cr[6].eq {
	pc = 0x82B92F10; continue 'dispatch;
	}
	// 82B92F44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B92F48: 48615270  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B92F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B92F50 size=424
    let mut pc: u32 = 0x82B92F50;
    'dispatch: loop {
        match pc {
            0x82B92F50 => {
    //   block [0x82B92F50..0x82B930F8)
	// 82B92F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B92F54: 4861520D  bl 0x831a8160
	ctx.lr = 0x82B92F58;
	sub_831A8130(ctx, base);
	// 82B92F58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B92F5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82B92F60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82B92F64: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B92F68: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82B92F6C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B92F74: 409A0020  bne cr6, 0x82b92f94
	if !ctx.cr[6].eq {
	pc = 0x82B92F94; continue 'dispatch;
	}
	// 82B92F78: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92F7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B92F80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B92F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B92F88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B92F8C: 4BFFF845  bl 0x82b927d0
	ctx.lr = 0x82B92F90;
	sub_82B927D0(ctx, base);
	// 82B92F90: 4800015C  b 0x82b930ec
	pc = 0x82B930EC; continue 'dispatch;
	// 82B92F94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92F98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B92F9C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B92FA0: 409A0020  bne cr6, 0x82b92fc0
	if !ctx.cr[6].eq {
	pc = 0x82B92FC0; continue 'dispatch;
	}
	// 82B92FA4: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 82B92FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92FAC: 4826028D  bl 0x82df3238
	ctx.lr = 0x82B92FB0;
	sub_82DF3238(ctx, base);
	// 82B92FB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92FB4: 4182011C  beq 0x82b930d0
	if ctx.cr[0].eq {
	pc = 0x82B930D0; continue 'dispatch;
	}
	// 82B92FB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B92FBC: 4BFFFFC0  b 0x82b92f7c
	pc = 0x82B92F7C; continue 'dispatch;
	// 82B92FC0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B92FC4: 409A002C  bne cr6, 0x82b92ff0
	if !ctx.cr[6].eq {
	pc = 0x82B92FF0; continue 'dispatch;
	}
	// 82B92FC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B92FD0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82B92FD4: 48260265  bl 0x82df3238
	ctx.lr = 0x82B92FD8;
	sub_82DF3238(ctx, base);
	// 82B92FD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B92FDC: 418200F4  beq 0x82b930d0
	if ctx.cr[0].eq {
	pc = 0x82B930D0; continue 'dispatch;
	}
	// 82B92FE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B92FE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B92FE8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B92FEC: 4BFFFF94  b 0x82b92f80
	pc = 0x82B92F80; continue 'dispatch;
	// 82B92FF0: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 82B92FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B92FF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82B92FFC: 4826023D  bl 0x82df3238
	ctx.lr = 0x82B93000;
	sub_82DF3238(ctx, base);
	// 82B93000: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B93004: 4182005C  beq 0x82b93060
	if ctx.cr[0].eq {
	pc = 0x82B93060; continue 'dispatch;
	}
	// 82B93008: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82B9300C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B93010: 4BFFEE01  bl 0x82b91e10
	ctx.lr = 0x82B93014;
	sub_82B91E10(ctx, base);
	// 82B93014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B93018: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B9301C: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82B93020: 48260219  bl 0x82df3238
	ctx.lr = 0x82B93024;
	sub_82DF3238(ctx, base);
	// 82B93024: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B93028: 41820038  beq 0x82b93060
	if ctx.cr[0].eq {
	pc = 0x82B93060; continue 'dispatch;
	}
	// 82B9302C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B93030: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B93034: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B93038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B9303C: 896B0091  lbz r11, 0x91(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B93040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B93044: 419A0010  beq cr6, 0x82b93054
	if ctx.cr[6].eq {
	pc = 0x82B93054; continue 'dispatch;
	}
	// 82B93048: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B9304C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82B93050: 4BFFFF3C  b 0x82b92f8c
	pc = 0x82B92F8C; continue 'dispatch;
	// 82B93054: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B93058: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82B9305C: 4BFFFF30  b 0x82b92f8c
	pc = 0x82B92F8C; continue 'dispatch;
	// 82B93060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B93064: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82B93068: 482601D1  bl 0x82df3238
	ctx.lr = 0x82B9306C;
	sub_82DF3238(ctx, base);
	// 82B9306C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B93070: 41820060  beq 0x82b930d0
	if ctx.cr[0].eq {
	pc = 0x82B930D0; continue 'dispatch;
	}
	// 82B93074: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82B93078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B9307C: 4BFFEE7D  bl 0x82b91ef8
	ctx.lr = 0x82B93080;
	sub_82B91EF8(ctx, base);
	// 82B93080: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93084: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82B93088: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B9308C: 419A0018  beq cr6, 0x82b930a4
	if ctx.cr[6].eq {
	pc = 0x82B930A4; continue 'dispatch;
	}
	// 82B93090: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 82B93094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B93098: 482601A1  bl 0x82df3238
	ctx.lr = 0x82B9309C;
	sub_82DF3238(ctx, base);
	// 82B9309C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B930A0: 41820030  beq 0x82b930d0
	if ctx.cr[0].eq {
	pc = 0x82B930D0; continue 'dispatch;
	}
	// 82B930A4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82B930A8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82B930AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B930B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B930B4: 896B0091  lbz r11, 0x91(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(145 as u32) ) } as u64;
	// 82B930B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82B930BC: 419A000C  beq cr6, 0x82b930c8
	if ctx.cr[6].eq {
	pc = 0x82B930C8; continue 'dispatch;
	}
	// 82B930C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82B930C4: 4BFFFF88  b 0x82b9304c
	pc = 0x82B9304C; continue 'dispatch;
	// 82B930C8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82B930CC: 4BFFFF8C  b 0x82b93058
	pc = 0x82B93058; continue 'dispatch;
	// 82B930D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B930D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B930D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B930DC: 4BFFF91D  bl 0x82b929f8
	ctx.lr = 0x82B930E0;
	sub_82B929F8(ctx, base);
	// 82B930E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B930E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B930E8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B930EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B930F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82B930F4: 486150BC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B930F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B930F8 size=84
    let mut pc: u32 = 0x82B930F8;
    'dispatch: loop {
        match pc {
            0x82B930F8 => {
    //   block [0x82B930F8..0x82B9314C)
	// 82B930F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B930FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82B93100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82B93104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B93108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B9310C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93110: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93114: 4BFFFDD5  bl 0x82b92ee8
	ctx.lr = 0x82B93118;
	sub_82B92EE8(ctx, base);
	// 82B93118: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9311C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B93120: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82B93124: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B93128: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9312C: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82B93130: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93134: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82B93138: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82B9313C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82B93140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82B93144: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82B93148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B93150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B93150 size=188
    let mut pc: u32 = 0x82B93150;
    'dispatch: loop {
        match pc {
            0x82B93150 => {
    //   block [0x82B93150..0x82B9320C)
	// 82B93150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B93154: 48615019  bl 0x831a816c
	ctx.lr = 0x82B93158;
	sub_831A8130(ctx, base);
	// 82B93158: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B9315C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B93160: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82B93164: 4BFFED3D  bl 0x82b91ea0
	ctx.lr = 0x82B93168;
	sub_82B91EA0(ctx, base);
	// 82B93168: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B9316C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82B93170: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B93174: 419A0018  beq cr6, 0x82b9318c
	if ctx.cr[6].eq {
	pc = 0x82B9318C; continue 'dispatch;
	}
	// 82B93178: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82B9317C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82B93180: 482600B9  bl 0x82df3238
	ctx.lr = 0x82B93184;
	sub_82DF3238(ctx, base);
	// 82B93184: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82B93188: 41820078  beq 0x82b93200
	if ctx.cr[0].eq {
	pc = 0x82B93200; continue 'dispatch;
	}
	// 82B9318C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B93190: 4825FF61  bl 0x82df30f0
	ctx.lr = 0x82B93194;
	sub_82DF30F0(ctx, base);
	// 82B93194: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82B93198: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82B9319C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82B931A0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82B931A4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82B931A8: 4B9E7789  bl 0x8257a930
	ctx.lr = 0x82B931AC;
	sub_8257A930(ctx, base);
	// 82B931AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82B931B0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82B931B4: 48260A4D  bl 0x82df3c00
	ctx.lr = 0x82B931B8;
	sub_82DF3C00(ctx, base);
	// 82B931B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82B931BC: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 82B931C0: 4BFFF4D9  bl 0x82b92698
	ctx.lr = 0x82B931C4;
	sub_82B92698(ctx, base);
	// 82B931C4: 38C100E0  addi r6, r1, 0xe0
	ctx.r[6].s64 = ctx.r[1].s64 + 224;
	// 82B931C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82B931CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82B931D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B931D4: 4BFFFD7D  bl 0x82b92f50
	ctx.lr = 0x82B931D8;
	sub_82B92F50(ctx, base);
	// 82B931D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82B931DC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82B931E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B931E4: 4BFFF45D  bl 0x82b92640
	ctx.lr = 0x82B931E8;
	sub_82B92640(ctx, base);
	// 82B931E8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82B931EC: 4B9E77C5  bl 0x8257a9b0
	ctx.lr = 0x82B931F0;
	sub_8257A9B0(ctx, base);
	// 82B931F0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82B931F4: 4B83F1F5  bl 0x823d23e8
	ctx.lr = 0x82B931F8;
	sub_823D23E8(ctx, base);
	// 82B931F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82B931FC: 4826022D  bl 0x82df3428
	ctx.lr = 0x82B93200;
	sub_82DF3428(ctx, base);
	// 82B93200: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82B93204: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82B93208: 48614FB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82B93210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82B93210 size=132
    let mut pc: u32 = 0x82B93210;
    'dispatch: loop {
        match pc {
            0x82B93210 => {
    //   block [0x82B93210..0x82B93294)
	// 82B93210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82B93214: 48614F55  bl 0x831a8168
	ctx.lr = 0x82B93218;
	sub_831A8130(ctx, base);
	// 82B93218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82B9321C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82B93220: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82B93224: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82B93228: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82B9322C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B93234: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82B93238: 409A0044  bne cr6, 0x82b9327c
	if !ctx.cr[6].eq {
	pc = 0x82B9327C; continue 'dispatch;
	}
	// 82B9323C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82B93240: 409A003C  bne cr6, 0x82b9327c
	if !ctx.cr[6].eq {
	pc = 0x82B9327C; continue 'dispatch;
	}
	// 82B93244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82B93248: 4BFFFEB1  bl 0x82b930f8
	ctx.lr = 0x82B9324C;
	sub_82B930F8(ctx, base);
	// 82B9324C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82B93250: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82B93254: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82B93258: 48000030  b 0x82b93288
	pc = 0x82B93288; continue 'dispatch;
	// 82B9325C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82B93260: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82B93264: 4BFFEC95  bl 0x82b91ef8
	ctx.lr = 0x82B93268;
	sub_82B91EF8(ctx, base);
	// 82B93268: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82B9326C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82B93270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82B93274: 4BFFF875  bl 0x82b92ae8
	ctx.lr = 0x82B93278;
	sub_82B92AE8(ctx, base);
	// 82B93278: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82B9327C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82B93280: 409AFFDC  bne cr6, 0x82b9325c
	if !ctx.cr[6].eq {
	pc = 0x82B9325C; continue 'dispatch;
	}
	// 82B93284: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82B93288: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82B9328C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82B93290: 48614F28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


