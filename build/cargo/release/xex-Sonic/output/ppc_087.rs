pub fn sub_827E1020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1020 size=76
    let mut pc: u32 = 0x827E1020;
    'dispatch: loop {
        match pc {
            0x827E1020 => {
    //   block [0x827E1020..0x827E106C)
	// 827E1020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E102C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E1030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E1034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1038: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E103C: 4BFFFF8D  bl 0x827e0fc8
	ctx.lr = 0x827E1040;
	sub_827E0FC8(ctx, base);
	// 827E1040: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1044: 4182000C  beq 0x827e1050
	if ctx.cr[0].eq {
	pc = 0x827E1050; continue 'dispatch;
	}
	// 827E1048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E104C: 4BADF21D  bl 0x822c0268
	ctx.lr = 0x827E1050;
	sub_822C0268(ctx, base);
	// 827E1050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E1058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E105C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E1060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E1064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E1068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1070 size=52
    let mut pc: u32 = 0x827E1070;
    'dispatch: loop {
        match pc {
            0x827E1070 => {
    //   block [0x827E1070..0x827E10A4)
	// 827E1070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E107C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E1080: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E1084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1088: 4BAE8E81  bl 0x822c9f08
	ctx.lr = 0x827E108C;
	sub_822C9F08(ctx, base);
	// 827E108C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1090: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E1094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E1098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E109C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E10A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E10A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E10A8 size=52
    let mut pc: u32 = 0x827E10A8;
    'dispatch: loop {
        match pc {
            0x827E10A8 => {
    //   block [0x827E10A8..0x827E10DC)
	// 827E10A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E10AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E10B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E10B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E10B8: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E10BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E10C0: 4BAE8E49  bl 0x822c9f08
	ctx.lr = 0x827E10C4;
	sub_822C9F08(ctx, base);
	// 827E10C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E10C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E10CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E10D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E10D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E10D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E10E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E10E0 size=156
    let mut pc: u32 = 0x827E10E0;
    'dispatch: loop {
        match pc {
            0x827E10E0 => {
    //   block [0x827E10E0..0x827E117C)
	// 827E10E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E10E4: 489C7089  bl 0x831a816c
	ctx.lr = 0x827E10E8;
	sub_831A8130(ctx, base);
	// 827E10E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E10EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E10F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E10F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E10F8: 4860FA89  bl 0x82df0b80
	ctx.lr = 0x827E10FC;
	sub_82DF0B80(ctx, base);
	// 827E10FC: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 827E1100: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 827E1104: 386B5634  addi r3, r11, 0x5634
	ctx.r[3].s64 = ctx.r[11].s64 + 22068;
	// 827E1108: 83BEA0E8  lwz r29, -0x5f18(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24344 as u32) ) } as u64;
	// 827E110C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E1110: 4BBBFED9  bl 0x823a0fe8
	ctx.lr = 0x827E1114;
	sub_823A0FE8(ctx, base);
	// 827E1114: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E1118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E111C: 4BBC0015  bl 0x823a1130
	ctx.lr = 0x827E1120;
	sub_823A1130(ctx, base);
	// 827E1120: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E1124: 40820044  bne 0x827e1168
	if !ctx.cr[0].eq {
	pc = 0x827E1168; continue 'dispatch;
	}
	// 827E1128: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E112C: 419A000C  beq cr6, 0x827e1138
	if ctx.cr[6].eq {
	pc = 0x827E1138; continue 'dispatch;
	}
	// 827E1130: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 827E1134: 48000034  b 0x827e1168
	pc = 0x827E1168; continue 'dispatch;
	// 827E1138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E113C: 4BFFF735  bl 0x827e0870
	ctx.lr = 0x827E1140;
	sub_827E0870(ctx, base);
	// 827E1140: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 827E1144: 409A000C  bne cr6, 0x827e1150
	if !ctx.cr[6].eq {
	pc = 0x827E1150; continue 'dispatch;
	}
	// 827E1148: 489CAA01  bl 0x831abb48
	ctx.lr = 0x827E114C;
	sub_831ABB48(ctx, base);
	// 827E114C: 4800001C  b 0x827e1168
	pc = 0x827E1168; continue 'dispatch;
	// 827E1150: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E1154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1158: 93FEA0E8  stw r31, -0x5f18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-24344 as u32), ctx.r[31].u32 ) };
	// 827E115C: 4BBBFEFD  bl 0x823a1058
	ctx.lr = 0x827E1160;
	sub_823A1058(ctx, base);
	// 827E1160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1164: 4860FD0D  bl 0x82df0e70
	ctx.lr = 0x827E1168;
	sub_82DF0E70(ctx, base);
	// 827E1168: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E116C: 4860FA5D  bl 0x82df0bc8
	ctx.lr = 0x827E1170;
	sub_82DF0BC8(ctx, base);
	// 827E1170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1174: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E1178: 489C7044  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1180 size=124
    let mut pc: u32 = 0x827E1180;
    'dispatch: loop {
        match pc {
            0x827E1180 => {
    //   block [0x827E1180..0x827E11FC)
	// 827E1180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1184: 489C6FE9  bl 0x831a816c
	ctx.lr = 0x827E1188;
	sub_831A8130(ctx, base);
	// 827E1188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E118C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E1190: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E1194: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E119C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E11A0: 4BBBFEB9  bl 0x823a1058
	ctx.lr = 0x827E11A4;
	sub_823A1058(ctx, base);
	// 827E11A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E11A8: 4BFFFF39  bl 0x827e10e0
	ctx.lr = 0x827E11AC;
	sub_827E10E0(ctx, base);
	// 827E11AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E11B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E11B4: 419A0028  beq cr6, 0x827e11dc
	if ctx.cr[6].eq {
	pc = 0x827E11DC; continue 'dispatch;
	}
	// 827E11B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E11BC: 4BBBFEF5  bl 0x823a10b0
	ctx.lr = 0x827E11C0;
	sub_823A10B0(ctx, base);
	// 827E11C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E11C4: 41820018  beq 0x827e11dc
	if ctx.cr[0].eq {
	pc = 0x827E11DC; continue 'dispatch;
	}
	// 827E11C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E11CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E11D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E11D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E11D8: 4E800421  bctrl
	ctx.lr = 0x827E11DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E11DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E11E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E11E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E11E8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E11EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E11F0: 4E800421  bctrl
	ctx.lr = 0x827E11F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E11F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E11F8: 489C6FC4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1200 size=100
    let mut pc: u32 = 0x827E1200;
    'dispatch: loop {
        match pc {
            0x827E1200 => {
    //   block [0x827E1200..0x827E1264)
	// 827E1200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E120C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E1210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1214: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E1218: 419A0034  beq cr6, 0x827e124c
	if ctx.cr[6].eq {
	pc = 0x827E124C; continue 'dispatch;
	}
	// 827E121C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E1224: 409A0028  bne cr6, 0x827e124c
	if !ctx.cr[6].eq {
	pc = 0x827E124C; continue 'dispatch;
	}
	// 827E1228: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827E122C: 4BADF70D  bl 0x822c0938
	ctx.lr = 0x827E1230;
	sub_822C0938(ctx, base);
	// 827E1230: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1234: 41820010  beq 0x827e1244
	if ctx.cr[0].eq {
	pc = 0x827E1244; continue 'dispatch;
	}
	// 827E1238: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E123C: 4BFFF7C5  bl 0x827e0a00
	ctx.lr = 0x827E1240;
	sub_827E0A00(ctx, base);
	// 827E1240: 48000008  b 0x827e1248
	pc = 0x827E1248; continue 'dispatch;
	// 827E1244: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E1248: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 827E124C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 827E1250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E1254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E1258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E125C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E1260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1268 size=100
    let mut pc: u32 = 0x827E1268;
    'dispatch: loop {
        match pc {
            0x827E1268 => {
    //   block [0x827E1268..0x827E12CC)
	// 827E1268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E126C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E1274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E1278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E127C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E1280: 419A0034  beq cr6, 0x827e12b4
	if ctx.cr[6].eq {
	pc = 0x827E12B4; continue 'dispatch;
	}
	// 827E1284: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E128C: 409A0028  bne cr6, 0x827e12b4
	if !ctx.cr[6].eq {
	pc = 0x827E12B4; continue 'dispatch;
	}
	// 827E1290: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 827E1294: 4BADF6A5  bl 0x822c0938
	ctx.lr = 0x827E1298;
	sub_822C0938(ctx, base);
	// 827E1298: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E129C: 41820010  beq 0x827e12ac
	if ctx.cr[0].eq {
	pc = 0x827E12AC; continue 'dispatch;
	}
	// 827E12A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E12A4: 4BFFFC6D  bl 0x827e0f10
	ctx.lr = 0x827E12A8;
	sub_827E0F10(ctx, base);
	// 827E12A8: 48000008  b 0x827e12b0
	pc = 0x827E12B0; continue 'dispatch;
	// 827E12AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E12B0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 827E12B4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 827E12B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E12BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E12C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E12C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E12C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E12D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E12D0 size=124
    let mut pc: u32 = 0x827E12D0;
    'dispatch: loop {
        match pc {
            0x827E12D0 => {
    //   block [0x827E12D0..0x827E134C)
	// 827E12D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E12D4: 489C6E95  bl 0x831a8168
	ctx.lr = 0x827E12D8;
	sub_831A8130(ctx, base);
	// 827E12D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E12DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E12E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827E12E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827E12E8: 4BBCCCE1  bl 0x823adfc8
	ctx.lr = 0x827E12EC;
	sub_823ADFC8(ctx, base);
	// 827E12EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E12F0: 939F0028  stw r28, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	// 827E12F4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 827E12F8: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 827E12FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1300: 4BFFFE81  bl 0x827e1180
	ctx.lr = 0x827E1304;
	sub_827E1180(ctx, base);
	// 827E1304: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E1308: B07F0030  sth r3, 0x30(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u16 ) };
	// 827E130C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E1310: 409A001C  bne cr6, 0x827e132c
	if !ctx.cr[6].eq {
	pc = 0x827E132C; continue 'dispatch;
	}
	// 827E1314: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1318: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E131C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1320: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 827E1324: 61640004  ori r4, r11, 4
	ctx.r[4].u64 = ctx.r[11].u64 | 4;
	// 827E1328: 4BBCCB99  bl 0x823adec0
	ctx.lr = 0x827E132C;
	sub_823ADEC0(ctx, base);
	// 827E132C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1330: 41820010  beq 0x827e1340
	if ctx.cr[0].eq {
	pc = 0x827E1340; continue 'dispatch;
	}
	// 827E1334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1338: 48610009  bl 0x82df1340
	ctx.lr = 0x827E133C;
	sub_82DF1340(ctx, base);
	// 827E133C: 48000008  b 0x827e1344
	pc = 0x827E1344; continue 'dispatch;
	// 827E1340: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 827E1344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E1348: 489C6E70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1350 size=156
    let mut pc: u32 = 0x827E1350;
    'dispatch: loop {
        match pc {
            0x827E1350 => {
    //   block [0x827E1350..0x827E13EC)
	// 827E1350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1354: 489C6E19  bl 0x831a816c
	ctx.lr = 0x827E1358;
	sub_831A8130(ctx, base);
	// 827E1358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E135C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1360: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E1364: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E1368: 4860F819  bl 0x82df0b80
	ctx.lr = 0x827E136C;
	sub_82DF0B80(ctx, base);
	// 827E136C: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 827E1370: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E1374: 386BA0F8  addi r3, r11, -0x5f08
	ctx.r[3].s64 = ctx.r[11].s64 + -24328;
	// 827E1378: 83BEA0EC  lwz r29, -0x5f14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24340 as u32) ) } as u64;
	// 827E137C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E1380: 4BBBFC69  bl 0x823a0fe8
	ctx.lr = 0x827E1384;
	sub_823A0FE8(ctx, base);
	// 827E1384: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E1388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E138C: 4BBBFDA5  bl 0x823a1130
	ctx.lr = 0x827E1390;
	sub_823A1130(ctx, base);
	// 827E1390: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E1394: 40820044  bne 0x827e13d8
	if !ctx.cr[0].eq {
	pc = 0x827E13D8; continue 'dispatch;
	}
	// 827E1398: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E139C: 419A000C  beq cr6, 0x827e13a8
	if ctx.cr[6].eq {
	pc = 0x827E13A8; continue 'dispatch;
	}
	// 827E13A0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 827E13A4: 48000034  b 0x827e13d8
	pc = 0x827E13D8; continue 'dispatch;
	// 827E13A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E13AC: 4BFFFE55  bl 0x827e1200
	ctx.lr = 0x827E13B0;
	sub_827E1200(ctx, base);
	// 827E13B0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 827E13B4: 409A000C  bne cr6, 0x827e13c0
	if !ctx.cr[6].eq {
	pc = 0x827E13C0; continue 'dispatch;
	}
	// 827E13B8: 489CA791  bl 0x831abb48
	ctx.lr = 0x827E13BC;
	sub_831ABB48(ctx, base);
	// 827E13BC: 4800001C  b 0x827e13d8
	pc = 0x827E13D8; continue 'dispatch;
	// 827E13C0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E13C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E13C8: 93FEA0EC  stw r31, -0x5f14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-24340 as u32), ctx.r[31].u32 ) };
	// 827E13CC: 4BBBFC8D  bl 0x823a1058
	ctx.lr = 0x827E13D0;
	sub_823A1058(ctx, base);
	// 827E13D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E13D4: 4860FA9D  bl 0x82df0e70
	ctx.lr = 0x827E13D8;
	sub_82DF0E70(ctx, base);
	// 827E13D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E13DC: 4860F7ED  bl 0x82df0bc8
	ctx.lr = 0x827E13E0;
	sub_82DF0BC8(ctx, base);
	// 827E13E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E13E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E13E8: 489C6DD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E13F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E13F0 size=156
    let mut pc: u32 = 0x827E13F0;
    'dispatch: loop {
        match pc {
            0x827E13F0 => {
    //   block [0x827E13F0..0x827E148C)
	// 827E13F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E13F4: 489C6D79  bl 0x831a816c
	ctx.lr = 0x827E13F8;
	sub_831A8130(ctx, base);
	// 827E13F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E13FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E1404: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E1408: 4860F779  bl 0x82df0b80
	ctx.lr = 0x827E140C;
	sub_82DF0B80(ctx, base);
	// 827E140C: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 827E1410: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E1414: 386BA0F4  addi r3, r11, -0x5f0c
	ctx.r[3].s64 = ctx.r[11].s64 + -24332;
	// 827E1418: 83BEA0F0  lwz r29, -0x5f10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24336 as u32) ) } as u64;
	// 827E141C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E1420: 4BBBFBC9  bl 0x823a0fe8
	ctx.lr = 0x827E1424;
	sub_823A0FE8(ctx, base);
	// 827E1424: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E1428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E142C: 4BBBFD05  bl 0x823a1130
	ctx.lr = 0x827E1430;
	sub_823A1130(ctx, base);
	// 827E1430: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E1434: 40820044  bne 0x827e1478
	if !ctx.cr[0].eq {
	pc = 0x827E1478; continue 'dispatch;
	}
	// 827E1438: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E143C: 419A000C  beq cr6, 0x827e1448
	if ctx.cr[6].eq {
	pc = 0x827E1448; continue 'dispatch;
	}
	// 827E1440: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 827E1444: 48000034  b 0x827e1478
	pc = 0x827E1478; continue 'dispatch;
	// 827E1448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E144C: 4BFFFE1D  bl 0x827e1268
	ctx.lr = 0x827E1450;
	sub_827E1268(ctx, base);
	// 827E1450: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 827E1454: 409A000C  bne cr6, 0x827e1460
	if !ctx.cr[6].eq {
	pc = 0x827E1460; continue 'dispatch;
	}
	// 827E1458: 489CA6F1  bl 0x831abb48
	ctx.lr = 0x827E145C;
	sub_831ABB48(ctx, base);
	// 827E145C: 4800001C  b 0x827e1478
	pc = 0x827E1478; continue 'dispatch;
	// 827E1460: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E1464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1468: 93FEA0F0  stw r31, -0x5f10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-24336 as u32), ctx.r[31].u32 ) };
	// 827E146C: 4BBBFBED  bl 0x823a1058
	ctx.lr = 0x827E1470;
	sub_823A1058(ctx, base);
	// 827E1470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1474: 4860F9FD  bl 0x82df0e70
	ctx.lr = 0x827E1478;
	sub_82DF0E70(ctx, base);
	// 827E1478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E147C: 4860F74D  bl 0x82df0bc8
	ctx.lr = 0x827E1480;
	sub_82DF0BC8(ctx, base);
	// 827E1480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1484: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E1488: 489C6D34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1490 size=168
    let mut pc: u32 = 0x827E1490;
    'dispatch: loop {
        match pc {
            0x827E1490 => {
    //   block [0x827E1490..0x827E1538)
	// 827E1490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E149C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E14A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E14A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E14A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E14AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E14B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E14B4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827E14B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E14BC: 554A077D  rlwinm. r10, r10, 0, 0x1d, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E14C0: 40820024  bne 0x827e14e4
	if !ctx.cr[0].eq {
	pc = 0x827E14E4; continue 'dispatch;
	}
	// 827E14C4: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E14C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E14CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E14D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E14D4: 4E800421  bctrl
	ctx.lr = 0x827E14D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E14D8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 827E14DC: 409A0008  bne cr6, 0x827e14e4
	if !ctx.cr[6].eq {
	pc = 0x827E14E4; continue 'dispatch;
	}
	// 827E14E0: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 827E14E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E14E8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E14EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E14F0: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827E14F4: 419A0028  beq cr6, 0x827e151c
	if ctx.cr[6].eq {
	pc = 0x827E151C; continue 'dispatch;
	}
	// 827E14F8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E14FC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E1500: 7D6BFB78  or r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 827E1504: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E1508: 409A0008  bne cr6, 0x827e1510
	if !ctx.cr[6].eq {
	pc = 0x827E1510; continue 'dispatch;
	}
	// 827E150C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 827E1510: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1514: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E1518: 4BBCC9A9  bl 0x823adec0
	ctx.lr = 0x827E151C;
	sub_823ADEC0(ctx, base);
	// 827E151C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E1520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E1524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E1528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E152C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E1530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E1534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1538 size=128
    let mut pc: u32 = 0x827E1538;
    'dispatch: loop {
        match pc {
            0x827E1538 => {
    //   block [0x827E1538..0x827E15B8)
	// 827E1538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E153C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E1540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E1544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E1548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E154C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E1550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E1554: 4BBC2FCD  bl 0x823a4520
	ctx.lr = 0x827E1558;
	sub_823A4520(ctx, base);
	// 827E1558: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E155C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1560: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E1564: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1568: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E156C: 409A0014  bne cr6, 0x827e1580
	if !ctx.cr[6].eq {
	pc = 0x827E1580; continue 'dispatch;
	}
	// 827E1570: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 827E1574: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 827E1578: 419A0008  beq cr6, 0x827e1580
	if ctx.cr[6].eq {
	pc = 0x827E1580; continue 'dispatch;
	}
	// 827E157C: 4BFFFF15  bl 0x827e1490
	ctx.lr = 0x827E1580;
	sub_827E1490(ctx, base);
	// 827E1580: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E1588: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E158C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E1590: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1594: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827E1598: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827E159C: 997E0004  stb r11, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 827E15A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E15A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E15A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E15AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E15B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E15B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E15B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E15B8 size=532
    let mut pc: u32 = 0x827E15B8;
    'dispatch: loop {
        match pc {
            0x827E15B8 => {
    //   block [0x827E15B8..0x827E17CC)
	// 827E15B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E15BC: 489C6B9D  bl 0x831a8158
	ctx.lr = 0x827E15C0;
	sub_831A8130(ctx, base);
	// 827E15C0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E15C4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827E15C8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827E15CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E15D0: FB410140  std r26, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[26].u64 ) };
	// 827E15D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E15D8: F8C10148  std r6, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[6].u64 ) };
	// 827E15DC: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 827E15E0: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E15E4: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 827E15E8: 556B0463  rlwinm. r11, r11, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E15EC: 40820024  bne 0x827e1610
	if !ctx.cr[0].eq {
	pc = 0x827E1610; continue 'dispatch;
	}
	// 827E15F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E15F4: 5769063E  clrlwi r9, r27, 0x18
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 827E15F8: 81410148  lwz r10, 0x148(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 827E15FC: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1600: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E1604: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1608: 4E800421  bctrl
	ctx.lr = 0x827E160C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E160C: 480001B4  b 0x827e17c0
	pc = 0x827E17C0; continue 'dispatch;
	// 827E1610: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E1614: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E161C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E1620: 4BBBFA39  bl 0x823a1058
	ctx.lr = 0x827E1624;
	sub_823A1058(ctx, base);
	// 827E1624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E1628: 4BFFFDC9  bl 0x827e13f0
	ctx.lr = 0x827E162C;
	sub_827E13F0(ctx, base);
	// 827E162C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827E1630: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E1634: 419A0028  beq cr6, 0x827e165c
	if ctx.cr[6].eq {
	pc = 0x827E165C; continue 'dispatch;
	}
	// 827E1638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E163C: 4BBBFA75  bl 0x823a10b0
	ctx.lr = 0x827E1640;
	sub_823A10B0(ctx, base);
	// 827E1640: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1644: 41820018  beq 0x827e165c
	if ctx.cr[0].eq {
	pc = 0x827E165C; continue 'dispatch;
	}
	// 827E1648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E164C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E1650: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1654: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1658: 4E800421  bctrl
	ctx.lr = 0x827E165C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E165C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1660: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E1664: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1668: 4BAE7E79  bl 0x822c94e0
	ctx.lr = 0x827E166C;
	sub_822C94E0(ctx, base);
	// 827E166C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1670: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827E1674: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1678: 41820030  beq 0x827e16a8
	if ctx.cr[0].eq {
	pc = 0x827E16A8; continue 'dispatch;
	}
	// 827E167C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E1680: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E1684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1688: 4E800421  bctrl
	ctx.lr = 0x827E168C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E168C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E1690: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1694: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827E1698: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E169C: 4BAE84F5  bl 0x822c9b90
	ctx.lr = 0x827E16A0;
	sub_822C9B90(ctx, base);
	// 827E16A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E16A4: 4800002C  b 0x827e16d0
	pc = 0x827E16D0; continue 'dispatch;
	// 827E16A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E16AC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E16B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E16B4: 4E800421  bctrl
	ctx.lr = 0x827E16B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E16B8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E16BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E16C0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 827E16C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E16C8: 4BAE84C9  bl 0x822c9b90
	ctx.lr = 0x827E16CC;
	sub_822C9B90(ctx, base);
	// 827E16CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E16D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E16D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E16D8: 4BAE7E09  bl 0x822c94e0
	ctx.lr = 0x827E16DC;
	sub_822C94E0(ctx, base);
	// 827E16DC: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E16E0: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827E16E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E16E8: 40990010  ble cr6, 0x827e16f8
	if !ctx.cr[6].gt {
	pc = 0x827E16F8; continue 'dispatch;
	}
	// 827E16EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827E16F0: 7FE85850  subf r31, r8, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827E16F4: 41990008  bgt cr6, 0x827e16fc
	if ctx.cr[6].gt {
	pc = 0x827E16FC; continue 'dispatch;
	}
	// 827E16F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E16FC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E1700: 556B05F2  rlwinm r11, r11, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827E1704: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 827E1708: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 827E170C: 419A0040  beq cr6, 0x827e174c
	if ctx.cr[6].eq {
	pc = 0x827E174C; continue 'dispatch;
	}
	// 827E1710: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 827E1714: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 827E1718: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827E171C: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1720: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E1724: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E1728: 4BFFF5F1  bl 0x827e0d18
	ctx.lr = 0x827E172C;
	sub_827E0D18(ctx, base);
	// 827E172C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1730: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1734: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E1738: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827E173C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1740: 91410140  stw r10, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 827E1744: 91210144  stw r9, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[9].u32 ) };
	// 827E1748: EB410140  ld r26, 0x140(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	// 827E174C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827E1750: 80E10074  lwz r7, 0x74(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E1754: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 827E1758: 40980008  bge cr6, 0x827e1760
	if !ctx.cr[6].lt {
	pc = 0x827E1760; continue 'dispatch;
	}
	// 827E175C: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 827E1760: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827E1764: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E1768: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E176C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E1770: 4BFFF541  bl 0x827e0cb0
	ctx.lr = 0x827E1774;
	sub_827E0CB0(ctx, base);
	// 827E1774: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E1778: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E177C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 827E1780: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 827E1784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E1788: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E178C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E1790: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1794: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1798: 915D0018  stw r10, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 827E179C: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E17A0: 90A10144  stw r5, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[5].u32 ) };
	// 827E17A4: 91210140  stw r9, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[9].u32 ) };
	// 827E17A8: E8A10140  ld r5, 0x140(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	// 827E17AC: 4BFFF56D  bl 0x827e0d18
	ctx.lr = 0x827E17B0;
	sub_827E0D18(ctx, base);
	// 827E17B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E17B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E17B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E17BC: 4BAE7D25  bl 0x822c94e0
	ctx.lr = 0x827E17C0;
	sub_822C94E0(ctx, base);
	// 827E17C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E17C4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827E17C8: 489C69E0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E17D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E17D0 size=1560
    let mut pc: u32 = 0x827E17D0;
    'dispatch: loop {
        match pc {
            0x827E17D0 => {
    //   block [0x827E17D0..0x827E1DE8)
	// 827E17D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E17D4: 489C6961  bl 0x831a8134
	ctx.lr = 0x827E17D8;
	sub_831A8130(ctx, base);
	// 827E17D8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E17DC: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 827E17E0: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 827E17E4: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 827E17E8: FAC10170  std r22, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[22].u64 ) };
	// 827E17EC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827E17F0: F8C10178  std r6, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[6].u64 ) };
	// 827E17F4: 7D104378  mr r16, r8
	ctx.r[16].u64 = ctx.r[8].u64;
	// 827E17F8: 81710024  lwz r11, 0x24(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E17FC: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 827E1800: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 827E1804: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E180C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E1810: 4BBBF849  bl 0x823a1058
	ctx.lr = 0x827E1814;
	sub_823A1058(ctx, base);
	// 827E1814: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E1818: 4BFFFBD9  bl 0x827e13f0
	ctx.lr = 0x827E181C;
	sub_827E13F0(ctx, base);
	// 827E181C: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 827E1820: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E1824: 419A0028  beq cr6, 0x827e184c
	if ctx.cr[6].eq {
	pc = 0x827E184C; continue 'dispatch;
	}
	// 827E1828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E182C: 4BBBF885  bl 0x823a10b0
	ctx.lr = 0x827E1830;
	sub_823A10B0(ctx, base);
	// 827E1830: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1834: 41820018  beq 0x827e184c
	if ctx.cr[0].eq {
	pc = 0x827E184C; continue 'dispatch;
	}
	// 827E1838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E183C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E1840: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1848: 4E800421  bctrl
	ctx.lr = 0x827E184C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E184C: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1850: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 827E1854: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E1858: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E185C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1860: 4E800421  bctrl
	ctx.lr = 0x827E1864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E1864: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1868: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 827E186C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1874: 4E800421  bctrl
	ctx.lr = 0x827E1878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E1878: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 827E187C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1880: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E1884: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1888: 4BAE3459  bl 0x822c4ce0
	ctx.lr = 0x827E188C;
	sub_822C4CE0(ctx, base);
	// 827E188C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 827E1890: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 827E1894: B2610054  sth r19, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[19].u16 ) };
	// 827E1898: 38FB0008  addi r7, r27, 8
	ctx.r[7].s64 = ctx.r[27].s64 + 8;
	// 827E189C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 827E18A0: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 827E18A4: 9261005C  stw r19, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[19].u32 ) };
	// 827E18A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827E18AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E18B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E18B4: 486101CD  bl 0x82df1a80
	ctx.lr = 0x827E18B8;
	sub_82DF1A80(ctx, base);
	// 827E18B8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E18BC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 827E18C0: 2F0B002B  cmpwi cr6, r11, 0x2b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 43, &mut ctx.xer);
	// 827E18C4: 419A0010  beq cr6, 0x827e18d4
	if ctx.cr[6].eq {
	pc = 0x827E18D4; continue 'dispatch;
	}
	// 827E18C8: 2F0B002D  cmpwi cr6, r11, 0x2d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 45, &mut ctx.xer);
	// 827E18CC: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	// 827E18D0: 409A0008  bne cr6, 0x827e18d8
	if !ctx.cr[6].eq {
	pc = 0x827E18D8; continue 'dispatch;
	}
	// 827E18D4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 827E18D8: 489CA261  bl 0x831abb38
	ctx.lr = 0x827E18DC;
	sub_831ABB38(ctx, base);
	// 827E18DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E18E0: 39400065  li r10, 0x65
	ctx.r[10].s64 = 101;
	// 827E18E4: 838101B4  lwz r28, 0x1b4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 827E18E8: 38800065  li r4, 0x65
	ctx.r[4].s64 = 101;
	// 827E18EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E18F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E18F4: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E18F8: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 827E18FC: 9A61005A  stb r19, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[19].u8 ) };
	// 827E1900: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 827E1904: 489C881D  bl 0x831aa120
	ctx.lr = 0x827E1908;
	sub_831AA120(ctx, base);
	// 827E1908: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E190C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E1910: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E1914: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 827E1918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E191C: 489C8805  bl 0x831aa120
	ctx.lr = 0x827E1920;
	sub_831AA120(ctx, base);
	// 827E1920: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E1924: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 827E1928: 41820008  beq 0x827e1930
	if ctx.cr[0].eq {
	pc = 0x827E1930; continue 'dispatch;
	}
	// 827E192C: 830101AC  lwz r24, 0x1ac(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 827E1930: 812100B8  lwz r9, 0xb8(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E1934: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E1938: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E193C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827E1940: 40980008  bge cr6, 0x827e1948
	if !ctx.cr[6].lt {
	pc = 0x827E1948; continue 'dispatch;
	}
	// 827E1944: 394100A4  addi r10, r1, 0xa4
	ctx.r[10].s64 = ctx.r[1].s64 + 164;
	// 827E1948: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E194C: 2B0A007F  cmplwi cr6, r10, 0x7f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 127 as u32, &mut ctx.xer);
	// 827E1950: 419A0170  beq cr6, 0x827e1ac0
	if ctx.cr[6].eq {
	pc = 0x827E1AC0; continue 'dispatch;
	}
	// 827E1954: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E1958: 40980008  bge cr6, 0x827e1960
	if !ctx.cr[6].lt {
	pc = 0x827E1960; continue 'dispatch;
	}
	// 827E195C: 396100A4  addi r11, r1, 0xa4
	ctx.r[11].s64 = ctx.r[1].s64 + 164;
	// 827E1960: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1964: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1968: 40810158  ble 0x827e1ac0
	if !ctx.cr[0].gt {
	pc = 0x827E1AC0; continue 'dispatch;
	}
	// 827E196C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E1970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E1974: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1978: 4BBCCF71  bl 0x823ae8e8
	ctx.lr = 0x827E197C;
	sub_823AE8E8(ctx, base);
	// 827E197C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E1980: 409A0018  bne cr6, 0x827e1998
	if !ctx.cr[6].eq {
	pc = 0x827E1998; continue 'dispatch;
	}
	// 827E1984: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827E1988: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827E198C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1990: 4BBCCD59  bl 0x823ae6e8
	ctx.lr = 0x827E1994;
	sub_823AE6E8(ctx, base);
	// 827E1994: 48000034  b 0x827e19c8
	pc = 0x827E19C8; continue 'dispatch;
	// 827E1998: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E199C: 409A0018  bne cr6, 0x827e19b4
	if !ctx.cr[6].eq {
	pc = 0x827E19B4; continue 'dispatch;
	}
	// 827E19A0: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827E19A4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 827E19A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E19AC: 4BBCCD3D  bl 0x823ae6e8
	ctx.lr = 0x827E19B0;
	sub_823AE6E8(ctx, base);
	// 827E19B0: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 827E19B4: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 827E19B8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827E19BC: 7C9FE850  subf r4, r31, r29
	ctx.r[4].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 827E19C0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E19C4: 4BBCCDF5  bl 0x823ae7b8
	ctx.lr = 0x827E19C8;
	sub_823AE7B8(ctx, base);
	// 827E19C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E19CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E19D0: 409A0018  bne cr6, 0x827e19e8
	if !ctx.cr[6].eq {
	pc = 0x827E19E8; continue 'dispatch;
	}
	// 827E19D4: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827E19D8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 827E19DC: 4BBCCD0D  bl 0x823ae6e8
	ctx.lr = 0x827E19E0;
	sub_823AE6E8(ctx, base);
	// 827E19E0: 82E101A4  lwz r23, 0x1a4(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 827E19E4: 48000030  b 0x827e1a14
	pc = 0x827E1A14; continue 'dispatch;
	// 827E19E8: 7FFFF050  subf r31, r31, r30
	ctx.r[31].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 827E19EC: 80A101A4  lwz r5, 0x1a4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 827E19F0: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 827E19F4: 389F0001  addi r4, r31, 1
	ctx.r[4].s64 = ctx.r[31].s64 + 1;
	// 827E19F8: 4BBCCDC1  bl 0x823ae7b8
	ctx.lr = 0x827E19FC;
	sub_823AE7B8(ctx, base);
	// 827E19FC: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 827E1A00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 827E1A04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E1A08: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1A0C: 4BBCCDAD  bl 0x823ae7b8
	ctx.lr = 0x827E1A10;
	sub_823AE7B8(ctx, base);
	// 827E1A10: 7E779B78  mr r23, r19
	ctx.r[23].u64 = ctx.r[19].u64;
	// 827E1A14: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E1A18: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 827E1A1C: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E1A20: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E1A24: 40980008  bge cr6, 0x827e1a2c
	if !ctx.cr[6].lt {
	pc = 0x827E1A2C; continue 'dispatch;
	}
	// 827E1A28: 3BC100A4  addi r30, r1, 0xa4
	ctx.r[30].s64 = ctx.r[1].s64 + 164;
	// 827E1A2C: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E1A30: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827E1A34: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E1A38: 40980008  bge cr6, 0x827e1a40
	if !ctx.cr[6].lt {
	pc = 0x827E1A40; continue 'dispatch;
	}
	// 827E1A3C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 827E1A40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827E1A44: 489CA1D5  bl 0x831abc18
	ctx.lr = 0x827E1A48;
	sub_831ABC18(ctx, base);
	// 827E1A48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E1A4C: 48000044  b 0x827e1a90
	pc = 0x827E1A90; continue 'dispatch;
	// 827E1A50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1A54: 4099004C  ble cr6, 0x827e1aa0
	if !ctx.cr[6].gt {
	pc = 0x827E1AA0; continue 'dispatch;
	}
	// 827E1A58: 7D5AF850  subf r10, r26, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 827E1A5C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E1A60: 40980040  bge cr6, 0x827e1aa0
	if !ctx.cr[6].lt {
	pc = 0x827E1AA0; continue 'dispatch;
	}
	// 827E1A64: 7FEBF850  subf r31, r11, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 827E1A68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E1A6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827E1A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E1A74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1A78: 4BBCCD41  bl 0x823ae7b8
	ctx.lr = 0x827E1A7C;
	sub_823AE7B8(ctx, base);
	// 827E1A7C: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 827E1A80: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 827E1A84: 7D4A0775  extsb. r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E1A88: 40810008  ble 0x827e1a90
	if !ctx.cr[0].gt {
	pc = 0x827E1A90; continue 'dispatch;
	}
	// 827E1A8C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827E1A90: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1A94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 827E1A98: 2F0B007F  cmpwi cr6, r11, 0x7f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 127, &mut ctx.xer);
	// 827E1A9C: 409AFFB4  bne cr6, 0x827e1a50
	if !ctx.cr[6].eq {
	pc = 0x827E1A50; continue 'dispatch;
	}
	// 827E1AA0: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E1AA4: 83E10084  lwz r31, 0x84(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827E1AA8: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E1AAC: 40980008  bge cr6, 0x827e1ab4
	if !ctx.cr[6].lt {
	pc = 0x827E1AB4; continue 'dispatch;
	}
	// 827E1AB0: 3BE10084  addi r31, r1, 0x84
	ctx.r[31].s64 = ctx.r[1].s64 + 132;
	// 827E1AB4: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827E1AB8: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 827E1ABC: 48000008  b 0x827e1ac4
	pc = 0x827E1AC4; continue 'dispatch;
	// 827E1AC0: 82E101A4  lwz r23, 0x1a4(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 827E1AC4: 7D75BA14  add r11, r21, r23
	ctx.r[11].u64 = ctx.r[21].u64 + ctx.r[23].u64;
	// 827E1AC8: 7D4BC214  add r10, r11, r24
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 827E1ACC: 81710018  lwz r11, 0x18(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E1AD0: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 827E1AD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1AD8: 40990010  ble cr6, 0x827e1ae8
	if !ctx.cr[6].gt {
	pc = 0x827E1AE8; continue 'dispatch;
	}
	// 827E1ADC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E1AE0: 7F2A5850  subf r25, r10, r11
	ctx.r[25].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827E1AE4: 41990008  bgt cr6, 0x827e1aec
	if ctx.cr[6].gt {
	pc = 0x827E1AEC; continue 'dispatch;
	}
	// 827E1AE8: 7E799B78  mr r25, r19
	ctx.r[25].u64 = ctx.r[19].u64;
	// 827E1AEC: 81710010  lwz r11, 0x10(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E1AF0: 556B05F2  rlwinm r11, r11, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827E1AF4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 827E1AF8: 419A0098  beq cr6, 0x827e1b90
	if ctx.cr[6].eq {
	pc = 0x827E1B90; continue 'dispatch;
	}
	// 827E1AFC: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 827E1B00: 81610178  lwz r11, 0x178(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 827E1B04: 419A0040  beq cr6, 0x827e1b44
	if ctx.cr[6].eq {
	pc = 0x827E1B44; continue 'dispatch;
	}
	// 827E1B08: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1B0C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827E1B10: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 827E1B14: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 827E1B18: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1B1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1B20: 4BFFF1F9  bl 0x827e0d18
	ctx.lr = 0x827E1B24;
	sub_827E0D18(ctx, base);
	// 827E1B24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1B28: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1B2C: 7E799B78  mr r25, r19
	ctx.r[25].u64 = ctx.r[19].u64;
	// 827E1B30: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1B34: 91610170  stw r11, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 827E1B38: 91410174  stw r10, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 827E1B3C: EAC10170  ld r22, 0x170(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 827E1B40: 48000054  b 0x827e1b94
	pc = 0x827E1B94; continue 'dispatch;
	// 827E1B44: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827E1B48: 419A0040  beq cr6, 0x827e1b88
	if ctx.cr[6].eq {
	pc = 0x827E1B88; continue 'dispatch;
	}
	// 827E1B4C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827E1B50: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 827E1B54: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827E1B58: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1B5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1B60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1B64: 4BFFF215  bl 0x827e0d78
	ctx.lr = 0x827E1B68;
	sub_827E0D78(ctx, base);
	// 827E1B68: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1B6C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1B70: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827E1B74: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1B78: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 827E1B7C: 91410174  stw r10, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 827E1B80: 91210170  stw r9, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[9].u32 ) };
	// 827E1B84: EAC10170  ld r22, 0x170(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 827E1B88: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E1B8C: 4BFFFF80  b 0x827e1b0c
	pc = 0x827E1B0C; continue 'dispatch;
	// 827E1B90: 83C10178  lwz r30, 0x178(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 827E1B94: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E1B98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E1B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1BA0: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 827E1BA4: 489C857D  bl 0x831aa120
	ctx.lr = 0x827E1BA8;
	sub_831AA120(ctx, base);
	// 827E1BA8: A3410054  lhz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E1BAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1BB0: 418200CC  beq 0x827e1c7c
	if ctx.cr[0].eq {
	pc = 0x827E1C7C; continue 'dispatch;
	}
	// 827E1BB4: 7D7F1850  subf r11, r31, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 827E1BB8: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 827E1BBC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 827E1BC0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 827E1BC4: 391DFFFF  addi r8, r29, -1
	ctx.r[8].s64 = ctx.r[29].s64 + -1;
	// 827E1BC8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827E1BCC: 7BC607C6  sldi r6, r30, 0x20
	ctx.r[6].u64 = ctx.r[30].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E1BD0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1BD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1BD8: 4BFFF239  bl 0x827e0e10
	ctx.lr = 0x827E1BDC;
	sub_827E0E10(ctx, base);
	// 827E1BDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E1BE0: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 827E1BE4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827E1BE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1BEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1BF0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1BF4: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827E1BF8: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1BFC: 4BFFF11D  bl 0x827e0d18
	ctx.lr = 0x827E1C00;
	sub_827E0D18(ctx, base);
	// 827E1C00: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1C04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E1C08: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 827E1C0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1C10: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1C14: 82CA0004  lwz r22, 4(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1C18: 82AA0008  lwz r21, 8(r10)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1C20: 4E800421  bctrl
	ctx.lr = 0x827E1C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E1C24: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827E1C28: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 827E1C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E1C30: 92A10068  stw r21, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[21].u32 ) };
	// 827E1C34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1C38: 4BFFF029  bl 0x827e0c60
	ctx.lr = 0x827E1C3C;
	sub_827E0C60(ctx, base);
	// 827E1C3C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827E1C40: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 827E1C44: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827E1C48: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827E1C4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1C50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1C54: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1C58: 4BFFF0C1  bl 0x827e0d18
	ctx.lr = 0x827E1C5C;
	sub_827E0D18(ctx, base);
	// 827E1C5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1C60: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1C64: 7FFDFA14  add r31, r29, r31
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 827E1C68: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1C6C: 7F9DE050  subf r28, r29, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 827E1C70: 91610170  stw r11, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 827E1C74: 91410174  stw r10, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 827E1C78: EAC10170  ld r22, 0x170(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 827E1C7C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E1C80: 38800065  li r4, 0x65
	ctx.r[4].s64 = 101;
	// 827E1C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1C88: 489C8499  bl 0x831aa120
	ctx.lr = 0x827E1C8C;
	sub_831AA120(ctx, base);
	// 827E1C8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1C90: 418200B0  beq 0x827e1d40
	if ctx.cr[0].eq {
	pc = 0x827E1D40; continue 'dispatch;
	}
	// 827E1C94: 7D7F1850  subf r11, r31, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 827E1C98: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 827E1C9C: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 827E1CA0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 827E1CA4: 391DFFFF  addi r8, r29, -1
	ctx.r[8].s64 = ctx.r[29].s64 + -1;
	// 827E1CA8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827E1CAC: 7BC607C6  sldi r6, r30, 0x20
	ctx.r[6].u64 = ctx.r[30].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E1CB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1CB4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1CB8: 4BFFF159  bl 0x827e0e10
	ctx.lr = 0x827E1CBC;
	sub_827E0E10(ctx, base);
	// 827E1CBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E1CC0: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 827E1CC4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827E1CC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1CCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1CD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1CD4: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827E1CD8: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1CDC: 4BFFF03D  bl 0x827e0d18
	ctx.lr = 0x827E1CE0;
	sub_827E0D18(ctx, base);
	// 827E1CE0: 81710010  lwz r11, 0x10(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E1CE4: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 827E1CE8: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1CEC: 41820010  beq 0x827e1cfc
	if ctx.cr[0].eq {
	pc = 0x827E1CFC; continue 'dispatch;
	}
	// 827E1CF0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E1CF4: 38EBD1EC  addi r7, r11, -0x2e14
	ctx.r[7].s64 = ctx.r[11].s64 + -11796;
	// 827E1CF8: 4800000C  b 0x827e1d04
	pc = 0x827E1D04; continue 'dispatch;
	// 827E1CFC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E1D00: 38EBD1E8  addi r7, r11, -0x2e18
	ctx.r[7].s64 = ctx.r[11].s64 + -11800;
	// 827E1D04: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1D08: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827E1D0C: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 827E1D10: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1D14: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1D18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1D1C: 4BFFF05D  bl 0x827e0d78
	ctx.lr = 0x827E1D20;
	sub_827E0D78(ctx, base);
	// 827E1D20: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1D24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1D28: 7FFDFA14  add r31, r29, r31
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 827E1D2C: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1D30: 7F9DE050  subf r28, r29, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 827E1D34: 91410170  stw r10, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[10].u32 ) };
	// 827E1D38: 91610174  stw r11, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 827E1D3C: EAC10170  ld r22, 0x170(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 827E1D40: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 827E1D44: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 827E1D48: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 827E1D4C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827E1D50: 7BC607C6  sldi r6, r30, 0x20
	ctx.r[6].u64 = ctx.r[30].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E1D54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1D58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E1D5C: 4BFFF0B5  bl 0x827e0e10
	ctx.lr = 0x827E1D60;
	sub_827E0E10(ctx, base);
	// 827E1D60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E1D64: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 827E1D68: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827E1D6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1D70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E1D74: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1D78: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827E1D7C: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1D80: 4BFFEF99  bl 0x827e0d18
	ctx.lr = 0x827E1D84;
	sub_827E0D18(ctx, base);
	// 827E1D84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E1D88: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 827E1D8C: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 827E1D90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1D94: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 827E1D98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1D9C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1DA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1DA4: 92710018  stw r19, 0x18(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(24 as u32), ctx.r[19].u32 ) };
	// 827E1DA8: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1DAC: 91410170  stw r10, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[10].u32 ) };
	// 827E1DB0: 91210174  stw r9, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[9].u32 ) };
	// 827E1DB4: E8A10170  ld r5, 0x170(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 827E1DB8: 4BFFEF61  bl 0x827e0d18
	ctx.lr = 0x827E1DBC;
	sub_827E0D18(ctx, base);
	// 827E1DBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1DC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E1DC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1DC8: 4BAE2F19  bl 0x822c4ce0
	ctx.lr = 0x827E1DCC;
	sub_822C4CE0(ctx, base);
	// 827E1DCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E1DD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E1DD4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E1DD8: 4BAE2F09  bl 0x822c4ce0
	ctx.lr = 0x827E1DDC;
	sub_822C4CE0(ctx, base);
	// 827E1DDC: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 827E1DE0: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 827E1DE4: 489C63A0  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E1DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E1DE8 size=712
    let mut pc: u32 = 0x827E1DE8;
    'dispatch: loop {
        match pc {
            0x827E1DE8 => {
    //   block [0x827E1DE8..0x827E20B0)
	// 827E1DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E1DEC: 489C635D  bl 0x831a8148
	ctx.lr = 0x827E1DF0;
	sub_831A8130(ctx, base);
	// 827E1DF0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E1DF4: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 827E1DF8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827E1DFC: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 827E1E00: FB010130  std r24, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[24].u64 ) };
	// 827E1E04: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827E1E08: F8C10138  std r6, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[6].u64 ) };
	// 827E1E0C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 827E1E10: 81750024  lwz r11, 0x24(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E1E14: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 827E1E18: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 827E1E1C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1E24: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E1E28: 4BBBF231  bl 0x823a1058
	ctx.lr = 0x827E1E2C;
	sub_823A1058(ctx, base);
	// 827E1E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E1E30: 4BFFF5C1  bl 0x827e13f0
	ctx.lr = 0x827E1E34;
	sub_827E13F0(ctx, base);
	// 827E1E34: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827E1E38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E1E3C: 419A0028  beq cr6, 0x827e1e64
	if ctx.cr[6].eq {
	pc = 0x827E1E64; continue 'dispatch;
	}
	// 827E1E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E1E44: 4BBBF26D  bl 0x823a10b0
	ctx.lr = 0x827E1E48;
	sub_823A10B0(ctx, base);
	// 827E1E48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E1E4C: 41820018  beq 0x827e1e64
	if ctx.cr[0].eq {
	pc = 0x827E1E64; continue 'dispatch;
	}
	// 827E1E50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1E54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E1E58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1E5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1E60: 4E800421  bctrl
	ctx.lr = 0x827E1E64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E1E64: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1E68: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827E1E6C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E1E70: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E1E74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E1E78: 4E800421  bctrl
	ctx.lr = 0x827E1E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E1E7C: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1E80: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 827E1E84: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 827E1E88: 2F0B002B  cmpwi cr6, r11, 0x2b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 43, &mut ctx.xer);
	// 827E1E8C: 419A003C  beq cr6, 0x827e1ec8
	if ctx.cr[6].eq {
	pc = 0x827E1EC8; continue 'dispatch;
	}
	// 827E1E90: 2F0B002D  cmpwi cr6, r11, 0x2d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 45, &mut ctx.xer);
	// 827E1E94: 419A0034  beq cr6, 0x827e1ec8
	if ctx.cr[6].eq {
	pc = 0x827E1EC8; continue 'dispatch;
	}
	// 827E1E98: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 827E1E9C: 409A0024  bne cr6, 0x827e1ec0
	if !ctx.cr[6].eq {
	pc = 0x827E1EC0; continue 'dispatch;
	}
	// 827E1EA0: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 827E1EA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 827E1EA8: 2F0B0078  cmpwi cr6, r11, 0x78
	ctx.cr[6].compare_i32(ctx.r[11].s32, 120, &mut ctx.xer);
	// 827E1EAC: 419A000C  beq cr6, 0x827e1eb8
	if ctx.cr[6].eq {
	pc = 0x827E1EB8; continue 'dispatch;
	}
	// 827E1EB0: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 827E1EB4: 409A000C  bne cr6, 0x827e1ec0
	if !ctx.cr[6].eq {
	pc = 0x827E1EC0; continue 'dispatch;
	}
	// 827E1EB8: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 827E1EBC: 48000010  b 0x827e1ecc
	pc = 0x827E1ECC; continue 'dispatch;
	// 827E1EC0: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 827E1EC4: 48000008  b 0x827e1ecc
	pc = 0x827E1ECC; continue 'dispatch;
	// 827E1EC8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 827E1ECC: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E1ED0: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827E1ED4: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 827E1ED8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 827E1EDC: 40980008  bge cr6, 0x827e1ee4
	if !ctx.cr[6].lt {
	pc = 0x827E1EE4; continue 'dispatch;
	}
	// 827E1EE0: 39610084  addi r11, r1, 0x84
	ctx.r[11].s64 = ctx.r[1].s64 + 132;
	// 827E1EE4: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1EE8: 2B0B007F  cmplwi cr6, r11, 0x7f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 127 as u32, &mut ctx.xer);
	// 827E1EEC: 419A0094  beq cr6, 0x827e1f80
	if ctx.cr[6].eq {
	pc = 0x827E1F80; continue 'dispatch;
	}
	// 827E1EF0: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 827E1EF4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 827E1EF8: 40980008  bge cr6, 0x827e1f00
	if !ctx.cr[6].lt {
	pc = 0x827E1F00; continue 'dispatch;
	}
	// 827E1EFC: 39610084  addi r11, r1, 0x84
	ctx.r[11].s64 = ctx.r[1].s64 + 132;
	// 827E1F00: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1F04: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1F08: 40810078  ble 0x827e1f80
	if !ctx.cr[0].gt {
	pc = 0x827E1F80; continue 'dispatch;
	}
	// 827E1F0C: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 827E1F10: 40980008  bge cr6, 0x827e1f18
	if !ctx.cr[6].lt {
	pc = 0x827E1F18; continue 'dispatch;
	}
	// 827E1F14: 3B810084  addi r28, r1, 0x84
	ctx.r[28].s64 = ctx.r[1].s64 + 132;
	// 827E1F18: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 827E1F1C: 48000054  b 0x827e1f70
	pc = 0x827E1F70; continue 'dispatch;
	// 827E1F20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1F24: 4099005C  ble cr6, 0x827e1f80
	if !ctx.cr[6].gt {
	pc = 0x827E1F80; continue 'dispatch;
	}
	// 827E1F28: 7D5AF850  subf r10, r26, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 827E1F2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E1F30: 40980050  bge cr6, 0x827e1f80
	if !ctx.cr[6].lt {
	pc = 0x827E1F80; continue 'dispatch;
	}
	// 827E1F34: 7FEBF850  subf r31, r11, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 827E1F38: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 827E1F3C: 7CBFF214  add r5, r31, r30
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 827E1F40: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 827E1F44: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 827E1F48: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 827E1F4C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 827E1F50: 489C6DB9  bl 0x831a8d08
	ctx.lr = 0x827E1F54;
	sub_831A8D08(ctx, base);
	// 827E1F54: 7F3FF1AE  stbx r25, r31, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[25].u8) };
	// 827E1F58: 895C0001  lbz r10, 1(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1 as u32) ) } as u64;
	// 827E1F5C: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 827E1F60: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 827E1F64: 7D4A0775  extsb. r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E1F68: 40810008  ble 0x827e1f70
	if !ctx.cr[0].gt {
	pc = 0x827E1F70; continue 'dispatch;
	}
	// 827E1F6C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 827E1F70: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1F74: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 827E1F78: 2F0B007F  cmpwi cr6, r11, 0x7f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 127, &mut ctx.xer);
	// 827E1F7C: 409AFFA4  bne cr6, 0x827e1f20
	if !ctx.cr[6].eq {
	pc = 0x827E1F20; continue 'dispatch;
	}
	// 827E1F80: 81750018  lwz r11, 0x18(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E1F84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E1F88: 40990010  ble cr6, 0x827e1f98
	if !ctx.cr[6].gt {
	pc = 0x827E1F98; continue 'dispatch;
	}
	// 827E1F8C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827E1F90: 7FFD5850  subf r31, r29, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827E1F94: 41990008  bgt cr6, 0x827e1f9c
	if ctx.cr[6].gt {
	pc = 0x827E1F9C; continue 'dispatch;
	}
	// 827E1F98: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 827E1F9C: 81750010  lwz r11, 0x10(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E1FA0: 556B05F2  rlwinm r11, r11, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827E1FA4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 827E1FA8: 419A007C  beq cr6, 0x827e2024
	if ctx.cr[6].eq {
	pc = 0x827E2024; continue 'dispatch;
	}
	// 827E1FAC: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 827E1FB0: 81610138  lwz r11, 0x138(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) } as u64;
	// 827E1FB4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827E1FB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E1FBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E1FC0: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E1FC4: 419A0030  beq cr6, 0x827e1ff4
	if ctx.cr[6].eq {
	pc = 0x827E1FF4; continue 'dispatch;
	}
	// 827E1FC8: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 827E1FCC: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 827E1FD0: 4BFFED49  bl 0x827e0d18
	ctx.lr = 0x827E1FD4;
	sub_827E0D18(ctx, base);
	// 827E1FD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E1FD8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E1FDC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 827E1FE0: 83830008  lwz r28, 8(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E1FE4: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 827E1FE8: 91410134  stw r10, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[10].u32 ) };
	// 827E1FEC: EB010130  ld r24, 0x130(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	// 827E1FF0: 48000038  b 0x827e2028
	pc = 0x827E2028; continue 'dispatch;
	// 827E1FF4: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 827E1FF8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827E1FFC: 4BFFED7D  bl 0x827e0d78
	ctx.lr = 0x827E2000;
	sub_827E0D78(ctx, base);
	// 827E2000: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E2004: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E2008: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827E200C: 7FDAF214  add r30, r26, r30
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 827E2010: 7FBAE850  subf r29, r26, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[26].s64;
	// 827E2014: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E2018: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827E201C: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2020: 4BFFFFA8  b 0x827e1fc8
	pc = 0x827E1FC8; continue 'dispatch;
	// 827E2024: 83810138  lwz r28, 0x138(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) } as u64;
	// 827E2028: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E202C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 827E2030: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E2034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E2038: 4E800421  bctrl
	ctx.lr = 0x827E203C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E203C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 827E2040: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 827E2044: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827E2048: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827E204C: 7B8607C6  sldi r6, r28, 0x20
	ctx.r[6].u64 = ctx.r[28].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 827E2050: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E2054: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827E2058: 4BFFEDB9  bl 0x827e0e10
	ctx.lr = 0x827E205C;
	sub_827E0E10(ctx, base);
	// 827E205C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E2060: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 827E2064: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 827E2068: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E206C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 827E2070: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2074: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2078: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E207C: 93350018  stw r25, 0x18(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 827E2080: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2084: 91410130  stw r10, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[10].u32 ) };
	// 827E2088: 91210134  stw r9, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[9].u32 ) };
	// 827E208C: E8A10130  ld r5, 0x130(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	// 827E2090: 4BFFEC89  bl 0x827e0d18
	ctx.lr = 0x827E2094;
	sub_827E0D18(ctx, base);
	// 827E2094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2098: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E209C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E20A0: 4BAE2C41  bl 0x822c4ce0
	ctx.lr = 0x827E20A4;
	sub_822C4CE0(ctx, base);
	// 827E20A4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 827E20A8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 827E20AC: 489C60EC  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E20B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E20B0 size=300
    let mut pc: u32 = 0x827E20B0;
    'dispatch: loop {
        match pc {
            0x827E20B0 => {
    //   block [0x827E20B0..0x827E21DC)
	// 827E20B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E20B4: 489C60B1  bl 0x831a8164
	ctx.lr = 0x827E20B8;
	sub_831A8130(ctx, base);
	// 827E20B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E20BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E20C0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827E20C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E20C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E20CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827E20D0: 4BFFF469  bl 0x827e1538
	ctx.lr = 0x827E20D4;
	sub_827E1538(ctx, base);
	// 827E20D4: 8961005C  lbz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E20D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E20DC: 418200B4  beq 0x827e2190
	if ctx.cr[0].eq {
	pc = 0x827E2190; continue 'dispatch;
	}
	// 827E20E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E20E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E20E8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E20EC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E20F0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E20F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E20F8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E20FC: 4BBBEF5D  bl 0x823a1058
	ctx.lr = 0x827E2100;
	sub_823A1058(ctx, base);
	// 827E2100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2104: 4BFFF24D  bl 0x827e1350
	ctx.lr = 0x827E2108;
	sub_827E1350(ctx, base);
	// 827E2108: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E210C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E2110: 419A0028  beq cr6, 0x827e2138
	if ctx.cr[6].eq {
	pc = 0x827E2138; continue 'dispatch;
	}
	// 827E2114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E2118: 4BBBEF99  bl 0x823a10b0
	ctx.lr = 0x827E211C;
	sub_823A10B0(ctx, base);
	// 827E211C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2120: 41820018  beq 0x827e2138
	if ctx.cr[0].eq {
	pc = 0x827E2138; continue 'dispatch;
	}
	// 827E2124: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2128: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E212C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E2134: 4E800421  bctrl
	ctx.lr = 0x827E2138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E2138: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E213C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2140: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2144: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 827E2148: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827E214C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E2150: 9B810064  stb r28, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 827E2154: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827E2158: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E215C: 83C7001C  lwz r30, 0x1c(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E2160: 7D7F4214  add r11, r31, r8
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[8].u64;
	// 827E2164: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 827E2168: 7CFF5214  add r7, r31, r10
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 827E216C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E2170: A10B0030  lhz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E2174: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2178: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 827E217C: 4E800421  bctrl
	ctx.lr = 0x827E2180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E2180: 89610074  lbz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E2184: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2188: 41820008  beq 0x827e2190
	if ctx.cr[0].eq {
	pc = 0x827E2190; continue 'dispatch;
	}
	// 827E218C: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 827E2190: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2194: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E2198: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E219C: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E21A0: 419A0028  beq cr6, 0x827e21c8
	if ctx.cr[6].eq {
	pc = 0x827E21C8; continue 'dispatch;
	}
	// 827E21A4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E21A8: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E21AC: 7D6BE378  or r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[28].u64;
	// 827E21B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E21B4: 409A0008  bne cr6, 0x827e21bc
	if !ctx.cr[6].eq {
	pc = 0x827E21BC; continue 'dispatch;
	}
	// 827E21B8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 827E21BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E21C0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E21C4: 4BBCBCFD  bl 0x823adec0
	ctx.lr = 0x827E21C8;
	sub_823ADEC0(ctx, base);
	// 827E21C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E21CC: 4BBCEA35  bl 0x823b0c00
	ctx.lr = 0x827E21D0;
	sub_823B0C00(ctx, base);
	// 827E21D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E21D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827E21D8: 489C5FDC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E21E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E21E0 size=308
    let mut pc: u32 = 0x827E21E0;
    'dispatch: loop {
        match pc {
            0x827E21E0 => {
    //   block [0x827E21E0..0x827E2314)
	// 827E21E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E21E4: 489C5F85  bl 0x831a8168
	ctx.lr = 0x827E21E8;
	sub_831A8130(ctx, base);
	// 827E21E8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 827E21EC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E21F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E21F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827E21F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E21FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E2200: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827E2204: 4BFFF335  bl 0x827e1538
	ctx.lr = 0x827E2208;
	sub_827E1538(ctx, base);
	// 827E2208: 8961005C  lbz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E220C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2210: 418200B4  beq 0x827e22c4
	if ctx.cr[0].eq {
	pc = 0x827E22C4; continue 'dispatch;
	}
	// 827E2214: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E221C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2220: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 827E2224: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E222C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E2230: 4BBBEE29  bl 0x823a1058
	ctx.lr = 0x827E2234;
	sub_823A1058(ctx, base);
	// 827E2234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2238: 4BFFF119  bl 0x827e1350
	ctx.lr = 0x827E223C;
	sub_827E1350(ctx, base);
	// 827E223C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E2240: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E2244: 419A0028  beq cr6, 0x827e226c
	if ctx.cr[6].eq {
	pc = 0x827E226C; continue 'dispatch;
	}
	// 827E2248: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E224C: 4BBBEE65  bl 0x823a10b0
	ctx.lr = 0x827E2250;
	sub_823A10B0(ctx, base);
	// 827E2250: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2254: 41820018  beq 0x827e226c
	if ctx.cr[0].eq {
	pc = 0x827E226C; continue 'dispatch;
	}
	// 827E2258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E225C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E2260: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2264: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E2268: 4E800421  bctrl
	ctx.lr = 0x827E226C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E226C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2270: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827E2274: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2278: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E227C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827E2280: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E2284: 9B810064  stb r28, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 827E2288: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827E228C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2290: 7D7F4A14  add r11, r31, r9
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[9].u64;
	// 827E2294: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 827E2298: 8128000C  lwz r9, 0xc(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E229C: 7CFF5214  add r7, r31, r10
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 827E22A0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E22A4: A10B0030  lhz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E22A8: 794607E6  rldicr r6, r10, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E22AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827E22B0: 4E800421  bctrl
	ctx.lr = 0x827E22B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E22B4: 89610074  lbz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E22B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E22BC: 41820008  beq 0x827e22c4
	if ctx.cr[0].eq {
	pc = 0x827E22C4; continue 'dispatch;
	}
	// 827E22C0: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 827E22C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E22C8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E22CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E22D0: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E22D4: 419A0028  beq cr6, 0x827e22fc
	if ctx.cr[6].eq {
	pc = 0x827E22FC; continue 'dispatch;
	}
	// 827E22D8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E22DC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E22E0: 7D6BE378  or r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[28].u64;
	// 827E22E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E22E8: 409A0008  bne cr6, 0x827e22f0
	if !ctx.cr[6].eq {
	pc = 0x827E22F0; continue 'dispatch;
	}
	// 827E22EC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 827E22F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E22F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E22F8: 4BBCBBC9  bl 0x823adec0
	ctx.lr = 0x827E22FC;
	sub_823ADEC0(ctx, base);
	// 827E22FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E2300: 4BBCE901  bl 0x823b0c00
	ctx.lr = 0x827E2304;
	sub_823B0C00(ctx, base);
	// 827E2304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2308: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827E230C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 827E2310: 489C5EA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2318 size=180
    let mut pc: u32 = 0x827E2318;
    'dispatch: loop {
        match pc {
            0x827E2318 => {
    //   block [0x827E2318..0x827E23CC)
	// 827E2318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E231C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E2320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E2324: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E232C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E2330: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827E2334: 419A0028  beq cr6, 0x827e235c
	if ctx.cr[6].eq {
	pc = 0x827E235C; continue 'dispatch;
	}
	// 827E2338: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E233C: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 827E2340: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 827E2344: 394A574C  addi r10, r10, 0x574c
	ctx.r[10].s64 = ctx.r[10].s64 + 22348;
	// 827E2348: 3929D1F0  addi r9, r9, -0x2e10
	ctx.r[9].s64 = ctx.r[9].s64 + -11792;
	// 827E234C: 39085628  addi r8, r8, 0x5628
	ctx.r[8].s64 = ctx.r[8].s64 + 22056;
	// 827E2350: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E2354: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 827E2358: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 827E235C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2360: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827E2364: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2368: 39295638  addi r9, r9, 0x5638
	ctx.r[9].s64 = ctx.r[9].s64 + 22072;
	// 827E236C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2370: 7D2AF92E  stwx r9, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 827E2374: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2378: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E237C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2380: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2384: 4BFFEF4D  bl 0x827e12d0
	ctx.lr = 0x827E2388;
	sub_827E12D0(ctx, base);
	// 827E2388: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E238C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 827E2390: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E2394: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827E2398: 394A5630  addi r10, r10, 0x5630
	ctx.r[10].s64 = ctx.r[10].s64 + 22064;
	// 827E239C: 39295640  addi r9, r9, 0x5640
	ctx.r[9].s64 = ctx.r[9].s64 + 22080;
	// 827E23A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E23A4: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E23A8: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 827E23AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E23B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E23B4: 7D2BF92E  stwx r9, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 827E23B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E23BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E23C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E23C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E23C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E23D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E23D0 size=136
    let mut pc: u32 = 0x827E23D0;
    'dispatch: loop {
        match pc {
            0x827E23D0 => {
    //   block [0x827E23D0..0x827E2458)
	// 827E23D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E23D4: 489C5D8D  bl 0x831a8160
	ctx.lr = 0x827E23D8;
	sub_831A8130(ctx, base);
	// 827E23D8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E23DC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E23E0: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 827E23E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E23E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E23EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E23F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E23F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E23F8: 80DC0010  lwz r6, 0x10(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E23FC: 38ABD1F8  addi r5, r11, -0x2e08
	ctx.r[5].s64 = ctx.r[11].s64 + -11784;
	// 827E2400: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E2404: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 827E2408: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 827E240C: 4BBCBE7D  bl 0x823ae288
	ctx.lr = 0x827E2410;
	sub_823AE288(ctx, base);
	// 827E2410: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E2414: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 827E2418: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E241C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827E2420: 489C67A1  bl 0x831a8bc0
	ctx.lr = 0x827E2424;
	sub_831A8BC0(ctx, base);
	// 827E2424: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 827E2428: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E242C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2430: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 827E2434: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E2438: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E243C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E2440: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2448: 4BFFF9A1  bl 0x827e1de8
	ctx.lr = 0x827E244C;
	sub_827E1DE8(ctx, base);
	// 827E244C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2450: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E2454: 489C5D5C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2458 size=136
    let mut pc: u32 = 0x827E2458;
    'dispatch: loop {
        match pc {
            0x827E2458 => {
    //   block [0x827E2458..0x827E24E0)
	// 827E2458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E245C: 489C5D05  bl 0x831a8160
	ctx.lr = 0x827E2460;
	sub_831A8130(ctx, base);
	// 827E2460: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2464: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E2468: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 827E246C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E2470: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E2474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2478: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E247C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E2480: 80DC0010  lwz r6, 0x10(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E2484: 38ABD1FC  addi r5, r11, -0x2e04
	ctx.r[5].s64 = ctx.r[11].s64 + -11780;
	// 827E2488: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E248C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 827E2490: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 827E2494: 4BBCBDF5  bl 0x823ae288
	ctx.lr = 0x827E2498;
	sub_823AE288(ctx, base);
	// 827E2498: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E249C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 827E24A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E24A4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827E24A8: 489C6719  bl 0x831a8bc0
	ctx.lr = 0x827E24AC;
	sub_831A8BC0(ctx, base);
	// 827E24AC: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 827E24B0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E24B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E24B8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 827E24BC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E24C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E24C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E24C8: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E24CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E24D0: 4BFFF919  bl 0x827e1de8
	ctx.lr = 0x827E24D4;
	sub_827E1DE8(ctx, base);
	// 827E24D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E24D8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E24DC: 489C5CD4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E24E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E24E0 size=136
    let mut pc: u32 = 0x827E24E0;
    'dispatch: loop {
        match pc {
            0x827E24E0 => {
    //   block [0x827E24E0..0x827E2568)
	// 827E24E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E24E4: 489C5C7D  bl 0x831a8160
	ctx.lr = 0x827E24E8;
	sub_831A8130(ctx, base);
	// 827E24E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E24EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E24F0: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 827E24F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E24F8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E24FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2500: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E2504: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E2508: 80DC0010  lwz r6, 0x10(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E250C: 38ABD200  addi r5, r11, -0x2e00
	ctx.r[5].s64 = ctx.r[11].s64 + -11776;
	// 827E2510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E2514: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 827E2518: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 827E251C: 4BBCBD6D  bl 0x823ae288
	ctx.lr = 0x827E2520;
	sub_823AE288(ctx, base);
	// 827E2520: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E2524: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 827E2528: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E252C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827E2530: 489C6691  bl 0x831a8bc0
	ctx.lr = 0x827E2534;
	sub_831A8BC0(ctx, base);
	// 827E2534: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 827E2538: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E253C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2540: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 827E2544: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E2548: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E254C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E2550: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2554: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2558: 4BFFF891  bl 0x827e1de8
	ctx.lr = 0x827E255C;
	sub_827E1DE8(ctx, base);
	// 827E255C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2560: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E2564: 489C5C4C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2568 size=136
    let mut pc: u32 = 0x827E2568;
    'dispatch: loop {
        match pc {
            0x827E2568 => {
    //   block [0x827E2568..0x827E25F0)
	// 827E2568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E256C: 489C5BF5  bl 0x831a8160
	ctx.lr = 0x827E2570;
	sub_831A8130(ctx, base);
	// 827E2570: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2574: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E2578: F8C10108  std r6, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[6].u64 ) };
	// 827E257C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E2580: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E2584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2588: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E258C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E2590: 80DC0010  lwz r6, 0x10(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E2594: 38ABD204  addi r5, r11, -0x2dfc
	ctx.r[5].s64 = ctx.r[11].s64 + -11772;
	// 827E2598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E259C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 827E25A0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 827E25A4: 4BBCBCE5  bl 0x823ae288
	ctx.lr = 0x827E25A8;
	sub_823AE288(ctx, base);
	// 827E25A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E25AC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 827E25B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E25B4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827E25B8: 489C6609  bl 0x831a8bc0
	ctx.lr = 0x827E25BC;
	sub_831A8BC0(ctx, base);
	// 827E25BC: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 827E25C0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E25C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E25C8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 827E25CC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E25D0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E25D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E25D8: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E25DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E25E0: 4BFFF809  bl 0x827e1de8
	ctx.lr = 0x827E25E4;
	sub_827E1DE8(ctx, base);
	// 827E25E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E25E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E25EC: 489C5BC4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E25F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E25F0 size=396
    let mut pc: u32 = 0x827E25F0;
    'dispatch: loop {
        match pc {
            0x827E25F0 => {
    //   block [0x827E25F0..0x827E277C)
	// 827E25F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E25F4: 489C5B61  bl 0x831a8154
	ctx.lr = 0x827E25F8;
	sub_831A8130(ctx, base);
	// 827E25F8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 827E25FC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2600: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827E2604: F8C10178  std r6, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[6].u64 ) };
	// 827E2608: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E260C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827E2610: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 827E2614: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827E2618: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 827E261C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E2620: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E2624: 41990014  bgt cr6, 0x827e2638
	if ctx.cr[6].gt {
	pc = 0x827E2638; continue 'dispatch;
	}
	// 827E2628: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E262C: 554A04A5  rlwinm. r10, r10, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E2630: 40820008  bne 0x827e2638
	if !ctx.cr[0].eq {
	pc = 0x827E2638; continue 'dispatch;
	}
	// 827E2634: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 827E2638: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 827E263C: 3B600024  li r27, 0x24
	ctx.r[27].s64 = 36;
	// 827E2640: 41990008  bgt cr6, 0x827e2648
	if ctx.cr[6].gt {
	pc = 0x827E2648; continue 'dispatch;
	}
	// 827E2644: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 827E2648: 80DD0010  lwz r6, 0x10(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E264C: 7FFB5850  subf r31, r27, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 827E2650: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827E2654: 54CB04A6  rlwinm r11, r6, 0, 0x12, 0x13
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 827E2658: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827E265C: 2F0B2000  cmpwi cr6, r11, 0x2000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8192, &mut ctx.xer);
	// 827E2660: 409A00A8  bne cr6, 0x827e2708
	if !ctx.cr[6].eq {
	pc = 0x827E2708; continue 'dispatch;
	}
	// 827E2664: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E2668: C98BD228  lfd f12, -0x2dd8(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-11736 as u32) ) };
	// 827E266C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E2670: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 827E2674: 41980008  blt cr6, 0x827e267c
	if ctx.cr[6].lt {
	pc = 0x827E267C; continue 'dispatch;
	}
	// 827E2678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E267C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E2680: 41820008  beq 0x827e2688
	if ctx.cr[0].eq {
	pc = 0x827E2688; continue 'dispatch;
	}
	// 827E2684: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 827E2688: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E268C: C80AD220  lfd f0, -0x2de0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11744 as u32) ) };
	// 827E2690: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E2694: 41980024  blt cr6, 0x827e26b8
	if ctx.cr[6].lt {
	pc = 0x827E26B8; continue 'dispatch;
	}
	// 827E2698: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E269C: C9AAD218  lfd f13, -0x2de8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11752 as u32) ) };
	// 827E26A0: 2B1C1388  cmplwi cr6, r28, 0x1388
	ctx.cr[6].compare_u32(ctx.r[28].u32, 5000 as u32, &mut ctx.xer);
	// 827E26A4: 40980014  bge cr6, 0x827e26b8
	if !ctx.cr[6].lt {
	pc = 0x827E26B8; continue 'dispatch;
	}
	// 827E26A8: FFFF0372  fmul f31, f31, f13
	ctx.f[31].f64 = ctx.f[31].f64 * ctx.f[13].f64;
	// 827E26AC: 3B9C000A  addi r28, r28, 0xa
	ctx.r[28].s64 = ctx.r[28].s64 + 10;
	// 827E26B0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E26B4: 4098FFEC  bge cr6, 0x827e26a0
	if !ctx.cr[6].lt {
	pc = 0x827E26A0; continue 'dispatch;
	}
	// 827E26B8: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 827E26BC: 40990040  ble cr6, 0x827e26fc
	if !ctx.cr[6].gt {
	pc = 0x827E26FC; continue 'dispatch;
	}
	// 827E26C0: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 827E26C4: 41980038  blt cr6, 0x827e26fc
	if ctx.cr[6].lt {
	pc = 0x827E26FC; continue 'dispatch;
	}
	// 827E26C8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E26CC: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 827E26D0: C9AAD210  lfd f13, -0x2df0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11760 as u32) ) };
	// 827E26D4: C809D208  lfd f0, -0x2df8(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-11768 as u32) ) };
	// 827E26D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E26DC: 41990020  bgt cr6, 0x827e26fc
	if ctx.cr[6].gt {
	pc = 0x827E26FC; continue 'dispatch;
	}
	// 827E26E0: 2B1E1388  cmplwi cr6, r30, 0x1388
	ctx.cr[6].compare_u32(ctx.r[30].u32, 5000 as u32, &mut ctx.xer);
	// 827E26E4: 40980018  bge cr6, 0x827e26fc
	if !ctx.cr[6].lt {
	pc = 0x827E26FC; continue 'dispatch;
	}
	// 827E26E8: 3BFFFFF6  addi r31, r31, -0xa
	ctx.r[31].s64 = ctx.r[31].s64 + -10;
	// 827E26EC: FFFF0372  fmul f31, f31, f13
	ctx.f[31].f64 = ctx.f[31].f64 * ctx.f[13].f64;
	// 827E26F0: 3BDE000A  addi r30, r30, 0xa
	ctx.r[30].s64 = ctx.r[30].s64 + 10;
	// 827E26F4: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 827E26F8: 4098FFE0  bge cr6, 0x827e26d8
	if !ctx.cr[6].lt {
	pc = 0x827E26D8; continue 'dispatch;
	}
	// 827E26FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E2700: 419A0008  beq cr6, 0x827e2708
	if ctx.cr[6].eq {
	pc = 0x827E2708; continue 'dispatch;
	}
	// 827E2704: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 827E2708: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E270C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E2710: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E2714: 4BBCBADD  bl 0x823ae1f0
	ctx.lr = 0x827E2718;
	sub_823AE1F0(ctx, base);
	// 827E2718: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827E271C: D8210030  stfd f1, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[1].u64 ) };
	// 827E2720: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 827E2724: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E2728: 3880006C  li r4, 0x6c
	ctx.r[4].s64 = 108;
	// 827E272C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E2730: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827E2734: 489C648D  bl 0x831a8bc0
	ctx.lr = 0x827E2738;
	sub_831A8BC0(ctx, base);
	// 827E2738: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827E273C: 81610178  lwz r11, 0x178(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 827E2740: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 827E2744: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 827E2748: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 827E274C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 827E2750: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E2754: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827E2758: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827E275C: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E2760: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E2764: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E2768: 4BFFF069  bl 0x827e17d0
	ctx.lr = 0x827E276C;
	sub_827E17D0(ctx, base);
	// 827E276C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E2770: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 827E2774: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 827E2778: 489C5A2C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2780 size=396
    let mut pc: u32 = 0x827E2780;
    'dispatch: loop {
        match pc {
            0x827E2780 => {
    //   block [0x827E2780..0x827E290C)
	// 827E2780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2784: 489C59D1  bl 0x831a8154
	ctx.lr = 0x827E2788;
	sub_831A8130(ctx, base);
	// 827E2788: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 827E278C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2790: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827E2794: F8C10178  std r6, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[6].u64 ) };
	// 827E2798: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E279C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827E27A0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 827E27A4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827E27A8: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 827E27AC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E27B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E27B4: 41990014  bgt cr6, 0x827e27c8
	if ctx.cr[6].gt {
	pc = 0x827E27C8; continue 'dispatch;
	}
	// 827E27B8: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E27BC: 554A04A5  rlwinm. r10, r10, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E27C0: 40820008  bne 0x827e27c8
	if !ctx.cr[0].eq {
	pc = 0x827E27C8; continue 'dispatch;
	}
	// 827E27C4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 827E27C8: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 827E27CC: 3B600024  li r27, 0x24
	ctx.r[27].s64 = 36;
	// 827E27D0: 41990008  bgt cr6, 0x827e27d8
	if ctx.cr[6].gt {
	pc = 0x827E27D8; continue 'dispatch;
	}
	// 827E27D4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 827E27D8: 80DD0010  lwz r6, 0x10(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E27DC: 7FFB5850  subf r31, r27, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 827E27E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827E27E4: 54CB04A6  rlwinm r11, r6, 0, 0x12, 0x13
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 827E27E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827E27EC: 2F0B2000  cmpwi cr6, r11, 0x2000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8192, &mut ctx.xer);
	// 827E27F0: 409A00A8  bne cr6, 0x827e2898
	if !ctx.cr[6].eq {
	pc = 0x827E2898; continue 'dispatch;
	}
	// 827E27F4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E27F8: C98BD228  lfd f12, -0x2dd8(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-11736 as u32) ) };
	// 827E27FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E2800: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 827E2804: 41980008  blt cr6, 0x827e280c
	if ctx.cr[6].lt {
	pc = 0x827E280C; continue 'dispatch;
	}
	// 827E2808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E280C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E2810: 41820008  beq 0x827e2818
	if ctx.cr[0].eq {
	pc = 0x827E2818; continue 'dispatch;
	}
	// 827E2814: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 827E2818: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E281C: C80AD220  lfd f0, -0x2de0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11744 as u32) ) };
	// 827E2820: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E2824: 41980024  blt cr6, 0x827e2848
	if ctx.cr[6].lt {
	pc = 0x827E2848; continue 'dispatch;
	}
	// 827E2828: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E282C: C9AAD218  lfd f13, -0x2de8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11752 as u32) ) };
	// 827E2830: 2B1C1388  cmplwi cr6, r28, 0x1388
	ctx.cr[6].compare_u32(ctx.r[28].u32, 5000 as u32, &mut ctx.xer);
	// 827E2834: 40980014  bge cr6, 0x827e2848
	if !ctx.cr[6].lt {
	pc = 0x827E2848; continue 'dispatch;
	}
	// 827E2838: FFFF0372  fmul f31, f31, f13
	ctx.f[31].f64 = ctx.f[31].f64 * ctx.f[13].f64;
	// 827E283C: 3B9C000A  addi r28, r28, 0xa
	ctx.r[28].s64 = ctx.r[28].s64 + 10;
	// 827E2840: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E2844: 4098FFEC  bge cr6, 0x827e2830
	if !ctx.cr[6].lt {
	pc = 0x827E2830; continue 'dispatch;
	}
	// 827E2848: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 827E284C: 40990040  ble cr6, 0x827e288c
	if !ctx.cr[6].gt {
	pc = 0x827E288C; continue 'dispatch;
	}
	// 827E2850: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 827E2854: 41980038  blt cr6, 0x827e288c
	if ctx.cr[6].lt {
	pc = 0x827E288C; continue 'dispatch;
	}
	// 827E2858: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E285C: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 827E2860: C9AAD210  lfd f13, -0x2df0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-11760 as u32) ) };
	// 827E2864: C809D208  lfd f0, -0x2df8(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-11768 as u32) ) };
	// 827E2868: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827E286C: 41990020  bgt cr6, 0x827e288c
	if ctx.cr[6].gt {
	pc = 0x827E288C; continue 'dispatch;
	}
	// 827E2870: 2B1E1388  cmplwi cr6, r30, 0x1388
	ctx.cr[6].compare_u32(ctx.r[30].u32, 5000 as u32, &mut ctx.xer);
	// 827E2874: 40980018  bge cr6, 0x827e288c
	if !ctx.cr[6].lt {
	pc = 0x827E288C; continue 'dispatch;
	}
	// 827E2878: 3BFFFFF6  addi r31, r31, -0xa
	ctx.r[31].s64 = ctx.r[31].s64 + -10;
	// 827E287C: FFFF0372  fmul f31, f31, f13
	ctx.f[31].f64 = ctx.f[31].f64 * ctx.f[13].f64;
	// 827E2880: 3BDE000A  addi r30, r30, 0xa
	ctx.r[30].s64 = ctx.r[30].s64 + 10;
	// 827E2884: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 827E2888: 4098FFE0  bge cr6, 0x827e2868
	if !ctx.cr[6].lt {
	pc = 0x827E2868; continue 'dispatch;
	}
	// 827E288C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E2890: 419A0008  beq cr6, 0x827e2898
	if ctx.cr[6].eq {
	pc = 0x827E2898; continue 'dispatch;
	}
	// 827E2894: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 827E2898: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 827E289C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E28A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E28A4: 4BBCB94D  bl 0x823ae1f0
	ctx.lr = 0x827E28A8;
	sub_823AE1F0(ctx, base);
	// 827E28A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827E28AC: D8210030  stfd f1, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[1].u64 ) };
	// 827E28B0: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 827E28B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E28B8: 3880006C  li r4, 0x6c
	ctx.r[4].s64 = 108;
	// 827E28BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E28C0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827E28C4: 489C62FD  bl 0x831a8bc0
	ctx.lr = 0x827E28C8;
	sub_831A8BC0(ctx, base);
	// 827E28C8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827E28CC: 81610178  lwz r11, 0x178(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 827E28D0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 827E28D4: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 827E28D8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 827E28DC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 827E28E0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E28E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827E28E8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827E28EC: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E28F0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E28F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E28F8: 4BFFEED9  bl 0x827e17d0
	ctx.lr = 0x827E28FC;
	sub_827E17D0(ctx, base);
	// 827E28FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E2900: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 827E2904: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 827E2908: 489C589C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2910 size=112
    let mut pc: u32 = 0x827E2910;
    'dispatch: loop {
        match pc {
            0x827E2910 => {
    //   block [0x827E2910..0x827E2980)
	// 827E2910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2914: 489C5851  bl 0x831a8164
	ctx.lr = 0x827E2918;
	sub_831A8130(ctx, base);
	// 827E2918: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E291C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E2920: F8C100E8  std r6, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[6].u64 ) };
	// 827E2924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2928: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E292C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E2930: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 827E2934: 38ABD230  addi r5, r11, -0x2dd0
	ctx.r[5].s64 = ctx.r[11].s64 + -11728;
	// 827E2938: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 827E293C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2940: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E2944: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 827E2948: 489C6279  bl 0x831a8bc0
	ctx.lr = 0x827E294C;
	sub_831A8BC0(ctx, base);
	// 827E294C: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 827E2950: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827E2954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2958: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 827E295C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E2960: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E2964: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E2968: 796607E6  rldicr r6, r11, 0x20, 0x3f
	ctx.r[6].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 827E296C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2970: 4BFFF479  bl 0x827e1de8
	ctx.lr = 0x827E2974;
	sub_827E1DE8(ctx, base);
	// 827E2974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2978: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827E297C: 489C5838  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2980 size=392
    let mut pc: u32 = 0x827E2980;
    'dispatch: loop {
        match pc {
            0x827E2980 => {
    //   block [0x827E2980..0x827E2B08)
	// 827E2980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2984: 489C57E1  bl 0x831a8164
	ctx.lr = 0x827E2988;
	sub_831A8130(ctx, base);
	// 827E2988: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E298C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E2990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E2998: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 827E299C: 489C672D  bl 0x831a90c8
	ctx.lr = 0x827E29A0;
	sub_831A90C8(ctx, base);
	// 827E29A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E29A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E29A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E29AC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E29B0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E29B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E29B8: 40990010  ble cr6, 0x827e29c8
	if !ctx.cr[6].gt {
	pc = 0x827E29C8; continue 'dispatch;
	}
	// 827E29BC: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 827E29C0: 7F9E5850  subf r28, r30, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827E29C4: 41990008  bgt cr6, 0x827e29cc
	if ctx.cr[6].gt {
	pc = 0x827E29CC; continue 'dispatch;
	}
	// 827E29C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827E29CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E29D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E29D4: 4BFFEB65  bl 0x827e1538
	ctx.lr = 0x827E29D8;
	sub_827E1538(ctx, base);
	// 827E29D8: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E29DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E29E0: 4082000C  bne 0x827e29ec
	if !ctx.cr[0].eq {
	pc = 0x827E29EC; continue 'dispatch;
	}
	// 827E29E4: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 827E29E8: 480000D4  b 0x827e2abc
	pc = 0x827E2ABC; continue 'dispatch;
	// 827E29EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E29F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E29F4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E29F8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E29FC: 556B05F2  rlwinm r11, r11, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827E2A00: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 827E2A04: 419A0038  beq cr6, 0x827e2a3c
	if ctx.cr[6].eq {
	pc = 0x827E2A3C; continue 'dispatch;
	}
	// 827E2A08: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E2A0C: 40990030  ble cr6, 0x827e2a3c
	if !ctx.cr[6].gt {
	pc = 0x827E2A3C; continue 'dispatch;
	}
	// 827E2A10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2A14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2A18: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2A1C: A08B0030  lhz r4, 0x30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E2A20: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E2A24: 4BFFCEBD  bl 0x827df8e0
	ctx.lr = 0x827E2A28;
	sub_827DF8E0(ctx, base);
	// 827E2A28: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 827E2A2C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 827E2A30: 419A0074  beq cr6, 0x827e2aa4
	if ctx.cr[6].eq {
	pc = 0x827E2AA4; continue 'dispatch;
	}
	// 827E2A34: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E2A38: 4181FFD8  bgt 0x827e2a10
	if ctx.cr[0].gt {
	pc = 0x827E2A10; continue 'dispatch;
	}
	// 827E2A3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2A40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E2A44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E2A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2A4C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2A50: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E2A54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2A58: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827E2A5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E2A60: 4E800421  bctrl
	ctx.lr = 0x827E2A64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E2A64: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 827E2A68: 409A003C  bne cr6, 0x827e2aa4
	if !ctx.cr[6].eq {
	pc = 0x827E2AA4; continue 'dispatch;
	}
	// 827E2A6C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E2A70: 40990038  ble cr6, 0x827e2aa8
	if !ctx.cr[6].gt {
	pc = 0x827E2AA8; continue 'dispatch;
	}
	// 827E2A74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2A78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2A7C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2A80: A08B0030  lhz r4, 0x30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E2A84: 806B0028  lwz r3, 0x28(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E2A88: 4BFFCE59  bl 0x827df8e0
	ctx.lr = 0x827E2A8C;
	sub_827DF8E0(ctx, base);
	// 827E2A8C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 827E2A90: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 827E2A94: 419A0010  beq cr6, 0x827e2aa4
	if ctx.cr[6].eq {
	pc = 0x827E2AA4; continue 'dispatch;
	}
	// 827E2A98: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E2A9C: 4181FFD8  bgt 0x827e2a74
	if ctx.cr[0].gt {
	pc = 0x827E2A74; continue 'dispatch;
	}
	// 827E2AA0: 48000008  b 0x827e2aa8
	pc = 0x827E2AA8; continue 'dispatch;
	// 827E2AA4: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 827E2AA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2AAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E2AB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2AB4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2AB8: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 827E2ABC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2AC0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 827E2AC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2AC8: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E2ACC: 419A0028  beq cr6, 0x827e2af4
	if ctx.cr[6].eq {
	pc = 0x827E2AF4; continue 'dispatch;
	}
	// 827E2AD0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E2AD4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827E2AD8: 7D6BDB78  or r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[27].u64;
	// 827E2ADC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E2AE0: 409A0008  bne cr6, 0x827e2ae8
	if !ctx.cr[6].eq {
	pc = 0x827E2AE8; continue 'dispatch;
	}
	// 827E2AE4: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 827E2AE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2AEC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E2AF0: 4BBCB3D1  bl 0x823adec0
	ctx.lr = 0x827E2AF4;
	sub_823ADEC0(ctx, base);
	// 827E2AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2AF8: 4BBCE109  bl 0x823b0c00
	ctx.lr = 0x827E2AFC;
	sub_823B0C00(ctx, base);
	// 827E2AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2B00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827E2B04: 489C56B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E2B08 size=128
    let mut pc: u32 = 0x827E2B08;
    'dispatch: loop {
        match pc {
            0x827E2B08 => {
    //   block [0x827E2B08..0x827E2B88)
	// 827E2B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2B0C: 489C5661  bl 0x831a816c
	ctx.lr = 0x827E2B10;
	sub_831A8130(ctx, base);
	// 827E2B10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E2B18: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E2B1C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827E2B20: 419A0028  beq cr6, 0x827e2b48
	if ctx.cr[6].eq {
	pc = 0x827E2B48; continue 'dispatch;
	}
	// 827E2B24: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 827E2B28: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 827E2B2C: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827E2B30: 396B15FC  addi r11, r11, 0x15fc
	ctx.r[11].s64 = ctx.r[11].s64 + 5628;
	// 827E2B34: 394A15F4  addi r10, r10, 0x15f4
	ctx.r[10].s64 = ctx.r[10].s64 + 5620;
	// 827E2B38: 39295628  addi r9, r9, 0x5628
	ctx.r[9].s64 = ctx.r[9].s64 + 22056;
	// 827E2B3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E2B40: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E2B44: 913F0054  stw r9, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 827E2B48: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 827E2B4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2B50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2B58: 4BFFF7C1  bl 0x827e2318
	ctx.lr = 0x827E2B5C;
	sub_827E2318(ctx, base);
	// 827E2B5C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2B60: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E2B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E2B68: 396B56C0  addi r11, r11, 0x56c0
	ctx.r[11].s64 = ctx.r[11].s64 + 22208;
	// 827E2B6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E2B70: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2B74: 7D6AF92E  stwx r11, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 827E2B78: 4BFFD661  bl 0x827e01d8
	ctx.lr = 0x827E2B7C;
	sub_827E01D8(ctx, base);
	// 827E2B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E2B80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E2B84: 489C5638  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E2B88 size=600
    let mut pc: u32 = 0x827E2B88;
    'dispatch: loop {
        match pc {
            0x827E2B88 => {
    //   block [0x827E2B88..0x827E2DE0)
	// 827E2B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2B8C: 489C55E1  bl 0x831a816c
	ctx.lr = 0x827E2B90;
	sub_831A8130(ctx, base);
	// 827E2B90: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E2B94: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E2B98: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827E2B9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E2BA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827E2BA4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 827E2BA8: 896BB862  lbz r11, -0x479e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-18334 as u32) ) } as u64;
	// 827E2BAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2BB0: 408200D4  bne 0x827e2c84
	if !ctx.cr[0].eq {
	pc = 0x827E2C84; continue 'dispatch;
	}
	// 827E2BB4: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 827E2BB8: 4BFFFF51  bl 0x827e2b08
	ctx.lr = 0x827E2BBC;
	sub_827E2B08(ctx, base);
	// 827E2BBC: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 827E2BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2BC4: 4860EF25  bl 0x82df1ae8
	ctx.lr = 0x827E2BC8;
	sub_82DF1AE8(ctx, base);
	// 827E2BC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E2BCC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 827E2BD0: 4BFFC769  bl 0x827df338
	ctx.lr = 0x827E2BD4;
	sub_827DF338(ctx, base);
	// 827E2BD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E2BD8: 4082000C  bne 0x827e2be4
	if !ctx.cr[0].eq {
	pc = 0x827E2BE4; continue 'dispatch;
	}
	// 827E2BDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E2BE0: 48000010  b 0x827e2bf0
	pc = 0x827E2BF0; continue 'dispatch;
	// 827E2BE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2BEC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 827E2BF0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E2BF4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E2BF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E2BFC: 512A3DF2  rlwimi r10, r9, 7, 0x17, 0x19
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(7) as u64) & 0x00000000000001C0) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFE3F);
	// 827E2C00: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 827E2C04: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 827E2C08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2C0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2C10: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 827E2C14: B12B0030  sth r9, 0x30(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[9].u16 ) };
	// 827E2C18: 4BFFF499  bl 0x827e20b0
	ctx.lr = 0x827E2C1C;
	sub_827E20B0(ctx, base);
	// 827E2C1C: 3881014C  addi r4, r1, 0x14c
	ctx.r[4].s64 = ctx.r[1].s64 + 332;
	// 827E2C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E2C24: 4BFFDCB5  bl 0x827e08d8
	ctx.lr = 0x827E2C28;
	sub_827E08D8(ctx, base);
	// 827E2C28: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E2C2C: 37EBFFFD  addic. r31, r11, -3
	ctx.xer.ca = (ctx.r[11].u32 > (!(-3 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -3;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E2C30: 40810030  ble 0x827e2c60
	if !ctx.cr[0].gt {
	pc = 0x827E2C60; continue 'dispatch;
	}
	// 827E2C34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E2C38: 3BCB989C  addi r30, r11, -0x6764
	ctx.r[30].s64 = ctx.r[11].s64 + -26468;
	// 827E2C3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E2C40: 489C6489  bl 0x831a90c8
	ctx.lr = 0x827E2C44;
	sub_831A90C8(ctx, base);
	// 827E2C44: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 827E2C48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E2C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E2C50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E2C54: 4BFF93FD  bl 0x827dc050
	ctx.lr = 0x827E2C58;
	sub_827DC050(ctx, base);
	// 827E2C58: 37FFFFFD  addic. r31, r31, -3
	ctx.xer.ca = (ctx.r[31].u32 > (!(-3 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -3;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E2C5C: 4181FFE0  bgt 0x827e2c3c
	if ctx.cr[0].gt {
	pc = 0x827E2C3C; continue 'dispatch;
	}
	// 827E2C60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E2C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E2C68: 4BAE71F1  bl 0x822c9e58
	ctx.lr = 0x827E2C6C;
	sub_822C9E58(ctx, base);
	// 827E2C6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2C70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E2C74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E2C78: 4BAE61B9  bl 0x822c8e30
	ctx.lr = 0x827E2C7C;
	sub_822C8E30(ctx, base);
	// 827E2C7C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 827E2C80: 48000150  b 0x827e2dd0
	pc = 0x827E2DD0; continue 'dispatch;
	// 827E2C84: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E2C88: 4BFFFE81  bl 0x827e2b08
	ctx.lr = 0x827E2C8C;
	sub_827E2B08(ctx, base);
	// 827E2C8C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E2C90: 396100B8  addi r11, r1, 0xb8
	ctx.r[11].s64 = ctx.r[1].s64 + 184;
	// 827E2C94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827E2C98: 392100B8  addi r9, r1, 0xb8
	ctx.r[9].s64 = ctx.r[1].s64 + 184;
	// 827E2C9C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 827E2CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E2CA4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2CA8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827E2CAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E2CB0: 510A3DF2  rlwimi r10, r8, 7, 0x17, 0x19
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(7) as u64) & 0x00000000000001C0) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFE3F);
	// 827E2CB4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 827E2CB8: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E2CBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2CC0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 827E2CC4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E2CC8: 510A6CA6  rlwimi r10, r8, 0xd, 0x12, 0x13
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(13) as u64) & 0x0000000000003000) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFCFFF);
	// 827E2CCC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 827E2CD0: 4860EE19  bl 0x82df1ae8
	ctx.lr = 0x827E2CD4;
	sub_82DF1AE8(ctx, base);
	// 827E2CD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E2CD8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 827E2CDC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E2CE0: 4860EDF1  bl 0x82df1ad0
	ctx.lr = 0x827E2CE4;
	sub_82DF1AD0(ctx, base);
	// 827E2CE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E2CE8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 827E2CEC: 4BFFC64D  bl 0x827df338
	ctx.lr = 0x827E2CF0;
	sub_827DF338(ctx, base);
	// 827E2CF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E2CF4: 4BFFC645  bl 0x827df338
	ctx.lr = 0x827E2CF8;
	sub_827DF338(ctx, base);
	// 827E2CF8: 7FEBFE70  srawi r11, r31, 0x1f
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 31) as i64;
	// 827E2CFC: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E2D00: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 827E2D04: 7FEA5A78  xor r10, r31, r11
	ctx.r[10].u64 = ctx.r[31].u64 ^ ctx.r[11].u64;
	// 827E2D08: 3D000010  lis r8, 0x10
	ctx.r[8].s64 = 1048576;
	// 827E2D0C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827E2D10: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E2D14: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 827E2D18: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 827E2D1C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 827E2D20: B12A0030  sth r9, 0x30(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[9].u16 ) };
	// 827E2D24: 4099002C  ble cr6, 0x827e2d50
	if !ctx.cr[6].gt {
	pc = 0x827E2D50; continue 'dispatch;
	}
	// 827E2D28: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 827E2D2C: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E2D30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827E2D34: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E2D38: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 827E2D3C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E2D40: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 827E2D44: C00A5768  lfs f0, 0x5768(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E2D48: 3BEB5760  addi r31, r11, 0x5760
	ctx.r[31].s64 = ctx.r[11].s64 + 22368;
	// 827E2D4C: 48000030  b 0x827e2d7c
	pc = 0x827E2D7C; continue 'dispatch;
	// 827E2D50: 2F0B0400  cmpwi cr6, r11, 0x400
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1024, &mut ctx.xer);
	// 827E2D54: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 827E2D58: 40990038  ble cr6, 0x827e2d90
	if !ctx.cr[6].gt {
	pc = 0x827E2D90; continue 'dispatch;
	}
	// 827E2D5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827E2D60: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E2D64: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 827E2D68: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E2D6C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E2D70: C00A575C  lfs f0, 0x575c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E2D74: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 827E2D78: 3BEB5754  addi r31, r11, 0x5754
	ctx.r[31].s64 = ctx.r[11].s64 + 22356;
	// 827E2D7C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 827E2D80: 4BFFF461  bl 0x827e21e0
	ctx.lr = 0x827E2D84;
	sub_827E21E0(ctx, base);
	// 827E2D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E2D88: 4BFFFBF9  bl 0x827e2980
	ctx.lr = 0x827E2D8C;
	sub_827E2980(ctx, base);
	// 827E2D8C: 48000018  b 0x827e2da4
	pc = 0x827E2DA4; continue 'dispatch;
	// 827E2D90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827E2D94: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E2D98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 827E2D9C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 827E2DA0: 4BFFF441  bl 0x827e21e0
	ctx.lr = 0x827E2DA4;
	sub_827E21E0(ctx, base);
	// 827E2DA4: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 827E2DA8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E2DAC: 4BFFDB2D  bl 0x827e08d8
	ctx.lr = 0x827E2DB0;
	sub_827E08D8(ctx, base);
	// 827E2DB0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827E2DB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E2DB8: 4BAE70A1  bl 0x822c9e58
	ctx.lr = 0x827E2DBC;
	sub_822C9E58(ctx, base);
	// 827E2DBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E2DC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E2DC4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E2DC8: 4BAE6069  bl 0x822c8e30
	ctx.lr = 0x827E2DCC;
	sub_822C8E30(ctx, base);
	// 827E2DCC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E2DD0: 4BFFD569  bl 0x827e0338
	ctx.lr = 0x827E2DD4;
	sub_827E0338(ctx, base);
	// 827E2DD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E2DD8: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 827E2DDC: 489C53E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E2DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E2DE0 size=2088
    let mut pc: u32 = 0x827E2DE0;
    'dispatch: loop {
        match pc {
            0x827E2DE0 => {
    //   block [0x827E2DE0..0x827E3608)
	// 827E2DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E2DE4: 489C536D  bl 0x831a8150
	ctx.lr = 0x827E2DE8;
	sub_831A8130(ctx, base);
	// 827E2DE8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 827E2DEC: 489C5C6D  bl 0x831a8a58
	ctx.lr = 0x827E2DF0;
	sub_831A8A40(ctx, base);
	// 827E2DF0: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3608 size=636
    let mut pc: u32 = 0x827E3608;
    'dispatch: loop {
        match pc {
            0x827E3608 => {
    //   block [0x827E3608..0x827E3884)
	// 827E3608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E360C: 489C4B4D  bl 0x831a8158
	ctx.lr = 0x827E3610;
	sub_831A8130(ctx, base);
	// 827E3610: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3614: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E3618: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827E361C: 396B5128  addi r11, r11, 0x5128
	ctx.r[11].s64 = ctx.r[11].s64 + 20776;
	// 827E3620: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827E3624: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827E3628: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 827E362C: 3B200052  li r25, 0x52
	ctx.r[25].s64 = 82;
	// 827E3630: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 827E3634: 817EFFFC  lwz r11, -4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 827E3638: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 827E363C: 409A0234  bne cr6, 0x827e3870
	if !ctx.cr[6].eq {
	pc = 0x827E3870; continue 'dispatch;
	}
	// 827E3640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3644: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3648: 486103C1  bl 0x82df3a08
	ctx.lr = 0x827E364C;
	sub_82DF3A08(ctx, base);
	// 827E364C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827E3650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E3654: 48615CB5  bl 0x82df9308
	ctx.lr = 0x827E3658;
	sub_82DF9308(ctx, base);
	// 827E3658: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E365C: 4860FDCD  bl 0x82df3428
	ctx.lr = 0x827E3660;
	sub_82DF3428(ctx, base);
	// 827E3660: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E3664: 4BADD2D5  bl 0x822c0938
	ctx.lr = 0x827E3668;
	sub_822C0938(ctx, base);
	// 827E3668: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E366C: 41820028  beq 0x827e3694
	if ctx.cr[0].eq {
	pc = 0x827E3694; continue 'dispatch;
	}
	// 827E3670: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E3674: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3678: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 827E367C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3680: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 827E3684: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827E3688: 4BFFB8D9  bl 0x827def60
	ctx.lr = 0x827E368C;
	sub_827DEF60(ctx, base);
	// 827E368C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E3690: 48000008  b 0x827e3698
	pc = 0x827E3698; continue 'dispatch;
	// 827E3694: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E3698: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827E369C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E36A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E36A4: 4BFFBA3D  bl 0x827df0e0
	ctx.lr = 0x827E36A8;
	sub_827DF0E0(ctx, base);
	// 827E36A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E36B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E36B4: 4BADC94D  bl 0x822c0000
	ctx.lr = 0x827E36B8;
	sub_822C0000(ctx, base);
	// 827E36B8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E36BC: 38DA0001  addi r6, r26, 1
	ctx.r[6].s64 = ctx.r[26].s64 + 1;
	// 827E36C0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E36C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E36C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E36CC: 4BFFFF3D  bl 0x827e3608
	ctx.lr = 0x827E36D0;
	sub_827E3608(ctx, base);
	// 827E36D0: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E36D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E36D8: 419A00AC  beq cr6, 0x827e3784
	if ctx.cr[6].eq {
	pc = 0x827E3784; continue 'dispatch;
	}
	// 827E36DC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E36E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E36E4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 827E36E8: 419A0024  beq cr6, 0x827e370c
	if ctx.cr[6].eq {
	pc = 0x827E370C; continue 'dispatch;
	}
	// 827E36EC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 827E36F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E36F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E36F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E36FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3708: 4082FFE8  bne 0x827e36f0
	if !ctx.cr[0].eq {
	pc = 0x827E36F0; continue 'dispatch;
	}
	// 827E370C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E3710: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3714: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E3718: 4BCA94F9  bl 0x8248cc10
	ctx.lr = 0x827E371C;
	sub_8248CC10(ctx, base);
	// 827E371C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E3720: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3724: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E372C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 827E3730: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 827E3734: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 827E3738: 419A0024  beq cr6, 0x827e375c
	if ctx.cr[6].eq {
	pc = 0x827E375C; continue 'dispatch;
	}
	// 827E373C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E3740: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3744: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3748: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E374C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3750: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3754: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3758: 4082FFE8  bne 0x827e3740
	if !ctx.cr[0].eq {
	pc = 0x827E3740; continue 'dispatch;
	}
	// 827E375C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827E3760: 389C0014  addi r4, r28, 0x14
	ctx.r[4].s64 = ctx.r[28].s64 + 20;
	// 827E3764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E3768: 4BFFA799  bl 0x827ddf00
	ctx.lr = 0x827E376C;
	sub_827DDF00(ctx, base);
	// 827E376C: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827E3770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3774: 419A0008  beq cr6, 0x827e377c
	if ctx.cr[6].eq {
	pc = 0x827E377C; continue 'dispatch;
	}
	// 827E3778: 4BADD119  bl 0x822c0890
	ctx.lr = 0x827E377C;
	sub_822C0890(ctx, base);
	// 827E377C: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 827E3780: 480000A8  b 0x827e3828
	pc = 0x827E3828; continue 'dispatch;
	// 827E3784: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827E3788: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E378C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 827E3790: 419A0024  beq cr6, 0x827e37b4
	if ctx.cr[6].eq {
	pc = 0x827E37B4; continue 'dispatch;
	}
	// 827E3794: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 827E3798: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E379C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E37A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E37A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E37A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E37AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E37B0: 4082FFE8  bne 0x827e3798
	if !ctx.cr[0].eq {
	pc = 0x827E3798; continue 'dispatch;
	}
	// 827E37B4: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 827E37B8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E37BC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E37C0: 4BCA9451  bl 0x8248cc10
	ctx.lr = 0x827E37C4;
	sub_8248CC10(ctx, base);
	// 827E37C4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E37C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E37CC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E37D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E37D4: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 827E37D8: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 827E37DC: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 827E37E0: 419A0024  beq cr6, 0x827e3804
	if ctx.cr[6].eq {
	pc = 0x827E3804; continue 'dispatch;
	}
	// 827E37E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E37E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E37EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E37F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E37F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E37F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E37FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3800: 4082FFE8  bne 0x827e37e8
	if !ctx.cr[0].eq {
	pc = 0x827E37E8; continue 'dispatch;
	}
	// 827E3804: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 827E3808: 389B00A0  addi r4, r27, 0xa0
	ctx.r[4].s64 = ctx.r[27].s64 + 160;
	// 827E380C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827E3810: 4BFFA6F1  bl 0x827ddf00
	ctx.lr = 0x827E3814;
	sub_827DDF00(ctx, base);
	// 827E3814: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E3818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E381C: 419A0008  beq cr6, 0x827e3824
	if ctx.cr[6].eq {
	pc = 0x827E3824; continue 'dispatch;
	}
	// 827E3820: 4BADD071  bl 0x822c0890
	ctx.lr = 0x827E3824;
	sub_822C0890(ctx, base);
	// 827E3824: 806100B8  lwz r3, 0xb8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E3828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E382C: 419A0008  beq cr6, 0x827e3834
	if ctx.cr[6].eq {
	pc = 0x827E3834; continue 'dispatch;
	}
	// 827E3830: 4BADD061  bl 0x822c0890
	ctx.lr = 0x827E3834;
	sub_822C0890(ctx, base);
	// 827E3834: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3838: 2B0B0048  cmplwi cr6, r11, 0x48
	ctx.cr[6].compare_u32(ctx.r[11].u32, 72 as u32, &mut ctx.xer);
	// 827E383C: 40980024  bge cr6, 0x827e3860
	if !ctx.cr[6].lt {
	pc = 0x827E3860; continue 'dispatch;
	}
	// 827E3840: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E3844: 387B00E8  addi r3, r27, 0xe8
	ctx.r[3].s64 = ctx.r[27].s64 + 232;
	// 827E3848: 483DC019  bl 0x82bbf860
	ctx.lr = 0x827E384C;
	sub_82BBF860(ctx, base);
	// 827E384C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E3850: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827E3854: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 827E3858: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E385C: 4BAE0C05  bl 0x822c4460
	ctx.lr = 0x827E3860;
	sub_822C4460(ctx, base);
	// 827E3860: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E3864: 419A000C  beq cr6, 0x827e3870
	if ctx.cr[6].eq {
	pc = 0x827E3870; continue 'dispatch;
	}
	// 827E3868: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E386C: 4BADD025  bl 0x822c0890
	ctx.lr = 0x827E3870;
	sub_822C0890(ctx, base);
	// 827E3870: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 827E3874: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 827E3878: 4082FDBC  bne 0x827e3634
	if !ctx.cr[0].eq {
	pc = 0x827E3634; continue 'dispatch;
	}
	// 827E387C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 827E3880: 489C4928  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3888 size=652
    let mut pc: u32 = 0x827E3888;
    'dispatch: loop {
        match pc {
            0x827E3888 => {
    //   block [0x827E3888..0x827E3B14)
	// 827E3888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E388C: 489C48C9  bl 0x831a8154
	ctx.lr = 0x827E3890;
	sub_831A8130(ctx, base);
	// 827E3890: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3894: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E3898: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E389C: 396B5128  addi r11, r11, 0x5128
	ctx.r[11].s64 = ctx.r[11].s64 + 20776;
	// 827E38A0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827E38A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E38A8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 827E38AC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 827E38B0: 3B000052  li r24, 0x52
	ctx.r[24].s64 = 82;
	// 827E38B4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 827E38B8: 817EFFFC  lwz r11, -4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 827E38BC: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827E38C0: 409A0240  bne cr6, 0x827e3b00
	if !ctx.cr[6].eq {
	pc = 0x827E3B00; continue 'dispatch;
	}
	// 827E38C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E38C8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E38CC: 4861013D  bl 0x82df3a08
	ctx.lr = 0x827E38D0;
	sub_82DF3A08(ctx, base);
	// 827E38D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827E38D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E38D8: 48615A31  bl 0x82df9308
	ctx.lr = 0x827E38DC;
	sub_82DF9308(ctx, base);
	// 827E38DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E38E0: 4860FB49  bl 0x82df3428
	ctx.lr = 0x827E38E4;
	sub_82DF3428(ctx, base);
	// 827E38E4: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E38E8: 4BADD051  bl 0x822c0938
	ctx.lr = 0x827E38EC;
	sub_822C0938(ctx, base);
	// 827E38EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E38F0: 41820028  beq 0x827e3918
	if ctx.cr[0].eq {
	pc = 0x827E3918; continue 'dispatch;
	}
	// 827E38F4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E38F8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E38FC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 827E3900: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3904: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827E3908: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 827E390C: 4BFFB655  bl 0x827def60
	ctx.lr = 0x827E3910;
	sub_827DEF60(ctx, base);
	// 827E3910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E3914: 48000008  b 0x827e391c
	pc = 0x827E391C; continue 'dispatch;
	// 827E3918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E391C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827E3920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3924: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E3928: 4BFFB7B9  bl 0x827df0e0
	ctx.lr = 0x827E392C;
	sub_827DF0E0(ctx, base);
	// 827E392C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E3930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3934: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E3938: 4BADC6C9  bl 0x822c0000
	ctx.lr = 0x827E393C;
	sub_822C0000(ctx, base);
	// 827E393C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E3940: 38F90001  addi r7, r25, 1
	ctx.r[7].s64 = ctx.r[25].s64 + 1;
	// 827E3944: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3948: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E394C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3950: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E3954: 4BFFFF35  bl 0x827e3888
	ctx.lr = 0x827E3958;
	sub_827E3888(ctx, base);
	// 827E3958: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E395C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827E3960: 419A00AC  beq cr6, 0x827e3a0c
	if ctx.cr[6].eq {
	pc = 0x827E3A0C; continue 'dispatch;
	}
	// 827E3964: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E3968: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E396C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 827E3970: 419A0024  beq cr6, 0x827e3994
	if ctx.cr[6].eq {
	pc = 0x827E3994; continue 'dispatch;
	}
	// 827E3974: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 827E3978: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E397C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3980: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3984: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3988: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E398C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3990: 4082FFE8  bne 0x827e3978
	if !ctx.cr[0].eq {
	pc = 0x827E3978; continue 'dispatch;
	}
	// 827E3994: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E3998: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E399C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 827E39A0: 4BCA9271  bl 0x8248cc10
	ctx.lr = 0x827E39A4;
	sub_8248CC10(ctx, base);
	// 827E39A4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E39A8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E39AC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E39B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E39B4: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 827E39B8: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 827E39BC: 9121008C  stw r9, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 827E39C0: 419A0024  beq cr6, 0x827e39e4
	if ctx.cr[6].eq {
	pc = 0x827E39E4; continue 'dispatch;
	}
	// 827E39C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E39C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E39CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E39D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E39D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E39D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E39DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E39E0: 4082FFE8  bne 0x827e39c8
	if !ctx.cr[0].eq {
	pc = 0x827E39C8; continue 'dispatch;
	}
	// 827E39E4: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 827E39E8: 389B0014  addi r4, r27, 0x14
	ctx.r[4].s64 = ctx.r[27].s64 + 20;
	// 827E39EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827E39F0: 4BFFA511  bl 0x827ddf00
	ctx.lr = 0x827E39F4;
	sub_827DDF00(ctx, base);
	// 827E39F4: 80610090  lwz r3, 0x90(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 827E39F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E39FC: 419A0008  beq cr6, 0x827e3a04
	if ctx.cr[6].eq {
	pc = 0x827E3A04; continue 'dispatch;
	}
	// 827E3A00: 4BADCE91  bl 0x822c0890
	ctx.lr = 0x827E3A04;
	sub_822C0890(ctx, base);
	// 827E3A04: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 827E3A08: 480000A8  b 0x827e3ab0
	pc = 0x827E3AB0; continue 'dispatch;
	// 827E3A0C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827E3A10: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E3A14: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 827E3A18: 419A0024  beq cr6, 0x827e3a3c
	if ctx.cr[6].eq {
	pc = 0x827E3A3C; continue 'dispatch;
	}
	// 827E3A1C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 827E3A20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3A24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3A28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3A2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3A30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3A34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3A38: 4082FFE8  bne 0x827e3a20
	if !ctx.cr[0].eq {
	pc = 0x827E3A20; continue 'dispatch;
	}
	// 827E3A3C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 827E3A40: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3A44: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 827E3A48: 4BCA91C9  bl 0x8248cc10
	ctx.lr = 0x827E3A4C;
	sub_8248CC10(ctx, base);
	// 827E3A4C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E3A50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3A54: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3A5C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 827E3A60: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 827E3A64: 9121009C  stw r9, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 827E3A68: 419A0024  beq cr6, 0x827e3a8c
	if ctx.cr[6].eq {
	pc = 0x827E3A8C; continue 'dispatch;
	}
	// 827E3A6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E3A70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3A74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3A78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3A7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3A80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3A84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3A88: 4082FFE8  bne 0x827e3a70
	if !ctx.cr[0].eq {
	pc = 0x827E3A70; continue 'dispatch;
	}
	// 827E3A8C: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 827E3A90: 389A00A0  addi r4, r26, 0xa0
	ctx.r[4].s64 = ctx.r[26].s64 + 160;
	// 827E3A94: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E3A98: 4BFFA469  bl 0x827ddf00
	ctx.lr = 0x827E3A9C;
	sub_827DDF00(ctx, base);
	// 827E3A9C: 806100A0  lwz r3, 0xa0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 827E3AA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3AA4: 419A0008  beq cr6, 0x827e3aac
	if ctx.cr[6].eq {
	pc = 0x827E3AAC; continue 'dispatch;
	}
	// 827E3AA8: 4BADCDE9  bl 0x822c0890
	ctx.lr = 0x827E3AAC;
	sub_822C0890(ctx, base);
	// 827E3AAC: 806100C0  lwz r3, 0xc0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 827E3AB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3AB4: 419A0008  beq cr6, 0x827e3abc
	if ctx.cr[6].eq {
	pc = 0x827E3ABC; continue 'dispatch;
	}
	// 827E3AB8: 4BADCDD9  bl 0x822c0890
	ctx.lr = 0x827E3ABC;
	sub_822C0890(ctx, base);
	// 827E3ABC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3AC0: 2B0B0048  cmplwi cr6, r11, 0x48
	ctx.cr[6].compare_u32(ctx.r[11].u32, 72 as u32, &mut ctx.xer);
	// 827E3AC4: 4098002C  bge cr6, 0x827e3af0
	if !ctx.cr[6].lt {
	pc = 0x827E3AF0; continue 'dispatch;
	}
	// 827E3AC8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827E3ACC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E3AD0: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 827E3AD4: 387A00F4  addi r3, r26, 0xf4
	ctx.r[3].s64 = ctx.r[26].s64 + 244;
	// 827E3AD8: 4BFFB139  bl 0x827dec10
	ctx.lr = 0x827E3ADC;
	sub_827DEC10(ctx, base);
	// 827E3ADC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E3AE0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827E3AE4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 827E3AE8: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E3AEC: 4BAE0975  bl 0x822c4460
	ctx.lr = 0x827E3AF0;
	sub_822C4460(ctx, base);
	// 827E3AF0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E3AF4: 419A000C  beq cr6, 0x827e3b00
	if ctx.cr[6].eq {
	pc = 0x827E3B00; continue 'dispatch;
	}
	// 827E3AF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E3AFC: 4BADCD95  bl 0x822c0890
	ctx.lr = 0x827E3B00;
	sub_822C0890(ctx, base);
	// 827E3B00: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 827E3B04: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 827E3B08: 4082FDB0  bne 0x827e38b8
	if !ctx.cr[0].eq {
	pc = 0x827E38B8; continue 'dispatch;
	}
	// 827E3B0C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827E3B10: 489C4694  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3B18 size=112
    let mut pc: u32 = 0x827E3B18;
    'dispatch: loop {
        match pc {
            0x827E3B18 => {
    //   block [0x827E3B18..0x827E3B88)
	// 827E3B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E3B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E3B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E3B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3B2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E3B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E3B34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E3B38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3B3C: 4BFFB5A5  bl 0x827df0e0
	ctx.lr = 0x827E3B40;
	sub_827DF0E0(ctx, base);
	// 827E3B40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E3B44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E3B48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3B4C: 4BADC4B5  bl 0x822c0000
	ctx.lr = 0x827E3B50;
	sub_822C0000(ctx, base);
	// 827E3B50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3B54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E3B58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E3B5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3B64: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E3B68: 419A0008  beq cr6, 0x827e3b70
	if ctx.cr[6].eq {
	pc = 0x827E3B70; continue 'dispatch;
	}
	// 827E3B6C: 4BADCD25  bl 0x822c0890
	ctx.lr = 0x827E3B70;
	sub_822C0890(ctx, base);
	// 827E3B70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E3B74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E3B78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E3B7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E3B80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E3B84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3B88 size=632
    let mut pc: u32 = 0x827E3B88;
    'dispatch: loop {
        match pc {
            0x827E3B88 => {
    //   block [0x827E3B88..0x827E3E00)
	// 827E3B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3B8C: 489C45CD  bl 0x831a8158
	ctx.lr = 0x827E3B90;
	sub_831A8130(ctx, base);
	// 827E3B90: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3B94: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E3B98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E3B9C: 396B5500  addi r11, r11, 0x5500
	ctx.r[11].s64 = ctx.r[11].s64 + 21760;
	// 827E3BA0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 827E3BA4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827E3BA8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 827E3BAC: 3B20000B  li r25, 0xb
	ctx.r[25].s64 = 11;
	// 827E3BB0: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 827E3BB4: 817DFFFC  lwz r11, -4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 827E3BB8: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 827E3BBC: 409A0230  bne cr6, 0x827e3dec
	if !ctx.cr[6].eq {
	pc = 0x827E3DEC; continue 'dispatch;
	}
	// 827E3BC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3BC4: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3BC8: 4860FE41  bl 0x82df3a08
	ctx.lr = 0x827E3BCC;
	sub_82DF3A08(ctx, base);
	// 827E3BCC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827E3BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E3BD4: 48615735  bl 0x82df9308
	ctx.lr = 0x827E3BD8;
	sub_82DF9308(ctx, base);
	// 827E3BD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3BDC: 4860F84D  bl 0x82df3428
	ctx.lr = 0x827E3BE0;
	sub_82DF3428(ctx, base);
	// 827E3BE0: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E3BE4: 4BADCD55  bl 0x822c0938
	ctx.lr = 0x827E3BE8;
	sub_822C0938(ctx, base);
	// 827E3BE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E3BEC: 41820028  beq 0x827e3c14
	if ctx.cr[0].eq {
	pc = 0x827E3C14; continue 'dispatch;
	}
	// 827E3BF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827E3BF4: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3BF8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 827E3BFC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3C00: 38C00055  li r6, 0x55
	ctx.r[6].s64 = 85;
	// 827E3C04: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 827E3C08: 4BFFB359  bl 0x827def60
	ctx.lr = 0x827E3C0C;
	sub_827DEF60(ctx, base);
	// 827E3C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E3C10: 48000008  b 0x827e3c18
	pc = 0x827E3C18; continue 'dispatch;
	// 827E3C14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E3C18: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827E3C1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3C20: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E3C24: 4BFFB4BD  bl 0x827df0e0
	ctx.lr = 0x827E3C28;
	sub_827DF0E0(ctx, base);
	// 827E3C28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E3C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3C30: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827E3C34: 4BADC3CD  bl 0x822c0000
	ctx.lr = 0x827E3C38;
	sub_822C0000(ctx, base);
	// 827E3C38: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E3C3C: 3BDB0001  addi r30, r27, 1
	ctx.r[30].s64 = ctx.r[27].s64 + 1;
	// 827E3C40: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3C48: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827E3C4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E3C50: 4BFFFF39  bl 0x827e3b88
	ctx.lr = 0x827E3C54;
	sub_827E3B88(ctx, base);
	// 827E3C54: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E3C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3C5C: 409A001C  bne cr6, 0x827e3c78
	if !ctx.cr[6].eq {
	pc = 0x827E3C78; continue 'dispatch;
	}
	// 827E3C60: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827E3C64: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3C68: 38C00055  li r6, 0x55
	ctx.r[6].s64 = 85;
	// 827E3C6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E3C70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E3C74: 4BFFFC15  bl 0x827e3888
	ctx.lr = 0x827E3C78;
	sub_827E3888(ctx, base);
	// 827E3C78: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E3C7C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827E3C80: 419A00AC  beq cr6, 0x827e3d2c
	if ctx.cr[6].eq {
	pc = 0x827E3D2C; continue 'dispatch;
	}
	// 827E3C84: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E3C88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E3C8C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 827E3C90: 419A0024  beq cr6, 0x827e3cb4
	if ctx.cr[6].eq {
	pc = 0x827E3CB4; continue 'dispatch;
	}
	// 827E3C94: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E3C98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3C9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3CA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3CA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3CA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3CAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3CB0: 4082FFE8  bne 0x827e3c98
	if !ctx.cr[0].eq {
	pc = 0x827E3C98; continue 'dispatch;
	}
	// 827E3CB4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E3CB8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3CBC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E3CC0: 4BCA8F51  bl 0x8248cc10
	ctx.lr = 0x827E3CC4;
	sub_8248CC10(ctx, base);
	// 827E3CC4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E3CC8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3CCC: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3CD4: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 827E3CD8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 827E3CDC: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 827E3CE0: 419A0024  beq cr6, 0x827e3d04
	if ctx.cr[6].eq {
	pc = 0x827E3D04; continue 'dispatch;
	}
	// 827E3CE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E3CE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3CEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3CF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3CF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3CF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3CFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3D00: 4082FFE8  bne 0x827e3ce8
	if !ctx.cr[0].eq {
	pc = 0x827E3CE8; continue 'dispatch;
	}
	// 827E3D04: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827E3D08: 389A0014  addi r4, r26, 0x14
	ctx.r[4].s64 = ctx.r[26].s64 + 20;
	// 827E3D0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E3D10: 4BFFA1F1  bl 0x827ddf00
	ctx.lr = 0x827E3D14;
	sub_827DDF00(ctx, base);
	// 827E3D14: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827E3D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3D1C: 419A0008  beq cr6, 0x827e3d24
	if ctx.cr[6].eq {
	pc = 0x827E3D24; continue 'dispatch;
	}
	// 827E3D20: 4BADCB71  bl 0x822c0890
	ctx.lr = 0x827E3D24;
	sub_822C0890(ctx, base);
	// 827E3D24: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 827E3D28: 480000A8  b 0x827e3dd0
	pc = 0x827E3DD0; continue 'dispatch;
	// 827E3D2C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827E3D30: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E3D34: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 827E3D38: 419A0024  beq cr6, 0x827e3d5c
	if ctx.cr[6].eq {
	pc = 0x827E3D5C; continue 'dispatch;
	}
	// 827E3D3C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E3D40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3D44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3D48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3D4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3D50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3D54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3D58: 4082FFE8  bne 0x827e3d40
	if !ctx.cr[0].eq {
	pc = 0x827E3D40; continue 'dispatch;
	}
	// 827E3D5C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 827E3D60: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3D64: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E3D68: 4BCA8EA9  bl 0x8248cc10
	ctx.lr = 0x827E3D6C;
	sub_8248CC10(ctx, base);
	// 827E3D6C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E3D70: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3D74: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3D7C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 827E3D80: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 827E3D84: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 827E3D88: 419A0024  beq cr6, 0x827e3dac
	if ctx.cr[6].eq {
	pc = 0x827E3DAC; continue 'dispatch;
	}
	// 827E3D8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E3D90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3D94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3D98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E3D9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E3DA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E3DA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E3DA8: 4082FFE8  bne 0x827e3d90
	if !ctx.cr[0].eq {
	pc = 0x827E3D90; continue 'dispatch;
	}
	// 827E3DAC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 827E3DB0: 389C00A0  addi r4, r28, 0xa0
	ctx.r[4].s64 = ctx.r[28].s64 + 160;
	// 827E3DB4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827E3DB8: 4BFFA149  bl 0x827ddf00
	ctx.lr = 0x827E3DBC;
	sub_827DDF00(ctx, base);
	// 827E3DBC: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E3DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3DC4: 419A0008  beq cr6, 0x827e3dcc
	if ctx.cr[6].eq {
	pc = 0x827E3DCC; continue 'dispatch;
	}
	// 827E3DC8: 4BADCAC9  bl 0x822c0890
	ctx.lr = 0x827E3DCC;
	sub_822C0890(ctx, base);
	// 827E3DCC: 806100B8  lwz r3, 0xb8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E3DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3DD4: 419A0008  beq cr6, 0x827e3ddc
	if ctx.cr[6].eq {
	pc = 0x827E3DDC; continue 'dispatch;
	}
	// 827E3DD8: 4BADCAB9  bl 0x822c0890
	ctx.lr = 0x827E3DDC;
	sub_822C0890(ctx, base);
	// 827E3DDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E3DE0: 419A000C  beq cr6, 0x827e3dec
	if ctx.cr[6].eq {
	pc = 0x827E3DEC; continue 'dispatch;
	}
	// 827E3DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E3DE8: 4BADCAA9  bl 0x822c0890
	ctx.lr = 0x827E3DEC;
	sub_822C0890(ctx, base);
	// 827E3DEC: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 827E3DF0: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 827E3DF4: 4082FDC0  bne 0x827e3bb4
	if !ctx.cr[0].eq {
	pc = 0x827E3BB4; continue 'dispatch;
	}
	// 827E3DF8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 827E3DFC: 489C43AC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3E00 size=188
    let mut pc: u32 = 0x827E3E00;
    'dispatch: loop {
        match pc {
            0x827E3E00 => {
    //   block [0x827E3E00..0x827E3EBC)
	// 827E3E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E3E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E3E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E3E10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E3E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E3E1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827E3E20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E3E24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E3E28: 4BADCB11  bl 0x822c0938
	ctx.lr = 0x827E3E2C;
	sub_822C0938(ctx, base);
	// 827E3E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E3E30: 41820028  beq 0x827e3e58
	if ctx.cr[0].eq {
	pc = 0x827E3E58; continue 'dispatch;
	}
	// 827E3E34: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E3E38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 827E3E3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E3E40: 392B55A0  addi r9, r11, 0x55a0
	ctx.r[9].s64 = ctx.r[11].s64 + 21920;
	// 827E3E44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E3E48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E3E4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E3E50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E3E54: 48000008  b 0x827e3e5c
	pc = 0x827E3E5C; continue 'dispatch;
	// 827E3E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E3E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E3E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3E64: 409A003C  bne cr6, 0x827e3ea0
	if !ctx.cr[6].eq {
	pc = 0x827E3EA0; continue 'dispatch;
	}
	// 827E3E68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E3E6C: 419A0014  beq cr6, 0x827e3e80
	if ctx.cr[6].eq {
	pc = 0x827E3E80; continue 'dispatch;
	}
	// 827E3E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E3E74: 4BFFB36D  bl 0x827df1e0
	ctx.lr = 0x827E3E78;
	sub_827DF1E0(ctx, base);
	// 827E3E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E3E7C: 4BADC3ED  bl 0x822c0268
	ctx.lr = 0x827E3E80;
	sub_822C0268(ctx, base);
	// 827E3E80: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E3E84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E3E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E3E8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 827E3E90: 816BB86C  lwz r11, -0x4794(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18324 as u32) ) } as u64;
	// 827E3E94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E3E98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E3E9C: 4BADC165  bl 0x822c0000
	ctx.lr = 0x827E3EA0;
	sub_822C0000(ctx, base);
	// 827E3EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E3EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E3EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E3EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E3EB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E3EB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E3EB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3EC0 size=64
    let mut pc: u32 = 0x827E3EC0;
    'dispatch: loop {
        match pc {
            0x827E3EC0 => {
    //   block [0x827E3EC0..0x827E3F00)
	// 827E3EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E3EC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E3ECC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3ED0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E3ED4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E3ED8: 419A0014  beq cr6, 0x827e3eec
	if ctx.cr[6].eq {
	pc = 0x827E3EEC; continue 'dispatch;
	}
	// 827E3EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E3EE0: 4BFFB301  bl 0x827df1e0
	ctx.lr = 0x827E3EE4;
	sub_827DF1E0(ctx, base);
	// 827E3EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E3EE8: 4BADC381  bl 0x822c0268
	ctx.lr = 0x827E3EEC;
	sub_822C0268(ctx, base);
	// 827E3EEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E3EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E3EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E3EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E3EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3F00 size=112
    let mut pc: u32 = 0x827E3F00;
    'dispatch: loop {
        match pc {
            0x827E3F00 => {
    //   block [0x827E3F00..0x827E3F70)
	// 827E3F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E3F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E3F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E3F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3F14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E3F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E3F1C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E3F20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3F24: 4BFFFEDD  bl 0x827e3e00
	ctx.lr = 0x827E3F28;
	sub_827E3E00(ctx, base);
	// 827E3F28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E3F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E3F30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E3F34: 4BADC0CD  bl 0x822c0000
	ctx.lr = 0x827E3F38;
	sub_822C0000(ctx, base);
	// 827E3F38: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E3F3C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E3F40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E3F44: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E3F4C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E3F50: 419A0008  beq cr6, 0x827e3f58
	if ctx.cr[6].eq {
	pc = 0x827E3F58; continue 'dispatch;
	}
	// 827E3F54: 4BADC93D  bl 0x822c0890
	ctx.lr = 0x827E3F58;
	sub_822C0890(ctx, base);
	// 827E3F58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E3F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E3F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E3F64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E3F68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E3F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E3F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E3F70 size=344
    let mut pc: u32 = 0x827E3F70;
    'dispatch: loop {
        match pc {
            0x827E3F70 => {
    //   block [0x827E3F70..0x827E40C8)
	// 827E3F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E3F74: 489C41E9  bl 0x831a815c
	ctx.lr = 0x827E3F78;
	sub_831A8130(ctx, base);
	// 827E3F78: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E3F7C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827E3F80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E3F84: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827E3F88: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E3F8C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E3F90: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E3F94: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E3F98: 419A0128  beq cr6, 0x827e40c0
	if ctx.cr[6].eq {
	pc = 0x827E40C0; continue 'dispatch;
	}
	// 827E3F9C: 3B3D00CC  addi r25, r29, 0xcc
	ctx.r[25].s64 = ctx.r[29].s64 + 204;
	// 827E3FA0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827E3FA4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 827E3FA8: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E3FAC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 827E3FB0: 4BADC989  bl 0x822c0938
	ctx.lr = 0x827E3FB4;
	sub_822C0938(ctx, base);
	// 827E3FB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E3FB8: 41820018  beq 0x827e3fd0
	if ctx.cr[0].eq {
	pc = 0x827E3FD0; continue 'dispatch;
	}
	// 827E3FBC: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 827E3FC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E3FC4: 4BFFB26D  bl 0x827df230
	ctx.lr = 0x827E3FC8;
	sub_827DF230(ctx, base);
	// 827E3FC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E3FCC: 48000008  b 0x827e3fd4
	pc = 0x827E3FD4; continue 'dispatch;
	// 827E3FD0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E3FD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E3FD8: 4BFFFF29  bl 0x827e3f00
	ctx.lr = 0x827E3FDC;
	sub_827E3F00(ctx, base);
	// 827E3FDC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E3FE0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E3FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E3FE8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827E3FEC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 827E3FF0: 419A0024  beq cr6, 0x827e4014
	if ctx.cr[6].eq {
	pc = 0x827E4014; continue 'dispatch;
	}
	// 827E3FF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E3FF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E3FFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4000: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4004: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4008: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E400C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4010: 4082FFE8  bne 0x827e3ff8
	if !ctx.cr[0].eq {
	pc = 0x827E3FF8; continue 'dispatch;
	}
	// 827E4014: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E4018: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E401C: 488E1EE5  bl 0x830c5f00
	ctx.lr = 0x827E4020;
	sub_830C5F00(ctx, base);
	// 827E4020: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4024: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E4028: 916A0048  stw r11, 0x48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 827E402C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E4030: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E4034: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827E4038: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827E403C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E4040: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 827E4044: 419A0024  beq cr6, 0x827e4068
	if ctx.cr[6].eq {
	pc = 0x827E4068; continue 'dispatch;
	}
	// 827E4048: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E404C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4054: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4058: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E405C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4060: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4064: 4082FFE8  bne 0x827e404c
	if !ctx.cr[0].eq {
	pc = 0x827E404C; continue 'dispatch;
	}
	// 827E4068: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 827E406C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E4070: 483CF099  bl 0x82bb3108
	ctx.lr = 0x827E4074;
	sub_82BB3108(ctx, base);
	// 827E4074: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E4078: 419A000C  beq cr6, 0x827e4084
	if ctx.cr[6].eq {
	pc = 0x827E4084; continue 'dispatch;
	}
	// 827E407C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4080: 4BADC811  bl 0x822c0890
	ctx.lr = 0x827E4084;
	sub_822C0890(ctx, base);
	// 827E4084: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E4088: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827E408C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E4090: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 827E4094: 4BFFFEDD  bl 0x827e3f70
	ctx.lr = 0x827E4098;
	sub_827E3F70(ctx, base);
	// 827E4098: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E409C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E40A0: 419A0008  beq cr6, 0x827e40a8
	if ctx.cr[6].eq {
	pc = 0x827E40A8; continue 'dispatch;
	}
	// 827E40A4: 4BADC7ED  bl 0x822c0890
	ctx.lr = 0x827E40A8;
	sub_822C0890(ctx, base);
	// 827E40A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E40AC: 4BBBD5DD  bl 0x823a1688
	ctx.lr = 0x827E40B0;
	sub_823A1688(ctx, base);
	// 827E40B0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E40B4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E40B8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E40BC: 409AFEE8  bne cr6, 0x827e3fa4
	if !ctx.cr[6].eq {
	pc = 0x827E3FA4; continue 'dispatch;
	}
	// 827E40C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827E40C4: 489C40E8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E40C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E40C8 size=1336
    let mut pc: u32 = 0x827E40C8;
    'dispatch: loop {
        match pc {
            0x827E40C8 => {
    //   block [0x827E40C8..0x827E4600)
	// 827E40C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E40CC: 489C4085  bl 0x831a8150
	ctx.lr = 0x827E40D0;
	sub_831A8130(ctx, base);
	// 827E40D0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E40D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E40D8: 387D00E8  addi r3, r29, 0xe8
	ctx.r[3].s64 = ctx.r[29].s64 + 232;
	// 827E40DC: 483C8D7D  bl 0x82bace58
	ctx.lr = 0x827E40E0;
	sub_82BACE58(ctx, base);
	// 827E40E0: 387D00F4  addi r3, r29, 0xf4
	ctx.r[3].s64 = ctx.r[29].s64 + 244;
	// 827E40E4: 4BFF9165  bl 0x827dd248
	ctx.lr = 0x827E40E8;
	sub_827DD248(ctx, base);
	// 827E40E8: 387D00A0  addi r3, r29, 0xa0
	ctx.r[3].s64 = ctx.r[29].s64 + 160;
	// 827E40EC: 4BFF9105  bl 0x827dd1f0
	ctx.lr = 0x827E40F0;
	sub_827DD1F0(ctx, base);
	// 827E40F0: 897D0100  lbz r11, 0x100(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(256 as u32) ) } as u64;
	// 827E40F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E40F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E40FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E4100: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E4104: 41820010  beq 0x827e4114
	if ctx.cr[0].eq {
	pc = 0x827E4114; continue 'dispatch;
	}
	// 827E4108: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 827E410C: 4BFFF4FD  bl 0x827e3608
	ctx.lr = 0x827E4110;
	sub_827E3608(ctx, base);
	// 827E4110: 4800000C  b 0x827e411c
	pc = 0x827E411C; continue 'dispatch;
	// 827E4114: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 827E4118: 4BFFFA71  bl 0x827e3b88
	ctx.lr = 0x827E411C;
	sub_827E3B88(ctx, base);
	// 827E411C: 817D00C4  lwz r11, 0xc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 827E4120: 816B00E0  lwz r11, 0xe0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(224 as u32) ) } as u64;
	// 827E4124: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 827E4128: 4BAE63E9  bl 0x822ca510
	ctx.lr = 0x827E412C;
	sub_822CA510(ctx, base);
	// 827E412C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E4130: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E4134: 3B2B5788  addi r25, r11, 0x5788
	ctx.r[25].s64 = ctx.r[11].s64 + 22408;
	// 827E4138: 38A00455  li r5, 0x455
	ctx.r[5].s64 = 1109;
	// 827E413C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E4140: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E4144: 4BADC295  bl 0x822c03d8
	ctx.lr = 0x827E4148;
	sub_822C03D8(ctx, base);
	// 827E4148: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 827E414C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E4150: 41820018  beq 0x827e4168
	if ctx.cr[0].eq {
	pc = 0x827E4168; continue 'dispatch;
	}
	// 827E4154: 38BD00AC  addi r5, r29, 0xac
	ctx.r[5].s64 = ctx.r[29].s64 + 172;
	// 827E4158: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E415C: 4BFFB0D5  bl 0x827df230
	ctx.lr = 0x827E4160;
	sub_827DF230(ctx, base);
	// 827E4160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E4164: 48000008  b 0x827e416c
	pc = 0x827E416C; continue 'dispatch;
	// 827E4168: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 827E416C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E4170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4174: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E4178: 4BFFFC89  bl 0x827e3e00
	ctx.lr = 0x827E417C;
	sub_827E3E00(ctx, base);
	// 827E417C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E4180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4184: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E4188: 4BADBE79  bl 0x822c0000
	ctx.lr = 0x827E418C;
	sub_822C0000(ctx, base);
	// 827E418C: 82E10064  lwz r23, 0x64(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E4190: 83010060  lwz r24, 0x60(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E4194: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 827E4198: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 827E419C: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 827E41A0: 419A0024  beq cr6, 0x827e41c4
	if ctx.cr[6].eq {
	pc = 0x827E41C4; continue 'dispatch;
	}
	// 827E41A4: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 827E41A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E41AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E41B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E41B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E41B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E41BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E41C0: 4082FFE8  bne 0x827e41a8
	if !ctx.cr[0].eq {
	pc = 0x827E41A8; continue 'dispatch;
	}
	// 827E41C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E41C8: 807D00C4  lwz r3, 0xc4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 827E41CC: 488E1E1D  bl 0x830c5fe8
	ctx.lr = 0x827E41D0;
	sub_830C5FE8(ctx, base);
	// 827E41D0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E41D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E41D8: 38A00458  li r5, 0x458
	ctx.r[5].s64 = 1112;
	// 827E41DC: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E41E0: 4BADC1F9  bl 0x822c03d8
	ctx.lr = 0x827E41E4;
	sub_822C03D8(ctx, base);
	// 827E41E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E41E8: 41820018  beq 0x827e4200
	if ctx.cr[0].eq {
	pc = 0x827E4200; continue 'dispatch;
	}
	// 827E41EC: 38BD00B4  addi r5, r29, 0xb4
	ctx.r[5].s64 = ctx.r[29].s64 + 180;
	// 827E41F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E41F4: 4BFFB03D  bl 0x827df230
	ctx.lr = 0x827E41F8;
	sub_827DF230(ctx, base);
	// 827E41F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E41FC: 48000008  b 0x827e4204
	pc = 0x827E4204; continue 'dispatch;
	// 827E4200: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 827E4204: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E4208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E420C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E4210: 4BFFFBF1  bl 0x827e3e00
	ctx.lr = 0x827E4214;
	sub_827E3E00(ctx, base);
	// 827E4214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E4218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E421C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E4220: 4BADBDE1  bl 0x822c0000
	ctx.lr = 0x827E4224;
	sub_822C0000(ctx, base);
	// 827E4224: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E4228: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E422C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E4230: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E4234: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E4238: 419A0024  beq cr6, 0x827e425c
	if ctx.cr[6].eq {
	pc = 0x827E425C; continue 'dispatch;
	}
	// 827E423C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E4240: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4244: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4248: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E424C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4250: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4254: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4258: 4082FFE8  bne 0x827e4240
	if !ctx.cr[0].eq {
	pc = 0x827E4240; continue 'dispatch;
	}
	// 827E425C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4260: 807D00C4  lwz r3, 0xc4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 827E4264: 488E1D85  bl 0x830c5fe8
	ctx.lr = 0x827E4268;
	sub_830C5FE8(ctx, base);
	// 827E4268: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E426C: 419A000C  beq cr6, 0x827e4278
	if ctx.cr[6].eq {
	pc = 0x827E4278; continue 'dispatch;
	}
	// 827E4270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4274: 4BADC61D  bl 0x822c0890
	ctx.lr = 0x827E4278;
	sub_822C0890(ctx, base);
	// 827E4278: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E427C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E4280: 38A00465  li r5, 0x465
	ctx.r[5].s64 = 1125;
	// 827E4284: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E4288: 4BADC151  bl 0x822c03d8
	ctx.lr = 0x827E428C;
	sub_822C03D8(ctx, base);
	// 827E428C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E4290: 41820018  beq 0x827e42a8
	if ctx.cr[0].eq {
	pc = 0x827E42A8; continue 'dispatch;
	}
	// 827E4294: 38BD00BC  addi r5, r29, 0xbc
	ctx.r[5].s64 = ctx.r[29].s64 + 188;
	// 827E4298: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E429C: 4BFFAF95  bl 0x827df230
	ctx.lr = 0x827E42A0;
	sub_827DF230(ctx, base);
	// 827E42A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E42A4: 48000008  b 0x827e42ac
	pc = 0x827E42AC; continue 'dispatch;
	// 827E42A8: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 827E42AC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 827E42B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E42B4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E42B8: 4BFFFB49  bl 0x827e3e00
	ctx.lr = 0x827E42BC;
	sub_827E3E00(ctx, base);
	// 827E42BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E42C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E42C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E42C8: 4BADBD39  bl 0x822c0000
	ctx.lr = 0x827E42CC;
	sub_822C0000(ctx, base);
	// 827E42CC: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E42D0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E42D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E42D8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E42DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E42E0: 419A0024  beq cr6, 0x827e4304
	if ctx.cr[6].eq {
	pc = 0x827E4304; continue 'dispatch;
	}
	// 827E42E4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E42E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E42EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E42F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E42F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E42F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E42FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4300: 4082FFE8  bne 0x827e42e8
	if !ctx.cr[0].eq {
	pc = 0x827E42E8; continue 'dispatch;
	}
	// 827E4304: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4308: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E430C: 488E1BF5  bl 0x830c5f00
	ctx.lr = 0x827E4310;
	sub_830C5F00(ctx, base);
	// 827E4310: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E4314: 419A000C  beq cr6, 0x827e4320
	if ctx.cr[6].eq {
	pc = 0x827E4320; continue 'dispatch;
	}
	// 827E4318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E431C: 4BADC575  bl 0x822c0890
	ctx.lr = 0x827E4320;
	sub_822C0890(ctx, base);
	// 827E4320: 817D00C0  lwz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 827E4324: 815D00BC  lwz r10, 0xbc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(188 as u32) ) } as u64;
	// 827E4328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E432C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827E4330: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 827E4334: 419A0024  beq cr6, 0x827e4358
	if ctx.cr[6].eq {
	pc = 0x827E4358; continue 'dispatch;
	}
	// 827E4338: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E433C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4340: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4344: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4348: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E434C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4350: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4354: 4082FFE8  bne 0x827e433c
	if !ctx.cr[0].eq {
	pc = 0x827E433C; continue 'dispatch;
	}
	// 827E4358: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E435C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4360: 388B577C  addi r4, r11, 0x577c
	ctx.r[4].s64 = ctx.r[11].s64 + 22396;
	// 827E4364: 4860F6A5  bl 0x82df3a08
	ctx.lr = 0x827E4368;
	sub_82DF3A08(ctx, base);
	// 827E4368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E436C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827E4370: 48614F99  bl 0x82df9308
	ctx.lr = 0x827E4374;
	sub_82DF9308(ctx, base);
	// 827E4374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4378: 4860F0B1  bl 0x82df3428
	ctx.lr = 0x827E437C;
	sub_82DF3428(ctx, base);
	// 827E437C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E4380: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E4384: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E4388: 4BCA8889  bl 0x8248cc10
	ctx.lr = 0x827E438C;
	sub_8248CC10(ctx, base);
	// 827E438C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E4390: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4394: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E4398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E439C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 827E43A0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 827E43A4: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 827E43A8: 419A0024  beq cr6, 0x827e43cc
	if ctx.cr[6].eq {
	pc = 0x827E43CC; continue 'dispatch;
	}
	// 827E43AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E43B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E43B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E43B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E43BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E43C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E43C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E43C8: 4082FFE8  bne 0x827e43b0
	if !ctx.cr[0].eq {
	pc = 0x827E43B0; continue 'dispatch;
	}
	// 827E43CC: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 827E43D0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827E43D4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827E43D8: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 827E43DC: 4BFF9B25  bl 0x827ddf00
	ctx.lr = 0x827E43E0;
	sub_827DDF00(ctx, base);
	// 827E43E0: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827E43E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E43E8: 419A0008  beq cr6, 0x827e43f0
	if ctx.cr[6].eq {
	pc = 0x827E43F0; continue 'dispatch;
	}
	// 827E43EC: 4BADC4A5  bl 0x822c0890
	ctx.lr = 0x827E43F0;
	sub_822C0890(ctx, base);
	// 827E43F0: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 827E43F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E43F8: 419A0008  beq cr6, 0x827e4400
	if ctx.cr[6].eq {
	pc = 0x827E4400; continue 'dispatch;
	}
	// 827E43FC: 4BADC495  bl 0x822c0890
	ctx.lr = 0x827E4400;
	sub_822C0890(ctx, base);
	// 827E4400: 837D00A4  lwz r27, 0xa4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E4404: 839B0000  lwz r28, 0(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4408: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E440C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827E4410: 419A01D8  beq cr6, 0x827e45e8
	if ctx.cr[6].eq {
	pc = 0x827E45E8; continue 'dispatch;
	}
	// 827E4414: 3B5D00CC  addi r26, r29, 0xcc
	ctx.r[26].s64 = ctx.r[29].s64 + 204;
	// 827E4418: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E441C: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 827E4420: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E4424: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 827E4428: 38A0046C  li r5, 0x46c
	ctx.r[5].s64 = 1132;
	// 827E442C: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E4430: 4BADBFA9  bl 0x822c03d8
	ctx.lr = 0x827E4434;
	sub_822C03D8(ctx, base);
	// 827E4434: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E4438: 41820018  beq 0x827e4450
	if ctx.cr[0].eq {
	pc = 0x827E4450; continue 'dispatch;
	}
	// 827E443C: 38BC0010  addi r5, r28, 0x10
	ctx.r[5].s64 = ctx.r[28].s64 + 16;
	// 827E4440: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E4444: 4BFFADED  bl 0x827df230
	ctx.lr = 0x827E4448;
	sub_827DF230(ctx, base);
	// 827E4448: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E444C: 48000008  b 0x827e4454
	pc = 0x827E4454; continue 'dispatch;
	// 827E4450: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827E4454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4458: 4BFFFAA9  bl 0x827e3f00
	ctx.lr = 0x827E445C;
	sub_827E3F00(ctx, base);
	// 827E445C: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E4460: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E4464: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E4468: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 827E446C: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 827E4470: 419A0024  beq cr6, 0x827e4494
	if ctx.cr[6].eq {
	pc = 0x827E4494; continue 'dispatch;
	}
	// 827E4474: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E4478: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E447C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4480: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4484: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4488: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E448C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4490: 4082FFE8  bne 0x827e4478
	if !ctx.cr[0].eq {
	pc = 0x827E4478; continue 'dispatch;
	}
	// 827E4494: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 827E4498: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E449C: 488E1A65  bl 0x830c5f00
	ctx.lr = 0x827E44A0;
	sub_830C5F00(ctx, base);
	// 827E44A0: 931E0048  stw r24, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[24].u32 ) };
	// 827E44A4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 827E44A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E44AC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 827E44B0: 419A0024  beq cr6, 0x827e44d4
	if ctx.cr[6].eq {
	pc = 0x827E44D4; continue 'dispatch;
	}
	// 827E44B4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E44B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E44BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E44C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E44C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E44C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E44CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E44D0: 4082FFE8  bne 0x827e44b8
	if !ctx.cr[0].eq {
	pc = 0x827E44B8; continue 'dispatch;
	}
	// 827E44D4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E44D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E44DC: 483CEC2D  bl 0x82bb3108
	ctx.lr = 0x827E44E0;
	sub_82BB3108(ctx, base);
	// 827E44E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E44E4: 419A000C  beq cr6, 0x827e44f0
	if ctx.cr[6].eq {
	pc = 0x827E44F0; continue 'dispatch;
	}
	// 827E44E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E44EC: 4BADC3A5  bl 0x822c0890
	ctx.lr = 0x827E44F0;
	sub_822C0890(ctx, base);
	// 827E44F0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E44F4: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 827E44F8: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E44FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E4500: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 827E4504: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 827E4508: 419A0024  beq cr6, 0x827e452c
	if ctx.cr[6].eq {
	pc = 0x827E452C; continue 'dispatch;
	}
	// 827E450C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E4510: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4518: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E451C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4520: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4524: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4528: 4082FFE8  bne 0x827e4510
	if !ctx.cr[0].eq {
	pc = 0x827E4510; continue 'dispatch;
	}
	// 827E452C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 827E4530: 809C000C  lwz r4, 0xc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E4534: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E4538: 4BCA86D9  bl 0x8248cc10
	ctx.lr = 0x827E453C;
	sub_8248CC10(ctx, base);
	// 827E453C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E4540: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4544: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E4548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E454C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 827E4550: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 827E4554: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 827E4558: 419A0024  beq cr6, 0x827e457c
	if ctx.cr[6].eq {
	pc = 0x827E457C; continue 'dispatch;
	}
	// 827E455C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E4560: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4564: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4568: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E456C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4570: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4574: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4578: 4082FFE8  bne 0x827e4560
	if !ctx.cr[0].eq {
	pc = 0x827E4560; continue 'dispatch;
	}
	// 827E457C: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 827E4580: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 827E4584: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E4588: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 827E458C: 4BFF9975  bl 0x827ddf00
	ctx.lr = 0x827E4590;
	sub_827DDF00(ctx, base);
	// 827E4590: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827E4594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E4598: 419A0008  beq cr6, 0x827e45a0
	if ctx.cr[6].eq {
	pc = 0x827E45A0; continue 'dispatch;
	}
	// 827E459C: 4BADC2F5  bl 0x822c0890
	ctx.lr = 0x827E45A0;
	sub_822C0890(ctx, base);
	// 827E45A0: 806100B8  lwz r3, 0xb8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E45A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E45A8: 419A0008  beq cr6, 0x827e45b0
	if ctx.cr[6].eq {
	pc = 0x827E45B0; continue 'dispatch;
	}
	// 827E45AC: 4BADC2E5  bl 0x822c0890
	ctx.lr = 0x827E45B0;
	sub_822C0890(ctx, base);
	// 827E45B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E45B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E45B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E45BC: 38AB0014  addi r5, r11, 0x14
	ctx.r[5].s64 = ctx.r[11].s64 + 20;
	// 827E45C0: 4BFFF9B1  bl 0x827e3f70
	ctx.lr = 0x827E45C4;
	sub_827E3F70(ctx, base);
	// 827E45C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E45C8: 419A000C  beq cr6, 0x827e45d4
	if ctx.cr[6].eq {
	pc = 0x827E45D4; continue 'dispatch;
	}
	// 827E45CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E45D0: 4BADC2C1  bl 0x822c0890
	ctx.lr = 0x827E45D4;
	sub_822C0890(ctx, base);
	// 827E45D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E45D8: 4BBBD0B1  bl 0x823a1688
	ctx.lr = 0x827E45DC;
	sub_823A1688(ctx, base);
	// 827E45DC: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E45E0: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E45E4: 409AFE34  bne cr6, 0x827e4418
	if !ctx.cr[6].eq {
	pc = 0x827E4418; continue 'dispatch;
	}
	// 827E45E8: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 827E45EC: 419A000C  beq cr6, 0x827e45f8
	if ctx.cr[6].eq {
	pc = 0x827E45F8; continue 'dispatch;
	}
	// 827E45F0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827E45F4: 4BADC29D  bl 0x822c0890
	ctx.lr = 0x827E45F8;
	sub_822C0890(ctx, base);
	// 827E45F8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827E45FC: 489C3BA4  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E4600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E4600 size=4676
    let mut pc: u32 = 0x827E4600;
    'dispatch: loop {
        match pc {
            0x827E4600 => {
    //   block [0x827E4600..0x827E5844)
	// 827E4600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E4604: 489C3B45  bl 0x831a8148
	ctx.lr = 0x827E4608;
	sub_831A8130(ctx, base);
	// 827E4608: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 827E460C: 489C445D  bl 0x831a8a68
	ctx.lr = 0x827E4610;
	sub_831A8A40(ctx, base);
	// 827E4610: 9421FBE0  stwu r1, -0x420(r1)
	ea = ctx.r[1].u32.wrapping_add(-1056 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E4614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E4618: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827E461C: 488DE56D  bl 0x830c2b88
	ctx.lr = 0x827E4620;
	sub_830C2B88(ctx, base);
	// 827E4620: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E4624: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 827E4628: 396B55CC  addi r11, r11, 0x55cc
	ctx.r[11].s64 = ctx.r[11].s64 + 21964;
	// 827E462C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E4630: 4BFF8651  bl 0x827dcc80
	ctx.lr = 0x827E4634;
	sub_827DCC80(ctx, base);
	// 827E4634: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827E4638: 3D600200  lis r11, 0x200
	ctx.r[11].s64 = 33554432;
	// 827E463C: 935F00AC  stw r26, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 827E4640: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 827E4644: 935F00B0  stw r26, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[26].u32 ) };
	// 827E4648: 3B9F00AC  addi r28, r31, 0xac
	ctx.r[28].s64 = ctx.r[31].s64 + 172;
	// 827E464C: 935F00B4  stw r26, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[26].u32 ) };
	// 827E4650: 3B3F00B4  addi r25, r31, 0xb4
	ctx.r[25].s64 = ctx.r[31].s64 + 180;
	// 827E4654: 935F00B8  stw r26, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[26].u32 ) };
	// 827E4658: 3B7F00BC  addi r27, r31, 0xbc
	ctx.r[27].s64 = ctx.r[31].s64 + 188;
	// 827E465C: 935F00BC  stw r26, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 827E4660: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 827E4664: 935F00C0  stw r26, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	// 827E4668: 935F00C4  stw r26, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 827E466C: 935F00C8  stw r26, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 827E4670: 935F00D0  stw r26, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[26].u32 ) };
	// 827E4674: 935F00D4  stw r26, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[26].u32 ) };
	// 827E4678: 935F00D8  stw r26, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[26].u32 ) };
	// 827E467C: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 827E4680: 4BC3A189  bl 0x8241e808
	ctx.lr = 0x827E4684;
	sub_8241E808(ctx, base);
	// 827E4684: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 827E4688: 488CEE71  bl 0x830b34f8
	ctx.lr = 0x827E468C;
	sub_830B34F8(ctx, base);
	// 827E468C: 9BBF0100  stb r29, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[29].u8 ) };
	// 827E4690: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 827E4694: 4BFB7565  bl 0x8279bbf8
	ctx.lr = 0x827E4698;
	sub_8279BBF8(ctx, base);
	// 827E4698: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E469C: 935F0110  stw r26, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[26].u32 ) };
	// 827E46A0: 935F0114  stw r26, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[26].u32 ) };
	// 827E46A4: 935F00E0  stw r26, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[26].u32 ) };
	// 827E46A8: 935F00E4  stw r26, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 827E46AC: 894BB860  lbz r10, -0x47a0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-18336 as u32) ) } as u64;
	// 827E46B0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E46B4: 4182002C  beq 0x827e46e0
	if ctx.cr[0].eq {
	pc = 0x827E46E0; continue 'dispatch;
	}
	// 827E46B8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E46BC: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 827E46C0: 38EA9F48  addi r7, r10, -0x60b8
	ctx.r[7].s64 = ctx.r[10].s64 + -24760;
	// 827E46C4: 38C987E8  addi r6, r9, -0x7818
	ctx.r[6].s64 = ctx.r[9].s64 + -30744;
	// 827E46C8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 827E46CC: 3D202000  lis r9, 0x2000
	ctx.r[9].s64 = 536870912;
	// 827E46D0: 3D002000  lis r8, 0x2000
	ctx.r[8].s64 = 536870912;
	// 827E46D4: 994BB860  stb r10, -0x47a0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-18336 as u32), ctx.r[10].u8 ) };
	// 827E46D8: 91270154  stw r9, 0x154(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(340 as u32), ctx.r[9].u32 ) };
	// 827E46DC: 91061754  stw r8, 0x1754(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(5972 as u32), ctx.r[8].u32 ) };
	// 827E46E0: 897F0100  lbz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 827E46E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E46E8: 41820010  beq 0x827e46f8
	if ctx.cr[0].eq {
	pc = 0x827E46F8; continue 'dispatch;
	}
	// 827E46EC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E46F0: 93EBA0AC  stw r31, -0x5f54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24404 as u32), ctx.r[31].u32 ) };
	// 827E46F4: 4800000C  b 0x827e4700
	pc = 0x827E4700; continue 'dispatch;
	// 827E46F8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E46FC: 93EBA0B0  stw r31, -0x5f50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24400 as u32), ctx.r[31].u32 ) };
	// 827E4700: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 827E4704: 4BADC235  bl 0x822c0938
	ctx.lr = 0x827E4708;
	sub_822C0938(ctx, base);
	// 827E4708: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E470C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 827E4710: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E4714: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E4718: C3CA6218  lfs f30, 0x6218(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827E471C: 3AEBB804  addi r23, r11, -0x47fc
	ctx.r[23].s64 = ctx.r[11].s64 + -18428;
	// 827E4720: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827E4724: 41820078  beq 0x827e479c
	if ctx.cr[0].eq {
	pc = 0x827E479C; continue 'dispatch;
	}
	// 827E4728: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E472C: C1B70004  lfs f13, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E4730: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827E4734: C1970000  lfs f12, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E4738: D3E101A8  stfs f31, 0x1a8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 827E473C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 827E4740: D3E101AC  stfs f31, 0x1ac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 827E4744: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4748: D3E101D8  stfs f31, 0x1d8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 827E474C: 38899650  addi r4, r9, -0x69b0
	ctx.r[4].s64 = ctx.r[9].s64 + -27056;
	// 827E4750: C00B9680  lfs f0, -0x6980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4754: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E4758: C1AA8DC0  lfs f13, -0x7240(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E475C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E4760: D00101D0  stfs f0, 0x1d0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 827E4764: D1A101A0  stfs f13, 0x1a0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 827E4768: D1A101A4  stfs f13, 0x1a4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 827E476C: D3E101DC  stfs f31, 0x1dc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 827E4770: EC0BF028  fsubs f0, f11, f30
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E4774: D00101D4  stfs f0, 0x1d4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 827E4778: 4BAE4B79  bl 0x822c92f0
	ctx.lr = 0x827E477C;
	sub_822C92F0(ctx, base);
	// 827E477C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E4780: 38C101A0  addi r6, r1, 0x1a0
	ctx.r[6].s64 = ctx.r[1].s64 + 416;
	// 827E4784: 38A101D0  addi r5, r1, 0x1d0
	ctx.r[5].s64 = ctx.r[1].s64 + 464;
	// 827E4788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E478C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E4790: 488E2051  bl 0x830c67e0
	ctx.lr = 0x827E4794;
	sub_830C67E0(ctx, base);
	// 827E4794: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E4798: 48000008  b 0x827e47a0
	pc = 0x827E47A0; continue 'dispatch;
	// 827E479C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E47A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E47A4: 4BFF8535  bl 0x827dccd8
	ctx.lr = 0x827E47A8;
	sub_827DCCD8(ctx, base);
	// 827E47A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E47AC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E47B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E47B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E47B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E47BC: 419A0024  beq cr6, 0x827e47e0
	if ctx.cr[6].eq {
	pc = 0x827E47E0; continue 'dispatch;
	}
	// 827E47C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E47C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E47C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E47CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E47D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E47D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E47D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E47DC: 4082FFE8  bne 0x827e47c4
	if !ctx.cr[0].eq {
	pc = 0x827E47C4; continue 'dispatch;
	}
	// 827E47E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E47E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E47E8: 488DF131  bl 0x830c3918
	ctx.lr = 0x827E47EC;
	sub_830C3918(ctx, base);
	// 827E47EC: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E47F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E47F4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E47F8: 396BCC28  addi r11, r11, -0x33d8
	ctx.r[11].s64 = ctx.r[11].s64 + -13272;
	// 827E47FC: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 827E4800: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E4804: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E4808: 4BFFA389  bl 0x827deb90
	ctx.lr = 0x827E480C;
	sub_827DEB90(ctx, base);
	// 827E480C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4810: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E4814: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 827E4818: 4BC8C8B1  bl 0x824710c8
	ctx.lr = 0x827E481C;
	sub_824710C8(ctx, base);
	// 827E481C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4820: 4BAE4499  bl 0x822c8cb8
	ctx.lr = 0x827E4824;
	sub_822C8CB8(ctx, base);
	// 827E4824: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E4828: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 827E482C: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E4830: 9ACB0100  stb r22, 0x100(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[22].u8 ) };
	// 827E4834: 4BADC105  bl 0x822c0938
	ctx.lr = 0x827E4838;
	sub_822C0938(ctx, base);
	// 827E4838: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E483C: 41820050  beq 0x827e488c
	if ctx.cr[0].eq {
	pc = 0x827E488C; continue 'dispatch;
	}
	// 827E4840: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E4844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4848: 388B58C0  addi r4, r11, 0x58c0
	ctx.r[4].s64 = ctx.r[11].s64 + 22720;
	// 827E484C: 4860F1BD  bl 0x82df3a08
	ctx.lr = 0x827E4850;
	sub_82DF3A08(ctx, base);
	// 827E4850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4854: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 827E4858: 48614AB1  bl 0x82df9308
	ctx.lr = 0x827E485C;
	sub_82DF9308(ctx, base);
	// 827E485C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4860: 4860EBC9  bl 0x82df3428
	ctx.lr = 0x827E4864;
	sub_82DF3428(ctx, base);
	// 827E4864: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E4868: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827E486C: 808100A8  lwz r4, 0xa8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 827E4870: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 827E4874: 38C00055  li r6, 0x55
	ctx.r[6].s64 = 85;
	// 827E4878: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E487C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4880: 4BFFA6E1  bl 0x827def60
	ctx.lr = 0x827E4884;
	sub_827DEF60(ctx, base);
	// 827E4884: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E4888: 48000008  b 0x827e4890
	pc = 0x827E4890; continue 'dispatch;
	// 827E488C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E4890: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E4894: 4BFFF285  bl 0x827e3b18
	ctx.lr = 0x827E4898;
	sub_827E3B18(ctx, base);
	// 827E4898: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E489C: 4BADC09D  bl 0x822c0938
	ctx.lr = 0x827E48A0;
	sub_822C0938(ctx, base);
	// 827E48A0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E48A4: 41820050  beq 0x827e48f4
	if ctx.cr[0].eq {
	pc = 0x827E48F4; continue 'dispatch;
	}
	// 827E48A8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E48AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E48B0: 388B58AC  addi r4, r11, 0x58ac
	ctx.r[4].s64 = ctx.r[11].s64 + 22700;
	// 827E48B4: 4860F155  bl 0x82df3a08
	ctx.lr = 0x827E48B8;
	sub_82DF3A08(ctx, base);
	// 827E48B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E48BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E48C0: 48614A49  bl 0x82df9308
	ctx.lr = 0x827E48C4;
	sub_82DF9308(ctx, base);
	// 827E48C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E48C8: 4860EB61  bl 0x82df3428
	ctx.lr = 0x827E48CC;
	sub_82DF3428(ctx, base);
	// 827E48CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E48D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827E48D4: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 827E48D8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 827E48DC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E48E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E48E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E48E8: 4BFFA679  bl 0x827def60
	ctx.lr = 0x827E48EC;
	sub_827DEF60(ctx, base);
	// 827E48EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E48F0: 48000008  b 0x827e48f8
	pc = 0x827E48F8; continue 'dispatch;
	// 827E48F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E48F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E48FC: 4BFFF21D  bl 0x827e3b18
	ctx.lr = 0x827E4900;
	sub_827E3B18(ctx, base);
	// 827E4900: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 827E4904: 4BADC035  bl 0x822c0938
	ctx.lr = 0x827E4908;
	sub_822C0938(ctx, base);
	// 827E4908: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E490C: 41820050  beq 0x827e495c
	if ctx.cr[0].eq {
	pc = 0x827E495C; continue 'dispatch;
	}
	// 827E4910: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E4914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4918: 388B589C  addi r4, r11, 0x589c
	ctx.r[4].s64 = ctx.r[11].s64 + 22684;
	// 827E491C: 4860F0ED  bl 0x82df3a08
	ctx.lr = 0x827E4920;
	sub_82DF3A08(ctx, base);
	// 827E4920: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4924: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 827E4928: 486149E1  bl 0x82df9308
	ctx.lr = 0x827E492C;
	sub_82DF9308(ctx, base);
	// 827E492C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E4930: 4860EAF9  bl 0x82df3428
	ctx.lr = 0x827E4934;
	sub_82DF3428(ctx, base);
	// 827E4934: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827E4938: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827E493C: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E4940: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 827E4944: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E4948: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E494C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4950: 4BFFA611  bl 0x827def60
	ctx.lr = 0x827E4954;
	sub_827DEF60(ctx, base);
	// 827E4954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E4958: 48000008  b 0x827e4960
	pc = 0x827E4960; continue 'dispatch;
	// 827E495C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E4960: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E4964: 4BFFF1B5  bl 0x827e3b18
	ctx.lr = 0x827E4968;
	sub_827E3B18(ctx, base);
	// 827E4968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E496C: 4BFFF75D  bl 0x827e40c8
	ctx.lr = 0x827E4970;
	sub_827E40C8(ctx, base);
	// 827E4970: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E4974: 4BADBFC5  bl 0x822c0938
	ctx.lr = 0x827E4978;
	sub_822C0938(ctx, base);
	// 827E4978: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E497C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E4980: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 827E4984: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E4988: C38B9594  lfs f28, -0x6a6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 827E498C: C36A958C  lfs f27, -0x6a74(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27252 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 827E4990: C349D72C  lfs f26, -0x28d4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 827E4994: 4182005C  beq 0x827e49f0
	if ctx.cr[0].eq {
	pc = 0x827E49F0; continue 'dispatch;
	}
	// 827E4998: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E499C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E49A0: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E49A4: D34100D0  stfs f26, 0xd0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 827E49A8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 827E49AC: 388B588C  addi r4, r11, 0x588c
	ctx.r[4].s64 = ctx.r[11].s64 + 22668;
	// 827E49B0: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 827E49B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E49B8: D3E100DC  stfs f31, 0xdc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 827E49BC: D3610200  stfs f27, 0x200(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 827E49C0: D3810204  stfs f28, 0x204(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(516 as u32), tmp.u32 ) };
	// 827E49C4: D3E10208  stfs f31, 0x208(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(520 as u32), tmp.u32 ) };
	// 827E49C8: D3E1020C  stfs f31, 0x20c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 827E49CC: 4BAE4925  bl 0x822c92f0
	ctx.lr = 0x827E49D0;
	sub_822C92F0(ctx, base);
	// 827E49D0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E49D4: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 827E49D8: 38A10200  addi r5, r1, 0x200
	ctx.r[5].s64 = ctx.r[1].s64 + 512;
	// 827E49DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E49E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E49E4: 488DF7D5  bl 0x830c41b8
	ctx.lr = 0x827E49E8;
	sub_830C41B8(ctx, base);
	// 827E49E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E49EC: 48000008  b 0x827e49f4
	pc = 0x827E49F4; continue 'dispatch;
	// 827E49F0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E49F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E49F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E49FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4A00: 4BAE4369  bl 0x822c8d68
	ctx.lr = 0x827E4A04;
	sub_822C8D68(ctx, base);
	// 827E4A04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E4A08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4A0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4A10: 4BADB5F1  bl 0x822c0000
	ctx.lr = 0x827E4A14;
	sub_822C0000(ctx, base);
	// 827E4A14: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E4A18: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E4A1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4A20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E4A24: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E4A28: 419A0024  beq cr6, 0x827e4a4c
	if ctx.cr[6].eq {
	pc = 0x827E4A4C; continue 'dispatch;
	}
	// 827E4A2C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E4A30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4A34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4A38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4A3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4A40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4A44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4A48: 4082FFE8  bne 0x827e4a30
	if !ctx.cr[0].eq {
	pc = 0x827E4A30; continue 'dispatch;
	}
	// 827E4A4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4A54: 488DEEC5  bl 0x830c3918
	ctx.lr = 0x827E4A58;
	sub_830C3918(ctx, base);
	// 827E4A58: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E4A5C: 3D40827E  lis r10, -0x7d82
	ctx.r[10].s64 = -2105671680;
	// 827E4A60: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E4A64: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 827E4A68: 394AC1F8  addi r10, r10, -0x3e08
	ctx.r[10].s64 = ctx.r[10].s64 + -15880;
	// 827E4A6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E4A70: 896BA0B4  lbz r11, -0x5f4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24396 as u32) ) } as u64;
	// 827E4A74: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E4A78: 93410230  stw r26, 0x230(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(560 as u32), ctx.r[26].u32 ) };
	// 827E4A7C: 4BAE423D  bl 0x822c8cb8
	ctx.lr = 0x827E4A80;
	sub_822C8CB8(ctx, base);
	// 827E4A80: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 827E4A84: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E4A88: 4BFF97B1  bl 0x827de238
	ctx.lr = 0x827E4A8C;
	sub_827DE238(ctx, base);
	// 827E4A8C: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 827E4A90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4A94: 4BDA747D  bl 0x8258bf10
	ctx.lr = 0x827E4A98;
	sub_8258BF10(ctx, base);
	// 827E4A98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E4A9C: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E4AA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E4AA4: 4BC8C625  bl 0x824710c8
	ctx.lr = 0x827E4AA8;
	sub_824710C8(ctx, base);
	// 827E4AA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E4AAC: 4BAE420D  bl 0x822c8cb8
	ctx.lr = 0x827E4AB0;
	sub_822C8CB8(ctx, base);
	// 827E4AB0: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 827E4AB4: 4BAE4205  bl 0x822c8cb8
	ctx.lr = 0x827E4AB8;
	sub_822C8CB8(ctx, base);
	// 827E4AB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4ABC: 419A000C  beq cr6, 0x827e4ac8
	if ctx.cr[6].eq {
	pc = 0x827E4AC8; continue 'dispatch;
	}
	// 827E4AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4AC4: 4BADBDCD  bl 0x822c0890
	ctx.lr = 0x827E4AC8;
	sub_822C0890(ctx, base);
	// 827E4AC8: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 827E4ACC: 4BADBE6D  bl 0x822c0938
	ctx.lr = 0x827E4AD0;
	sub_822C0938(ctx, base);
	// 827E4AD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E4AD4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E4AD8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E4ADC: C30B9670  lfs f24, -0x6990(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 827E4AE0: C32A9674  lfs f25, -0x698c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27020 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 827E4AE4: 41820064  beq 0x827e4b48
	if ctx.cr[0].eq {
	pc = 0x827E4B48; continue 'dispatch;
	}
	// 827E4AE8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 827E4AEC: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4AF0: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E4AF4: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 827E4AF8: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 827E4AFC: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E4B00: D3E100FC  stfs f31, 0xfc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 827E4B04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4B08: D32101E0  stfs f25, 0x1e0(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 827E4B0C: 388A587C  addi r4, r10, 0x587c
	ctx.r[4].s64 = ctx.r[10].s64 + 22652;
	// 827E4B10: C00B7A10  lfs f0, 0x7a10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4B14: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 827E4B18: D30101E4  stfs f24, 0x1e4(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 827E4B1C: D3E101E8  stfs f31, 0x1e8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 827E4B20: D3E101EC  stfs f31, 0x1ec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 827E4B24: 4BAE47CD  bl 0x822c92f0
	ctx.lr = 0x827E4B28;
	sub_822C92F0(ctx, base);
	// 827E4B28: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E4B2C: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 827E4B30: 38A101E0  addi r5, r1, 0x1e0
	ctx.r[5].s64 = ctx.r[1].s64 + 480;
	// 827E4B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4B3C: 488E362D  bl 0x830c8168
	ctx.lr = 0x827E4B40;
	sub_830C8168(ctx, base);
	// 827E4B40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E4B44: 48000008  b 0x827e4b4c
	pc = 0x827E4B4C; continue 'dispatch;
	// 827E4B48: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E4B4C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E4B50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4B54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4B58: 4BAE4AE1  bl 0x822c9638
	ctx.lr = 0x827E4B5C;
	sub_822C9638(ctx, base);
	// 827E4B5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E4B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4B64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4B68: 4BADB499  bl 0x822c0000
	ctx.lr = 0x827E4B6C;
	sub_822C0000(ctx, base);
	// 827E4B6C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E4B70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E4B74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4B78: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E4B7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E4B80: 419A0024  beq cr6, 0x827e4ba4
	if ctx.cr[6].eq {
	pc = 0x827E4BA4; continue 'dispatch;
	}
	// 827E4B84: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E4B88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4B8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4B90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4B94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4B98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4B9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4BA0: 4082FFE8  bne 0x827e4b88
	if !ctx.cr[0].eq {
	pc = 0x827E4B88; continue 'dispatch;
	}
	// 827E4BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4BAC: 488DED6D  bl 0x830c3918
	ctx.lr = 0x827E4BB0;
	sub_830C3918(ctx, base);
	// 827E4BB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4BB4: 419A000C  beq cr6, 0x827e4bc0
	if ctx.cr[6].eq {
	pc = 0x827E4BC0; continue 'dispatch;
	}
	// 827E4BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4BBC: 4BADBCD5  bl 0x822c0890
	ctx.lr = 0x827E4BC0;
	sub_822C0890(ctx, base);
	// 827E4BC0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 827E4BC4: 4BADBD75  bl 0x822c0938
	ctx.lr = 0x827E4BC8;
	sub_822C0938(ctx, base);
	// 827E4BC8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E4BCC: 41820064  beq 0x827e4c30
	if ctx.cr[0].eq {
	pc = 0x827E4C30; continue 'dispatch;
	}
	// 827E4BD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E4BD4: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4BD8: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E4BDC: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 827E4BE0: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 827E4BE4: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E4BE8: D3E1011C  stfs f31, 0x11c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 827E4BEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4BF0: D3210220  stfs f25, 0x220(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), tmp.u32 ) };
	// 827E4BF4: 388A5864  addi r4, r10, 0x5864
	ctx.r[4].s64 = ctx.r[10].s64 + 22628;
	// 827E4BF8: C00B9690  lfs f0, -0x6970(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26992 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4BFC: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 827E4C00: D3010224  stfs f24, 0x224(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), tmp.u32 ) };
	// 827E4C04: D3E10228  stfs f31, 0x228(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(552 as u32), tmp.u32 ) };
	// 827E4C08: D3E1022C  stfs f31, 0x22c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), tmp.u32 ) };
	// 827E4C0C: 4BAE46E5  bl 0x822c92f0
	ctx.lr = 0x827E4C10;
	sub_822C92F0(ctx, base);
	// 827E4C10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E4C14: 38C10110  addi r6, r1, 0x110
	ctx.r[6].s64 = ctx.r[1].s64 + 272;
	// 827E4C18: 38A10220  addi r5, r1, 0x220
	ctx.r[5].s64 = ctx.r[1].s64 + 544;
	// 827E4C1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4C24: 488E2A55  bl 0x830c7678
	ctx.lr = 0x827E4C28;
	sub_830C7678(ctx, base);
	// 827E4C28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E4C2C: 48000008  b 0x827e4c34
	pc = 0x827E4C34; continue 'dispatch;
	// 827E4C30: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E4C34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E4C38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4C3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4C40: 4BAE4B89  bl 0x822c97c8
	ctx.lr = 0x827E4C44;
	sub_822C97C8(ctx, base);
	// 827E4C44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E4C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4C4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4C50: 4BADB3B1  bl 0x822c0000
	ctx.lr = 0x827E4C54;
	sub_822C0000(ctx, base);
	// 827E4C54: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E4C58: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E4C5C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 827E4C60: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 827E4C64: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E4C68: 419A0024  beq cr6, 0x827e4c8c
	if ctx.cr[6].eq {
	pc = 0x827E4C8C; continue 'dispatch;
	}
	// 827E4C6C: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 827E4C70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4C74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4C78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4C7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4C80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4C84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4C88: 4082FFE8  bne 0x827e4c70
	if !ctx.cr[0].eq {
	pc = 0x827E4C70; continue 'dispatch;
	}
	// 827E4C8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4C94: 488DEC85  bl 0x830c3918
	ctx.lr = 0x827E4C98;
	sub_830C3918(ctx, base);
	// 827E4C98: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 827E4C9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E4CA0: 817DA0A8  lwz r11, -0x5f58(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24408 as u32) ) } as u64;
	// 827E4CA4: C00A9C28  lfs f0, -0x63d8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4CA8: D01E00F0  stfs f0, 0xf0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 827E4CAC: 83970048  lwz r28, 0x48(r23)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 827E4CB0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 827E4CB4: 41980080  blt cr6, 0x827e4d34
	if ctx.cr[6].lt {
	pc = 0x827E4D34; continue 'dispatch;
	}
	// 827E4CB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E4CBC: 3B7E00E4  addi r27, r30, 0xe4
	ctx.r[27].s64 = ctx.r[30].s64 + 228;
	// 827E4CC0: 3B2B9698  addi r25, r11, -0x6968
	ctx.r[25].s64 = ctx.r[11].s64 + -26984;
	// 827E4CC4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E4CC8: 7EC5E030  slw r5, r22, r28
	if (ctx.r[28].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[22].u32) << ((ctx.r[28].u8 & 0x1F) as u32)) as u64;
	}
	// 827E4CCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4CD0: 4BAE4681  bl 0x822c9350
	ctx.lr = 0x827E4CD4;
	sub_822C9350(ctx, base);
	// 827E4CD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E4CD8: 38610310  addi r3, r1, 0x310
	ctx.r[3].s64 = ctx.r[1].s64 + 784;
	// 827E4CDC: 4BAE4615  bl 0x822c92f0
	ctx.lr = 0x827E4CE0;
	sub_822C92F0(ctx, base);
	// 827E4CE0: 38C10310  addi r6, r1, 0x310
	ctx.r[6].s64 = ctx.r[1].s64 + 784;
	// 827E4CE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E4CE8: 82BB0004  lwz r21, 4(r27)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E4CEC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 827E4CF0: 80B50004  lwz r5, 4(r21)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E4CF4: 4BAE5735  bl 0x822ca428
	ctx.lr = 0x827E4CF8;
	sub_822CA428(ctx, base);
	// 827E4CF8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 827E4CFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E4D00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E4D04: 4BAE5265  bl 0x822c9f68
	ctx.lr = 0x827E4D08;
	sub_822C9F68(ctx, base);
	// 827E4D08: 92950004  stw r20, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 827E4D0C: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E4D10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E4D14: 928B0000  stw r20, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 827E4D18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E4D1C: 38610310  addi r3, r1, 0x310
	ctx.r[3].s64 = ctx.r[1].s64 + 784;
	// 827E4D20: 4BAE4111  bl 0x822c8e30
	ctx.lr = 0x827E4D24;
	sub_822C8E30(ctx, base);
	// 827E4D24: 817DA0A8  lwz r11, -0x5f58(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24408 as u32) ) } as u64;
	// 827E4D28: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 827E4D2C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 827E4D30: 4098FF94  bge cr6, 0x827e4cc4
	if !ctx.cr[6].lt {
	pc = 0x827E4CC4; continue 'dispatch;
	}
	// 827E4D34: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E4D38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E4D3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4D40: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 827E4D44: 396BC208  addi r11, r11, -0x3df8
	ctx.r[11].s64 = ctx.r[11].s64 + -15864;
	// 827E4D48: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E4D4C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E4D50: 4BFF9569  bl 0x827de2b8
	ctx.lr = 0x827E4D54;
	sub_827DE2B8(ctx, base);
	// 827E4D54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E4D58: 387E00C0  addi r3, r30, 0xc0
	ctx.r[3].s64 = ctx.r[30].s64 + 192;
	// 827E4D5C: 4BC8C36D  bl 0x824710c8
	ctx.lr = 0x827E4D60;
	sub_824710C8(ctx, base);
	// 827E4D60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4D64: 4BAE3F55  bl 0x822c8cb8
	ctx.lr = 0x827E4D68;
	sub_822C8CB8(ctx, base);
	// 827E4D68: 9ADE00F9  stb r22, 0xf9(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(249 as u32), ctx.r[22].u8 ) };
	// 827E4D6C: 8177004C  lwz r11, 0x4c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(76 as u32) ) } as u64;
	// 827E4D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4D74: 815DA0A8  lwz r10, -0x5f58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24408 as u32) ) } as u64;
	// 827E4D78: 81370048  lwz r9, 0x48(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 827E4D7C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827E4D80: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 827E4D84: 488E1E6D  bl 0x830c6bf0
	ctx.lr = 0x827E4D88;
	sub_830C6BF0(ctx, base);
	// 827E4D88: 817DA0A8  lwz r11, -0x5f58(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24408 as u32) ) } as u64;
	// 827E4D8C: 8157004C  lwz r10, 0x4c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(76 as u32) ) } as u64;
	// 827E4D90: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 827E4D94: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 827E4D98: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827E4D9C: 7ECB5830  slw r11, r22, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[22].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 827E4DA0: 9169B864  stw r11, -0x479c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-18332 as u32), ctx.r[11].u32 ) };
	// 827E4DA4: 419A000C  beq cr6, 0x827e4db0
	if ctx.cr[6].eq {
	pc = 0x827E4DB0; continue 'dispatch;
	}
	// 827E4DA8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E4DAC: 4BADBAE5  bl 0x822c0890
	ctx.lr = 0x827E4DB0;
	sub_822C0890(ctx, base);
	// 827E4DB0: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E4DB4: 4BADBB85  bl 0x822c0938
	ctx.lr = 0x827E4DB8;
	sub_822C0938(ctx, base);
	// 827E4DB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E4DBC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E4DC0: C3AB95F8  lfs f29, -0x6a08(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27144 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 827E4DC4: 4182005C  beq 0x827e4e20
	if ctx.cr[0].eq {
	pc = 0x827E4E20; continue 'dispatch;
	}
	// 827E4DC8: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4DCC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E4DD0: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E4DD4: D3A10130  stfs f29, 0x130(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 827E4DD8: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 827E4DDC: 388B584C  addi r4, r11, 0x584c
	ctx.r[4].s64 = ctx.r[11].s64 + 22604;
	// 827E4DE0: D3E10138  stfs f31, 0x138(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 827E4DE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4DE8: D3E1013C  stfs f31, 0x13c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 827E4DEC: D3610210  stfs f27, 0x210(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 827E4DF0: D3810214  stfs f28, 0x214(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), tmp.u32 ) };
	// 827E4DF4: D3E10218  stfs f31, 0x218(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), tmp.u32 ) };
	// 827E4DF8: D3E1021C  stfs f31, 0x21c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), tmp.u32 ) };
	// 827E4DFC: 4BAE44F5  bl 0x822c92f0
	ctx.lr = 0x827E4E00;
	sub_822C92F0(ctx, base);
	// 827E4E00: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E4E04: 38C10130  addi r6, r1, 0x130
	ctx.r[6].s64 = ctx.r[1].s64 + 304;
	// 827E4E08: 38A10210  addi r5, r1, 0x210
	ctx.r[5].s64 = ctx.r[1].s64 + 528;
	// 827E4E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4E14: 488DF3A5  bl 0x830c41b8
	ctx.lr = 0x827E4E18;
	sub_830C41B8(ctx, base);
	// 827E4E18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E4E1C: 48000008  b 0x827e4e24
	pc = 0x827E4E24; continue 'dispatch;
	// 827E4E20: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E4E24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E4E28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4E2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4E30: 4BAE3F39  bl 0x822c8d68
	ctx.lr = 0x827E4E34;
	sub_822C8D68(ctx, base);
	// 827E4E34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E4E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4E3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4E40: 4BADB1C1  bl 0x822c0000
	ctx.lr = 0x827E4E44;
	sub_822C0000(ctx, base);
	// 827E4E44: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E4E48: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E4E4C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4E50: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E4E54: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E4E58: 419A0024  beq cr6, 0x827e4e7c
	if ctx.cr[6].eq {
	pc = 0x827E4E7C; continue 'dispatch;
	}
	// 827E4E5C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E4E60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4E64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4E68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4E6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4E70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4E74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4E78: 4082FFE8  bne 0x827e4e60
	if !ctx.cr[0].eq {
	pc = 0x827E4E60; continue 'dispatch;
	}
	// 827E4E7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4E84: 488DEA95  bl 0x830c3918
	ctx.lr = 0x827E4E88;
	sub_830C3918(ctx, base);
	// 827E4E88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E4E8C: 3D40827E  lis r10, -0x7d82
	ctx.r[10].s64 = -2105671680;
	// 827E4E90: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E4E94: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 827E4E98: 394AC228  addi r10, r10, -0x3dd8
	ctx.r[10].s64 = ctx.r[10].s64 + -15832;
	// 827E4E9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E4EA0: 896BB861  lbz r11, -0x479f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-18335 as u32) ) } as u64;
	// 827E4EA4: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E4EA8: 93410290  stw r26, 0x290(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(656 as u32), ctx.r[26].u32 ) };
	// 827E4EAC: 4BAE3E0D  bl 0x822c8cb8
	ctx.lr = 0x827E4EB0;
	sub_822C8CB8(ctx, base);
	// 827E4EB0: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 827E4EB4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E4EB8: 4BFF9381  bl 0x827de238
	ctx.lr = 0x827E4EBC;
	sub_827DE238(ctx, base);
	// 827E4EBC: 38810290  addi r4, r1, 0x290
	ctx.r[4].s64 = ctx.r[1].s64 + 656;
	// 827E4EC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4EC4: 4BDA704D  bl 0x8258bf10
	ctx.lr = 0x827E4EC8;
	sub_8258BF10(ctx, base);
	// 827E4EC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E4ECC: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E4ED0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E4ED4: 4BC8C1F5  bl 0x824710c8
	ctx.lr = 0x827E4ED8;
	sub_824710C8(ctx, base);
	// 827E4ED8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E4EDC: 4BAE3DDD  bl 0x822c8cb8
	ctx.lr = 0x827E4EE0;
	sub_822C8CB8(ctx, base);
	// 827E4EE0: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 827E4EE4: 4BAE3DD5  bl 0x822c8cb8
	ctx.lr = 0x827E4EE8;
	sub_822C8CB8(ctx, base);
	// 827E4EE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4EEC: 419A000C  beq cr6, 0x827e4ef8
	if ctx.cr[6].eq {
	pc = 0x827E4EF8; continue 'dispatch;
	}
	// 827E4EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4EF4: 4BADB99D  bl 0x822c0890
	ctx.lr = 0x827E4EF8;
	sub_822C0890(ctx, base);
	// 827E4EF8: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E4EFC: 4BADBA3D  bl 0x822c0938
	ctx.lr = 0x827E4F00;
	sub_822C0938(ctx, base);
	// 827E4F00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E4F04: 41820068  beq 0x827e4f6c
	if ctx.cr[0].eq {
	pc = 0x827E4F6C; continue 'dispatch;
	}
	// 827E4F08: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4F0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E4F10: EDA0F028  fsubs f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E4F14: D3A10150  stfs f29, 0x150(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 827E4F18: D3E10158  stfs f31, 0x158(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 827E4F1C: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E4F20: D3E1015C  stfs f31, 0x15c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 827E4F24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E4F28: D3610180  stfs f27, 0x180(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 827E4F2C: 388A5834  addi r4, r10, 0x5834
	ctx.r[4].s64 = ctx.r[10].s64 + 22580;
	// 827E4F30: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E4F34: D3810184  stfs f28, 0x184(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 827E4F38: D3E10188  stfs f31, 0x188(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 827E4F3C: D3E1018C  stfs f31, 0x18c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 827E4F40: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E4F44: D0010154  stfs f0, 0x154(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 827E4F48: 4BAE43A9  bl 0x822c92f0
	ctx.lr = 0x827E4F4C;
	sub_822C92F0(ctx, base);
	// 827E4F4C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E4F50: 38C10150  addi r6, r1, 0x150
	ctx.r[6].s64 = ctx.r[1].s64 + 336;
	// 827E4F54: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 827E4F58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E4F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E4F60: 488DF259  bl 0x830c41b8
	ctx.lr = 0x827E4F64;
	sub_830C41B8(ctx, base);
	// 827E4F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E4F68: 48000008  b 0x827e4f70
	pc = 0x827E4F70; continue 'dispatch;
	// 827E4F6C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E4F70: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E4F74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4F78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4F7C: 4BAE3DED  bl 0x822c8d68
	ctx.lr = 0x827E4F80;
	sub_822C8D68(ctx, base);
	// 827E4F80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E4F84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E4F88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E4F8C: 4BADB075  bl 0x822c0000
	ctx.lr = 0x827E4F90;
	sub_822C0000(ctx, base);
	// 827E4F90: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E4F94: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E4F98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E4F9C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E4FA0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E4FA4: 419A0024  beq cr6, 0x827e4fc8
	if ctx.cr[6].eq {
	pc = 0x827E4FC8; continue 'dispatch;
	}
	// 827E4FA8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E4FAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E4FB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4FB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E4FB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E4FBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E4FC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E4FC4: 4082FFE8  bne 0x827e4fac
	if !ctx.cr[0].eq {
	pc = 0x827E4FAC; continue 'dispatch;
	}
	// 827E4FC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E4FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E4FD0: 488DE949  bl 0x830c3918
	ctx.lr = 0x827E4FD4;
	sub_830C3918(ctx, base);
	// 827E4FD4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E4FD8: 3D40827E  lis r10, -0x7d82
	ctx.r[10].s64 = -2105671680;
	// 827E4FDC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E4FE0: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 827E4FE4: 394AC2E8  addi r10, r10, -0x3d18
	ctx.r[10].s64 = ctx.r[10].s64 + -15640;
	// 827E4FE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E4FEC: 896BA0B5  lbz r11, -0x5f4b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24395 as u32) ) } as u64;
	// 827E4FF0: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E4FF4: 93410250  stw r26, 0x250(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(592 as u32), ctx.r[26].u32 ) };
	// 827E4FF8: 4BAE3CC1  bl 0x822c8cb8
	ctx.lr = 0x827E4FFC;
	sub_822C8CB8(ctx, base);
	// 827E4FFC: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 827E5000: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E5004: 4BFF9235  bl 0x827de238
	ctx.lr = 0x827E5008;
	sub_827DE238(ctx, base);
	// 827E5008: 38810250  addi r4, r1, 0x250
	ctx.r[4].s64 = ctx.r[1].s64 + 592;
	// 827E500C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5010: 4BDA6F01  bl 0x8258bf10
	ctx.lr = 0x827E5014;
	sub_8258BF10(ctx, base);
	// 827E5014: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E5018: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E501C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E5020: 4BC8C0A9  bl 0x824710c8
	ctx.lr = 0x827E5024;
	sub_824710C8(ctx, base);
	// 827E5024: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E5028: 4BAE3C91  bl 0x822c8cb8
	ctx.lr = 0x827E502C;
	sub_822C8CB8(ctx, base);
	// 827E502C: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 827E5030: 4BAE3C89  bl 0x822c8cb8
	ctx.lr = 0x827E5034;
	sub_822C8CB8(ctx, base);
	// 827E5034: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E5038: 419A000C  beq cr6, 0x827e5044
	if ctx.cr[6].eq {
	pc = 0x827E5044; continue 'dispatch;
	}
	// 827E503C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5040: 4BADB851  bl 0x822c0890
	ctx.lr = 0x827E5044;
	sub_822C0890(ctx, base);
	// 827E5044: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E5048: 4BADB8F1  bl 0x822c0938
	ctx.lr = 0x827E504C;
	sub_822C0938(ctx, base);
	// 827E504C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E5050: 41820060  beq 0x827e50b0
	if ctx.cr[0].eq {
	pc = 0x827E50B0; continue 'dispatch;
	}
	// 827E5054: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5058: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E505C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E5060: D3A10170  stfs f29, 0x170(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 827E5064: D3E10178  stfs f31, 0x178(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 827E5068: 388B581C  addi r4, r11, 0x581c
	ctx.r[4].s64 = ctx.r[11].s64 + 22556;
	// 827E506C: D3E1017C  stfs f31, 0x17c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 827E5070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5074: D3610190  stfs f27, 0x190(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 827E5078: D3810194  stfs f28, 0x194(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 827E507C: D3E10198  stfs f31, 0x198(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 827E5080: D3E1019C  stfs f31, 0x19c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 827E5084: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 827E5088: D0010174  stfs f0, 0x174(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 827E508C: 4BAE4265  bl 0x822c92f0
	ctx.lr = 0x827E5090;
	sub_822C92F0(ctx, base);
	// 827E5090: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E5094: 38C10170  addi r6, r1, 0x170
	ctx.r[6].s64 = ctx.r[1].s64 + 368;
	// 827E5098: 38A10190  addi r5, r1, 0x190
	ctx.r[5].s64 = ctx.r[1].s64 + 400;
	// 827E509C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E50A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E50A4: 488DF115  bl 0x830c41b8
	ctx.lr = 0x827E50A8;
	sub_830C41B8(ctx, base);
	// 827E50A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E50AC: 48000008  b 0x827e50b4
	pc = 0x827E50B4; continue 'dispatch;
	// 827E50B0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E50B4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E50B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E50BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E50C0: 4BAE3CA9  bl 0x822c8d68
	ctx.lr = 0x827E50C4;
	sub_822C8D68(ctx, base);
	// 827E50C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E50C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E50CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E50D0: 4BADAF31  bl 0x822c0000
	ctx.lr = 0x827E50D4;
	sub_822C0000(ctx, base);
	// 827E50D4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E50D8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E50DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E50E0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E50E4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E50E8: 419A0024  beq cr6, 0x827e510c
	if ctx.cr[6].eq {
	pc = 0x827E510C; continue 'dispatch;
	}
	// 827E50EC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E50F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E50F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E50F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E50FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E5100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E5104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5108: 4082FFE8  bne 0x827e50f0
	if !ctx.cr[0].eq {
	pc = 0x827E50F0; continue 'dispatch;
	}
	// 827E510C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E5110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5114: 488DE805  bl 0x830c3918
	ctx.lr = 0x827E5118;
	sub_830C3918(ctx, base);
	// 827E5118: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E511C: 3D40827E  lis r10, -0x7d82
	ctx.r[10].s64 = -2105671680;
	// 827E5120: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E5124: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 827E5128: 394AC2F8  addi r10, r10, -0x3d08
	ctx.r[10].s64 = ctx.r[10].s64 + -15624;
	// 827E512C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E5130: 896BA0B6  lbz r11, -0x5f4a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24394 as u32) ) } as u64;
	// 827E5134: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E5138: 93410270  stw r26, 0x270(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), ctx.r[26].u32 ) };
	// 827E513C: 4BAE3B7D  bl 0x822c8cb8
	ctx.lr = 0x827E5140;
	sub_822C8CB8(ctx, base);
	// 827E5140: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 827E5144: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E5148: 4BFF90F1  bl 0x827de238
	ctx.lr = 0x827E514C;
	sub_827DE238(ctx, base);
	// 827E514C: 38810270  addi r4, r1, 0x270
	ctx.r[4].s64 = ctx.r[1].s64 + 624;
	// 827E5150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5154: 4BDA6DBD  bl 0x8258bf10
	ctx.lr = 0x827E5158;
	sub_8258BF10(ctx, base);
	// 827E5158: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E515C: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E5160: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E5164: 4BC8BF65  bl 0x824710c8
	ctx.lr = 0x827E5168;
	sub_824710C8(ctx, base);
	// 827E5168: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E516C: 4BAE3B4D  bl 0x822c8cb8
	ctx.lr = 0x827E5170;
	sub_822C8CB8(ctx, base);
	// 827E5170: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 827E5174: 4BAE3B45  bl 0x822c8cb8
	ctx.lr = 0x827E5178;
	sub_822C8CB8(ctx, base);
	// 827E5178: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E517C: 419A000C  beq cr6, 0x827e5188
	if ctx.cr[6].eq {
	pc = 0x827E5188; continue 'dispatch;
	}
	// 827E5180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5184: 4BADB70D  bl 0x822c0890
	ctx.lr = 0x827E5188;
	sub_822C0890(ctx, base);
	// 827E5188: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E518C: 4BADB7AD  bl 0x822c0938
	ctx.lr = 0x827E5190;
	sub_822C0938(ctx, base);
	// 827E5190: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E5194: 41820068  beq 0x827e51fc
	if ctx.cr[0].eq {
	pc = 0x827E51FC; continue 'dispatch;
	}
	// 827E5198: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E519C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E51A0: EDA0F028  fsubs f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E51A4: D3A101B0  stfs f29, 0x1b0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 827E51A8: D3E101B8  stfs f31, 0x1b8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 827E51AC: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E51B0: D3E101BC  stfs f31, 0x1bc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 827E51B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E51B8: D36100B0  stfs f27, 0xb0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 827E51BC: 388A5808  addi r4, r10, 0x5808
	ctx.r[4].s64 = ctx.r[10].s64 + 22536;
	// 827E51C0: C00B9584  lfs f0, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E51C4: D38100B4  stfs f28, 0xb4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 827E51C8: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 827E51CC: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 827E51D0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E51D4: D00101B4  stfs f0, 0x1b4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 827E51D8: 4BAE4119  bl 0x822c92f0
	ctx.lr = 0x827E51DC;
	sub_822C92F0(ctx, base);
	// 827E51DC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E51E0: 38C101B0  addi r6, r1, 0x1b0
	ctx.r[6].s64 = ctx.r[1].s64 + 432;
	// 827E51E4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 827E51E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E51EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E51F0: 488DEFC9  bl 0x830c41b8
	ctx.lr = 0x827E51F4;
	sub_830C41B8(ctx, base);
	// 827E51F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E51F8: 48000008  b 0x827e5200
	pc = 0x827E5200; continue 'dispatch;
	// 827E51FC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E5200: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5208: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E520C: 4BAE3B5D  bl 0x822c8d68
	ctx.lr = 0x827E5210;
	sub_822C8D68(ctx, base);
	// 827E5210: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E5214: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5218: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E521C: 4BADADE5  bl 0x822c0000
	ctx.lr = 0x827E5220;
	sub_822C0000(ctx, base);
	// 827E5220: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E5224: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5228: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E522C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E5230: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E5234: 419A0024  beq cr6, 0x827e5258
	if ctx.cr[6].eq {
	pc = 0x827E5258; continue 'dispatch;
	}
	// 827E5238: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E523C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E5240: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5244: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E5248: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E524C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E5250: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5254: 4082FFE8  bne 0x827e523c
	if !ctx.cr[0].eq {
	pc = 0x827E523C; continue 'dispatch;
	}
	// 827E5258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E525C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5260: 488DE6B9  bl 0x830c3918
	ctx.lr = 0x827E5264;
	sub_830C3918(ctx, base);
	// 827E5264: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5268: 3D40827E  lis r10, -0x7d82
	ctx.r[10].s64 = -2105671680;
	// 827E526C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E5270: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 827E5274: 394AC3C0  addi r10, r10, -0x3c40
	ctx.r[10].s64 = ctx.r[10].s64 + -15424;
	// 827E5278: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E527C: 896BB862  lbz r11, -0x479e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-18334 as u32) ) } as u64;
	// 827E5280: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E5284: 934102B0  stw r26, 0x2b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(688 as u32), ctx.r[26].u32 ) };
	// 827E5288: 4BAE3A31  bl 0x822c8cb8
	ctx.lr = 0x827E528C;
	sub_822C8CB8(ctx, base);
	// 827E528C: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 827E5290: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E5294: 4BFF8FA5  bl 0x827de238
	ctx.lr = 0x827E5298;
	sub_827DE238(ctx, base);
	// 827E5298: 388102B0  addi r4, r1, 0x2b0
	ctx.r[4].s64 = ctx.r[1].s64 + 688;
	// 827E529C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E52A0: 4BDA6C71  bl 0x8258bf10
	ctx.lr = 0x827E52A4;
	sub_8258BF10(ctx, base);
	// 827E52A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E52A8: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E52AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E52B0: 4BC8BE19  bl 0x824710c8
	ctx.lr = 0x827E52B4;
	sub_824710C8(ctx, base);
	// 827E52B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E52B8: 4BAE3A01  bl 0x822c8cb8
	ctx.lr = 0x827E52BC;
	sub_822C8CB8(ctx, base);
	// 827E52BC: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 827E52C0: 4BAE39F9  bl 0x822c8cb8
	ctx.lr = 0x827E52C4;
	sub_822C8CB8(ctx, base);
	// 827E52C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E52C8: 419A000C  beq cr6, 0x827e52d4
	if ctx.cr[6].eq {
	pc = 0x827E52D4; continue 'dispatch;
	}
	// 827E52CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E52D0: 4BADB5C1  bl 0x822c0890
	ctx.lr = 0x827E52D4;
	sub_822C0890(ctx, base);
	// 827E52D4: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E52D8: 4BADB661  bl 0x822c0938
	ctx.lr = 0x827E52DC;
	sub_822C0938(ctx, base);
	// 827E52DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E52E0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 827E52E4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 827E52E8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E52EC: C36B967C  lfs f27, -0x6984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 827E52F0: C3AA89AC  lfs f29, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 827E52F4: C349D7B8  lfs f26, -0x2848(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10312 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 827E52F8: 41820054  beq 0x827e534c
	if ctx.cr[0].eq {
	pc = 0x827E534C; continue 'dispatch;
	}
	// 827E52FC: D34101F0  stfs f26, 0x1f0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(496 as u32), tmp.u32 ) };
	// 827E5300: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5304: D3A101F4  stfs f29, 0x1f4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 827E5308: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E530C: D3E101F8  stfs f31, 0x1f8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 827E5310: 388B5800  addi r4, r11, 0x5800
	ctx.r[4].s64 = ctx.r[11].s64 + 22528;
	// 827E5314: D3E101FC  stfs f31, 0x1fc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 827E5318: D36101C0  stfs f27, 0x1c0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 827E531C: D38101C4  stfs f28, 0x1c4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 827E5320: D3E101C8  stfs f31, 0x1c8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 827E5324: D3E101CC  stfs f31, 0x1cc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 827E5328: 4BAE3FC9  bl 0x822c92f0
	ctx.lr = 0x827E532C;
	sub_822C92F0(ctx, base);
	// 827E532C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E5330: 38C101F0  addi r6, r1, 0x1f0
	ctx.r[6].s64 = ctx.r[1].s64 + 496;
	// 827E5334: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 827E5338: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E533C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5340: 488E2B69  bl 0x830c7ea8
	ctx.lr = 0x827E5344;
	sub_830C7EA8(ctx, base);
	// 827E5344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E5348: 48000008  b 0x827e5350
	pc = 0x827E5350; continue 'dispatch;
	// 827E534C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E5350: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5354: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E535C: 4BAE43A5  bl 0x822c9700
	ctx.lr = 0x827E5360;
	sub_822C9700(ctx, base);
	// 827E5360: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E5364: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5368: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E536C: 4BADAC95  bl 0x822c0000
	ctx.lr = 0x827E5370;
	sub_822C0000(ctx, base);
	// 827E5370: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E5374: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5378: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E537C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E5380: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E5384: 419A0024  beq cr6, 0x827e53a8
	if ctx.cr[6].eq {
	pc = 0x827E53A8; continue 'dispatch;
	}
	// 827E5388: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E538C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E5390: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5394: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E5398: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E539C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E53A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E53A4: 4082FFE8  bne 0x827e538c
	if !ctx.cr[0].eq {
	pc = 0x827E538C; continue 'dispatch;
	}
	// 827E53A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E53AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E53B0: 488DE569  bl 0x830c3918
	ctx.lr = 0x827E53B4;
	sub_830C3918(ctx, base);
	// 827E53B4: 934102F0  stw r26, 0x2f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(752 as u32), ctx.r[26].u32 ) };
	// 827E53B8: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E53BC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E53C0: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 827E53C4: 396BCF70  addi r11, r11, -0x3090
	ctx.r[11].s64 = ctx.r[11].s64 + -12432;
	// 827E53C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E53CC: 4BAE38ED  bl 0x822c8cb8
	ctx.lr = 0x827E53D0;
	sub_822C8CB8(ctx, base);
	// 827E53D0: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 827E53D4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E53D8: 4BFF8F61  bl 0x827de338
	ctx.lr = 0x827E53DC;
	sub_827DE338(ctx, base);
	// 827E53DC: 388102F0  addi r4, r1, 0x2f0
	ctx.r[4].s64 = ctx.r[1].s64 + 752;
	// 827E53E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E53E4: 4BDA6B2D  bl 0x8258bf10
	ctx.lr = 0x827E53E8;
	sub_8258BF10(ctx, base);
	// 827E53E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E53EC: 387D00C0  addi r3, r29, 0xc0
	ctx.r[3].s64 = ctx.r[29].s64 + 192;
	// 827E53F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E53F4: 4BC8BCD5  bl 0x824710c8
	ctx.lr = 0x827E53F8;
	sub_824710C8(ctx, base);
	// 827E53F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E53FC: 4BAE38BD  bl 0x822c8cb8
	ctx.lr = 0x827E5400;
	sub_822C8CB8(ctx, base);
	// 827E5400: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 827E5404: 4BAE38B5  bl 0x822c8cb8
	ctx.lr = 0x827E5408;
	sub_822C8CB8(ctx, base);
	// 827E5408: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E540C: 419A000C  beq cr6, 0x827e5418
	if ctx.cr[6].eq {
	pc = 0x827E5418; continue 'dispatch;
	}
	// 827E5410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5414: 4BADB47D  bl 0x822c0890
	ctx.lr = 0x827E5418;
	sub_822C0890(ctx, base);
	// 827E5418: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E541C: 4BADB51D  bl 0x822c0938
	ctx.lr = 0x827E5420;
	sub_822C0938(ctx, base);
	// 827E5420: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E5424: 4182005C  beq 0x827e5480
	if ctx.cr[0].eq {
	pc = 0x827E5480; continue 'dispatch;
	}
	// 827E5428: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E542C: D3A100C4  stfs f29, 0xc4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 827E5430: D3E100C8  stfs f31, 0xc8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 827E5434: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E5438: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 827E543C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5440: D36100E0  stfs f27, 0xe0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 827E5444: 388A57F4  addi r4, r10, 0x57f4
	ctx.r[4].s64 = ctx.r[10].s64 + 22516;
	// 827E5448: D38100E4  stfs f28, 0xe4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 827E544C: C00BE2B4  lfs f0, -0x1d4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5450: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 827E5454: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 827E5458: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 827E545C: 4BAE3E95  bl 0x822c92f0
	ctx.lr = 0x827E5460;
	sub_822C92F0(ctx, base);
	// 827E5460: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E5464: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 827E5468: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 827E546C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E5470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5474: 488E2A35  bl 0x830c7ea8
	ctx.lr = 0x827E5478;
	sub_830C7EA8(ctx, base);
	// 827E5478: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E547C: 48000008  b 0x827e5484
	pc = 0x827E5484; continue 'dispatch;
	// 827E5480: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E5484: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E548C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5490: 4BAE4271  bl 0x822c9700
	ctx.lr = 0x827E5494;
	sub_822C9700(ctx, base);
	// 827E5494: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E5498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E549C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E54A0: 4BADAB61  bl 0x822c0000
	ctx.lr = 0x827E54A4;
	sub_822C0000(ctx, base);
	// 827E54A4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E54A8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E54AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E54B0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E54B4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E54B8: 419A0024  beq cr6, 0x827e54dc
	if ctx.cr[6].eq {
	pc = 0x827E54DC; continue 'dispatch;
	}
	// 827E54BC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E54C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E54C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E54C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E54CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E54D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E54D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E54D8: 4082FFE8  bne 0x827e54c0
	if !ctx.cr[0].eq {
	pc = 0x827E54C0; continue 'dispatch;
	}
	// 827E54DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E54E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E54E4: 488DE435  bl 0x830c3918
	ctx.lr = 0x827E54E8;
	sub_830C3918(ctx, base);
	// 827E54E8: 934102D0  stw r26, 0x2d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(720 as u32), ctx.r[26].u32 ) };
	// 827E54EC: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E54F0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E54F4: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 827E54F8: 396BCAA8  addi r11, r11, -0x3558
	ctx.r[11].s64 = ctx.r[11].s64 + -13656;
	// 827E54FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E5500: 4BAE37B9  bl 0x822c8cb8
	ctx.lr = 0x827E5504;
	sub_822C8CB8(ctx, base);
	// 827E5504: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 827E5508: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E550C: 4BFF8E2D  bl 0x827de338
	ctx.lr = 0x827E5510;
	sub_827DE338(ctx, base);
	// 827E5510: 388102D0  addi r4, r1, 0x2d0
	ctx.r[4].s64 = ctx.r[1].s64 + 720;
	// 827E5514: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5518: 4BDA69F9  bl 0x8258bf10
	ctx.lr = 0x827E551C;
	sub_8258BF10(ctx, base);
	// 827E551C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E5520: 387D00C0  addi r3, r29, 0xc0
	ctx.r[3].s64 = ctx.r[29].s64 + 192;
	// 827E5524: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E5528: 4BC8BBA1  bl 0x824710c8
	ctx.lr = 0x827E552C;
	sub_824710C8(ctx, base);
	// 827E552C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E5530: 4BAE3789  bl 0x822c8cb8
	ctx.lr = 0x827E5534;
	sub_822C8CB8(ctx, base);
	// 827E5534: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 827E5538: 4BAE3781  bl 0x822c8cb8
	ctx.lr = 0x827E553C;
	sub_822C8CB8(ctx, base);
	// 827E553C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E5540: 419A000C  beq cr6, 0x827e554c
	if ctx.cr[6].eq {
	pc = 0x827E554C; continue 'dispatch;
	}
	// 827E5544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5548: 4BADB349  bl 0x822c0890
	ctx.lr = 0x827E554C;
	sub_822C0890(ctx, base);
	// 827E554C: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 827E5550: 4BADB3E9  bl 0x822c0938
	ctx.lr = 0x827E5554;
	sub_822C0938(ctx, base);
	// 827E5554: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E5558: 41820064  beq 0x827e55bc
	if ctx.cr[0].eq {
	pc = 0x827E55BC; continue 'dispatch;
	}
	// 827E555C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5560: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5564: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E5568: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 827E556C: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 827E5570: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E5574: D3E1010C  stfs f31, 0x10c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 827E5578: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E557C: D3210120  stfs f25, 0x120(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 827E5580: 388A57E8  addi r4, r10, 0x57e8
	ctx.r[4].s64 = ctx.r[10].s64 + 22504;
	// 827E5584: C00B57F0  lfs f0, 0x57f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5588: D0010100  stfs f0, 0x100(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 827E558C: D3010124  stfs f24, 0x124(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 827E5590: D3E10128  stfs f31, 0x128(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 827E5594: D3E1012C  stfs f31, 0x12c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 827E5598: 4BAE3D59  bl 0x822c92f0
	ctx.lr = 0x827E559C;
	sub_822C92F0(ctx, base);
	// 827E559C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E55A0: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 827E55A4: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 827E55A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E55AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E55B0: 488E2BB9  bl 0x830c8168
	ctx.lr = 0x827E55B4;
	sub_830C8168(ctx, base);
	// 827E55B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E55B8: 48000008  b 0x827e55c0
	pc = 0x827E55C0; continue 'dispatch;
	// 827E55BC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E55C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E55C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E55C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E55CC: 4BAE406D  bl 0x822c9638
	ctx.lr = 0x827E55D0;
	sub_822C9638(ctx, base);
	// 827E55D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E55D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E55D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E55DC: 4BADAA25  bl 0x822c0000
	ctx.lr = 0x827E55E0;
	sub_822C0000(ctx, base);
	// 827E55E0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E55E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E55E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E55EC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E55F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E55F4: 419A0024  beq cr6, 0x827e5618
	if ctx.cr[6].eq {
	pc = 0x827E5618; continue 'dispatch;
	}
	// 827E55F8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E55FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E5600: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5604: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E5608: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E560C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E5610: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5614: 4082FFE8  bne 0x827e55fc
	if !ctx.cr[0].eq {
	pc = 0x827E55FC; continue 'dispatch;
	}
	// 827E5618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E561C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5620: 488DE2F9  bl 0x830c3918
	ctx.lr = 0x827E5624;
	sub_830C3918(ctx, base);
	// 827E5624: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E5628: 419A000C  beq cr6, 0x827e5634
	if ctx.cr[6].eq {
	pc = 0x827E5634; continue 'dispatch;
	}
	// 827E562C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5630: 4BADB261  bl 0x822c0890
	ctx.lr = 0x827E5634;
	sub_822C0890(ctx, base);
	// 827E5634: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 827E5638: 4BADB301  bl 0x822c0938
	ctx.lr = 0x827E563C;
	sub_822C0938(ctx, base);
	// 827E563C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827E5640: 4182005C  beq 0x827e569c
	if ctx.cr[0].eq {
	pc = 0x827E569C; continue 'dispatch;
	}
	// 827E5644: C0170004  lfs f0, 4(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5648: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E564C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E5650: D3410140  stfs f26, 0x140(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 827E5654: D0010144  stfs f0, 0x144(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 827E5658: 388B57D4  addi r4, r11, 0x57d4
	ctx.r[4].s64 = ctx.r[11].s64 + 22484;
	// 827E565C: D3E10148  stfs f31, 0x148(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 827E5660: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5664: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 827E5668: D3210160  stfs f25, 0x160(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 827E566C: D3010164  stfs f24, 0x164(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 827E5670: D3E10168  stfs f31, 0x168(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 827E5674: D3E1016C  stfs f31, 0x16c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 827E5678: 4BAE3C79  bl 0x822c92f0
	ctx.lr = 0x827E567C;
	sub_822C92F0(ctx, base);
	// 827E567C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E5680: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 827E5684: 38A10160  addi r5, r1, 0x160
	ctx.r[5].s64 = ctx.r[1].s64 + 352;
	// 827E5688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E568C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5690: 488E1FE9  bl 0x830c7678
	ctx.lr = 0x827E5694;
	sub_830C7678(ctx, base);
	// 827E5694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E5698: 48000008  b 0x827e56a0
	pc = 0x827E56A0; continue 'dispatch;
	// 827E569C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 827E56A0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E56A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E56A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E56AC: 4BAE411D  bl 0x822c97c8
	ctx.lr = 0x827E56B0;
	sub_822C97C8(ctx, base);
	// 827E56B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E56B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E56B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E56BC: 4BADA945  bl 0x822c0000
	ctx.lr = 0x827E56C0;
	sub_822C0000(ctx, base);
	// 827E56C0: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E56C4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E56C8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827E56CC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 827E56D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E56D4: 419A0024  beq cr6, 0x827e56f8
	if ctx.cr[6].eq {
	pc = 0x827E56F8; continue 'dispatch;
	}
	// 827E56D8: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 827E56DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E56E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E56E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E56E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E56EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E56F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E56F4: 4082FFE8  bne 0x827e56dc
	if !ctx.cr[0].eq {
	pc = 0x827E56DC; continue 'dispatch;
	}
	// 827E56F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E56FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5700: 488DE219  bl 0x830c3918
	ctx.lr = 0x827E5704;
	sub_830C3918(ctx, base);
	// 827E5704: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5708: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 827E570C: 388B57CC  addi r4, r11, 0x57cc
	ctx.r[4].s64 = ctx.r[11].s64 + 22476;
	// 827E5710: 4BAE3BE1  bl 0x822c92f0
	ctx.lr = 0x827E5714;
	sub_822C92F0(ctx, base);
	// 827E5714: 3BDD00E4  addi r30, r29, 0xe4
	ctx.r[30].s64 = ctx.r[29].s64 + 228;
	// 827E5718: 38C10330  addi r6, r1, 0x330
	ctx.r[6].s64 = ctx.r[1].s64 + 816;
	// 827E571C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5720: 839D00E8  lwz r28, 0xe8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(232 as u32) ) } as u64;
	// 827E5724: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E5728: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E572C: 4BAE4CFD  bl 0x822ca428
	ctx.lr = 0x827E5730;
	sub_822CA428(ctx, base);
	// 827E5730: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827E5734: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E5738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E573C: 4BAE482D  bl 0x822c9f68
	ctx.lr = 0x827E5740;
	sub_822C9F68(ctx, base);
	// 827E5740: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 827E5744: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5748: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E574C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827E5750: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E5754: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 827E5758: 4BAE36D9  bl 0x822c8e30
	ctx.lr = 0x827E575C;
	sub_822C8E30(ctx, base);
	// 827E575C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E5760: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E5764: 4860C7FD  bl 0x82df1f60
	ctx.lr = 0x827E5768;
	sub_82DF1F60(ctx, base);
	// 827E5768: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 827E576C: 40810068  ble 0x827e57d4
	if !ctx.cr[0].gt {
	pc = 0x827E57D4; continue 'dispatch;
	}
	// 827E5770: 3B77002C  addi r27, r23, 0x2c
	ctx.r[27].s64 = ctx.r[23].s64 + 44;
	// 827E5774: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E5778: 38610350  addi r3, r1, 0x350
	ctx.r[3].s64 = ctx.r[1].s64 + 848;
	// 827E577C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5780: 4BAE3B71  bl 0x822c92f0
	ctx.lr = 0x827E5784;
	sub_822C92F0(ctx, base);
	// 827E5784: 38C10350  addi r6, r1, 0x350
	ctx.r[6].s64 = ctx.r[1].s64 + 848;
	// 827E5788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E578C: 831E0004  lwz r24, 4(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5790: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827E5794: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5798: 4BAE4C91  bl 0x822ca428
	ctx.lr = 0x827E579C;
	sub_822CA428(ctx, base);
	// 827E579C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 827E57A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E57A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E57A8: 4BAE47C1  bl 0x822c9f68
	ctx.lr = 0x827E57AC;
	sub_822C9F68(ctx, base);
	// 827E57AC: 92F80004  stw r23, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 827E57B0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E57B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E57B8: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 827E57BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E57C0: 38610350  addi r3, r1, 0x350
	ctx.r[3].s64 = ctx.r[1].s64 + 848;
	// 827E57C4: 4BAE366D  bl 0x822c8e30
	ctx.lr = 0x827E57C8;
	sub_822C8E30(ctx, base);
	// 827E57C8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E57CC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 827E57D0: 4082FFA8  bne 0x827e5778
	if !ctx.cr[0].eq {
	pc = 0x827E5778; continue 'dispatch;
	}
	// 827E57D4: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E57D8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E57DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E57E0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 827E57E4: 396BCB48  addi r11, r11, -0x34b8
	ctx.r[11].s64 = ctx.r[11].s64 + -13496;
	// 827E57E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E57EC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E57F0: 4BFF8AC9  bl 0x827de2b8
	ctx.lr = 0x827E57F4;
	sub_827DE2B8(ctx, base);
	// 827E57F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E57F8: 387D00C0  addi r3, r29, 0xc0
	ctx.r[3].s64 = ctx.r[29].s64 + 192;
	// 827E57FC: 4BC8B8CD  bl 0x824710c8
	ctx.lr = 0x827E5800;
	sub_824710C8(ctx, base);
	// 827E5800: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5804: 4BAE34B5  bl 0x822c8cb8
	ctx.lr = 0x827E5808;
	sub_822C8CB8(ctx, base);
	// 827E5808: 9ADD00F9  stb r22, 0xf9(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(249 as u32), ctx.r[22].u8 ) };
	// 827E580C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5810: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E5814: 816BB868  lwz r11, -0x4798(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18328 as u32) ) } as u64;
	// 827E5818: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 827E581C: 488E13D5  bl 0x830c6bf0
	ctx.lr = 0x827E5820;
	sub_830C6BF0(ctx, base);
	// 827E5820: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827E5824: 419A000C  beq cr6, 0x827e5830
	if ctx.cr[6].eq {
	pc = 0x827E5830; continue 'dispatch;
	}
	// 827E5828: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E582C: 4BADB065  bl 0x822c0890
	ctx.lr = 0x827E5830;
	sub_822C0890(ctx, base);
	// 827E5830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5834: 38210420  addi r1, r1, 0x420
	ctx.r[1].s64 = ctx.r[1].s64 + 1056;
	// 827E5838: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 827E583C: 489C3279  bl 0x831a8ab4
	ctx.lr = 0x827E5840;
	sub_831A8A8C(ctx, base);
	// 827E5840: 489C2958  b 0x831a8198
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E5848 size=344
    let mut pc: u32 = 0x827E5848;
    'dispatch: loop {
        match pc {
            0x827E5848 => {
    //   block [0x827E5848..0x827E59A0)
	// 827E5848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E584C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E5854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E5858: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E585C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E5860: 816BA0AC  lwz r11, -0x5f54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24404 as u32) ) } as u64;
	// 827E5864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E5868: 419A0010  beq cr6, 0x827e5878
	if ctx.cr[6].eq {
	pc = 0x827E5878; continue 'dispatch;
	}
	// 827E586C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E5870: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 827E5874: 48000114  b 0x827e5988
	pc = 0x827E5988; continue 'dispatch;
	// 827E5878: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E587C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E5880: 392BB804  addi r9, r11, -0x47fc
	ctx.r[9].s64 = ctx.r[11].s64 + -18428;
	// 827E5884: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 827E5888: C1ABB804  lfs f13, -0x47fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E588C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E5890: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E5894: C1690008  lfs f11, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E5898: C149000C  lfs f10, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E589C: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E58A0: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E58A4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E58A8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E58AC: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827E58B0: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827E58B4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827E58B8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827E58BC: 4BADB07D  bl 0x822c0938
	ctx.lr = 0x827E58C0;
	sub_822C0938(ctx, base);
	// 827E58C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E58C4: 4182001C  beq 0x827e58e0
	if ctx.cr[0].eq {
	pc = 0x827E58E0; continue 'dispatch;
	}
	// 827E58C8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827E58CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E58D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E58D4: 4BFFED2D  bl 0x827e4600
	ctx.lr = 0x827E58D8;
	sub_827E4600(ctx, base);
	// 827E58D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E58DC: 48000008  b 0x827e58e4
	pc = 0x827E58E4; continue 'dispatch;
	// 827E58E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E58E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E58E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E58EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E58F0: 4BFF6E01  bl 0x827dc6f0
	ctx.lr = 0x827E58F4;
	sub_827DC6F0(ctx, base);
	// 827E58F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E58F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E58FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5900: 4BADA701  bl 0x822c0000
	ctx.lr = 0x827E5904;
	sub_822C0000(ctx, base);
	// 827E5904: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5908: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E590C: 388B58C8  addi r4, r11, 0x58c8
	ctx.r[4].s64 = ctx.r[11].s64 + 22728;
	// 827E5910: 4BAE39E1  bl 0x822c92f0
	ctx.lr = 0x827E5914;
	sub_822C92F0(ctx, base);
	// 827E5914: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E5918: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E591C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5920: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E5924: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5928: 419A0024  beq cr6, 0x827e594c
	if ctx.cr[6].eq {
	pc = 0x827E594C; continue 'dispatch;
	}
	// 827E592C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E5930: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E5934: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5938: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E593C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E5940: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E5944: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5948: 4082FFE8  bne 0x827e5930
	if !ctx.cr[0].eq {
	pc = 0x827E5930; continue 'dispatch;
	}
	// 827E594C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E5950: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E5954: 4BAE4505  bl 0x822c9e58
	ctx.lr = 0x827E5958;
	sub_822C9E58(ctx, base);
	// 827E5958: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E595C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E5960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5964: 488DD01D  bl 0x830c2980
	ctx.lr = 0x827E5968;
	sub_830C2980(ctx, base);
	// 827E5968: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E596C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E5970: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E5974: 4BAE34BD  bl 0x822c8e30
	ctx.lr = 0x827E5978;
	sub_822C8E30(ctx, base);
	// 827E5978: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E597C: 419A000C  beq cr6, 0x827e5988
	if ctx.cr[6].eq {
	pc = 0x827E5988; continue 'dispatch;
	}
	// 827E5980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5984: 4BADAF0D  bl 0x822c0890
	ctx.lr = 0x827E5988;
	sub_822C0890(ctx, base);
	// 827E5988: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E598C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5994: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E599C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E59A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E59A0 size=344
    let mut pc: u32 = 0x827E59A0;
    'dispatch: loop {
        match pc {
            0x827E59A0 => {
    //   block [0x827E59A0..0x827E5AF8)
	// 827E59A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E59A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E59A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E59AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E59B0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E59B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E59B8: 816BA0B0  lwz r11, -0x5f50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24400 as u32) ) } as u64;
	// 827E59BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E59C0: 419A0010  beq cr6, 0x827e59d0
	if ctx.cr[6].eq {
	pc = 0x827E59D0; continue 'dispatch;
	}
	// 827E59C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E59C8: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 827E59CC: 48000114  b 0x827e5ae0
	pc = 0x827E5AE0; continue 'dispatch;
	// 827E59D0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E59D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E59D8: 392BB804  addi r9, r11, -0x47fc
	ctx.r[9].s64 = ctx.r[11].s64 + -18428;
	// 827E59DC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 827E59E0: C1ABB804  lfs f13, -0x47fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18428 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E59E4: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E59E8: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E59EC: C1690008  lfs f11, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E59F0: C149000C  lfs f10, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E59F4: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E59F8: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E59FC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E5A00: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E5A04: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827E5A08: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827E5A0C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827E5A10: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827E5A14: 4BADAF25  bl 0x822c0938
	ctx.lr = 0x827E5A18;
	sub_822C0938(ctx, base);
	// 827E5A18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E5A1C: 4182001C  beq 0x827e5a38
	if ctx.cr[0].eq {
	pc = 0x827E5A38; continue 'dispatch;
	}
	// 827E5A20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E5A24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E5A28: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E5A2C: 4BFFEBD5  bl 0x827e4600
	ctx.lr = 0x827E5A30;
	sub_827E4600(ctx, base);
	// 827E5A30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E5A34: 48000008  b 0x827e5a3c
	pc = 0x827E5A3C; continue 'dispatch;
	// 827E5A38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E5A3C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E5A40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E5A44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5A48: 4BFF6CA9  bl 0x827dc6f0
	ctx.lr = 0x827E5A4C;
	sub_827DC6F0(ctx, base);
	// 827E5A4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E5A50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E5A54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5A58: 4BADA5A9  bl 0x822c0000
	ctx.lr = 0x827E5A5C;
	sub_822C0000(ctx, base);
	// 827E5A5C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5A60: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E5A64: 388B58F4  addi r4, r11, 0x58f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22772;
	// 827E5A68: 4BAE3889  bl 0x822c92f0
	ctx.lr = 0x827E5A6C;
	sub_822C92F0(ctx, base);
	// 827E5A6C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E5A70: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5A74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5A78: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E5A7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5A80: 419A0024  beq cr6, 0x827e5aa4
	if ctx.cr[6].eq {
	pc = 0x827E5AA4; continue 'dispatch;
	}
	// 827E5A84: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E5A88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E5A8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5A90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E5A94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E5A98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E5A9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E5AA0: 4082FFE8  bne 0x827e5a88
	if !ctx.cr[0].eq {
	pc = 0x827E5A88; continue 'dispatch;
	}
	// 827E5AA4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E5AA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E5AAC: 4BAE43AD  bl 0x822c9e58
	ctx.lr = 0x827E5AB0;
	sub_822C9E58(ctx, base);
	// 827E5AB0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E5AB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E5AB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5ABC: 488DCEC5  bl 0x830c2980
	ctx.lr = 0x827E5AC0;
	sub_830C2980(ctx, base);
	// 827E5AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E5AC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E5AC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E5ACC: 4BAE3365  bl 0x822c8e30
	ctx.lr = 0x827E5AD0;
	sub_822C8E30(ctx, base);
	// 827E5AD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5AD4: 419A000C  beq cr6, 0x827e5ae0
	if ctx.cr[6].eq {
	pc = 0x827E5AE0; continue 'dispatch;
	}
	// 827E5AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5ADC: 4BADADB5  bl 0x822c0890
	ctx.lr = 0x827E5AE0;
	sub_822C0890(ctx, base);
	// 827E5AE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E5AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5AEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E5AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5AF8 size=72
    let mut pc: u32 = 0x827E5AF8;
    'dispatch: loop {
        match pc {
            0x827E5AF8 => {
    //   block [0x827E5AF8..0x827E5B40)
	// 827E5AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5B00: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 827E5B04: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 827E5B08: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 827E5B0C: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 827E5B10: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 827E5B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5B18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E5B1C: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 827E5B20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E5B24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E5B28: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5B2C: 489C6CAD  bl 0x831ac7d8
	ctx.lr = 0x827E5B30;
	sub_831AC7D8(ctx, base);
	// 827E5B30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E5B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B40 size=4
    let mut pc: u32 = 0x827E5B40;
    'dispatch: loop {
        match pc {
            0x827E5B40 => {
    //   block [0x827E5B40..0x827E5B44)
	// 827E5B40: 488DC8C0  b 0x830c2400
	sub_830C2400(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B48 size=20
    let mut pc: u32 = 0x827E5B48;
    'dispatch: loop {
        match pc {
            0x827E5B48 => {
    //   block [0x827E5B48..0x827E5B5C)
	// 827E5B48: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E5B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5B50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 827E5B54: 916AA104  stw r11, -0x5efc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-24316 as u32), ctx.r[11].u32 ) };
	// 827E5B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B60 size=12
    let mut pc: u32 = 0x827E5B60;
    'dispatch: loop {
        match pc {
            0x827E5B60 => {
    //   block [0x827E5B60..0x827E5B6C)
	// 827E5B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5B64: 996300E0  stb r11, 0xe0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 827E5B68: 488DBBC8  b 0x830c1730
	sub_830C1730(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B70 size=4
    let mut pc: u32 = 0x827E5B70;
    'dispatch: loop {
        match pc {
            0x827E5B70 => {
    //   block [0x827E5B70..0x827E5B74)
	// 827E5B70: 488DBDC0  b 0x830c1930
	sub_830C1930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B78 size=4
    let mut pc: u32 = 0x827E5B78;
    'dispatch: loop {
        match pc {
            0x827E5B78 => {
    //   block [0x827E5B78..0x827E5B7C)
	// 827E5B78: 488DBF40  b 0x830c1ab8
	sub_830C1AB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B80 size=4
    let mut pc: u32 = 0x827E5B80;
    'dispatch: loop {
        match pc {
            0x827E5B80 => {
    //   block [0x827E5B80..0x827E5B84)
	// 827E5B80: 488DC710  b 0x830c2290
	sub_830C2290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B88 size=4
    let mut pc: u32 = 0x827E5B88;
    'dispatch: loop {
        match pc {
            0x827E5B88 => {
    //   block [0x827E5B88..0x827E5B8C)
	// 827E5B88: 488DB940  b 0x830c14c8
	sub_830C14C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B90 size=8
    let mut pc: u32 = 0x827E5B90;
    'dispatch: loop {
        match pc {
            0x827E5B90 => {
    //   block [0x827E5B90..0x827E5B98)
	// 827E5B90: 90830100  stw r4, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[4].u32 ) };
	// 827E5B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5B98 size=12
    let mut pc: u32 = 0x827E5B98;
    'dispatch: loop {
        match pc {
            0x827E5B98 => {
    //   block [0x827E5B98..0x827E5BA4)
	// 827E5B98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E5B9C: 886BA101  lbz r3, -0x5eff(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24319 as u32) ) } as u64;
	// 827E5BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5BA8 size=12
    let mut pc: u32 = 0x827E5BA8;
    'dispatch: loop {
        match pc {
            0x827E5BA8 => {
    //   block [0x827E5BA8..0x827E5BB4)
	// 827E5BA8: B0830154  sth r4, 0x154(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[4].u16 ) };
	// 827E5BAC: 90A30158  stw r5, 0x158(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), ctx.r[5].u32 ) };
	// 827E5BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5BB8 size=136
    let mut pc: u32 = 0x827E5BB8;
    'dispatch: loop {
        match pc {
            0x827E5BB8 => {
    //   block [0x827E5BB8..0x827E5C40)
	// 827E5BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5BC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E5BC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E5BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5BCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E5BD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E5BD4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827E5BD8: 409A0020  bne cr6, 0x827e5bf8
	if !ctx.cr[6].eq {
	pc = 0x827E5BF8; continue 'dispatch;
	}
	// 827E5BDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5BE0: 419A0048  beq cr6, 0x827e5c28
	if ctx.cr[6].eq {
	pc = 0x827E5C28; continue 'dispatch;
	}
	// 827E5BE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5BE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5BEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5BF0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E5BF4: 48000034  b 0x827e5c28
	pc = 0x827E5C28; continue 'dispatch;
	// 827E5BF8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827E5BFC: 419A002C  beq cr6, 0x827e5c28
	if ctx.cr[6].eq {
	pc = 0x827E5C28; continue 'dispatch;
	}
	// 827E5C00: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5C04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5C08: 388BBFE0  addi r4, r11, -0x4020
	ctx.r[4].s64 = ctx.r[11].s64 + -16416;
	// 827E5C0C: 489C24ED  bl 0x831a80f8
	ctx.lr = 0x827E5C10;
	sub_831A80F8(ctx, base);
	// 827E5C10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E5C14: 4182000C  beq 0x827e5c20
	if ctx.cr[0].eq {
	pc = 0x827E5C20; continue 'dispatch;
	}
	// 827E5C18: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E5C1C: 4800000C  b 0x827e5c28
	pc = 0x827E5C28; continue 'dispatch;
	// 827E5C20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5C24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5C28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E5C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5C34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E5C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5C40 size=136
    let mut pc: u32 = 0x827E5C40;
    'dispatch: loop {
        match pc {
            0x827E5C40 => {
    //   block [0x827E5C40..0x827E5CC8)
	// 827E5C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5C48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E5C4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E5C50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5C54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E5C58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E5C5C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827E5C60: 409A0020  bne cr6, 0x827e5c80
	if !ctx.cr[6].eq {
	pc = 0x827E5C80; continue 'dispatch;
	}
	// 827E5C64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5C68: 419A0048  beq cr6, 0x827e5cb0
	if ctx.cr[6].eq {
	pc = 0x827E5CB0; continue 'dispatch;
	}
	// 827E5C6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5C70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5C74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5C78: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E5C7C: 48000034  b 0x827e5cb0
	pc = 0x827E5CB0; continue 'dispatch;
	// 827E5C80: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827E5C84: 419A002C  beq cr6, 0x827e5cb0
	if ctx.cr[6].eq {
	pc = 0x827E5CB0; continue 'dispatch;
	}
	// 827E5C88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5C8C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5C90: 388BC080  addi r4, r11, -0x3f80
	ctx.r[4].s64 = ctx.r[11].s64 + -16256;
	// 827E5C94: 489C2465  bl 0x831a80f8
	ctx.lr = 0x827E5C98;
	sub_831A80F8(ctx, base);
	// 827E5C98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E5C9C: 4182000C  beq 0x827e5ca8
	if ctx.cr[0].eq {
	pc = 0x827E5CA8; continue 'dispatch;
	}
	// 827E5CA0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E5CA4: 4800000C  b 0x827e5cb0
	pc = 0x827E5CB0; continue 'dispatch;
	// 827E5CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5CAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5CB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E5CB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5CB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5CBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5CC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E5CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5CC8 size=16
    let mut pc: u32 = 0x827E5CC8;
    'dispatch: loop {
        match pc {
            0x827E5CC8 => {
    //   block [0x827E5CC8..0x827E5CD8)
	// 827E5CC8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E5CCC: 816BA104  lwz r11, -0x5efc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24316 as u32) ) } as u64;
	// 827E5CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E5CD4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5CD8 size=12
    let mut pc: u32 = 0x827E5CD8;
    'dispatch: loop {
        match pc {
            0x827E5CD8 => {
    //   block [0x827E5CD8..0x827E5CE4)
	// 827E5CD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E5CDC: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 827E5CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5CE8 size=32
    let mut pc: u32 = 0x827E5CE8;
    'dispatch: loop {
        match pc {
            0x827E5CE8 => {
    //   block [0x827E5CE8..0x827E5D08)
	// 827E5CE8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E5CEC: 816BA104  lwz r11, -0x5efc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24316 as u32) ) } as u64;
	// 827E5CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E5CF4: 419A0014  beq cr6, 0x827e5d08
	if ctx.cr[6].eq {
		sub_827E5D08(ctx, base);
		return;
	}
	// 827E5CF8: 896B0014  lbz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E5CFC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827E5D00: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827E5D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E5D08 size=8
    let mut pc: u32 = 0x827E5D08;
    'dispatch: loop {
        match pc {
            0x827E5D08 => {
    //   block [0x827E5D08..0x827E5D10)
	// 827E5D08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E5D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5D10 size=196
    let mut pc: u32 = 0x827E5D10;
    'dispatch: loop {
        match pc {
            0x827E5D10 => {
    //   block [0x827E5D10..0x827E5DD4)
	// 827E5D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E5D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E5D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5D24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E5D28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5D2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827E5D30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E5D34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5D38: 4BADAC01  bl 0x822c0938
	ctx.lr = 0x827E5D3C;
	sub_822C0938(ctx, base);
	// 827E5D3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E5D40: 41820028  beq 0x827e5d68
	if ctx.cr[0].eq {
	pc = 0x827E5D68; continue 'dispatch;
	}
	// 827E5D44: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E5D48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 827E5D4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E5D50: 392B5978  addi r9, r11, 0x5978
	ctx.r[9].s64 = ctx.r[11].s64 + 22904;
	// 827E5D54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E5D58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E5D5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E5D60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E5D64: 48000008  b 0x827e5d6c
	pc = 0x827E5D6C; continue 'dispatch;
	// 827E5D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E5D6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E5D74: 409A0044  bne cr6, 0x827e5db8
	if !ctx.cr[6].eq {
	pc = 0x827E5DB8; continue 'dispatch;
	}
	// 827E5D78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E5D7C: 419A001C  beq cr6, 0x827e5d98
	if ctx.cr[6].eq {
	pc = 0x827E5D98; continue 'dispatch;
	}
	// 827E5D80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5D84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E5D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5D8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5D90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E5D94: 4E800421  bctrl
	ctx.lr = 0x827E5D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E5D98: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5D9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E5DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E5DA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 827E5DA8: 816BBFD8  lwz r11, -0x4028(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16424 as u32) ) } as u64;
	// 827E5DAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E5DB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E5DB4: 4BADA24D  bl 0x822c0000
	ctx.lr = 0x827E5DB8;
	sub_822C0000(ctx, base);
	// 827E5DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E5DBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E5DC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5DC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5DC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5DCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E5DD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5DD8 size=72
    let mut pc: u32 = 0x827E5DD8;
    'dispatch: loop {
        match pc {
            0x827E5DD8 => {
    //   block [0x827E5DD8..0x827E5E20)
	// 827E5DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5DE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5DE4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827E5DE8: 419A001C  beq cr6, 0x827e5e04
	if ctx.cr[6].eq {
	pc = 0x827E5E04; continue 'dispatch;
	}
	// 827E5DEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E5DF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E5DF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E5DF8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5DFC: 4BFFFDBD  bl 0x827e5bb8
	ctx.lr = 0x827E5E00;
	sub_827E5BB8(ctx, base);
	// 827E5E00: 48000010  b 0x827e5e10
	pc = 0x827E5E10; continue 'dispatch;
	// 827E5E04: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5E08: 396BBFE0  addi r11, r11, -0x4020
	ctx.r[11].s64 = ctx.r[11].s64 + -16416;
	// 827E5E0C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5E10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E5E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5E20 size=72
    let mut pc: u32 = 0x827E5E20;
    'dispatch: loop {
        match pc {
            0x827E5E20 => {
    //   block [0x827E5E20..0x827E5E68)
	// 827E5E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5E28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5E2C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827E5E30: 419A001C  beq cr6, 0x827e5e4c
	if ctx.cr[6].eq {
	pc = 0x827E5E4C; continue 'dispatch;
	}
	// 827E5E34: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E5E38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E5E3C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E5E40: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5E44: 4BFFFDFD  bl 0x827e5c40
	ctx.lr = 0x827E5E48;
	sub_827E5C40(ctx, base);
	// 827E5E48: 48000010  b 0x827e5e58
	pc = 0x827E5E58; continue 'dispatch;
	// 827E5E4C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E5E50: 396BC080  addi r11, r11, -0x3f80
	ctx.r[11].s64 = ctx.r[11].s64 + -16256;
	// 827E5E54: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5E58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E5E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5E68 size=112
    let mut pc: u32 = 0x827E5E68;
    'dispatch: loop {
        match pc {
            0x827E5E68 => {
    //   block [0x827E5E68..0x827E5ED8)
	// 827E5E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E5E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E5E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5E7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E5E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E5E84: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E5E88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5E8C: 4BAE3875  bl 0x822c9700
	ctx.lr = 0x827E5E90;
	sub_822C9700(ctx, base);
	// 827E5E90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E5E94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5E98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E5E9C: 4BADA165  bl 0x822c0000
	ctx.lr = 0x827E5EA0;
	sub_822C0000(ctx, base);
	// 827E5EA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E5EA4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E5EA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E5EAC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5EB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E5EB4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E5EB8: 419A0008  beq cr6, 0x827e5ec0
	if ctx.cr[6].eq {
	pc = 0x827E5EC0; continue 'dispatch;
	}
	// 827E5EBC: 4BADA9D5  bl 0x822c0890
	ctx.lr = 0x827E5EC0;
	sub_822C0890(ctx, base);
	// 827E5EC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E5EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E5EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E5ECC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E5ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E5ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5ED8 size=180
    let mut pc: u32 = 0x827E5ED8;
    'dispatch: loop {
        match pc {
            0x827E5ED8 => {
    //   block [0x827E5ED8..0x827E5F8C)
	// 827E5ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5EDC: 489C228D  bl 0x831a8168
	ctx.lr = 0x827E5EE0;
	sub_831A8130(ctx, base);
	// 827E5EE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5EE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E5EE8: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 827E5EEC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E5EF0: F8C100A8  std r6, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u64 ) };
	// 827E5EF4: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 827E5EF8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E5EFC: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 827E5F00: 4198000C  blt cr6, 0x827e5f0c
	if ctx.cr[6].lt {
	pc = 0x827E5F0C; continue 'dispatch;
	}
	// 827E5F04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5F08: 48000008  b 0x827e5f10
	pc = 0x827E5F10; continue 'dispatch;
	// 827E5F0C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E5F10: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E5F14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E5F18: 409A000C  bne cr6, 0x827e5f24
	if !ctx.cr[6].eq {
	pc = 0x827E5F24; continue 'dispatch;
	}
	// 827E5F1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827E5F20: 4800000C  b 0x827e5f2c
	pc = 0x827E5F2C; continue 'dispatch;
	// 827E5F24: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827E5F28: 7D7E0E70  srawi r30, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827E5F2C: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 827E5F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E5F34: 409A000C  bne cr6, 0x827e5f40
	if !ctx.cr[6].eq {
	pc = 0x827E5F40; continue 'dispatch;
	}
	// 827E5F38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E5F3C: 4800000C  b 0x827e5f48
	pc = 0x827E5F48; continue 'dispatch;
	// 827E5F40: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827E5F44: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827E5F48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E5F50: 4BAE2F61  bl 0x822c8eb0
	ctx.lr = 0x827E5F54;
	sub_822C8EB0(ctx, base);
	// 827E5F54: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E5F58: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 827E5F5C: 4198000C  blt cr6, 0x827e5f68
	if ctx.cr[6].lt {
	pc = 0x827E5F68; continue 'dispatch;
	}
	// 827E5F60: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5F64: 48000008  b 0x827e5f6c
	pc = 0x827E5F6C; continue 'dispatch;
	// 827E5F68: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E5F6C: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827E5F70: 3920FFFE  li r9, -2
	ctx.r[9].s64 = -2;
	// 827E5F74: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827E5F78: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E5F7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E5F80: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E5F84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E5F88: 489C2230  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E5F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E5F90 size=120
    let mut pc: u32 = 0x827E5F90;
    'dispatch: loop {
        match pc {
            0x827E5F90 => {
    //   block [0x827E5F90..0x827E6008)
	// 827E5F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E5F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E5F98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E5F9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E5FA0: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 827E5FA4: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E5FA8: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 827E5FAC: 4198000C  blt cr6, 0x827e5fb8
	if ctx.cr[6].lt {
	pc = 0x827E5FB8; continue 'dispatch;
	}
	// 827E5FB0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E5FB4: 48000008  b 0x827e5fbc
	pc = 0x827E5FBC; continue 'dispatch;
	// 827E5FB8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827E5FBC: 80E40014  lwz r7, 0x14(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E5FC0: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 827E5FC4: 3900FFFE  li r8, -2
	ctx.r[8].s64 = -2;
	// 827E5FC8: 54E9083C  slwi r9, r7, 1
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 827E5FCC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 827E5FD0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 827E5FD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827E5FD8: 41980008  blt cr6, 0x827e5fe0
	if ctx.cr[6].lt {
	pc = 0x827E5FE0; continue 'dispatch;
	}
	// 827E5FDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E5FE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E5FE4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 827E5FE8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 827E5FEC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E5FF0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827E5FF4: 4BFFFEE5  bl 0x827e5ed8
	ctx.lr = 0x827E5FF8;
	sub_827E5ED8(ctx, base);
	// 827E5FF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E5FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6008 size=80
    let mut pc: u32 = 0x827E6008;
    'dispatch: loop {
        match pc {
            0x827E6008 => {
    //   block [0x827E6008..0x827E6058)
	// 827E6008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E600C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6014: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E601C: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 827E6020: 4BB8E171  bl 0x82374190
	ctx.lr = 0x827E6024;
	sub_82374190(ctx, base);
	// 827E6024: 387F011C  addi r3, r31, 0x11c
	ctx.r[3].s64 = ctx.r[31].s64 + 284;
	// 827E6028: 4BFFFF69  bl 0x827e5f90
	ctx.lr = 0x827E602C;
	sub_827E5F90(ctx, base);
	// 827E602C: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 827E6030: 4BB8E161  bl 0x82374190
	ctx.lr = 0x827E6034;
	sub_82374190(ctx, base);
	// 827E6034: 387F0138  addi r3, r31, 0x138
	ctx.r[3].s64 = ctx.r[31].s64 + 312;
	// 827E6038: 4BFFFF59  bl 0x827e5f90
	ctx.lr = 0x827E603C;
	sub_827E5F90(ctx, base);
	// 827E603C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 827E6040: B17F0154  sth r11, 0x154(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u16 ) };
	// 827E6044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E6048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E604C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E6058 size=16
    let mut pc: u32 = 0x827E6058;
    'dispatch: loop {
        match pc {
            0x827E6058 => {
    //   block [0x827E6058..0x827E6068)
	// 827E6058: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E605C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6060: 3863011C  addi r3, r3, 0x11c
	ctx.r[3].s64 = ctx.r[3].s64 + 284;
	// 827E6064: 4BAE30CC  b 0x822c9130
	sub_822C9130(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E6068 size=16
    let mut pc: u32 = 0x827E6068;
    'dispatch: loop {
        match pc {
            0x827E6068 => {
    //   block [0x827E6068..0x827E6078)
	// 827E6068: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E606C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6070: 38630138  addi r3, r3, 0x138
	ctx.r[3].s64 = ctx.r[3].s64 + 312;
	// 827E6074: 4BAE30BC  b 0x822c9130
	sub_822C9130(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6078 size=520
    let mut pc: u32 = 0x827E6078;
    'dispatch: loop {
        match pc {
            0x827E6078 => {
    //   block [0x827E6078..0x827E6280)
	// 827E6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E607C: 489C20ED  bl 0x831a8168
	ctx.lr = 0x827E6080;
	sub_831A8130(ctx, base);
	// 827E6080: 9421FAE0  stwu r1, -0x520(r1)
	ea = ctx.r[1].u32.wrapping_add(-1312 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E6088: 488DB3D9  bl 0x830c1460
	ctx.lr = 0x827E608C;
	sub_830C1460(ctx, base);
	// 827E608C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E6090: 896BA101  lbz r11, -0x5eff(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24319 as u32) ) } as u64;
	// 827E6094: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E6098: 41820038  beq 0x827e60d0
	if ctx.cr[0].eq {
	pc = 0x827E60D0; continue 'dispatch;
	}
	// 827E609C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E60A0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 827E60A4: 388B59D4  addi r4, r11, 0x59d4
	ctx.r[4].s64 = ctx.r[11].s64 + 22996;
	// 827E60A8: 4BAE3249  bl 0x822c92f0
	ctx.lr = 0x827E60AC;
	sub_822C92F0(ctx, base);
	// 827E60AC: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 827E60B0: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 827E60B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E60B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827E60BC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 827E60C0: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 827E60C4: 4BAE306D  bl 0x822c9130
	ctx.lr = 0x827E60C8;
	sub_822C9130(ctx, base);
	// 827E60C8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 827E60CC: 48000034  b 0x827e6100
	pc = 0x827E6100; continue 'dispatch;
	// 827E60D0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E60D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E60D8: 388B59C0  addi r4, r11, 0x59c0
	ctx.r[4].s64 = ctx.r[11].s64 + 22976;
	// 827E60DC: 4BAE3215  bl 0x822c92f0
	ctx.lr = 0x827E60E0;
	sub_822C92F0(ctx, base);
	// 827E60E0: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 827E60E4: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 827E60E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E60EC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827E60F0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827E60F4: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 827E60F8: 4BAE3039  bl 0x822c9130
	ctx.lr = 0x827E60FC;
	sub_822C9130(ctx, base);
	// 827E60FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E6100: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6104: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E6108: 4BAE2D29  bl 0x822c8e30
	ctx.lr = 0x827E610C;
	sub_822C8E30(ctx, base);
	// 827E610C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6110: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E6114: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E6118: 4BAE2D19  bl 0x822c8e30
	ctx.lr = 0x827E611C;
	sub_822C8E30(ctx, base);
	// 827E611C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827E6120: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6124: 389F011C  addi r4, r31, 0x11c
	ctx.r[4].s64 = ctx.r[31].s64 + 284;
	// 827E6128: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E612C: 4BAE3955  bl 0x822c9a80
	ctx.lr = 0x827E6130;
	sub_822C9A80(ctx, base);
	// 827E6130: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E6134: 3BCB59B8  addi r30, r11, 0x59b8
	ctx.r[30].s64 = ctx.r[11].s64 + 22968;
	// 827E6138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E613C: 489C2F8D  bl 0x831a90c8
	ctx.lr = 0x827E6140;
	sub_831A90C8(ctx, base);
	// 827E6140: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E6144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E6148: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E614C: 4BAE3B3D  bl 0x822c9c88
	ctx.lr = 0x827E6150;
	sub_822C9C88(ctx, base);
	// 827E6150: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827E6154: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6158: 389F0138  addi r4, r31, 0x138
	ctx.r[4].s64 = ctx.r[31].s64 + 312;
	// 827E615C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E6160: 4BAE3921  bl 0x822c9a80
	ctx.lr = 0x827E6164;
	sub_822C9A80(ctx, base);
	// 827E6164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E6168: 489C2F61  bl 0x831a90c8
	ctx.lr = 0x827E616C;
	sub_831A90C8(ctx, base);
	// 827E616C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E6170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E6174: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E6178: 4BAE3B11  bl 0x822c9c88
	ctx.lr = 0x827E617C;
	sub_822C9C88(ctx, base);
	// 827E617C: A97F0154  lha r11, 0x154(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as i16) as i64;
	// 827E6180: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 827E6184: 40810028  ble 0x827e61ac
	if !ctx.cr[0].gt {
	pc = 0x827E61AC; continue 'dispatch;
	}
	// 827E6188: 839F0158  lwz r28, 0x158(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 827E618C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E6190: 419A001C  beq cr6, 0x827e61ac
	if ctx.cr[6].eq {
	pc = 0x827E61AC; continue 'dispatch;
	}
	// 827E6194: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E6198: 489C2F31  bl 0x831a90c8
	ctx.lr = 0x827E619C;
	sub_831A90C8(ctx, base);
	// 827E619C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E61A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E61A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E61A8: 4BAE3AE1  bl 0x822c9c88
	ctx.lr = 0x827E61AC;
	sub_822C9C88(ctx, base);
	// 827E61AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E61B0: 489C2F19  bl 0x831a90c8
	ctx.lr = 0x827E61B4;
	sub_831A90C8(ctx, base);
	// 827E61B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E61B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E61BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E61C0: 4BAE3AC9  bl 0x822c9c88
	ctx.lr = 0x827E61C4;
	sub_822C9C88(ctx, base);
	// 827E61C4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E61C8: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 827E61CC: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 827E61D0: 896BA102  lbz r11, -0x5efe(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24318 as u32) ) } as u64;
	// 827E61D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E61D8: 41820024  beq 0x827e61fc
	if ctx.cr[0].eq {
	pc = 0x827E61FC; continue 'dispatch;
	}
	// 827E61DC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E61E0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 827E61E4: 38AB5998  addi r5, r11, 0x5998
	ctx.r[5].s64 = ctx.r[11].s64 + 22936;
	// 827E61E8: 4BFFF911  bl 0x827e5af8
	ctx.lr = 0x827E61EC;
	sub_827E5AF8(ctx, base);
	// 827E61EC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 827E61F0: 489C2ED9  bl 0x831a90c8
	ctx.lr = 0x827E61F4;
	sub_831A90C8(ctx, base);
	// 827E61F4: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 827E61F8: 48000020  b 0x827e6218
	pc = 0x827E6218; continue 'dispatch;
	// 827E61FC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E6200: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 827E6204: 38AB5988  addi r5, r11, 0x5988
	ctx.r[5].s64 = ctx.r[11].s64 + 22920;
	// 827E6208: 4BFFF8F1  bl 0x827e5af8
	ctx.lr = 0x827E620C;
	sub_827E5AF8(ctx, base);
	// 827E620C: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 827E6210: 489C2EB9  bl 0x831a90c8
	ctx.lr = 0x827E6214;
	sub_831A90C8(ctx, base);
	// 827E6214: 388102F0  addi r4, r1, 0x2f0
	ctx.r[4].s64 = ctx.r[1].s64 + 752;
	// 827E6218: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E621C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E6220: 4BAE3A69  bl 0x822c9c88
	ctx.lr = 0x827E6224;
	sub_822C9C88(ctx, base);
	// 827E6224: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827E6228: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E622C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 827E6230: 40980008  bge cr6, 0x827e6238
	if !ctx.cr[6].lt {
	pc = 0x827E6238; continue 'dispatch;
	}
	// 827E6234: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 827E6238: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E623C: 4BAE30B5  bl 0x822c92f0
	ctx.lr = 0x827E6240;
	sub_822C92F0(ctx, base);
	// 827E6240: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 827E6244: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827E6248: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E624C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 827E6250: 386B0090  addi r3, r11, 0x90
	ctx.r[3].s64 = ctx.r[11].s64 + 144;
	// 827E6254: 4BAE2EDD  bl 0x822c9130
	ctx.lr = 0x827E6258;
	sub_822C9130(ctx, base);
	// 827E6258: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E625C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E6260: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E6264: 4BAE2BCD  bl 0x822c8e30
	ctx.lr = 0x827E6268;
	sub_822C8E30(ctx, base);
	// 827E6268: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E626C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E6270: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E6274: 4BAE2BBD  bl 0x822c8e30
	ctx.lr = 0x827E6278;
	sub_822C8E30(ctx, base);
	// 827E6278: 38210520  addi r1, r1, 0x520
	ctx.r[1].s64 = ctx.r[1].s64 + 1312;
	// 827E627C: 489C1F3C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6280 size=128
    let mut pc: u32 = 0x827E6280;
    'dispatch: loop {
        match pc {
            0x827E6280 => {
    //   block [0x827E6280..0x827E6300)
	// 827E6280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6284: 489C1EE9  bl 0x831a816c
	ctx.lr = 0x827E6288;
	sub_831A8130(ctx, base);
	// 827E6288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E628C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E6290: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E6294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E6298: 3BEBAC18  addi r31, r11, -0x53e8
	ctx.r[31].s64 = ctx.r[11].s64 + -21480;
	// 827E629C: 816AAC20  lwz r11, -0x53e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21472 as u32) ) } as u64;
	// 827E62A0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827E62A4: 40820024  bne 0x827e62c8
	if !ctx.cr[0].eq {
	pc = 0x827E62C8; continue 'dispatch;
	}
	// 827E62A8: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 827E62AC: 3D00827E  lis r8, -0x7d82
	ctx.r[8].s64 = -2105671680;
	// 827E62B0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827E62B4: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 827E62B8: 39085DD8  addi r8, r8, 0x5dd8
	ctx.r[8].s64 = ctx.r[8].s64 + 24024;
	// 827E62BC: 916AAC20  stw r11, -0x53e0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21472 as u32), ctx.r[11].u32 ) };
	// 827E62C0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E62C4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827E62C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E62CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E62D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E62D4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 827E62D8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827E62DC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E62E0: 4BDEC641  bl 0x825d2920
	ctx.lr = 0x827E62E4;
	sub_825D2920(ctx, base);
	// 827E62E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E62E8: 4182000C  beq 0x827e62f4
	if ctx.cr[0].eq {
	pc = 0x827E62F4; continue 'dispatch;
	}
	// 827E62EC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E62F0: 48000008  b 0x827e62f8
	pc = 0x827E62F8; continue 'dispatch;
	// 827E62F4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827E62F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E62FC: 489C1EC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6300 size=128
    let mut pc: u32 = 0x827E6300;
    'dispatch: loop {
        match pc {
            0x827E6300 => {
    //   block [0x827E6300..0x827E6380)
	// 827E6300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6304: 489C1E69  bl 0x831a816c
	ctx.lr = 0x827E6308;
	sub_831A8130(ctx, base);
	// 827E6308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E630C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E6310: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E6314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E6318: 3BEBAC24  addi r31, r11, -0x53dc
	ctx.r[31].s64 = ctx.r[11].s64 + -21468;
	// 827E631C: 816AAC2C  lwz r11, -0x53d4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21460 as u32) ) } as u64;
	// 827E6320: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827E6324: 40820024  bne 0x827e6348
	if !ctx.cr[0].eq {
	pc = 0x827E6348; continue 'dispatch;
	}
	// 827E6328: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 827E632C: 3D00827E  lis r8, -0x7d82
	ctx.r[8].s64 = -2105671680;
	// 827E6330: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827E6334: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 827E6338: 39085E20  addi r8, r8, 0x5e20
	ctx.r[8].s64 = ctx.r[8].s64 + 24096;
	// 827E633C: 916AAC2C  stw r11, -0x53d4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21460 as u32), ctx.r[11].u32 ) };
	// 827E6340: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E6344: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827E6348: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E634C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E6350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E6354: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 827E6358: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827E635C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E6360: 4BDEC5C1  bl 0x825d2920
	ctx.lr = 0x827E6364;
	sub_825D2920(ctx, base);
	// 827E6364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E6368: 4182000C  beq 0x827e6374
	if ctx.cr[0].eq {
	pc = 0x827E6374; continue 'dispatch;
	}
	// 827E636C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E6370: 48000008  b 0x827e6378
	pc = 0x827E6378; continue 'dispatch;
	// 827E6374: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827E6378: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E637C: 489C1E40  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6380 size=48
    let mut pc: u32 = 0x827E6380;
    'dispatch: loop {
        match pc {
            0x827E6380 => {
    //   block [0x827E6380..0x827E63B0)
	// 827E6380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6388: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E638C: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 827E6390: 38830104  addi r4, r3, 0x104
	ctx.r[4].s64 = ctx.r[3].s64 + 260;
	// 827E6394: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 827E6398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E639C: 4BB3A985  bl 0x82320d20
	ctx.lr = 0x827E63A0;
	sub_82320D20(ctx, base);
	// 827E63A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E63A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E63A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E63AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E63B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E63B0 size=48
    let mut pc: u32 = 0x827E63B0;
    'dispatch: loop {
        match pc {
            0x827E63B0 => {
    //   block [0x827E63B0..0x827E63E0)
	// 827E63B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E63B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E63B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E63BC: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 827E63C0: 38830110  addi r4, r3, 0x110
	ctx.r[4].s64 = ctx.r[3].s64 + 272;
	// 827E63C4: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 827E63C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E63CC: 4BB3A955  bl 0x82320d20
	ctx.lr = 0x827E63D0;
	sub_82320D20(ctx, base);
	// 827E63D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E63D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E63D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E63DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E63E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E63E0 size=2064
    let mut pc: u32 = 0x827E63E0;
    'dispatch: loop {
        match pc {
            0x827E63E0 => {
    //   block [0x827E63E0..0x827E6BF0)
	// 827E63E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E63E4: 489C1D61  bl 0x831a8144
	ctx.lr = 0x827E63E8;
	sub_831A8130(ctx, base);
	// 827E63E8: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 827E63EC: 489C2689  bl 0x831a8a74
	ctx.lr = 0x827E63F0;
	sub_831A8A40(ctx, base);
	// 827E63F0: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E63F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E63F8: 488DC791  bl 0x830c2b88
	ctx.lr = 0x827E63FC;
	sub_830C2B88(ctx, base);
	// 827E63FC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 827E6400: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E6404: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 827E6408: 392000A0  li r9, 0xa0
	ctx.r[9].s64 = 160;
	// 827E640C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 827E6410: 394A5A44  addi r10, r10, 0x5a44
	ctx.r[10].s64 = ctx.r[10].s64 + 23108;
	// 827E6414: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827E6418: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E641C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6BF0 size=136
    let mut pc: u32 = 0x827E6BF0;
    'dispatch: loop {
        match pc {
            0x827E6BF0 => {
    //   block [0x827E6BF0..0x827E6C78)
	// 827E6BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6BF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6BF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6BFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6C00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E6C04: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 827E6C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E6C0C: 419A0008  beq cr6, 0x827e6c14
	if ctx.cr[6].eq {
	pc = 0x827E6C14; continue 'dispatch;
	}
	// 827E6C10: 4BAD9C81  bl 0x822c0890
	ctx.lr = 0x827E6C14;
	sub_822C0890(ctx, base);
	// 827E6C14: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 827E6C18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E6C1C: 419A0008  beq cr6, 0x827e6c24
	if ctx.cr[6].eq {
	pc = 0x827E6C24; continue 'dispatch;
	}
	// 827E6C20: 4BAD9C71  bl 0x822c0890
	ctx.lr = 0x827E6C24;
	sub_822C0890(ctx, base);
	// 827E6C24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6C28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E6C2C: 387F0138  addi r3, r31, 0x138
	ctx.r[3].s64 = ctx.r[31].s64 + 312;
	// 827E6C30: 4BAE2201  bl 0x822c8e30
	ctx.lr = 0x827E6C34;
	sub_822C8E30(ctx, base);
	// 827E6C34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E6C38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E6C3C: 387F011C  addi r3, r31, 0x11c
	ctx.r[3].s64 = ctx.r[31].s64 + 284;
	// 827E6C40: 4BAE21F1  bl 0x822c8e30
	ctx.lr = 0x827E6C44;
	sub_822C8E30(ctx, base);
	// 827E6C44: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 827E6C48: 4BB3A2A9  bl 0x82320ef0
	ctx.lr = 0x827E6C4C;
	sub_82320EF0(ctx, base);
	// 827E6C4C: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 827E6C50: 4BB3A2A1  bl 0x82320ef0
	ctx.lr = 0x827E6C54;
	sub_82320EF0(ctx, base);
	// 827E6C54: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 827E6C58: 4BC833A9  bl 0x8246a000
	ctx.lr = 0x827E6C5C;
	sub_8246A000(ctx, base);
	// 827E6C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E6C60: 488DBE89  bl 0x830c2ae8
	ctx.lr = 0x827E6C64;
	sub_830C2AE8(ctx, base);
	// 827E6C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E6C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6C78 size=76
    let mut pc: u32 = 0x827E6C78;
    'dispatch: loop {
        match pc {
            0x827E6C78 => {
    //   block [0x827E6C78..0x827E6CC4)
	// 827E6C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E6C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E6C90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E6C94: 4BFFFF5D  bl 0x827e6bf0
	ctx.lr = 0x827E6C98;
	sub_827E6BF0(ctx, base);
	// 827E6C98: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E6C9C: 4182000C  beq 0x827e6ca8
	if ctx.cr[0].eq {
	pc = 0x827E6CA8; continue 'dispatch;
	}
	// 827E6CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E6CA4: 4BAD95C5  bl 0x822c0268
	ctx.lr = 0x827E6CA8;
	sub_822C0268(ctx, base);
	// 827E6CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E6CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E6CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6CB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E6CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E6CC8 size=336
    let mut pc: u32 = 0x827E6CC8;
    'dispatch: loop {
        match pc {
            0x827E6CC8 => {
    //   block [0x827E6CC8..0x827E6E18)
	// 827E6CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6CD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E6CD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6CD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6CDC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E6CE0: 816BA104  lwz r11, -0x5efc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24316 as u32) ) } as u64;
	// 827E6CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E6CE8: 419A0010  beq cr6, 0x827e6cf8
	if ctx.cr[6].eq {
	pc = 0x827E6CF8; continue 'dispatch;
	}
	// 827E6CEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E6CF0: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 827E6CF4: 4800010C  b 0x827e6e00
	pc = 0x827E6E00; continue 'dispatch;
	// 827E6CF8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E6CFC: 894BA103  lbz r10, -0x5efd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-24317 as u32) ) } as u64;
	// 827E6D00: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E6D04: 4082000C  bne 0x827e6d10
	if !ctx.cr[0].eq {
	pc = 0x827E6D10; continue 'dispatch;
	}
	// 827E6D08: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E6D0C: 994BA103  stb r10, -0x5efd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-24317 as u32), ctx.r[10].u8 ) };
	// 827E6D10: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E6D14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E6D18: 392BBF78  addi r9, r11, -0x4088
	ctx.r[9].s64 = ctx.r[11].s64 + -16520;
	// 827E6D1C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 827E6D20: C1ABBF78  lfs f13, -0x4088(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E6D24: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E6D28: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E6D2C: C1690008  lfs f11, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E6D30: C149000C  lfs f10, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E6D34: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E6D38: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E6D3C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E6D40: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E6D44: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827E6D48: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827E6D4C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827E6D50: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827E6D54: 4BAD9BE5  bl 0x822c0938
	ctx.lr = 0x827E6D58;
	sub_822C0938(ctx, base);
	// 827E6D58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E6D5C: 41820018  beq 0x827e6d74
	if ctx.cr[0].eq {
	pc = 0x827E6D74; continue 'dispatch;
	}
	// 827E6D60: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E6D64: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E6D68: 4BFFF679  bl 0x827e63e0
	ctx.lr = 0x827E6D6C;
	sub_827E63E0(ctx, base);
	// 827E6D6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E6D70: 48000008  b 0x827e6d78
	pc = 0x827E6D78; continue 'dispatch;
	// 827E6D74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E6D78: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E6D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E6D80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E6D84: 4BFFEF8D  bl 0x827e5d10
	ctx.lr = 0x827E6D88;
	sub_827E5D10(ctx, base);
	// 827E6D88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E6D8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E6D90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E6D94: 4BAD926D  bl 0x822c0000
	ctx.lr = 0x827E6D98;
	sub_822C0000(ctx, base);
	// 827E6D98: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E6D9C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E6DA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E6DA4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E6DA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E6DAC: 419A0024  beq cr6, 0x827e6dd0
	if ctx.cr[6].eq {
	pc = 0x827E6DD0; continue 'dispatch;
	}
	// 827E6DB0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E6DB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E6DB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E6DBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E6DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E6DC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E6DC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E6DCC: 4082FFE8  bne 0x827e6db4
	if !ctx.cr[0].eq {
	pc = 0x827E6DB4; continue 'dispatch;
	}
	// 827E6DD0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E6DD4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E6DD8: 388B5A90  addi r4, r11, 0x5a90
	ctx.r[4].s64 = ctx.r[11].s64 + 23184;
	// 827E6DDC: 4BAE2515  bl 0x822c92f0
	ctx.lr = 0x827E6DE0;
	sub_822C92F0(ctx, base);
	// 827E6DE0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E6DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E6DE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E6DEC: 488DBB95  bl 0x830c2980
	ctx.lr = 0x827E6DF0;
	sub_830C2980(ctx, base);
	// 827E6DF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E6DF4: 419A000C  beq cr6, 0x827e6e00
	if ctx.cr[6].eq {
	pc = 0x827E6E00; continue 'dispatch;
	}
	// 827E6DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E6DFC: 4BAD9A95  bl 0x822c0890
	ctx.lr = 0x827E6E00;
	sub_822C0890(ctx, base);
	// 827E6E00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827E6E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6E0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E6E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E6E18 size=20
    let mut pc: u32 = 0x827E6E18;
    'dispatch: loop {
        match pc {
            0x827E6E18 => {
    //   block [0x827E6E18..0x827E6E2C)
	// 827E6E18: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E6E1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E6E20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 827E6E24: 916AAC34  stw r11, -0x53cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21452 as u32), ctx.r[11].u32 ) };
	// 827E6E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E6E30 size=4
    let mut pc: u32 = 0x827E6E30;
    'dispatch: loop {
        match pc {
            0x827E6E30 => {
    //   block [0x827E6E30..0x827E6E34)
	// 827E6E30: 488DA630  b 0x830c1460
	sub_830C1460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E6E38 size=8
    let mut pc: u32 = 0x827E6E38;
    'dispatch: loop {
        match pc {
            0x827E6E38 => {
    //   block [0x827E6E38..0x827E6E40)
	// 827E6E38: 988300D9  stb r4, 0xd9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(217 as u32), ctx.r[4].u8 ) };
	// 827E6E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6E40 size=40
    let mut pc: u32 = 0x827E6E40;
    'dispatch: loop {
        match pc {
            0x827E6E40 => {
    //   block [0x827E6E40..0x827E6E68)
	// 827E6E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6E48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6E4C: 4860C245  bl 0x82df3090
	ctx.lr = 0x827E6E50;
	sub_82DF3090(ctx, base);
	// 827E6E50: 4860BB01  bl 0x82df2950
	ctx.lr = 0x827E6E54;
	sub_82DF2950(ctx, base);
	// 827E6E54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 827E6E58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E6E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6E68 size=136
    let mut pc: u32 = 0x827E6E68;
    'dispatch: loop {
        match pc {
            0x827E6E68 => {
    //   block [0x827E6E68..0x827E6EF0)
	// 827E6E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6E70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E6E74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E6E80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E6E84: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827E6E88: 409A0020  bne cr6, 0x827e6ea8
	if !ctx.cr[6].eq {
	pc = 0x827E6EA8; continue 'dispatch;
	}
	// 827E6E8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E6E90: 419A0048  beq cr6, 0x827e6ed8
	if ctx.cr[6].eq {
	pc = 0x827E6ED8; continue 'dispatch;
	}
	// 827E6E94: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6E98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6E9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E6EA0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E6EA4: 48000034  b 0x827e6ed8
	pc = 0x827E6ED8; continue 'dispatch;
	// 827E6EA8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827E6EAC: 419A002C  beq cr6, 0x827e6ed8
	if ctx.cr[6].eq {
	pc = 0x827E6ED8; continue 'dispatch;
	}
	// 827E6EB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E6EB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6EB8: 388BC2A8  addi r4, r11, -0x3d58
	ctx.r[4].s64 = ctx.r[11].s64 + -15704;
	// 827E6EBC: 489C123D  bl 0x831a80f8
	ctx.lr = 0x827E6EC0;
	sub_831A80F8(ctx, base);
	// 827E6EC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E6EC4: 4182000C  beq 0x827e6ed0
	if ctx.cr[0].eq {
	pc = 0x827E6ED0; continue 'dispatch;
	}
	// 827E6EC8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E6ECC: 4800000C  b 0x827e6ed8
	pc = 0x827E6ED8; continue 'dispatch;
	// 827E6ED0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E6ED4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6ED8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E6EDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6EE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6EE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E6EE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6EEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6EF0 size=136
    let mut pc: u32 = 0x827E6EF0;
    'dispatch: loop {
        match pc {
            0x827E6EF0 => {
    //   block [0x827E6EF0..0x827E6F78)
	// 827E6EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E6EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E6F08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E6F0C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827E6F10: 409A0020  bne cr6, 0x827e6f30
	if !ctx.cr[6].eq {
	pc = 0x827E6F30; continue 'dispatch;
	}
	// 827E6F14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E6F18: 419A0048  beq cr6, 0x827e6f60
	if ctx.cr[6].eq {
	pc = 0x827E6F60; continue 'dispatch;
	}
	// 827E6F1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6F20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6F24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E6F28: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E6F2C: 48000034  b 0x827e6f60
	pc = 0x827E6F60; continue 'dispatch;
	// 827E6F30: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827E6F34: 419A002C  beq cr6, 0x827e6f60
	if ctx.cr[6].eq {
	pc = 0x827E6F60; continue 'dispatch;
	}
	// 827E6F38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E6F3C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6F40: 388BC388  addi r4, r11, -0x3c78
	ctx.r[4].s64 = ctx.r[11].s64 + -15480;
	// 827E6F44: 489C11B5  bl 0x831a80f8
	ctx.lr = 0x827E6F48;
	sub_831A80F8(ctx, base);
	// 827E6F48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E6F4C: 4182000C  beq 0x827e6f58
	if ctx.cr[0].eq {
	pc = 0x827E6F58; continue 'dispatch;
	}
	// 827E6F50: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E6F54: 4800000C  b 0x827e6f60
	pc = 0x827E6F60; continue 'dispatch;
	// 827E6F58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E6F5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6F60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E6F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6F6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E6F70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E6F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E6F78 size=136
    let mut pc: u32 = 0x827E6F78;
    'dispatch: loop {
        match pc {
            0x827E6F78 => {
    //   block [0x827E6F78..0x827E7000)
	// 827E6F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E6F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E6F80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E6F84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E6F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E6F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E6F90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E6F94: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827E6F98: 409A0020  bne cr6, 0x827e6fb8
	if !ctx.cr[6].eq {
	pc = 0x827E6FB8; continue 'dispatch;
	}
	// 827E6F9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E6FA0: 419A0048  beq cr6, 0x827e6fe8
	if ctx.cr[6].eq {
	pc = 0x827E6FE8; continue 'dispatch;
	}
	// 827E6FA4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6FA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6FAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E6FB0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E6FB4: 48000034  b 0x827e6fe8
	pc = 0x827E6FE8; continue 'dispatch;
	// 827E6FB8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827E6FBC: 419A002C  beq cr6, 0x827e6fe8
	if ctx.cr[6].eq {
	pc = 0x827E6FE8; continue 'dispatch;
	}
	// 827E6FC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E6FC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E6FC8: 388BC428  addi r4, r11, -0x3bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -15320;
	// 827E6FCC: 489C112D  bl 0x831a80f8
	ctx.lr = 0x827E6FD0;
	sub_831A80F8(ctx, base);
	// 827E6FD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E6FD4: 4182000C  beq 0x827e6fe0
	if ctx.cr[0].eq {
	pc = 0x827E6FE0; continue 'dispatch;
	}
	// 827E6FD8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E6FDC: 4800000C  b 0x827e6fe8
	pc = 0x827E6FE8; continue 'dispatch;
	// 827E6FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E6FE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E6FE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E6FEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E6FF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E6FF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E6FF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E6FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7000 size=16
    let mut pc: u32 = 0x827E7000;
    'dispatch: loop {
        match pc {
            0x827E7000 => {
    //   block [0x827E7000..0x827E7010)
	// 827E7000: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E7004: 816BAC34  lwz r11, -0x53cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827E7008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E700C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7010 size=12
    let mut pc: u32 = 0x827E7010;
    'dispatch: loop {
        match pc {
            0x827E7010 => {
    //   block [0x827E7010..0x827E701C)
	// 827E7010: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E7014: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 827E7018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7020 size=32
    let mut pc: u32 = 0x827E7020;
    'dispatch: loop {
        match pc {
            0x827E7020 => {
    //   block [0x827E7020..0x827E7040)
	// 827E7020: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E7024: 816BAC34  lwz r11, -0x53cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827E7028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E702C: 419A0014  beq cr6, 0x827e7040
	if ctx.cr[6].eq {
		sub_827E7040(ctx, base);
		return;
	}
	// 827E7030: 896B0014  lbz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E7034: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827E7038: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827E703C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7040 size=8
    let mut pc: u32 = 0x827E7040;
    'dispatch: loop {
        match pc {
            0x827E7040 => {
    //   block [0x827E7040..0x827E7048)
	// 827E7040: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E7044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7048 size=196
    let mut pc: u32 = 0x827E7048;
    'dispatch: loop {
        match pc {
            0x827E7048 => {
    //   block [0x827E7048..0x827E710C)
	// 827E7048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E704C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E7054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E7058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E705C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E7060: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E7064: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827E7068: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E706C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7070: 4BAD98C9  bl 0x822c0938
	ctx.lr = 0x827E7074;
	sub_822C0938(ctx, base);
	// 827E7074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E7078: 41820028  beq 0x827e70a0
	if ctx.cr[0].eq {
	pc = 0x827E70A0; continue 'dispatch;
	}
	// 827E707C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E7080: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 827E7084: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E7088: 392B5B1C  addi r9, r11, 0x5b1c
	ctx.r[9].s64 = ctx.r[11].s64 + 23324;
	// 827E708C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E7090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E7094: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E7098: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E709C: 48000008  b 0x827e70a4
	pc = 0x827E70A4; continue 'dispatch;
	// 827E70A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E70A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E70A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E70AC: 409A0044  bne cr6, 0x827e70f0
	if !ctx.cr[6].eq {
	pc = 0x827E70F0; continue 'dispatch;
	}
	// 827E70B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E70B4: 419A001C  beq cr6, 0x827e70d0
	if ctx.cr[6].eq {
	pc = 0x827E70D0; continue 'dispatch;
	}
	// 827E70B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E70BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E70C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E70C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E70C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E70CC: 4E800421  bctrl
	ctx.lr = 0x827E70D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E70D0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E70D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E70D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E70DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 827E70E0: 816BC1E8  lwz r11, -0x3e18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15896 as u32) ) } as u64;
	// 827E70E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E70E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E70EC: 4BAD8F15  bl 0x822c0000
	ctx.lr = 0x827E70F0;
	sub_822C0000(ctx, base);
	// 827E70F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E70F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E70F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E70FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E7100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E7104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E7108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7110 size=20
    let mut pc: u32 = 0x827E7110;
    'dispatch: loop {
        match pc {
            0x827E7110 => {
    //   block [0x827E7110..0x827E7124)
	// 827E7110: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7114: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7118: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E711C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7120: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7124(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7124 size=44
    let mut pc: u32 = 0x827E7124;
    'dispatch: loop {
        match pc {
            0x827E7124 => {
    //   block [0x827E7124..0x827E7150)
	// 827E7124: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7128: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E712C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E7130: 41990020  bgt cr6, 0x827e7150
	if ctx.cr[6].gt {
		sub_827E7150(ctx, base);
		return;
	}
	// 827E7134: 41980014  blt cr6, 0x827e7148
	if ctx.cr[6].lt {
	pc = 0x827E7148; continue 'dispatch;
	}
	// 827E7138: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E713C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E7140: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E7144: 4198000C  blt cr6, 0x827e7150
	if ctx.cr[6].lt {
		sub_827E7150(ctx, base);
		return;
	}
	// 827E7148: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E714C: 48000008  b 0x827e7154
	sub_827E7150(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7150 size=20
    let mut pc: u32 = 0x827E7150;
    'dispatch: loop {
        match pc {
            0x827E7150 => {
    //   block [0x827E7150..0x827E7164)
	// 827E7150: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E7154: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E7158: 4182000C  beq 0x827e7164
	if ctx.cr[0].eq {
		sub_827E7164(ctx, base);
		return;
	}
	// 827E715C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7160: 4800000C  b 0x827e716c
	sub_827E7164(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7164(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E7164 size=24
    let mut pc: u32 = 0x827E7164;
    'dispatch: loop {
        match pc {
            0x827E7164 => {
    //   block [0x827E7164..0x827E717C)
	// 827E7164: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827E7168: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E716C: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7170: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7174: 419AFFB4  beq cr6, 0x827e7128
	if ctx.cr[6].eq {
		sub_827E7124(ctx, base);
		return;
	}
	// 827E7178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7180 size=108
    let mut pc: u32 = 0x827E7180;
    'dispatch: loop {
        match pc {
            0x827E7180 => {
    //   block [0x827E7180..0x827E71EC)
	// 827E7180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7188: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E718C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E7190: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E7194: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 827E7198: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 827E719C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 827E71A0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E71A4: 4860AF25  bl 0x82df20c8
	ctx.lr = 0x827E71A8;
	sub_82DF20C8(ctx, base);
	// 827E71A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E71AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E71B0: 41820008  beq 0x827e71b8
	if ctx.cr[0].eq {
	pc = 0x827E71B8; continue 'dispatch;
	}
	// 827E71B4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E71B8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E71BC: 41820008  beq 0x827e71c4
	if ctx.cr[0].eq {
	pc = 0x827E71C4; continue 'dispatch;
	}
	// 827E71C0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E71C4: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E71C8: 41820008  beq 0x827e71d0
	if ctx.cr[0].eq {
	pc = 0x827E71D0; continue 'dispatch;
	}
	// 827E71CC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E71D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E71D4: 9943001D  stb r10, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[10].u8 ) };
	// 827E71D8: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 827E71DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E71E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E71E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E71E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E71F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E71F0 size=72
    let mut pc: u32 = 0x827E71F0;
    'dispatch: loop {
        match pc {
            0x827E71F0 => {
    //   block [0x827E71F0..0x827E7238)
	// 827E71F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E71F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E71F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E71FC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827E7200: 419A001C  beq cr6, 0x827e721c
	if ctx.cr[6].eq {
	pc = 0x827E721C; continue 'dispatch;
	}
	// 827E7204: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E7208: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E720C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E7210: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E7214: 4BFFFC55  bl 0x827e6e68
	ctx.lr = 0x827E7218;
	sub_827E6E68(ctx, base);
	// 827E7218: 48000010  b 0x827e7228
	pc = 0x827E7228; continue 'dispatch;
	// 827E721C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E7220: 396BC2A8  addi r11, r11, -0x3d58
	ctx.r[11].s64 = ctx.r[11].s64 + -15704;
	// 827E7224: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7228: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E722C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E7230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E7234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7238 size=72
    let mut pc: u32 = 0x827E7238;
    'dispatch: loop {
        match pc {
            0x827E7238 => {
    //   block [0x827E7238..0x827E7280)
	// 827E7238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E723C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7244: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827E7248: 419A001C  beq cr6, 0x827e7264
	if ctx.cr[6].eq {
	pc = 0x827E7264; continue 'dispatch;
	}
	// 827E724C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E7250: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E7254: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E7258: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E725C: 4BFFFC95  bl 0x827e6ef0
	ctx.lr = 0x827E7260;
	sub_827E6EF0(ctx, base);
	// 827E7260: 48000010  b 0x827e7270
	pc = 0x827E7270; continue 'dispatch;
	// 827E7264: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E7268: 396BC388  addi r11, r11, -0x3c78
	ctx.r[11].s64 = ctx.r[11].s64 + -15480;
	// 827E726C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7270: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E7274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E7278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E727C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7280 size=72
    let mut pc: u32 = 0x827E7280;
    'dispatch: loop {
        match pc {
            0x827E7280 => {
    //   block [0x827E7280..0x827E72C8)
	// 827E7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7288: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E728C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827E7290: 419A001C  beq cr6, 0x827e72ac
	if ctx.cr[6].eq {
	pc = 0x827E72AC; continue 'dispatch;
	}
	// 827E7294: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E7298: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E729C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E72A0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E72A4: 4BFFFCD5  bl 0x827e6f78
	ctx.lr = 0x827E72A8;
	sub_827E6F78(ctx, base);
	// 827E72A8: 48000010  b 0x827e72b8
	pc = 0x827E72B8; continue 'dispatch;
	// 827E72AC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E72B0: 396BC428  addi r11, r11, -0x3bd8
	ctx.r[11].s64 = ctx.r[11].s64 + -15320;
	// 827E72B4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E72B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E72BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E72C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E72C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E72C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E72C8 size=588
    let mut pc: u32 = 0x827E72C8;
    'dispatch: loop {
        match pc {
            0x827E72C8 => {
    //   block [0x827E72C8..0x827E7514)
	// 827E72C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E72CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E72D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E72D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E72D8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 827E72DC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 827E72E0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 827E72E4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E72E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E72EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E72F0: 488DB111  bl 0x830c2400
	ctx.lr = 0x827E72F4;
	sub_830C2400(ctx, base);
	// 827E72F4: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E72F8: 806B0068  lwz r3, 0x68(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 827E72FC: 48691285  bl 0x82e78580
	ctx.lr = 0x827E7300;
	sub_82E78580(ctx, base);
	// 827E7300: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827E7304: 809F00B4  lwz r4, 0xb4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E7308: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E730C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827E7310: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827E7314: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 827E7318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E731C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 827E7320: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7324: C00A5778  lfs f0, 0x5778(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E7328: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E732C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 827E7330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E7334: 4E800421  bctrl
	ctx.lr = 0x827E7338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E7338: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E733C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E7340: 808B0068  lwz r4, 0x68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 827E7344: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7348: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E734C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E7350: 4E800421  bctrl
	ctx.lr = 0x827E7354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E7354: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E7358: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E735C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E7360: 396BC1EC  addi r11, r11, -0x3e14
	ctx.r[11].s64 = ctx.r[11].s64 + -15892;
	// 827E7364: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E7368: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E736C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E7370: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E7374: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E7378: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 827E737C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 827E7380: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E7384: EFCB002A  fadds f30, f11, f0
	ctx.f[30].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E7388: C00100A4  lfs f0, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E738C: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E7390: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E7394: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 827E7398: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E739C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 827E73A0: EC1E6828  fsubs f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 827E73A4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 827E73A8: EFAD0028  fsubs f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E73AC: 4BAE72CD  bl 0x822ce678
	ctx.lr = 0x827E73B0;
	sub_822CE678(ctx, base);
	// 827E73B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E73B4: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E73B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E73BC: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E73C0: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E73C4: 488E1ED5  bl 0x830c9298
	ctx.lr = 0x827E73C8;
	sub_830C9298(ctx, base);
	// 827E73C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E73CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827E73D0: 488E1E99  bl 0x830c9268
	ctx.lr = 0x827E73D4;
	sub_830C9268(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7518 size=88
    let mut pc: u32 = 0x827E7518;
    'dispatch: loop {
        match pc {
            0x827E7518 => {
    //   block [0x827E7518..0x827E7570)
	// 827E7518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E751C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7520: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E7524: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E752C: 4BFFFC55  bl 0x827e7180
	ctx.lr = 0x827E7530;
	sub_827E7180(ctx, base);
	// 827E7530: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E7534: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 827E7538: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E753C: 9963001D  stb r11, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 827E7540: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7544: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E7548: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E754C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7550: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7554: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E7558: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E755C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E7560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E7564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E7568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E756C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7570 size=124
    let mut pc: u32 = 0x827E7570;
    'dispatch: loop {
        match pc {
            0x827E7570 => {
    //   block [0x827E7570..0x827E75EC)
	// 827E7570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7578: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E757C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E7584: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 827E7588: F89F0000  std r4, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 827E758C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7590: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E7594: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E759C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827E75A0: 419A0024  beq cr6, 0x827e75c4
	if ctx.cr[6].eq {
	pc = 0x827E75C4; continue 'dispatch;
	}
	// 827E75A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E75A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E75AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E75B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E75B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E75B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E75BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E75C0: 4082FFE8  bne 0x827e75a8
	if !ctx.cr[0].eq {
	pc = 0x827E75A8; continue 'dispatch;
	}
	// 827E75C4: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E75C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E75CC: 419A0008  beq cr6, 0x827e75d4
	if ctx.cr[6].eq {
	pc = 0x827E75D4; continue 'dispatch;
	}
	// 827E75D0: 4BAD92C1  bl 0x822c0890
	ctx.lr = 0x827E75D4;
	sub_822C0890(ctx, base);
	// 827E75D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E75D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E75DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E75E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E75E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E75E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E75F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E75F0 size=144
    let mut pc: u32 = 0x827E75F0;
    'dispatch: loop {
        match pc {
            0x827E75F0 => {
    //   block [0x827E75F0..0x827E7680)
	// 827E75F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E75F4: 489C0B79  bl 0x831a816c
	ctx.lr = 0x827E75F8;
	sub_831A8130(ctx, base);
	// 827E75F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E75FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E7600: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827E7604: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E7608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E760C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E7610: 4BFFFB01  bl 0x827e7110
	ctx.lr = 0x827E7614;
	sub_827E7110(ctx, base);
	// 827E7614: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7618: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827E761C: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827E7620: 419A0044  beq cr6, 0x827e7664
	if ctx.cr[6].eq {
	pc = 0x827E7664; continue 'dispatch;
	}
	// 827E7624: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7628: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E762C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7630: 41990020  bgt cr6, 0x827e7650
	if ctx.cr[6].gt {
	pc = 0x827E7650; continue 'dispatch;
	}
	// 827E7634: 41980014  blt cr6, 0x827e7648
	if ctx.cr[6].lt {
	pc = 0x827E7648; continue 'dispatch;
	}
	// 827E7638: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E763C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7640: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7644: 4198000C  blt cr6, 0x827e7650
	if ctx.cr[6].lt {
	pc = 0x827E7650; continue 'dispatch;
	}
	// 827E7648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E764C: 48000008  b 0x827e7654
	pc = 0x827E7654; continue 'dispatch;
	// 827E7650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E7654: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E7658: 4082000C  bne 0x827e7664
	if !ctx.cr[0].eq {
	pc = 0x827E7664; continue 'dispatch;
	}
	// 827E765C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E7660: 4800000C  b 0x827e766c
	pc = 0x827E766C; continue 'dispatch;
	// 827E7664: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 827E7668: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 827E766C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7670: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7674: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7678: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E767C: 489C0B40  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7680 size=428
    let mut pc: u32 = 0x827E7680;
    'dispatch: loop {
        match pc {
            0x827E7680 => {
    //   block [0x827E7680..0x827E782C)
	// 827E7680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7684: 489C0AD9  bl 0x831a815c
	ctx.lr = 0x827E7688;
	sub_831A8130(ctx, base);
	// 827E7688: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E768C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E7690: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E7694: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E7698: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 827E769C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 827E76A0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E76A4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827E76A8: 41980010  blt cr6, 0x827e76b8
	if ctx.cr[6].lt {
	pc = 0x827E76B8; continue 'dispatch;
	}
	// 827E76AC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E76B0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827E76B4: 40980008  bge cr6, 0x827e76bc
	if !ctx.cr[6].lt {
	pc = 0x827E76BC; continue 'dispatch;
	}
	// 827E76B8: 486091C1  bl 0x82df0878
	ctx.lr = 0x827E76BC;
	sub_82DF0878(ctx, base);
	// 827E76BC: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E76C0: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 827E76C4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E76C8: 40980008  bge cr6, 0x827e76d0
	if !ctx.cr[6].lt {
	pc = 0x827E76D0; continue 'dispatch;
	}
	// 827E76CC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827E76D0: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E76D4: 216BFFFF  subfic r11, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[11].s64 = (-1 as i64) - ctx.r[11].s64;
	// 827E76D8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E76DC: 41990008  bgt cr6, 0x827e76e4
	if ctx.cr[6].gt {
	pc = 0x827E76E4; continue 'dispatch;
	}
	// 827E76E0: 48609061  bl 0x82df0740
	ctx.lr = 0x827E76E4;
	sub_82DF0740(ctx, base);
	// 827E76E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E76E8: 419A0138  beq cr6, 0x827e7820
	if ctx.cr[6].eq {
	pc = 0x827E7820; continue 'dispatch;
	}
	// 827E76EC: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E76F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E76F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E76F8: 7F3E5A14  add r25, r30, r11
	ctx.r[25].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 827E76FC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E7700: 4BADDCB9  bl 0x822c53b8
	ctx.lr = 0x827E7704;
	sub_822C53B8(ctx, base);
	// 827E7704: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E7708: 41820118  beq 0x827e7820
	if ctx.cr[0].eq {
	pc = 0x827E7820; continue 'dispatch;
	}
	// 827E770C: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E7710: 3B7C0004  addi r27, r28, 4
	ctx.r[27].s64 = ctx.r[28].s64 + 4;
	// 827E7714: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E7718: 4198000C  blt cr6, 0x827e7724
	if ctx.cr[6].lt {
	pc = 0x827E7724; continue 'dispatch;
	}
	// 827E771C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7720: 48000008  b 0x827e7728
	pc = 0x827E7728; continue 'dispatch;
	// 827E7724: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 827E7728: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E772C: 4198000C  blt cr6, 0x827e7738
	if ctx.cr[6].lt {
	pc = 0x827E7738; continue 'dispatch;
	}
	// 827E7730: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7734: 48000008  b 0x827e773c
	pc = 0x827E773C; continue 'dispatch;
	// 827E7738: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827E773C: 811C0014  lwz r8, 0x14(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E7740: 7D3F4850  subf r9, r31, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[31].s64;
	// 827E7744: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E7748: 7CDF4050  subf r6, r31, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[31].s64;
	// 827E774C: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 827E7750: 7C9E4850  subf r4, r30, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 827E7754: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827E7758: 489C15B1  bl 0x831a8d08
	ctx.lr = 0x827E775C;
	sub_831A8D08(ctx, base);
	// 827E775C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827E7760: 409A0058  bne cr6, 0x827e77b8
	if !ctx.cr[6].eq {
	pc = 0x827E77B8; continue 'dispatch;
	}
	// 827E7764: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827E7768: 7D1AF214  add r8, r26, r30
	ctx.r[8].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 827E776C: 41980008  blt cr6, 0x827e7774
	if ctx.cr[6].lt {
	pc = 0x827E7774; continue 'dispatch;
	}
	// 827E7770: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 827E7774: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E7778: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E777C: 4198000C  blt cr6, 0x827e7788
	if ctx.cr[6].lt {
	pc = 0x827E7788; continue 'dispatch;
	}
	// 827E7780: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7784: 48000008  b 0x827e778c
	pc = 0x827E778C; continue 'dispatch;
	// 827E7788: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 827E778C: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E7790: 4198000C  blt cr6, 0x827e779c
	if ctx.cr[6].lt {
	pc = 0x827E779C; continue 'dispatch;
	}
	// 827E7794: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7798: 48000008  b 0x827e77a0
	pc = 0x827E77A0; continue 'dispatch;
	// 827E779C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827E77A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827E77A4: 7CAA4214  add r5, r10, r8
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 827E77A8: 7C9F4850  subf r4, r31, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[31].s64;
	// 827E77AC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E77B0: 489C1559  bl 0x831a8d08
	ctx.lr = 0x827E77B4;
	sub_831A8D08(ctx, base);
	// 827E77B4: 48000048  b 0x827e77fc
	pc = 0x827E77FC; continue 'dispatch;
	// 827E77B8: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E77BC: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E77C0: 4198000C  blt cr6, 0x827e77cc
	if ctx.cr[6].lt {
	pc = 0x827E77CC; continue 'dispatch;
	}
	// 827E77C4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E77C8: 48000008  b 0x827e77d0
	pc = 0x827E77D0; continue 'dispatch;
	// 827E77CC: 393D0004  addi r9, r29, 4
	ctx.r[9].s64 = ctx.r[29].s64 + 4;
	// 827E77D0: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E77D4: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 827E77D8: 4198000C  blt cr6, 0x827e77e4
	if ctx.cr[6].lt {
	pc = 0x827E77E4; continue 'dispatch;
	}
	// 827E77DC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E77E0: 48000008  b 0x827e77e8
	pc = 0x827E77E8; continue 'dispatch;
	// 827E77E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827E77E8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827E77EC: 7CA9D214  add r5, r9, r26
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 827E77F0: 7C9F5050  subf r4, r31, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 827E77F4: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827E77F8: 489C1439  bl 0x831a8c30
	ctx.lr = 0x827E77FC;
	sub_831A8C30(ctx, base);
	// 827E77FC: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E7800: 933C0014  stw r25, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 827E7804: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E7808: 4198000C  blt cr6, 0x827e7814
	if ctx.cr[6].lt {
	pc = 0x827E7814; continue 'dispatch;
	}
	// 827E780C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7810: 48000008  b 0x827e7818
	pc = 0x827E7818; continue 'dispatch;
	// 827E7814: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827E7818: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E781C: 7D4BC9AE  stbx r10, r11, r25
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[10].u8) };
	// 827E7820: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E7824: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827E7828: 489C0984  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7830 size=116
    let mut pc: u32 = 0x827E7830;
    'dispatch: loop {
        match pc {
            0x827E7830 => {
    //   block [0x827E7830..0x827E78A4)
	// 827E7830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7834: 489C092D  bl 0x831a8160
	ctx.lr = 0x827E7838;
	sub_831A8130(ctx, base);
	// 827E7838: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E783C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E7840: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E7844: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E7848: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827E784C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 827E7850: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 827E7854: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E7858: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 827E785C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 827E7860: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 827E7864: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 827E7868: 4860A861  bl 0x82df20c8
	ctx.lr = 0x827E786C;
	sub_82DF20C8(ctx, base);
	// 827E786C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E7870: 41820028  beq 0x827e7898
	if ctx.cr[0].eq {
	pc = 0x827E7898; continue 'dispatch;
	}
	// 827E7874: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827E7878: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E787C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 827E7880: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827E7884: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827E7888: 483C8401  bl 0x82bafc88
	ctx.lr = 0x827E788C;
	sub_82BAFC88(ctx, base);
	// 827E788C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E7890: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 827E7894: 997F001D  stb r11, 0x1d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 827E7898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E789C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827E78A0: 489C0910  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E78A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E78A8 size=408
    let mut pc: u32 = 0x827E78A8;
    'dispatch: loop {
        match pc {
            0x827E78A8 => {
    //   block [0x827E78A8..0x827E7A40)
	// 827E78A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E78AC: 489C08B5  bl 0x831a8160
	ctx.lr = 0x827E78B0;
	sub_831A8130(ctx, base);
	// 827E78B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E78B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E78B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E78BC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827E78C0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 827E78C4: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 827E78C8: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E78CC: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E78D0: 4198000C  blt cr6, 0x827e78dc
	if ctx.cr[6].lt {
	pc = 0x827E78DC; continue 'dispatch;
	}
	// 827E78D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E78D8: 48000008  b 0x827e78e0
	pc = 0x827E78E0; continue 'dispatch;
	// 827E78DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E78E0: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E78E4: 4198002C  blt cr6, 0x827e7910
	if ctx.cr[6].lt {
	pc = 0x827E7910; continue 'dispatch;
	}
	// 827E78E8: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E78EC: 4198000C  blt cr6, 0x827e78f8
	if ctx.cr[6].lt {
	pc = 0x827E78F8; continue 'dispatch;
	}
	// 827E78F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E78F4: 48000008  b 0x827e78fc
	pc = 0x827E78FC; continue 'dispatch;
	// 827E78F8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E78FC: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E7900: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827E7904: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827E7908: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E790C: 41990008  bgt cr6, 0x827e7914
	if ctx.cr[6].gt {
	pc = 0x827E7914; continue 'dispatch;
	}
	// 827E7910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E7914: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E7918: 41820034  beq 0x827e794c
	if ctx.cr[0].eq {
	pc = 0x827E794C; continue 'dispatch;
	}
	// 827E791C: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E7920: 4198000C  blt cr6, 0x827e792c
	if ctx.cr[6].lt {
	pc = 0x827E792C; continue 'dispatch;
	}
	// 827E7924: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7928: 48000008  b 0x827e7930
	pc = 0x827E7930; continue 'dispatch;
	// 827E792C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E7930: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E7934: 7CCBD050  subf r6, r11, r26
	ctx.r[6].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 827E7938: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E793C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E7940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E7944: 4BFFFD3D  bl 0x827e7680
	ctx.lr = 0x827E7948;
	sub_827E7680(ctx, base);
	// 827E7948: 480000F0  b 0x827e7a38
	pc = 0x827E7A38; continue 'dispatch;
	// 827E794C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E7950: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E7954: 40980008  bge cr6, 0x827e795c
	if !ctx.cr[6].lt {
	pc = 0x827E795C; continue 'dispatch;
	}
	// 827E7958: 48608F21  bl 0x82df0878
	ctx.lr = 0x827E795C;
	sub_82DF0878(ctx, base);
	// 827E795C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E7960: 216BFFFF  subfic r11, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[11].s64 = (-1 as i64) - ctx.r[11].s64;
	// 827E7964: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827E7968: 41990008  bgt cr6, 0x827e7970
	if ctx.cr[6].gt {
	pc = 0x827E7970; continue 'dispatch;
	}
	// 827E796C: 48608DD5  bl 0x82df0740
	ctx.lr = 0x827E7970;
	sub_82DF0740(ctx, base);
	// 827E7970: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E7974: 419A00C0  beq cr6, 0x827e7a34
	if ctx.cr[6].eq {
	pc = 0x827E7A34; continue 'dispatch;
	}
	// 827E7978: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E797C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E7980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E7984: 7F7C5A14  add r27, r28, r11
	ctx.r[27].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 827E7988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E798C: 4BADDA2D  bl 0x822c53b8
	ctx.lr = 0x827E7990;
	sub_822C53B8(ctx, base);
	// 827E7990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E7994: 418200A0  beq 0x827e7a34
	if ctx.cr[0].eq {
	pc = 0x827E7A34; continue 'dispatch;
	}
	// 827E7998: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E799C: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E79A0: 4198000C  blt cr6, 0x827e79ac
	if ctx.cr[6].lt {
	pc = 0x827E79AC; continue 'dispatch;
	}
	// 827E79A4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E79A8: 48000008  b 0x827e79b0
	pc = 0x827E79B0; continue 'dispatch;
	// 827E79AC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827E79B0: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 827E79B4: 4198000C  blt cr6, 0x827e79c0
	if ctx.cr[6].lt {
	pc = 0x827E79C0; continue 'dispatch;
	}
	// 827E79B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E79BC: 48000008  b 0x827e79c4
	pc = 0x827E79C4; continue 'dispatch;
	// 827E79C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E79C4: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E79C8: 7D3E4850  subf r9, r30, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	// 827E79CC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827E79D0: 7CDE4050  subf r6, r30, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 827E79D4: 7CAAF214  add r5, r10, r30
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 827E79D8: 7C9C4850  subf r4, r28, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 827E79DC: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 827E79E0: 489C1329  bl 0x831a8d08
	ctx.lr = 0x827E79E4;
	sub_831A8D08(ctx, base);
	// 827E79E4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E79E8: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E79EC: 4198000C  blt cr6, 0x827e79f8
	if ctx.cr[6].lt {
	pc = 0x827E79F8; continue 'dispatch;
	}
	// 827E79F0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E79F4: 48000008  b 0x827e79fc
	pc = 0x827E79FC; continue 'dispatch;
	// 827E79F8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827E79FC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827E7A00: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827E7A04: 7C9E5850  subf r4, r30, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827E7A08: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 827E7A0C: 489C1225  bl 0x831a8c30
	ctx.lr = 0x827E7A10;
	sub_831A8C30(ctx, base);
	// 827E7A10: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E7A14: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 827E7A18: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827E7A1C: 4198000C  blt cr6, 0x827e7a28
	if ctx.cr[6].lt {
	pc = 0x827E7A28; continue 'dispatch;
	}
	// 827E7A20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7A24: 48000008  b 0x827e7a2c
	pc = 0x827E7A2C; continue 'dispatch;
	// 827E7A28: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827E7A2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E7A30: 7D4BD9AE  stbx r10, r11, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u8) };
	// 827E7A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E7A38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827E7A3C: 489C0774  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7A40 size=108
    let mut pc: u32 = 0x827E7A40;
    'dispatch: loop {
        match pc {
            0x827E7A40 => {
    //   block [0x827E7A40..0x827E7AAC)
	// 827E7A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E7A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E7A4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7A50: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E7A54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E7A58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E7A5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827E7A60: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E7A64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827E7A68: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827E7A6C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 827E7A70: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 827E7A74: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E7A78: 4BFF5381  bl 0x827dcdf8
	ctx.lr = 0x827E7A7C;
	sub_827DCDF8(ctx, base);
	// 827E7A7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7A80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E7A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7A88: 419A000C  beq cr6, 0x827e7a94
	if ctx.cr[6].eq {
	pc = 0x827E7A94; continue 'dispatch;
	}
	// 827E7A8C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827E7A90: 4BAD8E01  bl 0x822c0890
	ctx.lr = 0x827E7A94;
	sub_822C0890(ctx, base);
	// 827E7A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E7A98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E7A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E7AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E7AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E7AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7AB0 size=104
    let mut pc: u32 = 0x827E7AB0;
    'dispatch: loop {
        match pc {
            0x827E7AB0 => {
    //   block [0x827E7AB0..0x827E7B18)
	// 827E7AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7AB4: 489C06B5  bl 0x831a8168
	ctx.lr = 0x827E7AB8;
	sub_831A8130(ctx, base);
	// 827E7AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7ABC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E7AC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E7AC4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827E7AC8: 897E001D  lbz r11, 0x1d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7AD0: 409A0040  bne cr6, 0x827e7b10
	if !ctx.cr[6].eq {
	pc = 0x827E7B10; continue 'dispatch;
	}
	// 827E7AD4: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 827E7AD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E7ADC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7AE0: 4BFFFFD1  bl 0x827e7ab0
	ctx.lr = 0x827E7AE4;
	sub_827E7AB0(ctx, base);
	// 827E7AE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E7AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7AEC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7AF0: 4BFF5259  bl 0x827dcd48
	ctx.lr = 0x827E7AF4;
	sub_827DCD48(ctx, base);
	// 827E7AF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E7AF8: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E7AFC: 4860A68D  bl 0x82df2188
	ctx.lr = 0x827E7B00;
	sub_82DF2188(ctx, base);
	// 827E7B00: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7B04: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 827E7B08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7B0C: 419AFFCC  beq cr6, 0x827e7ad8
	if ctx.cr[6].eq {
	pc = 0x827E7AD8; continue 'dispatch;
	}
	// 827E7B10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E7B14: 489C06A4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7B18 size=548
    let mut pc: u32 = 0x827E7B18;
    'dispatch: loop {
        match pc {
            0x827E7B18 => {
    //   block [0x827E7B18..0x827E7D3C)
	// 827E7B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7B1C: 489C0645  bl 0x831a8160
	ctx.lr = 0x827E7B20;
	sub_831A8130(ctx, base);
	// 827E7B20: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7B24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E7B28: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 827E7B2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E7B30: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 827E7B34: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827E7B38: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7B3C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 827E7B40: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827E7B44: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7B48: 41980048  blt cr6, 0x827e7b90
	if ctx.cr[6].lt {
	pc = 0x827E7B90; continue 'dispatch;
	}
	// 827E7B4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E7B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E7B54: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 827E7B58: 4BADDD71  bl 0x822c58c8
	ctx.lr = 0x827E7B5C;
	sub_822C58C8(ctx, base);
	// 827E7B5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E7B60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E7B64: 4BADDCB5  bl 0x822c5818
	ctx.lr = 0x827E7B68;
	sub_822C5818(ctx, base);
	// 827E7B68: 4BADC749  bl 0x822c42b0
	ctx.lr = 0x827E7B6C;
	sub_822C42B0(ctx, base);
	// 827E7B6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E7B70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E7B74: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 827E7B78: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827E7B7C: 4BADD8F5  bl 0x822c5470
	ctx.lr = 0x827E7B80;
	sub_822C5470(ctx, base);
	// 827E7B80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E7B84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E7B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E7B8C: 4BADD155  bl 0x822c4ce0
	ctx.lr = 0x827E7B90;
	sub_822C4CE0(ctx, base);
	// 827E7B90: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7B94: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827E7B98: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827E7B9C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 827E7BA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E7BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7BA8: 4BFFFC89  bl 0x827e7830
	ctx.lr = 0x827E7BAC;
	sub_827E7830(ctx, base);
	// 827E7BAC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7BB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7BB4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E7BB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E7BBC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7BC0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E7BC4: 409A0018  bne cr6, 0x827e7bdc
	if !ctx.cr[6].eq {
	pc = 0x827E7BDC; continue 'dispatch;
	}
	// 827E7BC8: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 827E7BCC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7BD0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7BD4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7BD8: 4800003C  b 0x827e7c14
	pc = 0x827E7C14; continue 'dispatch;
	// 827E7BDC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E7BE0: 41820020  beq 0x827e7c00
	if ctx.cr[0].eq {
	pc = 0x827E7C00; continue 'dispatch;
	}
	// 827E7BE4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7BE8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7BEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7BF0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E7BF4: 409A0024  bne cr6, 0x827e7c18
	if !ctx.cr[6].eq {
	pc = 0x827E7C18; continue 'dispatch;
	}
	// 827E7BF8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7BFC: 4800001C  b 0x827e7c18
	pc = 0x827E7C18; continue 'dispatch;
	// 827E7C00: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827E7C04: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7C0C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E7C10: 409A0008  bne cr6, 0x827e7c18
	if !ctx.cr[6].eq {
	pc = 0x827E7C18; continue 'dispatch;
	}
	// 827E7C14: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827E7C18: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C1C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 827E7C20: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 827E7C24: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 827E7C28: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7C2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7C30: 409A00F0  bne cr6, 0x827e7d20
	if !ctx.cr[6].eq {
	pc = 0x827E7D20; continue 'dispatch;
	}
	// 827E7C34: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 827E7C38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7C3C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C40: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7C44: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827E7C48: 409A0054  bne cr6, 0x827e7c9c
	if !ctx.cr[6].eq {
	pc = 0x827E7C9C; continue 'dispatch;
	}
	// 827E7C4C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7C50: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7C54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827E7C58: 419A0054  beq cr6, 0x827e7cac
	if ctx.cr[6].eq {
	pc = 0x827E7CAC; continue 'dispatch;
	}
	// 827E7C5C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7C60: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7C64: 409A0010  bne cr6, 0x827e7c74
	if !ctx.cr[6].eq {
	pc = 0x827E7C74; continue 'dispatch;
	}
	// 827E7C68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7C6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E7C70: 4BD47919  bl 0x8252f588
	ctx.lr = 0x827E7C74;
	sub_8252F588(ctx, base);
	// 827E7C74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7C7C: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7C80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C88: 9B6B001C  stb r27, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 827E7C8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C90: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7C94: 4BD4795D  bl 0x8252f5f0
	ctx.lr = 0x827E7C98;
	sub_8252F5F0(ctx, base);
	// 827E7C98: 48000074  b 0x827e7d0c
	pc = 0x827E7D0C; continue 'dispatch;
	// 827E7C9C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7CA0: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7CA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827E7CA8: 409A0028  bne cr6, 0x827e7cd0
	if !ctx.cr[6].eq {
	pc = 0x827E7CD0; continue 'dispatch;
	}
	// 827E7CAC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7CB0: 9BA9001C  stb r29, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7CB4: 9BAA001C  stb r29, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7CB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7CBC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7CC0: 9B6A001C  stb r27, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 827E7CC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7CC8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7CCC: 48000040  b 0x827e7d0c
	pc = 0x827E7D0C; continue 'dispatch;
	// 827E7CD0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7CD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7CD8: 409A0010  bne cr6, 0x827e7ce8
	if !ctx.cr[6].eq {
	pc = 0x827E7CE8; continue 'dispatch;
	}
	// 827E7CDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7CE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E7CE4: 4BD4790D  bl 0x8252f5f0
	ctx.lr = 0x827E7CE8;
	sub_8252F5F0(ctx, base);
	// 827E7CE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E7CF0: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7CF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7CF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7CFC: 9B6B001C  stb r27, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 827E7D00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7D04: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7D08: 4BD47881  bl 0x8252f588
	ctx.lr = 0x827E7D0C;
	sub_8252F588(ctx, base);
	// 827E7D0C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7D10: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E7D14: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7D18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7D1C: 419AFF1C  beq cr6, 0x827e7c38
	if ctx.cr[6].eq {
	pc = 0x827E7C38; continue 'dispatch;
	}
	// 827E7D20: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7D24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E7D28: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7D2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7D30: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7D34: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827E7D38: 489C0478  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E7D40 size=1028
    let mut pc: u32 = 0x827E7D40;
    'dispatch: loop {
        match pc {
            0x827E7D40 => {
    //   block [0x827E7D40..0x827E8144)
	// 827E7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E7D44: 489C0415  bl 0x831a8158
	ctx.lr = 0x827E7D48;
	sub_831A8130(ctx, base);
	// 827E7D48: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E7D4C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827E7D50: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827E7D54: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 827E7D58: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 827E7D5C: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7D64: 419A0048  beq cr6, 0x827e7dac
	if ctx.cr[6].eq {
	pc = 0x827E7DAC; continue 'dispatch;
	}
	// 827E7D68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E7D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E7D70: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 827E7D74: 4BADDB55  bl 0x822c58c8
	ctx.lr = 0x827E7D78;
	sub_822C58C8(ctx, base);
	// 827E7D78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E7D7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E7D80: 4BAE2131  bl 0x822c9eb0
	ctx.lr = 0x827E7D84;
	sub_822C9EB0(ctx, base);
	// 827E7D84: 4BADC52D  bl 0x822c42b0
	ctx.lr = 0x827E7D88;
	sub_822C42B0(ctx, base);
	// 827E7D88: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E7D8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E7D90: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 827E7D94: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827E7D98: 4BADD6D9  bl 0x822c5470
	ctx.lr = 0x827E7D9C;
	sub_822C5470(ctx, base);
	// 827E7D9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E7DA0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E7DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E7DA8: 4BADCF39  bl 0x822c4ce0
	ctx.lr = 0x827E7DAC;
	sub_822C4CE0(ctx, base);
	// 827E7DAC: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 827E7DB0: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 827E7DB4: 48072C05  bl 0x8285a9b8
	ctx.lr = 0x827E7DB8;
	sub_8285A9B8(ctx, base);
	// 827E7DB8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7DBC: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7DC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7DC4: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 827E7DC8: 419A000C  beq cr6, 0x827e7dd4
	if ctx.cr[6].eq {
	pc = 0x827E7DD4; continue 'dispatch;
	}
	// 827E7DCC: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7DD0: 48000028  b 0x827e7df8
	pc = 0x827E7DF8; continue 'dispatch;
	// 827E7DD4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7DD8: 894A001D  lbz r10, 0x1d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7DE0: 419A000C  beq cr6, 0x827e7dec
	if ctx.cr[6].eq {
	pc = 0x827E7DEC; continue 'dispatch;
	}
	// 827E7DE4: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 827E7DE8: 48000010  b 0x827e7df8
	pc = 0x827E7DF8; continue 'dispatch;
	// 827E7DEC: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7DF0: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7DF4: 409A00DC  bne cr6, 0x827e7ed0
	if !ctx.cr[6].eq {
	pc = 0x827E7ED0; continue 'dispatch;
	}
	// 827E7DF8: 897C001D  lbz r11, 0x1d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7DFC: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7E04: 409A0008  bne cr6, 0x827e7e0c
	if !ctx.cr[6].eq {
	pc = 0x827E7E0C; continue 'dispatch;
	}
	// 827E7E08: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827E7E0C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7E10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7E14: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7E18: 409A000C  bne cr6, 0x827e7e24
	if !ctx.cr[6].eq {
	pc = 0x827E7E24; continue 'dispatch;
	}
	// 827E7E1C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 827E7E20: 4800001C  b 0x827e7e3c
	pc = 0x827E7E3C; continue 'dispatch;
	// 827E7E24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7E28: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7E2C: 409A000C  bne cr6, 0x827e7e38
	if !ctx.cr[6].eq {
	pc = 0x827E7E38; continue 'dispatch;
	}
	// 827E7E30: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7E34: 48000008  b 0x827e7e3c
	pc = 0x827E7E3C; continue 'dispatch;
	// 827E7E38: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827E7E3C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7E40: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7E44: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7E48: 409A003C  bne cr6, 0x827e7e84
	if !ctx.cr[6].eq {
	pc = 0x827E7E84; continue 'dispatch;
	}
	// 827E7E4C: 897C001D  lbz r11, 0x1d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7E54: 419A000C  beq cr6, 0x827e7e60
	if ctx.cr[6].eq {
	pc = 0x827E7E60; continue 'dispatch;
	}
	// 827E7E58: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 827E7E5C: 48000024  b 0x827e7e80
	pc = 0x827E7E80; continue 'dispatch;
	// 827E7E60: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7E64: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 827E7E68: 4800000C  b 0x827e7e74
	pc = 0x827E7E74; continue 'dispatch;
	// 827E7E6C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827E7E70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7E74: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7E78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827E7E7C: 419AFFF0  beq cr6, 0x827e7e6c
	if ctx.cr[6].eq {
	pc = 0x827E7E6C; continue 'dispatch;
	}
	// 827E7E80: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E7E84: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7E88: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7E8C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7E90: 409A00D4  bne cr6, 0x827e7f64
	if !ctx.cr[6].eq {
	pc = 0x827E7F64; continue 'dispatch;
	}
	// 827E7E94: 897C001D  lbz r11, 0x1d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7E9C: 419A000C  beq cr6, 0x827e7ea8
	if ctx.cr[6].eq {
	pc = 0x827E7EA8; continue 'dispatch;
	}
	// 827E7EA0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 827E7EA4: 48000024  b 0x827e7ec8
	pc = 0x827E7EC8; continue 'dispatch;
	// 827E7EA8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7EAC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 827E7EB0: 4800000C  b 0x827e7ebc
	pc = 0x827E7EBC; continue 'dispatch;
	// 827E7EB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827E7EB8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7EBC: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7EC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827E7EC4: 419AFFF0  beq cr6, 0x827e7eb4
	if ctx.cr[6].eq {
	pc = 0x827E7EB4; continue 'dispatch;
	}
	// 827E7EC8: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E7ECC: 48000098  b 0x827e7f64
	pc = 0x827E7F64; continue 'dispatch;
	// 827E7ED0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 827E7ED4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7ED8: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E7EDC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7EE0: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7EE4: 409A000C  bne cr6, 0x827e7ef0
	if !ctx.cr[6].eq {
	pc = 0x827E7EF0; continue 'dispatch;
	}
	// 827E7EE8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 827E7EEC: 4800002C  b 0x827e7f18
	pc = 0x827E7F18; continue 'dispatch;
	// 827E7EF0: 897C001D  lbz r11, 0x1d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7EF4: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E7EFC: 409A0008  bne cr6, 0x827e7f04
	if !ctx.cr[6].eq {
	pc = 0x827E7F04; continue 'dispatch;
	}
	// 827E7F00: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827E7F04: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827E7F08: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7F0C: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E7F10: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7F14: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 827E7F18: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F20: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7F24: 409A000C  bne cr6, 0x827e7f30
	if !ctx.cr[6].eq {
	pc = 0x827E7F30; continue 'dispatch;
	}
	// 827E7F28: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 827E7F2C: 48000020  b 0x827e7f4c
	pc = 0x827E7F4C; continue 'dispatch;
	// 827E7F30: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7F38: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E7F3C: 409A000C  bne cr6, 0x827e7f48
	if !ctx.cr[6].eq {
	pc = 0x827E7F48; continue 'dispatch;
	}
	// 827E7F40: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 827E7F44: 48000008  b 0x827e7f4c
	pc = 0x827E7F4C; continue 'dispatch;
	// 827E7F48: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 827E7F4C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F50: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E7F54: 897B001C  lbz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7F58: 8959001C  lbz r10, 0x1c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7F5C: 9979001C  stb r11, 0x1c(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 827E7F60: 995B001C  stb r10, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 827E7F64: 897B001C  lbz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7F68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827E7F6C: 409A0198  bne cr6, 0x827e8104
	if !ctx.cr[6].eq {
	pc = 0x827E8104; continue 'dispatch;
	}
	// 827E7F70: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F74: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 827E7F78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E7F7C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7F80: 419A0180  beq cr6, 0x827e8100
	if ctx.cr[6].eq {
	pc = 0x827E8100; continue 'dispatch;
	}
	// 827E7F84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E7F88: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7F8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827E7F90: 409A0170  bne cr6, 0x827e8100
	if !ctx.cr[6].eq {
	pc = 0x827E8100; continue 'dispatch;
	}
	// 827E7F94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7F98: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E7F9C: 409A00A8  bne cr6, 0x827e8044
	if !ctx.cr[6].eq {
	pc = 0x827E8044; continue 'dispatch;
	}
	// 827E7FA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7FA4: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7FA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7FAC: 409A001C  bne cr6, 0x827e7fc8
	if !ctx.cr[6].eq {
	pc = 0x827E7FC8; continue 'dispatch;
	}
	// 827E7FB0: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E7FB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E7FB8: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E7FBC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E7FC0: 4BD475C9  bl 0x8252f588
	ctx.lr = 0x827E7FC4;
	sub_8252F588(ctx, base);
	// 827E7FC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7FC8: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E7FCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E7FD0: 409A00C8  bne cr6, 0x827e8098
	if !ctx.cr[6].eq {
	pc = 0x827E8098; continue 'dispatch;
	}
	// 827E7FD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E7FD8: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7FDC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E7FE0: 409A0014  bne cr6, 0x827e7ff4
	if !ctx.cr[6].eq {
	pc = 0x827E7FF4; continue 'dispatch;
	}
	// 827E7FE4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7FE8: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7FEC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E7FF0: 419A00A4  beq cr6, 0x827e8094
	if ctx.cr[6].eq {
	pc = 0x827E8094; continue 'dispatch;
	}
	// 827E7FF4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E7FF8: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E7FFC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E8000: 409A0020  bne cr6, 0x827e8020
	if !ctx.cr[6].eq {
	pc = 0x827E8020; continue 'dispatch;
	}
	// 827E8004: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8008: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E800C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E8010: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E8014: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E8018: 4BD475D9  bl 0x8252f5f0
	ctx.lr = 0x827E801C;
	sub_8252F5F0(ctx, base);
	// 827E801C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8020: 895F001C  lbz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E8024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E8028: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E802C: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 827E8030: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E8034: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8038: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E803C: 4BD4754D  bl 0x8252f588
	ctx.lr = 0x827E8040;
	sub_8252F588(ctx, base);
	// 827E8040: 480000C0  b 0x827e8100
	pc = 0x827E8100; continue 'dispatch;
	// 827E8044: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E8048: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E804C: 409A001C  bne cr6, 0x827e8068
	if !ctx.cr[6].eq {
	pc = 0x827E8068; continue 'dispatch;
	}
	// 827E8050: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E8054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E8058: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E805C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E8060: 4BD47591  bl 0x8252f5f0
	ctx.lr = 0x827E8064;
	sub_8252F5F0(ctx, base);
	// 827E8064: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8068: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E806C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E8070: 409A0028  bne cr6, 0x827e8098
	if !ctx.cr[6].eq {
	pc = 0x827E8098; continue 'dispatch;
	}
	// 827E8074: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8078: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E807C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E8080: 409A0034  bne cr6, 0x827e80b4
	if !ctx.cr[6].eq {
	pc = 0x827E80B4; continue 'dispatch;
	}
	// 827E8084: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8088: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E808C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E8090: 409A0024  bne cr6, 0x827e80b4
	if !ctx.cr[6].eq {
	pc = 0x827E80B4; continue 'dispatch;
	}
	// 827E8094: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E8098: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E809C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827E80A0: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E80A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E80A8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E80AC: 409AFEDC  bne cr6, 0x827e7f88
	if !ctx.cr[6].eq {
	pc = 0x827E7F88; continue 'dispatch;
	}
	// 827E80B0: 48000050  b 0x827e8100
	pc = 0x827E8100; continue 'dispatch;
	// 827E80B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E80B8: 894A001C  lbz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E80BC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827E80C0: 409A0020  bne cr6, 0x827e80e0
	if !ctx.cr[6].eq {
	pc = 0x827E80E0; continue 'dispatch;
	}
	// 827E80C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E80C8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827E80CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E80D0: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E80D4: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 827E80D8: 4BD474B1  bl 0x8252f588
	ctx.lr = 0x827E80DC;
	sub_8252F588(ctx, base);
	// 827E80DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E80E0: 895F001C  lbz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E80E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E80E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E80EC: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 827E80F0: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E80F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E80F8: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E80FC: 4BD474F5  bl 0x8252f5f0
	ctx.lr = 0x827E8100;
	sub_8252F5F0(ctx, base);
	// 827E8100: 9BDC001C  stb r30, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 827E8104: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E8108: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E810C: 4BFF4C3D  bl 0x827dcd48
	ctx.lr = 0x827E8110;
	sub_827DCD48(ctx, base);
	// 827E8110: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E8114: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E8118: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E811C: 4860A06D  bl 0x82df2188
	ctx.lr = 0x827E8120;
	sub_82DF2188(ctx, base);
	// 827E8120: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E8128: 419A000C  beq cr6, 0x827e8134
	if ctx.cr[6].eq {
	pc = 0x827E8134; continue 'dispatch;
	}
	// 827E812C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827E8130: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E8134: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 827E8138: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E813C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827E8140: 489C0068  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E8148 size=84
    let mut pc: u32 = 0x827E8148;
    'dispatch: loop {
        match pc {
            0x827E8148 => {
    //   block [0x827E8148..0x827E819C)
	// 827E8148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E814C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E8150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E8154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E8158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E815C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8160: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8164: 4BFFF94D  bl 0x827e7ab0
	ctx.lr = 0x827E8168;
	sub_827E7AB0(ctx, base);
	// 827E8168: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E816C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E8170: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E8174: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E8178: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E817C: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E8180: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8184: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E8188: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E818C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E8190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E8194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E8198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E81A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E81A0 size=312
    let mut pc: u32 = 0x827E81A0;
    'dispatch: loop {
        match pc {
            0x827E81A0 => {
    //   block [0x827E81A0..0x827E82D8)
	// 827E81A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E81A4: 489BFFBD  bl 0x831a8160
	ctx.lr = 0x827E81A8;
	sub_831A8130(ctx, base);
	// 827E81A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E81AC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827E81B0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 827E81B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E81B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 827E81BC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 827E81C0: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E81C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E81C8: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E81CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E81D0: 409A0058  bne cr6, 0x827e8228
	if !ctx.cr[6].eq {
	pc = 0x827E8228; continue 'dispatch;
	}
	// 827E81D4: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E81D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E81DC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827E81E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827E81E4: 41990020  bgt cr6, 0x827e8204
	if ctx.cr[6].gt {
	pc = 0x827E8204; continue 'dispatch;
	}
	// 827E81E8: 41980014  blt cr6, 0x827e81fc
	if ctx.cr[6].lt {
	pc = 0x827E81FC; continue 'dispatch;
	}
	// 827E81EC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E81F0: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E81F4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E81F8: 4198000C  blt cr6, 0x827e8204
	if ctx.cr[6].lt {
	pc = 0x827E8204; continue 'dispatch;
	}
	// 827E81FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827E8200: 48000008  b 0x827e8208
	pc = 0x827E8208; continue 'dispatch;
	// 827E8204: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 827E8208: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E820C: 4182000C  beq 0x827e8218
	if ctx.cr[0].eq {
	pc = 0x827E8218; continue 'dispatch;
	}
	// 827E8210: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8214: 48000008  b 0x827e821c
	pc = 0x827E821C; continue 'dispatch;
	// 827E8218: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E821C: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827E8220: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827E8224: 419AFFB4  beq cr6, 0x827e81d8
	if ctx.cr[6].eq {
	pc = 0x827E81D8; continue 'dispatch;
	}
	// 827E8228: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827E822C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E8230: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827E8234: 41820048  beq 0x827e827c
	if ctx.cr[0].eq {
	pc = 0x827E827C; continue 'dispatch;
	}
	// 827E8238: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E823C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E8240: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8244: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E8248: 409A002C  bne cr6, 0x827e8274
	if !ctx.cr[6].eq {
	pc = 0x827E8274; continue 'dispatch;
	}
	// 827E824C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827E8250: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E8254: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827E8258: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E825C: 4BFFF8BD  bl 0x827e7b18
	ctx.lr = 0x827E8260;
	sub_827E7B18(ctx, base);
	// 827E8260: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E8264: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 827E8268: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E826C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E8270: 4800005C  b 0x827e82cc
	pc = 0x827E82CC; continue 'dispatch;
	// 827E8274: 48072815  bl 0x8285aa88
	ctx.lr = 0x827E8278;
	sub_8285AA88(ctx, base);
	// 827E8278: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E827C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8280: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E8284: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E8288: 41990020  bgt cr6, 0x827e82a8
	if ctx.cr[6].gt {
	pc = 0x827E82A8; continue 'dispatch;
	}
	// 827E828C: 41980014  blt cr6, 0x827e82a0
	if ctx.cr[6].lt {
	pc = 0x827E82A0; continue 'dispatch;
	}
	// 827E8290: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8294: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E8298: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E829C: 4198000C  blt cr6, 0x827e82a8
	if ctx.cr[6].lt {
	pc = 0x827E82A8; continue 'dispatch;
	}
	// 827E82A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E82A4: 48000008  b 0x827e82ac
	pc = 0x827E82AC; continue 'dispatch;
	// 827E82A8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 827E82AC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E82B0: 41820010  beq 0x827e82c0
	if ctx.cr[0].eq {
	pc = 0x827E82C0; continue 'dispatch;
	}
	// 827E82B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E82B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E82BC: 4BFFFF94  b 0x827e8250
	pc = 0x827E8250; continue 'dispatch;
	// 827E82C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E82C4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E82C8: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 827E82CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E82D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827E82D4: 489BFEDC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E82D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E82D8 size=132
    let mut pc: u32 = 0x827E82D8;
    'dispatch: loop {
        match pc {
            0x827E82D8 => {
    //   block [0x827E82D8..0x827E835C)
	// 827E82D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E82DC: 489BFE8D  bl 0x831a8168
	ctx.lr = 0x827E82E0;
	sub_831A8130(ctx, base);
	// 827E82E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E82E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E82E8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 827E82EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E82F0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827E82F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E82F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E82FC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E8300: 409A0044  bne cr6, 0x827e8344
	if !ctx.cr[6].eq {
	pc = 0x827E8344; continue 'dispatch;
	}
	// 827E8304: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E8308: 409A003C  bne cr6, 0x827e8344
	if !ctx.cr[6].eq {
	pc = 0x827E8344; continue 'dispatch;
	}
	// 827E830C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E8310: 4BFFFE39  bl 0x827e8148
	ctx.lr = 0x827E8314;
	sub_827E8148(ctx, base);
	// 827E8314: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8318: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E831C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E8320: 48000030  b 0x827e8350
	pc = 0x827E8350; continue 'dispatch;
	// 827E8324: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 827E8328: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 827E832C: 4807268D  bl 0x8285a9b8
	ctx.lr = 0x827E8330;
	sub_8285A9B8(ctx, base);
	// 827E8330: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E8334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E8338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E833C: 4BFFFA05  bl 0x827e7d40
	ctx.lr = 0x827E8340;
	sub_827E7D40(ctx, base);
	// 827E8340: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827E8344: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E8348: 409AFFDC  bne cr6, 0x827e8324
	if !ctx.cr[6].eq {
	pc = 0x827E8324; continue 'dispatch;
	}
	// 827E834C: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 827E8350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E8354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E8358: 489BFE60  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E8360 size=128
    let mut pc: u32 = 0x827E8360;
    'dispatch: loop {
        match pc {
            0x827E8360 => {
    //   block [0x827E8360..0x827E83E0)
	// 827E8360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E8364: 489BFE09  bl 0x831a816c
	ctx.lr = 0x827E8368;
	sub_831A8130(ctx, base);
	// 827E8368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E836C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E8370: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E8374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E8378: 3BEBAC40  addi r31, r11, -0x53c0
	ctx.r[31].s64 = ctx.r[11].s64 + -21440;
	// 827E837C: 816AAC48  lwz r11, -0x53b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21432 as u32) ) } as u64;
	// 827E8380: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827E8384: 40820024  bne 0x827e83a8
	if !ctx.cr[0].eq {
	pc = 0x827E83A8; continue 'dispatch;
	}
	// 827E8388: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 827E838C: 3D00827E  lis r8, -0x7d82
	ctx.r[8].s64 = -2105671680;
	// 827E8390: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827E8394: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 827E8398: 39087238  addi r8, r8, 0x7238
	ctx.r[8].s64 = ctx.r[8].s64 + 29240;
	// 827E839C: 916AAC48  stw r11, -0x53b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21432 as u32), ctx.r[11].u32 ) };
	// 827E83A0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E83A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827E83A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E83AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E83B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E83B4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 827E83B8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827E83BC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E83C0: 4BDEA561  bl 0x825d2920
	ctx.lr = 0x827E83C4;
	sub_825D2920(ctx, base);
	// 827E83C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E83C8: 4182000C  beq 0x827e83d4
	if ctx.cr[0].eq {
	pc = 0x827E83D4; continue 'dispatch;
	}
	// 827E83CC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E83D0: 48000008  b 0x827e83d8
	pc = 0x827E83D8; continue 'dispatch;
	// 827E83D4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827E83D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E83DC: 489BFDE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E83E0 size=128
    let mut pc: u32 = 0x827E83E0;
    'dispatch: loop {
        match pc {
            0x827E83E0 => {
    //   block [0x827E83E0..0x827E8460)
	// 827E83E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E83E4: 489BFD89  bl 0x831a816c
	ctx.lr = 0x827E83E8;
	sub_831A8130(ctx, base);
	// 827E83E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E83EC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E83F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E83F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E83F8: 3BEBAC4C  addi r31, r11, -0x53b4
	ctx.r[31].s64 = ctx.r[11].s64 + -21428;
	// 827E83FC: 816AAC54  lwz r11, -0x53ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21420 as u32) ) } as u64;
	// 827E8400: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827E8404: 40820024  bne 0x827e8428
	if !ctx.cr[0].eq {
	pc = 0x827E8428; continue 'dispatch;
	}
	// 827E8408: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 827E840C: 3D00827E  lis r8, -0x7d82
	ctx.r[8].s64 = -2105671680;
	// 827E8410: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827E8414: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 827E8418: 39087280  addi r8, r8, 0x7280
	ctx.r[8].s64 = ctx.r[8].s64 + 29312;
	// 827E841C: 916AAC54  stw r11, -0x53ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21420 as u32), ctx.r[11].u32 ) };
	// 827E8420: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E8424: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827E8428: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E842C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E8430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E8434: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 827E8438: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827E843C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E8440: 4BDEA4E1  bl 0x825d2920
	ctx.lr = 0x827E8444;
	sub_825D2920(ctx, base);
	// 827E8444: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E8448: 4182000C  beq 0x827e8454
	if ctx.cr[0].eq {
	pc = 0x827E8454; continue 'dispatch;
	}
	// 827E844C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E8450: 48000008  b 0x827e8458
	pc = 0x827E8458; continue 'dispatch;
	// 827E8454: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827E8458: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E845C: 489BFD60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E8460 size=552
    let mut pc: u32 = 0x827E8460;
    'dispatch: loop {
        match pc {
            0x827E8460 => {
    //   block [0x827E8460..0x827E8688)
	// 827E8460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E8464: 489BFCFD  bl 0x831a8160
	ctx.lr = 0x827E8468;
	sub_831A8130(ctx, base);
	// 827E8468: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E846C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827E8470: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E8474: 93610124  stw r27, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[27].u32 ) };
	// 827E8478: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E847C: 3B9D00A4  addi r28, r29, 0xa4
	ctx.r[28].s64 = ctx.r[29].s64 + 164;
	// 827E8480: 38A10124  addi r5, r1, 0x124
	ctx.r[5].s64 = ctx.r[1].s64 + 292;
	// 827E8484: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E8488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E848C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827E8490: 48136A39  bl 0x8291eec8
	ctx.lr = 0x827E8494;
	sub_8291EEC8(ctx, base);
	// 827E8494: 817D00A8  lwz r11, 0xa8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 827E8498: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E849C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827E84A0: 409A01A4  bne cr6, 0x827e8644
	if !ctx.cr[6].eq {
	pc = 0x827E8644; continue 'dispatch;
	}
	// 827E84A4: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 827E84A8: 4BAD8491  bl 0x822c0938
	ctx.lr = 0x827E84AC;
	sub_822C0938(ctx, base);
	// 827E84AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E84B0: 41820068  beq 0x827e8518
	if ctx.cr[0].eq {
	pc = 0x827E8518; continue 'dispatch;
	}
	// 827E84B4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 827E84B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E84BC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 827E84C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E84C4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E84C8: C1AB6218  lfs f13, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E84CC: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E84D0: C18989AC  lfs f12, -0x7654(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E84D4: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 827E84D8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 827E84DC: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 827E84E0: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 827E84E4: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 827E84E8: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 827E84EC: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 827E84F0: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 827E84F4: 48611135  bl 0x82df9628
	ctx.lr = 0x827E84F8;
	sub_82DF9628(ctx, base);
	// 827E84F8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E84FC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 827E8500: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 827E8504: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E8508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E850C: 488DFC5D  bl 0x830c8168
	ctx.lr = 0x827E8510;
	sub_830C8168(ctx, base);
	// 827E8510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E8514: 48000008  b 0x827e851c
	pc = 0x827E851C; continue 'dispatch;
	// 827E8518: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E851C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E8520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E8524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E8528: 4BAE1111  bl 0x822c9638
	ctx.lr = 0x827E852C;
	sub_822C9638(ctx, base);
	// 827E852C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827E8530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E8534: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E8538: 4BAD7AC9  bl 0x822c0000
	ctx.lr = 0x827E853C;
	sub_822C0000(ctx, base);
	// 827E853C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E8540: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E8544: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E8548: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E854C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E8550: 419A0024  beq cr6, 0x827e8574
	if ctx.cr[6].eq {
	pc = 0x827E8574; continue 'dispatch;
	}
	// 827E8554: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E8558: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E855C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8560: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E8564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E8568: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E856C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8570: 4082FFE8  bne 0x827e8558
	if !ctx.cr[0].eq {
	pc = 0x827E8558; continue 'dispatch;
	}
	// 827E8574: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827E8578: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827E857C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827E8580: 4BCA4691  bl 0x8248cc10
	ctx.lr = 0x827E8584;
	sub_8248CC10(ctx, base);
	// 827E8584: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8588: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E858C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E8590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E8594: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827E8598: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E859C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 827E85A0: 419A0024  beq cr6, 0x827e85c4
	if ctx.cr[6].eq {
	pc = 0x827E85C4; continue 'dispatch;
	}
	// 827E85A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E85A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E85AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E85B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E85B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E85B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E85BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E85C0: 4082FFE8  bne 0x827e85a8
	if !ctx.cr[0].eq {
	pc = 0x827E85A8; continue 'dispatch;
	}
	// 827E85C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827E85C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E85CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E85D0: 4BFE7911  bl 0x827cfee0
	ctx.lr = 0x827E85D4;
	sub_827CFEE0(ctx, base);
	// 827E85D4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827E85D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E85DC: 419A0008  beq cr6, 0x827e85e4
	if ctx.cr[6].eq {
	pc = 0x827E85E4; continue 'dispatch;
	}
	// 827E85E0: 4BAD82B1  bl 0x822c0890
	ctx.lr = 0x827E85E4;
	sub_822C0890(ctx, base);
	// 827E85E4: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827E85E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E85EC: 419A0008  beq cr6, 0x827e85f4
	if ctx.cr[6].eq {
	pc = 0x827E85F4; continue 'dispatch;
	}
	// 827E85F0: 4BAD82A1  bl 0x822c0890
	ctx.lr = 0x827E85F4;
	sub_822C0890(ctx, base);
	// 827E85F4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E85F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E85FC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827E8600: 419A0024  beq cr6, 0x827e8624
	if ctx.cr[6].eq {
	pc = 0x827E8624; continue 'dispatch;
	}
	// 827E8604: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E8608: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E860C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8610: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E8614: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E8618: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E861C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8620: 4082FFE8  bne 0x827e8608
	if !ctx.cr[0].eq {
	pc = 0x827E8608; continue 'dispatch;
	}
	// 827E8624: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E8628: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E862C: 488DB2ED  bl 0x830c3918
	ctx.lr = 0x827E8630;
	sub_830C3918(ctx, base);
	// 827E8630: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E8634: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E8638: 419A000C  beq cr6, 0x827e8644
	if ctx.cr[6].eq {
	pc = 0x827E8644; continue 'dispatch;
	}
	// 827E863C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E8640: 4BAD8251  bl 0x822c0890
	ctx.lr = 0x827E8644;
	sub_822C0890(ctx, base);
	// 827E8644: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E8648: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E864C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E8650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E8654: 917A0004  stw r11, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E8658: 419A0024  beq cr6, 0x827e867c
	if ctx.cr[6].eq {
	pc = 0x827E867C; continue 'dispatch;
	}
	// 827E865C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E8660: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E8664: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8668: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E866C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E8670: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E8674: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E8678: 4082FFE8  bne 0x827e8660
	if !ctx.cr[0].eq {
	pc = 0x827E8660; continue 'dispatch;
	}
	// 827E867C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827E8680: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 827E8684: 489BFB2C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E8688 size=88
    let mut pc: u32 = 0x827E8688;
    'dispatch: loop {
        match pc {
            0x827E8688 => {
    //   block [0x827E8688..0x827E86E0)
	// 827E8688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E868C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E8690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E8694: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E8698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E869C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E86A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E86A4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E86A8: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E86AC: 4BFFFC2D  bl 0x827e82d8
	ctx.lr = 0x827E86B0;
	sub_827E82D8(ctx, base);
	// 827E86B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E86B4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E86B8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 827E86BC: 48609ACD  bl 0x82df2188
	ctx.lr = 0x827E86C0;
	sub_82DF2188(ctx, base);
	// 827E86C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E86C4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827E86C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E86CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E86D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E86D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E86D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E86DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E86E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E86E0 size=128
    let mut pc: u32 = 0x827E86E0;
    'dispatch: loop {
        match pc {
            0x827E86E0 => {
    //   block [0x827E86E0..0x827E8760)
	// 827E86E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E86E4: 489BFA89  bl 0x831a816c
	ctx.lr = 0x827E86E8;
	sub_831A8130(ctx, base);
	// 827E86E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E86EC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E86F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E86F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E86F8: 3BEBAC58  addi r31, r11, -0x53a8
	ctx.r[31].s64 = ctx.r[11].s64 + -21416;
	// 827E86FC: 816AAC60  lwz r11, -0x53a0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21408 as u32) ) } as u64;
	// 827E8700: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827E8704: 40820024  bne 0x827e8728
	if !ctx.cr[0].eq {
	pc = 0x827E8728; continue 'dispatch;
	}
	// 827E8708: 3D20827E  lis r9, -0x7d82
	ctx.r[9].s64 = -2105671680;
	// 827E870C: 3D00827E  lis r8, -0x7d82
	ctx.r[8].s64 = -2105671680;
	// 827E8710: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827E8714: 39297A40  addi r9, r9, 0x7a40
	ctx.r[9].s64 = ctx.r[9].s64 + 31296;
	// 827E8718: 390871F0  addi r8, r8, 0x71f0
	ctx.r[8].s64 = ctx.r[8].s64 + 29168;
	// 827E871C: 916AAC60  stw r11, -0x53a0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21408 as u32), ctx.r[11].u32 ) };
	// 827E8720: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E8724: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827E8728: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E872C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E8730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E8734: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 827E8738: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827E873C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E8740: 4BDEA1E1  bl 0x825d2920
	ctx.lr = 0x827E8744;
	sub_825D2920(ctx, base);
	// 827E8744: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E8748: 4182000C  beq 0x827e8754
	if ctx.cr[0].eq {
	pc = 0x827E8754; continue 'dispatch;
	}
	// 827E874C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827E8750: 48000008  b 0x827e8758
	pc = 0x827E8758; continue 'dispatch;
	// 827E8754: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827E8758: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E875C: 489BFA60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E8760 size=80
    let mut pc: u32 = 0x827E8760;
    'dispatch: loop {
        match pc {
            0x827E8760 => {
    //   block [0x827E8760..0x827E87B0)
	// 827E8760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E8764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E8768: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 827E876C: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 827E8770: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 827E8774: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 827E8778: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 827E877C: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 827E8780: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E8784: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827E8788: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 827E878C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 827E8790: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 827E8794: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E8798: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E879C: 489C4135  bl 0x831ac8d0
	ctx.lr = 0x827E87A0;
	sub_831AC8D0(ctx, base);
	// 827E87A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E87A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E87A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E87AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E87B0 size=156
    let mut pc: u32 = 0x827E87B0;
    'dispatch: loop {
        match pc {
            0x827E87B0 => {
    //   block [0x827E87B0..0x827E884C)
	// 827E87B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E87B4: 489BF9B5  bl 0x831a8168
	ctx.lr = 0x827E87B8;
	sub_831A8130(ctx, base);
	// 827E87B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E87BC: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 827E87C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E87C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E87C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E87CC: 83CB00DC  lwz r30, 0xdc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 827E87D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E87D4: 48612185  bl 0x82dfa958
	ctx.lr = 0x827E87D8;
	sub_82DFA958(ctx, base);
	// 827E87D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E87DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E87E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E87E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E87E8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E87EC: 486121CD  bl 0x82dfa9b8
	ctx.lr = 0x827E87F0;
	sub_82DFA9B8(ctx, base);
	// 827E87F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E87F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E87F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E87FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E8800: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E8804: 486121B5  bl 0x82dfa9b8
	ctx.lr = 0x827E8808;
	sub_82DFA9B8(ctx, base);
	// 827E8808: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E880C: 48000020  b 0x827e882c
	pc = 0x827E882C; continue 'dispatch;
	// 827E8810: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E8814: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E881C: 4861213D  bl 0x82dfa958
	ctx.lr = 0x827E8820;
	sub_82DFA958(ctx, base);
	// 827E8820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8824: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827E8828: 7FABE850  subf r29, r11, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 827E882C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827E8830: 409AFFE0  bne cr6, 0x827e8810
	if !ctx.cr[6].eq {
	pc = 0x827E8810; continue 'dispatch;
	}
	// 827E8834: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E8838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E883C: 41980008  blt cr6, 0x827e8844
	if ctx.cr[6].lt {
	pc = 0x827E8844; continue 'dispatch;
	}
	// 827E8840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E8844: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827E8848: 489BF970  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E8850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E8850 size=2032
    let mut pc: u32 = 0x827E8850;
    'dispatch: loop {
        match pc {
            0x827E8850 => {
    //   block [0x827E8850..0x827E9040)
	// 827E8850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E8854: 489BF8FD  bl 0x831a8150
	ctx.lr = 0x827E8858;
	sub_831A8130(ctx, base);
	// 827E8858: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 827E885C: 489C0209  bl 0x831a8a64
	ctx.lr = 0x827E8860;
	sub_831A8A40(ctx, base);
	// 827E8860: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E8864: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E8868: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827E886C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E8870: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 827E8874: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827E8878: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E887C: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E8880: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 827E8884: 419807AC  blt cr6, 0x827e9030
	if ctx.cr[6].lt {
	pc = 0x827E9030; continue 'dispatch;
	}
	// 827E8888: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E888C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E8890: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 827E8894: 4199079C  bgt cr6, 0x827e9030
	if ctx.cr[6].gt {
	pc = 0x827E9030; continue 'dispatch;
	}
	// 827E8898: 48820C41  bl 0x830094d8
	ctx.lr = 0x827E889C;
	sub_830094D8(ctx, base);
	// 827E889C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 827E88A0: 41820790  beq 0x827e9030
	if ctx.cr[0].eq {
	pc = 0x827E9030; continue 'dispatch;
	}
	// 827E88A4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E88A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E88AC: 83A40068  lwz r29, 0x68(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) } as u64;
	// 827E88B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827E88B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E88B8: 4E800421  bctrl
	ctx.lr = 0x827E88BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E88BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E88C0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 827E88C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E88C8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827E88CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E88D0: 4E800421  bctrl
	ctx.lr = 0x827E88D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E88D4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 827E88D8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 827E88DC: C00100E0  lfs f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E88E0: C1A100E4  lfs f13, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E88E4: 893F0034  lbz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 827E88E8: C1810074  lfs f12, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E88EC: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 827E88F0: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E88F4: ED8C682A  fadds f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 827E88F8: C141007C  lfs f10, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E88FC: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E8900: C1210078  lfs f9, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 827E8904: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827E8908: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 827E890C: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E8910: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E8914: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E8918: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E891C: 9B810058  stb r28, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 827E8920: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E8924: 3ADF003C  addi r22, r31, 0x3c
	ctx.r[22].s64 = ctx.r[31].s64 + 60;
	// 827E8928: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E892C: 82EB00DC  lwz r23, 0xdc(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 827E8930: C3DE0004  lfs f30, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827E8934: 41820030  beq 0x827e8964
	if ctx.cr[0].eq {
	pc = 0x827E8964; continue 'dispatch;
	}
	// 827E8938: 896B00D9  lbz r11, 0xd9(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(217 as u32) ) } as u64;
	// 827E893C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E8940: 40820024  bne 0x827e8964
	if !ctx.cr[0].eq {
	pc = 0x827E8964; continue 'dispatch;
	}
	// 827E8944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E8948: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 827E894C: 3B3F0040  addi r25, r31, 0x40
	ctx.r[25].s64 = ctx.r[31].s64 + 64;
	// 827E8950: 4BFFFE61  bl 0x827e87b0
	ctx.lr = 0x827E8954;
	sub_827E87B0(ctx, base);
	// 827E8954: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 827E8958: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 827E895C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E8960: 48000024  b 0x827e8984
	pc = 0x827E8984; continue 'dispatch;
	// 827E8964: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E8968: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 827E896C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827E8970: 3B3F0040  addi r25, r31, 0x40
	ctx.r[25].s64 = ctx.r[31].s64 + 64;
	// 827E8974: 48611FE5  bl 0x82dfa958
	ctx.lr = 0x827E8978;
	sub_82DFA958(ctx, base);
	// 827E8978: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E897C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 827E8980: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E8984: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 827E8988: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827E898C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8990: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 827E8994: 396B08A0  addi r11, r11, 0x8a0
	ctx.r[11].s64 = ctx.r[11].s64 + 2208;
	// 827E8998: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E899C: 80FB000C  lwz r7, 0xc(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E89A0: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827E89A4: C30B0000  lfs f24, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 827E89A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E89AC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827E89B0: 3BABC1EC  addi r29, r11, -0x3e14
	ctx.r[29].s64 = ctx.r[11].s64 + -15892;
	// 827E89B4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E89B8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 827E89BC: 90E8000C  stw r7, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 827E89C0: 91680008  stw r11, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827E89C4: C1A100B8  lfs f13, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E89C8: EF400632  fmuls f26, f0, f24
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 827E89CC: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E89D0: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 827E89D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 827E89D8: 41980008  blt cr6, 0x827e89e0
	if ctx.cr[6].lt {
	pc = 0x827E89E0; continue 'dispatch;
	}
	// 827E89DC: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 827E89E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E89E4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827E89E8: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 827E89EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E89F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E89F4: 488DC59D  bl 0x830c4f90
	ctx.lr = 0x827E89F8;
	sub_830C4F90(ctx, base);
	// 827E89F8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 827E89FC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E8A00: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8A04: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 827E8A08: EFE0D82A  fadds f31, f0, f27
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 827E8A0C: 3B0B5B4C  addi r24, r11, 0x5b4c
	ctx.r[24].s64 = ctx.r[11].s64 + 23372;
	// 827E8A10: C32ADD6C  lfs f25, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 827E8A14: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827E8A18: EFBA0672  fmuls f29, f26, f25
	ctx.f[29].f64 = (((ctx.f[26].f64 * ctx.f[25].f64) as f32) as f64);
	// 827E8A1C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 827E8A20: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 827E8A24: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 827E8A28: 4BFFFD39  bl 0x827e8760
	ctx.lr = 0x827E8A2C;
	sub_827E8760(ctx, base);
	// 827E8A2C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 827E8A30: 4BAE02E9  bl 0x822c8d18
	ctx.lr = 0x827E8A34;
	sub_822C8D18(ctx, base);
	// 827E8A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E8A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E8A3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 827E8A40: 409A0008  bne cr6, 0x827e8a48
	if !ctx.cr[6].eq {
	pc = 0x827E8A48; continue 'dispatch;
	}
	// 827E8A44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E8A48: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 827E8A4C: C07A0000  lfs f3, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 827E8A50: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 827E8A54: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 827E8A58: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827E8A5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827E8A60: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827E8A64: 488D6FD5  bl 0x830bfa38
	ctx.lr = 0x827E8A68;
	sub_830BFA38(ctx, base);
	// 827E8A68: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 827E8A6C: 48609225  bl 0x82df1c90
	ctx.lr = 0x827E8A70;
	sub_82DF1C90(ctx, base);
	// 827E8A70: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 827E8A74: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8A78: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827E8A7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827E8A80: C1610078  lfs f11, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E8A84: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E8A88: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 827E8A8C: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E8A90: C00A5778  lfs f0, 0x5778(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8A94: EEEB6828  fsubs f23, f11, f13
	ctx.f[23].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 827E8A98: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E8A9C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 827E8AA0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 827E8AA4: EF8C0032  fmuls f28, f12, f0
	ctx.f[28].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 827E8AA8: 4BAE5BD1  bl 0x822ce678
	ctx.lr = 0x827E8AAC;
	sub_822CE678(ctx, base);
	// 827E8AAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E8AB0: C1BA0000  lfs f13, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E8AB4: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 827E8AB8: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8ABC: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E8AC0: 488E07D9  bl 0x830c9298
	ctx.lr = 0x827E8AC4;
	sub_830C9298(ctx, base);
	// 827E8AC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827E8AC8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 827E8ACC: 488E079D  bl 0x830c9268
	ctx.lr = 0x827E8AD0;
	sub_830C9268(ctx, base);
	// 827E8AD0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E8AD4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E8AD8: C1810074  lfs f12, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E8ADC: 3BCBC1E0  addi r30, r11, -0x3e20
	ctx.r[30].s64 = ctx.r[11].s64 + -15904;
	// 827E8AE0: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 827E8AE4: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 827E8AE8: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 827E8AEC: C00A9C28  lfs f0, -0x63d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8AF0: EDBE002A  fadds f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 827E8AF4: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 827E8AF8: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8AFC: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 827E8B00: EC00FDFA  fmadds f0, f0, f23, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64 + ctx.f[31].f64) as f32) as f64);
	// 827E8B04: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 827E8B08: 41990008  bgt cr6, 0x827e8b10
	if ctx.cr[6].gt {
	pc = 0x827E8B10; continue 'dispatch;
	}
	// 827E8B0C: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 827E8B10: C001007C  lfs f0, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E8B14: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 827E8B18: 41980008  blt cr6, 0x827e8b20
	if ctx.cr[6].lt {
	pc = 0x827E8B20; continue 'dispatch;
	}
	// 827E8B1C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 827E8B20: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E8B24: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 827E8B28: 488E06D9  bl 0x830c9200
	ctx.lr = 0x827E8B2C;
	sub_830C9200(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E9040 size=96
    let mut pc: u32 = 0x827E9040;
    'dispatch: loop {
        match pc {
            0x827E9040 => {
    //   block [0x827E9040..0x827E90A0)
	// 827E9040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E9048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E904C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E9050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E9058: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E905C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E9060: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E9064: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 827E9068: 4BADFDC9  bl 0x822c8e30
	ctx.lr = 0x827E906C;
	sub_822C8E30(ctx, base);
	// 827E906C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 827E9070: 4BAE1581  bl 0x822ca5f0
	ctx.lr = 0x827E9074;
	sub_822CA5F0(ctx, base);
	// 827E9074: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E9078: 4182000C  beq 0x827e9084
	if ctx.cr[0].eq {
	pc = 0x827E9084; continue 'dispatch;
	}
	// 827E907C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9080: 4BAD71E9  bl 0x822c0268
	ctx.lr = 0x827E9084;
	sub_822C0268(ctx, base);
	// 827E9084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E908C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E9090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E9094: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E9098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E909C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E90A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E90A0 size=184
    let mut pc: u32 = 0x827E90A0;
    'dispatch: loop {
        match pc {
            0x827E90A0 => {
    //   block [0x827E90A0..0x827E9158)
	// 827E90A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E90A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E90A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E90AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E90B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E90B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E90B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E90BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827E90C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827E90C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E90C8: 4BAD7871  bl 0x822c0938
	ctx.lr = 0x827E90CC;
	sub_822C0938(ctx, base);
	// 827E90CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E90D0: 41820028  beq 0x827e90f8
	if ctx.cr[0].eq {
	pc = 0x827E90F8; continue 'dispatch;
	}
	// 827E90D4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E90D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 827E90DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827E90E0: 392B5B30  addi r9, r11, 0x5b30
	ctx.r[9].s64 = ctx.r[11].s64 + 23344;
	// 827E90E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E90E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827E90EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827E90F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827E90F4: 48000008  b 0x827e90fc
	pc = 0x827E90FC; continue 'dispatch;
	// 827E90F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827E90FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E9100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9104: 409A0038  bne cr6, 0x827e913c
	if !ctx.cr[6].eq {
	pc = 0x827E913C; continue 'dispatch;
	}
	// 827E9108: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E910C: 419A0010  beq cr6, 0x827e911c
	if ctx.cr[6].eq {
	pc = 0x827E911C; continue 'dispatch;
	}
	// 827E9110: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E9114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9118: 4BFFFF29  bl 0x827e9040
	ctx.lr = 0x827E911C;
	sub_827E9040(ctx, base);
	// 827E911C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E9120: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E9124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E9128: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 827E912C: 816BC1E8  lwz r11, -0x3e18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15896 as u32) ) } as u64;
	// 827E9130: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E9134: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E9138: 4BAD6EC9  bl 0x822c0000
	ctx.lr = 0x827E913C;
	sub_822C0000(ctx, base);
	// 827E913C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E9140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E9144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E9148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E914C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E9150: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E9154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E9158 size=12
    let mut pc: u32 = 0x827E9158;
    'dispatch: loop {
        match pc {
            0x827E9158 => {
    //   block [0x827E9158..0x827E9164)
	// 827E9158: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827E915C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9160: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9164(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E9164 size=8
    let mut pc: u32 = 0x827E9164;
    'dispatch: loop {
        match pc {
            0x827E9164 => {
    //   block [0x827E9164..0x827E916C)
	// 827E9164: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E9168: 4BFFFED8  b 0x827e9040
	sub_827E9040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E916C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827E916C size=4
    let mut pc: u32 = 0x827E916C;
    'dispatch: loop {
        match pc {
            0x827E916C => {
    //   block [0x827E916C..0x827E9170)
	// 827E916C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E9170 size=112
    let mut pc: u32 = 0x827E9170;
    'dispatch: loop {
        match pc {
            0x827E9170 => {
    //   block [0x827E9170..0x827E91E0)
	// 827E9170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E9178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E917C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E9180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E9188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E918C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827E9190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9194: 4BFFFF0D  bl 0x827e90a0
	ctx.lr = 0x827E9198;
	sub_827E90A0(ctx, base);
	// 827E9198: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827E919C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E91A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E91A4: 4BAD6E5D  bl 0x822c0000
	ctx.lr = 0x827E91A8;
	sub_822C0000(ctx, base);
	// 827E91A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E91AC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E91B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E91B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E91B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E91BC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827E91C0: 419A0008  beq cr6, 0x827e91c8
	if ctx.cr[6].eq {
	pc = 0x827E91C8; continue 'dispatch;
	}
	// 827E91C4: 4BAD76CD  bl 0x822c0890
	ctx.lr = 0x827E91C8;
	sub_822C0890(ctx, base);
	// 827E91C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E91CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E91D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E91D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E91D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E91DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E91E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E91E0 size=1192
    let mut pc: u32 = 0x827E91E0;
    'dispatch: loop {
        match pc {
            0x827E91E0 => {
    //   block [0x827E91E0..0x827E9688)
	// 827E91E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E91E4: 489BEF6D  bl 0x831a8150
	ctx.lr = 0x827E91E8;
	sub_831A8130(ctx, base);
	// 827E91E8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E91EC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827E91F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827E91F4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827E91F8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 827E91FC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 827E9200: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 827E9204: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 827E9208: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E920C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 827E9210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9214: 419A0044  beq cr6, 0x827e9258
	if ctx.cr[6].eq {
	pc = 0x827E9258; continue 'dispatch;
	}
	// 827E9218: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E921C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9220: 419A0024  beq cr6, 0x827e9244
	if ctx.cr[6].eq {
	pc = 0x827E9244; continue 'dispatch;
	}
	// 827E9224: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 827E9228: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827E922C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9230: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827E9234: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827E9238: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E923C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9240: 4082FFE8  bne 0x827e9228
	if !ctx.cr[0].eq {
	pc = 0x827E9228; continue 'dispatch;
	}
	// 827E9244: 83CB0040  lwz r30, 0x40(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 827E9248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E924C: 419A0010  beq cr6, 0x827e925c
	if ctx.cr[6].eq {
	pc = 0x827E925C; continue 'dispatch;
	}
	// 827E9250: 4BAD7641  bl 0x822c0890
	ctx.lr = 0x827E9254;
	sub_822C0890(ctx, base);
	// 827E9254: 48000008  b 0x827e925c
	pc = 0x827E925C; continue 'dispatch;
	// 827E9258: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 827E925C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9260: 3B9800C4  addi r28, r24, 0xc4
	ctx.r[28].s64 = ctx.r[24].s64 + 196;
	// 827E9264: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9268: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827E926C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E9270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E9274: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 827E9278: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 827E927C: 4BFFE375  bl 0x827e75f0
	ctx.lr = 0x827E9280;
	sub_827E75F0(ctx, base);
	// 827E9280: 815800C8  lwz r10, 0xc8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(200 as u32) ) } as u64;
	// 827E9284: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E9288: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827E928C: 409A0188  bne cr6, 0x827e9414
	if !ctx.cr[6].eq {
	pc = 0x827E9414; continue 'dispatch;
	}
	// 827E9290: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E9294: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827E9298: 388B5B58  addi r4, r11, 0x5b58
	ctx.r[4].s64 = ctx.r[11].s64 + 23384;
	// 827E929C: 38A00207  li r5, 0x207
	ctx.r[5].s64 = 519;
	// 827E92A0: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 827E92A4: 4BAD7135  bl 0x822c03d8
	ctx.lr = 0x827E92A8;
	sub_822C03D8(ctx, base);
	// 827E92A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827E92AC: 41820044  beq 0x827e92f0
	if ctx.cr[0].eq {
	pc = 0x827E92F0; continue 'dispatch;
	}
	// 827E92B0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E92B4: 48611855  bl 0x82dfab08
	ctx.lr = 0x827E92B8;
	sub_82DFAB08(ctx, base);
	// 827E92B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E92BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827E92C0: 4BAE0B99  bl 0x822c9e58
	ctx.lr = 0x827E92C4;
	sub_822C9E58(ctx, base);
	// 827E92C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E92C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E92CC: 4BAE137D  bl 0x822ca648
	ctx.lr = 0x827E92D0;
	sub_822CA648(ctx, base);
	// 827E92D0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E92D4: 931F003C  stw r24, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[24].u32 ) };
	// 827E92D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E92DC: 396B5B44  addi r11, r11, 0x5b44
	ctx.r[11].s64 = ctx.r[11].s64 + 23364;
	// 827E92E0: 933F0040  stw r25, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	// 827E92E4: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 827E92E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E92EC: 48000008  b 0x827e92f4
	pc = 0x827E92F4; continue 'dispatch;
	// 827E92F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E92F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E92F8: 4BFFFE79  bl 0x827e9170
	ctx.lr = 0x827E92FC;
	sub_827E9170(ctx, base);
	// 827E92FC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9304: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E9308: 83410060  lwz r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E930C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827E9310: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 827E9314: 419A003C  beq cr6, 0x827e9350
	if ctx.cr[6].eq {
	pc = 0x827E9350; continue 'dispatch;
	}
	// 827E9318: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E931C: 419A0024  beq cr6, 0x827e9340
	if ctx.cr[6].eq {
	pc = 0x827E9340; continue 'dispatch;
	}
	// 827E9320: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E9324: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9328: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E932C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9330: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9334: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9338: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E933C: 4082FFE8  bne 0x827e9324
	if !ctx.cr[0].eq {
	pc = 0x827E9324; continue 'dispatch;
	}
	// 827E9340: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E9344: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9348: 488DCBB9  bl 0x830c5f00
	ctx.lr = 0x827E934C;
	sub_830C5F00(ctx, base);
	// 827E934C: 48000038  b 0x827e9384
	pc = 0x827E9384; continue 'dispatch;
	// 827E9350: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E9354: 419A0024  beq cr6, 0x827e9378
	if ctx.cr[6].eq {
	pc = 0x827E9378; continue 'dispatch;
	}
	// 827E9358: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E935C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E936C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9374: 4082FFE8  bne 0x827e935c
	if !ctx.cr[0].eq {
	pc = 0x827E935C; continue 'dispatch;
	}
	// 827E9378: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E937C: 807800B4  lwz r3, 0xb4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E9380: 488DCC69  bl 0x830c5fe8
	ctx.lr = 0x827E9384;
	sub_830C5FE8(ctx, base);
	// 827E9384: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 827E9388: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E938C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827E9390: 419A0024  beq cr6, 0x827e93b4
	if ctx.cr[6].eq {
	pc = 0x827E93B4; continue 'dispatch;
	}
	// 827E9394: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E9398: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E939C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E93A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E93A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E93A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E93AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E93B0: 4082FFE8  bne 0x827e9398
	if !ctx.cr[0].eq {
	pc = 0x827E9398; continue 'dispatch;
	}
	// 827E93B4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E93B8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827E93BC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E93C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827E93C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827E93C8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 827E93CC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827E93D0: 4BFFE1A1  bl 0x827e7570
	ctx.lr = 0x827E93D4;
	sub_827E7570(ctx, base);
	// 827E93D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E93D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E93DC: 483C68AD  bl 0x82bafc88
	ctx.lr = 0x827E93E0;
	sub_82BAFC88(ctx, base);
	// 827E93E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E93E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E93E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827E93EC: 4BFFEDB5  bl 0x827e81a0
	ctx.lr = 0x827E93F0;
	sub_827E81A0(ctx, base);
	// 827E93F0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827E93F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E93F8: 419A0008  beq cr6, 0x827e9400
	if ctx.cr[6].eq {
	pc = 0x827E9400; continue 'dispatch;
	}
	// 827E93FC: 4BAD7495  bl 0x822c0890
	ctx.lr = 0x827E9400;
	sub_822C0890(ctx, base);
	// 827E9400: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 827E9404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9408: 419A01A8  beq cr6, 0x827e95b0
	if ctx.cr[6].eq {
	pc = 0x827E95B0; continue 'dispatch;
	}
	// 827E940C: 4BAD7485  bl 0x822c0890
	ctx.lr = 0x827E9410;
	sub_822C0890(ctx, base);
	// 827E9410: 480001A0  b 0x827e95b0
	pc = 0x827E95B0; continue 'dispatch;
	// 827E9414: 83EB0018  lwz r31, 0x18(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E9418: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E941C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E9420: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 827E9424: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 827E9428: 419A0024  beq cr6, 0x827e944c
	if ctx.cr[6].eq {
	pc = 0x827E944C; continue 'dispatch;
	}
	// 827E942C: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 827E9430: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827E9434: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9438: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827E943C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827E9440: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9444: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9448: 4082FFE8  bne 0x827e9430
	if !ctx.cr[0].eq {
	pc = 0x827E9430; continue 'dispatch;
	}
	// 827E944C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827E9450: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 827E9454: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827E9458: 4BADB009  bl 0x822c4460
	ctx.lr = 0x827E945C;
	sub_822C4460(ctx, base);
	// 827E945C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E9460: 419A000C  beq cr6, 0x827e946c
	if ctx.cr[6].eq {
	pc = 0x827E946C; continue 'dispatch;
	}
	// 827E9464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9468: 4BAD7429  bl 0x822c0890
	ctx.lr = 0x827E946C;
	sub_822C0890(ctx, base);
	// 827E946C: 83410060  lwz r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E9470: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E9474: 817A003C  lwz r11, 0x3c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 827E9478: 807A0040  lwz r3, 0x40(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 827E947C: 808B00DC  lwz r4, 0xdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 827E9480: 48611559  bl 0x82dfa9d8
	ctx.lr = 0x827E9484;
	sub_82DFA9D8(ctx, base);
	// 827E9484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9488: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E948C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E9490: 409A0094  bne cr6, 0x827e9524
	if !ctx.cr[6].eq {
	pc = 0x827E9524; continue 'dispatch;
	}
	// 827E9494: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E949C: 419A0048  beq cr6, 0x827e94e4
	if ctx.cr[6].eq {
	pc = 0x827E94E4; continue 'dispatch;
	}
	// 827E94A0: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 827E94A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E94A8: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 827E94AC: 419A0024  beq cr6, 0x827e94d0
	if ctx.cr[6].eq {
	pc = 0x827E94D0; continue 'dispatch;
	}
	// 827E94B0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E94B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E94B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E94BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E94C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E94C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E94C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E94CC: 4082FFE8  bne 0x827e94b4
	if !ctx.cr[0].eq {
	pc = 0x827E94B4; continue 'dispatch;
	}
	// 827E94D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E94D4: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E94D8: 488DCC69  bl 0x830c6140
	ctx.lr = 0x827E94DC;
	sub_830C6140(ctx, base);
	// 827E94DC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827E94E0: 4BFFFF24  b 0x827e9404
	pc = 0x827E9404; continue 'dispatch;
	// 827E94E4: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 827E94E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E94EC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827E94F0: 419A0024  beq cr6, 0x827e9514
	if ctx.cr[6].eq {
	pc = 0x827E9514; continue 'dispatch;
	}
	// 827E94F4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E94F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E94FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9500: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9508: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E950C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9510: 4082FFE8  bne 0x827e94f8
	if !ctx.cr[0].eq {
	pc = 0x827E94F8; continue 'dispatch;
	}
	// 827E9514: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E9518: 807800B4  lwz r3, 0xb4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E951C: 488DCC9D  bl 0x830c61b8
	ctx.lr = 0x827E9520;
	sub_830C61B8(ctx, base);
	// 827E9520: 48000090  b 0x827e95b0
	pc = 0x827E95B0; continue 'dispatch;
	// 827E9524: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E9528: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E952C: 409A0084  bne cr6, 0x827e95b0
	if !ctx.cr[6].eq {
	pc = 0x827E95B0; continue 'dispatch;
	}
	// 827E9530: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9534: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 827E9538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E953C: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827E9540: 419A003C  beq cr6, 0x827e957c
	if ctx.cr[6].eq {
	pc = 0x827E957C; continue 'dispatch;
	}
	// 827E9544: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E9548: 419A0024  beq cr6, 0x827e956c
	if ctx.cr[6].eq {
	pc = 0x827E956C; continue 'dispatch;
	}
	// 827E954C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E9550: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9554: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9558: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E955C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9560: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9564: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9568: 4082FFE8  bne 0x827e9550
	if !ctx.cr[0].eq {
	pc = 0x827E9550; continue 'dispatch;
	}
	// 827E956C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E9570: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9574: 488DC98D  bl 0x830c5f00
	ctx.lr = 0x827E9578;
	sub_830C5F00(ctx, base);
	// 827E9578: 48000038  b 0x827e95b0
	pc = 0x827E95B0; continue 'dispatch;
	// 827E957C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E9580: 419A0024  beq cr6, 0x827e95a4
	if ctx.cr[6].eq {
	pc = 0x827E95A4; continue 'dispatch;
	}
	// 827E9584: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E9588: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E958C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9590: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9594: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9598: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E959C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E95A0: 4082FFE8  bne 0x827e9588
	if !ctx.cr[0].eq {
	pc = 0x827E9588; continue 'dispatch;
	}
	// 827E95A4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 827E95A8: 807800B4  lwz r3, 0xb4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E95AC: 488DCA3D  bl 0x830c5fe8
	ctx.lr = 0x827E95B0;
	sub_830C5FE8(ctx, base);
	// 827E95B0: 92DA0048  stw r22, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[22].u32 ) };
	// 827E95B4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E95B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E95BC: 419A0010  beq cr6, 0x827e95cc
	if ctx.cr[6].eq {
	pc = 0x827E95CC; continue 'dispatch;
	}
	// 827E95C0: 896B0034  lbz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 827E95C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E95C8: 418200A8  beq 0x827e9670
	if ctx.cr[0].eq {
	pc = 0x827E9670; continue 'dispatch;
	}
	// 827E95CC: 897A0034  lbz r11, 0x34(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) } as u64;
	// 827E95D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E95D4: 40820008  bne 0x827e95dc
	if !ctx.cr[0].eq {
	pc = 0x827E95DC; continue 'dispatch;
	}
	// 827E95D8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 827E95DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E95E0: 809800DC  lwz r4, 0xdc(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(220 as u32) ) } as u64;
	// 827E95E4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E95E8: 486113D1  bl 0x82dfa9b8
	ctx.lr = 0x827E95EC;
	sub_82DFA9B8(ctx, base);
	// 827E95EC: 83630008  lwz r27, 8(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E95F0: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E95F4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E95F8: 419A0078  beq cr6, 0x827e9670
	if ctx.cr[6].eq {
	pc = 0x827E9670; continue 'dispatch;
	}
	// 827E95FC: 3B970001  addi r28, r23, 1
	ctx.r[28].s64 = ctx.r[23].s64 + 1;
	// 827E9600: 57BD063E  clrlwi r29, r29, 0x18
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 827E9604: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 827E9608: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E960C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 827E9610: 419A0024  beq cr6, 0x827e9634
	if ctx.cr[6].eq {
	pc = 0x827E9634; continue 'dispatch;
	}
	// 827E9614: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 827E9618: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E961C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9620: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9628: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E962C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9630: 4082FFE8  bne 0x827e9618
	if !ctx.cr[0].eq {
	pc = 0x827E9618; continue 'dispatch;
	}
	// 827E9634: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827E9638: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E963C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 827E9640: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827E9644: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E9648: 4BFFFB99  bl 0x827e91e0
	ctx.lr = 0x827E964C;
	sub_827E91E0(ctx, base);
	// 827E964C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827E9650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9654: 419A0008  beq cr6, 0x827e965c
	if ctx.cr[6].eq {
	pc = 0x827E965C; continue 'dispatch;
	}
	// 827E9658: 4BAD7239  bl 0x822c0890
	ctx.lr = 0x827E965C;
	sub_822C0890(ctx, base);
	// 827E965C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827E9660: 409A0010  bne cr6, 0x827e9670
	if !ctx.cr[6].eq {
	pc = 0x827E9670; continue 'dispatch;
	}
	// 827E9664: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827E9668: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827E966C: 409AFF98  bne cr6, 0x827e9604
	if !ctx.cr[6].eq {
	pc = 0x827E9604; continue 'dispatch;
	}
	// 827E9670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827E9674: 419A000C  beq cr6, 0x827e9680
	if ctx.cr[6].eq {
	pc = 0x827E9680; continue 'dispatch;
	}
	// 827E9678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E967C: 4BAD7215  bl 0x822c0890
	ctx.lr = 0x827E9680;
	sub_822C0890(ctx, base);
	// 827E9680: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827E9684: 489BEB1C  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E9688 size=564
    let mut pc: u32 = 0x827E9688;
    'dispatch: loop {
        match pc {
            0x827E9688 => {
    //   block [0x827E9688..0x827E98BC)
	// 827E9688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E968C: 489BEAC9  bl 0x831a8154
	ctx.lr = 0x827E9690;
	sub_831A8130(ctx, base);
	// 827E9690: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 827E9694: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9698: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827E969C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 827E96A0: 486099F1  bl 0x82df3090
	ctx.lr = 0x827E96A4;
	sub_82DF3090(ctx, base);
	// 827E96A4: 48683FB5  bl 0x82e6d658
	ctx.lr = 0x827E96A8;
	sub_82E6D658(ctx, base);
	// 827E96A8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 827E96AC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 827E96B0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E96B4: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 827E96B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E96BC: C3E989AC  lfs f31, -0x7654(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827E96C0: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 827E96C4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 827E96C8: 3B6BC1EC  addi r27, r11, -0x3e14
	ctx.r[27].s64 = ctx.r[11].s64 + -15892;
	// 827E96CC: 3BCAC1AC  addi r30, r10, -0x3e54
	ctx.r[30].s64 = ctx.r[10].s64 + -15956;
	// 827E96D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E96D4: 7C9FF02E  lwzx r4, r31, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 827E96D8: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 827E96DC: 4860FF9D  bl 0x82df9678
	ctx.lr = 0x827E96E0;
	sub_82DF9678(ctx, base);
	// 827E96E0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 827E96E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827E96E8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827E96EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827E96F0: 4BFFED71  bl 0x827e8460
	ctx.lr = 0x827E96F4;
	sub_827E8460(ctx, base);
	// 827E96F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E96F8: 7C9FF02E  lwzx r4, r31, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 827E96FC: 4BADFBF5  bl 0x822c92f0
	ctx.lr = 0x827E9700;
	sub_822C92F0(ctx, base);
	// 827E9700: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827E9704: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E9708: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E970C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E9710: 387D0090  addi r3, r29, 0x90
	ctx.r[3].s64 = ctx.r[29].s64 + 144;
	// 827E9714: 4BADFA1D  bl 0x822c9130
	ctx.lr = 0x827E9718;
	sub_822C9130(ctx, base);
	// 827E9718: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E971C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827E9720: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827E9724: 4BADF70D  bl 0x822c8e30
	ctx.lr = 0x827E9728;
	sub_822C8E30(ctx, base);
	// 827E9728: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827E972C: 7C1FDC2E  lfsx f0, r31, r27
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9730: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 827E9734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9738: D3FD0034  stfs f31, 0x34(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 827E973C: 419A0008  beq cr6, 0x827e9744
	if ctx.cr[6].eq {
	pc = 0x827E9744; continue 'dispatch;
	}
	// 827E9740: 4BAD7151  bl 0x822c0890
	ctx.lr = 0x827E9744;
	sub_822C0890(ctx, base);
	// 827E9744: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827E9748: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 827E974C: 2B1F0020  cmplwi cr6, r31, 0x20
	ctx.cr[6].compare_u32(ctx.r[31].u32, 32 as u32, &mut ctx.xer);
	// 827E9750: 4198FF80  blt cr6, 0x827e96d0
	if ctx.cr[6].lt {
	pc = 0x827E96D0; continue 'dispatch;
	}
	// 827E9754: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827E9758: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E975C: 48000040  b 0x827e979c
	pc = 0x827E979C; continue 'dispatch;
	// 827E9760: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E9764: 809900DC  lwz r4, 0xdc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(220 as u32) ) } as u64;
	// 827E9768: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E976C: 4861128D  bl 0x82dfa9f8
	ctx.lr = 0x827E9770;
	sub_82DFA9F8(ctx, base);
	// 827E9770: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E9774: 40820024  bne 0x827e9798
	if !ctx.cr[0].eq {
	pc = 0x827E9798; continue 'dispatch;
	}
	// 827E9778: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 827E977C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827E9780: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 827E9784: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E9788: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827E978C: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9790: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E9794: 4BFFFA4D  bl 0x827e91e0
	ctx.lr = 0x827E9798;
	sub_827E91E0(ctx, base);
	// 827E9798: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 827E979C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E97A0: 409AFFC0  bne cr6, 0x827e9760
	if !ctx.cr[6].eq {
	pc = 0x827E9760; continue 'dispatch;
	}
	// 827E97A4: 83D900C8  lwz r30, 0xc8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(200 as u32) ) } as u64;
	// 827E97A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E97AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E97B0: 480000F8  b 0x827e98a8
	pc = 0x827E98A8; continue 'dispatch;
	// 827E97B4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E97B8: 814A0048  lwz r10, 0x48(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 827E97BC: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827E97C0: 419A00DC  beq cr6, 0x827e989c
	if ctx.cr[6].eq {
	pc = 0x827E989C; continue 'dispatch;
	}
	// 827E97C4: 83EB0018  lwz r31, 0x18(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827E97C8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827E97CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E97D0: 419A0024  beq cr6, 0x827e97f4
	if ctx.cr[6].eq {
	pc = 0x827E97F4; continue 'dispatch;
	}
	// 827E97D4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 827E97D8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827E97DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E97E0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827E97E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827E97E8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E97EC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E97F0: 4082FFE8  bne 0x827e97d8
	if !ctx.cr[0].eq {
	pc = 0x827E97D8; continue 'dispatch;
	}
	// 827E97F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E97F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827E97FC: 419A0054  beq cr6, 0x827e9850
	if ctx.cr[6].eq {
	pc = 0x827E9850; continue 'dispatch;
	}
	// 827E9800: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827E9804: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E9808: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 827E980C: 419A0024  beq cr6, 0x827e9830
	if ctx.cr[6].eq {
	pc = 0x827E9830; continue 'dispatch;
	}
	// 827E9810: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 827E9814: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827E9818: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E981C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827E9820: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827E9824: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9828: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E982C: 4082FFE8  bne 0x827e9814
	if !ctx.cr[0].eq {
	pc = 0x827E9814; continue 'dispatch;
	}
	// 827E9830: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827E9834: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E9838: 488DC909  bl 0x830c6140
	ctx.lr = 0x827E983C;
	sub_830C6140(ctx, base);
	// 827E983C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827E9840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9844: 419A0048  beq cr6, 0x827e988c
	if ctx.cr[6].eq {
	pc = 0x827E988C; continue 'dispatch;
	}
	// 827E9848: 4BAD7049  bl 0x822c0890
	ctx.lr = 0x827E984C;
	sub_822C0890(ctx, base);
	// 827E984C: 48000040  b 0x827e988c
	pc = 0x827E988C; continue 'dispatch;
	// 827E9850: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827E9854: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E9858: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 827E985C: 419A0024  beq cr6, 0x827e9880
	if ctx.cr[6].eq {
	pc = 0x827E9880; continue 'dispatch;
	}
	// 827E9860: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827E9864: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9868: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E986C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9870: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9874: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9878: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E987C: 4082FFE8  bne 0x827e9864
	if !ctx.cr[0].eq {
	pc = 0x827E9864; continue 'dispatch;
	}
	// 827E9880: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827E9884: 807900B4  lwz r3, 0xb4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(180 as u32) ) } as u64;
	// 827E9888: 488DC931  bl 0x830c61b8
	ctx.lr = 0x827E988C;
	sub_830C61B8(ctx, base);
	// 827E988C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827E9890: 419A000C  beq cr6, 0x827e989c
	if ctx.cr[6].eq {
	pc = 0x827E989C; continue 'dispatch;
	}
	// 827E9894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9898: 4BAD6FF9  bl 0x822c0890
	ctx.lr = 0x827E989C;
	sub_822C0890(ctx, base);
	// 827E989C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827E98A0: 48071119  bl 0x8285a9b8
	ctx.lr = 0x827E98A4;
	sub_8285A9B8(ctx, base);
	// 827E98A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E98A8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827E98AC: 409AFF08  bne cr6, 0x827e97b4
	if !ctx.cr[6].eq {
	pc = 0x827E97B4; continue 'dispatch;
	}
	// 827E98B0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 827E98B4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 827E98B8: 489BE8EC  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E98C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E98C0 size=108
    let mut pc: u32 = 0x827E98C0;
    'dispatch: loop {
        match pc {
            0x827E98C0 => {
    //   block [0x827E98C0..0x827E992C)
	// 827E98C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E98C4: 489BE8A9  bl 0x831a816c
	ctx.lr = 0x827E98C8;
	sub_831A8130(ctx, base);
	// 827E98C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E98CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827E98D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827E98D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E98D8: 83FE00BC  lwz r31, 0xbc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) } as u64;
	// 827E98DC: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 827E98E0: 48611229  bl 0x82dfab08
	ctx.lr = 0x827E98E4;
	sub_82DFAB08(ctx, base);
	// 827E98E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E98E8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 827E98EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827E98F0: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 827E98F4: 4BADF83D  bl 0x822c9130
	ctx.lr = 0x827E98F8;
	sub_822C9130(ctx, base);
	// 827E98F8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E98FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827E9900: 816AAC38  lwz r11, -0x53c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21448 as u32) ) } as u64;
	// 827E9904: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 827E9908: 908AAC38  stw r4, -0x53c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21448 as u32), ctx.r[4].u32 ) };
	// 827E990C: 4BFFFD7D  bl 0x827e9688
	ctx.lr = 0x827E9910;
	sub_827E9688(ctx, base);
	// 827E9910: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E9914: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9918: 419A0008  beq cr6, 0x827e9920
	if ctx.cr[6].eq {
	pc = 0x827E9920; continue 'dispatch;
	}
	// 827E991C: 4BAD6F75  bl 0x822c0890
	ctx.lr = 0x827E9920;
	sub_822C0890(ctx, base);
	// 827E9920: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827E9924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E9928: 489BE894  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E9930 size=1368
    let mut pc: u32 = 0x827E9930;
    'dispatch: loop {
        match pc {
            0x827E9930 => {
    //   block [0x827E9930..0x827E9E88)
	// 827E9930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9934: 489BE825  bl 0x831a8158
	ctx.lr = 0x827E9938;
	sub_831A8130(ctx, base);
	// 827E9938: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 827E993C: 489BF139  bl 0x831a8a74
	ctx.lr = 0x827E9940;
	sub_831A8A40(ctx, base);
	// 827E9940: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E9948: 488D9241  bl 0x830c2b88
	ctx.lr = 0x827E994C;
	sub_830C2B88(ctx, base);
	// 827E994C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827E9950: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 827E9954: 396B5BB4  addi r11, r11, 0x5bb4
	ctx.r[11].s64 = ctx.r[11].s64 + 23476;
	// 827E9958: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827E995C: 4BFB229D  bl 0x8279bbf8
	ctx.lr = 0x827E9960;
	sub_8279BBF8(ctx, base);
	// 827E9960: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827E9964: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 827E9968: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 827E996C: 3BBF00B4  addi r29, r31, 0xb4
	ctx.r[29].s64 = ctx.r[31].s64 + 180;
	// 827E9970: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 827E9974: 3B7F00BC  addi r27, r31, 0xbc
	ctx.r[27].s64 = ctx.r[31].s64 + 188;
	// 827E9978: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 827E997C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 827E9980: 4BFFDB99  bl 0x827e7518
	ctx.lr = 0x827E9984;
	sub_827E7518(ctx, base);
	// 827E9984: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827E9988: 806B1108  lwz r3, 0x1108(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4360 as u32) ) } as u64;
	// 827E998C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9990: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9994: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827E9998: 4E800421  bctrl
	ctx.lr = 0x827E999C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827E999C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827E99A0: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 827E99A4: 935F00D0  stw r26, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[26].u32 ) };
	// 827E99A8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E99AC: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 827E99B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E99B4: 4BAD7145  bl 0x822c0af8
	ctx.lr = 0x827E99B8;
	sub_822C0AF8(ctx, base);
	// 827E99B8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827E99BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827E99C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E99C4: 4BAD663D  bl 0x822c0000
	ctx.lr = 0x827E99C8;
	sub_822C0000(ctx, base);
	// 827E99C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827E99CC: 9BDF00D8  stb r30, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u8 ) };
	// 827E99D0: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 827E99D4: 9BDF00D9  stb r30, 0xd9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(217 as u32), ctx.r[30].u8 ) };
	// 827E99D8: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 827E99DC: 93EBAC34  stw r31, -0x53cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-21452 as u32), ctx.r[31].u32 ) };
	// 827E99E0: 4BAD6F59  bl 0x822c0938
	ctx.lr = 0x827E99E4;
	sub_822C0938(ctx, base);
	// 827E99E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E99E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 827E99EC: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 827E99F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E99F4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827E99F8: C36A093C  lfs f27, 0x93c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 827E99FC: 3B4BC1CC  addi r26, r11, -0x3e34
	ctx.r[26].s64 = ctx.r[11].s64 + -15924;
	// 827E9A00: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827E9A04: C3C88DC0  lfs f30, -0x7240(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29248 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827E9A08: 41820070  beq 0x827e9a78
	if ctx.cr[0].eq {
	pc = 0x827E9A78; continue 'dispatch;
	}
	// 827E9A0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E9A10: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E9A14: C19A0000  lfs f12, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E9A18: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E9A1C: D3C100B0  stfs f30, 0xb0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 827E9A20: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9A24: D3C100B4  stfs f30, 0xb4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 827E9A28: 388A9650  addi r4, r10, -0x69b0
	ctx.r[4].s64 = ctx.r[10].s64 + -27056;
	// 827E9A2C: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 827E9A30: C00B9680  lfs f0, -0x6980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9A34: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E9A38: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 827E9A3C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 827E9A40: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 827E9A44: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 827E9A48: D3E100FC  stfs f31, 0xfc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 827E9A4C: EC0DD828  fsubs f0, f13, f27
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[27].f64) as f32) as f64);
	// 827E9A50: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 827E9A54: 4BADF89D  bl 0x822c92f0
	ctx.lr = 0x827E9A58;
	sub_822C92F0(ctx, base);
	// 827E9A58: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E9A5C: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 827E9A60: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 827E9A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E9A68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E9A6C: 488DCD75  bl 0x830c67e0
	ctx.lr = 0x827E9A70;
	sub_830C67E0(ctx, base);
	// 827E9A70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E9A74: 48000008  b 0x827e9a7c
	pc = 0x827E9A7C; continue 'dispatch;
	// 827E9A78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E9A7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E9A80: 4BFF3259  bl 0x827dccd8
	ctx.lr = 0x827E9A84;
	sub_827DCCD8(ctx, base);
	// 827E9A84: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E9A88: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9A90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E9A94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E9A98: 419A0024  beq cr6, 0x827e9abc
	if ctx.cr[6].eq {
	pc = 0x827E9ABC; continue 'dispatch;
	}
	// 827E9A9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E9AA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9AA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9AA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9AAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9AB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9AB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9AB8: 4082FFE8  bne 0x827e9aa0
	if !ctx.cr[0].eq {
	pc = 0x827E9AA0; continue 'dispatch;
	}
	// 827E9ABC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E9AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9AC4: 488D9E55  bl 0x830c3918
	ctx.lr = 0x827E9AC8;
	sub_830C3918(ctx, base);
	// 827E9AC8: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827E9ACC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9AD0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E9AD4: 396B98C0  addi r11, r11, -0x6740
	ctx.r[11].s64 = ctx.r[11].s64 + -26432;
	// 827E9AD8: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 827E9ADC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E9AE0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E9AE4: 4BFFEBFD  bl 0x827e86e0
	ctx.lr = 0x827E9AE8;
	sub_827E86E0(ctx, base);
	// 827E9AE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9AEC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 827E9AF0: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 827E9AF4: 4BC875D5  bl 0x824710c8
	ctx.lr = 0x827E9AF8;
	sub_824710C8(ctx, base);
	// 827E9AF8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9AFC: 4BADF1BD  bl 0x822c8cb8
	ctx.lr = 0x827E9B00;
	sub_822C8CB8(ctx, base);
	// 827E9B00: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9B04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827E9B08: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E9B0C: 996A0100  stb r11, 0x100(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 827E9B10: 4BAD6E29  bl 0x822c0938
	ctx.lr = 0x827E9B14;
	sub_822C0938(ctx, base);
	// 827E9B14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E9B18: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 827E9B1C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E9B20: C38B9594  lfs f28, -0x6a6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 827E9B24: C3AA89AC  lfs f29, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 827E9B28: 41820064  beq 0x827e9b8c
	if ctx.cr[0].eq {
	pc = 0x827E9B8C; continue 'dispatch;
	}
	// 827E9B2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 827E9B30: D3A10094  stfs f29, 0x94(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 827E9B34: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E9B38: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 827E9B3C: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 827E9B40: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827E9B44: D38100E4  stfs f28, 0xe4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 827E9B48: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9B4C: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 827E9B50: 38895BA4  addi r4, r9, 0x5ba4
	ctx.r[4].s64 = ctx.r[9].s64 + 23460;
	// 827E9B54: C00BD7B8  lfs f0, -0x2848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9B58: C1AA958C  lfs f13, -0x6a74(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E9B5C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 827E9B60: D1A100E0  stfs f13, 0xe0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 827E9B64: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 827E9B68: 4BADF789  bl 0x822c92f0
	ctx.lr = 0x827E9B6C;
	sub_822C92F0(ctx, base);
	// 827E9B6C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E9B70: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 827E9B74: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 827E9B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E9B7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E9B80: 488DA639  bl 0x830c41b8
	ctx.lr = 0x827E9B84;
	sub_830C41B8(ctx, base);
	// 827E9B84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E9B88: 48000008  b 0x827e9b90
	pc = 0x827E9B90; continue 'dispatch;
	// 827E9B8C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 827E9B90: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E9B94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E9B98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9B9C: 4BADF1CD  bl 0x822c8d68
	ctx.lr = 0x827E9BA0;
	sub_822C8D68(ctx, base);
	// 827E9BA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E9BA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E9BA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9BAC: 4BAD6455  bl 0x822c0000
	ctx.lr = 0x827E9BB0;
	sub_822C0000(ctx, base);
	// 827E9BB0: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E9BB4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E9BB8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827E9BBC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 827E9BC0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E9BC4: 419A0024  beq cr6, 0x827e9be8
	if ctx.cr[6].eq {
	pc = 0x827E9BE8; continue 'dispatch;
	}
	// 827E9BC8: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 827E9BCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9BD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9BD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9BD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9BDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9BE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9BE4: 4082FFE8  bne 0x827e9bcc
	if !ctx.cr[0].eq {
	pc = 0x827E9BCC; continue 'dispatch;
	}
	// 827E9BE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9BF0: 488D9D29  bl 0x830c3918
	ctx.lr = 0x827E9BF4;
	sub_830C3918(ctx, base);
	// 827E9BF4: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E9BF8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 827E9BFC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E9C00: 396B6E38  addi r11, r11, 0x6e38
	ctx.r[11].s64 = ctx.r[11].s64 + 28216;
	// 827E9C04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E9C08: 897F00D9  lbz r11, 0xd9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(217 as u32) ) } as u64;
	// 827E9C0C: 997D00E8  stb r11, 0xe8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[11].u8 ) };
	// 827E9C10: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 827E9C14: 4BADF0A5  bl 0x822c8cb8
	ctx.lr = 0x827E9C18;
	sub_822C8CB8(ctx, base);
	// 827E9C18: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 827E9C1C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E9C20: 4BFFE741  bl 0x827e8360
	ctx.lr = 0x827E9C24;
	sub_827E8360(ctx, base);
	// 827E9C24: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 827E9C28: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9C2C: 4BDA22E5  bl 0x8258bf10
	ctx.lr = 0x827E9C30;
	sub_8258BF10(ctx, base);
	// 827E9C30: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827E9C34: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 827E9C38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827E9C3C: 4BC8748D  bl 0x824710c8
	ctx.lr = 0x827E9C40;
	sub_824710C8(ctx, base);
	// 827E9C40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E9C44: 4BADF075  bl 0x822c8cb8
	ctx.lr = 0x827E9C48;
	sub_822C8CB8(ctx, base);
	// 827E9C48: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 827E9C4C: 4BADF06D  bl 0x822c8cb8
	ctx.lr = 0x827E9C50;
	sub_822C8CB8(ctx, base);
	// 827E9C50: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827E9C54: 4BAD6CE5  bl 0x822c0938
	ctx.lr = 0x827E9C58;
	sub_822C0938(ctx, base);
	// 827E9C58: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E9C5C: 41820064  beq 0x827e9cc0
	if ctx.cr[0].eq {
	pc = 0x827E9CC0; continue 'dispatch;
	}
	// 827E9C60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E9C64: D3A10064  stfs f29, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827E9C68: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E9C6C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827E9C70: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827E9C74: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827E9C78: D3810074  stfs f28, 0x74(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E9C7C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9C80: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E9C84: 388957F4  addi r4, r9, 0x57f4
	ctx.r[4].s64 = ctx.r[9].s64 + 22516;
	// 827E9C88: C00BE2B4  lfs f0, -0x1d4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9C8C: C1AA967C  lfs f13, -0x6984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27012 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E9C90: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827E9C94: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E9C98: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E9C9C: 4BADF655  bl 0x822c92f0
	ctx.lr = 0x827E9CA0;
	sub_822C92F0(ctx, base);
	// 827E9CA0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E9CA4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827E9CA8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 827E9CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E9CB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E9CB4: 488DE1F5  bl 0x830c7ea8
	ctx.lr = 0x827E9CB8;
	sub_830C7EA8(ctx, base);
	// 827E9CB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827E9CBC: 48000008  b 0x827e9cc4
	pc = 0x827E9CC4; continue 'dispatch;
	// 827E9CC0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 827E9CC4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E9CC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E9CCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9CD0: 4BADFA31  bl 0x822c9700
	ctx.lr = 0x827E9CD4;
	sub_822C9700(ctx, base);
	// 827E9CD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827E9CD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827E9CDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9CE0: 4BAD6321  bl 0x822c0000
	ctx.lr = 0x827E9CE4;
	sub_822C0000(ctx, base);
	// 827E9CE4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827E9CE8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827E9CEC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E9CF0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 827E9CF4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827E9CF8: 419A0024  beq cr6, 0x827e9d1c
	if ctx.cr[6].eq {
	pc = 0x827E9D1C; continue 'dispatch;
	}
	// 827E9CFC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 827E9D00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9D04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9D08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9D0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9D10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9D14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9D18: 4082FFE8  bne 0x827e9d00
	if !ctx.cr[0].eq {
	pc = 0x827E9D00; continue 'dispatch;
	}
	// 827E9D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E9D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9D24: 488D9BF5  bl 0x830c3918
	ctx.lr = 0x827E9D28;
	sub_830C3918(ctx, base);
	// 827E9D28: 93C10120  stw r30, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 827E9D2C: 3D60827E  lis r11, -0x7d82
	ctx.r[11].s64 = -2105671680;
	// 827E9D30: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827E9D34: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 827E9D38: 396B6E40  addi r11, r11, 0x6e40
	ctx.r[11].s64 = ctx.r[11].s64 + 28224;
	// 827E9D3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827E9D40: 4BADEF79  bl 0x822c8cb8
	ctx.lr = 0x827E9D44;
	sub_822C8CB8(ctx, base);
	// 827E9D44: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 827E9D48: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827E9D4C: 4BFFE695  bl 0x827e83e0
	ctx.lr = 0x827E9D50;
	sub_827E83E0(ctx, base);
	// 827E9D50: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 827E9D54: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9D58: 4BDA21B9  bl 0x8258bf10
	ctx.lr = 0x827E9D5C;
	sub_8258BF10(ctx, base);
	// 827E9D5C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827E9D60: 387D00C0  addi r3, r29, 0xc0
	ctx.r[3].s64 = ctx.r[29].s64 + 192;
	// 827E9D64: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827E9D68: 4BC87361  bl 0x824710c8
	ctx.lr = 0x827E9D6C;
	sub_824710C8(ctx, base);
	// 827E9D6C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827E9D70: 4BADEF49  bl 0x822c8cb8
	ctx.lr = 0x827E9D74;
	sub_822C8CB8(ctx, base);
	// 827E9D74: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 827E9D78: 4BADEF41  bl 0x822c8cb8
	ctx.lr = 0x827E9D7C;
	sub_822C8CB8(ctx, base);
	// 827E9D7C: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 827E9D80: 4BAD6BB9  bl 0x822c0938
	ctx.lr = 0x827E9D84;
	sub_822C0938(ctx, base);
	// 827E9D84: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827E9D88: 4182007C  beq 0x827e9e04
	if ctx.cr[0].eq {
	pc = 0x827E9E04; continue 'dispatch;
	}
	// 827E9D8C: C01A0004  lfs f0, 4(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9D90: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827E9D94: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 827E9D98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827E9D9C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 827E9DA0: D3C10080  stfs f30, 0x80(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 827E9DA4: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 827E9DA8: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 827E9DAC: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 827E9DB0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 827E9DB4: C00A95F8  lfs f0, -0x6a08(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9DB8: 38885B98  addi r4, r8, 0x5b98
	ctx.r[4].s64 = ctx.r[8].s64 + 23448;
	// 827E9DBC: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 827E9DC0: C18B959C  lfs f12, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E9DC4: C1A99670  lfs f13, -0x6990(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27024 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E9DC8: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 827E9DCC: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 827E9DD0: EC0BD828  fsubs f0, f11, f27
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[27].f64) as f32) as f64);
	// 827E9DD4: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 827E9DD8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 827E9DDC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 827E9DE0: 4BADF511  bl 0x822c92f0
	ctx.lr = 0x827E9DE4;
	sub_822C92F0(ctx, base);
	// 827E9DE4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827E9DE8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 827E9DEC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 827E9DF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E9DF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827E9DF8: 488DE371  bl 0x830c8168
	ctx.lr = 0x827E9DFC;
	sub_830C8168(ctx, base);
	// 827E9DFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827E9E00: 48000008  b 0x827e9e08
	pc = 0x827E9E08; continue 'dispatch;
	// 827E9E04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827E9E08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827E9E0C: 4BAE4BD5  bl 0x822ce9e0
	ctx.lr = 0x827E9E10;
	sub_822CE9E0(ctx, base);
	// 827E9E10: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827E9E14: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827E9E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9E1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827E9E20: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827E9E24: 419A0024  beq cr6, 0x827e9e48
	if ctx.cr[6].eq {
	pc = 0x827E9E48; continue 'dispatch;
	}
	// 827E9E28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827E9E2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827E9E30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9E34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827E9E38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827E9E3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827E9E40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827E9E44: 4082FFE8  bne 0x827e9e2c
	if !ctx.cr[0].eq {
	pc = 0x827E9E2C; continue 'dispatch;
	}
	// 827E9E48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827E9E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9E50: 488D9AC9  bl 0x830c3918
	ctx.lr = 0x827E9E54;
	sub_830C3918(ctx, base);
	// 827E9E54: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827E9E58: 419A000C  beq cr6, 0x827e9e64
	if ctx.cr[6].eq {
	pc = 0x827E9E64; continue 'dispatch;
	}
	// 827E9E5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827E9E60: 4BAD6A31  bl 0x822c0890
	ctx.lr = 0x827E9E64;
	sub_822C0890(ctx, base);
	// 827E9E64: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827E9E68: 419A000C  beq cr6, 0x827e9e74
	if ctx.cr[6].eq {
	pc = 0x827E9E74; continue 'dispatch;
	}
	// 827E9E6C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827E9E70: 4BAD6A21  bl 0x822c0890
	ctx.lr = 0x827E9E74;
	sub_822C0890(ctx, base);
	// 827E9E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9E78: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 827E9E7C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 827E9E80: 489BEC41  bl 0x831a8ac0
	ctx.lr = 0x827E9E84;
	sub_831A8A8C(ctx, base);
	// 827E9E84: 489BE324  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E9E88 size=112
    let mut pc: u32 = 0x827E9E88;
    'dispatch: loop {
        match pc {
            0x827E9E88 => {
    //   block [0x827E9E88..0x827E9EF8)
	// 827E9E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E9E90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E9E94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9E98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E9E9C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 827E9EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9EA4: 419A0008  beq cr6, 0x827e9eac
	if ctx.cr[6].eq {
	pc = 0x827E9EAC; continue 'dispatch;
	}
	// 827E9EA8: 4BAD69E9  bl 0x822c0890
	ctx.lr = 0x827E9EAC;
	sub_822C0890(ctx, base);
	// 827E9EAC: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 827E9EB0: 4BFFE7D9  bl 0x827e8688
	ctx.lr = 0x827E9EB4;
	sub_827E8688(ctx, base);
	// 827E9EB4: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 827E9EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9EBC: 419A0008  beq cr6, 0x827e9ec4
	if ctx.cr[6].eq {
	pc = 0x827E9EC4; continue 'dispatch;
	}
	// 827E9EC0: 4BAD69D1  bl 0x822c0890
	ctx.lr = 0x827E9EC4;
	sub_822C0890(ctx, base);
	// 827E9EC4: 807F00B8  lwz r3, 0xb8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 827E9EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827E9ECC: 419A0008  beq cr6, 0x827e9ed4
	if ctx.cr[6].eq {
	pc = 0x827E9ED4; continue 'dispatch;
	}
	// 827E9ED0: 4BAD69C1  bl 0x822c0890
	ctx.lr = 0x827E9ED4;
	sub_822C0890(ctx, base);
	// 827E9ED4: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 827E9ED8: 48303421  bl 0x82aed2f8
	ctx.lr = 0x827E9EDC;
	sub_82AED2F8(ctx, base);
	// 827E9EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9EE0: 488D8C09  bl 0x830c2ae8
	ctx.lr = 0x827E9EE4;
	sub_830C2AE8(ctx, base);
	// 827E9EE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827E9EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E9EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E9EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E9EF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827E9EF8 size=76
    let mut pc: u32 = 0x827E9EF8;
    'dispatch: loop {
        match pc {
            0x827E9EF8 => {
    //   block [0x827E9EF8..0x827E9F44)
	// 827E9EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827E9F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827E9F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827E9F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E9F10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827E9F14: 4BFFFF75  bl 0x827e9e88
	ctx.lr = 0x827E9F18;
	sub_827E9E88(ctx, base);
	// 827E9F18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827E9F1C: 4182000C  beq 0x827e9f28
	if ctx.cr[0].eq {
	pc = 0x827E9F28; continue 'dispatch;
	}
	// 827E9F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9F24: 4BAD6345  bl 0x822c0268
	ctx.lr = 0x827E9F28;
	sub_822C0268(ctx, base);
	// 827E9F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827E9F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827E9F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827E9F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827E9F38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827E9F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827E9F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827E9F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827E9F48 size=360
    let mut pc: u32 = 0x827E9F48;
    'dispatch: loop {
        match pc {
            0x827E9F48 => {
    //   block [0x827E9F48..0x827EA0B0)
	// 827E9F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827E9F4C: 489BE21D  bl 0x831a8168
	ctx.lr = 0x827E9F50;
	sub_831A8130(ctx, base);
	// 827E9F50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827E9F54: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 827E9F58: 817EAC34  lwz r11, -0x53cc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827E9F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827E9F60: 419A0028  beq cr6, 0x827e9f88
	if ctx.cr[6].eq {
	pc = 0x827E9F88; continue 'dispatch;
	}
	// 827E9F64: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827E9F68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827E9F6C: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 827E9F70: 807EAC34  lwz r3, -0x53cc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827E9F74: 816AAC38  lwz r11, -0x53c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21448 as u32) ) } as u64;
	// 827E9F78: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 827E9F7C: 908AAC38  stw r4, -0x53c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21448 as u32), ctx.r[4].u32 ) };
	// 827E9F80: 4BFFF709  bl 0x827e9688
	ctx.lr = 0x827E9F84;
	sub_827E9688(ctx, base);
	// 827E9F84: 48000124  b 0x827ea0a8
	pc = 0x827EA0A8; continue 'dispatch;
	// 827E9F88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827E9F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827E9F90: 392BC1D4  addi r9, r11, -0x3e2c
	ctx.r[9].s64 = ctx.r[11].s64 + -15916;
	// 827E9F94: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 827E9F98: C16BC1D4  lfs f11, -0x3e2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15916 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827E9F9C: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827E9FA0: C1A9FFF8  lfs f13, -8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827E9FA4: C189FFFC  lfs f12, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827E9FA8: C1490004  lfs f10, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827E9FAC: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827E9FB0: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827E9FB4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827E9FB8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827E9FBC: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827E9FC0: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827E9FC4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827E9FC8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827E9FCC: 4BAD696D  bl 0x822c0938
	ctx.lr = 0x827E9FD0;
	sub_822C0938(ctx, base);
	// 827E9FD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827E9FD4: 41820018  beq 0x827e9fec
	if ctx.cr[0].eq {
	pc = 0x827E9FEC; continue 'dispatch;
	}
	// 827E9FD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827E9FDC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827E9FE0: 4BFFF951  bl 0x827e9930
	ctx.lr = 0x827E9FE4;
	sub_827E9930(ctx, base);
	// 827E9FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827E9FE8: 48000008  b 0x827e9ff0
	pc = 0x827E9FF0; continue 'dispatch;
	// 827E9FEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827E9FF0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827E9FF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827E9FF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827E9FFC: 4BFFD04D  bl 0x827e7048
	ctx.lr = 0x827EA000;
	sub_827E7048(ctx, base);
	// 827EA000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EA004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EA008: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EA00C: 4BAD5FF5  bl 0x822c0000
	ctx.lr = 0x827EA010;
	sub_822C0000(ctx, base);
	// 827EA010: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA014: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EA018: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EA01C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827EA020: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827EA024: 419A0024  beq cr6, 0x827ea048
	if ctx.cr[6].eq {
	pc = 0x827EA048; continue 'dispatch;
	}
	// 827EA028: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 827EA02C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EA030: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA034: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EA038: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EA03C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EA040: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA044: 4082FFE8  bne 0x827ea02c
	if !ctx.cr[0].eq {
	pc = 0x827EA02C; continue 'dispatch;
	}
	// 827EA048: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EA04C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827EA050: 388B5C00  addi r4, r11, 0x5c00
	ctx.r[4].s64 = ctx.r[11].s64 + 23552;
	// 827EA054: 4BADF29D  bl 0x822c92f0
	ctx.lr = 0x827EA058;
	sub_822C92F0(ctx, base);
	// 827EA058: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827EA05C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EA060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA064: 488D891D  bl 0x830c2980
	ctx.lr = 0x827EA068;
	sub_830C2980(ctx, base);
	// 827EA068: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 827EA06C: 907F00A0  stw r3, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 827EA070: 807EAC34  lwz r3, -0x53cc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827EA074: 817CAC38  lwz r11, -0x53c8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-21448 as u32) ) } as u64;
	// 827EA078: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 827EA07C: 909CAC38  stw r4, -0x53c8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-21448 as u32), ctx.r[4].u32 ) };
	// 827EA080: 4BFFF609  bl 0x827e9688
	ctx.lr = 0x827EA084;
	sub_827E9688(ctx, base);
	// 827EA084: 817CAC38  lwz r11, -0x53c8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-21448 as u32) ) } as u64;
	// 827EA088: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 827EA08C: 807EAC34  lwz r3, -0x53cc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-21452 as u32) ) } as u64;
	// 827EA090: 909CAC38  stw r4, -0x53c8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-21448 as u32), ctx.r[4].u32 ) };
	// 827EA094: 4BFFF5F5  bl 0x827e9688
	ctx.lr = 0x827EA098;
	sub_827E9688(ctx, base);
	// 827EA098: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EA09C: 419A000C  beq cr6, 0x827ea0a8
	if ctx.cr[6].eq {
	pc = 0x827EA0A8; continue 'dispatch;
	}
	// 827EA0A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EA0A4: 4BAD67ED  bl 0x822c0890
	ctx.lr = 0x827EA0A8;
	sub_822C0890(ctx, base);
	// 827EA0A8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827EA0AC: 489BE10C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA0B0 size=100
    let mut pc: u32 = 0x827EA0B0;
    'dispatch: loop {
        match pc {
            0x827EA0B0 => {
    //   block [0x827EA0B0..0x827EA114)
	// 827EA0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA0B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA0BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA0C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA0C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA0C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA0CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EA0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA0D4: 4E800421  bctrl
	ctx.lr = 0x827EA0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA0D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EA0E0: 419A0018  beq cr6, 0x827ea0f8
	if ctx.cr[6].eq {
	pc = 0x827EA0F8; continue 'dispatch;
	}
	// 827EA0E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA0E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827EA0EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA0F4: 4E800421  bctrl
	ctx.lr = 0x827EA0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA0F8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827EA0FC: 4860932D  bl 0x82df3428
	ctx.lr = 0x827EA100;
	sub_82DF3428(ctx, base);
	// 827EA100: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EA104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA10C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA118 size=96
    let mut pc: u32 = 0x827EA118;
    'dispatch: loop {
        match pc {
            0x827EA118 => {
    //   block [0x827EA118..0x827EA178)
	// 827EA118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA12C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827EA130: 48609AD1  bl 0x82df3c00
	ctx.lr = 0x827EA134;
	sub_82DF3C00(ctx, base);
	// 827EA134: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827EA138: 806B1108  lwz r3, 0x1108(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4360 as u32) ) } as u64;
	// 827EA13C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA140: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA144: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA148: 4E800421  bctrl
	ctx.lr = 0x827EA14C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA14C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 827EA150: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA154: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA15C: 4E800421  bctrl
	ctx.lr = 0x827EA160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA164: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EA168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA16C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA178 size=8
    let mut pc: u32 = 0x827EA178;
    'dispatch: loop {
        match pc {
            0x827EA178 => {
    //   block [0x827EA178..0x827EA180)
	// 827EA178: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 827EA17C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA180 size=8
    let mut pc: u32 = 0x827EA180;
    'dispatch: loop {
        match pc {
            0x827EA180 => {
    //   block [0x827EA180..0x827EA188)
	// 827EA180: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA184: 4BB145E4  b 0x822fe768
	sub_822FE768(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA188 size=8
    let mut pc: u32 = 0x827EA188;
    'dispatch: loop {
        match pc {
            0x827EA188 => {
    //   block [0x827EA188..0x827EA190)
	// 827EA188: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA18C: 4867250C  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA190 size=92
    let mut pc: u32 = 0x827EA190;
    'dispatch: loop {
        match pc {
            0x827EA190 => {
    //   block [0x827EA190..0x827EA1EC)
	// 827EA190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EA19C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA1A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA1A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA1AC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA1B0: 483CA669  bl 0x82bb4818
	ctx.lr = 0x827EA1B4;
	sub_82BB4818(ctx, base);
	// 827EA1B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EA1B8: 4182001C  beq 0x827ea1d4
	if ctx.cr[0].eq {
	pc = 0x827EA1D4; continue 'dispatch;
	}
	// 827EA1BC: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EA1C0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA1C4: 483CB32D  bl 0x82bb54f0
	ctx.lr = 0x827EA1C8;
	sub_82BB54F0(ctx, base);
	// 827EA1C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EA1CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA1D0: 4BB13B19  bl 0x822fdce8
	ctx.lr = 0x827EA1D4;
	sub_822FDCE8(ctx, base);
	// 827EA1D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA1D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA1DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA1E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA1E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA1F0 size=92
    let mut pc: u32 = 0x827EA1F0;
    'dispatch: loop {
        match pc {
            0x827EA1F0 => {
    //   block [0x827EA1F0..0x827EA24C)
	// 827EA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA1F4: 489BDF71  bl 0x831a8164
	ctx.lr = 0x827EA1F8;
	sub_831A8130(ctx, base);
	// 827EA1F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA200: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA204: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827EA208: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 827EA20C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 827EA210: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA214: 483CA605  bl 0x82bb4818
	ctx.lr = 0x827EA218;
	sub_82BB4818(ctx, base);
	// 827EA218: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EA21C: 41820028  beq 0x827ea244
	if ctx.cr[0].eq {
	pc = 0x827EA244; continue 'dispatch;
	}
	// 827EA220: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 827EA224: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EA228: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 827EA22C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA230: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EA234: 483CB61D  bl 0x82bb5850
	ctx.lr = 0x827EA238;
	sub_82BB5850(ctx, base);
	// 827EA238: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EA23C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA240: 4BB13AA9  bl 0x822fdce8
	ctx.lr = 0x827EA244;
	sub_822FDCE8(ctx, base);
	// 827EA244: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EA248: 489BDF6C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA250 size=12
    let mut pc: u32 = 0x827EA250;
    'dispatch: loop {
        match pc {
            0x827EA250 => {
    //   block [0x827EA250..0x827EA25C)
	// 827EA250: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EA258: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA25C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA25C size=8
    let mut pc: u32 = 0x827EA25C;
    'dispatch: loop {
        match pc {
            0x827EA25C => {
    //   block [0x827EA25C..0x827EA264)
	// 827EA25C: 4BB13A8C  b 0x822fdce8
	sub_822FDCE8(ctx, base);
	return;
	// 827EA260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA268 size=8
    let mut pc: u32 = 0x827EA268;
    'dispatch: loop {
        match pc {
            0x827EA268 => {
    //   block [0x827EA268..0x827EA270)
	// 827EA268: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA26C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x827EA270 size=52
    let mut pc: u32 = 0x827EA270;
    'dispatch: loop {
        match pc {
            0x827EA270 => {
    //   block [0x827EA270..0x827EA2A4)
	// 827EA270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EA274: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EA278: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 827EA27C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 827EA280: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 827EA284: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EA288: D1A1FFF8  stfs f13, -8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 827EA28C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EA290: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 827EA294: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 827EA298: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA2A8 size=8
    let mut pc: u32 = 0x827EA2A8;
    'dispatch: loop {
        match pc {
            0x827EA2A8 => {
    //   block [0x827EA2A8..0x827EA2B0)
	// 827EA2A8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA2AC: 4BB13FAC  b 0x822fe258
	sub_822FE258(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA2B0 size=84
    let mut pc: u32 = 0x827EA2B0;
    'dispatch: loop {
        match pc {
            0x827EA2B0 => {
    //   block [0x827EA2B0..0x827EA304)
	// 827EA2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA2BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827EA2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA2C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA2C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA2CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA2D0: 4BB13F89  bl 0x822fe258
	ctx.lr = 0x827EA2D4;
	sub_822FE258(ctx, base);
	// 827EA2D4: 486098D5  bl 0x82df3ba8
	ctx.lr = 0x827EA2D8;
	sub_82DF3BA8(ctx, base);
	// 827EA2D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EA2DC: 40820010  bne 0x827ea2ec
	if !ctx.cr[0].eq {
	pc = 0x827EA2EC; continue 'dispatch;
	}
	// 827EA2E0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA2E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EA2E8: 4BB12F41  bl 0x822fd228
	ctx.lr = 0x827EA2EC;
	sub_822FD228(ctx, base);
	// 827EA2EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA2F8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA308 size=8
    let mut pc: u32 = 0x827EA308;
    'dispatch: loop {
        match pc {
            0x827EA308 => {
    //   block [0x827EA308..0x827EA310)
	// 827EA308: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA30C: 4BB14064  b 0x822fe370
	sub_822FE370(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA310 size=8
    let mut pc: u32 = 0x827EA310;
    'dispatch: loop {
        match pc {
            0x827EA310 => {
    //   block [0x827EA310..0x827EA318)
	// 827EA310: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA314: 4BB13CBC  b 0x822fdfd0
	sub_822FDFD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA318 size=8
    let mut pc: u32 = 0x827EA318;
    'dispatch: loop {
        match pc {
            0x827EA318 => {
    //   block [0x827EA318..0x827EA320)
	// 827EA318: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA31C: 4BB13D44  b 0x822fe060
	sub_822FE060(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA320 size=8
    let mut pc: u32 = 0x827EA320;
    'dispatch: loop {
        match pc {
            0x827EA320 => {
    //   block [0x827EA320..0x827EA328)
	// 827EA320: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA324: 4BB1361C  b 0x822fd940
	sub_822FD940(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA328 size=12
    let mut pc: u32 = 0x827EA328;
    'dispatch: loop {
        match pc {
            0x827EA328 => {
    //   block [0x827EA328..0x827EA334)
	// 827EA328: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA32C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EA330: 4BB13588  b 0x822fd8b8
	sub_822FD8B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA338 size=12
    let mut pc: u32 = 0x827EA338;
    'dispatch: loop {
        match pc {
            0x827EA338 => {
    //   block [0x827EA338..0x827EA344)
	// 827EA338: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA33C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EA340: 4BB134F0  b 0x822fd830
	sub_822FD830(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA348 size=12
    let mut pc: u32 = 0x827EA348;
    'dispatch: loop {
        match pc {
            0x827EA348 => {
    //   block [0x827EA348..0x827EA354)
	// 827EA348: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA34C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EA350: 4BB13460  b 0x822fd7b0
	sub_822FD7B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA358 size=8
    let mut pc: u32 = 0x827EA358;
    'dispatch: loop {
        match pc {
            0x827EA358 => {
    //   block [0x827EA358..0x827EA360)
	// 827EA358: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA35C: 4BB13314  b 0x822fd670
	sub_822FD670(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA360 size=8
    let mut pc: u32 = 0x827EA360;
    'dispatch: loop {
        match pc {
            0x827EA360 => {
    //   block [0x827EA360..0x827EA368)
	// 827EA360: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA364: 4BB1329C  b 0x822fd600
	sub_822FD600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA368 size=8
    let mut pc: u32 = 0x827EA368;
    'dispatch: loop {
        match pc {
            0x827EA368 => {
    //   block [0x827EA368..0x827EA370)
	// 827EA368: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA36C: 4BB13F9C  b 0x822fe308
	sub_822FE308(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA370 size=8
    let mut pc: u32 = 0x827EA370;
    'dispatch: loop {
        match pc {
            0x827EA370 => {
    //   block [0x827EA370..0x827EA378)
	// 827EA370: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA374: 4BB140EC  b 0x822fe460
	sub_822FE460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA378 size=8
    let mut pc: u32 = 0x827EA378;
    'dispatch: loop {
        match pc {
            0x827EA378 => {
    //   block [0x827EA378..0x827EA380)
	// 827EA378: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA37C: 483C8E4C  b 0x82bb31c8
	sub_82BB31C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA380 size=196
    let mut pc: u32 = 0x827EA380;
    'dispatch: loop {
        match pc {
            0x827EA380 => {
    //   block [0x827EA380..0x827EA444)
	// 827EA380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EA38C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA390: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 827EA394: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA39C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA3A0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 827EA3A4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 827EA3A8: 392BFFE0  addi r9, r11, -0x20
	ctx.r[9].s64 = ctx.r[11].s64 + -32;
	// 827EA3AC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 827EA3B0: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EA3B4: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA448 size=64
    let mut pc: u32 = 0x827EA448;
    'dispatch: loop {
        match pc {
            0x827EA448 => {
    //   block [0x827EA448..0x827EA488)
	// 827EA448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA454: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA460: 4BFFFF21  bl 0x827ea380
	ctx.lr = 0x827EA464;
	sub_827EA380(ctx, base);
	// 827EA464: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827EA468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA46C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA488 size=84
    let mut pc: u32 = 0x827EA488;
    'dispatch: loop {
        match pc {
            0x827EA488 => {
    //   block [0x827EA488..0x827EA4DC)
	// 827EA488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA490: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA494: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA4A0: 4BFFFEE1  bl 0x827ea380
	ctx.lr = 0x827EA4A4;
	sub_827EA380(ctx, base);
	// 827EA4A4: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EA4A8: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EA4AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA4B0: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827EA4B4: C161006C  lfs f11, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827EA4B8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827EA4BC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 827EA4C0: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 827EA4C4: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 827EA4C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EA4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA4E0 size=60
    let mut pc: u32 = 0x827EA4E0;
    'dispatch: loop {
        match pc {
            0x827EA4E0 => {
    //   block [0x827EA4E0..0x827EA51C)
	// 827EA4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA4E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA4EC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 827EA4F0: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA4F8: 4BB13999  bl 0x822fde90
	ctx.lr = 0x827EA4FC;
	sub_822FDE90(ctx, base);
	// 827EA4FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EA504: 419A0008  beq cr6, 0x827ea50c
	if ctx.cr[6].eq {
	pc = 0x827EA50C; continue 'dispatch;
	}
	// 827EA508: 4BAD6389  bl 0x822c0890
	ctx.lr = 0x827EA50C;
	sub_822C0890(ctx, base);
	// 827EA50C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EA510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA520 size=116
    let mut pc: u32 = 0x827EA520;
    'dispatch: loop {
        match pc {
            0x827EA520 => {
    //   block [0x827EA520..0x827EA594)
	// 827EA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA52C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827EA530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA538: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA53C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA540: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA548: 4E800421  bctrl
	ctx.lr = 0x827EA54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA54C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EA550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA554: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EA558: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EA55C: 483C875D  bl 0x82bb2cb8
	ctx.lr = 0x827EA560;
	sub_82BB2CB8(ctx, base);
	// 827EA560: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA564: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA56C: 419A000C  beq cr6, 0x827ea578
	if ctx.cr[6].eq {
	pc = 0x827EA578; continue 'dispatch;
	}
	// 827EA570: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EA574: 4BAD631D  bl 0x822c0890
	ctx.lr = 0x827EA578;
	sub_822C0890(ctx, base);
	// 827EA578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA57C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA588: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA598 size=100
    let mut pc: u32 = 0x827EA598;
    'dispatch: loop {
        match pc {
            0x827EA598 => {
    //   block [0x827EA598..0x827EA5FC)
	// 827EA598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA5A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA5A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA5AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA5B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA5B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA5B8: 4E800421  bctrl
	ctx.lr = 0x827EA5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA5BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EA5C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA5C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EA5C8: 483C8601  bl 0x82bb2bc8
	ctx.lr = 0x827EA5CC;
	sub_82BB2BC8(ctx, base);
	// 827EA5CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA5D0: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA5D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA5D8: 419A000C  beq cr6, 0x827ea5e4
	if ctx.cr[6].eq {
	pc = 0x827EA5E4; continue 'dispatch;
	}
	// 827EA5DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EA5E0: 4BAD62B1  bl 0x822c0890
	ctx.lr = 0x827EA5E4;
	sub_822C0890(ctx, base);
	// 827EA5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA5E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA5EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA5F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA600 size=76
    let mut pc: u32 = 0x827EA600;
    'dispatch: loop {
        match pc {
            0x827EA600 => {
    //   block [0x827EA600..0x827EA64C)
	// 827EA600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EA60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA61C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827EA620: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 827EA624: 4BAE0A45  bl 0x822cb068
	ctx.lr = 0x827EA628;
	sub_822CB068(ctx, base);
	// 827EA628: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA630: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EA634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA63C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA650 size=112
    let mut pc: u32 = 0x827EA650;
    'dispatch: loop {
        match pc {
            0x827EA650 => {
    //   block [0x827EA650..0x827EA6C0)
	// 827EA650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA654: 489BDB19  bl 0x831a816c
	ctx.lr = 0x827EA658;
	sub_831A8130(ctx, base);
	// 827EA658: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA65C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EA660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA664: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827EA668: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA66C: 483CB1DD  bl 0x82bb5848
	ctx.lr = 0x827EA670;
	sub_82BB5848(ctx, base);
	// 827EA670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EA674: 419A0044  beq cr6, 0x827ea6b8
	if ctx.cr[6].eq {
	pc = 0x827EA6B8; continue 'dispatch;
	}
	// 827EA678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA67C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA680: 48609389  bl 0x82df3a08
	ctx.lr = 0x827EA684;
	sub_82DF3A08(ctx, base);
	// 827EA684: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EA688: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EA68C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA690: 4BB142E9  bl 0x822fe978
	ctx.lr = 0x827EA694;
	sub_822FE978(ctx, base);
	// 827EA694: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EA698: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EA69C: 419A0008  beq cr6, 0x827ea6a4
	if ctx.cr[6].eq {
	pc = 0x827EA6A4; continue 'dispatch;
	}
	// 827EA6A0: 4BAD61F1  bl 0x822c0890
	ctx.lr = 0x827EA6A4;
	sub_822C0890(ctx, base);
	// 827EA6A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA6A8: 48608D81  bl 0x82df3428
	ctx.lr = 0x827EA6AC;
	sub_82DF3428(ctx, base);
	// 827EA6AC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 827EA6B0: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 827EA6B4: 4082FFC4  bne 0x827ea678
	if !ctx.cr[0].eq {
	pc = 0x827EA678; continue 'dispatch;
	}
	// 827EA6B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EA6BC: 489BDB00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA6C0 size=8
    let mut pc: u32 = 0x827EA6C0;
    'dispatch: loop {
        match pc {
            0x827EA6C0 => {
    //   block [0x827EA6C0..0x827EA6C8)
	// 827EA6C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EA6C4: 4BFFFF8C  b 0x827ea650
	sub_827EA650(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EA6C8 size=168
    let mut pc: u32 = 0x827EA6C8;
    'dispatch: loop {
        match pc {
            0x827EA6C8 => {
    //   block [0x827EA6C8..0x827EA770)
	// 827EA6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA6D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EA6D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA6D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA6DC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EA6E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA6E4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA6E8: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 827EA6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA6F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EA6F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EA6F8: 419A0024  beq cr6, 0x827ea71c
	if ctx.cr[6].eq {
	pc = 0x827EA71C; continue 'dispatch;
	}
	// 827EA6FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EA700: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EA704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA708: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EA70C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EA710: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EA714: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA718: 4082FFE8  bne 0x827ea700
	if !ctx.cr[0].eq {
	pc = 0x827EA700; continue 'dispatch;
	}
	// 827EA71C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EA720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EA724: 4862A84D  bl 0x82e14f70
	ctx.lr = 0x827EA728;
	sub_82E14F70(ctx, base);
	// 827EA728: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EA730: 419A0008  beq cr6, 0x827ea738
	if ctx.cr[6].eq {
	pc = 0x827EA738; continue 'dispatch;
	}
	// 827EA734: 4BAD615D  bl 0x822c0890
	ctx.lr = 0x827EA738;
	sub_822C0890(ctx, base);
	// 827EA738: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EA73C: 486140A5  bl 0x82dfe7e0
	ctx.lr = 0x827EA740;
	sub_82DFE7E0(ctx, base);
	// 827EA740: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EA744: 41820014  beq 0x827ea758
	if ctx.cr[0].eq {
	pc = 0x827EA758; continue 'dispatch;
	}
	// 827EA748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EA74C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA750: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EA754: 483CAD9D  bl 0x82bb54f0
	ctx.lr = 0x827EA758;
	sub_82BB54F0(ctx, base);
	// 827EA758: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA75C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA764: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA770 size=24
    let mut pc: u32 = 0x827EA770;
    'dispatch: loop {
        match pc {
            0x827EA770 => {
    //   block [0x827EA770..0x827EA788)
	// 827EA770: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA774: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EA778: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EA77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA780: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827EA784: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EA788 size=36
    let mut pc: u32 = 0x827EA788;
    'dispatch: loop {
        match pc {
            0x827EA788 => {
    //   block [0x827EA788..0x827EA7AC)
	// 827EA788: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EA78C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EA790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA794: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EA798: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EA79C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EA7A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA7A4: 4082FFE8  bne 0x827ea78c
	if !ctx.cr[0].eq {
	pc = 0x827EA78C; continue 'dispatch;
	}
	// 827EA7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA7B0 size=84
    let mut pc: u32 = 0x827EA7B0;
    'dispatch: loop {
        match pc {
            0x827EA7B0 => {
    //   block [0x827EA7B0..0x827EA804)
	// 827EA7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA7B4: 489BD9B9  bl 0x831a816c
	ctx.lr = 0x827EA7B8;
	sub_831A8130(ctx, base);
	// 827EA7B8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 827EA7BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA7C0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827EA7C4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EA7C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA7CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA7D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EA7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA7D8: 4BDA1739  bl 0x8258bf10
	ctx.lr = 0x827EA7DC;
	sub_8258BF10(ctx, base);
	// 827EA7DC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 827EA7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EA7E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EA7E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EA7EC: 4BB13325  bl 0x822fdb10
	ctx.lr = 0x827EA7F0;
	sub_822FDB10(ctx, base);
	// 827EA7F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EA7F4: 4BADE4C5  bl 0x822c8cb8
	ctx.lr = 0x827EA7F8;
	sub_822C8CB8(ctx, base);
	// 827EA7F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EA7FC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 827EA800: 489BD9BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA808 size=68
    let mut pc: u32 = 0x827EA808;
    'dispatch: loop {
        match pc {
            0x827EA808 => {
    //   block [0x827EA808..0x827EA84C)
	// 827EA808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA80C: 489BD961  bl 0x831a816c
	ctx.lr = 0x827EA810;
	sub_831A8130(ctx, base);
	// 827EA810: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA814: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EA818: 83A3000C  lwz r29, 0xc(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA81C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EA824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA828: 4BDA16E9  bl 0x8258bf10
	ctx.lr = 0x827EA82C;
	sub_8258BF10(ctx, base);
	// 827EA82C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827EA830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EA834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EA838: 483C7BB1  bl 0x82bb23e8
	ctx.lr = 0x827EA83C;
	sub_82BB23E8(ctx, base);
	// 827EA83C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EA840: 4BADE479  bl 0x822c8cb8
	ctx.lr = 0x827EA844;
	sub_822C8CB8(ctx, base);
	// 827EA844: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EA848: 489BD974  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA850 size=120
    let mut pc: u32 = 0x827EA850;
    'dispatch: loop {
        match pc {
            0x827EA850 => {
    //   block [0x827EA850..0x827EA8C8)
	// 827EA850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA858: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA85C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827EA860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA864: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA86C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA870: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EA878: 4E800421  bctrl
	ctx.lr = 0x827EA87C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EA87C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EA880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA884: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EA888: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EA88C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EA890: 483C8391  bl 0x82bb2c20
	ctx.lr = 0x827EA894;
	sub_82BB2C20(ctx, base);
	// 827EA894: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EA898: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EA89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA8A0: 419A000C  beq cr6, 0x827ea8ac
	if ctx.cr[6].eq {
	pc = 0x827EA8AC; continue 'dispatch;
	}
	// 827EA8A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EA8A8: 4BAD5FE9  bl 0x822c0890
	ctx.lr = 0x827EA8AC;
	sub_822C0890(ctx, base);
	// 827EA8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA8B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA8B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA8B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA8BC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA8C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA8C8 size=156
    let mut pc: u32 = 0x827EA8C8;
    'dispatch: loop {
        match pc {
            0x827EA8C8 => {
    //   block [0x827EA8C8..0x827EA964)
	// 827EA8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EA8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EA8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EA8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA8DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EA8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EA8E4: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 827EA8E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA8EC: 4800BEDD  bl 0x827f67c8
	ctx.lr = 0x827EA8F0;
	sub_827F67C8(ctx, base);
	// 827EA8F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EA8F4: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827EA8F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827EA8FC: 419A0040  beq cr6, 0x827ea93c
	if ctx.cr[6].eq {
	pc = 0x827EA93C; continue 'dispatch;
	}
	// 827EA900: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EA904: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EA908: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EA90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA910: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827EA914: 419A0034  beq cr6, 0x827ea948
	if ctx.cr[6].eq {
	pc = 0x827EA948; continue 'dispatch;
	}
	// 827EA918: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EA91C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EA920: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA924: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EA928: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EA92C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EA930: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EA934: 4082FFE8  bne 0x827ea91c
	if !ctx.cr[0].eq {
	pc = 0x827EA91C; continue 'dispatch;
	}
	// 827EA938: 48000010  b 0x827ea948
	pc = 0x827EA948; continue 'dispatch;
	// 827EA93C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EA940: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EA944: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827EA948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EA94C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EA950: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EA954: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EA958: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EA95C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EA960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EA968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EA968 size=396
    let mut pc: u32 = 0x827EA968;
    'dispatch: loop {
        match pc {
            0x827EA968 => {
    //   block [0x827EA968..0x827EAAF4)
	// 827EA968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EA96C: 489BD7FD  bl 0x831a8168
	ctx.lr = 0x827EA970;
	sub_831A8130(ctx, base);
	// 827EA970: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 827EA974: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EA978: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EA97C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EA980: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EA984: 3B8B5C20  addi r28, r11, 0x5c20
	ctx.r[28].s64 = ctx.r[11].s64 + 23584;
	// 827EA988: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EA98C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EA990: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EA994: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 827EA998: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EA99C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 827EA9A0: 48607A49  bl 0x82df23e8
	ctx.lr = 0x827EA9A4;
	sub_82DF23E8(ctx, base);
	// 827EA9A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EA9A8: 41820018  beq 0x827ea9c0
	if ctx.cr[0].eq {
	pc = 0x827EA9C0; continue 'dispatch;
	}
	// 827EA9AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EA9B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EA9B4: 483C924D  bl 0x82bb3c00
	ctx.lr = 0x827EA9B8;
	sub_82BB3C00(ctx, base);
	// 827EA9B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EA9BC: 48000008  b 0x827ea9c4
	pc = 0x827EA9C4; continue 'dispatch;
	// 827EA9C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827EA9C4: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 827EA9C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EA9CC: 4BB72A15  bl 0x8235d3e0
	ctx.lr = 0x827EA9D0;
	sub_8235D3E0(ctx, base);
	// 827EA9D0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EA9D4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EA9D8: 483C2F61  bl 0x82bad938
	ctx.lr = 0x827EA9DC;
	sub_82BAD938(ctx, base);
	// 827EA9DC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827EA9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EA9E4: 3BEBAC64  addi r31, r11, -0x539c
	ctx.r[31].s64 = ctx.r[11].s64 + -21404;
	// 827EA9E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EA9EC: 481DDD6D  bl 0x829c8758
	ctx.lr = 0x827EA9F0;
	sub_829C8758(ctx, base);
	// 827EA9F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EA9F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EA9F8: 409A0088  bne cr6, 0x827eaa80
	if !ctx.cr[6].eq {
	pc = 0x827EAA80; continue 'dispatch;
	}
	// 827EA9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EAA00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EAA04: 481DDD55  bl 0x829c8758
	ctx.lr = 0x827EAA08;
	sub_829C8758(ctx, base);
	// 827EAA08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EAA0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EAA10: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 827EAA14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAA18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827EAA1C: 4BAD9A45  bl 0x822c4460
	ctx.lr = 0x827EAA20;
	sub_822C4460(ctx, base);
	// 827EAA20: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EAA24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAA28: 419A0008  beq cr6, 0x827eaa30
	if ctx.cr[6].eq {
	pc = 0x827EAA30; continue 'dispatch;
	}
	// 827EAA2C: 4BAD5E65  bl 0x822c0890
	ctx.lr = 0x827EAA30;
	sub_822C0890(ctx, base);
	// 827EAA30: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EAA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EAA38: 409A0048  bne cr6, 0x827eaa80
	if !ctx.cr[6].eq {
	pc = 0x827EAA80; continue 'dispatch;
	}
	// 827EAA3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EAA40: 483C5859  bl 0x82bb0298
	ctx.lr = 0x827EAA44;
	sub_82BB0298(ctx, base);
	// 827EAA44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EAA48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EAA4C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 827EAA50: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAA54: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827EAA58: 4BAD9A09  bl 0x822c4460
	ctx.lr = 0x827EAA5C;
	sub_822C4460(ctx, base);
	// 827EAA5C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827EAA60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAA64: 419A0008  beq cr6, 0x827eaa6c
	if ctx.cr[6].eq {
	pc = 0x827EAA6C; continue 'dispatch;
	}
	// 827EAA68: 4BAD5E29  bl 0x822c0890
	ctx.lr = 0x827EAA6C;
	sub_822C0890(ctx, base);
	// 827EAA6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EAA70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EAA74: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827EAA78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EAA7C: 4BD0B835  bl 0x824f62b0
	ctx.lr = 0x827EAA80;
	sub_824F62B0(ctx, base);
	// 827EAA80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EAA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EAA88: 419A0010  beq cr6, 0x827eaa98
	if ctx.cr[6].eq {
	pc = 0x827EAA98; continue 'dispatch;
	}
	// 827EAA8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EAA90: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAA94: 483C4B2D  bl 0x82baf5c0
	ctx.lr = 0x827EAA98;
	sub_82BAF5C0(ctx, base);
	// 827EAA98: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EAA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAAA0: 419A0008  beq cr6, 0x827eaaa8
	if ctx.cr[6].eq {
	pc = 0x827EAAA8; continue 'dispatch;
	}
	// 827EAAA4: 4BAD5DED  bl 0x822c0890
	ctx.lr = 0x827EAAA8;
	sub_822C0890(ctx, base);
	// 827EAAA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EAAAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EAAB0: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 827EAAB4: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 827EAAB8: 48607931  bl 0x82df23e8
	ctx.lr = 0x827EAABC;
	sub_82DF23E8(ctx, base);
	// 827EAABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EAAC0: 41820010  beq 0x827eaad0
	if ctx.cr[0].eq {
	pc = 0x827EAAD0; continue 'dispatch;
	}
	// 827EAAC4: 4BB13EED  bl 0x822fe9b0
	ctx.lr = 0x827EAAC8;
	sub_822FE9B0(ctx, base);
	// 827EAAC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EAACC: 48000008  b 0x827eaad4
	pc = 0x827EAAD4; continue 'dispatch;
	// 827EAAD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827EAAD4: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 827EAAD8: 4BB72979  bl 0x8235d450
	ctx.lr = 0x827EAADC;
	sub_8235D450(ctx, base);
	// 827EAADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EAAE0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EAAE4: 4BDF2C25  bl 0x825dd708
	ctx.lr = 0x827EAAE8;
	sub_825DD708(ctx, base);
	// 827EAAE8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EAAEC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 827EAAF0: 489BD6C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAAF8 size=344
    let mut pc: u32 = 0x827EAAF8;
    'dispatch: loop {
        match pc {
            0x827EAAF8 => {
    //   block [0x827EAAF8..0x827EAC50)
	// 827EAAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAAFC: 489BD66D  bl 0x831a8168
	ctx.lr = 0x827EAB00;
	sub_831A8130(ctx, base);
	// 827EAB00: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAB04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAB08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EAB0C: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 827EAB10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EAB14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827EAB18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EAB1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EAB20: 4800BCA9  bl 0x827f67c8
	ctx.lr = 0x827EAB24;
	sub_827F67C8(ctx, base);
	// 827EAB24: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827EAB28: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EAB2C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827EAB30: 409A0118  bne cr6, 0x827eac48
	if !ctx.cr[6].eq {
	pc = 0x827EAC48; continue 'dispatch;
	}
	// 827EAB34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EAB38: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EAB40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 827EAB44: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827EAB48: 419A0024  beq cr6, 0x827eab6c
	if ctx.cr[6].eq {
	pc = 0x827EAB6C; continue 'dispatch;
	}
	// 827EAB4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EAB50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EAB54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EAB58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EAB5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EAB60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EAB64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EAB68: 4082FFE8  bne 0x827eab50
	if !ctx.cr[0].eq {
	pc = 0x827EAB50; continue 'dispatch;
	}
	// 827EAB6C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827EAB70: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EAB74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EAB78: 4BB13BF1  bl 0x822fe768
	ctx.lr = 0x827EAB7C;
	sub_822FE768(ctx, base);
	// 827EAB7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EAB80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAB84: 419A0008  beq cr6, 0x827eab8c
	if ctx.cr[6].eq {
	pc = 0x827EAB8C; continue 'dispatch;
	}
	// 827EAB88: 4BAD5D09  bl 0x822c0890
	ctx.lr = 0x827EAB8C;
	sub_822C0890(ctx, base);
	// 827EAB8C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EAB90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAB94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EAB98: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 827EAB9C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827EABA0: 419A0024  beq cr6, 0x827eabc4
	if ctx.cr[6].eq {
	pc = 0x827EABC4; continue 'dispatch;
	}
	// 827EABA4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827EABA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EABAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EABB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EABB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EABB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EABBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EABC0: 4082FFE8  bne 0x827eaba8
	if !ctx.cr[0].eq {
	pc = 0x827EABA8; continue 'dispatch;
	}
	// 827EABC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EABC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EABCC: 48609035  bl 0x82df3c00
	ctx.lr = 0x827EABD0;
	sub_82DF3C00(ctx, base);
	// 827EABD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EABD4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827EABD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EABDC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827EABE0: 482A0C31  bl 0x82a8b810
	ctx.lr = 0x827EABE4;
	sub_82A8B810(ctx, base);
	// 827EABE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EABE8: 48608841  bl 0x82df3428
	ctx.lr = 0x827EABEC;
	sub_82DF3428(ctx, base);
	// 827EABEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EABF0: 419A000C  beq cr6, 0x827eabfc
	if ctx.cr[6].eq {
	pc = 0x827EABFC; continue 'dispatch;
	}
	// 827EABF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EABF8: 4BAD5C99  bl 0x822c0890
	ctx.lr = 0x827EABFC;
	sub_822C0890(ctx, base);
	// 827EABFC: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 827EAC00: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827EAC04: 4839ABAD  bl 0x82b857b0
	ctx.lr = 0x827EAC08;
	sub_82B857B0(ctx, base);
	// 827EAC08: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 827EAC0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EAC10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EAC14: 4839BDAD  bl 0x82b869c0
	ctx.lr = 0x827EAC18;
	sub_82B869C0(ctx, base);
	// 827EAC18: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827EAC1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAC20: 419A0008  beq cr6, 0x827eac28
	if ctx.cr[6].eq {
	pc = 0x827EAC28; continue 'dispatch;
	}
	// 827EAC24: 4BAD5C6D  bl 0x822c0890
	ctx.lr = 0x827EAC28;
	sub_822C0890(ctx, base);
	// 827EAC28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827EAC2C: 486087FD  bl 0x82df3428
	ctx.lr = 0x827EAC30;
	sub_82DF3428(ctx, base);
	// 827EAC30: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 827EAC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAC38: 419A0008  beq cr6, 0x827eac40
	if ctx.cr[6].eq {
	pc = 0x827EAC40; continue 'dispatch;
	}
	// 827EAC3C: 4BAD5C55  bl 0x822c0890
	ctx.lr = 0x827EAC40;
	sub_822C0890(ctx, base);
	// 827EAC40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827EAC44: 486087E5  bl 0x82df3428
	ctx.lr = 0x827EAC48;
	sub_82DF3428(ctx, base);
	// 827EAC48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EAC4C: 489BD56C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAC50 size=92
    let mut pc: u32 = 0x827EAC50;
    'dispatch: loop {
        match pc {
            0x827EAC50 => {
    //   block [0x827EAC50..0x827EACAC)
	// 827EAC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAC58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAC5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAC60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAC64: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EAC68: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 827EAC6C: 396B5C5C  addi r11, r11, 0x5c5c
	ctx.r[11].s64 = ctx.r[11].s64 + 23644;
	// 827EAC70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EAC74: 4BDC549D  bl 0x825b0110
	ctx.lr = 0x827EAC78;
	sub_825B0110(ctx, base);
	// 827EAC78: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EAC7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAC80: 419A0008  beq cr6, 0x827eac88
	if ctx.cr[6].eq {
	pc = 0x827EAC88; continue 'dispatch;
	}
	// 827EAC84: 4BAD5C0D  bl 0x822c0890
	ctx.lr = 0x827EAC88;
	sub_822C0890(ctx, base);
	// 827EAC88: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EAC8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EAC90: 419A0008  beq cr6, 0x827eac98
	if ctx.cr[6].eq {
	pc = 0x827EAC98; continue 'dispatch;
	}
	// 827EAC94: 4BAD5BFD  bl 0x822c0890
	ctx.lr = 0x827EAC98;
	sub_822C0890(ctx, base);
	// 827EAC98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EAC9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EACA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EACA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EACA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EACB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EACB0 size=104
    let mut pc: u32 = 0x827EACB0;
    'dispatch: loop {
        match pc {
            0x827EACB0 => {
    //   block [0x827EACB0..0x827EAD18)
	// 827EACB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EACB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EACB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EACBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EACC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EACC4: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827EACC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EACCC: 394A5C5C  addi r10, r10, 0x5c5c
	ctx.r[10].s64 = ctx.r[10].s64 + 23644;
	// 827EACD0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 827EACD4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EACD8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827EACDC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827EACE0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827EACE4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 827EACE8: 4BFB0F11  bl 0x8279bbf8
	ctx.lr = 0x827EACEC;
	sub_8279BBF8(ctx, base);
	// 827EACEC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 827EACF0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 827EACF4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 827EACF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EACFC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAD18 size=76
    let mut pc: u32 = 0x827EAD18;
    'dispatch: loop {
        match pc {
            0x827EAD18 => {
    //   block [0x827EAD18..0x827EAD64)
	// 827EAD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAD20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EAD24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAD28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAD2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAD30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EAD34: 4BFFFF1D  bl 0x827eac50
	ctx.lr = 0x827EAD38;
	sub_827EAC50(ctx, base);
	// 827EAD38: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EAD3C: 4182000C  beq 0x827ead48
	if ctx.cr[0].eq {
	pc = 0x827EAD48; continue 'dispatch;
	}
	// 827EAD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EAD44: 4BAD5525  bl 0x822c0268
	ctx.lr = 0x827EAD48;
	sub_822C0268(ctx, base);
	// 827EAD48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EAD4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EAD50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EAD54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EAD58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EAD5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EAD60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAD68 size=96
    let mut pc: u32 = 0x827EAD68;
    'dispatch: loop {
        match pc {
            0x827EAD68 => {
    //   block [0x827EAD68..0x827EADC8)
	// 827EAD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAD6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAD70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAD74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAD78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAD7C: 48002615  bl 0x827ed390
	ctx.lr = 0x827EAD80;
	sub_827ED390(ctx, base);
	// 827EAD80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 827EAD84: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827EAD88: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 827EAD8C: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827EAD90: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 827EAD94: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 827EAD98: 394A5CDC  addi r10, r10, 0x5cdc
	ctx.r[10].s64 = ctx.r[10].s64 + 23772;
	// 827EAD9C: 39295CC8  addi r9, r9, 0x5cc8
	ctx.r[9].s64 = ctx.r[9].s64 + 23752;
	// 827EADA0: 39685C7C  addi r11, r8, 0x5c7c
	ctx.r[11].s64 = ctx.r[8].s64 + 23676;
	// 827EADA4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EADA8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 827EADAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EADB0: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 827EADB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EADB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EADBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EADC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EADC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EADC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EADC8 size=92
    let mut pc: u32 = 0x827EADC8;
    'dispatch: loop {
        match pc {
            0x827EADC8 => {
    //   block [0x827EADC8..0x827EAE24)
	// 827EADC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EADCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EADD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EADD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EADD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EADDC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EADE0: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827EADE4: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827EADE8: 396B5CDC  addi r11, r11, 0x5cdc
	ctx.r[11].s64 = ctx.r[11].s64 + 23772;
	// 827EADEC: 394A5CC8  addi r10, r10, 0x5cc8
	ctx.r[10].s64 = ctx.r[10].s64 + 23752;
	// 827EADF0: 39295C7C  addi r9, r9, 0x5c7c
	ctx.r[9].s64 = ctx.r[9].s64 + 23676;
	// 827EADF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EADF8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 827EADFC: 387F0208  addi r3, r31, 0x208
	ctx.r[3].s64 = ctx.r[31].s64 + 520;
	// 827EAE00: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 827EAE04: 4BFBC855  bl 0x827a7658
	ctx.lr = 0x827EAE08;
	sub_827A7658(ctx, base);
	// 827EAE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EAE0C: 48001C6D  bl 0x827eca78
	ctx.lr = 0x827EAE10;
	sub_827ECA78(ctx, base);
	// 827EAE10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EAE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EAE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EAE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EAE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAE28 size=152
    let mut pc: u32 = 0x827EAE28;
    'dispatch: loop {
        match pc {
            0x827EAE28 => {
    //   block [0x827EAE28..0x827EAEC0)
	// 827EAE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAE2C: 489BD339  bl 0x831a8164
	ctx.lr = 0x827EAE30;
	sub_831A8130(ctx, base);
	// 827EAE30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAE34: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 827EAE38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EAE40: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827EAE44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EAE48: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 827EAE4C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 827EAE50: 48608BB9  bl 0x82df3a08
	ctx.lr = 0x827EAE54;
	sub_82DF3A08(ctx, base);
	// 827EAE54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EAE58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EAE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EAE60: 4BD1D921  bl 0x82508780
	ctx.lr = 0x827EAE64;
	sub_82508780(ctx, base);
	// 827EAE64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EAE68: 486085C1  bl 0x82df3428
	ctx.lr = 0x827EAE6C;
	sub_82DF3428(ctx, base);
	// 827EAE6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EAE70: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 827EAE74: 409A0008  bne cr6, 0x827eae7c
	if !ctx.cr[6].eq {
	pc = 0x827EAE7C; continue 'dispatch;
	}
	// 827EAE78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827EAE7C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 827EAE80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EAE84: 808BD068  lwz r4, -0x2f98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12184 as u32) ) } as u64;
	// 827EAE88: 48608B81  bl 0x82df3a08
	ctx.lr = 0x827EAE8C;
	sub_82DF3A08(ctx, base);
	// 827EAE8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827EAE90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EAE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EAE98: 4BD1D959  bl 0x825087f0
	ctx.lr = 0x827EAE9C;
	sub_825087F0(ctx, base);
	// 827EAE9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EAEA0: 48608589  bl 0x82df3428
	ctx.lr = 0x827EAEA4;
	sub_82DF3428(ctx, base);
	// 827EAEA4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827EAEA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EAEAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EAEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EAEB4: 48001D05  bl 0x827ecbb8
	ctx.lr = 0x827EAEB8;
	sub_827ECBB8(ctx, base);
	// 827EAEB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EAEBC: 489BD2F8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EAEC0 size=16
    let mut pc: u32 = 0x827EAEC0;
    'dispatch: loop {
        match pc {
            0x827EAEC0 => {
    //   block [0x827EAEC0..0x827EAED0)
	// 827EAEC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827EAEC4: 816B7058  lwz r11, 0x7058(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 827EAEC8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EAECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAED0 size=92
    let mut pc: u32 = 0x827EAED0;
    'dispatch: loop {
        match pc {
            0x827EAED0 => {
    //   block [0x827EAED0..0x827EAF2C)
	// 827EAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EAEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAEE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EAEE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EAEEC: 4800127D  bl 0x827ec168
	ctx.lr = 0x827EAEF0;
	sub_827EC168(ctx, base);
	// 827EAEF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EAEF4: 4800126D  bl 0x827ec160
	ctx.lr = 0x827EAEF8;
	sub_827EC160(ctx, base);
	// 827EAEF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EAEFC: 41820018  beq 0x827eaf14
	if ctx.cr[0].eq {
	pc = 0x827EAF14; continue 'dispatch;
	}
	// 827EAF00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EAF08: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827EAF0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EAF10: 4E800421  bctrl
	ctx.lr = 0x827EAF14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EAF14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EAF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EAF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EAF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EAF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EAF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAF30 size=136
    let mut pc: u32 = 0x827EAF30;
    'dispatch: loop {
        match pc {
            0x827EAF30 => {
    //   block [0x827EAF30..0x827EAFB8)
	// 827EAF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAF38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EAF3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAF40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAF44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EAF48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EAF4C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827EAF50: 409A0020  bne cr6, 0x827eaf70
	if !ctx.cr[6].eq {
	pc = 0x827EAF70; continue 'dispatch;
	}
	// 827EAF54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EAF58: 419A0048  beq cr6, 0x827eafa0
	if ctx.cr[6].eq {
	pc = 0x827EAFA0; continue 'dispatch;
	}
	// 827EAF5C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 827EAF60: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 827EAF64: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 827EAF68: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 827EAF6C: 48000034  b 0x827eafa0
	pc = 0x827EAFA0; continue 'dispatch;
	// 827EAF70: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827EAF74: 419A002C  beq cr6, 0x827eafa0
	if ctx.cr[6].eq {
	pc = 0x827EAFA0; continue 'dispatch;
	}
	// 827EAF78: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827EAF7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAF80: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 827EAF84: 489BD175  bl 0x831a80f8
	ctx.lr = 0x827EAF88;
	sub_831A80F8(ctx, base);
	// 827EAF88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EAF8C: 4182000C  beq 0x827eaf98
	if ctx.cr[0].eq {
	pc = 0x827EAF98; continue 'dispatch;
	}
	// 827EAF90: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827EAF94: 4800000C  b 0x827eafa0
	pc = 0x827EAFA0; continue 'dispatch;
	// 827EAF98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EAF9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EAFA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EAFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EAFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EAFAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EAFB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EAFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EAFB8 size=8
    let mut pc: u32 = 0x827EAFB8;
    'dispatch: loop {
        match pc {
            0x827EAFB8 => {
    //   block [0x827EAFB8..0x827EAFC0)
	// 827EAFB8: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 827EAFBC: 4800007C  b 0x827eb038
	sub_827EB038(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EAFC0 size=16
    let mut pc: u32 = 0x827EAFC0;
    'dispatch: loop {
        match pc {
            0x827EAFC0 => {
    //   block [0x827EAFC0..0x827EAFD0)
	// 827EAFC0: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EAFC4: 816C0050  lwz r11, 0x50(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EAFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EAFCC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EAFD0 size=8
    let mut pc: u32 = 0x827EAFD0;
    'dispatch: loop {
        match pc {
            0x827EAFD0 => {
    //   block [0x827EAFD0..0x827EAFD8)
	// 827EAFD0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 827EAFD4: 48000064  b 0x827eb038
	sub_827EB038(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EAFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EAFD8 size=96
    let mut pc: u32 = 0x827EAFD8;
    'dispatch: loop {
        match pc {
            0x827EAFD8 => {
    //   block [0x827EAFD8..0x827EB038)
	// 827EAFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EAFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EAFE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EAFE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EAFE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EAFEC: 48002555  bl 0x827ed540
	ctx.lr = 0x827EAFF0;
	sub_827ED540(ctx, base);
	// 827EAFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 827EAFF4: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 827EAFF8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 827EAFFC: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 827EB000: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 827EB004: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 827EB008: 394A5CDC  addi r10, r10, 0x5cdc
	ctx.r[10].s64 = ctx.r[10].s64 + 23772;
	// 827EB00C: 39295CC8  addi r9, r9, 0x5cc8
	ctx.r[9].s64 = ctx.r[9].s64 + 23752;
	// 827EB010: 39685C7C  addi r11, r8, 0x5c7c
	ctx.r[11].s64 = ctx.r[8].s64 + 23676;
	// 827EB014: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EB018: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 827EB01C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB020: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 827EB024: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EB028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB038 size=76
    let mut pc: u32 = 0x827EB038;
    'dispatch: loop {
        match pc {
            0x827EB038 => {
    //   block [0x827EB038..0x827EB084)
	// 827EB038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB050: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EB054: 4BFFFD75  bl 0x827eadc8
	ctx.lr = 0x827EB058;
	sub_827EADC8(ctx, base);
	// 827EB058: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB05C: 4182000C  beq 0x827eb068
	if ctx.cr[0].eq {
	pc = 0x827EB068; continue 'dispatch;
	}
	// 827EB060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB064: 48607375  bl 0x82df23d8
	ctx.lr = 0x827EB068;
	sub_82DF23D8(ctx, base);
	// 827EB068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB06C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EB070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB07C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EB088 size=8
    let mut pc: u32 = 0x827EB088;
    'dispatch: loop {
        match pc {
            0x827EB088 => {
    //   block [0x827EB088..0x827EB090)
	// 827EB088: 806301CC  lwz r3, 0x1cc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EB08C: 4BFFF104  b 0x827ea190
	sub_827EA190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB090 size=140
    let mut pc: u32 = 0x827EB090;
    'dispatch: loop {
        match pc {
            0x827EB090 => {
    //   block [0x827EB090..0x827EB11C)
	// 827EB090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB09C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB0A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB0A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB0A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EB0AC: 480010B5  bl 0x827ec160
	ctx.lr = 0x827EB0B0;
	sub_827EC160(ctx, base);
	// 827EB0B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EB0B4: 41820018  beq 0x827eb0cc
	if ctx.cr[0].eq {
	pc = 0x827EB0CC; continue 'dispatch;
	}
	// 827EB0B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB0BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB0C0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827EB0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB0C8: 4E800421  bctrl
	ctx.lr = 0x827EB0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB0CC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EB0D0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EB0D4: 4861370D  bl 0x82dfe7e0
	ctx.lr = 0x827EB0D8;
	sub_82DFE7E0(ctx, base);
	// 827EB0D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB0DC: 4182001C  beq 0x827eb0f8
	if ctx.cr[0].eq {
	pc = 0x827EB0F8; continue 'dispatch;
	}
	// 827EB0E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB0E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB0EC: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB0F4: 4E800421  bctrl
	ctx.lr = 0x827EB0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB0F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB100: 480012C1  bl 0x827ec3c0
	ctx.lr = 0x827EB104;
	sub_827EC3C0(ctx, base);
	// 827EB104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EB108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB10C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB110: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB120 size=92
    let mut pc: u32 = 0x827EB120;
    'dispatch: loop {
        match pc {
            0x827EB120 => {
    //   block [0x827EB120..0x827EB17C)
	// 827EB120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB12C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB134: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827EB138: 817F12C0  lwz r11, 0x12c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4800 as u32) ) } as u64;
	// 827EB13C: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 * 48;
	// 827EB140: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 827EB144: 489BD3CD  bl 0x831a8510
	ctx.lr = 0x827EB148;
	sub_831A8510(ctx, base);
	// 827EB148: 817F12C0  lwz r11, 0x12c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4800 as u32) ) } as u64;
	// 827EB14C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EB150: 917F12C0  stw r11, 0x12c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4800 as u32), ctx.r[11].u32 ) };
	// 827EB154: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827EB158: 2B0B0063  cmplwi cr6, r11, 0x63
	ctx.cr[6].compare_u32(ctx.r[11].u32, 99 as u32, &mut ctx.xer);
	// 827EB15C: 4099000C  ble cr6, 0x827eb168
	if !ctx.cr[6].gt {
	pc = 0x827EB168; continue 'dispatch;
	}
	// 827EB160: 39600063  li r11, 0x63
	ctx.r[11].s64 = 99;
	// 827EB164: 917F12C0  stw r11, 0x12c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4800 as u32), ctx.r[11].u32 ) };
	// 827EB168: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EB16C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB174: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB180 size=96
    let mut pc: u32 = 0x827EB180;
    'dispatch: loop {
        match pc {
            0x827EB180 => {
    //   block [0x827EB180..0x827EB1E0)
	// 827EB180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB18C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB198: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 827EB19C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB1A0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827EB1A4: 4863F945  bl 0x82e2aae8
	ctx.lr = 0x827EB1A8;
	sub_82E2AAE8(ctx, base);
	// 827EB1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB1AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EB1B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EB1B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EB1B8: 48643CB9  bl 0x82e2ee70
	ctx.lr = 0x827EB1BC;
	sub_82E2EE70(ctx, base);
	// 827EB1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB1C0: 4863F941  bl 0x82e2ab00
	ctx.lr = 0x827EB1C4;
	sub_82E2AB00(ctx, base);
	// 827EB1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB1C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EB1CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB1D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB1D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB1D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB1DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB1E0 size=48
    let mut pc: u32 = 0x827EB1E0;
    'dispatch: loop {
        match pc {
            0x827EB1E0 => {
    //   block [0x827EB1E0..0x827EB210)
	// 827EB1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB1E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB1E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB1EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB1F4: 482C0AF5  bl 0x82aabce8
	ctx.lr = 0x827EB1F8;
	sub_82AABCE8(ctx, base);
	// 827EB1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB1FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EB200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB208: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB20C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EB210 size=136
    let mut pc: u32 = 0x827EB210;
    'dispatch: loop {
        match pc {
            0x827EB210 => {
    //   block [0x827EB210..0x827EB298)
	// 827EB210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB21C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB220: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 827EB224: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB22C: 48000F35  bl 0x827ec160
	ctx.lr = 0x827EB230;
	sub_827EC160(ctx, base);
	// 827EB230: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827EB234: 41820048  beq 0x827eb27c
	if ctx.cr[0].eq {
	pc = 0x827EB27C; continue 'dispatch;
	}
	// 827EB238: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB240: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 827EB244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB248: 4E800421  bctrl
	ctx.lr = 0x827EB24C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB24C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB250: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB258: C3EB0000  lfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827EB25C: 48003535  bl 0x827ee790
	ctx.lr = 0x827EB260;
	sub_827EE790(ctx, base);
	// 827EB260: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB264: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EB268: 4BFEED81  bl 0x827d9fe8
	ctx.lr = 0x827EB26C;
	sub_827D9FE8(ctx, base);
	// 827EB26C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB274: 419A0008  beq cr6, 0x827eb27c
	if ctx.cr[6].eq {
	pc = 0x827EB27C; continue 'dispatch;
	}
	// 827EB278: 4BAD5619  bl 0x822c0890
	ctx.lr = 0x827EB27C;
	sub_822C0890(ctx, base);
	// 827EB27C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EB280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB288: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 827EB28C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB298 size=172
    let mut pc: u32 = 0x827EB298;
    'dispatch: loop {
        match pc {
            0x827EB298 => {
    //   block [0x827EB298..0x827EB344)
	// 827EB298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB29C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB2A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB2A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB2A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB2AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EB2B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EB2B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827EB2B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EB2BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EB2C0: 4BAD5679  bl 0x822c0938
	ctx.lr = 0x827EB2C4;
	sub_822C0938(ctx, base);
	// 827EB2C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EB2C8: 41820028  beq 0x827eb2f0
	if ctx.cr[0].eq {
	pc = 0x827EB2F0; continue 'dispatch;
	}
	// 827EB2CC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EB2D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 827EB2D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EB2D8: 392B5D50  addi r9, r11, 0x5d50
	ctx.r[9].s64 = ctx.r[11].s64 + 23888;
	// 827EB2DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827EB2E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB2E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827EB2E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827EB2EC: 48000008  b 0x827eb2f4
	pc = 0x827EB2F4; continue 'dispatch;
	// 827EB2F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EB2F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EB2F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB2FC: 409A002C  bne cr6, 0x827eb328
	if !ctx.cr[6].eq {
	pc = 0x827EB328; continue 'dispatch;
	}
	// 827EB300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB304: 4BAD4F65  bl 0x822c0268
	ctx.lr = 0x827EB308;
	sub_822C0268(ctx, base);
	// 827EB308: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827EB30C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827EB310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB314: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 827EB318: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EB31C: 816BC554  lwz r11, -0x3aac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15020 as u32) ) } as u64;
	// 827EB320: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EB324: 4BAD4CDD  bl 0x822c0000
	ctx.lr = 0x827EB328;
	sub_822C0000(ctx, base);
	// 827EB328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB32C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EB330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB33C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB348 size=72
    let mut pc: u32 = 0x827EB348;
    'dispatch: loop {
        match pc {
            0x827EB348 => {
    //   block [0x827EB348..0x827EB390)
	// 827EB348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB354: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 827EB358: 419A001C  beq cr6, 0x827eb374
	if ctx.cr[6].eq {
	pc = 0x827EB374; continue 'dispatch;
	}
	// 827EB35C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827EB360: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EB364: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 827EB368: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EB36C: 4BFFFBC5  bl 0x827eaf30
	ctx.lr = 0x827EB370;
	sub_827EAF30(ctx, base);
	// 827EB370: 48000010  b 0x827eb380
	pc = 0x827EB380; continue 'dispatch;
	// 827EB374: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827EB378: 396BC5C8  addi r11, r11, -0x3a38
	ctx.r[11].s64 = ctx.r[11].s64 + -14904;
	// 827EB37C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EB380: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EB384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB38C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB390 size=240
    let mut pc: u32 = 0x827EB390;
    'dispatch: loop {
        match pc {
            0x827EB390 => {
    //   block [0x827EB390..0x827EB480)
	// 827EB390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB398: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB39C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB3A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB3A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB3A8: 38650008  addi r3, r5, 8
	ctx.r[3].s64 = ctx.r[5].s64 + 8;
	// 827EB3AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EB3B0: 486087F9  bl 0x82df3ba8
	ctx.lr = 0x827EB3B4;
	sub_82DF3BA8(ctx, base);
	// 827EB3B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB3B8: 41820038  beq 0x827eb3f0
	if ctx.cr[0].eq {
	pc = 0x827EB3F0; continue 'dispatch;
	}
	// 827EB3BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB3C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB3C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB3C8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 827EB3CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB3D0: 4E800421  bctrl
	ctx.lr = 0x827EB3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB3D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB3D8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EB3DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EB3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB3E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB3E8: 4BD25771  bl 0x82510b58
	ctx.lr = 0x827EB3EC;
	sub_82510B58(ctx, base);
	// 827EB3EC: 4800007C  b 0x827eb468
	pc = 0x827EB468; continue 'dispatch;
	// 827EB3F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EB3F4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB3FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 827EB400: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827EB404: 419A0024  beq cr6, 0x827eb428
	if ctx.cr[6].eq {
	pc = 0x827EB428; continue 'dispatch;
	}
	// 827EB408: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EB40C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EB410: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB414: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EB418: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EB41C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EB420: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB424: 4082FFE8  bne 0x827eb40c
	if !ctx.cr[0].eq {
	pc = 0x827EB40C; continue 'dispatch;
	}
	// 827EB428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB42C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB434: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 827EB438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB43C: 4E800421  bctrl
	ctx.lr = 0x827EB440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB440: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB444: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EB448: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827EB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB450: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB454: 4BD255A5  bl 0x825109f8
	ctx.lr = 0x827EB458;
	sub_825109F8(ctx, base);
	// 827EB458: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EB45C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB460: 419A0008  beq cr6, 0x827eb468
	if ctx.cr[6].eq {
	pc = 0x827EB468; continue 'dispatch;
	}
	// 827EB464: 4BAD542D  bl 0x822c0890
	ctx.lr = 0x827EB468;
	sub_822C0890(ctx, base);
	// 827EB468: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EB46C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB474: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB480 size=192
    let mut pc: u32 = 0x827EB480;
    'dispatch: loop {
        match pc {
            0x827EB480 => {
    //   block [0x827EB480..0x827EB540)
	// 827EB480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EB48C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EB490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EB498: 38650008  addi r3, r5, 8
	ctx.r[3].s64 = ctx.r[5].s64 + 8;
	// 827EB49C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EB4A0: 48608709  bl 0x82df3ba8
	ctx.lr = 0x827EB4A4;
	sub_82DF3BA8(ctx, base);
	// 827EB4A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB4A8: 41820020  beq 0x827eb4c8
	if ctx.cr[0].eq {
	pc = 0x827EB4C8; continue 'dispatch;
	}
	// 827EB4AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827EB4B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EB4B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EB4B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB4BC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 827EB4C0: 4BD24D31  bl 0x825101f0
	ctx.lr = 0x827EB4C4;
	sub_825101F0(ctx, base);
	// 827EB4C4: 48000064  b 0x827eb528
	pc = 0x827EB528; continue 'dispatch;
	// 827EB4C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EB4CC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB4D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EB4D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EB4DC: 419A0024  beq cr6, 0x827eb500
	if ctx.cr[6].eq {
	pc = 0x827EB500; continue 'dispatch;
	}
	// 827EB4E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EB4E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EB4E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB4EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EB4F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EB4F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EB4F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB4FC: 4082FFE8  bne 0x827eb4e4
	if !ctx.cr[0].eq {
	pc = 0x827EB4E4; continue 'dispatch;
	}
	// 827EB500: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 827EB504: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827EB508: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EB50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB510: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 827EB514: 4BD24BAD  bl 0x825100c0
	ctx.lr = 0x827EB518;
	sub_825100C0(ctx, base);
	// 827EB518: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB51C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB520: 419A0008  beq cr6, 0x827eb528
	if ctx.cr[6].eq {
	pc = 0x827EB528; continue 'dispatch;
	}
	// 827EB524: 4BAD536D  bl 0x822c0890
	ctx.lr = 0x827EB528;
	sub_822C0890(ctx, base);
	// 827EB528: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EB52C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB534: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EB538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EB53C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EB540 size=80
    let mut pc: u32 = 0x827EB540;
    'dispatch: loop {
        match pc {
            0x827EB540 => {
    //   block [0x827EB540..0x827EB590)
	// 827EB540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EB548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB54C: 48000C15  bl 0x827ec160
	ctx.lr = 0x827EB550;
	sub_827EC160(ctx, base);
	// 827EB550: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 827EB554: 4182002C  beq 0x827eb580
	if ctx.cr[0].eq {
	pc = 0x827EB580; continue 'dispatch;
	}
	// 827EB558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB55C: 48003235  bl 0x827ee790
	ctx.lr = 0x827EB560;
	sub_827EE790(ctx, base);
	// 827EB560: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EB564: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB568: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EB56C: 4BFEEA7D  bl 0x827d9fe8
	ctx.lr = 0x827EB570;
	sub_827D9FE8(ctx, base);
	// 827EB570: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB574: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB578: 419A0008  beq cr6, 0x827eb580
	if ctx.cr[6].eq {
	pc = 0x827EB580; continue 'dispatch;
	}
	// 827EB57C: 4BAD5315  bl 0x822c0890
	ctx.lr = 0x827EB580;
	sub_822C0890(ctx, base);
	// 827EB580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EB584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EB588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EB58C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB590 size=164
    let mut pc: u32 = 0x827EB590;
    'dispatch: loop {
        match pc {
            0x827EB590 => {
    //   block [0x827EB590..0x827EB634)
	// 827EB590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB594: 489BCBD5  bl 0x831a8168
	ctx.lr = 0x827EB598;
	sub_831A8130(ctx, base);
	// 827EB598: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB59C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827EB5A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EB5A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EB5A8: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827EB5AC: 41820038  beq 0x827eb5e4
	if ctx.cr[0].eq {
	pc = 0x827EB5E4; continue 'dispatch;
	}
	// 827EB5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB5B4: 489BE3D5  bl 0x831a9988
	ctx.lr = 0x827EB5B8;
	sub_831A9988(ctx, base);
	// 827EB5B8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 827EB5BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EB5C0: 386B5CA0  addi r3, r11, 0x5ca0
	ctx.r[3].s64 = ctx.r[11].s64 + 23712;
	// 827EB5C4: 489BCB35  bl 0x831a80f8
	ctx.lr = 0x827EB5C8;
	sub_831A80F8(ctx, base);
	// 827EB5C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB5CC: 41820018  beq 0x827eb5e4
	if ctx.cr[0].eq {
	pc = 0x827EB5E4; continue 'dispatch;
	}
	// 827EB5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB5D4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 827EB5D8: 4BFFFF69  bl 0x827eb540
	ctx.lr = 0x827EB5DC;
	sub_827EB540(ctx, base);
	// 827EB5DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 827EB5E0: 4800004C  b 0x827eb62c
	pc = 0x827EB62C; continue 'dispatch;
	// 827EB5E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827EB5E8: 419A0034  beq cr6, 0x827eb61c
	if ctx.cr[6].eq {
	pc = 0x827EB61C; continue 'dispatch;
	}
	// 827EB5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB5F0: 489BE399  bl 0x831a9988
	ctx.lr = 0x827EB5F4;
	sub_831A9988(ctx, base);
	// 827EB5F4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 827EB5F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EB5FC: 386B5CC8  addi r3, r11, 0x5cc8
	ctx.r[3].s64 = ctx.r[11].s64 + 23752;
	// 827EB600: 489BCAF9  bl 0x831a80f8
	ctx.lr = 0x827EB604;
	sub_831A80F8(ctx, base);
	// 827EB604: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB608: 41820014  beq 0x827eb61c
	if ctx.cr[0].eq {
	pc = 0x827EB61C; continue 'dispatch;
	}
	// 827EB60C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB610: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 827EB614: 4BFFFBFD  bl 0x827eb210
	ctx.lr = 0x827EB618;
	sub_827EB210(ctx, base);
	// 827EB618: 4BFFFFC4  b 0x827eb5dc
	pc = 0x827EB5DC; continue 'dispatch;
	// 827EB61C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827EB620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB628: 48001CF9  bl 0x827ed320
	ctx.lr = 0x827EB62C;
	sub_827ED320(ctx, base);
	// 827EB62C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EB630: 489BCB88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EB638 size=32
    let mut pc: u32 = 0x827EB638;
    'dispatch: loop {
        match pc {
            0x827EB638 => {
    //   block [0x827EB638..0x827EB658)
	// 827EB638: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB63C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827EB640: 394B01D4  addi r10, r11, 0x1d4
	ctx.r[10].s64 = ctx.r[11].s64 + 468;
	// 827EB644: 912B01D4  stw r9, 0x1d4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(468 as u32), ctx.r[9].u32 ) };
	// 827EB648: 806B01D8  lwz r3, 0x1d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(472 as u32) ) } as u64;
	// 827EB64C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB650: 912B01D8  stw r9, 0x1d8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(472 as u32), ctx.r[9].u32 ) };
	// 827EB654: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EB658 size=8
    let mut pc: u32 = 0x827EB658;
    'dispatch: loop {
        match pc {
            0x827EB658 => {
    //   block [0x827EB658..0x827EB660)
	// 827EB658: 4BAD5238  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 827EB65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB660 size=132
    let mut pc: u32 = 0x827EB660;
    'dispatch: loop {
        match pc {
            0x827EB660 => {
    //   block [0x827EB660..0x827EB6E4)
	// 827EB660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB664: 489BCB01  bl 0x831a8164
	ctx.lr = 0x827EB668;
	sub_831A8130(ctx, base);
	// 827EB668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB670: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827EB674: 3BA00063  li r29, 0x63
	ctx.r[29].s64 = 99;
	// 827EB678: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 827EB67C: 387EFFF8  addi r3, r30, -8
	ctx.r[3].s64 = ctx.r[30].s64 + -8;
	// 827EB680: 48613249  bl 0x82dfe8c8
	ctx.lr = 0x827EB684;
	sub_82DFE8C8(ctx, base);
	// 827EB684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB688: 48613241  bl 0x82dfe8c8
	ctx.lr = 0x827EB68C;
	sub_82DFE8C8(ctx, base);
	// 827EB68C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827EB690: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 827EB694: 4080FFE8  bge 0x827eb67c
	if !ctx.cr[0].lt {
	pc = 0x827EB67C; continue 'dispatch;
	}
	// 827EB698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EB69C: 3B9F12C4  addi r28, r31, 0x12c4
	ctx.r[28].s64 = ctx.r[31].s64 + 4804;
	// 827EB6A0: 917F12C0  stw r11, 0x12c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4800 as u32), ctx.r[11].u32 ) };
	// 827EB6A4: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827EB6A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EB6AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827EB6B0: 489BCE61  bl 0x831a8510
	ctx.lr = 0x827EB6B4;
	sub_831A8510(ctx, base);
	// 827EB6B4: 3BC00064  li r30, 0x64
	ctx.r[30].s64 = 100;
	// 827EB6B8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 827EB6BC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 827EB6C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EB6C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EB6C8: 489BCE49  bl 0x831a8510
	ctx.lr = 0x827EB6CC;
	sub_831A8510(ctx, base);
	// 827EB6CC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827EB6D0: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 827EB6D4: 4082FFE8  bne 0x827eb6bc
	if !ctx.cr[0].eq {
	pc = 0x827EB6BC; continue 'dispatch;
	}
	// 827EB6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB6DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EB6E0: 489BCAD4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB6E8 size=292
    let mut pc: u32 = 0x827EB6E8;
    'dispatch: loop {
        match pc {
            0x827EB6E8 => {
    //   block [0x827EB6E8..0x827EB80C)
	// 827EB6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB6EC: 489BCA81  bl 0x831a816c
	ctx.lr = 0x827EB6F0;
	sub_831A8130(ctx, base);
	// 827EB6F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB6F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EB6FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB700: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827EB704: 4BFFFA7D  bl 0x827eb180
	ctx.lr = 0x827EB708;
	sub_827EB180(ctx, base);
	// 827EB708: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EB70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB710: 419A00D4  beq cr6, 0x827eb7e4
	if ctx.cr[6].eq {
	pc = 0x827EB7E4; continue 'dispatch;
	}
	// 827EB714: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EB718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EB71C: 388B5D60  addi r4, r11, 0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + 23904;
	// 827EB720: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 827EB724: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 827EB728: 48606CC1  bl 0x82df23e8
	ctx.lr = 0x827EB72C;
	sub_82DF23E8(ctx, base);
	// 827EB72C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EB730: 41820014  beq 0x827eb744
	if ctx.cr[0].eq {
	pc = 0x827EB744; continue 'dispatch;
	}
	// 827EB734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EB738: 4862B159  bl 0x82e16890
	ctx.lr = 0x827EB73C;
	sub_82E16890(ctx, base);
	// 827EB73C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EB740: 48000008  b 0x827eb748
	pc = 0x827EB748; continue 'dispatch;
	// 827EB744: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827EB748: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827EB74C: 419A0020  beq cr6, 0x827eb76c
	if ctx.cr[6].eq {
	pc = 0x827EB76C; continue 'dispatch;
	}
	// 827EB750: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 827EB754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EB758: 4BB71C19  bl 0x8235d370
	ctx.lr = 0x827EB75C;
	sub_8235D370(ctx, base);
	// 827EB75C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827EB760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB768: 4BFFFC29  bl 0x827eb390
	ctx.lr = 0x827EB76C;
	sub_827EB390(ctx, base);
	// 827EB76C: 83DF00F4  lwz r30, 0xf4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 827EB770: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827EB774: 419A0070  beq cr6, 0x827eb7e4
	if ctx.cr[6].eq {
	pc = 0x827EB7E4; continue 'dispatch;
	}
	// 827EB778: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB77C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EB780: 482C0569  bl 0x82aabce8
	ctx.lr = 0x827EB784;
	sub_82AABCE8(ctx, base);
	// 827EB784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EB788: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB78C: 486276A5  bl 0x82e12e30
	ctx.lr = 0x827EB790;
	sub_82E12E30(ctx, base);
	// 827EB790: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827EB794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB798: 419A0008  beq cr6, 0x827eb7a0
	if ctx.cr[6].eq {
	pc = 0x827EB7A0; continue 'dispatch;
	}
	// 827EB79C: 4BAD50F5  bl 0x822c0890
	ctx.lr = 0x827EB7A0;
	sub_822C0890(ctx, base);
	// 827EB7A0: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 827EB7A4: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 827EB7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB7AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 827EB7B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827EB7B4: 419A0024  beq cr6, 0x827eb7d8
	if ctx.cr[6].eq {
	pc = 0x827EB7D8; continue 'dispatch;
	}
	// 827EB7B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EB7BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EB7C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB7C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EB7C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EB7CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EB7D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EB7D4: 4082FFE8  bne 0x827eb7bc
	if !ctx.cr[0].eq {
	pc = 0x827EB7BC; continue 'dispatch;
	}
	// 827EB7D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827EB7DC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EB7E0: 486298D1  bl 0x82e150b0
	ctx.lr = 0x827EB7E4;
	sub_82E150B0(ctx, base);
	// 827EB7E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB7E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB7EC: 419A0008  beq cr6, 0x827eb7f4
	if ctx.cr[6].eq {
	pc = 0x827EB7F4; continue 'dispatch;
	}
	// 827EB7F0: 4BAD50A1  bl 0x822c0890
	ctx.lr = 0x827EB7F4;
	sub_822C0890(ctx, base);
	// 827EB7F4: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EB7F8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827EB7FC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827EB800: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 827EB804: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EB808: 489BC9B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EB810 size=400
    let mut pc: u32 = 0x827EB810;
    'dispatch: loop {
        match pc {
            0x827EB810 => {
    //   block [0x827EB810..0x827EB9A0)
	// 827EB810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB814: 489BC951  bl 0x831a8164
	ctx.lr = 0x827EB818;
	sub_831A8130(ctx, base);
	// 827EB818: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 827EB81C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB824: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827EB828: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827EB82C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EB830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB834: 419A0150  beq cr6, 0x827eb984
	if ctx.cr[6].eq {
	pc = 0x827EB984; continue 'dispatch;
	}
	// 827EB838: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EB844: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 827EB848: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB84C: 4E800421  bctrl
	ctx.lr = 0x827EB850;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB850: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EB854: 3BDF01CC  addi r30, r31, 0x1cc
	ctx.r[30].s64 = ctx.r[31].s64 + 460;
	// 827EB858: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 827EB85C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 827EB860: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB864: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 827EB868: 4BAD8BF9  bl 0x822c4460
	ctx.lr = 0x827EB86C;
	sub_822C4460(ctx, base);
	// 827EB86C: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EB870: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EB874: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827EB878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB87C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827EB880: 697D0001  xori r29, r11, 1
	ctx.r[29].u64 = ctx.r[11].u64 ^ 1;
	// 827EB884: 419A0008  beq cr6, 0x827eb88c
	if ctx.cr[6].eq {
	pc = 0x827EB88C; continue 'dispatch;
	}
	// 827EB888: 4BAD5009  bl 0x822c0890
	ctx.lr = 0x827EB88C;
	sub_822C0890(ctx, base);
	// 827EB88C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EB890: 418200F4  beq 0x827eb984
	if ctx.cr[0].eq {
	pc = 0x827EB984; continue 'dispatch;
	}
	// 827EB894: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EB898: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EB89C: 388B5D60  addi r4, r11, 0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + 23904;
	// 827EB8A0: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 827EB8A4: 386012F4  li r3, 0x12f4
	ctx.r[3].s64 = 4852;
	// 827EB8A8: 4BAD4B31  bl 0x822c03d8
	ctx.lr = 0x827EB8AC;
	sub_822C03D8(ctx, base);
	// 827EB8AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EB8B0: 41820018  beq 0x827eb8c8
	if ctx.cr[0].eq {
	pc = 0x827EB8C8; continue 'dispatch;
	}
	// 827EB8B4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 827EB8B8: 388BC558  addi r4, r11, -0x3aa8
	ctx.r[4].s64 = ctx.r[11].s64 + -15016;
	// 827EB8BC: 4BFFFDA5  bl 0x827eb660
	ctx.lr = 0x827EB8C0;
	sub_827EB660(ctx, base);
	// 827EB8C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EB8C4: 48000008  b 0x827eb8cc
	pc = 0x827EB8CC; continue 'dispatch;
	// 827EB8C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827EB8CC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827EB8D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EB8D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EB8D8: 4BFFF9C1  bl 0x827eb298
	ctx.lr = 0x827EB8DC;
	sub_827EB298(ctx, base);
	// 827EB8DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827EB8E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EB8E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EB8E8: 4BAD4719  bl 0x822c0000
	ctx.lr = 0x827EB8EC;
	sub_822C0000(ctx, base);
	// 827EB8EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB8F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EB8F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EB8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB8FC: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EB900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB904: 4E800421  bctrl
	ctx.lr = 0x827EB908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB908: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB90C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EB910: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 827EB914: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB91C: 4E800421  bctrl
	ctx.lr = 0x827EB920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EB924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EB928: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EB92C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 827EB930: 4BD23B99  bl 0x8250f4c8
	ctx.lr = 0x827EB934;
	sub_8250F4C8(ctx, base);
	// 827EB934: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EB938: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EB93C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EB940: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827EB944: 4BFFF025  bl 0x827ea968
	ctx.lr = 0x827EB948;
	sub_827EA968(ctx, base);
	// 827EB948: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EB94C: 48606345  bl 0x82df1c90
	ctx.lr = 0x827EB950;
	sub_82DF1C90(ctx, base);
	// 827EB950: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EB954: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827EB958: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB95C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827EB960: 80AB12C0  lwz r5, 0x12c0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4800 as u32) ) } as u64;
	// 827EB964: 4BFFECED  bl 0x827ea650
	ctx.lr = 0x827EB968;
	sub_827EA650(ctx, base);
	// 827EB968: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EB96C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB970: 4BFFED59  bl 0x827ea6c8
	ctx.lr = 0x827EB974;
	sub_827EA6C8(ctx, base);
	// 827EB974: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EB978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EB97C: 419A0008  beq cr6, 0x827eb984
	if ctx.cr[6].eq {
	pc = 0x827EB984; continue 'dispatch;
	}
	// 827EB980: 4BAD4F11  bl 0x822c0890
	ctx.lr = 0x827EB984;
	sub_822C0890(ctx, base);
	// 827EB984: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EB988: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827EB98C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827EB990: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 827EB994: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EB998: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 827EB99C: 489BC818  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EB9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EB9A0 size=400
    let mut pc: u32 = 0x827EB9A0;
    'dispatch: loop {
        match pc {
            0x827EB9A0 => {
    //   block [0x827EB9A0..0x827EBB30)
	// 827EB9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EB9A4: 489BC7B1  bl 0x831a8154
	ctx.lr = 0x827EB9A8;
	sub_831A8130(ctx, base);
	// 827EB9A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EB9AC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 827EB9B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827EB9B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EB9B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EB9BC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB9C0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827EB9C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EB9C8: 409A0160  bne cr6, 0x827ebb28
	if !ctx.cr[6].eq {
	pc = 0x827EBB28; continue 'dispatch;
	}
	// 827EB9CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB9D0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 827EB9D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EB9D8: 4E800421  bctrl
	ctx.lr = 0x827EB9DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EB9DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EB9E0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 827EB9E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 827EB9E8: C18B0010  lfs f12, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827EB9EC: C1AAF614  lfs f13, -0x9ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EB9F0: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EB9F4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 827EB9F8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827EB9FC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827EBA00: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827EBA04: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827EBA08: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EBA0C: 48005EB5  bl 0x827f18c0
	ctx.lr = 0x827EBA10;
	sub_827F18C0(ctx, base);
	// 827EBA10: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 827EBA14: 394BBA80  addi r10, r11, -0x4580
	ctx.r[10].s64 = ctx.r[11].s64 + -17792;
	// 827EBA18: C00BBA80  lfs f0, -0x4580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBA1C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827EBA20: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EBA24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827EBA28: 388B5D60  addi r4, r11, 0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + 23904;
	// 827EBA2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EBA30: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBA34: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 827EBA38: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EBA3C: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 827EBA40: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827EBA44: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 827EBA48: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827EBA4C: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 827EBA50: 48606999  bl 0x82df23e8
	ctx.lr = 0x827EBA54;
	sub_82DF23E8(ctx, base);
	// 827EBA54: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827EBA58: 41820068  beq 0x827ebac0
	if ctx.cr[0].eq {
	pc = 0x827EBAC0; continue 'dispatch;
	}
	// 827EBA5C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBA60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EBA64: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827EBA68: 419A0008  beq cr6, 0x827eba70
	if ctx.cr[6].eq {
	pc = 0x827EBA70; continue 'dispatch;
	}
	// 827EBA6C: 4BAFC7DD  bl 0x822e8248
	ctx.lr = 0x827EBA70;
	sub_822E8248(ctx, base);
	// 827EBA70: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 827EBA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EBA78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EBA7C: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 827EBA80: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 827EBA84: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 827EBA88: 3B010070  addi r24, r1, 0x70
	ctx.r[24].s64 = ctx.r[1].s64 + 112;
	// 827EBA8C: 3AE10050  addi r23, r1, 0x50
	ctx.r[23].s64 = ctx.r[1].s64 + 80;
	// 827EBA90: 4BD23A89  bl 0x8250f518
	ctx.lr = 0x827EBA94;
	sub_8250F518(ctx, base);
	// 827EBA94: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827EBA98: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 827EBA9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827EBAA0: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 827EBAA4: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 827EBAA8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 827EBAAC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 827EBAB0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 827EBAB4: 482FB82D  bl 0x82ae72e0
	ctx.lr = 0x827EBAB8;
	sub_82AE72E0(ctx, base);
	// 827EBAB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EBABC: 48000008  b 0x827ebac4
	pc = 0x827EBAC4; continue 'dispatch;
	// 827EBAC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827EBAC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EBAC8: 4BB88791  bl 0x82374258
	ctx.lr = 0x827EBACC;
	sub_82374258(ctx, base);
	// 827EBACC: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EBAD0: 41820010  beq 0x827ebae0
	if ctx.cr[0].eq {
	pc = 0x827EBAE0; continue 'dispatch;
	}
	// 827EBAD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EBAD8: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 827EBADC: 486061B5  bl 0x82df1c90
	ctx.lr = 0x827EBAE0;
	sub_82DF1C90(ctx, base);
	// 827EBAE0: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EBAE4: 41820014  beq 0x827ebaf8
	if ctx.cr[0].eq {
	pc = 0x827EBAF8; continue 'dispatch;
	}
	// 827EBAE8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EBAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EBAF0: 419A0008  beq cr6, 0x827ebaf8
	if ctx.cr[6].eq {
	pc = 0x827EBAF8; continue 'dispatch;
	}
	// 827EBAF4: 4BAFC775  bl 0x822e8268
	ctx.lr = 0x827EBAF8;
	sub_822E8268(ctx, base);
	// 827EBAF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827EBAFC: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBB00: 38802005  li r4, 0x2005
	ctx.r[4].s64 = 8197;
	// 827EBB04: 4BCA36AD  bl 0x8248f1b0
	ctx.lr = 0x827EBB08;
	sub_8248F1B0(ctx, base);
	// 827EBB08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827EBB0C: 38802006  li r4, 0x2006
	ctx.r[4].s64 = 8198;
	// 827EBB10: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBB14: 4BCA369D  bl 0x8248f1b0
	ctx.lr = 0x827EBB18;
	sub_8248F1B0(ctx, base);
	// 827EBB18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827EBB1C: 3880200B  li r4, 0x200b
	ctx.r[4].s64 = 8203;
	// 827EBB20: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBB24: 4BCA368D  bl 0x8248f1b0
	ctx.lr = 0x827EBB28;
	sub_8248F1B0(ctx, base);
	// 827EBB28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827EBB2C: 489BC678  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EBB30 size=196
    let mut pc: u32 = 0x827EBB30;
    'dispatch: loop {
        match pc {
            0x827EBB30 => {
    //   block [0x827EBB30..0x827EBBF4)
	// 827EBB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBB34: 489BC639  bl 0x831a816c
	ctx.lr = 0x827EBB38;
	sub_831A8130(ctx, base);
	// 827EBB38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EBB40: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 827EBB44: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EBB48: 48607669  bl 0x82df31b0
	ctx.lr = 0x827EBB4C;
	sub_82DF31B0(ctx, base);
	// 827EBB4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EBB50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBB54: 48607EB5  bl 0x82df3a08
	ctx.lr = 0x827EBB58;
	sub_82DF3A08(ctx, base);
	// 827EBB58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EBB5C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 827EBB60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EBB64: 4BCA67A5  bl 0x82492308
	ctx.lr = 0x827EBB68;
	sub_82492308(ctx, base);
	// 827EBB68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBB6C: 486078BD  bl 0x82df3428
	ctx.lr = 0x827EBB70;
	sub_82DF3428(ctx, base);
	// 827EBB70: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EBB74: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EBB78: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827EBB7C: 419A0070  beq cr6, 0x827ebbec
	if ctx.cr[6].eq {
	pc = 0x827EBBEC; continue 'dispatch;
	}
	// 827EBB80: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 827EBB84: 4860762D  bl 0x82df31b0
	ctx.lr = 0x827EBB88;
	sub_82DF31B0(ctx, base);
	// 827EBB88: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827EBB8C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 827EBB90: 48607621  bl 0x82df31b0
	ctx.lr = 0x827EBB94;
	sub_82DF31B0(ctx, base);
	// 827EBB94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EBB98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827EBB9C: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827EBBA0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 827EBBA4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827EBBA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827EBBAC: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EBBB0: 9101006C  stw r8, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 827EBBB4: C18A08A4  lfs f12, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827EBBB8: 98E1007C  stb r7, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u8 ) };
	// 827EBBBC: C0099534  lfs f0, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBBC0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827EBBC4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827EBBC8: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827EBBCC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827EBBD0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827EBBD4: 48612CF5  bl 0x82dfe8c8
	ctx.lr = 0x827EBBD8;
	sub_82DFE8C8(ctx, base);
	// 827EBBD8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827EBBDC: 48612CED  bl 0x82dfe8c8
	ctx.lr = 0x827EBBE0;
	sub_82DFE8C8(ctx, base);
	// 827EBBE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827EBBE4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBBE8: 4BFFF539  bl 0x827eb120
	ctx.lr = 0x827EBBEC;
	sub_827EB120(ctx, base);
	// 827EBBEC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EBBF0: 489BC5CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EBBF8 size=192
    let mut pc: u32 = 0x827EBBF8;
    'dispatch: loop {
        match pc {
            0x827EBBF8 => {
    //   block [0x827EBBF8..0x827EBCB8)
	// 827EBBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBBFC: 489BC571  bl 0x831a816c
	ctx.lr = 0x827EBC00;
	sub_831A8130(ctx, base);
	// 827EBC00: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBC04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EBC08: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 827EBC0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EBC10: 486075A1  bl 0x82df31b0
	ctx.lr = 0x827EBC14;
	sub_82DF31B0(ctx, base);
	// 827EBC14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EBC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBC1C: 48607DED  bl 0x82df3a08
	ctx.lr = 0x827EBC20;
	sub_82DF3A08(ctx, base);
	// 827EBC20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EBC24: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 827EBC28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EBC2C: 4BCA66DD  bl 0x82492308
	ctx.lr = 0x827EBC30;
	sub_82492308(ctx, base);
	// 827EBC30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBC34: 486077F5  bl 0x82df3428
	ctx.lr = 0x827EBC38;
	sub_82DF3428(ctx, base);
	// 827EBC38: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EBC3C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EBC40: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827EBC44: 419A006C  beq cr6, 0x827ebcb0
	if ctx.cr[6].eq {
	pc = 0x827EBCB0; continue 'dispatch;
	}
	// 827EBC48: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EBC4C: 48607565  bl 0x82df31b0
	ctx.lr = 0x827EBC50;
	sub_82DF31B0(ctx, base);
	// 827EBC50: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827EBC54: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 827EBC58: 48607559  bl 0x82df31b0
	ctx.lr = 0x827EBC5C;
	sub_82DF31B0(ctx, base);
	// 827EBC5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827EBC60: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 827EBC64: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827EBC68: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 827EBC6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EBC70: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827EBC74: C1AA08A8  lfs f13, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EBC78: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827EBC7C: C18908A4  lfs f12, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827EBC80: 9961007C  stb r11, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 827EBC84: C0089534  lfs f0, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBC88: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827EBC8C: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827EBC90: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827EBC94: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827EBC98: 48612C31  bl 0x82dfe8c8
	ctx.lr = 0x827EBC9C;
	sub_82DFE8C8(ctx, base);
	// 827EBC9C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827EBCA0: 48612C29  bl 0x82dfe8c8
	ctx.lr = 0x827EBCA4;
	sub_82DFE8C8(ctx, base);
	// 827EBCA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827EBCA8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBCAC: 4BFFF475  bl 0x827eb120
	ctx.lr = 0x827EBCB0;
	sub_827EB120(ctx, base);
	// 827EBCB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EBCB4: 489BC508  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EBCB8 size=200
    let mut pc: u32 = 0x827EBCB8;
    'dispatch: loop {
        match pc {
            0x827EBCB8 => {
    //   block [0x827EBCB8..0x827EBD80)
	// 827EBCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBCBC: 489BC4B1  bl 0x831a816c
	ctx.lr = 0x827EBCC0;
	sub_831A8130(ctx, base);
	// 827EBCC0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 827EBCC4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBCC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EBCCC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EBCD0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 827EBCD4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EBCD8: 486074D9  bl 0x82df31b0
	ctx.lr = 0x827EBCDC;
	sub_82DF31B0(ctx, base);
	// 827EBCDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EBCE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBCE4: 48607D25  bl 0x82df3a08
	ctx.lr = 0x827EBCE8;
	sub_82DF3A08(ctx, base);
	// 827EBCE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EBCEC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 827EBCF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EBCF4: 4BCA6615  bl 0x82492308
	ctx.lr = 0x827EBCF8;
	sub_82492308(ctx, base);
	// 827EBCF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBCFC: 4860772D  bl 0x82df3428
	ctx.lr = 0x827EBD00;
	sub_82DF3428(ctx, base);
	// 827EBD00: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EBD04: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EBD08: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827EBD0C: 419A0068  beq cr6, 0x827ebd74
	if ctx.cr[6].eq {
	pc = 0x827EBD74; continue 'dispatch;
	}
	// 827EBD10: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 827EBD14: 4860749D  bl 0x82df31b0
	ctx.lr = 0x827EBD18;
	sub_82DF31B0(ctx, base);
	// 827EBD18: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827EBD1C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 827EBD20: 48607491  bl 0x82df31b0
	ctx.lr = 0x827EBD24;
	sub_82DF31B0(ctx, base);
	// 827EBD24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EBD28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 827EBD2C: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827EBD30: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827EBD34: D3E10068  stfs f31, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827EBD38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827EBD3C: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 827EBD40: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827EBD44: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EBD48: 9901007C  stb r8, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u8 ) };
	// 827EBD4C: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBD50: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827EBD54: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827EBD58: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827EBD5C: 48612B6D  bl 0x82dfe8c8
	ctx.lr = 0x827EBD60;
	sub_82DFE8C8(ctx, base);
	// 827EBD60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827EBD64: 48612B65  bl 0x82dfe8c8
	ctx.lr = 0x827EBD68;
	sub_82DFE8C8(ctx, base);
	// 827EBD68: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827EBD6C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBD70: 4BFFF3B1  bl 0x827eb120
	ctx.lr = 0x827EBD74;
	sub_827EB120(ctx, base);
	// 827EBD74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827EBD78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 827EBD7C: 489BC440  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EBD80 size=196
    let mut pc: u32 = 0x827EBD80;
    'dispatch: loop {
        match pc {
            0x827EBD80 => {
    //   block [0x827EBD80..0x827EBE44)
	// 827EBD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBD84: 489BC3E9  bl 0x831a816c
	ctx.lr = 0x827EBD88;
	sub_831A8130(ctx, base);
	// 827EBD88: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 827EBD8C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBD90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EBD94: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EBD98: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 827EBD9C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EBDA0: 48607411  bl 0x82df31b0
	ctx.lr = 0x827EBDA4;
	sub_82DF31B0(ctx, base);
	// 827EBDA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EBDA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBDAC: 48607C5D  bl 0x82df3a08
	ctx.lr = 0x827EBDB0;
	sub_82DF3A08(ctx, base);
	// 827EBDB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EBDB4: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 827EBDB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EBDBC: 4BCA654D  bl 0x82492308
	ctx.lr = 0x827EBDC0;
	sub_82492308(ctx, base);
	// 827EBDC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EBDC4: 48607665  bl 0x82df3428
	ctx.lr = 0x827EBDC8;
	sub_82DF3428(ctx, base);
	// 827EBDC8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EBDCC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EBDD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827EBDD4: 419A0064  beq cr6, 0x827ebe38
	if ctx.cr[6].eq {
	pc = 0x827EBE38; continue 'dispatch;
	}
	// 827EBDD8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EBDDC: 486073D5  bl 0x82df31b0
	ctx.lr = 0x827EBDE0;
	sub_82DF31B0(ctx, base);
	// 827EBDE0: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827EBDE4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 827EBDE8: 486073C9  bl 0x82df31b0
	ctx.lr = 0x827EBDEC;
	sub_82DF31B0(ctx, base);
	// 827EBDEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827EBDF0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 827EBDF4: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 827EBDF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EBDFC: D3E10068  stfs f31, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 827EBE00: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827EBE04: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827EBE08: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827EBE0C: 9961007C  stb r11, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 827EBE10: C0099534  lfs f0, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827EBE14: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827EBE18: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 827EBE1C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 827EBE20: 48612AA9  bl 0x82dfe8c8
	ctx.lr = 0x827EBE24;
	sub_82DFE8C8(ctx, base);
	// 827EBE24: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827EBE28: 48612AA1  bl 0x82dfe8c8
	ctx.lr = 0x827EBE2C;
	sub_82DFE8C8(ctx, base);
	// 827EBE2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827EBE30: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBE34: 4BFFF2ED  bl 0x827eb120
	ctx.lr = 0x827EBE38;
	sub_827EB120(ctx, base);
	// 827EBE38: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827EBE3C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 827EBE40: 489BC37C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EBE48 size=196
    let mut pc: u32 = 0x827EBE48;
    'dispatch: loop {
        match pc {
            0x827EBE48 => {
    //   block [0x827EBE48..0x827EBF0C)
	// 827EBE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBE4C: 489BC321  bl 0x831a816c
	ctx.lr = 0x827EBE50;
	sub_831A8130(ctx, base);
	// 827EBE50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 827EBE54: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBE58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EBE5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EBE60: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBE64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EBE68: 409A0098  bne cr6, 0x827ebf00
	if !ctx.cr[6].eq {
	pc = 0x827EBF00; continue 'dispatch;
	}
	// 827EBE6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBE70: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 827EBE74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EBE78: 4E800421  bctrl
	ctx.lr = 0x827EBE7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EBE7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 827EBE80: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 827EBE84: C3E30008  lfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827EBE88: 396BBC40  addi r11, r11, -0x43c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17344;
	// 827EBE8C: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBE90: 394A3D80  addi r10, r10, 0x3d80
	ctx.r[10].s64 = ctx.r[10].s64 + 15744;
	// 827EBE94: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 827EBE98: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 827EBE9C: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 827EBEA0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EBEA4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 827EBEA8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EBEAC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EBF10 size=128
    let mut pc: u32 = 0x827EBF10;
    'dispatch: loop {
        match pc {
            0x827EBF10 => {
    //   block [0x827EBF10..0x827EBF90)
	// 827EBF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBF14: 489BC259  bl 0x831a816c
	ctx.lr = 0x827EBF18;
	sub_831A8130(ctx, base);
	// 827EBF18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBF1C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 827EBF20: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 827EBF24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827EBF28: 3BEBAC6C  addi r31, r11, -0x5394
	ctx.r[31].s64 = ctx.r[11].s64 + -21396;
	// 827EBF2C: 816AAC74  lwz r11, -0x538c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21388 as u32) ) } as u64;
	// 827EBF30: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827EBF34: 40820024  bne 0x827ebf58
	if !ctx.cr[0].eq {
	pc = 0x827EBF58; continue 'dispatch;
	}
	// 827EBF38: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 827EBF3C: 3D00827F  lis r8, -0x7d81
	ctx.r[8].s64 = -2105606144;
	// 827EBF40: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 827EBF44: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 827EBF48: 3908B348  addi r8, r8, -0x4cb8
	ctx.r[8].s64 = ctx.r[8].s64 + -19640;
	// 827EBF4C: 916AAC74  stw r11, -0x538c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21388 as u32), ctx.r[11].u32 ) };
	// 827EBF50: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EBF54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827EBF58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827EBF5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827EBF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EBF64: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 827EBF68: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827EBF6C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EBF70: 4BE68651  bl 0x826545c0
	ctx.lr = 0x827EBF74;
	sub_826545C0(ctx, base);
	// 827EBF74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EBF78: 4182000C  beq 0x827ebf84
	if ctx.cr[0].eq {
	pc = 0x827EBF84; continue 'dispatch;
	}
	// 827EBF7C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827EBF80: 48000008  b 0x827ebf88
	pc = 0x827EBF88; continue 'dispatch;
	// 827EBF84: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827EBF88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EBF8C: 489BC230  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EBF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EBF90 size=144
    let mut pc: u32 = 0x827EBF90;
    'dispatch: loop {
        match pc {
            0x827EBF90 => {
    //   block [0x827EBF90..0x827EC020)
	// 827EBF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EBF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EBF98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EBF9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EBFA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EBFA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EBFA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EBFAC: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EBFB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EBFB4: 4E800421  bctrl
	ctx.lr = 0x827EBFB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EBFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EBFBC: 480001A5  bl 0x827ec160
	ctx.lr = 0x827EBFC0;
	sub_827EC160(ctx, base);
	// 827EBFC0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827EBFC4: 41820044  beq 0x827ec008
	if ctx.cr[0].eq {
	pc = 0x827EC008; continue 'dispatch;
	}
	// 827EBFC8: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 827EBFCC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827EBFD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EBFD4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827EBFD8: 394AAFC0  addi r10, r10, -0x5040
	ctx.r[10].s64 = ctx.r[10].s64 + -20544;
	// 827EBFDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EBFE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EBFE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EBFE8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EBFEC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827EBFF0: 4BFFFF21  bl 0x827ebf10
	ctx.lr = 0x827EBFF4;
	sub_827EBF10(ctx, base);
	// 827EBFF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827EBFF8: 387E0090  addi r3, r30, 0x90
	ctx.r[3].s64 = ctx.r[30].s64 + 144;
	// 827EBFFC: 4BC850CD  bl 0x824710c8
	ctx.lr = 0x827EC000;
	sub_824710C8(ctx, base);
	// 827EC000: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EC004: 4BADCCB5  bl 0x822c8cb8
	ctx.lr = 0x827EC008;
	sub_822C8CB8(ctx, base);
	// 827EC008: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EC00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EC018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC020 size=88
    let mut pc: u32 = 0x827EC020;
    'dispatch: loop {
        match pc {
            0x827EC020 => {
    //   block [0x827EC020..0x827EC078)
	// 827EC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC024: 489BC149  bl 0x831a816c
	ctx.lr = 0x827EC028;
	sub_831A8130(ctx, base);
	// 827EC028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC02C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC034: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EC038: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827EC03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC040: 389F01D4  addi r4, r31, 0x1d4
	ctx.r[4].s64 = ctx.r[31].s64 + 468;
	// 827EC044: 419A0010  beq cr6, 0x827ec054
	if ctx.cr[6].eq {
	pc = 0x827EC054; continue 'dispatch;
	}
	// 827EC048: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 827EC04C: 4BFFF955  bl 0x827eb9a0
	ctx.lr = 0x827EC050;
	sub_827EB9A0(ctx, base);
	// 827EC050: 48000008  b 0x827ec058
	pc = 0x827EC058; continue 'dispatch;
	// 827EC054: 4BFFFDF5  bl 0x827ebe48
	ctx.lr = 0x827EC058;
	sub_827EBE48(ctx, base);
	// 827EC058: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 827EC05C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827EC060: 409A0010  bne cr6, 0x827ec070
	if !ctx.cr[6].eq {
	pc = 0x827EC070; continue 'dispatch;
	}
	// 827EC064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EC068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC06C: 4BFFFF25  bl 0x827ebf90
	ctx.lr = 0x827EC070;
	sub_827EBF90(ctx, base);
	// 827EC070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC074: 489BC148  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC078 size=44
    let mut pc: u32 = 0x827EC078;
    'dispatch: loop {
        match pc {
            0x827EC078 => {
    //   block [0x827EC078..0x827EC0A4)
	// 827EC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC084: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EC088: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 827EC08C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827EC090: 4BFFFF91  bl 0x827ec020
	ctx.lr = 0x827EC094;
	sub_827EC020(ctx, base);
	// 827EC094: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EC098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC0A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC0A8 size=96
    let mut pc: u32 = 0x827EC0A8;
    'dispatch: loop {
        match pc {
            0x827EC0A8 => {
    //   block [0x827EC0A8..0x827EC108)
	// 827EC0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC0B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EC0B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC0B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC0BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC0C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EC0C4: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 827EC0C8: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 827EC0CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EC0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC0D4: 4E800421  bctrl
	ctx.lr = 0x827EC0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC0D8: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 827EC0DC: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 827EC0E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EC0E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EC0E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC0EC: 4E800421  bctrl
	ctx.lr = 0x827EC0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC0F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC0F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC0F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC0FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EC100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC108 size=8
    let mut pc: u32 = 0x827EC108;
    'dispatch: loop {
        match pc {
            0x827EC108 => {
    //   block [0x827EC108..0x827EC110)
	// 827EC108: 386300FC  addi r3, r3, 0xfc
	ctx.r[3].s64 = ctx.r[3].s64 + 252;
	// 827EC10C: 4867058C  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC110 size=8
    let mut pc: u32 = 0x827EC110;
    'dispatch: loop {
        match pc {
            0x827EC110 => {
    //   block [0x827EC110..0x827EC118)
	// 827EC110: 386300FC  addi r3, r3, 0xfc
	ctx.r[3].s64 = ctx.r[3].s64 + 252;
	// 827EC114: 4867035C  b 0x82e5c470
	sub_82E5C470(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC118 size=8
    let mut pc: u32 = 0x827EC118;
    'dispatch: loop {
        match pc {
            0x827EC118 => {
    //   block [0x827EC118..0x827EC120)
	// 827EC118: 38630164  addi r3, r3, 0x164
	ctx.r[3].s64 = ctx.r[3].s64 + 356;
	// 827EC11C: 4867057C  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC120 size=56
    let mut pc: u32 = 0x827EC120;
    'dispatch: loop {
        match pc {
            0x827EC120 => {
    //   block [0x827EC120..0x827EC158)
	// 827EC120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC12C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC134: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 827EC138: 48670561  bl 0x82e5c698
	ctx.lr = 0x827EC13C;
	sub_82E5C698(ctx, base);
	// 827EC13C: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 827EC140: 48670559  bl 0x82e5c698
	ctx.lr = 0x827EC144;
	sub_82E5C698(ctx, base);
	// 827EC144: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EC148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC14C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC150: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC158 size=4
    let mut pc: u32 = 0x827EC158;
    'dispatch: loop {
        match pc {
            0x827EC158 => {
    //   block [0x827EC158..0x827EC15C)
	// 827EC158: 4BD25C40  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC160 size=8
    let mut pc: u32 = 0x827EC160;
    'dispatch: loop {
        match pc {
            0x827EC160 => {
    //   block [0x827EC160..0x827EC168)
	// 827EC160: 806300E4  lwz r3, 0xe4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 827EC164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC168 size=84
    let mut pc: u32 = 0x827EC168;
    'dispatch: loop {
        match pc {
            0x827EC168 => {
    //   block [0x827EC168..0x827EC1BC)
	// 827EC168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EC174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC17C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC180: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EC184: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 827EC188: 48670F09  bl 0x82e5d090
	ctx.lr = 0x827EC18C;
	sub_82E5D090(ctx, base);
	// 827EC18C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EC190: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 827EC194: 48670EFD  bl 0x82e5d090
	ctx.lr = 0x827EC198;
	sub_82E5D090(ctx, base);
	// 827EC198: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EC19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC1A0: 488DB941  bl 0x830c7ae0
	ctx.lr = 0x827EC1A4;
	sub_830C7AE0(ctx, base);
	// 827EC1A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EC1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1C0 size=8
    let mut pc: u32 = 0x827EC1C0;
    'dispatch: loop {
        match pc {
            0x827EC1C0 => {
    //   block [0x827EC1C0..0x827EC1C8)
	// 827EC1C0: 8063015C  lwz r3, 0x15c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 827EC1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1C8 size=8
    let mut pc: u32 = 0x827EC1C8;
    'dispatch: loop {
        match pc {
            0x827EC1C8 => {
    //   block [0x827EC1C8..0x827EC1D0)
	// 827EC1C8: 806301D4  lwz r3, 0x1d4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(468 as u32) ) } as u64;
	// 827EC1CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1D0 size=8
    let mut pc: u32 = 0x827EC1D0;
    'dispatch: loop {
        match pc {
            0x827EC1D0 => {
    //   block [0x827EC1D0..0x827EC1D8)
	// 827EC1D0: 806301CC  lwz r3, 0x1cc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EC1D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1D8 size=8
    let mut pc: u32 = 0x827EC1D8;
    'dispatch: loop {
        match pc {
            0x827EC1D8 => {
    //   block [0x827EC1D8..0x827EC1E0)
	// 827EC1D8: 806300EC  lwz r3, 0xec(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EC1DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1E0 size=8
    let mut pc: u32 = 0x827EC1E0;
    'dispatch: loop {
        match pc {
            0x827EC1E0 => {
    //   block [0x827EC1E0..0x827EC1E8)
	// 827EC1E0: 806301DC  lwz r3, 0x1dc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(476 as u32) ) } as u64;
	// 827EC1E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1E8 size=8
    let mut pc: u32 = 0x827EC1E8;
    'dispatch: loop {
        match pc {
            0x827EC1E8 => {
    //   block [0x827EC1E8..0x827EC1F0)
	// 827EC1E8: 806301E8  lwz r3, 0x1e8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(488 as u32) ) } as u64;
	// 827EC1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1F0 size=8
    let mut pc: u32 = 0x827EC1F0;
    'dispatch: loop {
        match pc {
            0x827EC1F0 => {
    //   block [0x827EC1F0..0x827EC1F8)
	// 827EC1F0: 806301F4  lwz r3, 0x1f4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 827EC1F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC1F8 size=8
    let mut pc: u32 = 0x827EC1F8;
    'dispatch: loop {
        match pc {
            0x827EC1F8 => {
    //   block [0x827EC1F8..0x827EC200)
	// 827EC1F8: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC1FC: 4BFE37FC  b 0x827cf9f8
	sub_827CF9F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC200 size=8
    let mut pc: u32 = 0x827EC200;
    'dispatch: loop {
        match pc {
            0x827EC200 => {
    //   block [0x827EC200..0x827EC208)
	// 827EC200: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC204: 4BFE38B4  b 0x827cfab8
	sub_827CFAB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC208 size=96
    let mut pc: u32 = 0x827EC208;
    'dispatch: loop {
        match pc {
            0x827EC208 => {
    //   block [0x827EC208..0x827EC268)
	// 827EC208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC20C: 489BBF59  bl 0x831a8164
	ctx.lr = 0x827EC210;
	sub_831A8130(ctx, base);
	// 827EC210: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 827EC214: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC218: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EC21C: 83630204  lwz r27, 0x204(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC220: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC224: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EC228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC22C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EC230: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827EC234: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 827EC238: 4BD23291  bl 0x8250f4c8
	ctx.lr = 0x827EC23C;
	sub_8250F4C8(ctx, base);
	// 827EC23C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC240: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EC244: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EC248: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EC24C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827EC250: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 827EC254: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 827EC258: 4BFE40E1  bl 0x827d0338
	ctx.lr = 0x827EC25C;
	sub_827D0338(ctx, base);
	// 827EC25C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EC260: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 827EC264: 489BBF50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC268 size=8
    let mut pc: u32 = 0x827EC268;
    'dispatch: loop {
        match pc {
            0x827EC268 => {
    //   block [0x827EC268..0x827EC270)
	// 827EC268: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC26C: 4BFE33A4  b 0x827cf610
	sub_827CF610(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC270 size=8
    let mut pc: u32 = 0x827EC270;
    'dispatch: loop {
        match pc {
            0x827EC270 => {
    //   block [0x827EC270..0x827EC278)
	// 827EC270: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC274: 4BFE30FC  b 0x827cf370
	sub_827CF370(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC278 size=8
    let mut pc: u32 = 0x827EC278;
    'dispatch: loop {
        match pc {
            0x827EC278 => {
    //   block [0x827EC278..0x827EC280)
	// 827EC278: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC27C: 4BFE33FC  b 0x827cf678
	sub_827CF678(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC280 size=8
    let mut pc: u32 = 0x827EC280;
    'dispatch: loop {
        match pc {
            0x827EC280 => {
    //   block [0x827EC280..0x827EC288)
	// 827EC280: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC284: 4BFE3154  b 0x827cf3d8
	sub_827CF3D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC288 size=8
    let mut pc: u32 = 0x827EC288;
    'dispatch: loop {
        match pc {
            0x827EC288 => {
    //   block [0x827EC288..0x827EC290)
	// 827EC288: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC28C: 4BFE344C  b 0x827cf6d8
	sub_827CF6D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC290 size=8
    let mut pc: u32 = 0x827EC290;
    'dispatch: loop {
        match pc {
            0x827EC290 => {
    //   block [0x827EC290..0x827EC298)
	// 827EC290: 80630204  lwz r3, 0x204(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC294: 4BFE3B0C  b 0x827cfda0
	sub_827CFDA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC298 size=296
    let mut pc: u32 = 0x827EC298;
    'dispatch: loop {
        match pc {
            0x827EC298 => {
    //   block [0x827EC298..0x827EC3C0)
	// 827EC298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC29C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC2A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EC2A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC2A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC2AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC2B0: 48670BC9  bl 0x82e5ce78
	ctx.lr = 0x827EC2B4;
	sub_82E5CE78(ctx, base);
	// 827EC2B4: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC2B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC2BC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EC2C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC2C4: 4E800421  bctrl
	ctx.lr = 0x827EC2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC2C8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827EC2CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827EC2D0: 409A0084  bne cr6, 0x827ec354
	if !ctx.cr[6].eq {
	pc = 0x827EC354; continue 'dispatch;
	}
	// 827EC2D4: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC2DC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC2E0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827EC2E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC2E8: 4E800421  bctrl
	ctx.lr = 0x827EC2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC2EC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 827EC2F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EC2F4: 388B5D94  addi r4, r11, 0x5d94
	ctx.r[4].s64 = ctx.r[11].s64 + 23956;
	// 827EC2F8: 48607711  bl 0x82df3a08
	ctx.lr = 0x827EC2FC;
	sub_82DF3A08(ctx, base);
	// 827EC2FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EC300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC304: 486075AD  bl 0x82df38b0
	ctx.lr = 0x827EC308;
	sub_82DF38B0(ctx, base);
	// 827EC308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EC30C: 4860711D  bl 0x82df3428
	ctx.lr = 0x827EC310;
	sub_82DF3428(ctx, base);
	// 827EC310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EC314: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC318: 4867CE51  bl 0x82e69168
	ctx.lr = 0x827EC31C;
	sub_82E69168(ctx, base);
	// 827EC31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC320: 4866D401  bl 0x82e59720
	ctx.lr = 0x827EC324;
	sub_82E59720(ctx, base);
	// 827EC324: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827EC328: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827EC32C: 419A0018  beq cr6, 0x827ec344
	if ctx.cr[6].eq {
	pc = 0x827EC344; continue 'dispatch;
	}
	// 827EC330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC334: 4866E42D  bl 0x82e5a760
	ctx.lr = 0x827EC338;
	sub_82E5A760(ctx, base);
	// 827EC338: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827EC33C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827EC340: 409A000C  bne cr6, 0x827ec34c
	if !ctx.cr[6].eq {
	pc = 0x827EC34C; continue 'dispatch;
	}
	// 827EC344: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC348: 4867CEE9  bl 0x82e69230
	ctx.lr = 0x827EC34C;
	sub_82E69230(ctx, base);
	// 827EC34C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC350: 48000054  b 0x827ec3a4
	pc = 0x827EC3A4; continue 'dispatch;
	// 827EC354: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC358: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827EC35C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 827EC360: 41820048  beq 0x827ec3a8
	if ctx.cr[0].eq {
	pc = 0x827EC3A8; continue 'dispatch;
	}
	// 827EC364: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC368: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EC36C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EC370: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 827EC374: 83FF0060  lwz r31, 0x60(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 827EC378: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827EC37C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC380: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 827EC384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC388: 4E800421  bctrl
	ctx.lr = 0x827EC38C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC38C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC390: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EC394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC39C: 4E800421  bctrl
	ctx.lr = 0x827EC3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC3A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EC3A4: 48607085  bl 0x82df3428
	ctx.lr = 0x827EC3A8;
	sub_82DF3428(ctx, base);
	// 827EC3A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC3AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC3B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC3B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EC3B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC3BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC3C0 size=148
    let mut pc: u32 = 0x827EC3C0;
    'dispatch: loop {
        match pc {
            0x827EC3C0 => {
    //   block [0x827EC3C0..0x827EC454)
	// 827EC3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC3C4: 489BBDA1  bl 0x831a8164
	ctx.lr = 0x827EC3C8;
	sub_831A8130(ctx, base);
	// 827EC3C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC3CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC3D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827EC3D4: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 827EC3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC3DC: 419A004C  beq cr6, 0x827ec428
	if ctx.cr[6].eq {
	pc = 0x827EC428; continue 'dispatch;
	}
	// 827EC3E0: 83DF01FC  lwz r30, 0x1fc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 827EC3E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827EC3E8: 419A0040  beq cr6, 0x827ec428
	if ctx.cr[6].eq {
	pc = 0x827EC428; continue 'dispatch;
	}
	// 827EC3EC: 557C003E  slwi r28, r11, 0
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 827EC3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC3F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EC3F8: 482F7249  bl 0x82ae3640
	ctx.lr = 0x827EC3FC;
	sub_82AE3640(ctx, base);
	// 827EC3FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827EC400: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EC404: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EC408: 482F7101  bl 0x82ae3508
	ctx.lr = 0x827EC40C;
	sub_82AE3508(ctx, base);
	// 827EC40C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC410: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827EC414: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 827EC418: 4BB1B361  bl 0x82307778
	ctx.lr = 0x827EC41C;
	sub_82307778(ctx, base);
	// 827EC41C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EC424: 4BD9EAE5  bl 0x8258af08
	ctx.lr = 0x827EC428;
	sub_8258AF08(ctx, base);
	// 827EC428: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EC42C: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 827EC430: 4BFFFE69  bl 0x827ec298
	ctx.lr = 0x827EC434;
	sub_827EC298(ctx, base);
	// 827EC434: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EC438: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 827EC43C: 4BFFFE5D  bl 0x827ec298
	ctx.lr = 0x827EC440;
	sub_827EC298(ctx, base);
	// 827EC440: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EC444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC448: 4BD242C1  bl 0x82510708
	ctx.lr = 0x827EC44C;
	sub_82510708(ctx, base);
	// 827EC44C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 827EC450: 489BBD64  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC458 size=76
    let mut pc: u32 = 0x827EC458;
    'dispatch: loop {
        match pc {
            0x827EC458 => {
    //   block [0x827EC458..0x827EC4A4)
	// 827EC458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC464: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC468: 388300FC  addi r4, r3, 0xfc
	ctx.r[4].s64 = ctx.r[3].s64 + 252;
	// 827EC46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC470: 4866E0B1  bl 0x82e5a520
	ctx.lr = 0x827EC474;
	sub_82E5A520(ctx, base);
	// 827EC474: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EC478: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC480: 419A000C  beq cr6, 0x827ec48c
	if ctx.cr[6].eq {
	pc = 0x827EC48C; continue 'dispatch;
	}
	// 827EC484: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EC488: 4BAD4409  bl 0x822c0890
	ctx.lr = 0x827EC48C;
	sub_822C0890(ctx, base);
	// 827EC48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EC4A8 size=96
    let mut pc: u32 = 0x827EC4A8;
    'dispatch: loop {
        match pc {
            0x827EC4A8 => {
    //   block [0x827EC4A8..0x827EC508)
	// 827EC4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC4B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC4B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC4B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC4C0: 48607741  bl 0x82df3c00
	ctx.lr = 0x827EC4C4;
	sub_82DF3C00(ctx, base);
	// 827EC4C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EC4C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827EC4CC: 389F00FC  addi r4, r31, 0xfc
	ctx.r[4].s64 = ctx.r[31].s64 + 252;
	// 827EC4D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EC4D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EC4D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827EC4DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EC4E0: 48672519  bl 0x82e5e9f8
	ctx.lr = 0x827EC4E4;
	sub_82E5E9F8(ctx, base);
	// 827EC4E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EC4E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EC4EC: 419A0008  beq cr6, 0x827ec4f4
	if ctx.cr[6].eq {
	pc = 0x827EC4F4; continue 'dispatch;
	}
	// 827EC4F0: 4BAD43A1  bl 0x822c0890
	ctx.lr = 0x827EC4F4;
	sub_822C0890(ctx, base);
	// 827EC4F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC4F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC4FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EC508 size=108
    let mut pc: u32 = 0x827EC508;
    'dispatch: loop {
        match pc {
            0x827EC508 => {
    //   block [0x827EC508..0x827EC574)
	// 827EC508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC514: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC520: 486076E1  bl 0x82df3c00
	ctx.lr = 0x827EC524;
	sub_82DF3C00(ctx, base);
	// 827EC524: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EC528: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827EC52C: 389F0164  addi r4, r31, 0x164
	ctx.r[4].s64 = ctx.r[31].s64 + 356;
	// 827EC530: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EC534: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827EC538: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827EC53C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EC540: 48672421  bl 0x82e5e960
	ctx.lr = 0x827EC544;
	sub_82E5E960(ctx, base);
	// 827EC544: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827EC548: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC550: 419A000C  beq cr6, 0x827ec55c
	if ctx.cr[6].eq {
	pc = 0x827EC55C; continue 'dispatch;
	}
	// 827EC554: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EC558: 4BAD4339  bl 0x822c0890
	ctx.lr = 0x827EC55C;
	sub_822C0890(ctx, base);
	// 827EC55C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC578 size=76
    let mut pc: u32 = 0x827EC578;
    'dispatch: loop {
        match pc {
            0x827EC578 => {
    //   block [0x827EC578..0x827EC5C4)
	// 827EC578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EC580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EC584: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC588: 38830164  addi r4, r3, 0x164
	ctx.r[4].s64 = ctx.r[3].s64 + 356;
	// 827EC58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EC590: 4866DF91  bl 0x82e5a520
	ctx.lr = 0x827EC594;
	sub_82E5A520(ctx, base);
	// 827EC594: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EC598: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC5A0: 419A000C  beq cr6, 0x827ec5ac
	if ctx.cr[6].eq {
	pc = 0x827EC5AC; continue 'dispatch;
	}
	// 827EC5A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EC5A8: 4BAD42E9  bl 0x822c0890
	ctx.lr = 0x827EC5AC;
	sub_822C0890(ctx, base);
	// 827EC5AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC5B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EC5B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EC5B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EC5BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EC5C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC5C8 size=24
    let mut pc: u32 = 0x827EC5C8;
    'dispatch: loop {
        match pc {
            0x827EC5C8 => {
    //   block [0x827EC5C8..0x827EC5E0)
	// 827EC5C8: 816400EC  lwz r11, 0xec(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EC5CC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827EC5D0: 816400F0  lwz r11, 0xf0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(240 as u32) ) } as u64;
	// 827EC5D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC5D8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827EC5DC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EC5E0 size=36
    let mut pc: u32 = 0x827EC5E0;
    'dispatch: loop {
        match pc {
            0x827EC5E0 => {
    //   block [0x827EC5E0..0x827EC604)
	// 827EC5E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EC5E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EC5E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC5EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EC5F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EC5F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EC5F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC5FC: 4082FFE8  bne 0x827ec5e4
	if !ctx.cr[0].eq {
	pc = 0x827EC5E4; continue 'dispatch;
	}
	// 827EC600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EC608 size=144
    let mut pc: u32 = 0x827EC608;
    'dispatch: loop {
        match pc {
            0x827EC608 => {
    //   block [0x827EC608..0x827EC698)
	// 827EC608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC60C: 489BBB5D  bl 0x831a8168
	ctx.lr = 0x827EC610;
	sub_831A8130(ctx, base);
	// 827EC610: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 827EC614: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC618: 816300F0  lwz r11, 0xf0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 827EC61C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EC620: 814300EC  lwz r10, 0xec(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 827EC624: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EC628: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827EC62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC630: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EC634: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EC638: 419A0024  beq cr6, 0x827ec65c
	if ctx.cr[6].eq {
	pc = 0x827EC65C; continue 'dispatch;
	}
	// 827EC63C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EC640: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EC644: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC648: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EC64C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EC650: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EC654: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC658: 4082FFE8  bne 0x827ec640
	if !ctx.cr[0].eq {
	pc = 0x827EC640; continue 'dispatch;
	}
	// 827EC65C: 83A30204  lwz r29, 0x204(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC664: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EC668: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 827EC66C: 4BD22E5D  bl 0x8250f4c8
	ctx.lr = 0x827EC670;
	sub_8250F4C8(ctx, base);
	// 827EC670: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EC678: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827EC67C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827EC680: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827EC684: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827EC688: 4BFE2DB9  bl 0x827cf440
	ctx.lr = 0x827EC68C;
	sub_827CF440(ctx, base);
	// 827EC68C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827EC690: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 827EC694: 489BBB24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EC698 size=424
    let mut pc: u32 = 0x827EC698;
    'dispatch: loop {
        match pc {
            0x827EC698 => {
    //   block [0x827EC698..0x827EC840)
	// 827EC698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC69C: 489BBAB5  bl 0x831a8150
	ctx.lr = 0x827EC6A0;
	sub_831A8130(ctx, base);
	// 827EC6A0: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 827EC6A4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC6A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC6AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EC6B0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827EC6B4: 419A0180  beq cr6, 0x827ec834
	if ctx.cr[6].eq {
	pc = 0x827EC834; continue 'dispatch;
	}
	// 827EC6B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827EC6BC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 827EC6C0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827EC6C4: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 827EC6C8: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	// 827EC6CC: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827EC6D0: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 827EC6D4: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EC6D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC6DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC6E4: 4E800421  bctrl
	ctx.lr = 0x827EC6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC6E8: 483C0121  bl 0x82bac808
	ctx.lr = 0x827EC6EC;
	sub_82BAC808(ctx, base);
	// 827EC6EC: 4BFFDB7D  bl 0x827ea268
	ctx.lr = 0x827EC6F0;
	sub_827EA268(ctx, base);
	// 827EC6F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827EC6F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EC6F8: 48606AB9  bl 0x82df31b0
	ctx.lr = 0x827EC6FC;
	sub_82DF31B0(ctx, base);
	// 827EC6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC700: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827EC704: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827EC708: 487C0609  bl 0x82facd10
	ctx.lr = 0x827EC70C;
	sub_82FACD10(ctx, base);
	// 827EC70C: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 827EC710: 7C7C0734  extsh r28, r3
	ctx.r[28].s64 = ctx.r[3].s16 as i64;
	// 827EC714: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EC718: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC71C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EC724: 4E800421  bctrl
	ctx.lr = 0x827EC728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EC728: 482F7169  bl 0x82ae3890
	ctx.lr = 0x827EC72C;
	sub_82AE3890(ctx, base);
	// 827EC72C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 827EC730: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827EC734: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827EC738: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EC73C: 40820014  bne 0x827ec750
	if !ctx.cr[0].eq {
	pc = 0x827EC750; continue 'dispatch;
	}
	// 827EC740: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 827EC744: 1D7C0030  mulli r11, r28, 0x30
	ctx.r[11].s64 = ctx.r[28].s64 * 48;
	// 827EC748: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EC74C: 4800000C  b 0x827ec758
	pc = 0x827EC758; continue 'dispatch;
	// 827EC750: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827EC754: 487C2025  bl 0x82fae778
	ctx.lr = 0x827EC758;
	sub_82FAE778(ctx, base);
	// 827EC758: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 827EC75C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EC760: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 827EC764: 13C0EC07  vcmpneb. (lvlx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EC768: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 827EC76C: 13B9EC07  vcmpneb. (lvlx128) v29, v25, v29
	tmp.u32 = ctx.r[25].u32 + ctx.r[29].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EC770: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 827EC774: 139AEC07  vcmpneb. (lvlx128) v28, v26, v29
	tmp.u32 = ctx.r[26].u32 + ctx.r[29].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 827EC778: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EC840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EC840 size=176
    let mut pc: u32 = 0x827EC840;
    'dispatch: loop {
        match pc {
            0x827EC840 => {
    //   block [0x827EC840..0x827EC8F0)
	// 827EC840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EC844: 489BB91D  bl 0x831a8160
	ctx.lr = 0x827EC848;
	sub_831A8130(ctx, base);
	// 827EC848: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EC84C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827EC850: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827EC854: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827EC858: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 827EC85C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EC860: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EC864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC868: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827EC86C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827EC870: 419A0024  beq cr6, 0x827ec894
	if ctx.cr[6].eq {
	pc = 0x827EC894; continue 'dispatch;
	}
	// 827EC874: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827EC878: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827EC87C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC880: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827EC884: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827EC888: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EC88C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EC890: 4082FFE8  bne 0x827ec878
	if !ctx.cr[0].eq {
	pc = 0x827EC878; continue 'dispatch;
	}
	// 827EC894: 83630204  lwz r27, 0x204(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(516 as u32) ) } as u64;
	// 827EC898: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC89C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EC8A0: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 827EC8A4: 4BD22C25  bl 0x8250f4c8
	ctx.lr = 0x827EC8A8;
	sub_8250F4C8(ctx, base);
	// 827EC8A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827EC8AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EC8B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EC8B4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827EC8B8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827EC8BC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827EC8C0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EC8C4: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 827EC8C8: 4BFE37F9  bl 0x827d00c0
	ctx.lr = 0x827EC8CC;
	sub_827D00C0(ctx, base);
	// 827EC8CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EC8D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EC8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EC8D8: 419A000C  beq cr6, 0x827ec8e4
	if ctx.cr[6].eq {
	pc = 0x827EC8E4; continue 'dispatch;
	}
	// 827EC8DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EC8E0: 4BAD3FB1  bl 0x822c0890
	ctx.lr = 0x827EC8E4;
	sub_822C0890(ctx, base);
	// 827EC8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EC8E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EC8EC: 489BB8C4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


