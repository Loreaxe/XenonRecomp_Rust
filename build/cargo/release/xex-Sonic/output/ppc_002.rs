pub fn sub_822D4060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4060 size=116
    let mut pc: u32 = 0x822D4060;
    'dispatch: loop {
        match pc {
            0x822D4060 => {
    //   block [0x822D4060..0x822D40D4)
	// 822D4060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D406C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D4074: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D4078: 419A0040  beq cr6, 0x822d40b8
	if ctx.cr[6].eq {
	pc = 0x822D40B8; continue 'dispatch;
	}
	// 822D407C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822D4080: 0CDF0000  twi 6, r31, 0
	// 822D4084: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 822D4088: 2B0B0034  cmplwi cr6, r11, 0x34
	ctx.cr[6].compare_u32(ctx.r[11].u32, 52 as u32, &mut ctx.xer);
	// 822D408C: 4098002C  bge cr6, 0x822d40b8
	if !ctx.cr[6].lt {
	pc = 0x822D40B8; continue 'dispatch;
	}
	// 822D4090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D4094: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822D4098: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 822D409C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822D40A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D40A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822D40A8: 4BFF0209  bl 0x822c42b0
	ctx.lr = 0x822D40AC;
	sub_822C42B0(ctx, base);
	// 822D40AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D40B0: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 822D40B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822D40B8: 1C7F0034  mulli r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 * 52;
	// 822D40BC: 4BFEC87D  bl 0x822c0938
	ctx.lr = 0x822D40C0;
	sub_822C0938(ctx, base);
	// 822D40C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D40C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D40C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D40CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D40D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D40D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D40D8 size=132
    let mut pc: u32 = 0x822D40D8;
    'dispatch: loop {
        match pc {
            0x822D40D8 => {
    //   block [0x822D40D8..0x822D415C)
	// 822D40D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D40DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D40E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D40E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D40E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D40EC: 4BFFF43D  bl 0x822d3528
	ctx.lr = 0x822D40F0;
	sub_822D3528(ctx, base);
	// 822D40F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D40F4: 41820050  beq 0x822d4144
	if ctx.cr[0].eq {
	pc = 0x822D4144; continue 'dispatch;
	}
	// 822D40F8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822D40FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D4100: 4BFFFB59  bl 0x822d3c58
	ctx.lr = 0x822D4104;
	sub_822D3C58(ctx, base);
	// 822D4104: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D4108: 4182003C  beq 0x822d4144
	if ctx.cr[0].eq {
	pc = 0x822D4144; continue 'dispatch;
	}
	// 822D410C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D4110: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D4114: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822D4118: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822D411C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D4120: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D4124: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D4128: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822D412C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D4130: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822D4134: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822D4138: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D4160 size=112
    let mut pc: u32 = 0x822D4160;
    'dispatch: loop {
        match pc {
            0x822D4160 => {
    //   block [0x822D4160..0x822D41D0)
	// 822D4160: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D4164: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822D4168: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D416C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4170: 40990060  ble cr6, 0x822d41d0
	if !ctx.cr[6].gt {
		sub_822D41D0(ctx, base);
		return;
	}
	// 822D4174: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4178: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D417C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4184: 4099004C  ble cr6, 0x822d41d0
	if !ctx.cr[6].gt {
		sub_822D41D0(ctx, base);
		return;
	}
	// 822D4188: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D418C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 822D4190: 40990040  ble cr6, 0x822d41d0
	if !ctx.cr[6].gt {
		sub_822D41D0(ctx, base);
		return;
	}
	// 822D4194: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4198: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D419C: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 822D41A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D41A4: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D41A8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D41AC: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822D41B0: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D41B4: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 822D41B8: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 822D41BC: D181FFF4  stfs f12, -0xc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 822D41C0: D161FFF8  stfs f11, -8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 822D41C4: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D41D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D41D0 size=8
    let mut pc: u32 = 0x822D41D0;
    'dispatch: loop {
        match pc {
            0x822D41D0 => {
    //   block [0x822D41D0..0x822D41D8)
	// 822D41D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D41D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D41D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D41D8 size=264
    let mut pc: u32 = 0x822D41D8;
    'dispatch: loop {
        match pc {
            0x822D41D8 => {
    //   block [0x822D41D8..0x822D42E0)
	// 822D41D8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 822D41DC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 822D41E0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D41E4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822D41E8: 409A0018  bne cr6, 0x822d4200
	if !ctx.cr[6].eq {
	pc = 0x822D4200; continue 'dispatch;
	}
	// 822D41EC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D41F0: 40980008  bge cr6, 0x822d41f8
	if !ctx.cr[6].lt {
	pc = 0x822D41F8; continue 'dispatch;
	}
	// 822D41F4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822D41F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822D41FC: 480000D8  b 0x822d42d4
	pc = 0x822D42D4; continue 'dispatch;
	// 822D4200: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D4204: 419900CC  bgt cr6, 0x822d42d0
	if ctx.cr[6].gt {
	pc = 0x822D42D0; continue 'dispatch;
	}
	// 822D4208: 7D665850  subf r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 822D420C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D4210: 41980008  blt cr6, 0x822d4218
	if ctx.cr[6].lt {
	pc = 0x822D4218; continue 'dispatch;
	}
	// 822D4214: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 822D4218: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D421C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 822D4220: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 822D4224: 4198000C  blt cr6, 0x822d4230
	if ctx.cr[6].lt {
	pc = 0x822D4230; continue 'dispatch;
	}
	// 822D4228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D422C: 48000008  b 0x822d4234
	pc = 0x822D4234; continue 'dispatch;
	// 822D4230: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D4234: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4238: 7CEB2A14  add r7, r11, r5
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 822D423C: 7D450774  extsb r5, r10
	ctx.r[5].s64 = ctx.r[10].s8 as i64;
	// 822D4240: 89670000  lbz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4244: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 822D4248: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 822D424C: 409A0044  bne cr6, 0x822d4290
	if !ctx.cr[6].eq {
	pc = 0x822D4290; continue 'dispatch;
	}
	// 822D4250: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 822D4254: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 822D4258: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822D425C: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D4260: 41820028  beq 0x822d4288
	if ctx.cr[0].eq {
	pc = 0x822D4288; continue 'dispatch;
	}
	// 822D4264: 7D0B3214  add r8, r11, r6
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 822D4268: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D426C: 8BCA0000  lbz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4270: 7D3E4851  subf. r9, r30, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822D4274: 40820014  bne 0x822d4288
	if !ctx.cr[0].eq {
	pc = 0x822D4288; continue 'dispatch;
	}
	// 822D4278: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822D427C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4280: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 822D4284: 409AFFE4  bne cr6, 0x822d4268
	if !ctx.cr[6].eq {
	pc = 0x822D4268; continue 'dispatch;
	}
	// 822D4288: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D428C: 41820028  beq 0x822d42b4
	if ctx.cr[0].eq {
	pc = 0x822D42B4; continue 'dispatch;
	}
	// 822D4290: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 822D4294: 4198000C  blt cr6, 0x822d42a0
	if ctx.cr[6].lt {
	pc = 0x822D42A0; continue 'dispatch;
	}
	// 822D4298: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D429C: 48000008  b 0x822d42a4
	pc = 0x822D42A4; continue 'dispatch;
	// 822D42A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D42A4: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D42A8: 419A0028  beq cr6, 0x822d42d0
	if ctx.cr[6].eq {
	pc = 0x822D42D0; continue 'dispatch;
	}
	// 822D42AC: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 822D42B0: 4BFFFF90  b 0x822d4240
	pc = 0x822D4240; continue 'dispatch;
	// 822D42B4: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 822D42B8: 4198000C  blt cr6, 0x822d42c4
	if ctx.cr[6].lt {
	pc = 0x822D42C4; continue 'dispatch;
	}
	// 822D42BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D42C0: 48000008  b 0x822d42c8
	pc = 0x822D42C8; continue 'dispatch;
	// 822D42C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D42C8: 7C6B3850  subf r3, r11, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 822D42CC: 48000008  b 0x822d42d4
	pc = 0x822D42D4; continue 'dispatch;
	// 822D42D0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822D42D4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D42D8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 822D42DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D42E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D42E0 size=24
    let mut pc: u32 = 0x822D42E0;
    'dispatch: loop {
        match pc {
            0x822D42E0 => {
    //   block [0x822D42E0..0x822D42F8)
	// 822D42E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D42E4: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D42E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D42EC: 419A000C  beq cr6, 0x822d42f8
	if ctx.cr[6].eq {
		sub_822D42F8(ctx, base);
		return;
	}
	// 822D42F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D42F4: 48000070  b 0x822d4364
	sub_822D4364(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D42F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D42F8 size=24
    let mut pc: u32 = 0x822D42F8;
    'dispatch: loop {
        match pc {
            0x822D42F8 => {
    //   block [0x822D42F8..0x822D4310)
	// 822D42F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D42FC: 892A0031  lbz r9, 0x31(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D4300: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D4304: 409A0040  bne cr6, 0x822d4344
	if !ctx.cr[6].eq {
		sub_822D432C(ctx, base);
		return;
	}
	// 822D4308: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D430C: 4800000C  b 0x822d4318
	sub_822D4310(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D4310 size=28
    let mut pc: u32 = 0x822D4310;
    'dispatch: loop {
        match pc {
            0x822D4310 => {
    //   block [0x822D4310..0x822D432C)
	// 822D4310: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D4314: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4318: 892B0031  lbz r9, 0x31(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D431C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D4320: 419AFFF0  beq cr6, 0x822d4310
	if ctx.cr[6].eq {
	pc = 0x822D4310; continue 'dispatch;
	}
	// 822D4324: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D4328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D432C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D432C size=56
    let mut pc: u32 = 0x822D432C;
    'dispatch: loop {
        match pc {
            0x822D432C => {
    //   block [0x822D432C..0x822D4364)
	// 822D432C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4330: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4334: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822D4338: 409A001C  bne cr6, 0x822d4354
	if !ctx.cr[6].eq {
	pc = 0x822D4354; continue 'dispatch;
	}
	// 822D433C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4340: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D4344: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4348: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D434C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4350: 419AFFDC  beq cr6, 0x822d432c
	if ctx.cr[6].eq {
	pc = 0x822D432C; continue 'dispatch;
	}
	// 822D4354: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4358: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D435C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4360: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4364(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D4364 size=8
    let mut pc: u32 = 0x822D4364;
    'dispatch: loop {
        match pc {
            0x822D4364 => {
    //   block [0x822D4364..0x822D436C)
	// 822D4364: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D4370 size=116
    let mut pc: u32 = 0x822D4370;
    'dispatch: loop {
        match pc {
            0x822D4370 => {
    //   block [0x822D4370..0x822D43E4)
	// 822D4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4374: 48ED3DF9  bl 0x831a816c
	ctx.lr = 0x822D4378;
	sub_831A8130(ctx, base);
	// 822D4378: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D437C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D4380: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822D4384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D4388: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 822D438C: 48BA7B0D  bl 0x82e7be98
	ctx.lr = 0x822D4390;
	sub_82E7BE98(ctx, base);
	// 822D4390: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D4394: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 822D4398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D439C: 48BA7C3D  bl 0x82e7bfd8
	ctx.lr = 0x822D43A0;
	sub_82E7BFD8(ctx, base);
	// 822D43A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D43A4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 822D43A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D43AC: 4BFF0555  bl 0x822c4900
	ctx.lr = 0x822D43B0;
	sub_822C4900(ctx, base);
	// 822D43B0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 822D43B4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 822D43B8: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D43BC: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 822D43C0: 13C91C07  vcmpneb. (lvlx128) v30, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D43C4: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D43C8: 138B1C07  vcmpneb. (lvlx128) v28, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D43E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D43E8 size=652
    let mut pc: u32 = 0x822D43E8;
    'dispatch: loop {
        match pc {
            0x822D43E8 => {
    //   block [0x822D43E8..0x822D4674)
	// 822D43E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D43EC: 48ED3D55  bl 0x831a8140
	ctx.lr = 0x822D43F0;
	sub_831A8130(ctx, base);
	// 822D43F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D43F4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 822D43F8: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 822D43FC: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 822D4400: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 822D4404: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4408: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D440C: 419A0014  beq cr6, 0x822d4420
	if ctx.cr[6].eq {
	pc = 0x822D4420; continue 'dispatch;
	}
	// 822D4410: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4414: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822D4418: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822D441C: 5545DFFE  rlwinm r5, r10, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822D4420: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D4424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4428: 419A0238  beq cr6, 0x822d4660
	if ctx.cr[6].eq {
	pc = 0x822D4660; continue 'dispatch;
	}
	// 822D442C: 3AAB0014  addi r21, r11, 0x14
	ctx.r[21].s64 = ctx.r[11].s64 + 20;
	// 822D4430: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4434: 54B4063F  clrlwi. r20, r5, 0x18
	ctx.r[20].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 822D4438: 83F50000  lwz r31, 0(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D443C: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 822D4440: 40820008  bne 0x822d4448
	if !ctx.cr[0].eq {
	pc = 0x822D4448; continue 'dispatch;
	}
	// 822D4444: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 822D4448: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822D444C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4450: 48003FE9  bl 0x822d8438
	ctx.lr = 0x822D4454;
	sub_822D8438(ctx, base);
	// 822D4454: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D4458: 419A0174  beq cr6, 0x822d45cc
	if ctx.cr[6].eq {
	pc = 0x822D45CC; continue 'dispatch;
	}
	// 822D445C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4460: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D4464: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822D4468: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822D446C: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 822D4470: 7E779B78  mr r23, r19
	ctx.r[23].u64 = ctx.r[19].u64;
	// 822D4474: 3B6BA070  addi r27, r11, -0x5f90
	ctx.r[27].s64 = ctx.r[11].s64 + -24464;
	// 822D4478: 3B4AA060  addi r26, r10, -0x5fa0
	ctx.r[26].s64 = ctx.r[10].s64 + -24480;
	// 822D447C: 3B29A058  addi r25, r9, -0x5fa8
	ctx.r[25].s64 = ctx.r[9].s64 + -24488;
	// 822D4480: 3B08A050  addi r24, r8, -0x5fb0
	ctx.r[24].s64 = ctx.r[8].s64 + -24496;
	// 822D4484: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4488: 7FABB82E  lwzx r29, r11, r23
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 822D448C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4490: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 822D4494: 40990128  ble cr6, 0x822d45bc
	if !ctx.cr[6].gt {
	pc = 0x822D45BC; continue 'dispatch;
	}
	// 822D4498: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D449C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D44A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D44A4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D44A8: 7FCAE214  add r30, r10, r28
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 822D44AC: 419A00E0  beq cr6, 0x822d458c
	if ctx.cr[6].eq {
	pc = 0x822D458C; continue 'dispatch;
	}
	// 822D44B0: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 822D44B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D44B8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D44BC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D44C0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D44C4: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 822D44C8: 41820014  beq 0x822d44dc
	if ctx.cr[0].eq {
	pc = 0x822D44DC; continue 'dispatch;
	}
	// 822D44CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D44D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822D44D4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822D44D8: 419AFFE0  beq cr6, 0x822d44b8
	if ctx.cr[6].eq {
	pc = 0x822D44B8; continue 'dispatch;
	}
	// 822D44DC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D44E0: 40820010  bne 0x822d44f0
	if !ctx.cr[0].eq {
	pc = 0x822D44F0; continue 'dispatch;
	}
	// 822D44E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822D44E8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D44EC: 480000A0  b 0x822d458c
	pc = 0x822D458C; continue 'dispatch;
	// 822D44F0: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 822D44F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D44F8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D44FC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4500: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4504: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 822D4508: 41820014  beq 0x822d451c
	if ctx.cr[0].eq {
	pc = 0x822D451C; continue 'dispatch;
	}
	// 822D450C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4510: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822D4514: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822D4518: 419AFFE0  beq cr6, 0x822d44f8
	if ctx.cr[6].eq {
	pc = 0x822D44F8; continue 'dispatch;
	}
	// 822D451C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4520: 41820068  beq 0x822d4588
	if ctx.cr[0].eq {
	pc = 0x822D4588; continue 'dispatch;
	}
	// 822D4524: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822D4528: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D452C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4530: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4534: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4538: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 822D453C: 41820014  beq 0x822d4550
	if ctx.cr[0].eq {
	pc = 0x822D4550; continue 'dispatch;
	}
	// 822D4540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4544: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822D4548: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 822D454C: 419AFFE0  beq cr6, 0x822d452c
	if ctx.cr[6].eq {
	pc = 0x822D452C; continue 'dispatch;
	}
	// 822D4550: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4554: 41820034  beq 0x822d4588
	if ctx.cr[0].eq {
	pc = 0x822D4588; continue 'dispatch;
	}
	// 822D4558: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 822D455C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4560: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4564: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4568: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822D456C: 41820014  beq 0x822d4580
	if ctx.cr[0].eq {
	pc = 0x822D4580; continue 'dispatch;
	}
	// 822D4570: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822D4574: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4578: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822D457C: 419AFFE0  beq cr6, 0x822d455c
	if ctx.cr[6].eq {
	pc = 0x822D455C; continue 'dispatch;
	}
	// 822D4580: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4584: 40820008  bne 0x822d458c
	if !ctx.cr[0].eq {
	pc = 0x822D458C; continue 'dispatch;
	}
	// 822D4588: 927E0000  stw r19, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 822D458C: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 822D4590: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D4594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D4598: 4BFFFBC9  bl 0x822d4160
	ctx.lr = 0x822D459C;
	sub_822D4160(ctx, base);
	// 822D459C: 38BE0030  addi r5, r30, 0x30
	ctx.r[5].s64 = ctx.r[30].s64 + 48;
	// 822D45A0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 822D45A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D45A8: 4BFFFBB9  bl 0x822d4160
	ctx.lr = 0x822D45AC;
	sub_822D4160(ctx, base);
	// 822D45AC: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 822D45B0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822D45B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D45B8: 4BFFFBA9  bl 0x822d4160
	ctx.lr = 0x822D45BC;
	sub_822D4160(ctx, base);
	// 822D45BC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822D45C0: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 822D45C4: 3B9C0040  addi r28, r28, 0x40
	ctx.r[28].s64 = ctx.r[28].s64 + 64;
	// 822D45C8: 4082FEBC  bne 0x822d4484
	if !ctx.cr[0].eq {
	pc = 0x822D4484; continue 'dispatch;
	}
	// 822D45CC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 822D45D0: 419A0044  beq cr6, 0x822d4614
	if ctx.cr[6].eq {
	pc = 0x822D4614; continue 'dispatch;
	}
	// 822D45D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D45D8: 56CA3032  slwi r10, r22, 6
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822D45DC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 822D45E0: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 822D45E4: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 822D45E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D45EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D45F0: 3949FFC0  addi r10, r9, -0x40
	ctx.r[10].s64 = ctx.r[9].s64 + -64;
	// 822D45F4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D45F8: 90A9FFC0  stw r5, -0x40(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-64 as u32), ctx.r[5].u32 ) };
	// 822D45FC: 13EB30C7  vcmpequd (lvx128) v31, v11, v6
	tmp.u32 = ctx.r[11].u32 + ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4678 size=92
    let mut pc: u32 = 0x822D4678;
    'dispatch: loop {
        match pc {
            0x822D4678 => {
    //   block [0x822D4678..0x822D46D4)
	// 822D4678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D467C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4680: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4684: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D4688: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D468C: 4BFFF9D5  bl 0x822d4060
	ctx.lr = 0x822D4690;
	sub_822D4060(ctx, base);
	// 822D4690: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822D4694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D4698: 41820008  beq 0x822d46a0
	if ctx.cr[0].eq {
	pc = 0x822D46A0; continue 'dispatch;
	}
	// 822D469C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D46A0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D46A4: 41820008  beq 0x822d46ac
	if ctx.cr[0].eq {
	pc = 0x822D46AC; continue 'dispatch;
	}
	// 822D46A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D46AC: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D46B0: 41820008  beq 0x822d46b8
	if ctx.cr[0].eq {
	pc = 0x822D46B8; continue 'dispatch;
	}
	// 822D46B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D46B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822D46BC: 99430031  stb r10, 0x31(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(49 as u32), ctx.r[10].u8 ) };
	// 822D46C0: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 822D46C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D46C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D46CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D46D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D46D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D46D8 size=88
    let mut pc: u32 = 0x822D46D8;
    'dispatch: loop {
        match pc {
            0x822D46D8 => {
    //   block [0x822D46D8..0x822D4730)
	// 822D46D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D46DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D46E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D46E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D46E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D46EC: 4BFFFF8D  bl 0x822d4678
	ctx.lr = 0x822D46F0;
	sub_822D4678(ctx, base);
	// 822D46F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822D46F4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822D46F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822D46FC: 99630031  stb r11, 0x31(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 822D4700: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4704: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D4708: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D470C: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4710: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4714: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D4718: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D471C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D4720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D4724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D4728: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D472C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D4730 size=716
    let mut pc: u32 = 0x822D4730;
    'dispatch: loop {
        match pc {
            0x822D4730 => {
    //   block [0x822D4730..0x822D49FC)
	// 822D4730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4734: 48ED3A05  bl 0x831a8138
	ctx.lr = 0x822D4738;
	sub_831A8130(ctx, base);
	// 822D4738: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D473C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D4740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4744: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 822D4748: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822D474C: 388BA0A8  addi r4, r11, -0x5f58
	ctx.r[4].s64 = ctx.r[11].s64 + -24408;
	// 822D4750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4754: 4BFFEBAD  bl 0x822d3300
	ctx.lr = 0x822D4758;
	sub_822D3300(ctx, base);
	// 822D4758: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D475C: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 822D4760: 41820288  beq 0x822d49e8
	if ctx.cr[0].eq {
	pc = 0x822D49E8; continue 'dispatch;
	}
	// 822D4764: 9A210050  stb r17, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[17].u8 ) };
	// 822D4768: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D476C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D4770: 388BA0A0  addi r4, r11, -0x5f60
	ctx.r[4].s64 = ctx.r[11].s64 + -24416;
	// 822D4774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4778: 4BFFECF9  bl 0x822d3470
	ctx.lr = 0x822D477C;
	sub_822D3470(ctx, base);
	// 822D477C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4784: 388BA098  addi r4, r11, -0x5f68
	ctx.r[4].s64 = ctx.r[11].s64 + -24424;
	// 822D4788: 4BFFDC49  bl 0x822d23d0
	ctx.lr = 0x822D478C;
	sub_822D23D0(ctx, base);
	// 822D478C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 822D4790: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4794: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D479C: 4E800421  bctrl
	ctx.lr = 0x822D47A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D47A0: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D47A4: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 822D47A8: 28050000  cmplwi r5, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D47AC: 41820010  beq 0x822d47bc
	if ctx.cr[0].eq {
	pc = 0x822D47BC; continue 'dispatch;
	}
	// 822D47B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D47B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822D47B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D47BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822D47C0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D47C4: 48003C75  bl 0x822d8438
	ctx.lr = 0x822D47C8;
	sub_822D8438(ctx, base);
	// 822D47C8: 7E358B78  mr r21, r17
	ctx.r[21].u64 = ctx.r[17].u64;
	// 822D47CC: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 822D47D0: 4099017C  ble cr6, 0x822d494c
	if !ctx.cr[6].gt {
	pc = 0x822D494C; continue 'dispatch;
	}
	// 822D47D4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 822D47D8: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 822D47DC: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 822D47E0: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 822D47E4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822D47E8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822D47EC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D47F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D47F4: 7E348B78  mr r20, r17
	ctx.r[20].u64 = ctx.r[17].u64;
	// 822D47F8: 3BA7A090  addi r29, r7, -0x5f70
	ctx.r[29].s64 = ctx.r[7].s64 + -24432;
	// 822D47FC: 3B86A088  addi r28, r6, -0x5f78
	ctx.r[28].s64 = ctx.r[6].s64 + -24440;
	// 822D4800: 3B65A080  addi r27, r5, -0x5f80
	ctx.r[27].s64 = ctx.r[5].s64 + -24448;
	// 822D4804: 3B24A070  addi r25, r4, -0x5f90
	ctx.r[25].s64 = ctx.r[4].s64 + -24464;
	// 822D4808: 3B08A060  addi r24, r8, -0x5fa0
	ctx.r[24].s64 = ctx.r[8].s64 + -24480;
	// 822D480C: 3AE9A058  addi r23, r9, -0x5fa8
	ctx.r[23].s64 = ctx.r[9].s64 + -24488;
	// 822D4810: 3ACAA050  addi r22, r10, -0x5fb0
	ctx.r[22].s64 = ctx.r[10].s64 + -24496;
	// 822D4814: 3B4BA078  addi r26, r11, -0x5f88
	ctx.r[26].s64 = ctx.r[11].s64 + -24456;
	// 822D4818: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D481C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 822D4820: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 822D4824: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4828: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D482C: 4E800421  bctrl
	ctx.lr = 0x822D4830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D4830: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D4834: 41820108  beq 0x822d493c
	if ctx.cr[0].eq {
	pc = 0x822D493C; continue 'dispatch;
	}
	// 822D4838: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822D483C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4840: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D4844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D4848: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D484C: 7FEBA214  add r31, r11, r20
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 822D4850: 4BFF0491  bl 0x822c4ce0
	ctx.lr = 0x822D4854;
	sub_822C4CE0(ctx, base);
	// 822D4854: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822D4858: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D485C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4860: 4BFFE9E1  bl 0x822d3240
	ctx.lr = 0x822D4864;
	sub_822D3240(ctx, base);
	// 822D4864: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D4868: 41820094  beq 0x822d48fc
	if ctx.cr[0].eq {
	pc = 0x822D48FC; continue 'dispatch;
	}
	// 822D486C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 822D4870: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D4874: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 822D4878: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D487C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D4880: 4BFFDD71  bl 0x822d25f0
	ctx.lr = 0x822D4884;
	sub_822D25F0(ctx, base);
	// 822D4884: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D4888: 40820010  bne 0x822d4898
	if !ctx.cr[0].eq {
	pc = 0x822D4898; continue 'dispatch;
	}
	// 822D488C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822D4890: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4894: 48000068  b 0x822d48fc
	pc = 0x822D48FC; continue 'dispatch;
	// 822D4898: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 822D489C: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D48A0: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 822D48A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D48A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D48AC: 4BFFDD45  bl 0x822d25f0
	ctx.lr = 0x822D48B0;
	sub_822D25F0(ctx, base);
	// 822D48B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D48B4: 41820044  beq 0x822d48f8
	if ctx.cr[0].eq {
	pc = 0x822D48F8; continue 'dispatch;
	}
	// 822D48B8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822D48BC: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D48C0: 38E0000D  li r7, 0xd
	ctx.r[7].s64 = 13;
	// 822D48C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D48C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D48CC: 4BFFDD25  bl 0x822d25f0
	ctx.lr = 0x822D48D0;
	sub_822D25F0(ctx, base);
	// 822D48D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D48D4: 41820024  beq 0x822d48f8
	if ctx.cr[0].eq {
	pc = 0x822D48F8; continue 'dispatch;
	}
	// 822D48D8: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 822D48DC: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D48E0: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 822D48E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D48E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D48EC: 4BFFDD05  bl 0x822d25f0
	ctx.lr = 0x822D48F0;
	sub_822D25F0(ctx, base);
	// 822D48F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D48F4: 40820008  bne 0x822d48fc
	if !ctx.cr[0].eq {
	pc = 0x822D48FC; continue 'dispatch;
	}
	// 822D48F8: 923F0000  stw r17, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 822D48FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D4900: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 822D4904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4908: 4BFFF7D1  bl 0x822d40d8
	ctx.lr = 0x822D490C;
	sub_822D40D8(ctx, base);
	// 822D490C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D4910: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 822D4914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4918: 4BFFF7C1  bl 0x822d40d8
	ctx.lr = 0x822D491C;
	sub_822D40D8(ctx, base);
	// 822D491C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D4920: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 822D4924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4928: 4BFFF7B1  bl 0x822d40d8
	ctx.lr = 0x822D492C;
	sub_822D40D8(ctx, base);
	// 822D492C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4930: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D4934: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D4938: 4BFF03A9  bl 0x822c4ce0
	ctx.lr = 0x822D493C;
	sub_822C4CE0(ctx, base);
	// 822D493C: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 822D4940: 3A940040  addi r20, r20, 0x40
	ctx.r[20].s64 = ctx.r[20].s64 + 64;
	// 822D4944: 7F159000  cmpw cr6, r21, r18
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[18].s32, &mut ctx.xer);
	// 822D4948: 4198FED0  blt cr6, 0x822d4818
	if ctx.cr[6].lt {
	pc = 0x822D4818; continue 'dispatch;
	}
	// 822D494C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D4950: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D4954: 41820048  beq 0x822d499c
	if ctx.cr[0].eq {
	pc = 0x822D499C; continue 'dispatch;
	}
	// 822D4958: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822D495C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 822D4960: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D4964: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 822D4968: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 822D496C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822D4970: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4974: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D4978: 3949FFC0  addi r10, r9, -0x40
	ctx.r[10].s64 = ctx.r[9].s64 + -64;
	// 822D497C: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4980: 90A9FFC0  stw r5, -0x40(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-64 as u32), ctx.r[5].u32 ) };
	// 822D4984: 13EB30C7  vcmpequd (lvx128) v31, v11, v6
	tmp.u32 = ctx.r[11].u32 + ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4A00 size=88
    let mut pc: u32 = 0x822D4A00;
    'dispatch: loop {
        match pc {
            0x822D4A00 => {
    //   block [0x822D4A00..0x822D4A58)
	// 822D4A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4A04: 48ED3769  bl 0x831a816c
	ctx.lr = 0x822D4A08;
	sub_831A8130(ctx, base);
	// 822D4A08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4A0C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4A10: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D4A14: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4A18: 48000028  b 0x822d4a40
	pc = 0x822D4A40; continue 'dispatch;
	// 822D4A1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D4A20: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822D4A24: 4BFFF4C5  bl 0x822d3ee8
	ctx.lr = 0x822D4A28;
	sub_822D3EE8(ctx, base);
	// 822D4A28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D4A2C: 4182000C  beq 0x822d4a38
	if ctx.cr[0].eq {
	pc = 0x822D4A38; continue 'dispatch;
	}
	// 822D4A30: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4A34: 4800000C  b 0x822d4a40
	pc = 0x822D4A40; continue 'dispatch;
	// 822D4A38: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822D4A3C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4A40: 897F0031  lbz r11, 0x31(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D4A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D4A48: 419AFFD4  beq cr6, 0x822d4a1c
	if ctx.cr[6].eq {
	pc = 0x822D4A1C; continue 'dispatch;
	}
	// 822D4A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4A50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D4A54: 48ED3768  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4A58 size=252
    let mut pc: u32 = 0x822D4A58;
    'dispatch: loop {
        match pc {
            0x822D4A58 => {
    //   block [0x822D4A58..0x822D4B54)
	// 822D4A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4A5C: 48ED3709  bl 0x831a8164
	ctx.lr = 0x822D4A60;
	sub_831A8130(ctx, base);
	// 822D4A60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4A64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D4A68: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D4A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D4A70: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822D4A74: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4A78: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D4A7C: 40980008  bge cr6, 0x822d4a84
	if !ctx.cr[6].lt {
	pc = 0x822D4A84; continue 'dispatch;
	}
	// 822D4A80: 48B1BDF9  bl 0x82df0878
	ctx.lr = 0x822D4A84;
	sub_82DF0878(ctx, base);
	// 822D4A84: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4A88: 7D7B5850  subf r11, r27, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 822D4A8C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822D4A90: 40980008  bge cr6, 0x822d4a98
	if !ctx.cr[6].lt {
	pc = 0x822D4A98; continue 'dispatch;
	}
	// 822D4A94: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822D4A98: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4A9C: 214BFFFF  subfic r10, r11, -1
	ctx.xer.ca = ctx.r[11].u32 <= -1 as u32;
	ctx.r[10].s64 = (-1 as i64) - ctx.r[11].s64;
	// 822D4AA0: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822D4AA4: 40990010  ble cr6, 0x822d4ab4
	if !ctx.cr[6].gt {
	pc = 0x822D4AB4; continue 'dispatch;
	}
	// 822D4AA8: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822D4AAC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D4AB0: 40980008  bge cr6, 0x822d4ab8
	if !ctx.cr[6].lt {
	pc = 0x822D4AB8; continue 'dispatch;
	}
	// 822D4AB4: 48B1BC8D  bl 0x82df0740
	ctx.lr = 0x822D4AB8;
	sub_82DF0740(ctx, base);
	// 822D4AB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822D4ABC: 419A008C  beq cr6, 0x822d4b48
	if ctx.cr[6].eq {
	pc = 0x822D4B48; continue 'dispatch;
	}
	// 822D4AC0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4AC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4ACC: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822D4AD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D4AD4: 4BFF08E5  bl 0x822c53b8
	ctx.lr = 0x822D4AD8;
	sub_822C53B8(ctx, base);
	// 822D4AD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D4ADC: 4182006C  beq 0x822d4b48
	if ctx.cr[0].eq {
	pc = 0x822D4B48; continue 'dispatch;
	}
	// 822D4AE0: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D4AE4: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 822D4AE8: 4198000C  blt cr6, 0x822d4af4
	if ctx.cr[6].lt {
	pc = 0x822D4AF4; continue 'dispatch;
	}
	// 822D4AEC: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4AF0: 48000008  b 0x822d4af8
	pc = 0x822D4AF8; continue 'dispatch;
	// 822D4AF4: 391D0004  addi r8, r29, 4
	ctx.r[8].s64 = ctx.r[29].s64 + 4;
	// 822D4AF8: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D4AFC: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 822D4B00: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 822D4B04: 4198000C  blt cr6, 0x822d4b10
	if ctx.cr[6].lt {
	pc = 0x822D4B10; continue 'dispatch;
	}
	// 822D4B08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4B0C: 48000008  b 0x822d4b14
	pc = 0x822D4B14; continue 'dispatch;
	// 822D4B10: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 822D4B14: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4B18: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822D4B1C: 7CA8DA14  add r5, r8, r27
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[27].u64;
	// 822D4B20: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822D4B24: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822D4B28: 48ED4109  bl 0x831a8c30
	ctx.lr = 0x822D4B2C;
	sub_831A8C30(ctx, base);
	// 822D4B2C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D4B30: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 822D4B34: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 822D4B38: 41980008  blt cr6, 0x822d4b40
	if ctx.cr[6].lt {
	pc = 0x822D4B40; continue 'dispatch;
	}
	// 822D4B3C: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D4B44: 7D7DE1AE  stbx r11, r29, r28
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32), ctx.r[11].u8) };
	// 822D4B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4B4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D4B50: 48ED3664  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4B58 size=184
    let mut pc: u32 = 0x822D4B58;
    'dispatch: loop {
        match pc {
            0x822D4B58 => {
    //   block [0x822D4B58..0x822D4C10)
	// 822D4B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D4B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D4B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4B6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D4B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D4B74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822D4B78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D4B7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4B80: 4BFEBDB9  bl 0x822c0938
	ctx.lr = 0x822D4B84;
	sub_822C0938(ctx, base);
	// 822D4B84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D4B88: 41820028  beq 0x822d4bb0
	if ctx.cr[0].eq {
	pc = 0x822D4BB0; continue 'dispatch;
	}
	// 822D4B8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4B90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822D4B94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822D4B98: 392BA040  addi r9, r11, -0x5fc0
	ctx.r[9].s64 = ctx.r[11].s64 + -24512;
	// 822D4B9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D4BA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D4BA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D4BA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D4BAC: 48000008  b 0x822d4bb4
	pc = 0x822D4BB4; continue 'dispatch;
	// 822D4BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D4BB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D4BBC: 409A0038  bne cr6, 0x822d4bf4
	if !ctx.cr[6].eq {
	pc = 0x822D4BF4; continue 'dispatch;
	}
	// 822D4BC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D4BC4: 419A0010  beq cr6, 0x822d4bd4
	if ctx.cr[6].eq {
	pc = 0x822D4BD4; continue 'dispatch;
	}
	// 822D4BC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D4BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4BD0: 482185B1  bl 0x824ed180
	ctx.lr = 0x822D4BD4;
	sub_824ED180(ctx, base);
	// 822D4BD4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822D4BD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D4BDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4BE0: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822D4BE4: 816B2F28  lwz r11, 0x2f28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12072 as u32) ) } as u64;
	// 822D4BE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822D4BEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D4BF0: 4BFEB411  bl 0x822c0000
	ctx.lr = 0x822D4BF4;
	sub_822C0000(ctx, base);
	// 822D4BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4BF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D4BFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D4C00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D4C04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D4C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D4C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4C10 size=112
    let mut pc: u32 = 0x822D4C10;
    'dispatch: loop {
        match pc {
            0x822D4C10 => {
    //   block [0x822D4C10..0x822D4C80)
	// 822D4C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4C14: 48ED3559  bl 0x831a816c
	ctx.lr = 0x822D4C18;
	sub_831A8130(ctx, base);
	// 822D4C18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4C1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D4C20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D4C24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D4C28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D4C2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4C30: 4BFFFDD1  bl 0x822d4a00
	ctx.lr = 0x822D4C34;
	sub_822D4A00(ctx, base);
	// 822D4C34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4C38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822D4C3C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D4C40: 419A0020  beq cr6, 0x822d4c60
	if ctx.cr[6].eq {
	pc = 0x822D4C60; continue 'dispatch;
	}
	// 822D4C44: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 822D4C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D4C4C: 4BFFF29D  bl 0x822d3ee8
	ctx.lr = 0x822D4C50;
	sub_822D3EE8(ctx, base);
	// 822D4C50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D4C54: 4082000C  bne 0x822d4c60
	if !ctx.cr[0].eq {
	pc = 0x822D4C60; continue 'dispatch;
	}
	// 822D4C58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D4C5C: 48000010  b 0x822d4c6c
	pc = 0x822D4C6C; continue 'dispatch;
	// 822D4C60: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4C64: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 822D4C68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822D4C6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4C70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D4C74: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D4C78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D4C7C: 48ED3540  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4C80 size=120
    let mut pc: u32 = 0x822D4C80;
    'dispatch: loop {
        match pc {
            0x822D4C80 => {
    //   block [0x822D4C80..0x822D4CF8)
	// 822D4C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D4C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D4C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4C94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D4C98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D4C9C: 4BFF0AD5  bl 0x822c5770
	ctx.lr = 0x822D4CA0;
	sub_822C5770(ctx, base);
	// 822D4CA0: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 822D4CA4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822D4CA8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 822D4CAC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822D4CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D4CB4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822D4CB8: 419A0024  beq cr6, 0x822d4cdc
	if ctx.cr[6].eq {
	pc = 0x822D4CDC; continue 'dispatch;
	}
	// 822D4CBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822D4CC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D4CC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D4CC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D4CCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4CD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D4CD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D4CD8: 4082FFE8  bne 0x822d4cc0
	if !ctx.cr[0].eq {
	pc = 0x822D4CC0; continue 'dispatch;
	}
	// 822D4CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4CE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D4CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D4CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D4CEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D4CF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D4CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4CF8 size=120
    let mut pc: u32 = 0x822D4CF8;
    'dispatch: loop {
        match pc {
            0x822D4CF8 => {
    //   block [0x822D4CF8..0x822D4D70)
	// 822D4CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D4D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D4D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D4D10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D4D14: 4BFF0A5D  bl 0x822c5770
	ctx.lr = 0x822D4D18;
	sub_822C5770(ctx, base);
	// 822D4D18: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 822D4D1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4D20: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 822D4D24: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4D28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D4D2C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822D4D30: 419A0024  beq cr6, 0x822d4d54
	if ctx.cr[6].eq {
	pc = 0x822D4D54; continue 'dispatch;
	}
	// 822D4D34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822D4D38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D4D3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D4D40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D4D44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D4D48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D4D4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D4D50: 4082FFE8  bne 0x822d4d38
	if !ctx.cr[0].eq {
	pc = 0x822D4D38; continue 'dispatch;
	}
	// 822D4D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4D58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D4D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D4D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D4D64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D4D68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D4D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D4D70 size=148
    let mut pc: u32 = 0x822D4D70;
    'dispatch: loop {
        match pc {
            0x822D4D70 => {
    //   block [0x822D4D70..0x822D4E04)
	// 822D4D70: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4D74: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 822D4D78: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4D7C: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 822D4D80: 80C3000C  lwz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D4D84: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822D4D88: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D4D8C: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 822D4D90: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4D94: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D4D98: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 822D4D9C: 90C90008  stw r6, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 822D4DA0: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 822D4DA4: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4DA8: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D4DAC: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4DB0: 80E7000C  lwz r7, 0xc(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D4DB4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D4DB8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4DBC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D4DC0: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D4DC4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822D4DC8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D4DCC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822D4DD0: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D4DD4: 91240008  stw r9, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822D4DD8: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 822D4DDC: 90E40010  stw r7, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 822D4DE0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4DE4: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D4DE8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822D4DEC: 91640014  stw r11, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822D4DF0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D4DF4: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D4DF8: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822D4DFC: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822D4E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4E08 size=108
    let mut pc: u32 = 0x822D4E08;
    'dispatch: loop {
        match pc {
            0x822D4E08 => {
    //   block [0x822D4E08..0x822D4E74)
	// 822D4E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D4E10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D4E14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D4E18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D4E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4E24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D4E28: 4BFF0AA1  bl 0x822c58c8
	ctx.lr = 0x822D4E2C;
	sub_822C58C8(ctx, base);
	// 822D4E2C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822D4E30: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4E34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D4E38: 4BFFFC21  bl 0x822d4a58
	ctx.lr = 0x822D4E3C;
	sub_822D4A58(ctx, base);
	// 822D4E3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D4E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4E44: 4BFF092D  bl 0x822c5770
	ctx.lr = 0x822D4E48;
	sub_822C5770(ctx, base);
	// 822D4E48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4E4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D4E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4E54: 4BFEFE8D  bl 0x822c4ce0
	ctx.lr = 0x822D4E58;
	sub_822C4CE0(ctx, base);
	// 822D4E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4E5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822D4E60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D4E64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D4E68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D4E6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D4E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4E78 size=108
    let mut pc: u32 = 0x822D4E78;
    'dispatch: loop {
        match pc {
            0x822D4E78 => {
    //   block [0x822D4E78..0x822D4EE4)
	// 822D4E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4E7C: 48ED32E5  bl 0x831a8160
	ctx.lr = 0x822D4E80;
	sub_831A8130(ctx, base);
	// 822D4E80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4E84: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D4E88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D4E8C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D4E90: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822D4E94: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822D4E98: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 822D4E9C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822D4EA0: 48006B31  bl 0x822db9d0
	ctx.lr = 0x822D4EA4;
	sub_822DB9D0(ctx, base);
	// 822D4EA4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822D4EA8: 41820030  beq 0x822d4ed8
	if ctx.cr[0].eq {
	pc = 0x822D4ED8; continue 'dispatch;
	}
	// 822D4EAC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822D4EB0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822D4EB4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822D4EB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D4EBC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 822D4EC0: 4BFF08B1  bl 0x822c5770
	ctx.lr = 0x822D4EC4;
	sub_822C5770(ctx, base);
	// 822D4EC4: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822D4EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D4ECC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822D4ED0: 9B5F002C  stb r26, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 822D4ED4: 997F002D  stb r11, 0x2d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(45 as u32), ctx.r[11].u8 ) };
	// 822D4ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4EDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822D4EE0: 48ED32D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4EE8 size=100
    let mut pc: u32 = 0x822D4EE8;
    'dispatch: loop {
        match pc {
            0x822D4EE8 => {
    //   block [0x822D4EE8..0x822D4F4C)
	// 822D4EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4EEC: 48ED3275  bl 0x831a8160
	ctx.lr = 0x822D4EF0;
	sub_831A8130(ctx, base);
	// 822D4EF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4EF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D4EF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D4EFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D4F00: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822D4F04: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822D4F08: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822D4F0C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822D4F10: 4BFFF151  bl 0x822d4060
	ctx.lr = 0x822D4F14;
	sub_822D4060(ctx, base);
	// 822D4F14: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822D4F18: 41820028  beq 0x822d4f40
	if ctx.cr[0].eq {
	pc = 0x822D4F40; continue 'dispatch;
	}
	// 822D4F1C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822D4F20: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D4F24: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822D4F28: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822D4F2C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D4F30: 4BFFFD51  bl 0x822d4c80
	ctx.lr = 0x822D4F34;
	sub_822D4C80(ctx, base);
	// 822D4F34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D4F38: 9B5F0030  stb r26, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[26].u8 ) };
	// 822D4F3C: 997F0031  stb r11, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 822D4F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D4F44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822D4F48: 48ED3268  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D4F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D4F50 size=1044
    let mut pc: u32 = 0x822D4F50;
    'dispatch: loop {
        match pc {
            0x822D4F50 => {
    //   block [0x822D4F50..0x822D5364)
	// 822D4F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D4F54: 48ED3205  bl 0x831a8158
	ctx.lr = 0x822D4F58;
	sub_831A8130(ctx, base);
	// 822D4F58: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D4F5C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D4F60: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822D4F64: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822D4F68: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 822D4F6C: 897F0031  lbz r11, 0x31(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D4F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D4F74: 419A0048  beq cr6, 0x822d4fbc
	if ctx.cr[6].eq {
	pc = 0x822D4FBC; continue 'dispatch;
	}
	// 822D4F78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4F80: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 822D4F84: 4BFF0945  bl 0x822c58c8
	ctx.lr = 0x822D4F88;
	sub_822C58C8(ctx, base);
	// 822D4F88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D4F8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D4F90: 4BFF4F21  bl 0x822c9eb0
	ctx.lr = 0x822D4F94;
	sub_822C9EB0(ctx, base);
	// 822D4F94: 4BFEF31D  bl 0x822c42b0
	ctx.lr = 0x822D4F98;
	sub_822C42B0(ctx, base);
	// 822D4F98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D4F9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D4FA0: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 822D4FA4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822D4FA8: 4BFF04C9  bl 0x822c5470
	ctx.lr = 0x822D4FAC;
	sub_822C5470(ctx, base);
	// 822D4FAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D4FB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D4FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D4FB8: 4BFEFD29  bl 0x822c4ce0
	ctx.lr = 0x822D4FBC;
	sub_822C4CE0(ctx, base);
	// 822D4FBC: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 822D4FC0: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822D4FC4: 482141BD  bl 0x824e9180
	ctx.lr = 0x822D4FC8;
	sub_824E9180(ctx, base);
	// 822D4FC8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D4FCC: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D4FD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4FD4: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822D4FD8: 419A000C  beq cr6, 0x822d4fe4
	if ctx.cr[6].eq {
	pc = 0x822D4FE4; continue 'dispatch;
	}
	// 822D4FDC: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4FE0: 48000028  b 0x822d5008
	pc = 0x822D5008; continue 'dispatch;
	// 822D4FE4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D4FE8: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D4FEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D4FF0: 419A000C  beq cr6, 0x822d4ffc
	if ctx.cr[6].eq {
	pc = 0x822D4FFC; continue 'dispatch;
	}
	// 822D4FF4: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822D4FF8: 48000010  b 0x822d5008
	pc = 0x822D5008; continue 'dispatch;
	// 822D4FFC: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5000: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5004: 409A00DC  bne cr6, 0x822d50e0
	if !ctx.cr[6].eq {
	pc = 0x822D50E0; continue 'dispatch;
	}
	// 822D5008: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D500C: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5014: 409A0008  bne cr6, 0x822d501c
	if !ctx.cr[6].eq {
	pc = 0x822D501C; continue 'dispatch;
	}
	// 822D5018: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822D501C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5020: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5024: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5028: 409A000C  bne cr6, 0x822d5034
	if !ctx.cr[6].eq {
	pc = 0x822D5034; continue 'dispatch;
	}
	// 822D502C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822D5030: 4800001C  b 0x822d504c
	pc = 0x822D504C; continue 'dispatch;
	// 822D5034: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5038: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D503C: 409A000C  bne cr6, 0x822d5048
	if !ctx.cr[6].eq {
	pc = 0x822D5048; continue 'dispatch;
	}
	// 822D5040: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5044: 48000008  b 0x822d504c
	pc = 0x822D504C; continue 'dispatch;
	// 822D5048: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D504C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5050: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5054: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5058: 409A003C  bne cr6, 0x822d5094
	if !ctx.cr[6].eq {
	pc = 0x822D5094; continue 'dispatch;
	}
	// 822D505C: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D5060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5064: 419A000C  beq cr6, 0x822d5070
	if ctx.cr[6].eq {
	pc = 0x822D5070; continue 'dispatch;
	}
	// 822D5068: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822D506C: 48000024  b 0x822d5090
	pc = 0x822D5090; continue 'dispatch;
	// 822D5070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5074: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822D5078: 4800000C  b 0x822d5084
	pc = 0x822D5084; continue 'dispatch;
	// 822D507C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D5080: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5084: 890B0031  lbz r8, 0x31(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D5088: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D508C: 419AFFF0  beq cr6, 0x822d507c
	if ctx.cr[6].eq {
	pc = 0x822D507C; continue 'dispatch;
	}
	// 822D5090: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D5094: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5098: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D509C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D50A0: 409A00D4  bne cr6, 0x822d5174
	if !ctx.cr[6].eq {
	pc = 0x822D5174; continue 'dispatch;
	}
	// 822D50A4: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D50A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D50AC: 419A000C  beq cr6, 0x822d50b8
	if ctx.cr[6].eq {
	pc = 0x822D50B8; continue 'dispatch;
	}
	// 822D50B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822D50B4: 48000024  b 0x822d50d8
	pc = 0x822D50D8; continue 'dispatch;
	// 822D50B8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D50BC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822D50C0: 4800000C  b 0x822d50cc
	pc = 0x822D50CC; continue 'dispatch;
	// 822D50C4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822D50C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D50CC: 890B0031  lbz r8, 0x31(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D50D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D50D4: 419AFFF0  beq cr6, 0x822d50c4
	if ctx.cr[6].eq {
	pc = 0x822D50C4; continue 'dispatch;
	}
	// 822D50D8: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D50DC: 48000098  b 0x822d5174
	pc = 0x822D5174; continue 'dispatch;
	// 822D50E0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822D50E4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D50E8: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D50EC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D50F0: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D50F4: 409A000C  bne cr6, 0x822d5100
	if !ctx.cr[6].eq {
	pc = 0x822D5100; continue 'dispatch;
	}
	// 822D50F8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822D50FC: 4800002C  b 0x822d5128
	pc = 0x822D5128; continue 'dispatch;
	// 822D5100: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D5104: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D510C: 409A0008  bne cr6, 0x822d5114
	if !ctx.cr[6].eq {
	pc = 0x822D5114; continue 'dispatch;
	}
	// 822D5110: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822D5114: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5118: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D511C: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5120: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5124: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822D5128: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D512C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5130: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5134: 409A000C  bne cr6, 0x822d5140
	if !ctx.cr[6].eq {
	pc = 0x822D5140; continue 'dispatch;
	}
	// 822D5138: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822D513C: 48000020  b 0x822d515c
	pc = 0x822D515C; continue 'dispatch;
	// 822D5140: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5144: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5148: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D514C: 409A000C  bne cr6, 0x822d5158
	if !ctx.cr[6].eq {
	pc = 0x822D5158; continue 'dispatch;
	}
	// 822D5150: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822D5154: 48000008  b 0x822d515c
	pc = 0x822D515C; continue 'dispatch;
	// 822D5158: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 822D515C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5160: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D5164: 897B0030  lbz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5168: 89590030  lbz r10, 0x30(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D516C: 99790030  stb r11, 0x30(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 822D5170: 995B0030  stb r10, 0x30(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 822D5174: 897B0030  lbz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5178: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D517C: 409A0198  bne cr6, 0x822d5314
	if !ctx.cr[6].eq {
	pc = 0x822D5314; continue 'dispatch;
	}
	// 822D5180: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5184: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822D5188: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D518C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5190: 419A0180  beq cr6, 0x822d5310
	if ctx.cr[6].eq {
	pc = 0x822D5310; continue 'dispatch;
	}
	// 822D5194: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822D5198: 897C0030  lbz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D519C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D51A0: 409A0170  bne cr6, 0x822d5310
	if !ctx.cr[6].eq {
	pc = 0x822D5310; continue 'dispatch;
	}
	// 822D51A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D51A8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D51AC: 409A00A8  bne cr6, 0x822d5254
	if !ctx.cr[6].eq {
	pc = 0x822D5254; continue 'dispatch;
	}
	// 822D51B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D51B4: 894B0030  lbz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D51B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D51BC: 409A001C  bne cr6, 0x822d51d8
	if !ctx.cr[6].eq {
	pc = 0x822D51D8; continue 'dispatch;
	}
	// 822D51C0: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D51C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D51C8: 9BBF0030  stb r29, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D51CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D51D0: 4BFF4241  bl 0x822c9410
	ctx.lr = 0x822D51D4;
	sub_822C9410(ctx, base);
	// 822D51D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D51D8: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D51DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D51E0: 409A00C8  bne cr6, 0x822d52a8
	if !ctx.cr[6].eq {
	pc = 0x822D52A8; continue 'dispatch;
	}
	// 822D51E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D51E8: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D51EC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D51F0: 409A0014  bne cr6, 0x822d5204
	if !ctx.cr[6].eq {
	pc = 0x822D5204; continue 'dispatch;
	}
	// 822D51F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D51F8: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D51FC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D5200: 419A00A4  beq cr6, 0x822d52a4
	if ctx.cr[6].eq {
	pc = 0x822D52A4; continue 'dispatch;
	}
	// 822D5204: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5208: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D520C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D5210: 409A0020  bne cr6, 0x822d5230
	if !ctx.cr[6].eq {
	pc = 0x822D5230; continue 'dispatch;
	}
	// 822D5214: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5218: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822D521C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D5220: 9BCA0030  stb r30, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D5224: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D5228: 4BFF4251  bl 0x822c9478
	ctx.lr = 0x822D522C;
	sub_822C9478(ctx, base);
	// 822D522C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5230: 895F0030  lbz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D5238: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D523C: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 822D5240: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D5244: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5248: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D524C: 4BFF41C5  bl 0x822c9410
	ctx.lr = 0x822D5250;
	sub_822C9410(ctx, base);
	// 822D5250: 480000C0  b 0x822d5310
	pc = 0x822D5310; continue 'dispatch;
	// 822D5254: 894B0030  lbz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5258: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D525C: 409A001C  bne cr6, 0x822d5278
	if !ctx.cr[6].eq {
	pc = 0x822D5278; continue 'dispatch;
	}
	// 822D5260: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D5264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D5268: 9BBF0030  stb r29, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D526C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D5270: 4BFF4209  bl 0x822c9478
	ctx.lr = 0x822D5274;
	sub_822C9478(ctx, base);
	// 822D5274: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5278: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D527C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D5280: 409A0028  bne cr6, 0x822d52a8
	if !ctx.cr[6].eq {
	pc = 0x822D52A8; continue 'dispatch;
	}
	// 822D5284: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5288: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D528C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D5290: 409A0034  bne cr6, 0x822d52c4
	if !ctx.cr[6].eq {
	pc = 0x822D52C4; continue 'dispatch;
	}
	// 822D5294: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5298: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D529C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D52A0: 409A0024  bne cr6, 0x822d52c4
	if !ctx.cr[6].eq {
	pc = 0x822D52C4; continue 'dispatch;
	}
	// 822D52A4: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D52A8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D52AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 822D52B0: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D52B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D52B8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D52BC: 409AFEDC  bne cr6, 0x822d5198
	if !ctx.cr[6].eq {
	pc = 0x822D5198; continue 'dispatch;
	}
	// 822D52C0: 48000050  b 0x822d5310
	pc = 0x822D5310; continue 'dispatch;
	// 822D52C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D52C8: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D52CC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D52D0: 409A0020  bne cr6, 0x822d52f0
	if !ctx.cr[6].eq {
	pc = 0x822D52F0; continue 'dispatch;
	}
	// 822D52D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D52D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822D52DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D52E0: 9BCA0030  stb r30, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D52E4: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D52E8: 4BFF4129  bl 0x822c9410
	ctx.lr = 0x822D52EC;
	sub_822C9410(ctx, base);
	// 822D52EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D52F0: 895F0030  lbz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D52F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D52F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D52FC: 994B0030  stb r10, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 822D5300: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D5304: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5308: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D530C: 4BFF416D  bl 0x822c9478
	ctx.lr = 0x822D5310;
	sub_822C9478(ctx, base);
	// 822D5310: 9BDC0030  stb r30, 0x30(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 822D5314: 807B002C  lwz r3, 0x2c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D5318: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 822D531C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D5320: 419A0008  beq cr6, 0x822d5328
	if ctx.cr[6].eq {
	pc = 0x822D5328; continue 'dispatch;
	}
	// 822D5324: 4BFEB56D  bl 0x822c0890
	ctx.lr = 0x822D5328;
	sub_822C0890(ctx, base);
	// 822D5328: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D532C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D5330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D5334: 4BFEF9AD  bl 0x822c4ce0
	ctx.lr = 0x822D5338;
	sub_822C4CE0(ctx, base);
	// 822D5338: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822D533C: 4BFEAF2D  bl 0x822c0268
	ctx.lr = 0x822D5340;
	sub_822C0268(ctx, base);
	// 822D5340: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5348: 419A000C  beq cr6, 0x822d5354
	if ctx.cr[6].eq {
	pc = 0x822D5354; continue 'dispatch;
	}
	// 822D534C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822D5350: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5354: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822D5358: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822D535C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822D5360: 48ED2E48  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5368 size=116
    let mut pc: u32 = 0x822D5368;
    'dispatch: loop {
        match pc {
            0x822D5368 => {
    //   block [0x822D5368..0x822D53DC)
	// 822D5368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D536C: 48ED2DFD  bl 0x831a8168
	ctx.lr = 0x822D5370;
	sub_831A8130(ctx, base);
	// 822D5370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5374: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D5378: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D537C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822D5380: 897E0031  lbz r11, 0x31(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D5384: 48000048  b 0x822d53cc
	pc = 0x822D53CC; continue 'dispatch;
	// 822D5388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822D538C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5390: 4BFFFFD9  bl 0x822d5368
	ctx.lr = 0x822D5394;
	sub_822D5368(ctx, base);
	// 822D5394: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D5398: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 822D539C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D53A0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D53A4: 419A0008  beq cr6, 0x822d53ac
	if ctx.cr[6].eq {
	pc = 0x822D53AC; continue 'dispatch;
	}
	// 822D53A8: 4BFEB4E9  bl 0x822c0890
	ctx.lr = 0x822D53AC;
	sub_822C0890(ctx, base);
	// 822D53AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D53B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D53B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D53B8: 4BFEF929  bl 0x822c4ce0
	ctx.lr = 0x822D53BC;
	sub_822C4CE0(ctx, base);
	// 822D53BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D53C0: 4BFEAEA9  bl 0x822c0268
	ctx.lr = 0x822D53C4;
	sub_822C0268(ctx, base);
	// 822D53C4: 897F0031  lbz r11, 0x31(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D53C8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822D53CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D53D0: 419AFFB8  beq cr6, 0x822d5388
	if ctx.cr[6].eq {
	pc = 0x822D5388; continue 'dispatch;
	}
	// 822D53D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D53D8: 48ED2DE0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D53E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D53E0 size=120
    let mut pc: u32 = 0x822D53E0;
    'dispatch: loop {
        match pc {
            0x822D53E0 => {
    //   block [0x822D53E0..0x822D5458)
	// 822D53E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D53E4: 48ED2D89  bl 0x831a816c
	ctx.lr = 0x822D53E8;
	sub_831A8130(ctx, base);
	// 822D53E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D53EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D53F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D53F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D53F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D53FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D5400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5404: 4BFEF8DD  bl 0x822c4ce0
	ctx.lr = 0x822D5408;
	sub_822C4CE0(ctx, base);
	// 822D5408: 4800002C  b 0x822d5434
	pc = 0x822D5434; continue 'dispatch;
	// 822D540C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822D5410: 419A0010  beq cr6, 0x822d5420
	if ctx.cr[6].eq {
	pc = 0x822D5420; continue 'dispatch;
	}
	// 822D5414: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D5418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D541C: 4BFF0355  bl 0x822c5770
	ctx.lr = 0x822D5420;
	sub_822C5770(ctx, base);
	// 822D5420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D5424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5428: 4BFFF949  bl 0x822d4d70
	ctx.lr = 0x822D542C;
	sub_822D4D70(ctx, base);
	// 822D542C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 822D5430: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 822D5434: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D5438: 409AFFD4  bne cr6, 0x822d540c
	if !ctx.cr[6].eq {
	pc = 0x822D540C; continue 'dispatch;
	}
	// 822D543C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D5440: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D5444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5448: 4BFEF899  bl 0x822c4ce0
	ctx.lr = 0x822D544C;
	sub_822C4CE0(ctx, base);
	// 822D544C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5450: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822D5454: 48ED2D68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5458 size=548
    let mut pc: u32 = 0x822D5458;
    'dispatch: loop {
        match pc {
            0x822D5458 => {
    //   block [0x822D5458..0x822D567C)
	// 822D5458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D545C: 48ED2D05  bl 0x831a8160
	ctx.lr = 0x822D5460;
	sub_831A8130(ctx, base);
	// 822D5460: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5464: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D5468: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 822D546C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822D5470: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 822D5474: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D5478: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D547C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822D5480: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822D5484: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5488: 41980048  blt cr6, 0x822d54d0
	if ctx.cr[6].lt {
	pc = 0x822D54D0; continue 'dispatch;
	}
	// 822D548C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D5490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5494: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 822D5498: 4BFF0431  bl 0x822c58c8
	ctx.lr = 0x822D549C;
	sub_822C58C8(ctx, base);
	// 822D549C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D54A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D54A4: 4BFF0375  bl 0x822c5818
	ctx.lr = 0x822D54A8;
	sub_822C5818(ctx, base);
	// 822D54A8: 4BFEEE09  bl 0x822c42b0
	ctx.lr = 0x822D54AC;
	sub_822C42B0(ctx, base);
	// 822D54AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D54B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D54B4: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 822D54B8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822D54BC: 4BFEFFB5  bl 0x822c5470
	ctx.lr = 0x822D54C0;
	sub_822C5470(ctx, base);
	// 822D54C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D54C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D54C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D54CC: 4BFEF815  bl 0x822c4ce0
	ctx.lr = 0x822D54D0;
	sub_822C4CE0(ctx, base);
	// 822D54D0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D54D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822D54D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822D54DC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822D54E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D54E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D54E8: 4BFFF991  bl 0x822d4e78
	ctx.lr = 0x822D54EC;
	sub_822D4E78(ctx, base);
	// 822D54EC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D54F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D54F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D54F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D54FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5500: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D5504: 409A0018  bne cr6, 0x822d551c
	if !ctx.cr[6].eq {
	pc = 0x822D551C; continue 'dispatch;
	}
	// 822D5508: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822D550C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5510: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5514: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5518: 4800003C  b 0x822d5554
	pc = 0x822D5554; continue 'dispatch;
	// 822D551C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5520: 41820020  beq 0x822d5540
	if ctx.cr[0].eq {
	pc = 0x822D5540; continue 'dispatch;
	}
	// 822D5524: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5528: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D552C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5530: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D5534: 409A0024  bne cr6, 0x822d5558
	if !ctx.cr[6].eq {
	pc = 0x822D5558; continue 'dispatch;
	}
	// 822D5538: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D553C: 4800001C  b 0x822d5558
	pc = 0x822D5558; continue 'dispatch;
	// 822D5540: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D5544: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5548: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D554C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D5550: 409A0008  bne cr6, 0x822d5558
	if !ctx.cr[6].eq {
	pc = 0x822D5558; continue 'dispatch;
	}
	// 822D5554: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D5558: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D555C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 822D5560: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822D5564: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822D5568: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D556C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D5570: 409A00F0  bne cr6, 0x822d5660
	if !ctx.cr[6].eq {
	pc = 0x822D5660; continue 'dispatch;
	}
	// 822D5574: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822D5578: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D557C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5580: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5584: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822D5588: 409A0054  bne cr6, 0x822d55dc
	if !ctx.cr[6].eq {
	pc = 0x822D55DC; continue 'dispatch;
	}
	// 822D558C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5590: 892A002C  lbz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D5594: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D5598: 419A0054  beq cr6, 0x822d55ec
	if ctx.cr[6].eq {
	pc = 0x822D55EC; continue 'dispatch;
	}
	// 822D559C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D55A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D55A4: 409A0010  bne cr6, 0x822d55b4
	if !ctx.cr[6].eq {
	pc = 0x822D55B4; continue 'dispatch;
	}
	// 822D55A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D55AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D55B0: 4BFF9E41  bl 0x822cf3f0
	ctx.lr = 0x822D55B4;
	sub_822CF3F0(ctx, base);
	// 822D55B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D55B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D55BC: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 822D55C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D55C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D55C8: 9B6B002C  stb r27, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 822D55CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D55D0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D55D4: 4BFF9D65  bl 0x822cf338
	ctx.lr = 0x822D55D8;
	sub_822CF338(ctx, base);
	// 822D55D8: 48000074  b 0x822d564c
	pc = 0x822D564C; continue 'dispatch;
	// 822D55DC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D55E0: 892A002C  lbz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D55E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D55E8: 409A0028  bne cr6, 0x822d5610
	if !ctx.cr[6].eq {
	pc = 0x822D5610; continue 'dispatch;
	}
	// 822D55EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D55F0: 9BA9002C  stb r29, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 822D55F4: 9BAA002C  stb r29, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 822D55F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D55FC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5600: 9B6A002C  stb r27, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 822D5604: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5608: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D560C: 48000040  b 0x822d564c
	pc = 0x822D564C; continue 'dispatch;
	// 822D5610: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5614: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5618: 409A0010  bne cr6, 0x822d5628
	if !ctx.cr[6].eq {
	pc = 0x822D5628; continue 'dispatch;
	}
	// 822D561C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5620: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D5624: 4BFF9D15  bl 0x822cf338
	ctx.lr = 0x822D5628;
	sub_822CF338(ctx, base);
	// 822D5628: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D562C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5630: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 822D5634: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5638: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D563C: 9B6B002C  stb r27, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[27].u8 ) };
	// 822D5640: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5644: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5648: 4BFF9DA9  bl 0x822cf3f0
	ctx.lr = 0x822D564C;
	sub_822CF3F0(ctx, base);
	// 822D564C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5650: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822D5654: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822D5658: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D565C: 419AFF1C  beq cr6, 0x822d5578
	if ctx.cr[6].eq {
	pc = 0x822D5578; continue 'dispatch;
	}
	// 822D5660: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5664: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D5668: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D566C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5670: 9BAB002C  stb r29, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u8 ) };
	// 822D5674: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822D5678: 48ED2B38  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5680 size=548
    let mut pc: u32 = 0x822D5680;
    'dispatch: loop {
        match pc {
            0x822D5680 => {
    //   block [0x822D5680..0x822D58A4)
	// 822D5680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5684: 48ED2ADD  bl 0x831a8160
	ctx.lr = 0x822D5688;
	sub_831A8130(ctx, base);
	// 822D5688: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D568C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D5690: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 822D5694: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822D5698: 616B71C6  ori r11, r11, 0x71c6
	ctx.r[11].u64 = ctx.r[11].u64 | 29126;
	// 822D569C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D56A0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D56A4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822D56A8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822D56AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D56B0: 41980048  blt cr6, 0x822d56f8
	if ctx.cr[6].lt {
	pc = 0x822D56F8; continue 'dispatch;
	}
	// 822D56B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D56B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D56BC: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 822D56C0: 4BFF0209  bl 0x822c58c8
	ctx.lr = 0x822D56C4;
	sub_822C58C8(ctx, base);
	// 822D56C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D56C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D56CC: 4BFF014D  bl 0x822c5818
	ctx.lr = 0x822D56D0;
	sub_822C5818(ctx, base);
	// 822D56D0: 4BFEEBE1  bl 0x822c42b0
	ctx.lr = 0x822D56D4;
	sub_822C42B0(ctx, base);
	// 822D56D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D56D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D56DC: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 822D56E0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822D56E4: 4BFEFD8D  bl 0x822c5470
	ctx.lr = 0x822D56E8;
	sub_822C5470(ctx, base);
	// 822D56E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D56EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D56F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D56F4: 4BFEF5ED  bl 0x822c4ce0
	ctx.lr = 0x822D56F8;
	sub_822C4CE0(ctx, base);
	// 822D56F8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D56FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822D5700: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822D5704: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822D5708: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D570C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5710: 4BFFF7D9  bl 0x822d4ee8
	ctx.lr = 0x822D5714;
	sub_822D4EE8(ctx, base);
	// 822D5714: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5718: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D571C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D5720: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D5724: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5728: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D572C: 409A0018  bne cr6, 0x822d5744
	if !ctx.cr[6].eq {
	pc = 0x822D5744; continue 'dispatch;
	}
	// 822D5730: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822D5734: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5738: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D573C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5740: 4800003C  b 0x822d577c
	pc = 0x822D577C; continue 'dispatch;
	// 822D5744: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5748: 41820020  beq 0x822d5768
	if ctx.cr[0].eq {
	pc = 0x822D5768; continue 'dispatch;
	}
	// 822D574C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5750: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5754: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5758: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D575C: 409A0024  bne cr6, 0x822d5780
	if !ctx.cr[6].eq {
	pc = 0x822D5780; continue 'dispatch;
	}
	// 822D5760: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5764: 4800001C  b 0x822d5780
	pc = 0x822D5780; continue 'dispatch;
	// 822D5768: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D576C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5770: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5774: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D5778: 409A0008  bne cr6, 0x822d5780
	if !ctx.cr[6].eq {
	pc = 0x822D5780; continue 'dispatch;
	}
	// 822D577C: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822D5780: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5784: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 822D5788: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822D578C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822D5790: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5794: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D5798: 409A00F0  bne cr6, 0x822d5888
	if !ctx.cr[6].eq {
	pc = 0x822D5888; continue 'dispatch;
	}
	// 822D579C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822D57A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D57A4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57A8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D57AC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822D57B0: 409A0054  bne cr6, 0x822d5804
	if !ctx.cr[6].eq {
	pc = 0x822D5804; continue 'dispatch;
	}
	// 822D57B4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D57B8: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D57BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D57C0: 419A0054  beq cr6, 0x822d5814
	if ctx.cr[6].eq {
	pc = 0x822D5814; continue 'dispatch;
	}
	// 822D57C4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D57C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D57CC: 409A0010  bne cr6, 0x822d57dc
	if !ctx.cr[6].eq {
	pc = 0x822D57DC; continue 'dispatch;
	}
	// 822D57D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D57D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D57D8: 4BFF3C39  bl 0x822c9410
	ctx.lr = 0x822D57DC;
	sub_822C9410(ctx, base);
	// 822D57DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D57E4: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D57E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57F0: 9B6B0030  stb r27, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 822D57F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57F8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D57FC: 4BFF3C7D  bl 0x822c9478
	ctx.lr = 0x822D5800;
	sub_822C9478(ctx, base);
	// 822D5800: 48000074  b 0x822d5874
	pc = 0x822D5874; continue 'dispatch;
	// 822D5804: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5808: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D580C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822D5810: 409A0028  bne cr6, 0x822d5838
	if !ctx.cr[6].eq {
	pc = 0x822D5838; continue 'dispatch;
	}
	// 822D5814: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5818: 9BA90030  stb r29, 0x30(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D581C: 9BAA0030  stb r29, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D5820: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5824: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5828: 9B6A0030  stb r27, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 822D582C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5830: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5834: 48000040  b 0x822d5874
	pc = 0x822D5874; continue 'dispatch;
	// 822D5838: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D583C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5840: 409A0010  bne cr6, 0x822d5850
	if !ctx.cr[6].eq {
	pc = 0x822D5850; continue 'dispatch;
	}
	// 822D5844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5848: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D584C: 4BFF3C2D  bl 0x822c9478
	ctx.lr = 0x822D5850;
	sub_822C9478(ctx, base);
	// 822D5850: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5858: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D585C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5864: 9B6B0030  stb r27, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 822D5868: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D586C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5870: 4BFF3BA1  bl 0x822c9410
	ctx.lr = 0x822D5874;
	sub_822C9410(ctx, base);
	// 822D5874: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5878: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822D587C: 894A0030  lbz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D5880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D5884: 419AFF1C  beq cr6, 0x822d57a0
	if ctx.cr[6].eq {
	pc = 0x822D57A0; continue 'dispatch;
	}
	// 822D5888: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D588C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D5890: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822D5894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5898: 9BAB0030  stb r29, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[29].u8 ) };
	// 822D589C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822D58A0: 48ED2910  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D58A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D58A8 size=776
    let mut pc: u32 = 0x822D58A8;
    'dispatch: loop {
        match pc {
            0x822D58A8 => {
    //   block [0x822D58A8..0x822D5BB0)
	// 822D58A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D58AC: 48ED28AD  bl 0x831a8158
	ctx.lr = 0x822D58B0;
	sub_831A8130(ctx, base);
	// 822D58B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D58B4: 83060004  lwz r24, 4(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D58B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D58BC: 83460000  lwz r26, 0(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D58C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D58C4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D58C8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822D58CC: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 822D58D0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 822D58D4: 419A0024  beq cr6, 0x822d58f8
	if ctx.cr[6].eq {
	pc = 0x822D58F8; continue 'dispatch;
	}
	// 822D58D8: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 822D58DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D58E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D58E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D58E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D58EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D58F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D58F4: 4082FFE8  bne 0x822d58dc
	if !ctx.cr[0].eq {
	pc = 0x822D58DC; continue 'dispatch;
	}
	// 822D58F8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D58FC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822D5900: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D5904: 409A000C  bne cr6, 0x822d5910
	if !ctx.cr[6].eq {
	pc = 0x822D5910; continue 'dispatch;
	}
	// 822D5908: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 822D590C: 48000010  b 0x822d591c
	pc = 0x822D591C; continue 'dispatch;
	// 822D5910: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D5914: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822D5918: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D591C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822D5920: 419A0278  beq cr6, 0x822d5b98
	if ctx.cr[6].eq {
	pc = 0x822D5B98; continue 'dispatch;
	}
	// 822D5924: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D5928: 409A000C  bne cr6, 0x822d5934
	if !ctx.cr[6].eq {
	pc = 0x822D5934; continue 'dispatch;
	}
	// 822D592C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D5930: 48000010  b 0x822d5940
	pc = 0x822D5940; continue 'dispatch;
	// 822D5934: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5938: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822D593C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5940: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 822D5944: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 822D5948: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D594C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5950: 4098000C  bge cr6, 0x822d595c
	if !ctx.cr[6].lt {
	pc = 0x822D595C; continue 'dispatch;
	}
	// 822D5954: 488E23CD  bl 0x82bb7d20
	ctx.lr = 0x822D5958;
	sub_82BB7D20(ctx, base);
	// 822D5958: 48000240  b 0x822d5b98
	pc = 0x822D5B98; continue 'dispatch;
	// 822D595C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D5960: 409A000C  bne cr6, 0x822d596c
	if !ctx.cr[6].eq {
	pc = 0x822D596C; continue 'dispatch;
	}
	// 822D5964: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D5968: 48000010  b 0x822d5978
	pc = 0x822D5978; continue 'dispatch;
	// 822D596C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5970: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822D5974: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5978: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D597C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5980: 40980138  bge cr6, 0x822d5ab8
	if !ctx.cr[6].lt {
	pc = 0x822D5AB8; continue 'dispatch;
	}
	// 822D5984: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D5988: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 822D598C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D5990: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822D5994: 41980008  blt cr6, 0x822d599c
	if ctx.cr[6].lt {
	pc = 0x822D599C; continue 'dispatch;
	}
	// 822D5998: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 822D599C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D59A0: 409A000C  bne cr6, 0x822d59ac
	if !ctx.cr[6].eq {
	pc = 0x822D59AC; continue 'dispatch;
	}
	// 822D59A4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D59A8: 48000010  b 0x822d59b8
	pc = 0x822D59B8; continue 'dispatch;
	// 822D59AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D59B0: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822D59B4: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D59B8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D59BC: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D59C0: 40980024  bge cr6, 0x822d59e4
	if !ctx.cr[6].lt {
	pc = 0x822D59E4; continue 'dispatch;
	}
	// 822D59C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822D59C8: 409A000C  bne cr6, 0x822d59d4
	if !ctx.cr[6].eq {
	pc = 0x822D59D4; continue 'dispatch;
	}
	// 822D59CC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D59D0: 48000010  b 0x822d59e0
	pc = 0x822D59E0; continue 'dispatch;
	// 822D59D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D59D8: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 822D59DC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D59E0: 7F4BDA14  add r26, r11, r27
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D59E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D59E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D59EC: 48325145  bl 0x825fab30
	ctx.lr = 0x822D59F0;
	sub_825FAB30(ctx, base);
	// 822D59F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D59F4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D59F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D59FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5A00: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D5A04: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822D5A08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D5A0C: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D5A10: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822D5A14: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5A18: 487AE901  bl 0x82a84318
	ctx.lr = 0x822D5A1C;
	sub_82A84318(ctx, base);
	// 822D5A1C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D5A20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822D5A24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D5A28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D5A2C: 482B6885  bl 0x8258c2b0
	ctx.lr = 0x822D5A30;
	sub_8258C2B0(ctx, base);
	// 822D5A30: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822D5A34: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5A38: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D5A3C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D5A40: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5A44: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822D5A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5A4C: 9B2A0000  stb r25, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D5A50: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5A54: 487AE8C5  bl 0x82a84318
	ctx.lr = 0x822D5A58;
	sub_82A84318(ctx, base);
	// 822D5A58: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D5A60: 409A000C  bne cr6, 0x822d5a6c
	if !ctx.cr[6].eq {
	pc = 0x822D5A6C; continue 'dispatch;
	}
	// 822D5A64: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D5A68: 48000010  b 0x822d5a78
	pc = 0x822D5A78; continue 'dispatch;
	// 822D5A6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5A70: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 822D5A74: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5A78: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D5A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D5A80: 419A0018  beq cr6, 0x822d5a98
	if ctx.cr[6].eq {
	pc = 0x822D5A98; continue 'dispatch;
	}
	// 822D5A84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D5A88: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5A8C: 484FC8BD  bl 0x827d2348
	ctx.lr = 0x822D5A90;
	sub_827D2348(ctx, base);
	// 822D5A90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5A94: 4BFEA7D5  bl 0x822c0268
	ctx.lr = 0x822D5A98;
	sub_822C0268(ctx, base);
	// 822D5A98: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D5A9C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822D5AA0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822D5AA4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822D5AA8: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 822D5AAC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822D5AB0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D5AB4: 480000E4  b 0x822d5b98
	pc = 0x822D5B98; continue 'dispatch;
	// 822D5AB8: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5ABC: 577C1838  slwi r28, r27, 3
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 822D5AC0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5AC4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D5AC8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 822D5ACC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D5AD0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5AD4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D5AD8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D5ADC: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D5AE0: 40980064  bge cr6, 0x822d5b44
	if !ctx.cr[6].lt {
	pc = 0x822D5B44; continue 'dispatch;
	}
	// 822D5AE4: 7CBCF214  add r5, r28, r30
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822D5AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5AEC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5AF0: 487AE829  bl 0x82a84318
	ctx.lr = 0x822D5AF4;
	sub_82A84318(ctx, base);
	// 822D5AF4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5AF8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D5AFC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822D5B00: 7D7E1850  subf r11, r30, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 822D5B04: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5B08: 7C8BD850  subf r4, r11, r27
	ctx.r[4].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 822D5B0C: 482B67A5  bl 0x8258c2b0
	ctx.lr = 0x822D5B10;
	sub_8258C2B0(ctx, base);
	// 822D5B10: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5B14: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 822D5B18: 7FBC5850  subf r29, r28, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 822D5B1C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5B20: 48000018  b 0x822d5b38
	pc = 0x822D5B38; continue 'dispatch;
	// 822D5B24: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822D5B28: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 822D5B2C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822D5B30: 4BFEE931  bl 0x822c4460
	ctx.lr = 0x822D5B34;
	sub_822C4460(ctx, base);
	// 822D5B34: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822D5B38: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D5B3C: 409AFFE8  bne cr6, 0x822d5b24
	if !ctx.cr[6].eq {
	pc = 0x822D5B24; continue 'dispatch;
	}
	// 822D5B40: 48000058  b 0x822d5b98
	pc = 0x822D5B98; continue 'dispatch;
	// 822D5B44: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 822D5B48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D5B4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822D5B50: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5B54: 487AE7C5  bl 0x82a84318
	ctx.lr = 0x822D5B58;
	sub_82A84318(ctx, base);
	// 822D5B58: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 822D5B5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D5B60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D5B64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5B68: 482FEE01  bl 0x825d4968
	ctx.lr = 0x822D5B6C;
	sub_825D4968(ctx, base);
	// 822D5B6C: 7FBCF214  add r29, r28, r30
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822D5B70: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822D5B74: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D5B78: 419A0020  beq cr6, 0x822d5b98
	if ctx.cr[6].eq {
	pc = 0x822D5B98; continue 'dispatch;
	}
	// 822D5B7C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822D5B80: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 822D5B84: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D5B88: 4BFEE8D9  bl 0x822c4460
	ctx.lr = 0x822D5B8C;
	sub_822C4460(ctx, base);
	// 822D5B8C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 822D5B90: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D5B94: 409AFFE8  bne cr6, 0x822d5b7c
	if !ctx.cr[6].eq {
	pc = 0x822D5B7C; continue 'dispatch;
	}
	// 822D5B98: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 822D5B9C: 419A000C  beq cr6, 0x822d5ba8
	if ctx.cr[6].eq {
	pc = 0x822D5BA8; continue 'dispatch;
	}
	// 822D5BA0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822D5BA4: 4BFEACED  bl 0x822c0890
	ctx.lr = 0x822D5BA8;
	sub_822C0890(ctx, base);
	// 822D5BA8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822D5BAC: 48ED25FC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5BB0 size=84
    let mut pc: u32 = 0x822D5BB0;
    'dispatch: loop {
        match pc {
            0x822D5BB0 => {
    //   block [0x822D5BB0..0x822D5C04)
	// 822D5BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D5BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D5BBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D5BC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5BC8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5BCC: 4BFFF79D  bl 0x822d5368
	ctx.lr = 0x822D5BD0;
	sub_822D5368(ctx, base);
	// 822D5BD0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5BD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D5BD8: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D5BDC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5BE0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5BE4: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D5BE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5BEC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5BF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D5BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D5BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D5BFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D5C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5C08 size=236
    let mut pc: u32 = 0x822D5C08;
    'dispatch: loop {
        match pc {
            0x822D5C08 => {
    //   block [0x822D5C08..0x822D5CF4)
	// 822D5C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5C0C: 48ED2551  bl 0x831a815c
	ctx.lr = 0x822D5C10;
	sub_831A8130(ctx, base);
	// 822D5C10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5C14: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822D5C18: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822D5C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D5C20: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D5C24: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822D5C28: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5C2C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5C30: 4800002C  b 0x822d5c5c
	pc = 0x822D5C5C; continue 'dispatch;
	// 822D5C34: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 822D5C38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822D5C3C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822D5C40: 4BFFE2A9  bl 0x822d3ee8
	ctx.lr = 0x822D5C44;
	sub_822D3EE8(ctx, base);
	// 822D5C44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D5C48: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5C4C: 4182000C  beq 0x822d5c58
	if ctx.cr[0].eq {
	pc = 0x822D5C58; continue 'dispatch;
	}
	// 822D5C50: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5C54: 48000008  b 0x822d5c5c
	pc = 0x822D5C5C; continue 'dispatch;
	// 822D5C58: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5C5C: 897D002D  lbz r11, 0x2d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(45 as u32) ) } as u64;
	// 822D5C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5C64: 419AFFD0  beq cr6, 0x822d5c34
	if ctx.cr[6].eq {
	pc = 0x822D5C34; continue 'dispatch;
	}
	// 822D5C68: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822D5C6C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5C70: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822D5C74: 41820048  beq 0x822d5cbc
	if ctx.cr[0].eq {
	pc = 0x822D5CBC; continue 'dispatch;
	}
	// 822D5C78: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5C80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5C84: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5C88: 409A002C  bne cr6, 0x822d5cb4
	if !ctx.cr[6].eq {
	pc = 0x822D5CB4; continue 'dispatch;
	}
	// 822D5C8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822D5C90: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822D5C94: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822D5C98: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822D5C9C: 4BFFF7BD  bl 0x822d5458
	ctx.lr = 0x822D5CA0;
	sub_822D5458(ctx, base);
	// 822D5CA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D5CA4: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 822D5CA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5CAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D5CB0: 48000038  b 0x822d5ce8
	pc = 0x822D5CE8; continue 'dispatch;
	// 822D5CB4: 482793FD  bl 0x8254f0b0
	ctx.lr = 0x822D5CB8;
	sub_8254F0B0(ctx, base);
	// 822D5CB8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5CBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D5CC0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 822D5CC4: 4BFFE225  bl 0x822d3ee8
	ctx.lr = 0x822D5CC8;
	sub_822D3EE8(ctx, base);
	// 822D5CC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5CCC: 41820010  beq 0x822d5cdc
	if ctx.cr[0].eq {
	pc = 0x822D5CDC; continue 'dispatch;
	}
	// 822D5CD0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822D5CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5CD8: 4BFFFFB8  b 0x822d5c90
	pc = 0x822D5C90; continue 'dispatch;
	// 822D5CDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D5CE0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822D5CE4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 822D5CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D5CEC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822D5CF0: 48ED24BC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5CF8 size=236
    let mut pc: u32 = 0x822D5CF8;
    'dispatch: loop {
        match pc {
            0x822D5CF8 => {
    //   block [0x822D5CF8..0x822D5DE4)
	// 822D5CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5CFC: 48ED2461  bl 0x831a815c
	ctx.lr = 0x822D5D00;
	sub_831A8130(ctx, base);
	// 822D5D00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5D04: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822D5D08: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822D5D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D5D10: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D5D14: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822D5D18: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5D1C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5D20: 4800002C  b 0x822d5d4c
	pc = 0x822D5D4C; continue 'dispatch;
	// 822D5D24: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 822D5D28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822D5D2C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822D5D30: 4BFFE1B9  bl 0x822d3ee8
	ctx.lr = 0x822D5D34;
	sub_822D3EE8(ctx, base);
	// 822D5D34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D5D38: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5D3C: 4182000C  beq 0x822d5d48
	if ctx.cr[0].eq {
	pc = 0x822D5D48; continue 'dispatch;
	}
	// 822D5D40: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5D44: 48000008  b 0x822d5d4c
	pc = 0x822D5D4C; continue 'dispatch;
	// 822D5D48: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5D4C: 897D0031  lbz r11, 0x31(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(49 as u32) ) } as u64;
	// 822D5D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5D54: 419AFFD0  beq cr6, 0x822d5d24
	if ctx.cr[6].eq {
	pc = 0x822D5D24; continue 'dispatch;
	}
	// 822D5D58: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822D5D5C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5D60: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822D5D64: 41820048  beq 0x822d5dac
	if ctx.cr[0].eq {
	pc = 0x822D5DAC; continue 'dispatch;
	}
	// 822D5D68: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5D70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5D74: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5D78: 409A002C  bne cr6, 0x822d5da4
	if !ctx.cr[6].eq {
	pc = 0x822D5DA4; continue 'dispatch;
	}
	// 822D5D7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822D5D80: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822D5D84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822D5D88: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822D5D8C: 4BFFF8F5  bl 0x822d5680
	ctx.lr = 0x822D5D90;
	sub_822D5680(ctx, base);
	// 822D5D90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D5D94: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 822D5D98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5D9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D5DA0: 48000038  b 0x822d5dd8
	pc = 0x822D5DD8; continue 'dispatch;
	// 822D5DA4: 4BFFE53D  bl 0x822d42e0
	ctx.lr = 0x822D5DA8;
	sub_822D42E0(ctx, base);
	// 822D5DA8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D5DAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D5DB0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 822D5DB4: 4BFFE135  bl 0x822d3ee8
	ctx.lr = 0x822D5DB8;
	sub_822D3EE8(ctx, base);
	// 822D5DB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D5DBC: 41820010  beq 0x822d5dcc
	if ctx.cr[0].eq {
	pc = 0x822D5DCC; continue 'dispatch;
	}
	// 822D5DC0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822D5DC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5DC8: 4BFFFFB8  b 0x822d5d80
	pc = 0x822D5D80; continue 'dispatch;
	// 822D5DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D5DD0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822D5DD4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 822D5DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D5DDC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822D5DE0: 48ED23CC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5DE8 size=108
    let mut pc: u32 = 0x822D5DE8;
    'dispatch: loop {
        match pc {
            0x822D5DE8 => {
    //   block [0x822D5DE8..0x822D5E54)
	// 822D5DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5DEC: 48ED2381  bl 0x831a816c
	ctx.lr = 0x822D5DF0;
	sub_831A8130(ctx, base);
	// 822D5DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5DF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D5DF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D5DFC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822D5E00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5E08: 419A0014  beq cr6, 0x822d5e1c
	if ctx.cr[6].eq {
	pc = 0x822D5E1C; continue 'dispatch;
	}
	// 822D5E0C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5E10: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D5E14: 7D4A1E71  srawi. r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822D5E18: 4082000C  bne 0x822d5e24
	if !ctx.cr[0].eq {
	pc = 0x822D5E24; continue 'dispatch;
	}
	// 822D5E1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822D5E20: 4800000C  b 0x822d5e2c
	pc = 0x822D5E2C; continue 'dispatch;
	// 822D5E24: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 822D5E28: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5E2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822D5E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D5E34: 4BFFFA75  bl 0x822d58a8
	ctx.lr = 0x822D5E38;
	sub_822D58A8(ctx, base);
	// 822D5E38: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5E3C: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822D5E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5E44: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822D5E48: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D5E4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D5E50: 48ED236C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5E58 size=88
    let mut pc: u32 = 0x822D5E58;
    'dispatch: loop {
        match pc {
            0x822D5E58 => {
    //   block [0x822D5E58..0x822D5EB0)
	// 822D5E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5E5C: 48ED2309  bl 0x831a8164
	ctx.lr = 0x822D5E60;
	sub_831A8130(ctx, base);
	// 822D5E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5E64: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D5E68: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822D5E6C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822D5E70: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822D5E74: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 822D5E78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D5E7C: 419A0024  beq cr6, 0x822d5ea0
	if ctx.cr[6].eq {
	pc = 0x822D5EA0; continue 'dispatch;
	}
	// 822D5E80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822D5E84: 419A0010  beq cr6, 0x822d5e94
	if ctx.cr[6].eq {
	pc = 0x822D5E94; continue 'dispatch;
	}
	// 822D5E88: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D5E8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D5E90: 4BFEF8E1  bl 0x822c5770
	ctx.lr = 0x822D5E94;
	sub_822C5770(ctx, base);
	// 822D5E94: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822D5E98: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 822D5E9C: 4082FFE4  bne 0x822d5e80
	if !ctx.cr[0].eq {
	pc = 0x822D5E80; continue 'dispatch;
	}
	// 822D5EA0: 1D7F001C  mulli r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 * 28;
	// 822D5EA4: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822D5EA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D5EAC: 48ED2308  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5EB0 size=132
    let mut pc: u32 = 0x822D5EB0;
    'dispatch: loop {
        match pc {
            0x822D5EB0 => {
    //   block [0x822D5EB0..0x822D5F34)
	// 822D5EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5EB4: 48ED22B5  bl 0x831a8168
	ctx.lr = 0x822D5EB8;
	sub_831A8130(ctx, base);
	// 822D5EB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5EBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D5EC0: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 822D5EC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D5EC8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822D5ECC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5ED0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5ED4: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D5ED8: 409A0044  bne cr6, 0x822d5f1c
	if !ctx.cr[6].eq {
	pc = 0x822D5F1C; continue 'dispatch;
	}
	// 822D5EDC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5EE0: 409A003C  bne cr6, 0x822d5f1c
	if !ctx.cr[6].eq {
	pc = 0x822D5F1C; continue 'dispatch;
	}
	// 822D5EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D5EE8: 4BFFFCC9  bl 0x822d5bb0
	ctx.lr = 0x822D5EEC;
	sub_822D5BB0(ctx, base);
	// 822D5EEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5EF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5EF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D5EF8: 48000030  b 0x822d5f28
	pc = 0x822D5F28; continue 'dispatch;
	// 822D5EFC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 822D5F00: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822D5F04: 4821327D  bl 0x824e9180
	ctx.lr = 0x822D5F08;
	sub_824E9180(ctx, base);
	// 822D5F08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822D5F0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D5F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5F14: 4BFFF03D  bl 0x822d4f50
	ctx.lr = 0x822D5F18;
	sub_822D4F50(ctx, base);
	// 822D5F18: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822D5F1C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822D5F20: 409AFFDC  bne cr6, 0x822d5efc
	if !ctx.cr[6].eq {
	pc = 0x822D5EFC; continue 'dispatch;
	}
	// 822D5F24: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822D5F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D5F2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D5F30: 48ED2288  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5F38 size=188
    let mut pc: u32 = 0x822D5F38;
    'dispatch: loop {
        match pc {
            0x822D5F38 => {
    //   block [0x822D5F38..0x822D5FF4)
	// 822D5F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D5F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D5F44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5F48: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822D5F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5F50: 409A000C  bne cr6, 0x822d5f5c
	if !ctx.cr[6].eq {
	pc = 0x822D5F5C; continue 'dispatch;
	}
	// 822D5F54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822D5F58: 48000010  b 0x822d5f68
	pc = 0x822D5F68; continue 'dispatch;
	// 822D5F5C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5F60: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D5F64: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 822D5F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5F6C: 419A0068  beq cr6, 0x822d5fd4
	if ctx.cr[6].eq {
	pc = 0x822D5FD4; continue 'dispatch;
	}
	// 822D5F70: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D5F74: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822D5F78: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822D5F7C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D5F80: 40980054  bge cr6, 0x822d5fd4
	if !ctx.cr[6].lt {
	pc = 0x822D5FD4; continue 'dispatch;
	}
	// 822D5F84: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D5F8C: 419A003C  beq cr6, 0x822d5fc8
	if ctx.cr[6].eq {
	pc = 0x822D5FC8; continue 'dispatch;
	}
	// 822D5F90: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D5F94: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D5F98: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D5F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D5FA0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D5FA4: 419A0024  beq cr6, 0x822d5fc8
	if ctx.cr[6].eq {
	pc = 0x822D5FC8; continue 'dispatch;
	}
	// 822D5FA8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822D5FAC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 822D5FB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D5FB4: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 822D5FB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822D5FBC: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D5FC0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D5FC4: 4082FFE8  bne 0x822d5fac
	if !ctx.cr[0].eq {
	pc = 0x822D5FAC; continue 'dispatch;
	}
	// 822D5FC8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822D5FCC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D5FD0: 48000014  b 0x822d5fe4
	pc = 0x822D5FE4; continue 'dispatch;
	// 822D5FD4: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D5FD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D5FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D5FE0: 4BFFFE09  bl 0x822d5de8
	ctx.lr = 0x822D5FE4;
	sub_822D5DE8(ctx, base);
	// 822D5FE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D5FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D5FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D5FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D5FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D5FF8 size=80
    let mut pc: u32 = 0x822D5FF8;
    'dispatch: loop {
        match pc {
            0x822D5FF8 => {
    //   block [0x822D5FF8..0x822D6048)
	// 822D5FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D5FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D6000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D6004: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D6008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D600C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D6010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D6014: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6018: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D601C: 4BFFFE95  bl 0x822d5eb0
	ctx.lr = 0x822D6020;
	sub_822D5EB0(ctx, base);
	// 822D6020: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6024: 4BFEA245  bl 0x822c0268
	ctx.lr = 0x822D6028;
	sub_822C0268(ctx, base);
	// 822D6028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D602C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D6030: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D6034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D6038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D603C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D6040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D6044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D6048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D6048 size=768
    let mut pc: u32 = 0x822D6048;
    'dispatch: loop {
        match pc {
            0x822D6048 => {
    //   block [0x822D6048..0x822D6348)
	// 822D6048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D604C: 48ED2111  bl 0x831a815c
	ctx.lr = 0x822D6050;
	sub_831A8130(ctx, base);
	// 822D6050: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D6054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D6058: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D605C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822D6060: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D6064: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D6068: 4BFEF709  bl 0x822c5770
	ctx.lr = 0x822D606C;
	sub_822C5770(ctx, base);
	// 822D606C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6070: 3B40001C  li r26, 0x1c
	ctx.r[26].s64 = 28;
	// 822D6074: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822D6078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D607C: 409A000C  bne cr6, 0x822d6088
	if !ctx.cr[6].eq {
	pc = 0x822D6088; continue 'dispatch;
	}
	// 822D6080: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 822D6084: 48000010  b 0x822d6094
	pc = 0x822D6094; continue 'dispatch;
	// 822D6088: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D608C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D6090: 7D0AD3D6  divw r8, r10, r26
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 822D6094: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822D6098: 419A0298  beq cr6, 0x822d6330
	if ctx.cr[6].eq {
	pc = 0x822D6330; continue 'dispatch;
	}
	// 822D609C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D60A0: 409A000C  bne cr6, 0x822d60ac
	if !ctx.cr[6].eq {
	pc = 0x822D60AC; continue 'dispatch;
	}
	// 822D60A4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 822D60A8: 48000010  b 0x822d60b8
	pc = 0x822D60B8; continue 'dispatch;
	// 822D60AC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D60B0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D60B4: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 822D60B8: 3D200924  lis r9, 0x924
	ctx.r[9].s64 = 153354240;
	// 822D60BC: 61299249  ori r9, r9, 0x9249
	ctx.r[9].u64 = ctx.r[9].u64 | 37449;
	// 822D60C0: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 822D60C4: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D60C8: 4098000C  bge cr6, 0x822d60d4
	if !ctx.cr[6].lt {
	pc = 0x822D60D4; continue 'dispatch;
	}
	// 822D60CC: 488E1C55  bl 0x82bb7d20
	ctx.lr = 0x822D60D0;
	sub_82BB7D20(ctx, base);
	// 822D60D0: 48000260  b 0x822d6330
	pc = 0x822D6330; continue 'dispatch;
	// 822D60D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D60D8: 409A000C  bne cr6, 0x822d60e4
	if !ctx.cr[6].eq {
	pc = 0x822D60E4; continue 'dispatch;
	}
	// 822D60DC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 822D60E0: 48000010  b 0x822d60f0
	pc = 0x822D60F0; continue 'dispatch;
	// 822D60E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D60E8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D60EC: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 822D60F0: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 822D60F4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D60F8: 40980134  bge cr6, 0x822d622c
	if !ctx.cr[6].lt {
	pc = 0x822D622C; continue 'dispatch;
	}
	// 822D60FC: 550AF87E  srwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822D6100: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822D6104: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 822D6108: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822D610C: 41980008  blt cr6, 0x822d6114
	if ctx.cr[6].lt {
	pc = 0x822D6114; continue 'dispatch;
	}
	// 822D6110: 7F8A4214  add r28, r10, r8
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 822D6114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D6118: 409A000C  bne cr6, 0x822d6124
	if !ctx.cr[6].eq {
	pc = 0x822D6124; continue 'dispatch;
	}
	// 822D611C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 822D6120: 48000010  b 0x822d6130
	pc = 0x822D6130; continue 'dispatch;
	// 822D6124: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6128: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D612C: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 822D6130: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 822D6134: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D6138: 40980024  bge cr6, 0x822d615c
	if !ctx.cr[6].lt {
	pc = 0x822D615C; continue 'dispatch;
	}
	// 822D613C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D6140: 409A000C  bne cr6, 0x822d614c
	if !ctx.cr[6].eq {
	pc = 0x822D614C; continue 'dispatch;
	}
	// 822D6144: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D6148: 48000010  b 0x822d6158
	pc = 0x822D6158; continue 'dispatch;
	// 822D614C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6150: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D6154: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 822D6158: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D615C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D6160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822D6164: 4BFFDB75  bl 0x822d3cd8
	ctx.lr = 0x822D6168;
	sub_822D3CD8(ctx, base);
	// 822D6168: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D616C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6170: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D6174: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6178: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D617C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D6180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D6184: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D6188: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822D618C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6190: 4BFFF251  bl 0x822d53e0
	ctx.lr = 0x822D6194;
	sub_822D53E0(ctx, base);
	// 822D6194: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D6198: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822D619C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822D61A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D61A4: 4BFFFCB5  bl 0x822d5e58
	ctx.lr = 0x822D61A8;
	sub_822D5E58(ctx, base);
	// 822D61A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D61AC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D61B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822D61B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D61B8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D61BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D61C0: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D61C4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D61C8: 4BFFF219  bl 0x822d53e0
	ctx.lr = 0x822D61CC;
	sub_822D53E0(ctx, base);
	// 822D61CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D61D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D61D4: 409A000C  bne cr6, 0x822d61e0
	if !ctx.cr[6].eq {
	pc = 0x822D61E0; continue 'dispatch;
	}
	// 822D61D8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 822D61DC: 48000010  b 0x822d61ec
	pc = 0x822D61EC; continue 'dispatch;
	// 822D61E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D61E4: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 822D61E8: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 822D61EC: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822D61F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D61F4: 419A0018  beq cr6, 0x822d620c
	if ctx.cr[6].eq {
	pc = 0x822D620C; continue 'dispatch;
	}
	// 822D61F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D61FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6200: 4BFF9839  bl 0x822cfa38
	ctx.lr = 0x822D6204;
	sub_822CFA38(ctx, base);
	// 822D6204: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6208: 4BFEA061  bl 0x822c0268
	ctx.lr = 0x822D620C;
	sub_822C0268(ctx, base);
	// 822D620C: 1D7C001C  mulli r11, r28, 0x1c
	ctx.r[11].s64 = ctx.r[28].s64 * 28;
	// 822D6210: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822D6214: 1D5E001C  mulli r10, r30, 0x1c
	ctx.r[10].s64 = ctx.r[30].s64 * 28;
	// 822D6218: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822D621C: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 822D6220: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822D6224: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D6228: 48000108  b 0x822d6330
	pc = 0x822D6330; continue 'dispatch;
	// 822D622C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6230: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 822D6234: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6238: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 822D623C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D6240: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 822D6244: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822D6248: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822D624C: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 822D6250: 4098006C  bge cr6, 0x822d62bc
	if !ctx.cr[6].lt {
	pc = 0x822D62BC; continue 'dispatch;
	}
	// 822D6254: 1F9B001C  mulli r28, r27, 0x1c
	ctx.r[28].s64 = ctx.r[27].s64 * 28;
	// 822D6258: 7CBCF214  add r5, r28, r30
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822D625C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D6260: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6264: 4BFFF17D  bl 0x822d53e0
	ctx.lr = 0x822D6268;
	sub_822D53E0(ctx, base);
	// 822D6268: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D626C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822D6270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D6274: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 822D6278: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 822D627C: 7CABD850  subf r5, r11, r27
	ctx.r[5].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 822D6280: 4BFFFBD9  bl 0x822d5e58
	ctx.lr = 0x822D6284;
	sub_822D5E58(ctx, base);
	// 822D6284: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6288: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822D628C: 7FBC5850  subf r29, r28, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 822D6290: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D6294: 4800001C  b 0x822d62b0
	pc = 0x822D62B0; continue 'dispatch;
	// 822D6298: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822D629C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D62A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822D62A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D62A8: 4BFEF2D9  bl 0x822c5580
	ctx.lr = 0x822D62AC;
	sub_822C5580(ctx, base);
	// 822D62AC: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 822D62B0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D62B4: 409AFFE4  bne cr6, 0x822d6298
	if !ctx.cr[6].eq {
	pc = 0x822D6298; continue 'dispatch;
	}
	// 822D62B8: 48000078  b 0x822d6330
	pc = 0x822D6330; continue 'dispatch;
	// 822D62BC: 1F7B001C  mulli r27, r27, 0x1c
	ctx.r[27].s64 = ctx.r[27].s64 * 28;
	// 822D62C0: 7F9BE850  subf r28, r27, r29
	ctx.r[28].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 822D62C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D62C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822D62CC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D62D0: 4BFFF111  bl 0x822d53e0
	ctx.lr = 0x822D62D4;
	sub_822D53E0(ctx, base);
	// 822D62D4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 822D62D8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822D62DC: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 822D62E0: 419A0020  beq cr6, 0x822d6300
	if ctx.cr[6].eq {
	pc = 0x822D6300; continue 'dispatch;
	}
	// 822D62E4: 7FBCE850  subf r29, r28, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 822D62E8: 3BFFFFE4  addi r31, r31, -0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + -28;
	// 822D62EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D62F0: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 822D62F4: 4BFFEA7D  bl 0x822d4d70
	ctx.lr = 0x822D62F8;
	sub_822D4D70(ctx, base);
	// 822D62F8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822D62FC: 409AFFEC  bne cr6, 0x822d62e8
	if !ctx.cr[6].eq {
	pc = 0x822D62E8; continue 'dispatch;
	}
	// 822D6300: 7FBBF214  add r29, r27, r30
	ctx.r[29].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 822D6304: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822D6308: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D630C: 419A0024  beq cr6, 0x822d6330
	if ctx.cr[6].eq {
	pc = 0x822D6330; continue 'dispatch;
	}
	// 822D6310: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822D6314: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D6318: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822D631C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D6320: 4BFEF261  bl 0x822c5580
	ctx.lr = 0x822D6324;
	sub_822C5580(ctx, base);
	// 822D6324: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 822D6328: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D632C: 409AFFE4  bne cr6, 0x822d6310
	if !ctx.cr[6].eq {
	pc = 0x822D6310; continue 'dispatch;
	}
	// 822D6330: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D6334: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D6338: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D633C: 4BFEE9A5  bl 0x822c4ce0
	ctx.lr = 0x822D6340;
	sub_822C4CE0(ctx, base);
	// 822D6340: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822D6344: 48ED1E68  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D6348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D6348 size=364
    let mut pc: u32 = 0x822D6348;
    'dispatch: loop {
        match pc {
            0x822D6348 => {
    //   block [0x822D6348..0x822D64B4)
	// 822D6348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D634C: 48ED1E15  bl 0x831a8160
	ctx.lr = 0x822D6350;
	sub_831A8130(ctx, base);
	// 822D6350: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D6354: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D6358: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D635C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822D6360: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D6364: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D6368: 388BA0A8  addi r4, r11, -0x5f58
	ctx.r[4].s64 = ctx.r[11].s64 + -24408;
	// 822D636C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D6370: 4BFFCF91  bl 0x822d3300
	ctx.lr = 0x822D6374;
	sub_822D3300(ctx, base);
	// 822D6374: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D6378: 41820130  beq 0x822d64a8
	if ctx.cr[0].eq {
	pc = 0x822D64A8; continue 'dispatch;
	}
	// 822D637C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D6380: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D6384: 388BA0BC  addi r4, r11, -0x5f44
	ctx.r[4].s64 = ctx.r[11].s64 + -24388;
	// 822D6388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D638C: 4BFFD02D  bl 0x822d33b8
	ctx.lr = 0x822D6390;
	sub_822D33B8(ctx, base);
	// 822D6390: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822D6394: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822D6398: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D639C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 822D63A0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 822D63A4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 822D63A8: 4871C3B1  bl 0x829f2758
	ctx.lr = 0x822D63AC;
	sub_829F2758(ctx, base);
	// 822D63AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D63B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D63B4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D63B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D63BC: 4E800421  bctrl
	ctx.lr = 0x822D63C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D63C0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D63C4: 418200DC  beq 0x822d64a0
	if ctx.cr[0].eq {
	pc = 0x822D64A0; continue 'dispatch;
	}
	// 822D63C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D63CC: 3B4BA0B0  addi r26, r11, -0x5f50
	ctx.r[26].s64 = ctx.r[11].s64 + -24400;
	// 822D63D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D63D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D63D8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D63DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D63E0: 4E800421  bctrl
	ctx.lr = 0x822D63E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D63E4: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 822D63E8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822D63EC: 409A0098  bne cr6, 0x822d6484
	if !ctx.cr[6].eq {
	pc = 0x822D6484; continue 'dispatch;
	}
	// 822D63F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D63F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D63F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D63FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D6400: 4E800421  bctrl
	ctx.lr = 0x822D6404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D6404: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D6408: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D640C: 4BFFCCBD  bl 0x822d30c8
	ctx.lr = 0x822D6410;
	sub_822D30C8(ctx, base);
	// 822D6410: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822D6414: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 822D6418: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 822D641C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D6420: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D6424: 4BFFC1CD  bl 0x822d25f0
	ctx.lr = 0x822D6428;
	sub_822D25F0(ctx, base);
	// 822D6428: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D642C: 40820048  bne 0x822d6474
	if !ctx.cr[0].eq {
	pc = 0x822D6474; continue 'dispatch;
	}
	// 822D6430: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6434: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822D6438: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D643C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D6440: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822D6444: 4BFFE2ED  bl 0x822d4730
	ctx.lr = 0x822D6448;
	sub_822D4730(ctx, base);
	// 822D6448: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D644C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D6450: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822D6454: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6458: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D645C: 4BFEE005  bl 0x822c4460
	ctx.lr = 0x822D6460;
	sub_822C4460(ctx, base);
	// 822D6460: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822D6464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D6468: 419A0008  beq cr6, 0x822d6470
	if ctx.cr[6].eq {
	pc = 0x822D6470; continue 'dispatch;
	}
	// 822D646C: 4BFEA425  bl 0x822c0890
	ctx.lr = 0x822D6470;
	sub_822C0890(ctx, base);
	// 822D6470: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 822D6474: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D6478: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D647C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D6480: 4BFEE861  bl 0x822c4ce0
	ctx.lr = 0x822D6484;
	sub_822C4CE0(ctx, base);
	// 822D6484: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D648C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822D6490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D6494: 4E800421  bctrl
	ctx.lr = 0x822D6498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D6498: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D649C: 4082FF34  bne 0x822d63d0
	if !ctx.cr[0].eq {
	pc = 0x822D63D0; continue 'dispatch;
	}
	// 822D64A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D64A4: 48000008  b 0x822d64ac
	pc = 0x822D64AC; continue 'dispatch;
	// 822D64A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D64AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822D64B0: 48ED1D00  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D64B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D64B8 size=224
    let mut pc: u32 = 0x822D64B8;
    'dispatch: loop {
        match pc {
            0x822D64B8 => {
    //   block [0x822D64B8..0x822D6598)
	// 822D64B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D64BC: 48ED1CA1  bl 0x831a815c
	ctx.lr = 0x822D64C0;
	sub_831A8130(ctx, base);
	// 822D64C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D64C4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D64C8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822D64CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D64D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D64D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D64D8: 419A00B4  beq cr6, 0x822d658c
	if ctx.cr[6].eq {
	pc = 0x822D658C; continue 'dispatch;
	}
	// 822D64DC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D64E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D64E4: 419A00A8  beq cr6, 0x822d658c
	if ctx.cr[6].eq {
	pc = 0x822D658C; continue 'dispatch;
	}
	// 822D64E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822D64EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D64F0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D64F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D64F8: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822D64FC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822D6500: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822D6504: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 822D6508: 4871C251  bl 0x829f2758
	ctx.lr = 0x822D650C;
	sub_829F2758(ctx, base);
	// 822D650C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D6510: 3B5F0014  addi r26, r31, 0x14
	ctx.r[26].s64 = ctx.r[31].s64 + 20;
	// 822D6514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D6518: 419A006C  beq cr6, 0x822d6584
	if ctx.cr[6].eq {
	pc = 0x822D6584; continue 'dispatch;
	}
	// 822D651C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822D6520: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 822D6524: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6528: 7CBC582E  lwzx r5, r28, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822D652C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6530: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822D6534: 40990040  ble cr6, 0x822d6574
	if !ctx.cr[6].gt {
	pc = 0x822D6574; continue 'dispatch;
	}
	// 822D6538: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D653C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822D6540: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822D6544: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822D6548: 4BFFDEA1  bl 0x822d43e8
	ctx.lr = 0x822D654C;
	sub_822D43E8(ctx, base);
	// 822D654C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D6550: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D6554: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822D6558: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D655C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D6560: 4BFEDF01  bl 0x822c4460
	ctx.lr = 0x822D6564;
	sub_822C4460(ctx, base);
	// 822D6564: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822D6568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D656C: 419A0008  beq cr6, 0x822d6574
	if ctx.cr[6].eq {
	pc = 0x822D6574; continue 'dispatch;
	}
	// 822D6570: 4BFEA321  bl 0x822c0890
	ctx.lr = 0x822D6574;
	sub_822C0890(ctx, base);
	// 822D6574: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 822D6578: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 822D657C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822D6580: 4082FFA4  bne 0x822d6524
	if !ctx.cr[0].eq {
	pc = 0x822D6524; continue 'dispatch;
	}
	// 822D6584: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D6588: 48000008  b 0x822d6590
	pc = 0x822D6590; continue 'dispatch;
	// 822D658C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D6590: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822D6594: 48ED1C18  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D6598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D6598 size=112
    let mut pc: u32 = 0x822D6598;
    'dispatch: loop {
        match pc {
            0x822D6598 => {
    //   block [0x822D6598..0x822D6608)
	// 822D6598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D659C: 48ED1BD1  bl 0x831a816c
	ctx.lr = 0x822D65A0;
	sub_831A8130(ctx, base);
	// 822D65A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D65A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D65A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D65AC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822D65B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D65B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D65B8: 419A0018  beq cr6, 0x822d65d0
	if ctx.cr[6].eq {
	pc = 0x822D65D0; continue 'dispatch;
	}
	// 822D65BC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D65C0: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 822D65C4: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822D65C8: 7D2953D7  divw. r9, r9, r10
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822D65CC: 4082000C  bne 0x822d65d8
	if !ctx.cr[0].eq {
	pc = 0x822D65D8; continue 'dispatch;
	}
	// 822D65D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822D65D4: 4800000C  b 0x822d65e0
	pc = 0x822D65E0; continue 'dispatch;
	// 822D65D8: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 822D65DC: 7FCB53D6  divw r30, r11, r10
	ctx.r[30].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 822D65E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822D65E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D65E8: 4BFFFA61  bl 0x822d6048
	ctx.lr = 0x822D65EC;
	sub_822D6048(ctx, base);
	// 822D65EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D65F0: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 * 28;
	// 822D65F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822D65F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D65FC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D6600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D6604: 48ED1BB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D6608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D6608 size=484
    let mut pc: u32 = 0x822D6608;
    'dispatch: loop {
        match pc {
            0x822D6608 => {
    //   block [0x822D6608..0x822D67EC)
	// 822D6608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D660C: 48ED1B45  bl 0x831a8150
	ctx.lr = 0x822D6610;
	sub_831A8130(ctx, base);
	// 822D6610: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D6614: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D6618: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822D661C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822D6620: 388BA0D4  addi r4, r11, -0x5f2c
	ctx.r[4].s64 = ctx.r[11].s64 + -24364;
	// 822D6624: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 822D6628: 4BFFBDA9  bl 0x822d23d0
	ctx.lr = 0x822D662C;
	sub_822D23D0(ctx, base);
	// 822D662C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D6630: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6634: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D663C: 4E800421  bctrl
	ctx.lr = 0x822D6640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D6640: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 822D6644: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822D6648: 40810198  ble 0x822d67e0
	if !ctx.cr[0].gt {
	pc = 0x822D67E0; continue 'dispatch;
	}
	// 822D664C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D6650: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D6654: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822D6658: 3B4BA0D0  addi r26, r11, -0x5f30
	ctx.r[26].s64 = ctx.r[11].s64 + -24368;
	// 822D665C: 3BAAA0C8  addi r29, r10, -0x5f38
	ctx.r[29].s64 = ctx.r[10].s64 + -24376;
	// 822D6660: 3B89A0C4  addi r28, r9, -0x5f3c
	ctx.r[28].s64 = ctx.r[9].s64 + -24380;
	// 822D6664: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6668: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D666C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D6670: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6674: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D6678: 4E800421  bctrl
	ctx.lr = 0x822D667C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D667C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822D6680: 41820154  beq 0x822d67d4
	if ctx.cr[0].eq {
	pc = 0x822D67D4; continue 'dispatch;
	}
	// 822D6684: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D6688: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D668C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D6690: 4BFEE651  bl 0x822c4ce0
	ctx.lr = 0x822D6694;
	sub_822C4CE0(ctx, base);
	// 822D6694: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D6698: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D669C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D66A0: 4BFFCBA1  bl 0x822d3240
	ctx.lr = 0x822D66A4;
	sub_822D3240(ctx, base);
	// 822D66A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D66A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D66AC: 48001F65  bl 0x822d8610
	ctx.lr = 0x822D66B0;
	sub_822D8610(ctx, base);
	// 822D66B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D66B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D66B8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D66BC: 4BFFCE6D  bl 0x822d3528
	ctx.lr = 0x822D66C0;
	sub_822D3528(ctx, base);
	// 822D66C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822D66C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D66C8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822D66CC: 4BFFFC7D  bl 0x822d6348
	ctx.lr = 0x822D66D0;
	sub_822D6348(ctx, base);
	// 822D66D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D66D4: 418200E0  beq 0x822d67b4
	if ctx.cr[0].eq {
	pc = 0x822D67B4; continue 'dispatch;
	}
	// 822D66D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D66DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D66E0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822D66E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D66E8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822D66EC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822D66F0: 419A0024  beq cr6, 0x822d6714
	if ctx.cr[6].eq {
	pc = 0x822D6714; continue 'dispatch;
	}
	// 822D66F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822D66F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D66FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D6700: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D6704: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D6708: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D670C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D6710: 4082FFE8  bne 0x822d66f8
	if !ctx.cr[0].eq {
	pc = 0x822D66F8; continue 'dispatch;
	}
	// 822D6714: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822D6718: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D671C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 822D6720: 4BFFE6E9  bl 0x822d4e08
	ctx.lr = 0x822D6724;
	sub_822D4E08(ctx, base);
	// 822D6724: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 822D6728: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822D672C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822D6730: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822D6734: 4BFFE5C5  bl 0x822d4cf8
	ctx.lr = 0x822D6738;
	sub_822D4CF8(ctx, base);
	// 822D6738: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D673C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D6740: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 822D6744: 4BFEE59D  bl 0x822c4ce0
	ctx.lr = 0x822D6748;
	sub_822C4CE0(ctx, base);
	// 822D6748: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D674C: 419A000C  beq cr6, 0x822d6758
	if ctx.cr[6].eq {
	pc = 0x822D6758; continue 'dispatch;
	}
	// 822D6750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D6754: 4BFEA13D  bl 0x822c0890
	ctx.lr = 0x822D6758;
	sub_822C0890(ctx, base);
	// 822D6758: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 822D675C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822D6760: 4BFFE521  bl 0x822d4c80
	ctx.lr = 0x822D6764;
	sub_822D4C80(ctx, base);
	// 822D6764: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 822D6768: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822D676C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822D6770: 4BFFF589  bl 0x822d5cf8
	ctx.lr = 0x822D6774;
	sub_822D5CF8(ctx, base);
	// 822D6774: 806100E0  lwz r3, 0xe0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 822D6778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D677C: 419A0008  beq cr6, 0x822d6784
	if ctx.cr[6].eq {
	pc = 0x822D6784; continue 'dispatch;
	}
	// 822D6780: 4BFEA111  bl 0x822c0890
	ctx.lr = 0x822D6784;
	sub_822C0890(ctx, base);
	// 822D6784: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D6788: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D678C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822D6790: 4BFEE551  bl 0x822c4ce0
	ctx.lr = 0x822D6794;
	sub_822C4CE0(ctx, base);
	// 822D6794: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 822D6798: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D679C: 419A0008  beq cr6, 0x822d67a4
	if ctx.cr[6].eq {
	pc = 0x822D67A4; continue 'dispatch;
	}
	// 822D67A0: 4BFEA0F1  bl 0x822c0890
	ctx.lr = 0x822D67A4;
	sub_822C0890(ctx, base);
	// 822D67A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D67A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D67AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822D67B0: 4BFEE531  bl 0x822c4ce0
	ctx.lr = 0x822D67B4;
	sub_822C4CE0(ctx, base);
	// 822D67B4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D67B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D67BC: 419A0008  beq cr6, 0x822d67c4
	if ctx.cr[6].eq {
	pc = 0x822D67C4; continue 'dispatch;
	}
	// 822D67C0: 4BFEA0D1  bl 0x822c0890
	ctx.lr = 0x822D67C4;
	sub_822C0890(ctx, base);
	// 822D67C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D67C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D67CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D67D0: 4BFEE511  bl 0x822c4ce0
	ctx.lr = 0x822D67D4;
	sub_822C4CE0(ctx, base);
	// 822D67D4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 822D67D8: 7F1BC800  cmpw cr6, r27, r25
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[25].s32, &mut ctx.xer);
	// 822D67DC: 4198FE88  blt cr6, 0x822d6664
	if ctx.cr[6].lt {
	pc = 0x822D6664; continue 'dispatch;
	}
	// 822D67E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D67E4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 822D67E8: 48ED19B8  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D67F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D67F0 size=432
    let mut pc: u32 = 0x822D67F0;
    'dispatch: loop {
        match pc {
            0x822D67F0 => {
    //   block [0x822D67F0..0x822D69A0)
	// 822D67F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D67F4: 48ED1965  bl 0x831a8158
	ctx.lr = 0x822D67F8;
	sub_831A8130(ctx, base);
	// 822D67F8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D67FC: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D6800: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822D6804: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 822D6808: 3BA4000C  addi r29, r4, 0xc
	ctx.r[29].s64 = ctx.r[4].s64 + 12;
	// 822D680C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D6810: 419A0184  beq cr6, 0x822d6994
	if ctx.cr[6].eq {
	pc = 0x822D6994; continue 'dispatch;
	}
	// 822D6814: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822D6818: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D681C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822D6820: 3B6BA0D0  addi r27, r11, -0x5f30
	ctx.r[27].s64 = ctx.r[11].s64 + -24368;
	// 822D6824: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D6828: 7FFE582E  lwzx r31, r30, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822D682C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6830: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822D6834: 40990154  ble cr6, 0x822d6988
	if !ctx.cr[6].gt {
	pc = 0x822D6988; continue 'dispatch;
	}
	// 822D6838: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D683C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822D6840: 419A0148  beq cr6, 0x822d6988
	if ctx.cr[6].eq {
	pc = 0x822D6988; continue 'dispatch;
	}
	// 822D6844: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 822D6848: 4BFEF081  bl 0x822c58c8
	ctx.lr = 0x822D684C;
	sub_822C58C8(ctx, base);
	// 822D684C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D6850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D6854: 48001DBD  bl 0x822d8610
	ctx.lr = 0x822D6858;
	sub_822D8610(ctx, base);
	// 822D6858: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D685C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D6860: 40990108  ble cr6, 0x822d6968
	if !ctx.cr[6].gt {
	pc = 0x822D6968; continue 'dispatch;
	}
	// 822D6864: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D6868: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D686C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D6870: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822D6874: 409900F4  ble cr6, 0x822d6968
	if !ctx.cr[6].gt {
	pc = 0x822D6968; continue 'dispatch;
	}
	// 822D6878: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822D687C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6880: 4BFFFC39  bl 0x822d64b8
	ctx.lr = 0x822D6884;
	sub_822D64B8(ctx, base);
	// 822D6884: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D6888: 418200E0  beq 0x822d6968
	if ctx.cr[0].eq {
	pc = 0x822D6968; continue 'dispatch;
	}
	// 822D688C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D6890: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822D6894: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822D6898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D689C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822D68A0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822D68A4: 419A0024  beq cr6, 0x822d68c8
	if ctx.cr[6].eq {
	pc = 0x822D68C8; continue 'dispatch;
	}
	// 822D68A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822D68AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D68B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D68B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D68B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D68BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D68C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D68C4: 4082FFE8  bne 0x822d68ac
	if !ctx.cr[0].eq {
	pc = 0x822D68AC; continue 'dispatch;
	}
	// 822D68C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822D68CC: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 822D68D0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 822D68D4: 4BFFE535  bl 0x822d4e08
	ctx.lr = 0x822D68D8;
	sub_822D4E08(ctx, base);
	// 822D68D8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822D68DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822D68E0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822D68E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D68E8: 4BFFE411  bl 0x822d4cf8
	ctx.lr = 0x822D68EC;
	sub_822D4CF8(ctx, base);
	// 822D68EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D68F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D68F4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822D68F8: 4BFEE3E9  bl 0x822c4ce0
	ctx.lr = 0x822D68FC;
	sub_822C4CE0(ctx, base);
	// 822D68FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D6900: 419A000C  beq cr6, 0x822d690c
	if ctx.cr[6].eq {
	pc = 0x822D690C; continue 'dispatch;
	}
	// 822D6904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D6908: 4BFE9F89  bl 0x822c0890
	ctx.lr = 0x822D690C;
	sub_822C0890(ctx, base);
	// 822D690C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822D6910: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822D6914: 4BFFE36D  bl 0x822d4c80
	ctx.lr = 0x822D6918;
	sub_822D4C80(ctx, base);
	// 822D6918: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 822D691C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822D6920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D6924: 4BFFF3D5  bl 0x822d5cf8
	ctx.lr = 0x822D6928;
	sub_822D5CF8(ctx, base);
	// 822D6928: 806100C0  lwz r3, 0xc0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 822D692C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D6930: 419A0008  beq cr6, 0x822d6938
	if ctx.cr[6].eq {
	pc = 0x822D6938; continue 'dispatch;
	}
	// 822D6934: 4BFE9F5D  bl 0x822c0890
	ctx.lr = 0x822D6938;
	sub_822C0890(ctx, base);
	// 822D6938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D693C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D6940: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822D6944: 4BFEE39D  bl 0x822c4ce0
	ctx.lr = 0x822D6948;
	sub_822C4CE0(ctx, base);
	// 822D6948: 80610090  lwz r3, 0x90(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 822D694C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D6950: 419A0008  beq cr6, 0x822d6958
	if ctx.cr[6].eq {
	pc = 0x822D6958; continue 'dispatch;
	}
	// 822D6954: 4BFE9F3D  bl 0x822c0890
	ctx.lr = 0x822D6958;
	sub_822C0890(ctx, base);
	// 822D6958: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D695C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D6960: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822D6964: 4BFEE37D  bl 0x822c4ce0
	ctx.lr = 0x822D6968;
	sub_822C4CE0(ctx, base);
	// 822D6968: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D696C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D6970: 419A0008  beq cr6, 0x822d6978
	if ctx.cr[6].eq {
	pc = 0x822D6978; continue 'dispatch;
	}
	// 822D6974: 4BFE9F1D  bl 0x822c0890
	ctx.lr = 0x822D6978;
	sub_822C0890(ctx, base);
	// 822D6978: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D697C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D6980: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 822D6984: 4BFEE35D  bl 0x822c4ce0
	ctx.lr = 0x822D6988;
	sub_822C4CE0(ctx, base);
	// 822D6988: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822D698C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822D6990: 4082FE94  bne 0x822d6824
	if !ctx.cr[0].eq {
	pc = 0x822D6824; continue 'dispatch;
	}
	// 822D6994: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D6998: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 822D699C: 48ED180C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D69A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D69A0 size=164
    let mut pc: u32 = 0x822D69A0;
    'dispatch: loop {
        match pc {
            0x822D69A0 => {
    //   block [0x822D69A0..0x822D6A44)
	// 822D69A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D69A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D69A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D69AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D69B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D69B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D69B8: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 822D69BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D69C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D69C4: 409A000C  bne cr6, 0x822d69d0
	if !ctx.cr[6].eq {
	pc = 0x822D69D0; continue 'dispatch;
	}
	// 822D69C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822D69CC: 48000010  b 0x822d69dc
	pc = 0x822D69DC; continue 'dispatch;
	// 822D69D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D69D4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D69D8: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 822D69DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D69E0: 419A0038  beq cr6, 0x822d6a18
	if ctx.cr[6].eq {
	pc = 0x822D6A18; continue 'dispatch;
	}
	// 822D69E4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D69E8: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 822D69EC: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 822D69F0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D69F4: 40980024  bge cr6, 0x822d6a18
	if !ctx.cr[6].lt {
	pc = 0x822D6A18; continue 'dispatch;
	}
	// 822D69F8: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D69FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822D6A00: 419A000C  beq cr6, 0x822d6a0c
	if ctx.cr[6].eq {
	pc = 0x822D6A0C; continue 'dispatch;
	}
	// 822D6A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D6A08: 4BFEED69  bl 0x822c5770
	ctx.lr = 0x822D6A0C;
	sub_822C5770(ctx, base);
	// 822D6A0C: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 822D6A10: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D6A14: 48000018  b 0x822d6a2c
	pc = 0x822D6A2C; continue 'dispatch;
	// 822D6A18: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822D6A1C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D6A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D6A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D6A28: 4BFFFB71  bl 0x822d6598
	ctx.lr = 0x822D6A2C;
	sub_822D6598(ctx, base);
	// 822D6A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D6A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D6A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D6A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D6A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D6A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D6A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D6A48 size=2140
    let mut pc: u32 = 0x822D6A48;
    'dispatch: loop {
        match pc {
            0x822D6A48 => {
    //   block [0x822D6A48..0x822D72A4)
	// 822D6A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D6A4C: 48ED16ED  bl 0x831a8138
	ctx.lr = 0x822D6A50;
	sub_831A8130(ctx, base);
	// 822D6A50: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 822D6A54: 9421FBD0  stwu r1, -0x430(r1)
	ea = ctx.r[1].u32.wrapping_add(-1072 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D6A58: 3A200010  li r17, 0x10
	ctx.r[17].s64 = 16;
	// 822D6A5C: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D6A60: 3A400020  li r18, 0x20
	ctx.r[18].s64 = 32;
	// 822D6A64: 3A600030  li r19, 0x30
	ctx.r[19].s64 = 48;
	// 822D6A68: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 822D6A6C: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 822D6A70: 39210120  addi r9, r1, 0x120
	ctx.r[9].s64 = ctx.r[1].s64 + 288;
	// 822D6A74: 13D13407  vcmpneb. (lvlx128) v30, v17, v6
	tmp.u32 = ctx.r[17].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D6A78: 39010130  addi r8, r1, 0x130
	ctx.r[8].s64 = ctx.r[1].s64 + 304;
	// 822D6A7C: 13B23407  vcmpneb. (lvlx128) v29, v18, v6
	tmp.u32 = ctx.r[18].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D6A80: 13933407  vcmpneb. (lvlx128) v28, v19, v6
	tmp.u32 = ctx.r[19].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D6A84: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D72A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D72A8 size=1928
    let mut pc: u32 = 0x822D72A8;
    'dispatch: loop {
        match pc {
            0x822D72A8 => {
    //   block [0x822D72A8..0x822D7A30)
	// 822D72A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D72AC: 48ED0E9D  bl 0x831a8148
	ctx.lr = 0x822D72B0;
	sub_831A8130(ctx, base);
	// 822D72B0: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 822D72B4: 9421FC30  stwu r1, -0x3d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-976 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D72B8: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 822D72BC: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D72C0: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 822D72C4: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 822D72C8: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 822D72CC: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 822D72D0: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 822D72D4: 13D53407  vcmpneb. (lvlx128) v30, v21, v6
	tmp.u32 = ctx.r[21].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D72D8: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 822D72DC: 13BD3407  vcmpneb. (lvlx128) v29, v29, v6
	tmp.u32 = ctx.r[29].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D72E0: 139E3407  vcmpneb. (lvlx128) v28, v30, v6
	tmp.u32 = ctx.r[30].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D72E4: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D7A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D7A30 size=48
    let mut pc: u32 = 0x822D7A30;
    'dispatch: loop {
        match pc {
            0x822D7A30 => {
    //   block [0x822D7A30..0x822D7A60)
	// 822D7A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D7A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D7A38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D7A3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D7A40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D7A44: 4BFFC5CD  bl 0x822d4010
	ctx.lr = 0x822D7A48;
	sub_822D4010(ctx, base);
	// 822D7A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D7A4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D7A50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D7A54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D7A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D7A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D7A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D7A60 size=668
    let mut pc: u32 = 0x822D7A60;
    'dispatch: loop {
        match pc {
            0x822D7A60 => {
    //   block [0x822D7A60..0x822D7CFC)
	// 822D7A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D7A64: 48ED06ED  bl 0x831a8150
	ctx.lr = 0x822D7A68;
	sub_831A8130(ctx, base);
	// 822D7A68: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 822D7A6C: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D7A70: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 822D7A74: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7A78: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 822D7A7C: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7A80: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822D7A84: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 822D7A88: 38E100F0  addi r7, r1, 0xf0
	ctx.r[7].s64 = ctx.r[1].s64 + 240;
	// 822D7A8C: 13CB3407  vcmpneb. (lvlx128) v30, v11, v6
	tmp.u32 = ctx.r[11].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7A90: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 822D7A94: 3BE10110  addi r31, r1, 0x110
	ctx.r[31].s64 = ctx.r[1].s64 + 272;
	// 822D7A98: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D7A9C: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 822D7AA0: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7AA4: 13883407  vcmpneb. (lvlx128) v28, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7AA8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D7D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D7D00 size=164
    let mut pc: u32 = 0x822D7D00;
    'dispatch: loop {
        match pc {
            0x822D7D00 => {
    //   block [0x822D7D00..0x822D7DA4)
	// 822D7D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D7D04: 48ED0461  bl 0x831a8164
	ctx.lr = 0x822D7D08;
	sub_831A8130(ctx, base);
	// 822D7D08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D7D0C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822D7D10: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D7D14: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D7D18: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7D1C: 3BC4000C  addi r30, r4, 0xc
	ctx.r[30].s64 = ctx.r[4].s64 + 12;
	// 822D7D20: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822D7D24: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 822D7D28: 13CA3407  vcmpneb. (lvlx128) v30, v10, v6
	tmp.u32 = ctx.r[10].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7D2C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822D7D30: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D7D34: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822D7D38: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822D7D3C: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7D40: 13883407  vcmpneb. (lvlx128) v28, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D7D44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822D7D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D7DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D7DA8 size=336
    let mut pc: u32 = 0x822D7DA8;
    'dispatch: loop {
        match pc {
            0x822D7DA8 => {
    //   block [0x822D7DA8..0x822D7EF8)
	// 822D7DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D7DAC: 48ED03C1  bl 0x831a816c
	ctx.lr = 0x822D7DB0;
	sub_831A8130(ctx, base);
	// 822D7DB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D7DB4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7DB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D7DBC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822D7DC0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822D7DC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D7DC8: 4E800421  bctrl
	ctx.lr = 0x822D7DCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D7DCC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D7DD0: 4182011C  beq 0x822d7eec
	if ctx.cr[0].eq {
	pc = 0x822D7EEC; continue 'dispatch;
	}
	// 822D7DD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7DD8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D7DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D7DE0: 3BEAA180  addi r31, r10, -0x5e80
	ctx.r[31].s64 = ctx.r[10].s64 + -24192;
	// 822D7DE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D7DE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D7DEC: 4E800421  bctrl
	ctx.lr = 0x822D7DF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D7DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822D7DF4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822D7DF8: 4BFFB2D1  bl 0x822d30c8
	ctx.lr = 0x822D7DFC;
	sub_822D30C8(ctx, base);
	// 822D7DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D7E00: 4BFFA8C9  bl 0x822d26c8
	ctx.lr = 0x822D7E04;
	sub_822D26C8(ctx, base);
	// 822D7E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D7E08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D7E0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D7E10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822D7E14: 4BFECECD  bl 0x822c4ce0
	ctx.lr = 0x822D7E18;
	sub_822C4CE0(ctx, base);
	// 822D7E18: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D7E1C: 418200D0  beq 0x822d7eec
	if ctx.cr[0].eq {
	pc = 0x822D7EEC; continue 'dispatch;
	}
	// 822D7E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D7E24: 4BFFC8B5  bl 0x822d46d8
	ctx.lr = 0x822D7E28;
	sub_822D46D8(ctx, base);
	// 822D7E28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D7E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D7E30: 388BA178  addi r4, r11, -0x5e88
	ctx.r[4].s64 = ctx.r[11].s64 + -24200;
	// 822D7E34: 4BFFB6F5  bl 0x822d3528
	ctx.lr = 0x822D7E38;
	sub_822D3528(ctx, base);
	// 822D7E38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822D7E3C: 41820074  beq 0x822d7eb0
	if ctx.cr[0].eq {
	pc = 0x822D7EB0; continue 'dispatch;
	}
	// 822D7E40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D7E44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D7E48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D7E4C: 4BFECE95  bl 0x822c4ce0
	ctx.lr = 0x822D7E50;
	sub_822C4CE0(ctx, base);
	// 822D7E50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D7E54: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D7E58: 388BA078  addi r4, r11, -0x5f88
	ctx.r[4].s64 = ctx.r[11].s64 + -24456;
	// 822D7E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D7E60: 4BFFB3E1  bl 0x822d3240
	ctx.lr = 0x822D7E64;
	sub_822D3240(ctx, base);
	// 822D7E64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D7E68: 41820038  beq 0x822d7ea0
	if ctx.cr[0].eq {
	pc = 0x822D7EA0; continue 'dispatch;
	}
	// 822D7E6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D7E70: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D7E74: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 822D7E78: 38CBA16C  addi r6, r11, -0x5e94
	ctx.r[6].s64 = ctx.r[11].s64 + -24212;
	// 822D7E7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D7E80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D7E84: 4BFFA76D  bl 0x822d25f0
	ctx.lr = 0x822D7E88;
	sub_822D25F0(ctx, base);
	// 822D7E88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D7E8C: 40820014  bne 0x822d7ea0
	if !ctx.cr[0].eq {
	pc = 0x822D7EA0; continue 'dispatch;
	}
	// 822D7E90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D7E94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D7E98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D7E9C: 4BFFE76D  bl 0x822d6608
	ctx.lr = 0x822D7EA0;
	sub_822D6608(ctx, base);
	// 822D7EA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D7EA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D7EA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822D7EAC: 4BFECE35  bl 0x822c4ce0
	ctx.lr = 0x822D7EB0;
	sub_822C4CE0(ctx, base);
	// 822D7EB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D7EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D7EB8: 388BA164  addi r4, r11, -0x5e9c
	ctx.r[4].s64 = ctx.r[11].s64 + -24220;
	// 822D7EBC: 4BFFB66D  bl 0x822d3528
	ctx.lr = 0x822D7EC0;
	sub_822D3528(ctx, base);
	// 822D7EC0: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 822D7EC4: 41820018  beq 0x822d7edc
	if ctx.cr[0].eq {
	pc = 0x822D7EDC; continue 'dispatch;
	}
	// 822D7EC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822D7ECC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D7ED0: 38CB6880  addi r6, r11, 0x6880
	ctx.r[6].s64 = ctx.r[11].s64 + 26752;
	// 822D7ED4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D7ED8: 4BFFFB89  bl 0x822d7a60
	ctx.lr = 0x822D7EDC;
	sub_822D7A60(ctx, base);
	// 822D7EDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D7EE0: 4BFFE119  bl 0x822d5ff8
	ctx.lr = 0x822D7EE4;
	sub_822D5FF8(ctx, base);
	// 822D7EE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D7EE8: 48000008  b 0x822d7ef0
	pc = 0x822D7EF0; continue 'dispatch;
	// 822D7EEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D7EF0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822D7EF4: 48ED02C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D7EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D7EF8 size=268
    let mut pc: u32 = 0x822D7EF8;
    'dispatch: loop {
        match pc {
            0x822D7EF8 => {
    //   block [0x822D7EF8..0x822D8004)
	// 822D7EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D7EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D7F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D7F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D7F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D7F0C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D7F10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D7F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D7F18: 409900D0  ble cr6, 0x822d7fe8
	if !ctx.cr[6].gt {
	pc = 0x822D7FE8; continue 'dispatch;
	}
	// 822D7F1C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D7F20: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F28: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D7F2C: 409900BC  ble cr6, 0x822d7fe8
	if !ctx.cr[6].gt {
	pc = 0x822D7FE8; continue 'dispatch;
	}
	// 822D7F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D7F34: 4BFFC7A5  bl 0x822d46d8
	ctx.lr = 0x822D7F38;
	sub_822D46D8(ctx, base);
	// 822D7F38: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D7F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D7F40: 40990064  ble cr6, 0x822d7fa4
	if !ctx.cr[6].gt {
	pc = 0x822D7FA4; continue 'dispatch;
	}
	// 822D7F44: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D7F48: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F4C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D7F54: 40990050  ble cr6, 0x822d7fa4
	if !ctx.cr[6].gt {
	pc = 0x822D7FA4; continue 'dispatch;
	}
	// 822D7F58: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D7F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D7F60: 419A0044  beq cr6, 0x822d7fa4
	if ctx.cr[6].eq {
	pc = 0x822D7FA4; continue 'dispatch;
	}
	// 822D7F64: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D7F68: 394AA16C  addi r10, r10, -0x5e94
	ctx.r[10].s64 = ctx.r[10].s64 + -24212;
	// 822D7F6C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F70: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7F74: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D7F78: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 822D7F7C: 41820014  beq 0x822d7f90
	if ctx.cr[0].eq {
	pc = 0x822D7F90; continue 'dispatch;
	}
	// 822D7F80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 822D7F84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D7F88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822D7F8C: 419AFFE0  beq cr6, 0x822d7f6c
	if ctx.cr[6].eq {
	pc = 0x822D7F6C; continue 'dispatch;
	}
	// 822D7F90: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D7F94: 40820010  bne 0x822d7fa4
	if !ctx.cr[0].eq {
	pc = 0x822D7FA4; continue 'dispatch;
	}
	// 822D7F98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D7F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D7FA0: 4BFFE851  bl 0x822d67f0
	ctx.lr = 0x822D7FA4;
	sub_822D67F0(ctx, base);
	// 822D7FA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D7FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D7FAC: 4099002C  ble cr6, 0x822d7fd8
	if !ctx.cr[6].gt {
	pc = 0x822D7FD8; continue 'dispatch;
	}
	// 822D7FB0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D7FB4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7FB8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D7FBC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D7FC0: 40990018  ble cr6, 0x822d7fd8
	if !ctx.cr[6].gt {
	pc = 0x822D7FD8; continue 'dispatch;
	}
	// 822D7FC4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822D7FC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D7FCC: 38CB6880  addi r6, r11, 0x6880
	ctx.r[6].s64 = ctx.r[11].s64 + 26752;
	// 822D7FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D7FD4: 4BFFFD2D  bl 0x822d7d00
	ctx.lr = 0x822D7FD8;
	sub_822D7D00(ctx, base);
	// 822D7FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D7FDC: 4BFFE01D  bl 0x822d5ff8
	ctx.lr = 0x822D7FE0;
	sub_822D5FF8(ctx, base);
	// 822D7FE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D7FE4: 48000008  b 0x822d7fec
	pc = 0x822D7FEC; continue 'dispatch;
	// 822D7FE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D7FEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D7FF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D7FF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D7FF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D7FFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8008 size=280
    let mut pc: u32 = 0x822D8008;
    'dispatch: loop {
        match pc {
            0x822D8008 => {
    //   block [0x822D8008..0x822D8120)
	// 822D8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D800C: 48ED0159  bl 0x831a8164
	ctx.lr = 0x822D8010;
	sub_831A8130(ctx, base);
	// 822D8010: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8014: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822D8018: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 822D801C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D8020: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822D8024: 48D00225  bl 0x82fd8248
	ctx.lr = 0x822D8028;
	sub_82FD8248(ctx, base);
	// 822D8028: 3FC08339  lis r30, -0x7cc7
	ctx.r[30].s64 = -2093416448;
	// 822D802C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8030: 4182001C  beq 0x822d804c
	if ctx.cr[0].eq {
	pc = 0x822D804C; continue 'dispatch;
	}
	// 822D8034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822D8038: 80BEB7E8  lwz r5, -0x4818(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 822D803C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822D8040: 48CFF989  bl 0x82fd79c8
	ctx.lr = 0x822D8044;
	sub_82FD79C8(ctx, base);
	// 822D8044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8048: 48000008  b 0x822d8050
	pc = 0x822D8050; continue 'dispatch;
	// 822D804C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822D8050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8054: 419A00C0  beq cr6, 0x822d8114
	if ctx.cr[6].eq {
	pc = 0x822D8114; continue 'dispatch;
	}
	// 822D8058: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D805C: 811EB7E8  lwz r8, -0x4818(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-18456 as u32) ) } as u64;
	// 822D8060: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822D8064: 38CBA18C  addi r6, r11, -0x5e74
	ctx.r[6].s64 = ctx.r[11].s64 + -24180;
	// 822D8068: 5785003E  slwi r5, r28, 0
	ctx.r[5].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 822D806C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D8070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D8074: 48CFB9D5  bl 0x82fd3a48
	ctx.lr = 0x822D8078;
	sub_82FD3A48(ctx, base);
	// 822D8078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822D807C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8080: 48CFC609  bl 0x82fd4688
	ctx.lr = 0x822D8084;
	sub_82FD4688(ctx, base);
	// 822D8084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8088: 48CFC3A1  bl 0x82fd4428
	ctx.lr = 0x822D808C;
	sub_82FD4428(ctx, base);
	// 822D808C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822D8090: 40820064  bne 0x822d80f4
	if !ctx.cr[0].eq {
	pc = 0x822D80F4; continue 'dispatch;
	}
	// 822D8094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8098: 48CFC2E9  bl 0x82fd4380
	ctx.lr = 0x822D809C;
	sub_82FD4380(ctx, base);
	// 822D809C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D80A0: 41820054  beq 0x822d80f4
	if ctx.cr[0].eq {
	pc = 0x822D80F4; continue 'dispatch;
	}
	// 822D80A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822D80A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822D80AC: 4BFFFCFD  bl 0x822d7da8
	ctx.lr = 0x822D80B0;
	sub_822D7DA8(ctx, base);
	// 822D80B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D80B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D80B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D80BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D80C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D80C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D80C8: 4E800421  bctrl
	ctx.lr = 0x822D80CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D80CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D80D0: 48CFB9D9  bl 0x82fd3aa8
	ctx.lr = 0x822D80D4;
	sub_82FD3AA8(ctx, base);
	// 822D80D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D80D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D80DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D80E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D80E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D80E8: 4E800421  bctrl
	ctx.lr = 0x822D80EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D80EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D80F0: 48000028  b 0x822d8118
	pc = 0x822D8118; continue 'dispatch;
	// 822D80F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D80F8: 48CFB9B1  bl 0x82fd3aa8
	ctx.lr = 0x822D80FC;
	sub_82FD3AA8(ctx, base);
	// 822D80FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8100: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D8104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8108: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D810C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8110: 4E800421  bctrl
	ctx.lr = 0x822D8114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8118: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822D811C: 48ED0098  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8120 size=96
    let mut pc: u32 = 0x822D8120;
    'dispatch: loop {
        match pc {
            0x822D8120 => {
    //   block [0x822D8120..0x822D8180)
	// 822D8120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D812C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8134: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D8138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D813C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8140: 48B36369  bl 0x82e0e4a8
	ctx.lr = 0x822D8144;
	sub_82E0E4A8(ctx, base);
	// 822D8144: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8148: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822D814C: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822D8150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8154: 40990010  ble cr6, 0x822d8164
	if !ctx.cr[6].gt {
	pc = 0x822D8164; continue 'dispatch;
	}
	// 822D8158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D815C: 4BFFFD9D  bl 0x822d7ef8
	ctx.lr = 0x822D8160;
	sub_822D7EF8(ctx, base);
	// 822D8160: 48000008  b 0x822d8168
	pc = 0x822D8168; continue 'dispatch;
	// 822D8164: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8168: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D816C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8174: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D8178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D817C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8180 size=12
    let mut pc: u32 = 0x822D8180;
    'dispatch: loop {
        match pc {
            0x822D8180 => {
    //   block [0x822D8180..0x822D818C)
	// 822D8180: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D8184: 41820008  beq 0x822d818c
	if ctx.cr[0].eq {
		sub_822D818C(ctx, base);
		return;
	}
	// 822D8188: 4BFFFE80  b 0x822d8008
	sub_822D8008(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D818C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D818C size=4
    let mut pc: u32 = 0x822D818C;
    'dispatch: loop {
        match pc {
            0x822D818C => {
    //   block [0x822D818C..0x822D8190)
	// 822D818C: 4BFFFF94  b 0x822d8120
	sub_822D8120(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8190 size=160
    let mut pc: u32 = 0x822D8190;
    'dispatch: loop {
        match pc {
            0x822D8190 => {
    //   block [0x822D8190..0x822D8230)
	// 822D8190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D8194: EDA10072  fmuls f13, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 822D8198: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8230 size=264
    let mut pc: u32 = 0x822D8230;
    'dispatch: loop {
        match pc {
            0x822D8230 => {
    //   block [0x822D8230..0x822D8338)
	// 822D8230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D823C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8240: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D8244: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D8248: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D824C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D8250: 41980038  blt cr6, 0x822d8288
	if ctx.cr[6].lt {
	pc = 0x822D8288; continue 'dispatch;
	}
	// 822D8254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D8258: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D825C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D8260: 41990028  bgt cr6, 0x822d8288
	if ctx.cr[6].gt {
	pc = 0x822D8288; continue 'dispatch;
	}
	// 822D8264: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D826C: 419A001C  beq cr6, 0x822d8288
	if ctx.cr[6].eq {
	pc = 0x822D8288; continue 'dispatch;
	}
	// 822D8270: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D8274: 4098002C  bge cr6, 0x822d82a0
	if !ctx.cr[6].lt {
	pc = 0x822D82A0; continue 'dispatch;
	}
	// 822D8278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D827C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822D8280: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8338 size=188
    let mut pc: u32 = 0x822D8338;
    'dispatch: loop {
        match pc {
            0x822D8338 => {
    //   block [0x822D8338..0x822D83F4)
	// 822D8338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D833C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D8344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D834C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D8350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8354: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822D8358: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D835C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8360: 4BFE85D9  bl 0x822c0938
	ctx.lr = 0x822D8364;
	sub_822C0938(ctx, base);
	// 822D8364: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8368: 41820028  beq 0x822d8390
	if ctx.cr[0].eq {
	pc = 0x822D8390; continue 'dispatch;
	}
	// 822D836C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8370: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822D8374: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822D8378: 392BA1A0  addi r9, r11, -0x5e60
	ctx.r[9].s64 = ctx.r[11].s64 + -24160;
	// 822D837C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D8380: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8384: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D8388: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D838C: 48000008  b 0x822d8394
	pc = 0x822D8394; continue 'dispatch;
	// 822D8390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8394: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D839C: 409A003C  bne cr6, 0x822d83d8
	if !ctx.cr[6].eq {
	pc = 0x822D83D8; continue 'dispatch;
	}
	// 822D83A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D83A4: 419A0014  beq cr6, 0x822d83b8
	if ctx.cr[6].eq {
	pc = 0x822D83B8; continue 'dispatch;
	}
	// 822D83A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D83AC: 48ED085D  bl 0x831a8c08
	ctx.lr = 0x822D83B0;
	sub_831A8C08(ctx, base);
	// 822D83B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D83B4: 4BFE7EB5  bl 0x822c0268
	ctx.lr = 0x822D83B8;
	sub_822C0268(ctx, base);
	// 822D83B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822D83BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D83C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D83C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822D83C8: 816B2F7C  lwz r11, 0x2f7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12156 as u32) ) } as u64;
	// 822D83CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822D83D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D83D4: 4BFE7C2D  bl 0x822c0000
	ctx.lr = 0x822D83D8;
	sub_822C0000(ctx, base);
	// 822D83D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D83DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D83E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D83E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D83E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D83EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D83F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D83F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D83F8 size=64
    let mut pc: u32 = 0x822D83F8;
    'dispatch: loop {
        match pc {
            0x822D83F8 => {
    //   block [0x822D83F8..0x822D8438)
	// 822D83F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D83FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8404: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8408: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D840C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8410: 419A0014  beq cr6, 0x822d8424
	if ctx.cr[6].eq {
	pc = 0x822D8424; continue 'dispatch;
	}
	// 822D8414: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8418: 48ED07F1  bl 0x831a8c08
	ctx.lr = 0x822D841C;
	sub_831A8C08(ctx, base);
	// 822D841C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8420: 4BFE7E49  bl 0x822c0268
	ctx.lr = 0x822D8424;
	sub_822C0268(ctx, base);
	// 822D8424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D8428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D842C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8438 size=212
    let mut pc: u32 = 0x822D8438;
    'dispatch: loop {
        match pc {
            0x822D8438 => {
    //   block [0x822D8438..0x822D850C)
	// 822D8438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D843C: 48ECFD29  bl 0x831a8164
	ctx.lr = 0x822D8440;
	sub_831A8130(ctx, base);
	// 822D8440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8444: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8448: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D844C: 3B8BA1C8  addi r28, r11, -0x5e38
	ctx.r[28].s64 = ctx.r[11].s64 + -24120;
	// 822D8450: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D8454: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822D8458: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822D845C: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 822D8460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D8464: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 822D8468: 4BFE7F71  bl 0x822c03d8
	ctx.lr = 0x822D846C;
	sub_822C03D8(ctx, base);
	// 822D846C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8474: 41820010  beq 0x822d8484
	if ctx.cr[0].eq {
	pc = 0x822D8484; continue 'dispatch;
	}
	// 822D8478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D847C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8480: 48000008  b 0x822d8488
	pc = 0x822D8488; continue 'dispatch;
	// 822D8484: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822D8488: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D848C: 409A0010  bne cr6, 0x822d849c
	if !ctx.cr[6].eq {
	pc = 0x822D849C; continue 'dispatch;
	}
	// 822D8490: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8494: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D8498: 48000068  b 0x822d8500
	pc = 0x822D8500; continue 'dispatch;
	// 822D849C: 3D6003FF  lis r11, 0x3ff
	ctx.r[11].s64 = 67043328;
	// 822D84A0: 57A33032  slwi r3, r29, 6
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 822D84A4: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 822D84A8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D84AC: 40990008  ble cr6, 0x822d84b4
	if !ctx.cr[6].gt {
	pc = 0x822D84B4; continue 'dispatch;
	}
	// 822D84B0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822D84B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D84B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822D84BC: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 822D84C0: 4BFE7F19  bl 0x822c03d8
	ctx.lr = 0x822D84C4;
	sub_822C03D8(ctx, base);
	// 822D84C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D84C8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822D84CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822D84D0: 48ED0739  bl 0x831a8c08
	ctx.lr = 0x822D84D4;
	sub_831A8C08(ctx, base);
	// 822D84D4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822D84D8: 9B7F0008  stb r27, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u8 ) };
	// 822D84DC: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 822D84E0: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822D84E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D84E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D84EC: 4BFFFE4D  bl 0x822d8338
	ctx.lr = 0x822D84F0;
	sub_822D8338(ctx, base);
	// 822D84F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D84F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D84F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D84FC: 4BFE7B05  bl 0x822c0000
	ctx.lr = 0x822D8500;
	sub_822C0000(ctx, base);
	// 822D8500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D8504: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D8508: 48ECFCAC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8510 size=188
    let mut pc: u32 = 0x822D8510;
    'dispatch: loop {
        match pc {
            0x822D8510 => {
    //   block [0x822D8510..0x822D85CC)
	// 822D8510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D851C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8524: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D8528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D852C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822D8530: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D8534: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8538: 4BFE8401  bl 0x822c0938
	ctx.lr = 0x822D853C;
	sub_822C0938(ctx, base);
	// 822D853C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8540: 41820028  beq 0x822d8568
	if ctx.cr[0].eq {
	pc = 0x822D8568; continue 'dispatch;
	}
	// 822D8544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8548: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822D854C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822D8550: 392BA1B4  addi r9, r11, -0x5e4c
	ctx.r[9].s64 = ctx.r[11].s64 + -24140;
	// 822D8554: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D8558: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D855C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D8560: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D8564: 48000008  b 0x822d856c
	pc = 0x822D856C; continue 'dispatch;
	// 822D8568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D856C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8574: 409A003C  bne cr6, 0x822d85b0
	if !ctx.cr[6].eq {
	pc = 0x822D85B0; continue 'dispatch;
	}
	// 822D8578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D857C: 419A0014  beq cr6, 0x822d8590
	if ctx.cr[6].eq {
	pc = 0x822D8590; continue 'dispatch;
	}
	// 822D8580: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D8584: 48638025  bl 0x829105a8
	ctx.lr = 0x822D8588;
	sub_829105A8(ctx, base);
	// 822D8588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D858C: 4BFE7CDD  bl 0x822c0268
	ctx.lr = 0x822D8590;
	sub_822C0268(ctx, base);
	// 822D8590: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822D8594: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D8598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D859C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822D85A0: 816B2F7C  lwz r11, 0x2f7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12156 as u32) ) } as u64;
	// 822D85A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822D85A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D85AC: 4BFE7A55  bl 0x822c0000
	ctx.lr = 0x822D85B0;
	sub_822C0000(ctx, base);
	// 822D85B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D85B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D85B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D85BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D85C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D85C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D85C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D85D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D85D0 size=64
    let mut pc: u32 = 0x822D85D0;
    'dispatch: loop {
        match pc {
            0x822D85D0 => {
    //   block [0x822D85D0..0x822D8610)
	// 822D85D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D85D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D85D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D85DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D85E0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D85E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D85E8: 419A0014  beq cr6, 0x822d85fc
	if ctx.cr[6].eq {
	pc = 0x822D85FC; continue 'dispatch;
	}
	// 822D85EC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D85F0: 48637FB9  bl 0x829105a8
	ctx.lr = 0x822D85F4;
	sub_829105A8(ctx, base);
	// 822D85F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D85F8: 4BFE7C71  bl 0x822c0268
	ctx.lr = 0x822D85FC;
	sub_822C0268(ctx, base);
	// 822D85FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D8600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D860C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8610 size=184
    let mut pc: u32 = 0x822D8610;
    'dispatch: loop {
        match pc {
            0x822D8610 => {
    //   block [0x822D8610..0x822D86C8)
	// 822D8610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8614: 48ECFB59  bl 0x831a816c
	ctx.lr = 0x822D8618;
	sub_831A8130(ctx, base);
	// 822D8618: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D861C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8620: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D8624: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822D8628: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822D862C: 388BA1C8  addi r4, r11, -0x5e38
	ctx.r[4].s64 = ctx.r[11].s64 + -24120;
	// 822D8630: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 822D8634: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 822D8638: 4BFE7DA1  bl 0x822c03d8
	ctx.lr = 0x822D863C;
	sub_822C03D8(ctx, base);
	// 822D863C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8644: 41820024  beq 0x822d8668
	if ctx.cr[0].eq {
	pc = 0x822D8668; continue 'dispatch;
	}
	// 822D8648: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D864C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D8650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8654: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822D8658: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822D865C: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D8660: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822D8664: 48000008  b 0x822d866c
	pc = 0x822D866C; continue 'dispatch;
	// 822D8668: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822D866C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8670: 419A0044  beq cr6, 0x822d86b4
	if ctx.cr[6].eq {
	pc = 0x822D86B4; continue 'dispatch;
	}
	// 822D8674: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822D8678: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D867C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D8680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D8684: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822D8688: 4871A0D1  bl 0x829f2758
	ctx.lr = 0x822D868C;
	sub_829F2758(ctx, base);
	// 822D868C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822D8690: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 822D8694: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D8698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D869C: 4BFFFE75  bl 0x822d8510
	ctx.lr = 0x822D86A0;
	sub_822D8510(ctx, base);
	// 822D86A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D86A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D86A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D86AC: 4BFE7955  bl 0x822c0000
	ctx.lr = 0x822D86B0;
	sub_822C0000(ctx, base);
	// 822D86B0: 4800000C  b 0x822d86bc
	pc = 0x822D86BC; continue 'dispatch;
	// 822D86B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D86B8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D86BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D86C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D86C4: 48ECFAF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D86C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D86C8 size=12
    let mut pc: u32 = 0x822D86C8;
    'dispatch: loop {
        match pc {
            0x822D86C8 => {
    //   block [0x822D86C8..0x822D86D4)
	// 822D86C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D86CC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822D86D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D86D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D86D8 size=68
    let mut pc: u32 = 0x822D86D8;
    'dispatch: loop {
        match pc {
            0x822D86D8 => {
    //   block [0x822D86D8..0x822D871C)
	// 822D86D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D86DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D86E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D86E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D86E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D86EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D86F0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822D86F4: 396BA20C  addi r11, r11, -0x5df4
	ctx.r[11].s64 = ctx.r[11].s64 + -24052;
	// 822D86F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D86FC: 41820008  beq 0x822d8704
	if ctx.cr[0].eq {
	pc = 0x822D8704; continue 'dispatch;
	}
	// 822D8700: 4BFE7B69  bl 0x822c0268
	ctx.lr = 0x822D8704;
	sub_822C0268(ctx, base);
	// 822D8704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8708: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D870C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8720 size=72
    let mut pc: u32 = 0x822D8720;
    'dispatch: loop {
        match pc {
            0x822D8720 => {
    //   block [0x822D8720..0x822D8768)
	// 822D8720: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8724: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822D8728: 419A0020  beq cr6, 0x822d8748
	if ctx.cr[6].eq {
	pc = 0x822D8748; continue 'dispatch;
	}
	// 822D872C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822D8730: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8734: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822D8738: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D873C: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 822D8740: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 822D8744: 409AFFEC  bne cr6, 0x822d8730
	if !ctx.cr[6].eq {
	pc = 0x822D8730; continue 'dispatch;
	}
	// 822D8748: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D874C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8750: 419A000C  beq cr6, 0x822d875c
	if ctx.cr[6].eq {
	pc = 0x822D875C; continue 'dispatch;
	}
	// 822D8754: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8758: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D875C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8764: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8768 size=12
    let mut pc: u32 = 0x822D8768;
    'dispatch: loop {
        match pc {
            0x822D8768 => {
    //   block [0x822D8768..0x822D8774)
	// 822D8768: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D876C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D8770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8778 size=376
    let mut pc: u32 = 0x822D8778;
    'dispatch: loop {
        match pc {
            0x822D8778 => {
    //   block [0x822D8778..0x822D88F0)
	// 822D8778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D877C: 48ECF9F1  bl 0x831a816c
	ctx.lr = 0x822D8780;
	sub_831A8130(ctx, base);
	// 822D8780: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 822D8784: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 822D8788: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822D878C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8794: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 822D8798: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822D879C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D87A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822D87A4: 409A000C  bne cr6, 0x822d87b0
	if !ctx.cr[6].eq {
	pc = 0x822D87B0; continue 'dispatch;
	}
	// 822D87A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D87AC: 48000130  b 0x822d88dc
	pc = 0x822D88DC; continue 'dispatch;
	// 822D87B0: C3FF0020  lfs f31, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822D87B4: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D87B8: EFDFE82A  fadds f30, f31, f29
	ctx.f[30].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 822D87BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D87C0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D87C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822D87C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D87CC: 4E800421  bctrl
	ctx.lr = 0x822D87D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D87D0: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 822D87D4: 419A0028  beq cr6, 0x822d87fc
	if ctx.cr[6].eq {
	pc = 0x822D87FC; continue 'dispatch;
	}
	// 822D87D8: D03F0020  stfs f1, 0x20(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822D87DC: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D87E0: 38FF0050  addi r7, r31, 0x50
	ctx.r[7].s64 = ctx.r[31].s64 + 80;
	// 822D87E4: 38DF0040  addi r6, r31, 0x40
	ctx.r[6].s64 = ctx.r[31].s64 + 64;
	// 822D87E8: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 822D87EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D87F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D87F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D87F8: 4E800421  bctrl
	ctx.lr = 0x822D87FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D87FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822D8800: 419A00D8  beq cr6, 0x822d88d8
	if ctx.cr[6].eq {
	pc = 0x822D88D8; continue 'dispatch;
	}
	// 822D8804: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D8808: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822D880C: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822D8810: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D8814: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 822D8818: 40990064  ble cr6, 0x822d887c
	if !ctx.cr[6].gt {
	pc = 0x822D887C; continue 'dispatch;
	}
	// 822D881C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 822D8820: 409800B8  bge cr6, 0x822d88d8
	if !ctx.cr[6].lt {
	pc = 0x822D88D8; continue 'dispatch;
	}
	// 822D8824: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8828: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822D882C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822D8830: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D8834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8838: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D883C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8840: 4E800421  bctrl
	ctx.lr = 0x822D8844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8844: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D8848: 41820024  beq 0x822d886c
	if ctx.cr[0].eq {
	pc = 0x822D886C; continue 'dispatch;
	}
	// 822D884C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8850: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D8854: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D8858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D885C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D8860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8864: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8868: 4E800421  bctrl
	ctx.lr = 0x822D886C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D886C: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D8870: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 822D8874: 4198FFB0  blt cr6, 0x822d8824
	if ctx.cr[6].lt {
	pc = 0x822D8824; continue 'dispatch;
	}
	// 822D8878: 48000060  b 0x822d88d8
	pc = 0x822D88D8; continue 'dispatch;
	// 822D887C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 822D8880: 40990058  ble cr6, 0x822d88d8
	if !ctx.cr[6].gt {
	pc = 0x822D88D8; continue 'dispatch;
	}
	// 822D8884: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8888: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 822D888C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822D8890: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822D8894: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8898: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D889C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D88A0: 4E800421  bctrl
	ctx.lr = 0x822D88A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D88A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D88A8: 41820024  beq 0x822d88cc
	if ctx.cr[0].eq {
	pc = 0x822D88CC; continue 'dispatch;
	}
	// 822D88AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D88B0: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D88B4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822D88B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D88BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D88C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D88C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D88C8: 4E800421  bctrl
	ctx.lr = 0x822D88CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D88CC: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D88D0: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 822D88D4: 4199FFB0  bgt cr6, 0x822d8884
	if ctx.cr[6].gt {
	pc = 0x822D8884; continue 'dispatch;
	}
	// 822D88D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D88DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822D88E0: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822D88E4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822D88E8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822D88EC: 48ECF8D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D88F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D88F0 size=32
    let mut pc: u32 = 0x822D88F0;
    'dispatch: loop {
        match pc {
            0x822D88F0 => {
    //   block [0x822D88F0..0x822D8910)
	// 822D88F0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D88F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D88F8: 419A0018  beq cr6, 0x822d8910
	if ctx.cr[6].eq {
		sub_822D8910(ctx, base);
		return;
	}
	// 822D88FC: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8904: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D890C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8910 size=12
    let mut pc: u32 = 0x822D8910;
    'dispatch: loop {
        match pc {
            0x822D8910 => {
    //   block [0x822D8910..0x822D891C)
	// 822D8910: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D8914: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D8918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8920 size=24
    let mut pc: u32 = 0x822D8920;
    'dispatch: loop {
        match pc {
            0x822D8920 => {
    //   block [0x822D8920..0x822D8938)
	// 822D8920: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8924: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D892C: 409A000C  bne cr6, 0x822d8938
	if !ctx.cr[6].eq {
		sub_822D8938(ctx, base);
		return;
	}
	// 822D8930: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8938 size=20
    let mut pc: u32 = 0x822D8938;
    'dispatch: loop {
        match pc {
            0x822D8938 => {
    //   block [0x822D8938..0x822D894C)
	// 822D8938: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 822D893C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D8940: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8950 size=48
    let mut pc: u32 = 0x822D8950;
    'dispatch: loop {
        match pc {
            0x822D8950 => {
    //   block [0x822D8950..0x822D8980)
	// 822D8950: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8954: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822D8958: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 822D895C: 39000050  li r8, 0x50
	ctx.r[8].s64 = 80;
	// 822D8960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D8964: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8980 size=24
    let mut pc: u32 = 0x822D8980;
    'dispatch: loop {
        match pc {
            0x822D8980 => {
    //   block [0x822D8980..0x822D8998)
	// 822D8980: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8984: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8988: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D898C: 409A000C  bne cr6, 0x822d8998
	if !ctx.cr[6].eq {
		sub_822D8998(ctx, base);
		return;
	}
	// 822D8990: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8998 size=20
    let mut pc: u32 = 0x822D8998;
    'dispatch: loop {
        match pc {
            0x822D8998 => {
    //   block [0x822D8998..0x822D89AC)
	// 822D8998: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 822D899C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D89A0: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D89B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D89B0 size=64
    let mut pc: u32 = 0x822D89B0;
    'dispatch: loop {
        match pc {
            0x822D89B0 => {
    //   block [0x822D89B0..0x822D89F0)
	// 822D89B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D89B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D89B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D89BC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D89C0: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 822D89C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822D89C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D89CC: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D89D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D89D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D89D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D89DC: 4E800421  bctrl
	ctx.lr = 0x822D89E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D89E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D89E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D89E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D89EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D89F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D89F0 size=24
    let mut pc: u32 = 0x822D89F0;
    'dispatch: loop {
        match pc {
            0x822D89F0 => {
    //   block [0x822D89F0..0x822D8A08)
	// 822D89F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D89F4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D89F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D89FC: 409A000C  bne cr6, 0x822d8a08
	if !ctx.cr[6].eq {
		sub_822D8A08(ctx, base);
		return;
	}
	// 822D8A00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8A08 size=20
    let mut pc: u32 = 0x822D8A08;
    'dispatch: loop {
        match pc {
            0x822D8A08 => {
    //   block [0x822D8A08..0x822D8A1C)
	// 822D8A08: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822D8A0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D8A10: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8A20 size=136
    let mut pc: u32 = 0x822D8A20;
    'dispatch: loop {
        match pc {
            0x822D8A20 => {
    //   block [0x822D8A20..0x822D8AA8)
	// 822D8A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8A28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8A2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8A30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8A34: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8A3C: 409A000C  bne cr6, 0x822d8a48
	if !ctx.cr[6].eq {
	pc = 0x822D8A48; continue 'dispatch;
	}
	// 822D8A40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D8A44: 48000050  b 0x822d8a94
	pc = 0x822D8A94; continue 'dispatch;
	// 822D8A48: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8A4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8A50: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D8A54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8A58: 4E800421  bctrl
	ctx.lr = 0x822D8A5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8A5C: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D8A60: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 822D8A64: 419A002C  beq cr6, 0x822d8a90
	if ctx.cr[6].eq {
	pc = 0x822D8A90; continue 'dispatch;
	}
	// 822D8A68: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8A6C: D03F0020  stfs f1, 0x20(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822D8A70: 38FF0050  addi r7, r31, 0x50
	ctx.r[7].s64 = ctx.r[31].s64 + 80;
	// 822D8A74: 38DF0040  addi r6, r31, 0x40
	ctx.r[6].s64 = ctx.r[31].s64 + 64;
	// 822D8A78: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 822D8A7C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8A80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8A84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8A88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8A8C: 4E800421  bctrl
	ctx.lr = 0x822D8A90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8A90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D8A94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D8A98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8A9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D8AA8 size=28
    let mut pc: u32 = 0x822D8AA8;
    'dispatch: loop {
        match pc {
            0x822D8AA8 => {
    //   block [0x822D8AA8..0x822D8AC4)
	// 822D8AA8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8AAC: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D8AB0: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8AB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8AB8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822D8ABC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8AC0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8AC8 size=24
    let mut pc: u32 = 0x822D8AC8;
    'dispatch: loop {
        match pc {
            0x822D8AC8 => {
    //   block [0x822D8AC8..0x822D8AE0)
	// 822D8AC8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8ACC: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8AD4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822D8AD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8ADC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8AE0 size=24
    let mut pc: u32 = 0x822D8AE0;
    'dispatch: loop {
        match pc {
            0x822D8AE0 => {
    //   block [0x822D8AE0..0x822D8AF8)
	// 822D8AE0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8AE4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8AE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8AEC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D8AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8AF4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8AF8 size=60
    let mut pc: u32 = 0x822D8AF8;
    'dispatch: loop {
        match pc {
            0x822D8AF8 => {
    //   block [0x822D8AF8..0x822D8B34)
	// 822D8AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8B04: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B08: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822D8B0C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822D8B10: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8B18: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8B1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8B20: 4E800421  bctrl
	ctx.lr = 0x822D8B24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8B24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D8B28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8B2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8B38 size=24
    let mut pc: u32 = 0x822D8B38;
    'dispatch: loop {
        match pc {
            0x822D8B38 => {
    //   block [0x822D8B38..0x822D8B50)
	// 822D8B38: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B3C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8B44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8B4C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8B50 size=24
    let mut pc: u32 = 0x822D8B50;
    'dispatch: loop {
        match pc {
            0x822D8B50 => {
    //   block [0x822D8B50..0x822D8B68)
	// 822D8B50: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B54: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8B5C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8B64: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8B68 size=64
    let mut pc: u32 = 0x822D8B68;
    'dispatch: loop {
        match pc {
            0x822D8B68 => {
    //   block [0x822D8B68..0x822D8BA8)
	// 822D8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8B70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8B74: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B78: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822D8B7C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 822D8B80: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822D8B84: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8B88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8B8C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8B94: 4E800421  bctrl
	ctx.lr = 0x822D8B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822D8B9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8BA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8BA8 size=112
    let mut pc: u32 = 0x822D8BA8;
    'dispatch: loop {
        match pc {
            0x822D8BA8 => {
    //   block [0x822D8BA8..0x822D8C18)
	// 822D8BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8BB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8BB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8BBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8BC0: 396BA238  addi r11, r11, -0x5dc8
	ctx.r[11].s64 = ctx.r[11].s64 + -24008;
	// 822D8BC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8BC8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8BD0: 419A000C  beq cr6, 0x822d8bdc
	if ctx.cr[6].eq {
	pc = 0x822D8BDC; continue 'dispatch;
	}
	// 822D8BD4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D8BD8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D8BDC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D8BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8BE4: 419A000C  beq cr6, 0x822d8bf0
	if ctx.cr[6].eq {
	pc = 0x822D8BF0; continue 'dispatch;
	}
	// 822D8BE8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8BEC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D8BF0: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D8BF4: 4182000C  beq 0x822d8c00
	if ctx.cr[0].eq {
	pc = 0x822D8C00; continue 'dispatch;
	}
	// 822D8BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8BFC: 4BFE766D  bl 0x822c0268
	ctx.lr = 0x822D8C00;
	sub_822C0268(ctx, base);
	// 822D8C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8C04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D8C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8C10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8C14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8C18 size=176
    let mut pc: u32 = 0x822D8C18;
    'dispatch: loop {
        match pc {
            0x822D8C18 => {
    //   block [0x822D8C18..0x822D8CC8)
	// 822D8C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D8C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8C2C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8C34: 419A0078  beq cr6, 0x822d8cac
	if ctx.cr[6].eq {
	pc = 0x822D8CAC; continue 'dispatch;
	}
	// 822D8C38: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8C3C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8C40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8C44: 419A0024  beq cr6, 0x822d8c68
	if ctx.cr[6].eq {
	pc = 0x822D8C68; continue 'dispatch;
	}
	// 822D8C48: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822D8C4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D8C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8C54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D8C58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D8C5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D8C60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8C64: 4082FFE8  bne 0x822d8c4c
	if !ctx.cr[0].eq {
	pc = 0x822D8C4C; continue 'dispatch;
	}
	// 822D8C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D8C6C: 419A0030  beq cr6, 0x822d8c9c
	if ctx.cr[6].eq {
	pc = 0x822D8C9C; continue 'dispatch;
	}
	// 822D8C70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8C74: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 822D8C78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8C7C: 4E800421  bctrl
	ctx.lr = 0x822D8C80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8C80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D8C84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8C88: 419A000C  beq cr6, 0x822d8c94
	if ctx.cr[6].eq {
	pc = 0x822D8C94; continue 'dispatch;
	}
	// 822D8C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8C90: 4BFE7C01  bl 0x822c0890
	ctx.lr = 0x822D8C94;
	sub_822C0890(ctx, base);
	// 822D8C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D8C98: 48000018  b 0x822d8cb0
	pc = 0x822D8CB0; continue 'dispatch;
	// 822D8C9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8CA0: 419A000C  beq cr6, 0x822d8cac
	if ctx.cr[6].eq {
	pc = 0x822D8CAC; continue 'dispatch;
	}
	// 822D8CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8CA8: 4BFE7BE9  bl 0x822c0890
	ctx.lr = 0x822D8CAC;
	sub_822C0890(ctx, base);
	// 822D8CAC: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 822D8CB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D8CB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8CB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8CBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D8CC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8CC8 size=52
    let mut pc: u32 = 0x822D8CC8;
    'dispatch: loop {
        match pc {
            0x822D8CC8 => {
    //   block [0x822D8CC8..0x822D8CFC)
	// 822D8CC8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D8CCC: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822D8CD0: 392AA254  addi r9, r10, -0x5dac
	ctx.r[9].s64 = ctx.r[10].s64 + -23980;
	// 822D8CD4: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 822D8CD8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D8CDC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D8CE0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D8CE4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8CE8: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822D8CEC: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8CF4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822D8CF8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8CFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D8CFC size=36
    let mut pc: u32 = 0x822D8CFC;
    'dispatch: loop {
        match pc {
            0x822D8CFC => {
    //   block [0x822D8CFC..0x822D8D20)
	// 822D8CFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822D8D00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822D8D04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8D08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822D8D0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822D8D10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D8D14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8D18: 4082FFE8  bne 0x822d8d00
	if !ctx.cr[0].eq {
	pc = 0x822D8D00; continue 'dispatch;
	}
	// 822D8D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8D20 size=100
    let mut pc: u32 = 0x822D8D20;
    'dispatch: loop {
        match pc {
            0x822D8D20 => {
    //   block [0x822D8D20..0x822D8D84)
	// 822D8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8D24: 48ECF449  bl 0x831a816c
	ctx.lr = 0x822D8D28;
	sub_831A8130(ctx, base);
	// 822D8D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8D30: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D8D34: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 822D8D38: 394AA254  addi r10, r10, -0x5dac
	ctx.r[10].s64 = ctx.r[10].s64 + -23980;
	// 822D8D3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D8D40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822D8D44: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D8D48: 419A001C  beq cr6, 0x822d8d64
	if ctx.cr[6].eq {
	pc = 0x822D8D64; continue 'dispatch;
	}
	// 822D8D4C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D8D50: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D8D54: 4BFFF975  bl 0x822d86c8
	ctx.lr = 0x822D8D58;
	sub_822D86C8(ctx, base);
	// 822D8D58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822D8D5C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822D8D60: 409AFFEC  bne cr6, 0x822d8d4c
	if !ctx.cr[6].eq {
	pc = 0x822D8D4C; continue 'dispatch;
	}
	// 822D8D64: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8D68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822D8D6C: 419A0008  beq cr6, 0x822d8d74
	if ctx.cr[6].eq {
	pc = 0x822D8D74; continue 'dispatch;
	}
	// 822D8D70: 4BFE7B21  bl 0x822c0890
	ctx.lr = 0x822D8D74;
	sub_822C0890(ctx, base);
	// 822D8D74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D8D78: 4BFFF9A9  bl 0x822d8720
	ctx.lr = 0x822D8D7C;
	sub_822D8720(ctx, base);
	// 822D8D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D8D80: 48ECF43C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8D88 size=196
    let mut pc: u32 = 0x822D8D88;
    'dispatch: loop {
        match pc {
            0x822D8D88 => {
    //   block [0x822D8D88..0x822D8E4C)
	// 822D8D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D8D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8D9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D8DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8DA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822D8DA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D8DAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8DB0: 4BFE7B89  bl 0x822c0938
	ctx.lr = 0x822D8DB4;
	sub_822C0938(ctx, base);
	// 822D8DB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8DB8: 41820028  beq 0x822d8de0
	if ctx.cr[0].eq {
	pc = 0x822D8DE0; continue 'dispatch;
	}
	// 822D8DBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8DC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822D8DC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822D8DC8: 392BA240  addi r9, r11, -0x5dc0
	ctx.r[9].s64 = ctx.r[11].s64 + -24000;
	// 822D8DCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822D8DD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8DD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D8DD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822D8DDC: 48000008  b 0x822d8de4
	pc = 0x822D8DE4; continue 'dispatch;
	// 822D8DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8DE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D8DEC: 409A0044  bne cr6, 0x822d8e30
	if !ctx.cr[6].eq {
	pc = 0x822D8E30; continue 'dispatch;
	}
	// 822D8DF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8DF4: 419A001C  beq cr6, 0x822d8e10
	if ctx.cr[6].eq {
	pc = 0x822D8E10; continue 'dispatch;
	}
	// 822D8DF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8DFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822D8E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8E04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8E08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8E0C: 4E800421  bctrl
	ctx.lr = 0x822D8E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8E10: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822D8E14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D8E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D8E1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822D8E20: 816B3018  lwz r11, 0x3018(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12312 as u32) ) } as u64;
	// 822D8E24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822D8E28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D8E2C: 4BFE71D5  bl 0x822c0000
	ctx.lr = 0x822D8E30;
	sub_822C0000(ctx, base);
	// 822D8E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D8E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D8E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8E40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D8E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8E50 size=148
    let mut pc: u32 = 0x822D8E50;
    'dispatch: loop {
        match pc {
            0x822D8E50 => {
    //   block [0x822D8E50..0x822D8EE4)
	// 822D8E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8E5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8E60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D8E64: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8E68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822D8E6C: 419A0064  beq cr6, 0x822d8ed0
	if ctx.cr[6].eq {
	pc = 0x822D8ED0; continue 'dispatch;
	}
	// 822D8E70: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D8E74: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822D8E78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8E7C: 419A0024  beq cr6, 0x822d8ea0
	if ctx.cr[6].eq {
	pc = 0x822D8EA0; continue 'dispatch;
	}
	// 822D8E80: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 822D8E84: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 822D8E88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8E8C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 822D8E90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822D8E94: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822D8E98: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822D8E9C: 4082FFE8  bne 0x822d8e84
	if !ctx.cr[0].eq {
	pc = 0x822D8E84; continue 'dispatch;
	}
	// 822D8EA0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D8EA4: C02B0020  lfs f1, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D8EA8: 38EB0050  addi r7, r11, 0x50
	ctx.r[7].s64 = ctx.r[11].s64 + 80;
	// 822D8EAC: 38CB0040  addi r6, r11, 0x40
	ctx.r[6].s64 = ctx.r[11].s64 + 64;
	// 822D8EB0: 38AB0030  addi r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 + 48;
	// 822D8EB4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D8EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D8EBC: 4E800421  bctrl
	ctx.lr = 0x822D8EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D8EC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8EC4: 419A000C  beq cr6, 0x822d8ed0
	if ctx.cr[6].eq {
	pc = 0x822D8ED0; continue 'dispatch;
	}
	// 822D8EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8ECC: 4BFE79C5  bl 0x822c0890
	ctx.lr = 0x822D8ED0;
	sub_822C0890(ctx, base);
	// 822D8ED0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D8ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D8EE8 size=76
    let mut pc: u32 = 0x822D8EE8;
    'dispatch: loop {
        match pc {
            0x822D8EE8 => {
    //   block [0x822D8EE8..0x822D8F34)
	// 822D8EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D8EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D8EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D8EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8F00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D8F04: 4BFFFE1D  bl 0x822d8d20
	ctx.lr = 0x822D8F08;
	sub_822D8D20(ctx, base);
	// 822D8F08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D8F0C: 4182000C  beq 0x822d8f18
	if ctx.cr[0].eq {
	pc = 0x822D8F18; continue 'dispatch;
	}
	// 822D8F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8F14: 4BFE7355  bl 0x822c0268
	ctx.lr = 0x822D8F18;
	sub_822C0268(ctx, base);
	// 822D8F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D8F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D8F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D8F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D8F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D8F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D8F38 size=220
    let mut pc: u32 = 0x822D8F38;
    'dispatch: loop {
        match pc {
            0x822D8F38 => {
    //   block [0x822D8F38..0x822D9014)
	// 822D8F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D8F3C: 48ECF231  bl 0x831a816c
	ctx.lr = 0x822D8F40;
	sub_831A8130(ctx, base);
	// 822D8F40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D8F44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8F48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822D8F4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822D8F50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822D8F54: 388BA258  addi r4, r11, -0x5da8
	ctx.r[4].s64 = ctx.r[11].s64 + -23976;
	// 822D8F58: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 822D8F5C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 822D8F60: 4BFE7479  bl 0x822c03d8
	ctx.lr = 0x822D8F64;
	sub_822C03D8(ctx, base);
	// 822D8F64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822D8F68: 41820034  beq 0x822d8f9c
	if ctx.cr[0].eq {
	pc = 0x822D8F9C; continue 'dispatch;
	}
	// 822D8F6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D8F70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D8F74: 392BA238  addi r9, r11, -0x5dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -24008;
	// 822D8F78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8F7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822D8F80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D8F84: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822D8F88: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D8F8C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822D8F90: 9063001C  stw r3, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 822D8F94: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822D8F98: 4800000C  b 0x822d8fa4
	pc = 0x822D8FA4; continue 'dispatch;
	// 822D8F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D8FA0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822D8FA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822D8FA8: 409A0010  bne cr6, 0x822d8fb8
	if !ctx.cr[6].eq {
	pc = 0x822D8FB8; continue 'dispatch;
	}
	// 822D8FAC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8FB0: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822D8FB4: 48000054  b 0x822d9008
	pc = 0x822D9008; continue 'dispatch;
	// 822D8FB8: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 822D8FBC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 822D8FC0: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 822D8FC4: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822D8FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D8FCC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D8FD0: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 822D8FD4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D8FD8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D8FDC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822D8FE0: 4BFFFE71  bl 0x822d8e50
	ctx.lr = 0x822D8FE4;
	sub_822D8E50(ctx, base);
	// 822D8FE4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822D8FE8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822D8FEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D8FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D8FF4: 4BFFFD95  bl 0x822d8d88
	ctx.lr = 0x822D8FF8;
	sub_822D8D88(ctx, base);
	// 822D8FF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822D8FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D9000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D9004: 4BFE6FFD  bl 0x822c0000
	ctx.lr = 0x822D9008;
	sub_822C0000(ctx, base);
	// 822D9008: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822D900C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D9010: 48ECF1AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D9018 size=44
    let mut pc: u32 = 0x822D9018;
    'dispatch: loop {
        match pc {
            0x822D9018 => {
    //   block [0x822D9018..0x822D9044)
	// 822D9018: 81430070  lwz r10, 0x70(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 822D901C: 1D6A0030  mulli r11, r10, 0x30
	ctx.r[11].s64 = ctx.r[10].s64 * 48;
	// 822D9020: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 822D9024: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9028: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D902C: 41980018  blt cr6, 0x822d9044
	if ctx.cr[6].lt {
		sub_822D9044(ctx, base);
		return;
	}
	// 822D9030: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9034: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D9038: 4098000C  bge cr6, 0x822d9044
	if !ctx.cr[6].lt {
		sub_822D9044(ctx, base);
		return;
	}
	// 822D903C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822D9040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9044(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D9044 size=48
    let mut pc: u32 = 0x822D9044;
    'dispatch: loop {
        match pc {
            0x822D9044 => {
    //   block [0x822D9044..0x822D9074)
	// 822D9044: 39460001  addi r10, r6, 1
	ctx.r[10].s64 = ctx.r[6].s64 + 1;
	// 822D9048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822D904C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822D9050: 40990034  ble cr6, 0x822d9084
	if !ctx.cr[6].gt {
		sub_822D9074(ctx, base);
		return;
	}
	// 822D9054: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D9058: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822D905C: 1D090030  mulli r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 * 48;
	// 822D9060: 7C082C2E  lfsx f0, r8, r5
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9064: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D9068: 4198000C  blt cr6, 0x822d9074
	if ctx.cr[6].lt {
		sub_822D9074(ctx, base);
		return;
	}
	// 822D906C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822D9070: 48000008  b 0x822d9078
	sub_822D9074(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9074(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D9074 size=28
    let mut pc: u32 = 0x822D9074;
    'dispatch: loop {
        match pc {
            0x822D9074 => {
    //   block [0x822D9074..0x822D9090)
	// 822D9074: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822D9078: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822D907C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 822D9080: 4199FFD4  bgt cr6, 0x822d9054
	if ctx.cr[6].gt {
		sub_822D9044(ctx, base);
		return;
	}
	// 822D9084: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822D9088: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822D908C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D9090 size=20
    let mut pc: u32 = 0x822D9090;
    'dispatch: loop {
        match pc {
            0x822D9090 => {
    //   block [0x822D9090..0x822D90A4)
	// 822D9090: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D9094: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822D9098: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822D909C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822D90A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D90A8 size=32
    let mut pc: u32 = 0x822D90A8;
    'dispatch: loop {
        match pc {
            0x822D90A8 => {
    //   block [0x822D90A8..0x822D90C8)
	// 822D90A8: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 822D90AC: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D90B0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D90C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D90C8 size=96
    let mut pc: u32 = 0x822D90C8;
    'dispatch: loop {
        match pc {
            0x822D90C8 => {
    //   block [0x822D90C8..0x822D9128)
	// 822D90C8: C001FFF4  lfs f0, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D90CC: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D90D0: C181FFF0  lfs f12, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D90D4: C161FFF8  lfs f11, -8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822D90D8: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822D90DC: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822D90E0: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822D90E4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822D90E8: D1630010  stfs f11, 0x10(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822D90EC: C0040020  lfs f0, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D90F0: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 822D90F4: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D90F8: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822D90FC: C0040028  lfs f0, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9100: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822D9104: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9108: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 822D910C: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9110: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822D9114: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9118: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 822D911C: C004002C  lfs f0, 0x2c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9120: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822D9124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D9128 size=144
    let mut pc: u32 = 0x822D9128;
    'dispatch: loop {
        match pc {
            0x822D9128 => {
    //   block [0x822D9128..0x822D91B8)
	// 822D9128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D912C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D9130: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 822D9134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9138: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822D913C: C3E30010  lfs f31, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822D9140: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D9144: 41980034  blt cr6, 0x822d9178
	if ctx.cr[6].lt {
	pc = 0x822D9178; continue 'dispatch;
	}
	// 822D9148: 419A0010  beq cr6, 0x822d9158
	if ctx.cr[6].eq {
	pc = 0x822D9158; continue 'dispatch;
	}
	// 822D914C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D9150: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D9154: 48000050  b 0x822d91a4
	pc = 0x822D91A4; continue 'dispatch;
	// 822D9158: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822D915C: 4099000C  ble cr6, 0x822d9168
	if !ctx.cr[6].gt {
	pc = 0x822D9168; continue 'dispatch;
	}
	// 822D9160: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822D9164: 48000040  b 0x822d91a4
	pc = 0x822D91A4; continue 'dispatch;
	// 822D9168: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D916C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9170: FC21006E  fsel f1, f1, f1, f0
	ctx.f[1].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[0].f64 };
	// 822D9174: 48000030  b 0x822d91a4
	pc = 0x822D91A4; continue 'dispatch;
	// 822D9178: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D917C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 822D9180: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9184: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 822D9188: 40990010  ble cr6, 0x822d9198
	if !ctx.cr[6].gt {
	pc = 0x822D9198; continue 'dispatch;
	}
	// 822D918C: 48ED1685  bl 0x831aa810
	ctx.lr = 0x822D9190;
	sub_831AA810(ctx, base);
	// 822D9190: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822D9194: 48000010  b 0x822d91a4
	pc = 0x822D91A4; continue 'dispatch;
	// 822D9198: 48ED1679  bl 0x831aa810
	ctx.lr = 0x822D919C;
	sub_831AA810(ctx, base);
	// 822D919C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 822D91A0: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 822D91A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D91A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D91AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D91B0: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D91B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D91B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D91B8 size=180
    let mut pc: u32 = 0x822D91B8;
    'dispatch: loop {
        match pc {
            0x822D91B8 => {
    //   block [0x822D91B8..0x822D926C)
	// 822D91B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D91BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D91C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D91C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D91C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D91CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D91D4: 409A0010  bne cr6, 0x822d91e4
	if !ctx.cr[6].eq {
	pc = 0x822D91E4; continue 'dispatch;
	}
	// 822D91D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D91DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D91E0: 48000078  b 0x822d9258
	pc = 0x822D9258; continue 'dispatch;
	// 822D91E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D91E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D91EC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D91F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D91F4: 4E800421  bctrl
	ctx.lr = 0x822D91F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D91F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D91FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D9200: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D9204: 38CBFFFE  addi r6, r11, -2
	ctx.r[6].s64 = ctx.r[11].s64 + -2;
	// 822D9208: 4BFFFE11  bl 0x822d9018
	ctx.lr = 0x822D920C;
	sub_822D9018(ctx, base);
	// 822D920C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D9210: 1D430030  mulli r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 * 48;
	// 822D9214: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D9218: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D921C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822D9220: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9224: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D9228: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822D922C: C18A9F7C  lfs f12, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D9230: C16908A4  lfs f11, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822D9234: FD406A10  fabs f10, f13
	ctx.f[10].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 822D9238: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 822D923C: 4099000C  ble cr6, 0x822d9248
	if !ctx.cr[6].gt {
	pc = 0x822D9248; continue 'dispatch;
	}
	// 822D9240: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822D9244: ED606824  fdivs f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822D9248: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D924C: C1AB005C  lfs f13, 0x5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D9250: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822D9254: EC2D02FA  fmadds f1, f13, f11, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 822D9258: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D925C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D9260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D9264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D9268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D9270 size=340
    let mut pc: u32 = 0x822D9270;
    'dispatch: loop {
        match pc {
            0x822D9270 => {
    //   block [0x822D9270..0x822D93C4)
	// 822D9270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9274: 48ECEEF5  bl 0x831a8168
	ctx.lr = 0x822D9278;
	sub_831A8130(ctx, base);
	// 822D9278: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822D927C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D9284: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D9288: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822D928C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 822D9290: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D9294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D9298: 409A000C  bne cr6, 0x822d92a4
	if !ctx.cr[6].eq {
	pc = 0x822D92A4; continue 'dispatch;
	}
	// 822D929C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D92A0: 48000118  b 0x822d93b8
	pc = 0x822D93B8; continue 'dispatch;
	// 822D92A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D92A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D92AC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D92B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D92B4: 4E800421  bctrl
	ctx.lr = 0x822D92B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D92B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D92BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D92C0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D92C4: 38CBFFFE  addi r6, r11, -2
	ctx.r[6].s64 = ctx.r[11].s64 + -2;
	// 822D92C8: 4BFFFD51  bl 0x822d9018
	ctx.lr = 0x822D92CC;
	sub_822D9018(ctx, base);
	// 822D92CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D92D0: 1D430030  mulli r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 * 48;
	// 822D92D4: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D92D8: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D92DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D92E0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822D92E4: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D92E8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822D92EC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822D92F0: C18A9F7C  lfs f12, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D92F4: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 822D92F8: FD406A10  fabs f10, f13
	ctx.f[10].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 822D92FC: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 822D9300: 4099000C  ble cr6, 0x822d930c
	if !ctx.cr[6].gt {
	pc = 0x822D930C; continue 'dispatch;
	}
	// 822D9304: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822D9308: ED606824  fdivs f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822D930C: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9310: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822D9314: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D9318: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822D931C: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D9320: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822D9324: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822D9328: FC205890  fmr f1, f11
	ctx.f[1].f64 = ctx.f[11].f64;
	// 822D932C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822D9330: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 822D9334: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 822D9338: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D933C: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822D9340: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822D9344: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 822D9348: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 822D934C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 822D9350: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 822D9354: 48BA42ED  bl 0x82e7d640
	ctx.lr = 0x822D9358;
	sub_82E7D640(ctx, base);
	// 822D9358: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D935C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 822D9360: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822D9364: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 822D9368: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822D936C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D9370: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D93C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D93C8 size=68
    let mut pc: u32 = 0x822D93C8;
    'dispatch: loop {
        match pc {
            0x822D93C8 => {
    //   block [0x822D93C8..0x822D940C)
	// 822D93C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D93CC: 48ECEDA1  bl 0x831a816c
	ctx.lr = 0x822D93D0;
	sub_831A8130(ctx, base);
	// 822D93D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D93D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D93D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D93DC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D93E0: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D93E4: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 822D93E8: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 822D93EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D93F0: 4E800421  bctrl
	ctx.lr = 0x822D93F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822D93F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822D93F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822D93FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822D9400: 4BFFFC19  bl 0x822d9018
	ctx.lr = 0x822D9404;
	sub_822D9018(ctx, base);
	// 822D9404: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822D9408: 48ECEDB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D9410 size=28
    let mut pc: u32 = 0x822D9410;
    'dispatch: loop {
        match pc {
            0x822D9410 => {
    //   block [0x822D9410..0x822D942C)
	// 822D9410: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D9414: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822D9418: 41980014  blt cr6, 0x822d942c
	if ctx.cr[6].lt {
		sub_822D942C(ctx, base);
		return;
	}
	// 822D941C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9420: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D9424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822D9428: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D942C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D942C size=16
    let mut pc: u32 = 0x822D942C;
    'dispatch: loop {
        match pc {
            0x822D942C => {
    //   block [0x822D942C..0x822D943C)
	// 822D942C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D9430: 1D440030  mulli r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 * 48;
	// 822D9434: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D9438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D9440 size=80
    let mut pc: u32 = 0x822D9440;
    'dispatch: loop {
        match pc {
            0x822D9440 => {
    //   block [0x822D9440..0x822D9490)
	// 822D9440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D9448: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D944C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D9450: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 822D9454: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D9458: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822D945C: 4198000C  blt cr6, 0x822d9468
	if ctx.cr[6].lt {
	pc = 0x822D9468; continue 'dispatch;
	}
	// 822D9460: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D9464: 4800001C  b 0x822d9480
	pc = 0x822D9480; continue 'dispatch;
	// 822D9468: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D946C: 1D640030  mulli r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 * 48;
	// 822D9470: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822D9474: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822D9478: 48ECF099  bl 0x831a8510
	ctx.lr = 0x822D947C;
	sub_831A8510(ctx, base);
	// 822D947C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D9480: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D9484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D9488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D948C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D9490 size=56
    let mut pc: u32 = 0x822D9490;
    'dispatch: loop {
        match pc {
            0x822D9490 => {
    //   block [0x822D9490..0x822D94C8)
	// 822D9490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D9498: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D949C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822D94A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822D94A4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822D94A8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D94AC: 1CAA0030  mulli r5, r10, 0x30
	ctx.r[5].s64 = ctx.r[10].s64 * 48;
	// 822D94B0: 48ECF061  bl 0x831a8510
	ctx.lr = 0x822D94B4;
	sub_831A8510(ctx, base);
	// 822D94B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822D94B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822D94BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D94C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D94C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D94C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D94C8 size=8
    let mut pc: u32 = 0x822D94C8;
    'dispatch: loop {
        match pc {
            0x822D94C8 => {
    //   block [0x822D94C8..0x822D94D0)
	// 822D94C8: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 822D94CC: 4BFFA884  b 0x822d3d50
	sub_822D3D50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D94D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822D94D0 size=80
    let mut pc: u32 = 0x822D94D0;
    'dispatch: loop {
        match pc {
            0x822D94D0 => {
    //   block [0x822D94D0..0x822D9520)
	// 822D94D0: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822D9520 size=84
    let mut pc: u32 = 0x822D9520;
    'dispatch: loop {
        match pc {
            0x822D9520 => {
    //   block [0x822D9520..0x822D9574)
	// 822D9520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822D9528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822D952C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822D9530: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9534: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822D9538: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D953C: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 822D9540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822D9544: 48BA29E5  bl 0x82e7bf28
	ctx.lr = 0x822D9548;
	sub_82E7BF28(ctx, base);
	// 822D9548: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822D954C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D9550: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 822D9554: 4BFEB3AD  bl 0x822c4900
	ctx.lr = 0x822D9558;
	sub_822C4900(ctx, base);
	// 822D9558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D955C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822D9560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822D9564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822D9568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822D956C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822D9570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D9578 size=20
    let mut pc: u32 = 0x822D9578;
    'dispatch: loop {
        match pc {
            0x822D9578 => {
    //   block [0x822D9578..0x822D958C)
	// 822D9578: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822D957C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822D9580: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D9584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822D9588: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D958C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D958C size=76
    let mut pc: u32 = 0x822D958C;
    'dispatch: loop {
        match pc {
            0x822D958C => {
    //   block [0x822D958C..0x822D95D8)
	// 822D958C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822D9590: 40990040  ble cr6, 0x822d95d0
	if !ctx.cr[6].gt {
	pc = 0x822D95D0; continue 'dispatch;
	}
	// 822D9594: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9598: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822D959C: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 822D95A0: 812AFFC0  lwz r9, -0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-64 as u32) ) } as u64;
	// 822D95A4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822D95A8: 409A0014  bne cr6, 0x822d95bc
	if !ctx.cr[6].eq {
	pc = 0x822D95BC; continue 'dispatch;
	}
	// 822D95AC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D95B0: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822D95B4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822D95B8: 419A0008  beq cr6, 0x822d95c0
	if ctx.cr[6].eq {
	pc = 0x822D95C0; continue 'dispatch;
	}
	// 822D95BC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 822D95C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822D95C4: 7C691A14  add r3, r9, r3
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 822D95C8: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 822D95CC: 4082FFD4  bne 0x822d95a0
	if !ctx.cr[0].eq {
	pc = 0x822D95A0; continue 'dispatch;
	}
	// 822D95D0: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 822D95D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D95D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D95D8 size=904
    let mut pc: u32 = 0x822D95D8;
    'dispatch: loop {
        match pc {
            0x822D95D8 => {
    //   block [0x822D95D8..0x822D9960)
	// 822D95D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D95DC: 48ECEB85  bl 0x831a8160
	ctx.lr = 0x822D95E0;
	sub_831A8130(ctx, base);
	// 822D95E0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 822D95E4: 48ECF495  bl 0x831a8a78
	ctx.lr = 0x822D95E8;
	sub_831A8A40(ctx, base);
	// 822D95E8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D9960 size=444
    let mut pc: u32 = 0x822D9960;
    'dispatch: loop {
        match pc {
            0x822D9960 => {
    //   block [0x822D9960..0x822D9B1C)
	// 822D9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9964: 48ECE7F1  bl 0x831a8154
	ctx.lr = 0x822D9968;
	sub_831A8130(ctx, base);
	// 822D9968: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 822D996C: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 822D9970: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822D9974: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9978: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 822D997C: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 822D9980: 78A90020  clrldi r9, r5, 0x20
	ctx.r[9].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 822D9984: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822D9988: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 822D998C: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822D9990: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9994: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822D9998: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 822D999C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822D99A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822D99A4: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 822D99A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822D99AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D99B0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822D99B4: 54A83032  slwi r8, r5, 6
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 822D99B8: 54CA3032  slwi r10, r6, 6
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822D99BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822D99C0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822D99C4: 7D28582E  lwzx r9, r8, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822D99C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822D99CC: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822D99D0: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822D99D4: 409A0068  bne cr6, 0x822d9a3c
	if !ctx.cr[6].eq {
	pc = 0x822D9A3C; continue 'dispatch;
	}
	// 822D99D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D99DC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 822D99E0: 409A005C  bne cr6, 0x822d9a3c
	if !ctx.cr[6].eq {
	pc = 0x822D9A3C; continue 'dispatch;
	}
	// 822D99E4: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 822D99E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D99EC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822D99F0: 48BA22D9  bl 0x82e7bcc8
	ctx.lr = 0x822D99F4;
	sub_82E7BCC8(ctx, base);
	// 822D99F4: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 822D99F8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 822D99FC: 8141016C  lwz r10, 0x16c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 822D9A00: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822D9A04: 89210167  lbz r9, 0x167(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(359 as u32) ) } as u64;
	// 822D9A08: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822D9A0C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9A10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822D9A14: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822D9A18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822D9A1C: 4BFFFBBD  bl 0x822d95d8
	ctx.lr = 0x822D9A20;
	sub_822D95D8(ctx, base);
	// 822D9A20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9A24: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822D9A28: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 822D9A2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822D9A30: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D9B20 size=284
    let mut pc: u32 = 0x822D9B20;
    'dispatch: loop {
        match pc {
            0x822D9B20 => {
    //   block [0x822D9B20..0x822D9C3C)
	// 822D9B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9B24: 48ECE641  bl 0x831a8164
	ctx.lr = 0x822D9B28;
	sub_831A8130(ctx, base);
	// 822D9B28: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822D9B2C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9B30: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822D9B34: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822D9B38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822D9B3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822D9B40: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822D9B44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822D9B48: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822D9B4C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 822D9B50: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 822D9B54: 48BA2175  bl 0x82e7bcc8
	ctx.lr = 0x822D9B58;
	sub_82E7BCC8(ctx, base);
	// 822D9B58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822D9B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822D9B60: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 822D9B64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822D9B68: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 822D9B6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822D9B70: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822D9B74: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 822D9B78: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822D9B7C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822D9B80: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 822D9B84: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822D9B88: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 822D9B8C: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822D9B90: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822D9B94: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822D9B98: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822D9B9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822D9BA0: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822D9BA4: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 822D9BA8: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 822D9BAC: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 822D9BB0: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 822D9BB4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822D9BB8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822D9BBC: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 822D9BC0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822D9BC4: 4182004C  beq 0x822d9c10
	if ctx.cr[0].eq {
	pc = 0x822D9C10; continue 'dispatch;
	}
	// 822D9BC8: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 822D9BCC: 9B610057  stb r27, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[27].u8 ) };
	// 822D9BD0: 3BA50001  addi r29, r5, 1
	ctx.r[29].s64 = ctx.r[5].s64 + 1;
	// 822D9BD4: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 822D9BD8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 822D9BDC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822D9BE0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 822D9BE4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822D9BE8: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 822D9BEC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 822D9BF0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822D9BF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822D9BF8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 822D9BFC: 4BFFFD65  bl 0x822d9960
	ctx.lr = 0x822D9C00;
	sub_822D9960(ctx, base);
	// 822D9C00: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822D9C04: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822D9C08: 4198FFC0  blt cr6, 0x822d9bc8
	if ctx.cr[6].lt {
	pc = 0x822D9BC8; continue 'dispatch;
	}
	// 822D9C0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822D9C10: 3883FFD0  addi r4, r3, -0x30
	ctx.r[4].s64 = ctx.r[3].s64 + -48;
	// 822D9C14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822D9C18: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 822D9C1C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 822D9C20: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 822D9C24: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 822D9C28: 4BFFF481  bl 0x822d90a8
	ctx.lr = 0x822D9C2C;
	sub_822D90A8(ctx, base);
	// 822D9C2C: C0210070  lfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822D9C30: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 822D9C34: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822D9C38: 48ECE57C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822D9C40 size=636
    let mut pc: u32 = 0x822D9C40;
    'dispatch: loop {
        match pc {
            0x822D9C40 => {
    //   block [0x822D9C40..0x822D9EBC)
	// 822D9C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9C44: 48ECE519  bl 0x831a815c
	ctx.lr = 0x822D9C48;
	sub_831A8130(ctx, base);
	// 822D9C48: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 822D9C4C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822D9C50: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822D9C54: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822D9C58: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822D9C5C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822D9C60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822D9C64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 822D9C68: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 822D9C6C: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D9C70: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 822D9C74: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822D9C78: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822D9EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822D9EC0 size=492
    let mut pc: u32 = 0x822D9EC0;
    'dispatch: loop {
        match pc {
            0x822D9EC0 => {
    //   block [0x822D9EC0..0x822DA0AC)
	// 822D9EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822D9EC4: 48ECE28D  bl 0x831a8150
	ctx.lr = 0x822D9EC8;
	sub_831A8130(ctx, base);
	// 822D9EC8: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 822D9ECC: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 822D9ED0: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DA0B0 size=464
    let mut pc: u32 = 0x822DA0B0;
    'dispatch: loop {
        match pc {
            0x822DA0B0 => {
    //   block [0x822DA0B0..0x822DA280)
	// 822DA0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA0B4: 48ECE0A1  bl 0x831a8154
	ctx.lr = 0x822DA0B8;
	sub_831A8130(ctx, base);
	// 822DA0B8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 822DA0BC: 48ECE9BD  bl 0x831a8a78
	ctx.lr = 0x822DA0C0;
	sub_831A8A40(ctx, base);
	// 822DA0C0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA0C4: 83010174  lwz r24, 0x174(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 822DA0C8: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 822DA0CC: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 822DA0D0: 78CA0020  clrldi r10, r6, 0x20
	ctx.r[10].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 822DA0D4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822DA0D8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 822DA0DC: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822DA0E0: 81180000  lwz r8, 0(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA0E4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822DA0E8: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 822DA0EC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 822DA0F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 822DA0F4: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 822DA0F8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822DA0FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA100: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 822DA104: 54C93032  slwi r9, r6, 6
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822DA108: 54EA3032  slwi r10, r7, 6
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DA10C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA110: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822DA114: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822DA118: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DA11C: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822DA120: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822DA124: 409A0068  bne cr6, 0x822da18c
	if !ctx.cr[6].eq {
	pc = 0x822DA18C; continue 'dispatch;
	}
	// 822DA128: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA12C: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 822DA130: 409A005C  bne cr6, 0x822da18c
	if !ctx.cr[6].eq {
	pc = 0x822DA18C; continue 'dispatch;
	}
	// 822DA134: 80FB0000  lwz r7, 0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA138: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822DA13C: 83C10184  lwz r30, 0x184(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 822DA140: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 822DA144: 8B81017F  lbz r28, 0x17f(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(383 as u32) ) } as u64;
	// 822DA148: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 822DA14C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 822DA150: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA154: 38CA0010  addi r6, r10, 0x10
	ctx.r[6].s64 = ctx.r[10].s64 + 16;
	// 822DA158: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822DA15C: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 822DA160: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DA164: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822DA168: 9B810057  stb r28, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[28].u8 ) };
	// 822DA16C: 4BFFFAD5  bl 0x822d9c40
	ctx.lr = 0x822DA170;
	sub_822D9C40(ctx, base);
	// 822DA170: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA174: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 822DA178: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 822DA17C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA180: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DA280 size=328
    let mut pc: u32 = 0x822DA280;
    'dispatch: loop {
        match pc {
            0x822DA280 => {
    //   block [0x822DA280..0x822DA3C8)
	// 822DA280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA284: 48ECDEDD  bl 0x831a8160
	ctx.lr = 0x822DA288;
	sub_831A8130(ctx, base);
	// 822DA288: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822DA28C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA290: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DA294: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DA298: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 822DA29C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 822DA2A0: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 822DA2A4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA2A8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822DA2AC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA2B0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DA2B4: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 822DA2B8: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 822DA2BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DA2C0: 13C958C7  vcmpequd (lvx128) v30, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DA2C4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 822DA2C8: 13EA58C7  vcmpequd (lvx128) v31, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DA2CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA3C8 size=100
    let mut pc: u32 = 0x822DA3C8;
    'dispatch: loop {
        match pc {
            0x822DA3C8 => {
    //   block [0x822DA3C8..0x822DA42C)
	// 822DA3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA3D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA3D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA3DC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA3E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA3E4: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 822DA3E8: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 822DA3EC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DA3F0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DA3F4: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 822DA3F8: 4821BEB9  bl 0x824f62b0
	ctx.lr = 0x822DA3FC;
	sub_824F62B0(ctx, base);
	// 822DA3FC: 397F0068  addi r11, r31, 0x68
	ctx.r[11].s64 = ctx.r[31].s64 + 104;
	// 822DA400: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 822DA404: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DA408: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA40C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822DA410: 4821BEA1  bl 0x824f62b0
	ctx.lr = 0x822DA414;
	sub_824F62B0(ctx, base);
	// 822DA414: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA420: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA430 size=88
    let mut pc: u32 = 0x822DA430;
    'dispatch: loop {
        match pc {
            0x822DA430 => {
    //   block [0x822DA430..0x822DA488)
	// 822DA430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA438: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA43C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DA440: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA444: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 822DA448: 3929A30C  addi r9, r9, -0x5cf4
	ctx.r[9].s64 = ctx.r[9].s64 + -23796;
	// 822DA44C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DA450: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DA454: 419A001C  beq cr6, 0x822da470
	if ctx.cr[6].eq {
	pc = 0x822DA470; continue 'dispatch;
	}
	// 822DA458: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DA45C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA460: 48E15959  bl 0x830efdb8
	ctx.lr = 0x822DA464;
	sub_830EFDB8(ctx, base);
	// 822DA464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 822DA468: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DA46C: 409AFFEC  bne cr6, 0x822da458
	if !ctx.cr[6].eq {
	pc = 0x822DA458; continue 'dispatch;
	}
	// 822DA470: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 822DA474: 4BFFE2AD  bl 0x822d8720
	ctx.lr = 0x822DA478;
	sub_822D8720(ctx, base);
	// 822DA478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DA47C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA488 size=76
    let mut pc: u32 = 0x822DA488;
    'dispatch: loop {
        match pc {
            0x822DA488 => {
    //   block [0x822DA488..0x822DA4D4)
	// 822DA488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA4A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DA4A4: 4BFFFF8D  bl 0x822da430
	ctx.lr = 0x822DA4A8;
	sub_822DA430(ctx, base);
	// 822DA4A8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DA4AC: 4182000C  beq 0x822da4b8
	if ctx.cr[0].eq {
	pc = 0x822DA4B8; continue 'dispatch;
	}
	// 822DA4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA4B4: 4BFE5DB5  bl 0x822c0268
	ctx.lr = 0x822DA4B8;
	sub_822C0268(ctx, base);
	// 822DA4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA4C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA4D8 size=196
    let mut pc: u32 = 0x822DA4D8;
    'dispatch: loop {
        match pc {
            0x822DA4D8 => {
    //   block [0x822DA4D8..0x822DA59C)
	// 822DA4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA4E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA4E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA4E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA4EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DA4F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA4F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DA4F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DA4FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA500: 4BFE6439  bl 0x822c0938
	ctx.lr = 0x822DA504;
	sub_822C0938(ctx, base);
	// 822DA504: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DA508: 41820028  beq 0x822da530
	if ctx.cr[0].eq {
	pc = 0x822DA530; continue 'dispatch;
	}
	// 822DA50C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DA510: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DA514: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DA518: 392BA2A0  addi r9, r11, -0x5d60
	ctx.r[9].s64 = ctx.r[11].s64 + -23904;
	// 822DA51C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DA520: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DA524: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DA528: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DA52C: 48000008  b 0x822da534
	pc = 0x822DA534; continue 'dispatch;
	// 822DA530: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA534: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA53C: 409A0044  bne cr6, 0x822da580
	if !ctx.cr[6].eq {
	pc = 0x822DA580; continue 'dispatch;
	}
	// 822DA540: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DA544: 419A001C  beq cr6, 0x822da560
	if ctx.cr[6].eq {
	pc = 0x822DA560; continue 'dispatch;
	}
	// 822DA548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA54C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DA550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA554: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA558: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA55C: 4E800421  bctrl
	ctx.lr = 0x822DA560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA560: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DA564: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DA568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DA56C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DA570: 816B30C0  lwz r11, 0x30c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12480 as u32) ) } as u64;
	// 822DA574: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DA578: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DA57C: 4BFE5A85  bl 0x822c0000
	ctx.lr = 0x822DA580;
	sub_822C0000(ctx, base);
	// 822DA580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DA584: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA588: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA58C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA590: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA594: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA5A0 size=196
    let mut pc: u32 = 0x822DA5A0;
    'dispatch: loop {
        match pc {
            0x822DA5A0 => {
    //   block [0x822DA5A0..0x822DA664)
	// 822DA5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DA5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA5BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DA5C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DA5C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA5C8: 4BFE6371  bl 0x822c0938
	ctx.lr = 0x822DA5CC;
	sub_822C0938(ctx, base);
	// 822DA5CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DA5D0: 41820028  beq 0x822da5f8
	if ctx.cr[0].eq {
	pc = 0x822DA5F8; continue 'dispatch;
	}
	// 822DA5D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DA5D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DA5DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DA5E0: 392BA2B4  addi r9, r11, -0x5d4c
	ctx.r[9].s64 = ctx.r[11].s64 + -23884;
	// 822DA5E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DA5E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DA5EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DA5F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DA5F4: 48000008  b 0x822da5fc
	pc = 0x822DA5FC; continue 'dispatch;
	// 822DA5F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA5FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA604: 409A0044  bne cr6, 0x822da648
	if !ctx.cr[6].eq {
	pc = 0x822DA648; continue 'dispatch;
	}
	// 822DA608: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DA60C: 419A001C  beq cr6, 0x822da628
	if ctx.cr[6].eq {
	pc = 0x822DA628; continue 'dispatch;
	}
	// 822DA610: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA614: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DA618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA61C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA624: 4E800421  bctrl
	ctx.lr = 0x822DA628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA628: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DA62C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DA630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DA634: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DA638: 816B30C0  lwz r11, 0x30c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12480 as u32) ) } as u64;
	// 822DA63C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DA640: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DA644: 4BFE59BD  bl 0x822c0000
	ctx.lr = 0x822DA648;
	sub_822C0000(ctx, base);
	// 822DA648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DA64C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA658: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA668 size=196
    let mut pc: u32 = 0x822DA668;
    'dispatch: loop {
        match pc {
            0x822DA668 => {
    //   block [0x822DA668..0x822DA72C)
	// 822DA668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA670: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA674: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA67C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DA680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA684: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DA688: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DA68C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA690: 4BFE62A9  bl 0x822c0938
	ctx.lr = 0x822DA694;
	sub_822C0938(ctx, base);
	// 822DA694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DA698: 41820028  beq 0x822da6c0
	if ctx.cr[0].eq {
	pc = 0x822DA6C0; continue 'dispatch;
	}
	// 822DA69C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DA6A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DA6A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DA6A8: 392BA2C8  addi r9, r11, -0x5d38
	ctx.r[9].s64 = ctx.r[11].s64 + -23864;
	// 822DA6AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DA6B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DA6B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DA6B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DA6BC: 48000008  b 0x822da6c4
	pc = 0x822DA6C4; continue 'dispatch;
	// 822DA6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA6C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA6CC: 409A0044  bne cr6, 0x822da710
	if !ctx.cr[6].eq {
	pc = 0x822DA710; continue 'dispatch;
	}
	// 822DA6D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DA6D4: 419A001C  beq cr6, 0x822da6f0
	if ctx.cr[6].eq {
	pc = 0x822DA6F0; continue 'dispatch;
	}
	// 822DA6D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA6DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DA6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA6E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA6E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA6EC: 4E800421  bctrl
	ctx.lr = 0x822DA6F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA6F0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DA6F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DA6F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DA6FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DA700: 816B30C0  lwz r11, 0x30c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12480 as u32) ) } as u64;
	// 822DA704: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DA708: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DA70C: 4BFE58F5  bl 0x822c0000
	ctx.lr = 0x822DA710;
	sub_822C0000(ctx, base);
	// 822DA710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DA714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA71C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA720: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA730 size=196
    let mut pc: u32 = 0x822DA730;
    'dispatch: loop {
        match pc {
            0x822DA730 => {
    //   block [0x822DA730..0x822DA7F4)
	// 822DA730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA73C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DA748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA74C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DA750: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DA754: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA758: 4BFE61E1  bl 0x822c0938
	ctx.lr = 0x822DA75C;
	sub_822C0938(ctx, base);
	// 822DA75C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DA760: 41820028  beq 0x822da788
	if ctx.cr[0].eq {
	pc = 0x822DA788; continue 'dispatch;
	}
	// 822DA764: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DA768: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DA76C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DA770: 392BA2DC  addi r9, r11, -0x5d24
	ctx.r[9].s64 = ctx.r[11].s64 + -23844;
	// 822DA774: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DA778: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DA77C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DA780: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DA784: 48000008  b 0x822da78c
	pc = 0x822DA78C; continue 'dispatch;
	// 822DA788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA78C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA794: 409A0044  bne cr6, 0x822da7d8
	if !ctx.cr[6].eq {
	pc = 0x822DA7D8; continue 'dispatch;
	}
	// 822DA798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DA79C: 419A001C  beq cr6, 0x822da7b8
	if ctx.cr[6].eq {
	pc = 0x822DA7B8; continue 'dispatch;
	}
	// 822DA7A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA7A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DA7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA7AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA7B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA7B4: 4E800421  bctrl
	ctx.lr = 0x822DA7B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA7B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DA7BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DA7C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DA7C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DA7C8: 816B30C0  lwz r11, 0x30c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12480 as u32) ) } as u64;
	// 822DA7CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DA7D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DA7D4: 4BFE582D  bl 0x822c0000
	ctx.lr = 0x822DA7D8;
	sub_822C0000(ctx, base);
	// 822DA7D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DA7DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DA7E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA7E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA7E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DA7EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA7F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DA7F8 size=68
    let mut pc: u32 = 0x822DA7F8;
    'dispatch: loop {
        match pc {
            0x822DA7F8 => {
    //   block [0x822DA7F8..0x822DA83C)
	// 822DA7F8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA7FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA800: 419A0060  beq cr6, 0x822da860
	if ctx.cr[6].eq {
		sub_822DA860(ctx, base);
		return;
	}
	// 822DA804: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DA808: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DA80C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822DA810: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 822DA814: 4099004C  ble cr6, 0x822da860
	if !ctx.cr[6].gt {
		sub_822DA860(ctx, base);
		return;
	}
	// 822DA818: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA81C: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DA820: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DA824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA828: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DA82C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DA830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA834: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DA838: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA83C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DA83C size=36
    let mut pc: u32 = 0x822DA83C;
    'dispatch: loop {
        match pc {
            0x822DA83C => {
    //   block [0x822DA83C..0x822DA860)
	// 822DA83C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DA840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DA844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DA84C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DA850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DA854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA858: 4082FFE8  bne 0x822da840
	if !ctx.cr[0].eq {
	pc = 0x822DA840; continue 'dispatch;
	}
	// 822DA85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DA860 size=16
    let mut pc: u32 = 0x822DA860;
    'dispatch: loop {
        match pc {
            0x822DA860 => {
    //   block [0x822DA860..0x822DA870)
	// 822DA860: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DA864: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA868: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DA86C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA870 size=120
    let mut pc: u32 = 0x822DA870;
    'dispatch: loop {
        match pc {
            0x822DA870 => {
    //   block [0x822DA870..0x822DA8E8)
	// 822DA870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA874: 48ECD8F9  bl 0x831a816c
	ctx.lr = 0x822DA878;
	sub_831A8130(ctx, base);
	// 822DA878: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA87C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822DA884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DA888: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822DA88C: 4BFFFF6D  bl 0x822da7f8
	ctx.lr = 0x822DA890;
	sub_822DA7F8(ctx, base);
	// 822DA890: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DA894: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA89C: 419A000C  beq cr6, 0x822da8a8
	if ctx.cr[6].eq {
	pc = 0x822DA8A8; continue 'dispatch;
	}
	// 822DA8A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822DA8A4: 4BFE5FED  bl 0x822c0890
	ctx.lr = 0x822DA8A8;
	sub_822C0890(ctx, base);
	// 822DA8A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822DA8AC: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822DA8B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DA8B4: 4BFFFF45  bl 0x822da7f8
	ctx.lr = 0x822DA8B8;
	sub_822DA7F8(ctx, base);
	// 822DA8B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DA8BC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DA8C4: 419A000C  beq cr6, 0x822da8d0
	if ctx.cr[6].eq {
	pc = 0x822DA8D0; continue 'dispatch;
	}
	// 822DA8C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822DA8CC: 4BFE5FC5  bl 0x822c0890
	ctx.lr = 0x822DA8D0;
	sub_822C0890(ctx, base);
	// 822DA8D0: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 822DA8D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DA8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DA8DC: 4BFFF5E5  bl 0x822d9ec0
	ctx.lr = 0x822DA8E0;
	sub_822D9EC0(ctx, base);
	// 822DA8E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DA8E4: 48ECD8D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822DA8E8 size=8
    let mut pc: u32 = 0x822DA8E8;
    'dispatch: loop {
        match pc {
            0x822DA8E8 => {
    //   block [0x822DA8E8..0x822DA8F0)
	// 822DA8E8: C0230010  lfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DA8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA8F0 size=212
    let mut pc: u32 = 0x822DA8F0;
    'dispatch: loop {
        match pc {
            0x822DA8F0 => {
    //   block [0x822DA8F0..0x822DA9C4)
	// 822DA8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA8F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA8FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA904: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 822DA908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DA90C: 419A003C  beq cr6, 0x822da948
	if ctx.cr[6].eq {
	pc = 0x822DA948; continue 'dispatch;
	}
	// 822DA910: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 822DA914: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822DA918: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA91C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822DA920: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822DA924: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DA928: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA92C: 4082FFE8  bne 0x822da914
	if !ctx.cr[0].eq {
	pc = 0x822DA914; continue 'dispatch;
	}
	// 822DA930: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DA934: 409A0014  bne cr6, 0x822da948
	if !ctx.cr[6].eq {
	pc = 0x822DA948; continue 'dispatch;
	}
	// 822DA938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA93C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA944: 4E800421  bctrl
	ctx.lr = 0x822DA948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA948: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 822DA94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DA950: 419A003C  beq cr6, 0x822da98c
	if ctx.cr[6].eq {
	pc = 0x822DA98C; continue 'dispatch;
	}
	// 822DA954: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 822DA958: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 822DA95C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA960: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 822DA964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822DA968: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DA96C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DA970: 4082FFE8  bne 0x822da958
	if !ctx.cr[0].eq {
	pc = 0x822DA958; continue 'dispatch;
	}
	// 822DA974: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DA978: 409A0014  bne cr6, 0x822da98c
	if !ctx.cr[6].eq {
	pc = 0x822DA98C; continue 'dispatch;
	}
	// 822DA97C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DA980: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DA984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DA988: 4E800421  bctrl
	ctx.lr = 0x822DA98C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DA98C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DA990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DA994: 419A0008  beq cr6, 0x822da99c
	if ctx.cr[6].eq {
	pc = 0x822DA99C; continue 'dispatch;
	}
	// 822DA998: 4BFE5EF9  bl 0x822c0890
	ctx.lr = 0x822DA99C;
	sub_822C0890(ctx, base);
	// 822DA99C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DA9A0: 48ECE269  bl 0x831a8c08
	ctx.lr = 0x822DA9A4;
	sub_831A8C08(ctx, base);
	// 822DA9A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DA9A8: 396BA20C  addi r11, r11, -0x5df4
	ctx.r[11].s64 = ctx.r[11].s64 + -24052;
	// 822DA9AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DA9B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DA9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DA9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DA9BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DA9C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DA9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DA9C8 size=76
    let mut pc: u32 = 0x822DA9C8;
    'dispatch: loop {
        match pc {
            0x822DA9C8 => {
    //   block [0x822DA9C8..0x822DAA14)
	// 822DA9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DA9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DA9D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DA9D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DA9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DA9DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DA9E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DA9E4: 4BFFFF0D  bl 0x822da8f0
	ctx.lr = 0x822DA9E8;
	sub_822DA8F0(ctx, base);
	// 822DA9E8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DA9EC: 4182000C  beq 0x822da9f8
	if ctx.cr[0].eq {
	pc = 0x822DA9F8; continue 'dispatch;
	}
	// 822DA9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA9F4: 4BFE5875  bl 0x822c0268
	ctx.lr = 0x822DA9F8;
	sub_822C0268(ctx, base);
	// 822DA9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DA9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DAA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DAA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DAA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DAA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DAA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DAA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DAA18 size=688
    let mut pc: u32 = 0x822DAA18;
    'dispatch: loop {
        match pc {
            0x822DAA18 => {
    //   block [0x822DAA18..0x822DACC8)
	// 822DAA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DAA1C: 48ECD749  bl 0x831a8164
	ctx.lr = 0x822DAA20;
	sub_831A8130(ctx, base);
	// 822DAA20: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 822DAA24: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822DAA28: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DAA2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DAA30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822DAA34: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DAA38: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DAA3C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DAA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DAA44: 409A000C  bne cr6, 0x822daa50
	if !ctx.cr[6].eq {
	pc = 0x822DAA50; continue 'dispatch;
	}
	// 822DAA48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DAA4C: 4800026C  b 0x822dacb8
	pc = 0x822DACB8; continue 'dispatch;
	// 822DAA50: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAA54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DAA58: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DAA5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DAA60: 4E800421  bctrl
	ctx.lr = 0x822DAA64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DAA64: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DAA68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DAA6C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAA70: 38CBFFFE  addi r6, r11, -2
	ctx.r[6].s64 = ctx.r[11].s64 + -2;
	// 822DAA74: 4BFFE5A5  bl 0x822d9018
	ctx.lr = 0x822DAA78;
	sub_822D9018(ctx, base);
	// 822DAA78: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAA7C: 1D430030  mulli r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 * 48;
	// 822DAA80: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DAA84: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DAA88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DAA8C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DAA90: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822DAA94: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 822DAA98: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822DAA9C: C18A9F7C  lfs f12, -0x6084(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822DAAA0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 822DAAA4: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 822DAAA8: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 822DAAAC: 4099000C  ble cr6, 0x822daab8
	if !ctx.cr[6].gt {
	pc = 0x822DAAB8; continue 'dispatch;
	}
	// 822DAAB0: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 822DAAB4: EFC06824  fdivs f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822DAAB8: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DAABC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822DAAC0: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822DAAC4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822DAAC8: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822DAACC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DAAD0: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822DAAD4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822DAAD8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 822DAADC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 822DAAE0: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822DAAE4: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DAAE8: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822DAAEC: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822DAAF0: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 822DAAF4: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 822DAAF8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 822DAAFC: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822DAB00: 48BA2B41  bl 0x82e7d640
	ctx.lr = 0x822DAB04;
	sub_82E7D640(ctx, base);
	// 822DAB04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DAB08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822DAB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DAB10: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DACC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DACC8 size=288
    let mut pc: u32 = 0x822DACC8;
    'dispatch: loop {
        match pc {
            0x822DACC8 => {
    //   block [0x822DACC8..0x822DADE8)
	// 822DACC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DACCC: 48ECD48D  bl 0x831a8158
	ctx.lr = 0x822DACD0;
	sub_831A8130(ctx, base);
	// 822DACD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DACD4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822DACD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DACDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DACE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822DACE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DACE8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DACEC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822DACF0: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 822DACF4: 4BFFFB05  bl 0x822da7f8
	ctx.lr = 0x822DACF8;
	sub_822DA7F8(ctx, base);
	// 822DACF8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DACFC: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAD00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DAD04: 419A000C  beq cr6, 0x822dad10
	if ctx.cr[6].eq {
	pc = 0x822DAD10; continue 'dispatch;
	}
	// 822DAD08: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822DAD0C: 4BFE5B85  bl 0x822c0890
	ctx.lr = 0x822DAD10;
	sub_822C0890(ctx, base);
	// 822DAD10: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822DAD14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DAD18: 4BFFE861  bl 0x822d9578
	ctx.lr = 0x822DAD1C;
	sub_822D9578(ctx, base);
	// 822DAD1C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822DAD20: 4182008C  beq 0x822dadac
	if ctx.cr[0].eq {
	pc = 0x822DADAC; continue 'dispatch;
	}
	// 822DAD24: 3D600555  lis r11, 0x555
	ctx.r[11].s64 = 89456640;
	// 822DAD28: 1C7D0030  mulli r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 * 48;
	// 822DAD2C: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 822DAD30: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DAD34: 40990008  ble cr6, 0x822dad3c
	if !ctx.cr[6].gt {
	pc = 0x822DAD3C; continue 'dispatch;
	}
	// 822DAD38: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822DAD3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DAD40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DAD44: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DAD48: 38A00411  li r5, 0x411
	ctx.r[5].s64 = 1041;
	// 822DAD4C: 4BFE568D  bl 0x822c03d8
	ctx.lr = 0x822DAD50;
	sub_822C03D8(ctx, base);
	// 822DAD50: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822DAD54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAD58: 931F0004  stw r24, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 822DAD5C: 48ECDEAD  bl 0x831a8c08
	ctx.lr = 0x822DAD60;
	sub_831A8C08(ctx, base);
	// 822DAD60: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 822DAD64: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 822DAD68: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822DAD6C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822DAD70: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822DAD74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DAD78: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822DAD7C: 4BFFEDA5  bl 0x822d9b20
	ctx.lr = 0x822DAD80;
	sub_822D9B20(ctx, base);
	// 822DAD80: D03F0010  stfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822DAD84: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAD88: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 822DAD8C: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822DAD90: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 822DAD94: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DAD98: 4BFE96C9  bl 0x822c4460
	ctx.lr = 0x822DAD9C;
	sub_822C4460(ctx, base);
	// 822DAD9C: 897B0008  lbz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DADA0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822DADA4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822DADA8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DADAC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 822DADB0: 13E0F407  vcmpneb. (lvlx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DADB4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822DADB8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822DADBC: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 822DADC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DADC4: 13C8F407  vcmpneb. (lvlx128) v30, v8, v30
	tmp.u32 = ctx.r[8].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DADC8: 13A9F407  vcmpneb. (lvlx128) v29, v9, v30
	tmp.u32 = ctx.r[9].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DADCC: 138AF407  vcmpneb. (lvlx128) v28, v10, v30
	tmp.u32 = ctx.r[10].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DADE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DADE8 size=480
    let mut pc: u32 = 0x822DADE8;
    'dispatch: loop {
        match pc {
            0x822DADE8 => {
    //   block [0x822DADE8..0x822DAFC8)
	// 822DADE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DADEC: 48ECD361  bl 0x831a814c
	ctx.lr = 0x822DADF0;
	sub_831A8130(ctx, base);
	// 822DADF0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DADF4: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 822DADF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822DADFC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DAE00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822DAE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DAE08: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAE0C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 822DAE10: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 822DAE14: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 822DAE18: 4BFFF9E1  bl 0x822da7f8
	ctx.lr = 0x822DAE1C;
	sub_822DA7F8(ctx, base);
	// 822DAE1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DAE20: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DAE28: 419A000C  beq cr6, 0x822dae34
	if ctx.cr[6].eq {
	pc = 0x822DAE34; continue 'dispatch;
	}
	// 822DAE2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822DAE30: 4BFE5A61  bl 0x822c0890
	ctx.lr = 0x822DAE34;
	sub_822C0890(ctx, base);
	// 822DAE34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822DAE38: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAE3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DAE40: 4BFFF9B9  bl 0x822da7f8
	ctx.lr = 0x822DAE44;
	sub_822DA7F8(ctx, base);
	// 822DAE44: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DAE48: 83430000  lwz r26, 0(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DAE50: 419A000C  beq cr6, 0x822dae5c
	if ctx.cr[6].eq {
	pc = 0x822DAE5C; continue 'dispatch;
	}
	// 822DAE54: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822DAE58: 4BFE5A39  bl 0x822c0890
	ctx.lr = 0x822DAE5C;
	sub_822C0890(ctx, base);
	// 822DAE5C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAE60: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAE64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DAE68: 419A000C  beq cr6, 0x822dae74
	if ctx.cr[6].eq {
	pc = 0x822DAE74; continue 'dispatch;
	}
	// 822DAE6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DAE70: 48000150  b 0x822dafc0
	pc = 0x822DAFC0; continue 'dispatch;
	// 822DAE74: 8ABB0008  lbz r21, 8(r27)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DAE78: 897A0008  lbz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DAE7C: 28150000  cmplwi r21, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DAE80: 4182000C  beq 0x822dae8c
	if ctx.cr[0].eq {
	pc = 0x822DAE8C; continue 'dispatch;
	}
	// 822DAE84: 556A063F  clrlwi. r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DAE88: 4182FFE4  beq 0x822dae6c
	if ctx.cr[0].eq {
	pc = 0x822DAE6C; continue 'dispatch;
	}
	// 822DAE8C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 822DAE90: 409A000C  bne cr6, 0x822dae9c
	if !ctx.cr[6].eq {
	pc = 0x822DAE9C; continue 'dispatch;
	}
	// 822DAE94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DAE98: 4082FFD4  bne 0x822dae6c
	if !ctx.cr[0].eq {
	pc = 0x822DAE6C; continue 'dispatch;
	}
	// 822DAE9C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822DAEA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DAEA4: 4BFFE6D5  bl 0x822d9578
	ctx.lr = 0x822DAEA8;
	sub_822D9578(ctx, base);
	// 822DAEA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DAEAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822DAEB0: 4BFFE6C9  bl 0x822d9578
	ctx.lr = 0x822DAEB4;
	sub_822D9578(ctx, base);
	// 822DAEB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DAEB8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822DAEBC: 409AFFB0  bne cr6, 0x822dae6c
	if !ctx.cr[6].eq {
	pc = 0x822DAE6C; continue 'dispatch;
	}
	// 822DAEC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DAEC4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822DAEC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DAECC: 4BFFEFF5  bl 0x822d9ec0
	ctx.lr = 0x822DAED0;
	sub_822D9EC0(ctx, base);
	// 822DAED0: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DAED4: 41820010  beq 0x822daee4
	if ctx.cr[0].eq {
	pc = 0x822DAEE4; continue 'dispatch;
	}
	// 822DAED8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 822DAEDC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 822DAEE0: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 822DAEE4: 5479063F  clrlwi. r25, r3, 0x18
	ctx.r[25].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 822DAEE8: 40820008  bne 0x822daef0
	if !ctx.cr[0].eq {
	pc = 0x822DAEF0; continue 'dispatch;
	}
	// 822DAEEC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822DAEF0: 3D600555  lis r11, 0x555
	ctx.r[11].s64 = 89456640;
	// 822DAEF4: 1C7E0030  mulli r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 * 48;
	// 822DAEF8: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 822DAEFC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DAF00: 40990008  ble cr6, 0x822daf08
	if !ctx.cr[6].gt {
	pc = 0x822DAF08; continue 'dispatch;
	}
	// 822DAF04: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 822DAF08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DAF0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DAF10: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DAF14: 38A0044F  li r5, 0x44f
	ctx.r[5].s64 = 1103;
	// 822DAF18: 4BFE54C1  bl 0x822c03d8
	ctx.lr = 0x822DAF1C;
	sub_822C03D8(ctx, base);
	// 822DAF1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DAF20: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DAF24: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822DAF28: 48ECDCE1  bl 0x831a8c08
	ctx.lr = 0x822DAF2C;
	sub_831A8C08(ctx, base);
	// 822DAF2C: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822DAF30: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822DAF34: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 822DAF38: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 822DAF3C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822DAF40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DAF44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DAF48: 419A0010  beq cr6, 0x822daf58
	if ctx.cr[6].eq {
	pc = 0x822DAF58; continue 'dispatch;
	}
	// 822DAF4C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822DAF50: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822DAF54: 4800000C  b 0x822daf60
	pc = 0x822DAF60; continue 'dispatch;
	// 822DAF58: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DAF5C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DAF60: 4BFFF321  bl 0x822da280
	ctx.lr = 0x822DAF64;
	sub_822DA280(ctx, base);
	// 822DAF64: D03C0010  stfs f1, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822DAF68: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DAF6C: 38970004  addi r4, r23, 4
	ctx.r[4].s64 = ctx.r[23].s64 + 4;
	// 822DAF70: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822DAF74: 397C0014  addi r11, r28, 0x14
	ctx.r[11].s64 = ctx.r[28].s64 + 20;
	// 822DAF78: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DAF7C: 4BFE94E5  bl 0x822c4460
	ctx.lr = 0x822DAF80;
	sub_822C4460(ctx, base);
	// 822DAF80: 7EA70034  cntlzw r7, r21
	ctx.r[7].u64 = if ctx.r[21].u32 == 0 { 32 } else { ctx.r[21].u32.leading_zeros() as u64 };
	// 822DAF84: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 822DAF88: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822DAF8C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822DAF90: 397C0020  addi r11, r28, 0x20
	ctx.r[11].s64 = ctx.r[28].s64 + 32;
	// 822DAF94: 54E7DFFE  rlwinm r7, r7, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 822DAF98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DAF9C: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822DAFA0: 13E8FC07  vcmpneb. (lvlx128) v31, v8, v31
	tmp.u32 = ctx.r[8].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DAFA4: 13C9FC07  vcmpneb. (lvlx128) v30, v9, v31
	tmp.u32 = ctx.r[9].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DAFA8: 13AAFC07  vcmpneb. (lvlx128) v29, v10, v31
	tmp.u32 = ctx.r[10].u32 + ctx.r[31].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DAFAC: 1380FC07  vcmpneb. (lvlx128) v28, v0, v31
	tmp.u32 = ctx.r[31].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DAFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DAFC8 size=152
    let mut pc: u32 = 0x822DAFC8;
    'dispatch: loop {
        match pc {
            0x822DAFC8 => {
    //   block [0x822DAFC8..0x822DB060)
	// 822DAFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DAFCC: 48ECD19D  bl 0x831a8168
	ctx.lr = 0x822DAFD0;
	sub_831A8130(ctx, base);
	// 822DAFD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DAFD4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822DAFD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DAFDC: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DAFE0: 41820054  beq 0x822db034
	if ctx.cr[0].eq {
	pc = 0x822DB034; continue 'dispatch;
	}
	// 822DAFE4: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 822DAFE8: 3BBFFFFC  addi r29, r31, -4
	ctx.r[29].s64 = ctx.r[31].s64 + -4;
	// 822DAFEC: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DAFF0: 37CAFFFF  addic. r30, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822DAFF4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822DAFF8: 41800024  blt 0x822db01c
	if ctx.cr[0].lt {
	pc = 0x822DB01C; continue 'dispatch;
	}
	// 822DAFFC: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 822DB000: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 822DB004: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB00C: 419A0008  beq cr6, 0x822db014
	if ctx.cr[6].eq {
	pc = 0x822DB014; continue 'dispatch;
	}
	// 822DB010: 4BFE5881  bl 0x822c0890
	ctx.lr = 0x822DB014;
	sub_822C0890(ctx, base);
	// 822DB014: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 822DB018: 4080FFE8  bge 0x822db000
	if !ctx.cr[0].lt {
	pc = 0x822DB000; continue 'dispatch;
	}
	// 822DB01C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB020: 4182000C  beq 0x822db02c
	if ctx.cr[0].eq {
	pc = 0x822DB02C; continue 'dispatch;
	}
	// 822DB024: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB028: 48ECDBE1  bl 0x831a8c08
	ctx.lr = 0x822DB02C;
	sub_831A8C08(ctx, base);
	// 822DB02C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB030: 48000028  b 0x822db058
	pc = 0x822DB058; continue 'dispatch;
	// 822DB034: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DB038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB03C: 419A0008  beq cr6, 0x822db044
	if ctx.cr[6].eq {
	pc = 0x822DB044; continue 'dispatch;
	}
	// 822DB040: 4BFE5851  bl 0x822c0890
	ctx.lr = 0x822DB044;
	sub_822C0890(ctx, base);
	// 822DB044: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB048: 4182000C  beq 0x822db054
	if ctx.cr[0].eq {
	pc = 0x822DB054; continue 'dispatch;
	}
	// 822DB04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB050: 4BFE5219  bl 0x822c0268
	ctx.lr = 0x822DB054;
	sub_822C0268(ctx, base);
	// 822DB054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DB05C: 48ECD15C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DB060 size=344
    let mut pc: u32 = 0x822DB060;
    'dispatch: loop {
        match pc {
            0x822DB060 => {
    //   block [0x822DB060..0x822DB1B8)
	// 822DB060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB064: 48ECD0F1  bl 0x831a8154
	ctx.lr = 0x822DB068;
	sub_831A8130(ctx, base);
	// 822DB068: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB06C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822DB070: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DB074: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822DB078: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 822DB07C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 822DB080: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB084: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 822DB088: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DB090: 419A0014  beq cr6, 0x822db0a4
	if ctx.cr[6].eq {
	pc = 0x822DB0A4; continue 'dispatch;
	}
	// 822DB094: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DB098: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DB09C: 7D771E71  srawi. r23, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[23].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 822DB0A0: 40820014  bne 0x822db0b4
	if !ctx.cr[0].eq {
	pc = 0x822DB0B4; continue 'dispatch;
	}
	// 822DB0A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822DB0A8: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822DB0AC: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DB0B0: 480000FC  b 0x822db1ac
	pc = 0x822DB1AC; continue 'dispatch;
	// 822DB0B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB0B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB0BC: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DB0C0: 38A003E4  li r5, 0x3e4
	ctx.r[5].s64 = 996;
	// 822DB0C4: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 822DB0C8: 4BFE5311  bl 0x822c03d8
	ctx.lr = 0x822DB0CC;
	sub_822C03D8(ctx, base);
	// 822DB0CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB0D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822DB0D4: 41820050  beq 0x822db124
	if ctx.cr[0].eq {
	pc = 0x822DB124; continue 'dispatch;
	}
	// 822DB0D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB0DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DB0E0: 396BA314  addi r11, r11, -0x5cec
	ctx.r[11].s64 = ctx.r[11].s64 + -23788;
	// 822DB0E4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822DB0E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB0EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB0F0: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DB0F4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DB0F8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822DB0FC: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 822DB100: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 822DB104: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 822DB108: 93C30018  stw r30, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 822DB10C: 93C30060  stw r30, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 822DB110: 93C30064  stw r30, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 822DB114: 93C30068  stw r30, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 822DB118: 93C3006C  stw r30, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 822DB11C: 93C30070  stw r30, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 822DB120: 48000008  b 0x822db128
	pc = 0x822DB128; continue 'dispatch;
	// 822DB124: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822DB128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB12C: 419AFF7C  beq cr6, 0x822db0a8
	if ctx.cr[6].eq {
	pc = 0x822DB0A8; continue 'dispatch;
	}
	// 822DB130: 2B170002  cmplwi cr6, r23, 2
	ctx.cr[6].compare_u32(ctx.r[23].u32, 2 as u32, &mut ctx.xer);
	// 822DB134: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 822DB138: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 822DB13C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822DB140: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DB144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB148: 409A0038  bne cr6, 0x822db180
	if !ctx.cr[6].eq {
	pc = 0x822DB180; continue 'dispatch;
	}
	// 822DB14C: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 822DB150: 4BFFFC99  bl 0x822dade8
	ctx.lr = 0x822DB154;
	sub_822DADE8(ctx, base);
	// 822DB154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB158: 40820030  bne 0x822db188
	if !ctx.cr[0].eq {
	pc = 0x822DB188; continue 'dispatch;
	}
	// 822DB15C: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822DB160: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DB164: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DB168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB16C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB170: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DB178: 4E800421  bctrl
	ctx.lr = 0x822DB17C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DB17C: 48000030  b 0x822db1ac
	pc = 0x822DB1AC; continue 'dispatch;
	// 822DB180: 4BFFFB49  bl 0x822dacc8
	ctx.lr = 0x822DB184;
	sub_822DACC8(ctx, base);
	// 822DB184: 4BFFFFD0  b 0x822db154
	pc = 0x822DB154; continue 'dispatch;
	// 822DB188: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DB18C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822DB190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB198: 4BFFF341  bl 0x822da4d8
	ctx.lr = 0x822DB19C;
	sub_822DA4D8(ctx, base);
	// 822DB19C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DB1A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB1A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB1A8: 4BFE4E59  bl 0x822c0000
	ctx.lr = 0x822DB1AC;
	sub_822C0000(ctx, base);
	// 822DB1AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB1B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DB1B4: 48ECCFF0  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB1B8 size=172
    let mut pc: u32 = 0x822DB1B8;
    'dispatch: loop {
        match pc {
            0x822DB1B8 => {
    //   block [0x822DB1B8..0x822DB264)
	// 822DB1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB1BC: 48ECCFB1  bl 0x831a816c
	ctx.lr = 0x822DB1C0;
	sub_831A8130(ctx, base);
	// 822DB1C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB1C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB1C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DB1CC: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 822DB1D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB1D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DB1D8: 486ED581  bl 0x829c8758
	ctx.lr = 0x822DB1DC;
	sub_829C8758(ctx, base);
	// 822DB1DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DB1E0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 822DB1E4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DB1E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB1EC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB1F0: 4BFE9271  bl 0x822c4460
	ctx.lr = 0x822DB1F4;
	sub_822C4460(ctx, base);
	// 822DB1F4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DB1F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB1FC: 419A0008  beq cr6, 0x822db204
	if ctx.cr[6].eq {
	pc = 0x822DB204; continue 'dispatch;
	}
	// 822DB200: 4BFE5691  bl 0x822c0890
	ctx.lr = 0x822DB204;
	sub_822C0890(ctx, base);
	// 822DB204: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 822DB208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DB20C: 486ED54D  bl 0x829c8758
	ctx.lr = 0x822DB210;
	sub_829C8758(ctx, base);
	// 822DB210: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DB214: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822DB218: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DB21C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB220: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB224: 4BFE923D  bl 0x822c4460
	ctx.lr = 0x822DB228;
	sub_822C4460(ctx, base);
	// 822DB228: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DB22C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB230: 419A0008  beq cr6, 0x822db238
	if ctx.cr[6].eq {
	pc = 0x822DB238; continue 'dispatch;
	}
	// 822DB234: 4BFE565D  bl 0x822c0890
	ctx.lr = 0x822DB238;
	sub_822C0890(ctx, base);
	// 822DB238: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB23C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB240: 419A0014  beq cr6, 0x822db254
	if ctx.cr[6].eq {
	pc = 0x822DB254; continue 'dispatch;
	}
	// 822DB244: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB24C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822DB250: 409A0008  bne cr6, 0x822db258
	if !ctx.cr[6].eq {
	pc = 0x822DB258; continue 'dispatch;
	}
	// 822DB254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DB258: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 822DB25C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DB260: 48ECCF5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB268 size=164
    let mut pc: u32 = 0x822DB268;
    'dispatch: loop {
        match pc {
            0x822DB268 => {
    //   block [0x822DB268..0x822DB30C)
	// 822DB268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB26C: 48ECCF01  bl 0x831a816c
	ctx.lr = 0x822DB270;
	sub_831A8130(ctx, base);
	// 822DB270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB274: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DB278: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DB27C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DB280: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DB284: 816B173C  lwz r11, 0x173c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5948 as u32) ) } as u64;
	// 822DB288: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DB28C: 419A0068  beq cr6, 0x822db2f4
	if ctx.cr[6].eq {
	pc = 0x822DB2F4; continue 'dispatch;
	}
	// 822DB290: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB294: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB298: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DB29C: 38A004ED  li r5, 0x4ed
	ctx.r[5].s64 = 1261;
	// 822DB2A0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 822DB2A4: 4BFE5135  bl 0x822c03d8
	ctx.lr = 0x822DB2A8;
	sub_822C03D8(ctx, base);
	// 822DB2A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB2AC: 4182001C  beq 0x822db2c8
	if ctx.cr[0].eq {
	pc = 0x822DB2C8; continue 'dispatch;
	}
	// 822DB2B0: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 822DB2B4: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DB2B8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DB2BC: 4BFFDA0D  bl 0x822d8cc8
	ctx.lr = 0x822DB2C0;
	sub_822D8CC8(ctx, base);
	// 822DB2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB2C4: 48000008  b 0x822db2cc
	pc = 0x822DB2CC; continue 'dispatch;
	// 822DB2C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DB2CC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DB2D0: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 822DB2D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB2D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB2DC: 4BFFF2C5  bl 0x822da5a0
	ctx.lr = 0x822DB2E0;
	sub_822DA5A0(ctx, base);
	// 822DB2E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DB2E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB2E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB2EC: 4BFE4D15  bl 0x822c0000
	ctx.lr = 0x822DB2F0;
	sub_822C0000(ctx, base);
	// 822DB2F0: 48000010  b 0x822db300
	pc = 0x822DB300; continue 'dispatch;
	// 822DB2F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DB2F8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB2FC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DB300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DB308: 48ECCEB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB310 size=132
    let mut pc: u32 = 0x822DB310;
    'dispatch: loop {
        match pc {
            0x822DB310 => {
    //   block [0x822DB310..0x822DB394)
	// 822DB310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB314: 48ECCE59  bl 0x831a816c
	ctx.lr = 0x822DB318;
	sub_831A8130(ctx, base);
	// 822DB318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB31C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB320: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DB324: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB328: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DB32C: 38A00514  li r5, 0x514
	ctx.r[5].s64 = 1300;
	// 822DB330: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DB334: 4BFE50A5  bl 0x822c03d8
	ctx.lr = 0x822DB338;
	sub_822C03D8(ctx, base);
	// 822DB338: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB33C: 41820024  beq 0x822db360
	if ctx.cr[0].eq {
	pc = 0x822DB360; continue 'dispatch;
	}
	// 822DB340: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DB344: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822DB348: 394AA30C  addi r10, r10, -0x5cf4
	ctx.r[10].s64 = ctx.r[10].s64 + -23796;
	// 822DB34C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB350: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DB354: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DB358: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DB35C: 48000008  b 0x822db364
	pc = 0x822DB364; continue 'dispatch;
	// 822DB360: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DB364: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DB368: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822DB36C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB374: 4BFFF2F5  bl 0x822da668
	ctx.lr = 0x822DB378;
	sub_822DA668(ctx, base);
	// 822DB378: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DB37C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB384: 4BFE4C7D  bl 0x822c0000
	ctx.lr = 0x822DB388;
	sub_822C0000(ctx, base);
	// 822DB388: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB38C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DB390: 48ECCE2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB398 size=148
    let mut pc: u32 = 0x822DB398;
    'dispatch: loop {
        match pc {
            0x822DB398 => {
    //   block [0x822DB398..0x822DB42C)
	// 822DB398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DB3A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DB3A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB3A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB3AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB3B0: 396BA388  addi r11, r11, -0x5c78
	ctx.r[11].s64 = ctx.r[11].s64 + -23672;
	// 822DB3B4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822DB3B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB3BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB3C0: 419A000C  beq cr6, 0x822db3cc
	if ctx.cr[6].eq {
	pc = 0x822DB3CC; continue 'dispatch;
	}
	// 822DB3C4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822DB3C8: 4BFFFC01  bl 0x822dafc8
	ctx.lr = 0x822DB3CC;
	sub_822DAFC8(ctx, base);
	// 822DB3CC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822DB3D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB3D4: 419A000C  beq cr6, 0x822db3e0
	if ctx.cr[6].eq {
	pc = 0x822DB3E0; continue 'dispatch;
	}
	// 822DB3D8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822DB3DC: 4BFFFBED  bl 0x822dafc8
	ctx.lr = 0x822DB3E0;
	sub_822DAFC8(ctx, base);
	// 822DB3E0: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DB3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB3E8: 419A0008  beq cr6, 0x822db3f0
	if ctx.cr[6].eq {
	pc = 0x822DB3F0; continue 'dispatch;
	}
	// 822DB3EC: 4BFE54A5  bl 0x822c0890
	ctx.lr = 0x822DB3F0;
	sub_822C0890(ctx, base);
	// 822DB3F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DB3F8: 419A000C  beq cr6, 0x822db404
	if ctx.cr[6].eq {
	pc = 0x822DB404; continue 'dispatch;
	}
	// 822DB3FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DB400: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DB404: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DB408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DB40C: 419A000C  beq cr6, 0x822db418
	if ctx.cr[6].eq {
	pc = 0x822DB418; continue 'dispatch;
	}
	// 822DB410: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB414: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DB418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DB41C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DB420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DB424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DB428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB430 size=1076
    let mut pc: u32 = 0x822DB430;
    'dispatch: loop {
        match pc {
            0x822DB430 => {
    //   block [0x822DB430..0x822DB864)
	// 822DB430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB434: 48ECCD01  bl 0x831a8134
	ctx.lr = 0x822DB438;
	sub_831A8130(ctx, base);
	// 822DB438: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB43C: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 822DB440: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 822DB444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DB448: 7E2F8B78  mr r15, r17
	ctx.r[15].u64 = ctx.r[17].u64;
	// 822DB44C: 397E0014  addi r11, r30, 0x14
	ctx.r[11].s64 = ctx.r[30].s64 + 20;
	// 822DB450: 81520000  lwz r10, 0(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB454: 38920004  addi r4, r18, 4
	ctx.r[4].s64 = ctx.r[18].s64 + 4;
	// 822DB458: 91E10060  stw r15, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[15].u32 ) };
	// 822DB45C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DB460: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 822DB464: 4BFE8FFD  bl 0x822c4460
	ctx.lr = 0x822DB468;
	sub_822C4460(ctx, base);
	// 822DB468: 80720000  lwz r3, 0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB46C: 4BFF88E5  bl 0x822d3d50
	ctx.lr = 0x822DB470;
	sub_822D3D50(ctx, base);
	// 822DB470: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 822DB474: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 822DB478: 617FFFFF  ori r31, r11, 0xffff
	ctx.r[31].u64 = ctx.r[11].u64 | 65535;
	// 822DB47C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 822DB480: 7F14F840  cmplw cr6, r20, r31
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822DB484: 568B1838  slwi r11, r20, 3
	ctx.r[11].u32 = ctx.r[20].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DB488: 40990008  ble cr6, 0x822db490
	if !ctx.cr[6].gt {
	pc = 0x822DB490; continue 'dispatch;
	}
	// 822DB48C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822DB490: 3BA0FFFB  li r29, -5
	ctx.r[29].s64 = -5;
	// 822DB494: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DB498: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822DB49C: 40990008  ble cr6, 0x822db4a4
	if !ctx.cr[6].gt {
	pc = 0x822DB4A4; continue 'dispatch;
	}
	// 822DB4A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822DB4A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB4A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB4AC: 3A0BA340  addi r16, r11, -0x5cc0
	ctx.r[16].s64 = ctx.r[11].s64 + -23744;
	// 822DB4B0: 38A004A0  li r5, 0x4a0
	ctx.r[5].s64 = 1184;
	// 822DB4B4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 822DB4B8: 4BFE4F21  bl 0x822c03d8
	ctx.lr = 0x822DB4BC;
	sub_822C03D8(ctx, base);
	// 822DB4BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB4C0: 41820030  beq 0x822db4f0
	if ctx.cr[0].eq {
	pc = 0x822DB4F0; continue 'dispatch;
	}
	// 822DB4C4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 822DB4C8: 92830000  stw r20, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 822DB4CC: 3574FFFF  addic. r11, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB4D0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822DB4D4: 41800020  blt 0x822db4f4
	if ctx.cr[0].lt {
	pc = 0x822DB4F4; continue 'dispatch;
	}
	// 822DB4D8: 922A0000  stw r17, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 822DB4DC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB4E0: 922A0004  stw r17, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 822DB4E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822DB4E8: 4080FFF0  bge 0x822db4d8
	if !ctx.cr[0].lt {
	pc = 0x822DB4D8; continue 'dispatch;
	}
	// 822DB4EC: 48000008  b 0x822db4f4
	pc = 0x822DB4F4; continue 'dispatch;
	// 822DB4F0: 7E298B78  mr r9, r17
	ctx.r[9].u64 = ctx.r[17].u64;
	// 822DB4F4: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 822DB4F8: 3A7E001C  addi r19, r30, 0x1c
	ctx.r[19].s64 = ctx.r[30].s64 + 28;
	// 822DB4FC: 913E001C  stw r9, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 822DB500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB504: 419A000C  beq cr6, 0x822db510
	if ctx.cr[6].eq {
	pc = 0x822DB510; continue 'dispatch;
	}
	// 822DB508: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822DB50C: 4BFFFABD  bl 0x822dafc8
	ctx.lr = 0x822DB510;
	sub_822DAFC8(ctx, base);
	// 822DB510: 7F14F840  cmplw cr6, r20, r31
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[31].u32, &mut ctx.xer);
	// 822DB514: 568B1838  slwi r11, r20, 3
	ctx.r[11].u32 = ctx.r[20].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DB518: 40990008  ble cr6, 0x822db520
	if !ctx.cr[6].gt {
	pc = 0x822DB520; continue 'dispatch;
	}
	// 822DB51C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 822DB520: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822DB524: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DB528: 40990008  ble cr6, 0x822db530
	if !ctx.cr[6].gt {
	pc = 0x822DB530; continue 'dispatch;
	}
	// 822DB52C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822DB530: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 822DB534: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB538: 38A004A2  li r5, 0x4a2
	ctx.r[5].s64 = 1186;
	// 822DB53C: 4BFE4E9D  bl 0x822c03d8
	ctx.lr = 0x822DB540;
	sub_822C03D8(ctx, base);
	// 822DB540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB544: 41820030  beq 0x822db574
	if ctx.cr[0].eq {
	pc = 0x822DB574; continue 'dispatch;
	}
	// 822DB548: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 822DB54C: 92830000  stw r20, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 822DB550: 3574FFFF  addic. r11, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB554: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 822DB558: 41800020  blt 0x822db578
	if ctx.cr[0].lt {
	pc = 0x822DB578; continue 'dispatch;
	}
	// 822DB55C: 922A0000  stw r17, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u32 ) };
	// 822DB560: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB564: 922A0004  stw r17, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 822DB568: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 822DB56C: 4080FFF0  bge 0x822db55c
	if !ctx.cr[0].lt {
	pc = 0x822DB55C; continue 'dispatch;
	}
	// 822DB570: 48000008  b 0x822db578
	pc = 0x822DB578; continue 'dispatch;
	// 822DB574: 7E298B78  mr r9, r17
	ctx.r[9].u64 = ctx.r[17].u64;
	// 822DB578: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 822DB57C: 3ABE0020  addi r21, r30, 0x20
	ctx.r[21].s64 = ctx.r[30].s64 + 32;
	// 822DB580: 913E0020  stw r9, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 822DB584: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB588: 419A000C  beq cr6, 0x822db594
	if ctx.cr[6].eq {
	pc = 0x822DB594; continue 'dispatch;
	}
	// 822DB58C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 822DB590: 4BFFFA39  bl 0x822dafc8
	ctx.lr = 0x822DB594;
	sub_822DAFC8(ctx, base);
	// 822DB594: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 822DB598: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 822DB59C: 419A02BC  beq cr6, 0x822db858
	if ctx.cr[6].eq {
	pc = 0x822DB858; continue 'dispatch;
	}
	// 822DB5A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DB5A4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DB5A8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822DB5AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB5B0: 7E398B78  mr r25, r17
	ctx.r[25].u64 = ctx.r[17].u64;
	// 822DB5B4: 3F408212  lis r26, -0x7dee
	ctx.r[26].s64 = -2112749568;
	// 822DB5B8: 3AEAA120  addi r23, r10, -0x5ee0
	ctx.r[23].s64 = ctx.r[10].s64 + -24288;
	// 822DB5BC: 3AC9A124  addi r22, r9, -0x5edc
	ctx.r[22].s64 = ctx.r[9].s64 + -24284;
	// 822DB5C0: 3B08A128  addi r24, r8, -0x5ed8
	ctx.r[24].s64 = ctx.r[8].s64 + -24280;
	// 822DB5C4: 3B6BA12C  addi r27, r11, -0x5ed4
	ctx.r[27].s64 = ctx.r[11].s64 + -24276;
	// 822DB5C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822DB5CC: 80920000  lwz r4, 0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB5D0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 822DB5D4: 4BFF8845  bl 0x822d3e18
	ctx.lr = 0x822DB5D8;
	sub_822D3E18(ctx, base);
	// 822DB5D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DB5DC: 80720000  lwz r3, 0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB5E0: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 822DB5E4: 4BFF8795  bl 0x822d3d78
	ctx.lr = 0x822DB5E8;
	sub_822D3D78(ctx, base);
	// 822DB5E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DB5EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DB5F0: 48B18419  bl 0x82df3a08
	ctx.lr = 0x822DB5F4;
	sub_82DF3A08(ctx, base);
	// 822DB5F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DB5F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DB5FC: 48B18D7D  bl 0x82df4378
	ctx.lr = 0x822DB600;
	sub_82DF4378(ctx, base);
	// 822DB600: 817AB230  lwz r11, -0x4dd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19920 as u32) ) } as u64;
	// 822DB604: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822DB608: 419A00A8  beq cr6, 0x822db6b0
	if ctx.cr[6].eq {
	pc = 0x822DB6B0; continue 'dispatch;
	}
	// 822DB60C: 38A30001  addi r5, r3, 1
	ctx.r[5].s64 = ctx.r[3].s64 + 1;
	// 822DB610: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822DB614: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822DB618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB61C: 48B18F4D  bl 0x82df4568
	ctx.lr = 0x822DB620;
	sub_82DF4568(ctx, base);
	// 822DB620: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822DB624: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DB628: 48B183E1  bl 0x82df3a08
	ctx.lr = 0x822DB62C;
	sub_82DF3A08(ctx, base);
	// 822DB62C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822DB630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB634: 48B17CD5  bl 0x82df3308
	ctx.lr = 0x822DB638;
	sub_82DF3308(ctx, base);
	// 822DB638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB63C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DB640: 48B17DE9  bl 0x82df3428
	ctx.lr = 0x822DB644;
	sub_82DF3428(ctx, base);
	// 822DB644: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB648: 4082005C  bne 0x822db6a4
	if !ctx.cr[0].eq {
	pc = 0x822DB6A4; continue 'dispatch;
	}
	// 822DB64C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 822DB650: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DB654: 48B183B5  bl 0x82df3a08
	ctx.lr = 0x822DB658;
	sub_82DF3A08(ctx, base);
	// 822DB658: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 822DB65C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB660: 48B17CA9  bl 0x82df3308
	ctx.lr = 0x822DB664;
	sub_82DF3308(ctx, base);
	// 822DB664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB668: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DB66C: 48B17DBD  bl 0x82df3428
	ctx.lr = 0x822DB670;
	sub_82DF3428(ctx, base);
	// 822DB670: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB674: 40820030  bne 0x822db6a4
	if !ctx.cr[0].eq {
	pc = 0x822DB6A4; continue 'dispatch;
	}
	// 822DB678: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822DB67C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DB680: 48B18389  bl 0x82df3a08
	ctx.lr = 0x822DB684;
	sub_82DF3A08(ctx, base);
	// 822DB684: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822DB688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB68C: 48B17C7D  bl 0x82df3308
	ctx.lr = 0x822DB690;
	sub_82DF3308(ctx, base);
	// 822DB690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB694: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DB698: 48B17D91  bl 0x82df3428
	ctx.lr = 0x822DB69C;
	sub_82DF3428(ctx, base);
	// 822DB69C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB6A0: 41820008  beq 0x822db6a8
	if ctx.cr[0].eq {
	pc = 0x822DB6A8; continue 'dispatch;
	}
	// 822DB6A4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822DB6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DB6AC: 48B17D7D  bl 0x82df3428
	ctx.lr = 0x822DB6B0;
	sub_82DF3428(ctx, base);
	// 822DB6B0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 822DB6B4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822DB6B8: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB6BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DB6C0: 8BAB0080  lbz r29, 0x80(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 822DB6C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB6C8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 822DB6CC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 822DB6D0: 419A0024  beq cr6, 0x822db6f4
	if ctx.cr[6].eq {
	pc = 0x822DB6F4; continue 'dispatch;
	}
	// 822DB6D4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822DB6D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DB6DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DB6E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DB6E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DB6E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DB6EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DB6F0: 4082FFE8  bne 0x822db6d8
	if !ctx.cr[0].eq {
	pc = 0x822DB6D8; continue 'dispatch;
	}
	// 822DB6F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822DB6F8: 4BFFDE29  bl 0x822d9520
	ctx.lr = 0x822DB6FC;
	sub_822D9520(ctx, base);
	// 822DB6FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822DB700: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822DB704: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822DB708: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822DB70C: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 822DB710: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 822DB714: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 822DB718: 4BFFF949  bl 0x822db060
	ctx.lr = 0x822DB71C;
	sub_822DB060(ctx, base);
	// 822DB71C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB720: 419A000C  beq cr6, 0x822db72c
	if ctx.cr[6].eq {
	pc = 0x822DB72C; continue 'dispatch;
	}
	// 822DB724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB728: 4BFE5169  bl 0x822c0890
	ctx.lr = 0x822DB72C;
	sub_822C0890(ctx, base);
	// 822DB72C: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB730: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 822DB734: 83E10070  lwz r31, 0x70(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822DB738: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 822DB73C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DB740: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DB744: 4BFE8D1D  bl 0x822c4460
	ctx.lr = 0x822DB748;
	sub_822C4460(ctx, base);
	// 822DB748: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DB74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB750: 419A00D0  beq cr6, 0x822db820
	if ctx.cr[6].eq {
	pc = 0x822DB820; continue 'dispatch;
	}
	// 822DB754: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 822DB758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB75C: 38A004CB  li r5, 0x4cb
	ctx.r[5].s64 = 1227;
	// 822DB760: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 822DB764: 4BFE4C75  bl 0x822c03d8
	ctx.lr = 0x822DB768;
	sub_822C03D8(ctx, base);
	// 822DB768: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB76C: 41820048  beq 0x822db7b4
	if ctx.cr[0].eq {
	pc = 0x822DB7B4; continue 'dispatch;
	}
	// 822DB770: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822DB774: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DB778: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 822DB77C: 419A0024  beq cr6, 0x822db7a0
	if ctx.cr[6].eq {
	pc = 0x822DB7A0; continue 'dispatch;
	}
	// 822DB780: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822DB784: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DB788: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DB78C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DB790: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DB794: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DB798: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DB79C: 4082FFE8  bne 0x822db784
	if !ctx.cr[0].eq {
	pc = 0x822DB784; continue 'dispatch;
	}
	// 822DB7A0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 822DB7A4: 61EF0001  ori r15, r15, 1
	ctx.r[15].u64 = ctx.r[15].u64 | 1;
	// 822DB7A8: 4BFFD521  bl 0x822d8cc8
	ctx.lr = 0x822DB7AC;
	sub_822D8CC8(ctx, base);
	// 822DB7AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB7B0: 48000008  b 0x822db7b8
	pc = 0x822DB7B8; continue 'dispatch;
	// 822DB7B4: 7E3F8B78  mr r31, r17
	ctx.r[31].u64 = ctx.r[17].u64;
	// 822DB7B8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 822DB7BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB7C0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 822DB7C4: 4BFFEDDD  bl 0x822da5a0
	ctx.lr = 0x822DB7C8;
	sub_822DA5A0(ctx, base);
	// 822DB7C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DB7CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB7D0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 822DB7D4: 4BFE482D  bl 0x822c0000
	ctx.lr = 0x822DB7D8;
	sub_822C0000(ctx, base);
	// 822DB7D8: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB7DC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822DB7E0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 822DB7E4: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 822DB7E8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DB7EC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DB7F0: 4BFE8C71  bl 0x822c4460
	ctx.lr = 0x822DB7F4;
	sub_822C4460(ctx, base);
	// 822DB7F4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822DB7F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB7FC: 419A0008  beq cr6, 0x822db804
	if ctx.cr[6].eq {
	pc = 0x822DB804; continue 'dispatch;
	}
	// 822DB800: 4BFE5091  bl 0x822c0890
	ctx.lr = 0x822DB804;
	sub_822C0890(ctx, base);
	// 822DB804: 55EB07FF  clrlwi. r11, r15, 0x1f
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB808: 41820018  beq 0x822db820
	if ctx.cr[0].eq {
	pc = 0x822DB820; continue 'dispatch;
	}
	// 822DB80C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822DB810: 55EF003C  rlwinm r15, r15, 0, 0, 0x1e
	ctx.r[15].u64 = ctx.r[15].u32 as u64 & 0xFFFFFFFFu64;
	// 822DB814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB818: 419A0008  beq cr6, 0x822db820
	if ctx.cr[6].eq {
	pc = 0x822DB820; continue 'dispatch;
	}
	// 822DB81C: 4BFE5075  bl 0x822c0890
	ctx.lr = 0x822DB820;
	sub_822C0890(ctx, base);
	// 822DB820: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DB824: 419A000C  beq cr6, 0x822db830
	if ctx.cr[6].eq {
	pc = 0x822DB830; continue 'dispatch;
	}
	// 822DB828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB82C: 4BFE5065  bl 0x822c0890
	ctx.lr = 0x822DB830;
	sub_822C0890(ctx, base);
	// 822DB830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DB834: 48B17BF5  bl 0x82df3428
	ctx.lr = 0x822DB838;
	sub_82DF3428(ctx, base);
	// 822DB838: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 822DB83C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DB840: 419A0008  beq cr6, 0x822db848
	if ctx.cr[6].eq {
	pc = 0x822DB848; continue 'dispatch;
	}
	// 822DB844: 4BFE504D  bl 0x822c0890
	ctx.lr = 0x822DB848;
	sub_822C0890(ctx, base);
	// 822DB848: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822DB84C: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 822DB850: 7F1CA040  cmplw cr6, r28, r20
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[20].u32, &mut ctx.xer);
	// 822DB854: 4198FD74  blt cr6, 0x822db5c8
	if ctx.cr[6].lt {
	pc = 0x822DB5C8; continue 'dispatch;
	}
	// 822DB858: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DB85C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 822DB860: 48ECC924  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB868 size=276
    let mut pc: u32 = 0x822DB868;
    'dispatch: loop {
        match pc {
            0x822DB868 => {
    //   block [0x822DB868..0x822DB97C)
	// 822DB868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB86C: 48ECC8F9  bl 0x831a8164
	ctx.lr = 0x822DB870;
	sub_831A8130(ctx, base);
	// 822DB870: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB874: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB878: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DB87C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822DB880: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822DB884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DB888: 388BA340  addi r4, r11, -0x5cc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23744;
	// 822DB88C: 38A0051C  li r5, 0x51c
	ctx.r[5].s64 = 1308;
	// 822DB890: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 822DB894: 4BFE4B45  bl 0x822c03d8
	ctx.lr = 0x822DB898;
	sub_822C03D8(ctx, base);
	// 822DB898: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DB89C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822DB8A0: 41820038  beq 0x822db8d8
	if ctx.cr[0].eq {
	pc = 0x822DB8D8; continue 'dispatch;
	}
	// 822DB8A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DB8A8: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822DB8AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB8B0: 396BA388  addi r11, r11, -0x5c78
	ctx.r[11].s64 = ctx.r[11].s64 + -23672;
	// 822DB8B4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB8B8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 822DB8BC: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 822DB8C0: 90630010  stw r3, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 822DB8C4: 93A30014  stw r29, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 822DB8C8: 93A30018  stw r29, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 822DB8CC: 93A3001C  stw r29, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 822DB8D0: 93A30020  stw r29, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 822DB8D4: 48000008  b 0x822db8dc
	pc = 0x822DB8DC; continue 'dispatch;
	// 822DB8D8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 822DB8DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB8E0: 409A0010  bne cr6, 0x822db8f0
	if !ctx.cr[6].eq {
	pc = 0x822DB8F0; continue 'dispatch;
	}
	// 822DB8E4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822DB8E8: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822DB8EC: 48000084  b 0x822db970
	pc = 0x822DB970; continue 'dispatch;
	// 822DB8F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DB8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB8F8: 4BFFFB39  bl 0x822db430
	ctx.lr = 0x822DB8FC;
	sub_822DB430(ctx, base);
	// 822DB8FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB900: 40820028  bne 0x822db928
	if !ctx.cr[0].eq {
	pc = 0x822DB928; continue 'dispatch;
	}
	// 822DB904: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822DB908: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DB90C: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822DB910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB914: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB918: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DB91C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DB920: 4E800421  bctrl
	ctx.lr = 0x822DB924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DB924: 4800004C  b 0x822db970
	pc = 0x822DB970; continue 'dispatch;
	// 822DB928: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 822DB92C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 822DB930: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DB934: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 822DB938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB93C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB940: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB944: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822DB948: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DB94C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DB950: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DB954: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822DB958: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DB95C: 4BFFEDD5  bl 0x822da730
	ctx.lr = 0x822DB960;
	sub_822DA730(ctx, base);
	// 822DB960: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DB964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DB968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DB96C: 4BFE4695  bl 0x822c0000
	ctx.lr = 0x822DB970;
	sub_822C0000(ctx, base);
	// 822DB970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DB974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DB978: 48ECC83C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB980 size=76
    let mut pc: u32 = 0x822DB980;
    'dispatch: loop {
        match pc {
            0x822DB980 => {
    //   block [0x822DB980..0x822DB9CC)
	// 822DB980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DB988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DB98C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DB990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB998: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DB99C: 4BFFF9FD  bl 0x822db398
	ctx.lr = 0x822DB9A0;
	sub_822DB398(ctx, base);
	// 822DB9A0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DB9A4: 4182000C  beq 0x822db9b0
	if ctx.cr[0].eq {
	pc = 0x822DB9B0; continue 'dispatch;
	}
	// 822DB9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB9AC: 4BFE48BD  bl 0x822c0268
	ctx.lr = 0x822DB9B0;
	sub_822C0268(ctx, base);
	// 822DB9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DB9B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DB9B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DB9BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DB9C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DB9C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DB9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DB9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DB9D0 size=116
    let mut pc: u32 = 0x822DB9D0;
    'dispatch: loop {
        match pc {
            0x822DB9D0 => {
    //   block [0x822DB9D0..0x822DBA44)
	// 822DB9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DB9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DB9D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DB9DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DB9E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DB9E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DB9E8: 419A0040  beq cr6, 0x822dba28
	if ctx.cr[6].eq {
	pc = 0x822DBA28; continue 'dispatch;
	}
	// 822DB9EC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822DB9F0: 0CDF0000  twi 6, r31, 0
	// 822DB9F4: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 822DB9F8: 2B0B0030  cmplwi cr6, r11, 0x30
	ctx.cr[6].compare_u32(ctx.r[11].u32, 48 as u32, &mut ctx.xer);
	// 822DB9FC: 4098002C  bge cr6, 0x822dba28
	if !ctx.cr[6].lt {
	pc = 0x822DBA28; continue 'dispatch;
	}
	// 822DBA00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DBA04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DBA08: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 822DBA0C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822DBA10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DBA14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822DBA18: 4BFE8899  bl 0x822c42b0
	ctx.lr = 0x822DBA1C;
	sub_822C42B0(ctx, base);
	// 822DBA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DBA20: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 822DBA24: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822DBA28: 1C7F0030  mulli r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 * 48;
	// 822DBA2C: 4BFE4F0D  bl 0x822c0938
	ctx.lr = 0x822DBA30;
	sub_822C0938(ctx, base);
	// 822DBA30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DBA34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DBA38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DBA3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DBA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DBA48 size=320
    let mut pc: u32 = 0x822DBA48;
    'dispatch: loop {
        match pc {
            0x822DBA48 => {
    //   block [0x822DBA48..0x822DBB88)
	// 822DBA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DBA4C: 48ECC715  bl 0x831a8160
	ctx.lr = 0x822DBA50;
	sub_831A8130(ctx, base);
	// 822DBA50: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DBA54: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DBA58: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 822DBA5C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822DBA60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DBA64: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 822DBA68: 388000C0  li r4, 0xc0
	ctx.r[4].s64 = 192;
	// 822DBA6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822DBA70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822DBA74: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822DBA78: 48BC4CB9  bl 0x82ea0730
	ctx.lr = 0x822DBA7C;
	sub_82EA0730(ctx, base);
	// 822DBA7C: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 822DBA80: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822DBA84: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822DBA88: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 822DBA8C: C02AF614  lfs f1, -0x9ec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DBA90: 48C3CF11  bl 0x82f189a0
	ctx.lr = 0x822DBA94;
	sub_82F189A0(ctx, base);
	// 822DBA94: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 822DBA98: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DBA9C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DBAA0: 80FA0008  lwz r7, 8(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBAA4: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 822DBAA8: 80DA0000  lwz r6, 0(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DBB88 size=56
    let mut pc: u32 = 0x822DBB88;
    'dispatch: loop {
        match pc {
            0x822DBB88 => {
    //   block [0x822DBB88..0x822DBBC0)
	// 822DBB88: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DBB8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBB90: 394AA3BC  addi r10, r10, -0x5c44
	ctx.r[10].s64 = ctx.r[10].s64 + -23620;
	// 822DBB94: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822DBB98: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DBB9C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DBBA0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822DBBA4: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822DBBA8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822DBBAC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822DBBB0: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 822DBBB4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822DBBB8: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822DBBBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DBBC0 size=92
    let mut pc: u32 = 0x822DBBC0;
    'dispatch: loop {
        match pc {
            0x822DBBC0 => {
    //   block [0x822DBBC0..0x822DBC1C)
	// 822DBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DBBC4: 48ECC5A1  bl 0x831a8164
	ctx.lr = 0x822DBBC8;
	sub_831A8130(ctx, base);
	// 822DBBC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DBBCC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DBBD0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822DBBD4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822DBBD8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 822DBBDC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 822DBBE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DBBE4: 419A0028  beq cr6, 0x822dbc0c
	if ctx.cr[6].eq {
	pc = 0x822DBC0C; continue 'dispatch;
	}
	// 822DBBE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DBBEC: 419A0014  beq cr6, 0x822dbc00
	if ctx.cr[6].eq {
	pc = 0x822DBC00; continue 'dispatch;
	}
	// 822DBBF0: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822DBBF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DBBF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DBBFC: 48ECC915  bl 0x831a8510
	ctx.lr = 0x822DBC00;
	sub_831A8510(ctx, base);
	// 822DBC00: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822DBC04: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 822DBC08: 4082FFE0  bne 0x822dbbe8
	if !ctx.cr[0].eq {
	pc = 0x822DBBE8; continue 'dispatch;
	}
	// 822DBC0C: 1D7F0030  mulli r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 * 48;
	// 822DBC10: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822DBC14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DBC18: 48ECC59C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DBC20 size=188
    let mut pc: u32 = 0x822DBC20;
    'dispatch: loop {
        match pc {
            0x822DBC20 => {
    //   block [0x822DBC20..0x822DBCDC)
	// 822DBC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DBC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DBC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DBC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DBC30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DBC34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DBC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBC3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DBC40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DBC44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DBC48: 4BFE4CF1  bl 0x822c0938
	ctx.lr = 0x822DBC4C;
	sub_822C0938(ctx, base);
	// 822DBC4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DBC50: 41820028  beq 0x822dbc78
	if ctx.cr[0].eq {
	pc = 0x822DBC78; continue 'dispatch;
	}
	// 822DBC54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DBC58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DBC5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DBC60: 392BA394  addi r9, r11, -0x5c6c
	ctx.r[9].s64 = ctx.r[11].s64 + -23660;
	// 822DBC64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DBC68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DBC6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DBC70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DBC74: 48000008  b 0x822dbc7c
	pc = 0x822DBC7C; continue 'dispatch;
	// 822DBC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBC7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DBC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DBC84: 409A003C  bne cr6, 0x822dbcc0
	if !ctx.cr[6].eq {
	pc = 0x822DBCC0; continue 'dispatch;
	}
	// 822DBC88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DBC8C: 419A0014  beq cr6, 0x822dbca0
	if ctx.cr[6].eq {
	pc = 0x822DBCA0; continue 'dispatch;
	}
	// 822DBC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DBC94: 4818E36D  bl 0x8246a000
	ctx.lr = 0x822DBC98;
	sub_8246A000(ctx, base);
	// 822DBC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DBC9C: 4BFE45CD  bl 0x822c0268
	ctx.lr = 0x822DBCA0;
	sub_822C0268(ctx, base);
	// 822DBCA0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DBCA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DBCA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DBCAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DBCB0: 816B324C  lwz r11, 0x324c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12876 as u32) ) } as u64;
	// 822DBCB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DBCB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DBCBC: 4BFE4345  bl 0x822c0000
	ctx.lr = 0x822DBCC0;
	sub_822C0000(ctx, base);
	// 822DBCC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DBCC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DBCC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DBCCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DBCD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DBCD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DBCD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DBCE0 size=188
    let mut pc: u32 = 0x822DBCE0;
    'dispatch: loop {
        match pc {
            0x822DBCE0 => {
    //   block [0x822DBCE0..0x822DBD9C)
	// 822DBCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DBCE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DBCE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DBCEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DBCF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DBCF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DBCF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBCFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DBD00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DBD04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DBD08: 4BFE4C31  bl 0x822c0938
	ctx.lr = 0x822DBD0C;
	sub_822C0938(ctx, base);
	// 822DBD0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DBD10: 41820028  beq 0x822dbd38
	if ctx.cr[0].eq {
	pc = 0x822DBD38; continue 'dispatch;
	}
	// 822DBD14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DBD18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DBD1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DBD20: 392BA3A8  addi r9, r11, -0x5c58
	ctx.r[9].s64 = ctx.r[11].s64 + -23640;
	// 822DBD24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DBD28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DBD2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DBD30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DBD34: 48000008  b 0x822dbd3c
	pc = 0x822DBD3C; continue 'dispatch;
	// 822DBD38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBD3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DBD40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DBD44: 409A003C  bne cr6, 0x822dbd80
	if !ctx.cr[6].eq {
	pc = 0x822DBD80; continue 'dispatch;
	}
	// 822DBD48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DBD4C: 419A0014  beq cr6, 0x822dbd60
	if ctx.cr[6].eq {
	pc = 0x822DBD60; continue 'dispatch;
	}
	// 822DBD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DBD54: 4818E2AD  bl 0x8246a000
	ctx.lr = 0x822DBD58;
	sub_8246A000(ctx, base);
	// 822DBD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DBD5C: 4BFE450D  bl 0x822c0268
	ctx.lr = 0x822DBD60;
	sub_822C0268(ctx, base);
	// 822DBD60: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DBD64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DBD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DBD6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DBD70: 816B324C  lwz r11, 0x324c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12876 as u32) ) } as u64;
	// 822DBD74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DBD78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DBD7C: 4BFE4285  bl 0x822c0000
	ctx.lr = 0x822DBD80;
	sub_822C0000(ctx, base);
	// 822DBD80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DBD84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DBD88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DBD8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DBD90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DBD94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DBD98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DBDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DBDA0 size=768
    let mut pc: u32 = 0x822DBDA0;
    'dispatch: loop {
        match pc {
            0x822DBDA0 => {
    //   block [0x822DBDA0..0x822DC0A0)
	// 822DBDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DBDA4: 48ECC3B9  bl 0x831a815c
	ctx.lr = 0x822DBDA8;
	sub_831A8130(ctx, base);
	// 822DBDA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822DBDAC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DBDB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DBDB4: C3E60000  lfs f31, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822DBDB8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822DBDBC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 822DBDC0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DBDC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DBDC8: 409A000C  bne cr6, 0x822dbdd4
	if !ctx.cr[6].eq {
	pc = 0x822DBDD4; continue 'dispatch;
	}
	// 822DBDCC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822DBDD0: 48000010  b 0x822dbde0
	pc = 0x822DBDE0; continue 'dispatch;
	// 822DBDD4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DBDD8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DBDDC: 7D681670  srawi r8, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBDE0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822DBDE4: 419A02B0  beq cr6, 0x822dc094
	if ctx.cr[6].eq {
	pc = 0x822DC094; continue 'dispatch;
	}
	// 822DBDE8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DBDEC: 409A000C  bne cr6, 0x822dbdf8
	if !ctx.cr[6].eq {
	pc = 0x822DBDF8; continue 'dispatch;
	}
	// 822DBDF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBDF4: 48000010  b 0x822dbe04
	pc = 0x822DBE04; continue 'dispatch;
	// 822DBDF8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBDFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DBE00: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBE04: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 822DBE08: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 822DBE0C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DBE10: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822DBE14: 4098000C  bge cr6, 0x822dbe20
	if !ctx.cr[6].lt {
	pc = 0x822DBE20; continue 'dispatch;
	}
	// 822DBE18: 488DBF09  bl 0x82bb7d20
	ctx.lr = 0x822DBE1C;
	sub_82BB7D20(ctx, base);
	// 822DBE1C: 48000278  b 0x822dc094
	pc = 0x822DC094; continue 'dispatch;
	// 822DBE20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DBE24: 409A000C  bne cr6, 0x822dbe30
	if !ctx.cr[6].eq {
	pc = 0x822DBE30; continue 'dispatch;
	}
	// 822DBE28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBE2C: 48000010  b 0x822dbe3c
	pc = 0x822DBE3C; continue 'dispatch;
	// 822DBE30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBE34: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DBE38: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBE3C: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DBE40: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DBE44: 40980148  bge cr6, 0x822dbf8c
	if !ctx.cr[6].lt {
	pc = 0x822DBF8C; continue 'dispatch;
	}
	// 822DBE48: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBE4C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DBE50: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822DBE54: 4098000C  bge cr6, 0x822dbe60
	if !ctx.cr[6].lt {
	pc = 0x822DBE60; continue 'dispatch;
	}
	// 822DBE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBE5C: 48000008  b 0x822dbe64
	pc = 0x822DBE64; continue 'dispatch;
	// 822DBE60: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 822DBE64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DBE68: 409A000C  bne cr6, 0x822dbe74
	if !ctx.cr[6].eq {
	pc = 0x822DBE74; continue 'dispatch;
	}
	// 822DBE6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DBE70: 48000010  b 0x822dbe80
	pc = 0x822DBE80; continue 'dispatch;
	// 822DBE74: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBE78: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822DBE7C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 822DBE80: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 822DBE84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DBE88: 40980024  bge cr6, 0x822dbeac
	if !ctx.cr[6].lt {
	pc = 0x822DBEAC; continue 'dispatch;
	}
	// 822DBE8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DBE90: 409A000C  bne cr6, 0x822dbe9c
	if !ctx.cr[6].eq {
	pc = 0x822DBE9C; continue 'dispatch;
	}
	// 822DBE94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBE98: 48000010  b 0x822dbea8
	pc = 0x822DBEA8; continue 'dispatch;
	// 822DBE9C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBEA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DBEA4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBEA8: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DBEAC: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DBEB0: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822DBEB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DBEB8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DBEBC: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 822DBEC0: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822DBEC4: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DBEC8: 48B16201  bl 0x82df20c8
	ctx.lr = 0x822DBECC;
	sub_82DF20C8(ctx, base);
	// 822DBECC: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DBED0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DBED4: 7D65D050  subf r11, r5, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[5].s64;
	// 822DBED8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DBEDC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822DBEE0: 7FE6F214  add r31, r6, r30
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[30].u64;
	// 822DBEE4: 4182000C  beq 0x822dbef0
	if ctx.cr[0].eq {
	pc = 0x822DBEF0; continue 'dispatch;
	}
	// 822DBEE8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822DBEEC: 48ECCE1D  bl 0x831a8d08
	ctx.lr = 0x822DBEF0;
	sub_831A8D08(ctx, base);
	// 822DBEF0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822DBEF4: 419A0020  beq cr6, 0x822dbf14
	if ctx.cr[6].eq {
	pc = 0x822DBF14; continue 'dispatch;
	}
	// 822DBEF8: D3FF0000  stfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DBEFC: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DBF04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822DBF08: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822DBF0C: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822DBF10: 48ECCA89  bl 0x831a8998
	ctx.lr = 0x822DBF14;
	sub_831A8998(ctx, base);
	// 822DBF14: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBF18: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 822DBF1C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DBF20: 4182001C  beq 0x822dbf3c
	if ctx.cr[0].eq {
	pc = 0x822DBF3C; continue 'dispatch;
	}
	// 822DBF24: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822DBF28: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBF2C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DBF30: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DBF34: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822DBF38: 48ECCDD1  bl 0x831a8d08
	ctx.lr = 0x822DBF3C;
	sub_831A8D08(ctx, base);
	// 822DBF3C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DBF40: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DBF44: 409A000C  bne cr6, 0x822dbf50
	if !ctx.cr[6].eq {
	pc = 0x822DBF50; continue 'dispatch;
	}
	// 822DBF48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DBF4C: 48000010  b 0x822dbf5c
	pc = 0x822DBF5C; continue 'dispatch;
	// 822DBF50: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBF54: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 822DBF58: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBF5C: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DBF60: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DBF64: 419A000C  beq cr6, 0x822dbf70
	if ctx.cr[6].eq {
	pc = 0x822DBF70; continue 'dispatch;
	}
	// 822DBF68: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DBF6C: 48B1621D  bl 0x82df2188
	ctx.lr = 0x822DBF70;
	sub_82DF2188(ctx, base);
	// 822DBF70: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBF74: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DBF78: 7D5BF214  add r10, r27, r30
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 822DBF7C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822DBF80: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822DBF84: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DBF88: 4800010C  b 0x822dc094
	pc = 0x822DC094; continue 'dispatch;
	// 822DBF8C: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBF90: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 822DBF94: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBF98: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822DBF9C: 40980084  bge cr6, 0x822dc020
	if !ctx.cr[6].lt {
	pc = 0x822DC020; continue 'dispatch;
	}
	// 822DBFA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DBFA4: 4182001C  beq 0x822dbfc0
	if ctx.cr[0].eq {
	pc = 0x822DBFC0; continue 'dispatch;
	}
	// 822DBFA8: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822DBFAC: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBFB0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DBFB4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DBFB8: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 822DBFBC: 48ECCD4D  bl 0x831a8d08
	ctx.lr = 0x822DBFC0;
	sub_831A8D08(ctx, base);
	// 822DBFC0: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBFC4: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 822DBFC8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DBFCC: 7D6BC851  subf. r11, r11, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DBFD0: 4182001C  beq 0x822dbfec
	if ctx.cr[0].eq {
	pc = 0x822DBFEC; continue 'dispatch;
	}
	// 822DBFD4: D3E40000  stfs f31, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DBFD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DBFDC: 38640004  addi r3, r4, 4
	ctx.r[3].s64 = ctx.r[4].s64 + 4;
	// 822DBFE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822DBFE4: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 822DBFE8: 48ECC9B1  bl 0x831a8998
	ctx.lr = 0x822DBFEC;
	sub_831A8998(ctx, base);
	// 822DBFEC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DBFF0: 572A103A  slwi r10, r25, 2
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DBFF4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822DBFF8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DBFFC: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822DC000: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC004: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC008: 419A008C  beq cr6, 0x822dc094
	if ctx.cr[6].eq {
	pc = 0x822DC094; continue 'dispatch;
	}
	// 822DC00C: D3E90000  stfs f31, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DC010: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 822DC014: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC018: 409AFFF4  bne cr6, 0x822dc00c
	if !ctx.cr[6].eq {
	pc = 0x822DC00C; continue 'dispatch;
	}
	// 822DC01C: 48000078  b 0x822dc094
	pc = 0x822DC094; continue 'dispatch;
	// 822DC020: 573B103A  slwi r27, r25, 2
	ctx.r[27].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DC024: 7FDBF850  subf r30, r27, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 822DC028: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 822DC02C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC030: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822DC034: 7F86FA14  add r28, r6, r31
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 822DC038: 41820014  beq 0x822dc04c
	if ctx.cr[0].eq {
	pc = 0x822DC04C; continue 'dispatch;
	}
	// 822DC03C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DC040: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822DC044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC048: 48ECCCC1  bl 0x831a8d08
	ctx.lr = 0x822DC04C;
	sub_831A8D08(ctx, base);
	// 822DC04C: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 822DC050: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822DC054: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC058: 4081001C  ble 0x822dc074
	if !ctx.cr[0].gt {
	pc = 0x822DC074; continue 'dispatch;
	}
	// 822DC05C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC060: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DC064: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 822DC068: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822DC06C: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 822DC070: 48ECCC99  bl 0x831a8d08
	ctx.lr = 0x822DC074;
	sub_831A8D08(ctx, base);
	// 822DC074: 7D5BD214  add r10, r27, r26
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 822DC078: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822DC07C: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC080: 419A0014  beq cr6, 0x822dc094
	if ctx.cr[6].eq {
	pc = 0x822DC094; continue 'dispatch;
	}
	// 822DC084: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DC088: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DC08C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC090: 409AFFF4  bne cr6, 0x822dc084
	if !ctx.cr[6].eq {
	pc = 0x822DC084; continue 'dispatch;
	}
	// 822DC094: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DC098: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822DC09C: 48ECC110  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC0A0 size=760
    let mut pc: u32 = 0x822DC0A0;
    'dispatch: loop {
        match pc {
            0x822DC0A0 => {
    //   block [0x822DC0A0..0x822DC398)
	// 822DC0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC0A4: 48ECC0B5  bl 0x831a8158
	ctx.lr = 0x822DC0A8;
	sub_831A8130(ctx, base);
	// 822DC0A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC0AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DC0B0: A3060000  lhz r24, 0(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DC0B4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822DC0B8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 822DC0BC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC0C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DC0C4: 409A000C  bne cr6, 0x822dc0d0
	if !ctx.cr[6].eq {
	pc = 0x822DC0D0; continue 'dispatch;
	}
	// 822DC0C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822DC0CC: 48000010  b 0x822dc0dc
	pc = 0x822DC0DC; continue 'dispatch;
	// 822DC0D0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DC0D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DC0D8: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC0DC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822DC0E0: 419A02B0  beq cr6, 0x822dc390
	if ctx.cr[6].eq {
	pc = 0x822DC390; continue 'dispatch;
	}
	// 822DC0E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DC0E8: 409A000C  bne cr6, 0x822dc0f4
	if !ctx.cr[6].eq {
	pc = 0x822DC0F4; continue 'dispatch;
	}
	// 822DC0EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC0F0: 48000010  b 0x822dc100
	pc = 0x822DC100; continue 'dispatch;
	// 822DC0F4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC0F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DC0FC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC100: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 822DC104: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 822DC108: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC10C: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822DC110: 4098000C  bge cr6, 0x822dc11c
	if !ctx.cr[6].lt {
	pc = 0x822DC11C; continue 'dispatch;
	}
	// 822DC114: 488DBC0D  bl 0x82bb7d20
	ctx.lr = 0x822DC118;
	sub_82BB7D20(ctx, base);
	// 822DC118: 48000278  b 0x822dc390
	pc = 0x822DC390; continue 'dispatch;
	// 822DC11C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DC120: 409A000C  bne cr6, 0x822dc12c
	if !ctx.cr[6].eq {
	pc = 0x822DC12C; continue 'dispatch;
	}
	// 822DC124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC128: 48000010  b 0x822dc138
	pc = 0x822DC138; continue 'dispatch;
	// 822DC12C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC130: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DC134: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC138: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DC13C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC140: 40980148  bge cr6, 0x822dc288
	if !ctx.cr[6].lt {
	pc = 0x822DC288; continue 'dispatch;
	}
	// 822DC144: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC148: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC14C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822DC150: 4098000C  bge cr6, 0x822dc15c
	if !ctx.cr[6].lt {
	pc = 0x822DC15C; continue 'dispatch;
	}
	// 822DC154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC158: 48000008  b 0x822dc160
	pc = 0x822DC160; continue 'dispatch;
	// 822DC15C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 822DC160: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DC164: 409A000C  bne cr6, 0x822dc170
	if !ctx.cr[6].eq {
	pc = 0x822DC170; continue 'dispatch;
	}
	// 822DC168: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DC16C: 48000010  b 0x822dc17c
	pc = 0x822DC17C; continue 'dispatch;
	// 822DC170: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC174: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822DC178: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 822DC17C: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 822DC180: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC184: 40980024  bge cr6, 0x822dc1a8
	if !ctx.cr[6].lt {
	pc = 0x822DC1A8; continue 'dispatch;
	}
	// 822DC188: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822DC18C: 409A000C  bne cr6, 0x822dc198
	if !ctx.cr[6].eq {
	pc = 0x822DC198; continue 'dispatch;
	}
	// 822DC190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC194: 48000010  b 0x822dc1a4
	pc = 0x822DC1A4; continue 'dispatch;
	// 822DC198: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC19C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822DC1A0: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC1A4: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DC1A8: 557B083C  slwi r27, r11, 1
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DC1AC: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822DC1B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DC1B4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DC1B8: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 822DC1BC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822DC1C0: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC1C4: 48B15F05  bl 0x82df20c8
	ctx.lr = 0x822DC1C8;
	sub_82DF20C8(ctx, base);
	// 822DC1C8: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC1CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC1D0: 7D65D050  subf r11, r5, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[5].s64;
	// 822DC1D4: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC1D8: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822DC1DC: 7FC6FA14  add r30, r6, r31
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 822DC1E0: 4182000C  beq 0x822dc1ec
	if ctx.cr[0].eq {
	pc = 0x822DC1EC; continue 'dispatch;
	}
	// 822DC1E4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822DC1E8: 48ECCB21  bl 0x831a8d08
	ctx.lr = 0x822DC1EC;
	sub_831A8D08(ctx, base);
	// 822DC1EC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822DC1F0: 419A0020  beq cr6, 0x822dc210
	if ctx.cr[6].eq {
	pc = 0x822DC210; continue 'dispatch;
	}
	// 822DC1F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822DC1F8: 28190000  cmplwi r25, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DC1FC: 41820014  beq 0x822dc210
	if ctx.cr[0].eq {
	pc = 0x822DC210; continue 'dispatch;
	}
	// 822DC200: 7F2903A6  mtctr r25
	ctx.ctr.u64 = ctx.r[25].u64;
	// 822DC204: B30B0000  sth r24, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822DC208: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822DC20C: 4200FFF8  bdnz 0x822dc204
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822DC204; continue 'dispatch;
	}
	// 822DC210: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC214: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 822DC218: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC21C: 4182001C  beq 0x822dc238
	if ctx.cr[0].eq {
	pc = 0x822DC238; continue 'dispatch;
	}
	// 822DC220: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822DC224: 572B083C  slwi r11, r25, 1
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC228: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DC22C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DC230: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822DC234: 48ECCAD5  bl 0x831a8d08
	ctx.lr = 0x822DC238;
	sub_831A8D08(ctx, base);
	// 822DC238: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC23C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC240: 409A000C  bne cr6, 0x822dc24c
	if !ctx.cr[6].eq {
	pc = 0x822DC24C; continue 'dispatch;
	}
	// 822DC244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC248: 48000010  b 0x822dc258
	pc = 0x822DC258; continue 'dispatch;
	// 822DC24C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC250: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 822DC254: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC258: 7FCBCA14  add r30, r11, r25
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 822DC25C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC260: 419A000C  beq cr6, 0x822dc26c
	if ctx.cr[6].eq {
	pc = 0x822DC26C; continue 'dispatch;
	}
	// 822DC264: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC268: 48B15F21  bl 0x82df2188
	ctx.lr = 0x822DC26C;
	sub_82DF2188(ctx, base);
	// 822DC26C: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC270: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822DC274: 7D5BFA14  add r10, r27, r31
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 822DC278: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 822DC27C: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822DC280: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC284: 4800010C  b 0x822dc390
	pc = 0x822DC390; continue 'dispatch;
	// 822DC288: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC28C: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 822DC290: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC294: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 822DC298: 40980084  bge cr6, 0x822dc31c
	if !ctx.cr[6].lt {
	pc = 0x822DC31C; continue 'dispatch;
	}
	// 822DC29C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DC2A0: 4182001C  beq 0x822dc2bc
	if ctx.cr[0].eq {
	pc = 0x822DC2BC; continue 'dispatch;
	}
	// 822DC2A4: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822DC2A8: 572B083C  slwi r11, r25, 1
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC2AC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DC2B0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DC2B4: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 822DC2B8: 48ECCA51  bl 0x831a8d08
	ctx.lr = 0x822DC2BC;
	sub_831A8D08(ctx, base);
	// 822DC2BC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC2C0: 7D7A5050  subf r11, r26, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	// 822DC2C4: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC2C8: 7D6BC851  subf. r11, r11, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC2CC: 4182001C  beq 0x822dc2e8
	if ctx.cr[0].eq {
	pc = 0x822DC2E8; continue 'dispatch;
	}
	// 822DC2D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DC2D4: 41820014  beq 0x822dc2e8
	if ctx.cr[0].eq {
	pc = 0x822DC2E8; continue 'dispatch;
	}
	// 822DC2D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DC2DC: B30A0000  sth r24, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822DC2E0: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822DC2E4: 4200FFF8  bdnz 0x822dc2dc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822DC2DC; continue 'dispatch;
	}
	// 822DC2E8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC2EC: 572A083C  slwi r10, r25, 1
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822DC2F0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 822DC2F4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822DC2F8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822DC2FC: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC300: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC304: 419A008C  beq cr6, 0x822dc390
	if ctx.cr[6].eq {
	pc = 0x822DC390; continue 'dispatch;
	}
	// 822DC308: B3090000  sth r24, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822DC30C: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 822DC310: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC314: 409AFFF4  bne cr6, 0x822dc308
	if !ctx.cr[6].eq {
	pc = 0x822DC308; continue 'dispatch;
	}
	// 822DC318: 48000078  b 0x822dc390
	pc = 0x822DC390; continue 'dispatch;
	// 822DC31C: 573B083C  slwi r27, r25, 1
	ctx.r[27].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DC320: 7FDBF850  subf r30, r27, r31
	ctx.r[30].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 822DC324: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 822DC328: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC32C: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 822DC330: 7F86FA14  add r28, r6, r31
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 822DC334: 41820014  beq 0x822dc348
	if ctx.cr[0].eq {
	pc = 0x822DC348; continue 'dispatch;
	}
	// 822DC338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DC33C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822DC340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC344: 48ECC9C5  bl 0x831a8d08
	ctx.lr = 0x822DC348;
	sub_831A8D08(ctx, base);
	// 822DC348: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 822DC34C: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822DC350: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC354: 4081001C  ble 0x822dc370
	if !ctx.cr[0].gt {
	pc = 0x822DC370; continue 'dispatch;
	}
	// 822DC358: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC35C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822DC360: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 822DC364: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822DC368: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 822DC36C: 48ECC99D  bl 0x831a8d08
	ctx.lr = 0x822DC370;
	sub_831A8D08(ctx, base);
	// 822DC370: 7D5BD214  add r10, r27, r26
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 822DC374: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822DC378: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC37C: 419A0014  beq cr6, 0x822dc390
	if ctx.cr[6].eq {
	pc = 0x822DC390; continue 'dispatch;
	}
	// 822DC380: B30B0000  sth r24, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 822DC384: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 822DC388: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822DC38C: 409AFFF4  bne cr6, 0x822dc380
	if !ctx.cr[6].eq {
	pc = 0x822DC380; continue 'dispatch;
	}
	// 822DC390: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DC394: 48ECBE14  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DC398 size=244
    let mut pc: u32 = 0x822DC398;
    'dispatch: loop {
        match pc {
            0x822DC398 => {
    //   block [0x822DC398..0x822DC48C)
	// 822DC398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC39C: 48ECBDC9  bl 0x831a8164
	ctx.lr = 0x822DC3A0;
	sub_831A8130(ctx, base);
	// 822DC3A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC3A4: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 822DC3A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC3AC: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 822DC3B0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC3B4: 4099000C  ble cr6, 0x822dc3c0
	if !ctx.cr[6].gt {
	pc = 0x822DC3C0; continue 'dispatch;
	}
	// 822DC3B8: 488DB969  bl 0x82bb7d20
	ctx.lr = 0x822DC3BC;
	sub_82BB7D20(ctx, base);
	// 822DC3BC: 480000C8  b 0x822dc484
	pc = 0x822DC484; continue 'dispatch;
	// 822DC3C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC3C8: 419A0010  beq cr6, 0x822dc3d8
	if ctx.cr[6].eq {
	pc = 0x822DC3D8; continue 'dispatch;
	}
	// 822DC3CC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DC3D0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC3D4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DC3D8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 822DC3DC: 409800A8  bge cr6, 0x822dc484
	if !ctx.cr[6].lt {
	pc = 0x822DC484; continue 'dispatch;
	}
	// 822DC3E0: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822DC3E4: 549B103A  slwi r27, r4, 2
	ctx.r[27].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DC3E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DC3EC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DC3F0: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 822DC3F4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822DC3F8: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC3FC: 48B15CCD  bl 0x82df20c8
	ctx.lr = 0x822DC400;
	sub_82DF20C8(ctx, base);
	// 822DC400: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC404: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC408: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DC40C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 822DC410: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822DC414: 419A0028  beq cr6, 0x822dc43c
	if ctx.cr[6].eq {
	pc = 0x822DC43C; continue 'dispatch;
	}
	// 822DC418: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 822DC41C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DC420: 419A000C  beq cr6, 0x822dc42c
	if ctx.cr[6].eq {
	pc = 0x822DC42C; continue 'dispatch;
	}
	// 822DC424: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DC428: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DC42C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822DC430: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DC434: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822DC438: 409AFFE4  bne cr6, 0x822dc41c
	if !ctx.cr[6].eq {
	pc = 0x822DC41C; continue 'dispatch;
	}
	// 822DC43C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC440: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC444: 409A000C  bne cr6, 0x822dc450
	if !ctx.cr[6].eq {
	pc = 0x822DC450; continue 'dispatch;
	}
	// 822DC448: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822DC44C: 48000010  b 0x822dc45c
	pc = 0x822DC45C; continue 'dispatch;
	// 822DC450: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC454: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 822DC458: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DC45C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC460: 419A000C  beq cr6, 0x822dc46c
	if ctx.cr[6].eq {
	pc = 0x822DC46C; continue 'dispatch;
	}
	// 822DC464: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC468: 48B15D21  bl 0x82df2188
	ctx.lr = 0x822DC46C;
	sub_82DF2188(ctx, base);
	// 822DC46C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC470: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DC474: 7D5BF214  add r10, r27, r30
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 822DC478: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822DC47C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822DC480: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC484: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DC488: 48ECBD2C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC490 size=244
    let mut pc: u32 = 0x822DC490;
    'dispatch: loop {
        match pc {
            0x822DC490 => {
    //   block [0x822DC490..0x822DC584)
	// 822DC490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC494: 48ECBCD1  bl 0x831a8164
	ctx.lr = 0x822DC498;
	sub_831A8130(ctx, base);
	// 822DC498: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC49C: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 822DC4A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC4A4: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 822DC4A8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC4AC: 4099000C  ble cr6, 0x822dc4b8
	if !ctx.cr[6].gt {
	pc = 0x822DC4B8; continue 'dispatch;
	}
	// 822DC4B0: 488DB871  bl 0x82bb7d20
	ctx.lr = 0x822DC4B4;
	sub_82BB7D20(ctx, base);
	// 822DC4B4: 480000C8  b 0x822dc57c
	pc = 0x822DC57C; continue 'dispatch;
	// 822DC4B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC4C0: 419A0010  beq cr6, 0x822dc4d0
	if ctx.cr[6].eq {
	pc = 0x822DC4D0; continue 'dispatch;
	}
	// 822DC4C4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DC4C8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC4CC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC4D0: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 822DC4D4: 409800A8  bge cr6, 0x822dc57c
	if !ctx.cr[6].lt {
	pc = 0x822DC57C; continue 'dispatch;
	}
	// 822DC4D8: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822DC4DC: 549B083C  slwi r27, r4, 1
	ctx.r[27].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 822DC4E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DC4E4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DC4E8: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 822DC4EC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822DC4F0: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC4F4: 48B15BD5  bl 0x82df20c8
	ctx.lr = 0x822DC4F8;
	sub_82DF20C8(ctx, base);
	// 822DC4F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC4FC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC500: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DC504: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 822DC508: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822DC50C: 419A0028  beq cr6, 0x822dc534
	if ctx.cr[6].eq {
	pc = 0x822DC534; continue 'dispatch;
	}
	// 822DC510: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 822DC514: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DC518: 419A000C  beq cr6, 0x822dc524
	if ctx.cr[6].eq {
	pc = 0x822DC524; continue 'dispatch;
	}
	// 822DC51C: 7D0B522E  lhzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822DC520: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 822DC524: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 822DC528: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DC52C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822DC530: 409AFFE4  bne cr6, 0x822dc514
	if !ctx.cr[6].eq {
	pc = 0x822DC514; continue 'dispatch;
	}
	// 822DC534: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC538: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC53C: 409A000C  bne cr6, 0x822dc548
	if !ctx.cr[6].eq {
	pc = 0x822DC548; continue 'dispatch;
	}
	// 822DC540: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822DC544: 48000010  b 0x822dc554
	pc = 0x822DC554; continue 'dispatch;
	// 822DC548: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC54C: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 822DC550: 7D7D0E70  srawi r29, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC554: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822DC558: 419A000C  beq cr6, 0x822dc564
	if ctx.cr[6].eq {
	pc = 0x822DC564; continue 'dispatch;
	}
	// 822DC55C: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822DC560: 48B15C29  bl 0x82df2188
	ctx.lr = 0x822DC564;
	sub_82DF2188(ctx, base);
	// 822DC564: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC568: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822DC56C: 7D5BF214  add r10, r27, r30
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 822DC570: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822DC574: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822DC578: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC57C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DC580: 48ECBC34  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC588 size=100
    let mut pc: u32 = 0x822DC588;
    'dispatch: loop {
        match pc {
            0x822DC588 => {
    //   block [0x822DC588..0x822DC5EC)
	// 822DC588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DC594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DC598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC5A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DC5A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC5AC: 419A0018  beq cr6, 0x822dc5c4
	if ctx.cr[6].eq {
	pc = 0x822DC5C4; continue 'dispatch;
	}
	// 822DC5B0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC5B4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC5B8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC5BC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822DC5C0: 41990008  bgt cr6, 0x822dc5c8
	if ctx.cr[6].gt {
	pc = 0x822DC5C8; continue 'dispatch;
	}
	// 822DC5C4: 481AE2B5  bl 0x8248a878
	ctx.lr = 0x822DC5C8;
	sub_8248A878(ctx, base);
	// 822DC5C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC5CC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC5D0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DC5D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC5D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC5DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC5E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DC5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DC5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC5F0 size=108
    let mut pc: u32 = 0x822DC5F0;
    'dispatch: loop {
        match pc {
            0x822DC5F0 => {
    //   block [0x822DC5F0..0x822DC65C)
	// 822DC5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC5F4: 48ECBB79  bl 0x831a816c
	ctx.lr = 0x822DC5F8;
	sub_831A8130(ctx, base);
	// 822DC5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC5FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DC600: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DC604: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822DC608: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC610: 419A0014  beq cr6, 0x822dc624
	if ctx.cr[6].eq {
	pc = 0x822DC624; continue 'dispatch;
	}
	// 822DC614: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC618: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC61C: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DC620: 4082000C  bne 0x822dc62c
	if !ctx.cr[0].eq {
	pc = 0x822DC62C; continue 'dispatch;
	}
	// 822DC624: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822DC628: 4800000C  b 0x822dc634
	pc = 0x822DC634; continue 'dispatch;
	// 822DC62C: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 822DC630: 7D7D1670  srawi r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DC634: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822DC638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC63C: 4BFFF765  bl 0x822dbda0
	ctx.lr = 0x822DC640;
	sub_822DBDA0(ctx, base);
	// 822DC640: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC644: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DC64C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DC650: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DC654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC658: 48ECBB64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC660 size=108
    let mut pc: u32 = 0x822DC660;
    'dispatch: loop {
        match pc {
            0x822DC660 => {
    //   block [0x822DC660..0x822DC6CC)
	// 822DC660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC664: 48ECBB09  bl 0x831a816c
	ctx.lr = 0x822DC668;
	sub_831A8130(ctx, base);
	// 822DC668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC66C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DC670: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DC674: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822DC678: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC680: 419A0014  beq cr6, 0x822dc694
	if ctx.cr[6].eq {
	pc = 0x822DC694; continue 'dispatch;
	}
	// 822DC684: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC688: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC68C: 7D4A0E71  srawi. r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822DC690: 4082000C  bne 0x822dc69c
	if !ctx.cr[0].eq {
	pc = 0x822DC69C; continue 'dispatch;
	}
	// 822DC694: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822DC698: 4800000C  b 0x822dc6a4
	pc = 0x822DC6A4; continue 'dispatch;
	// 822DC69C: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 822DC6A0: 7D7D0E70  srawi r29, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC6A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822DC6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC6AC: 4BFFF9F5  bl 0x822dc0a0
	ctx.lr = 0x822DC6B0;
	sub_822DC0A0(ctx, base);
	// 822DC6B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC6B4: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822DC6B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DC6BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822DC6C0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DC6C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC6C8: 48ECBAF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC6D0 size=144
    let mut pc: u32 = 0x822DC6D0;
    'dispatch: loop {
        match pc {
            0x822DC6D0 => {
    //   block [0x822DC6D0..0x822DC760)
	// 822DC6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC6D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC6D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DC6DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DC6E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC6E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC6E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DC6EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DC6F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DC6F4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822DC6F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822DC6FC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822DC700: 409A000C  bne cr6, 0x822dc70c
	if !ctx.cr[6].eq {
	pc = 0x822DC70C; continue 'dispatch;
	}
	// 822DC704: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DC708: 48000040  b 0x822dc748
	pc = 0x822DC748; continue 'dispatch;
	// 822DC70C: 3D600555  lis r11, 0x555
	ctx.r[11].s64 = 89456640;
	// 822DC710: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 822DC714: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC718: 4099000C  ble cr6, 0x822dc724
	if !ctx.cr[6].gt {
	pc = 0x822DC724; continue 'dispatch;
	}
	// 822DC71C: 488DB605  bl 0x82bb7d20
	ctx.lr = 0x822DC720;
	sub_82BB7D20(ctx, base);
	// 822DC720: 48000024  b 0x822dc744
	pc = 0x822DC744; continue 'dispatch;
	// 822DC724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822DC728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DC72C: 4BFFF2A5  bl 0x822db9d0
	ctx.lr = 0x822DC730;
	sub_822DB9D0(ctx, base);
	// 822DC730: 1D7E0030  mulli r11, r30, 0x30
	ctx.r[11].s64 = ctx.r[30].s64 * 48;
	// 822DC734: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822DC738: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 822DC73C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 822DC740: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822DC744: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DC748: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC754: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DC758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DC75C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC760 size=112
    let mut pc: u32 = 0x822DC760;
    'dispatch: loop {
        match pc {
            0x822DC760 => {
    //   block [0x822DC760..0x822DC7D0)
	// 822DC760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DC76C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DC770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DC778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC77C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822DC780: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DC784: 4BFFF49D  bl 0x822dbc20
	ctx.lr = 0x822DC788;
	sub_822DBC20(ctx, base);
	// 822DC788: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DC78C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DC790: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DC794: 4BFE386D  bl 0x822c0000
	ctx.lr = 0x822DC798;
	sub_822C0000(ctx, base);
	// 822DC798: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DC79C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DC7A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DC7A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC7A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DC7AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DC7B0: 419A0008  beq cr6, 0x822dc7b8
	if ctx.cr[6].eq {
	pc = 0x822DC7B8; continue 'dispatch;
	}
	// 822DC7B4: 4BFE40DD  bl 0x822c0890
	ctx.lr = 0x822DC7B8;
	sub_822C0890(ctx, base);
	// 822DC7B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC7BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC7C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC7C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DC7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DC7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC7D0 size=112
    let mut pc: u32 = 0x822DC7D0;
    'dispatch: loop {
        match pc {
            0x822DC7D0 => {
    //   block [0x822DC7D0..0x822DC840)
	// 822DC7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC7D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DC7DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DC7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC7E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DC7E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC7EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822DC7F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DC7F4: 4BFFF4ED  bl 0x822dbce0
	ctx.lr = 0x822DC7F8;
	sub_822DBCE0(ctx, base);
	// 822DC7F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DC7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DC800: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DC804: 4BFE37FD  bl 0x822c0000
	ctx.lr = 0x822DC808;
	sub_822C0000(ctx, base);
	// 822DC808: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DC80C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DC810: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DC814: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DC81C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DC820: 419A0008  beq cr6, 0x822dc828
	if ctx.cr[6].eq {
	pc = 0x822DC828; continue 'dispatch;
	}
	// 822DC824: 4BFE406D  bl 0x822c0890
	ctx.lr = 0x822DC828;
	sub_822C0890(ctx, base);
	// 822DC828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DC82C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DC838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DC83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DC840 size=132
    let mut pc: u32 = 0x822DC840;
    'dispatch: loop {
        match pc {
            0x822DC840 => {
    //   block [0x822DC840..0x822DC8C4)
	// 822DC840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC848: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC84C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC850: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DC854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC858: 409A000C  bne cr6, 0x822dc864
	if !ctx.cr[6].eq {
	pc = 0x822DC864; continue 'dispatch;
	}
	// 822DC85C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DC860: 48000010  b 0x822dc870
	pc = 0x822DC870; continue 'dispatch;
	// 822DC864: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC868: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC86C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 822DC870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC874: 419A0030  beq cr6, 0x822dc8a4
	if ctx.cr[6].eq {
	pc = 0x822DC8A4; continue 'dispatch;
	}
	// 822DC878: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DC87C: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822DC880: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822DC884: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC888: 4098001C  bge cr6, 0x822dc8a4
	if !ctx.cr[6].lt {
	pc = 0x822DC8A4; continue 'dispatch;
	}
	// 822DC88C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC890: C0060000  lfs f0, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DC894: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 822DC898: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822DC89C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DC8A0: 48000014  b 0x822dc8b4
	pc = 0x822DC8B4; continue 'dispatch;
	// 822DC8A4: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC8A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DC8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DC8B0: 4BFFFD41  bl 0x822dc5f0
	ctx.lr = 0x822DC8B4;
	sub_822DC5F0(ctx, base);
	// 822DC8B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DC8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC8C8 size=132
    let mut pc: u32 = 0x822DC8C8;
    'dispatch: loop {
        match pc {
            0x822DC8C8 => {
    //   block [0x822DC8C8..0x822DC94C)
	// 822DC8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC8D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC8D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC8D8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822DC8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC8E0: 409A000C  bne cr6, 0x822dc8ec
	if !ctx.cr[6].eq {
	pc = 0x822DC8EC; continue 'dispatch;
	}
	// 822DC8E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822DC8E8: 48000010  b 0x822dc8f8
	pc = 0x822DC8F8; continue 'dispatch;
	// 822DC8EC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC8F0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822DC8F4: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 822DC8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DC8FC: 419A0030  beq cr6, 0x822dc92c
	if ctx.cr[6].eq {
	pc = 0x822DC92C; continue 'dispatch;
	}
	// 822DC900: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DC904: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822DC908: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 822DC90C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DC910: 4098001C  bge cr6, 0x822dc92c
	if !ctx.cr[6].lt {
	pc = 0x822DC92C; continue 'dispatch;
	}
	// 822DC914: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC918: A1460000  lhz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DC91C: 392B0002  addi r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 2;
	// 822DC920: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 822DC924: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 822DC928: 48000014  b 0x822dc93c
	pc = 0x822DC93C; continue 'dispatch;
	// 822DC92C: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DC930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DC934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DC938: 4BFFFD29  bl 0x822dc660
	ctx.lr = 0x822DC93C;
	sub_822DC660(ctx, base);
	// 822DC93C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DC940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DC950 size=128
    let mut pc: u32 = 0x822DC950;
    'dispatch: loop {
        match pc {
            0x822DC950 => {
    //   block [0x822DC950..0x822DC9D0)
	// 822DC950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DC958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DC95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DC960: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DC964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DC968: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DC96C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822DC970: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822DC974: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 822DC978: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822DC97C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 822DC980: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 822DC984: 4200FFF8  bdnz 0x822dc97c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822DC97C; continue 'dispatch;
	}
	// 822DC988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DC98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC990: 4BFFFD41  bl 0x822dc6d0
	ctx.lr = 0x822DC994;
	sub_822DC6D0(ctx, base);
	// 822DC994: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DC998: 4182001C  beq 0x822dc9b4
	if ctx.cr[0].eq {
	pc = 0x822DC9B4; continue 'dispatch;
	}
	// 822DC99C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822DC9A0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DC9A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DC9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC9AC: 4BFFF215  bl 0x822dbbc0
	ctx.lr = 0x822DC9B0;
	sub_822DBBC0(ctx, base);
	// 822DC9B0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 822DC9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DC9B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DC9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DC9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DC9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DC9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DC9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DC9D0 size=1068
    let mut pc: u32 = 0x822DC9D0;
    'dispatch: loop {
        match pc {
            0x822DC9D0 => {
    //   block [0x822DC9D0..0x822DCDFC)
	// 822DC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DC9D4: 48ECB771  bl 0x831a8144
	ctx.lr = 0x822DC9D8;
	sub_831A8130(ctx, base);
	// 822DC9D8: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 822DC9DC: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 822DC9E0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DCE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DCE00 size=1240
    let mut pc: u32 = 0x822DCE00;
    'dispatch: loop {
        match pc {
            0x822DCE00 => {
    //   block [0x822DCE00..0x822DD2D8)
	// 822DCE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DCE04: 48ECB33D  bl 0x831a8140
	ctx.lr = 0x822DCE08;
	sub_831A8130(ctx, base);
	// 822DCE08: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 822DCE0C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 822DCE10: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DD2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DD2D8 size=1224
    let mut pc: u32 = 0x822DD2D8;
    'dispatch: loop {
        match pc {
            0x822DD2D8 => {
    //   block [0x822DD2D8..0x822DD7A0)
	// 822DD2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DD2DC: 48ECAE59  bl 0x831a8134
	ctx.lr = 0x822DD2E0;
	sub_831A8130(ctx, base);
	// 822DD2E0: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DD7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DD7A0 size=1404
    let mut pc: u32 = 0x822DD7A0;
    'dispatch: loop {
        match pc {
            0x822DD7A0 => {
    //   block [0x822DD7A0..0x822DDD1C)
	// 822DD7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DD7A4: 48ECA991  bl 0x831a8134
	ctx.lr = 0x822DD7A8;
	sub_831A8130(ctx, base);
	// 822DD7A8: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DDD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DDD20 size=252
    let mut pc: u32 = 0x822DDD20;
    'dispatch: loop {
        match pc {
            0x822DDD20 => {
    //   block [0x822DDD20..0x822DDE1C)
	// 822DDD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DDD24: 48ECA43D  bl 0x831a8160
	ctx.lr = 0x822DDD28;
	sub_831A8130(ctx, base);
	// 822DDD28: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822DDD2C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DDD30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DDD34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DDD38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DDD3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DDD40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DDD44: 388BA430  addi r4, r11, -0x5bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -23504;
	// 822DDD48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DDD4C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DDD50: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DDD54: 48B15CB5  bl 0x82df3a08
	ctx.lr = 0x822DDD58;
	sub_82DF3A08(ctx, base);
	// 822DDD58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822DDD5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DDD60: 4850C3B9  bl 0x827ea118
	ctx.lr = 0x822DDD64;
	sub_827EA118(ctx, base);
	// 822DDD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DDD68: 48B156C1  bl 0x82df3428
	ctx.lr = 0x822DDD6C;
	sub_82DF3428(ctx, base);
	// 822DDD6C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822DDD70: 835F0018  lwz r26, 0x18(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DDD74: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822DDD78: 419A0024  beq cr6, 0x822ddd9c
	if ctx.cr[6].eq {
	pc = 0x822DDD9C; continue 'dispatch;
	}
	// 822DDD7C: 395A0004  addi r10, r26, 4
	ctx.r[10].s64 = ctx.r[26].s64 + 4;
	// 822DDD80: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 822DDD84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DDD88: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 822DDD8C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822DDD90: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DDD94: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DDD98: 4082FFE8  bne 0x822ddd80
	if !ctx.cr[0].eq {
	pc = 0x822DDD80; continue 'dispatch;
	}
	// 822DDD9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DDDA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DDDA4: 419A0034  beq cr6, 0x822dddd8
	if ctx.cr[6].eq {
	pc = 0x822DDDD8; continue 'dispatch;
	}
	// 822DDDA8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DDDAC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822DDDB0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822DDDB4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822DDDB8: 409A0020  bne cr6, 0x822dddd8
	if !ctx.cr[6].eq {
	pc = 0x822DDDD8; continue 'dispatch;
	}
	// 822DDDBC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822DDDC0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822DDDC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DDDC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DDDCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDDD0: 4BFFF509  bl 0x822dd2d8
	ctx.lr = 0x822DDDD4;
	sub_822DD2D8(ctx, base);
	// 822DDDD4: 48000020  b 0x822dddf4
	pc = 0x822DDDF4; continue 'dispatch;
	// 822DDDD8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822DDDDC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DDDE0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822DDDE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DDDE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DDDEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDDF0: 4BFFEBE1  bl 0x822dc9d0
	ctx.lr = 0x822DDDF4;
	sub_822DC9D0(ctx, base);
	// 822DDDF4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822DDDF8: 419A000C  beq cr6, 0x822dde04
	if ctx.cr[6].eq {
	pc = 0x822DDE04; continue 'dispatch;
	}
	// 822DDDFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822DDE00: 4BFE2A91  bl 0x822c0890
	ctx.lr = 0x822DDE04;
	sub_822C0890(ctx, base);
	// 822DDE04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DDE08: 4850C2A9  bl 0x827ea0b0
	ctx.lr = 0x822DDE0C;
	sub_827EA0B0(ctx, base);
	// 822DDE0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DDE10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DDE14: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822DDE18: 48ECA398  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DDE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DDE20 size=240
    let mut pc: u32 = 0x822DDE20;
    'dispatch: loop {
        match pc {
            0x822DDE20 => {
    //   block [0x822DDE20..0x822DDF10)
	// 822DDE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DDE24: 48ECA341  bl 0x831a8164
	ctx.lr = 0x822DDE28;
	sub_831A8130(ctx, base);
	// 822DDE28: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822DDE2C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DDE30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DDE34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DDE38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DDE3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DDE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DDE44: 388BA430  addi r4, r11, -0x5bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -23504;
	// 822DDE48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DDE4C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DDE50: 48B15BB9  bl 0x82df3a08
	ctx.lr = 0x822DDE54;
	sub_82DF3A08(ctx, base);
	// 822DDE54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822DDE58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DDE5C: 4850C2BD  bl 0x827ea118
	ctx.lr = 0x822DDE60;
	sub_827EA118(ctx, base);
	// 822DDE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DDE64: 48B155C5  bl 0x82df3428
	ctx.lr = 0x822DDE68;
	sub_82DF3428(ctx, base);
	// 822DDE68: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822DDE6C: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DDE70: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822DDE74: 419A0024  beq cr6, 0x822dde98
	if ctx.cr[6].eq {
	pc = 0x822DDE98; continue 'dispatch;
	}
	// 822DDE78: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 822DDE7C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 822DDE80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DDE84: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 822DDE88: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 822DDE8C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DDE90: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DDE94: 4082FFE8  bne 0x822dde7c
	if !ctx.cr[0].eq {
	pc = 0x822DDE7C; continue 'dispatch;
	}
	// 822DDE98: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DDE9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822DDEA0: 419A0030  beq cr6, 0x822dded0
	if ctx.cr[6].eq {
	pc = 0x822DDED0; continue 'dispatch;
	}
	// 822DDEA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822DDEA8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 822DDEAC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822DDEB0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 822DDEB4: 409A001C  bne cr6, 0x822dded0
	if !ctx.cr[6].eq {
	pc = 0x822DDED0; continue 'dispatch;
	}
	// 822DDEB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822DDEBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DDEC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DDEC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDEC8: 4BFFF8D9  bl 0x822dd7a0
	ctx.lr = 0x822DDECC;
	sub_822DD7A0(ctx, base);
	// 822DDECC: 4800001C  b 0x822ddee8
	pc = 0x822DDEE8; continue 'dispatch;
	// 822DDED0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822DDED4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DDED8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DDEDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DDEE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDEE4: 4BFFEF1D  bl 0x822dce00
	ctx.lr = 0x822DDEE8;
	sub_822DCE00(ctx, base);
	// 822DDEE8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822DDEEC: 419A000C  beq cr6, 0x822ddef8
	if ctx.cr[6].eq {
	pc = 0x822DDEF8; continue 'dispatch;
	}
	// 822DDEF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DDEF4: 4BFE299D  bl 0x822c0890
	ctx.lr = 0x822DDEF8;
	sub_822C0890(ctx, base);
	// 822DDEF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DDEFC: 4850C1B5  bl 0x827ea0b0
	ctx.lr = 0x822DDF00;
	sub_827EA0B0(ctx, base);
	// 822DDF00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DDF04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DDF08: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822DDF0C: 48ECA2A8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DDF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DDF10 size=8
    let mut pc: u32 = 0x822DDF10;
    'dispatch: loop {
        match pc {
            0x822DDF10 => {
    //   block [0x822DDF10..0x822DDF18)
	// 822DDF10: 3863FF9C  addi r3, r3, -0x64
	ctx.r[3].s64 = ctx.r[3].s64 + -100;
	// 822DDF14: 4800BEDC  b 0x822e9df0
	sub_822E9DF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DDF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DDF18 size=132
    let mut pc: u32 = 0x822DDF18;
    'dispatch: loop {
        match pc {
            0x822DDF18 => {
    //   block [0x822DDF18..0x822DDF9C)
	// 822DDF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DDF1C: 48ECA251  bl 0x831a816c
	ctx.lr = 0x822DDF20;
	sub_831A8130(ctx, base);
	// 822DDF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DDF24: 3BC3FF9C  addi r30, r3, -0x64
	ctx.r[30].s64 = ctx.r[3].s64 + -100;
	// 822DDF28: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DDF2C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822DDF30: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 822DDF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDF38: 4800C491  bl 0x822ea3c8
	ctx.lr = 0x822DDF3C;
	sub_822EA3C8(ctx, base);
	// 822DDF3C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822DDF40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DDF44: 3BEB1740  addi r31, r11, 0x1740
	ctx.r[31].s64 = ctx.r[11].s64 + 5952;
	// 822DDF48: 816A1744  lwz r11, 0x1744(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5956 as u32) ) } as u64;
	// 822DDF4C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DDF50: 4082001C  bne 0x822ddf6c
	if !ctx.cr[0].eq {
	pc = 0x822DDF6C; continue 'dispatch;
	}
	// 822DDF54: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822DDF58: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DDF5C: 916A1744  stw r11, 0x1744(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5956 as u32), ctx.r[11].u32 ) };
	// 822DDF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DDF64: 3889A43C  addi r4, r9, -0x5bc4
	ctx.r[4].s64 = ctx.r[9].s64 + -23492;
	// 822DDF68: 48B1B5C9  bl 0x82df9530
	ctx.lr = 0x822DDF6C;
	sub_82DF9530(ctx, base);
	// 822DDF6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DDF70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DDF74: 481B10F5  bl 0x8248f068
	ctx.lr = 0x822DDF78;
	sub_8248F068(ctx, base);
	// 822DDF78: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DDF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DDF80: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 822DDF84: 409A0008  bne cr6, 0x822ddf8c
	if !ctx.cr[6].eq {
	pc = 0x822DDF8C; continue 'dispatch;
	}
	// 822DDF88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DDF8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DDF90: 4824A061  bl 0x82527ff0
	ctx.lr = 0x822DDF94;
	sub_82527FF0(ctx, base);
	// 822DDF94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DDF98: 48ECA224  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DDFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DDFA0 size=196
    let mut pc: u32 = 0x822DDFA0;
    'dispatch: loop {
        match pc {
            0x822DDFA0 => {
    //   block [0x822DDFA0..0x822DE064)
	// 822DDFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DDFA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DDFA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DDFAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DDFB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DDFB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DDFB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DDFBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DDFC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DDFC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DDFC8: 4BFE2971  bl 0x822c0938
	ctx.lr = 0x822DDFCC;
	sub_822C0938(ctx, base);
	// 822DDFCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DDFD0: 41820028  beq 0x822ddff8
	if ctx.cr[0].eq {
	pc = 0x822DDFF8; continue 'dispatch;
	}
	// 822DDFD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DDFD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DDFDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DDFE0: 392BA448  addi r9, r11, -0x5bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -23480;
	// 822DDFE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DDFE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DDFEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DDFF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DDFF4: 48000008  b 0x822ddffc
	pc = 0x822DDFFC; continue 'dispatch;
	// 822DDFF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DDFFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DE004: 409A0044  bne cr6, 0x822de048
	if !ctx.cr[6].eq {
	pc = 0x822DE048; continue 'dispatch;
	}
	// 822DE008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DE00C: 419A001C  beq cr6, 0x822de028
	if ctx.cr[6].eq {
	pc = 0x822DE028; continue 'dispatch;
	}
	// 822DE010: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE014: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DE018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE01C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DE024: 4E800421  bctrl
	ctx.lr = 0x822DE028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DE028: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DE02C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DE030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DE034: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DE038: 816B3340  lwz r11, 0x3340(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13120 as u32) ) } as u64;
	// 822DE03C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DE040: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DE044: 4BFE1FBD  bl 0x822c0000
	ctx.lr = 0x822DE048;
	sub_822C0000(ctx, base);
	// 822DE048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE04C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DE050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DE05C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE068 size=136
    let mut pc: u32 = 0x822DE068;
    'dispatch: loop {
        match pc {
            0x822DE068 => {
    //   block [0x822DE068..0x822DE0F0)
	// 822DE068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE074: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE07C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822DE080: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE084: 419A0008  beq cr6, 0x822de08c
	if ctx.cr[6].eq {
	pc = 0x822DE08C; continue 'dispatch;
	}
	// 822DE088: 48900F51  bl 0x82bdefd8
	ctx.lr = 0x822DE08C;
	sub_82BDEFD8(ctx, base);
	// 822DE08C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822DE090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE094: 419A0008  beq cr6, 0x822de09c
	if ctx.cr[6].eq {
	pc = 0x822DE09C; continue 'dispatch;
	}
	// 822DE098: 48900F41  bl 0x82bdefd8
	ctx.lr = 0x822DE09C;
	sub_82BDEFD8(ctx, base);
	// 822DE09C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822DE0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE0A4: 419A0008  beq cr6, 0x822de0ac
	if ctx.cr[6].eq {
	pc = 0x822DE0AC; continue 'dispatch;
	}
	// 822DE0A8: 48900F31  bl 0x82bdefd8
	ctx.lr = 0x822DE0AC;
	sub_82BDEFD8(ctx, base);
	// 822DE0AC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822DE0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE0B4: 419A0008  beq cr6, 0x822de0bc
	if ctx.cr[6].eq {
	pc = 0x822DE0BC; continue 'dispatch;
	}
	// 822DE0B8: 4BFE27D9  bl 0x822c0890
	ctx.lr = 0x822DE0BC;
	sub_822C0890(ctx, base);
	// 822DE0BC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822DE0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE0C4: 419A0008  beq cr6, 0x822de0cc
	if ctx.cr[6].eq {
	pc = 0x822DE0CC; continue 'dispatch;
	}
	// 822DE0C8: 4BFE27C9  bl 0x822c0890
	ctx.lr = 0x822DE0CC;
	sub_822C0890(ctx, base);
	// 822DE0CC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822DE0D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE0D4: 419A0008  beq cr6, 0x822de0dc
	if ctx.cr[6].eq {
	pc = 0x822DE0DC; continue 'dispatch;
	}
	// 822DE0D8: 4BFE27B9  bl 0x822c0890
	ctx.lr = 0x822DE0DC;
	sub_822C0890(ctx, base);
	// 822DE0DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DE0E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE0E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE0E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE0F0 size=92
    let mut pc: u32 = 0x822DE0F0;
    'dispatch: loop {
        match pc {
            0x822DE0F0 => {
    //   block [0x822DE0F0..0x822DE14C)
	// 822DE0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE0F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE0FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE104: 4800BE65  bl 0x822e9f68
	ctx.lr = 0x822DE108;
	sub_822E9F68(ctx, base);
	// 822DE108: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 822DE10C: 4BFFDA7D  bl 0x822dbb88
	ctx.lr = 0x822DE110;
	sub_822DBB88(ctx, base);
	// 822DE110: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE114: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DE118: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DE11C: 396BA474  addi r11, r11, -0x5b8c
	ctx.r[11].s64 = ctx.r[11].s64 + -23436;
	// 822DE120: 394AA468  addi r10, r10, -0x5b98
	ctx.r[10].s64 = ctx.r[10].s64 + -23448;
	// 822DE124: 3929A45C  addi r9, r9, -0x5ba4
	ctx.r[9].s64 = ctx.r[9].s64 + -23460;
	// 822DE128: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE12C: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 822DE130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE134: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 822DE138: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DE13C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE144: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DE150 size=8
    let mut pc: u32 = 0x822DE150;
    'dispatch: loop {
        match pc {
            0x822DE150 => {
    //   block [0x822DE150..0x822DE158)
	// 822DE150: 3863FFB8  addi r3, r3, -0x48
	ctx.r[3].s64 = ctx.r[3].s64 + -72;
	// 822DE154: 48000004  b 0x822de158
	sub_822DE158(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE158 size=100
    let mut pc: u32 = 0x822DE158;
    'dispatch: loop {
        match pc {
            0x822DE158 => {
    //   block [0x822DE158..0x822DE1BC)
	// 822DE158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DE164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE170: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DE174: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DE178: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 822DE17C: 409A0008  bne cr6, 0x822de184
	if !ctx.cr[6].eq {
	pc = 0x822DE184; continue 'dispatch;
	}
	// 822DE180: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DE184: 4BFFFEE5  bl 0x822de068
	ctx.lr = 0x822DE188;
	sub_822DE068(ctx, base);
	// 822DE188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE18C: 4800BB6D  bl 0x822e9cf8
	ctx.lr = 0x822DE190;
	sub_822E9CF8(ctx, base);
	// 822DE190: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DE194: 4182000C  beq 0x822de1a0
	if ctx.cr[0].eq {
	pc = 0x822DE1A0; continue 'dispatch;
	}
	// 822DE198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE19C: 48B1423D  bl 0x82df23d8
	ctx.lr = 0x822DE1A0;
	sub_82DF23D8(ctx, base);
	// 822DE1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE1A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DE1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DE1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE1C0 size=260
    let mut pc: u32 = 0x822DE1C0;
    'dispatch: loop {
        match pc {
            0x822DE1C0 => {
    //   block [0x822DE1C0..0x822DE2C4)
	// 822DE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE1C4: 48EC9F99  bl 0x831a815c
	ctx.lr = 0x822DE1C8;
	sub_831A8130(ctx, base);
	// 822DE1C8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822DE1CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE1D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE1D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DE1D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DE1DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE1E0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822DE1E4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DE1E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DE1EC: 388BA4A8  addi r4, r11, -0x5b58
	ctx.r[4].s64 = ctx.r[11].s64 + -23384;
	// 822DE1F0: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 822DE1F4: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 822DE1F8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DE1FC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822DE200: 48B141E9  bl 0x82df23e8
	ctx.lr = 0x822DE204;
	sub_82DF23E8(ctx, base);
	// 822DE204: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822DE208: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DE20C: 41820014  beq 0x822de220
	if ctx.cr[0].eq {
	pc = 0x822DE220; continue 'dispatch;
	}
	// 822DE210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE214: 4BFFFEDD  bl 0x822de0f0
	ctx.lr = 0x822DE218;
	sub_822DE0F0(ctx, base);
	// 822DE218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE21C: 48000008  b 0x822de224
	pc = 0x822DE224; continue 'dispatch;
	// 822DE220: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822DE224: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822DE228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE22C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE230: 4BFFFD71  bl 0x822ddfa0
	ctx.lr = 0x822DE234;
	sub_822DDFA0(ctx, base);
	// 822DE234: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DE238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE23C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE240: 4BFE1DC1  bl 0x822c0000
	ctx.lr = 0x822DE244;
	sub_822C0000(ctx, base);
	// 822DE244: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DE248: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822DE24C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DE250: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DE254: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822DE258: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DE25C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 822DE260: 4BFFFAC1  bl 0x822ddd20
	ctx.lr = 0x822DE264;
	sub_822DDD20(ctx, base);
	// 822DE264: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DE268: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DE26C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE270: 41820034  beq 0x822de2a4
	if ctx.cr[0].eq {
	pc = 0x822DE2A4; continue 'dispatch;
	}
	// 822DE274: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DE278: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822DE27C: 419A0038  beq cr6, 0x822de2b4
	if ctx.cr[6].eq {
	pc = 0x822DE2B4; continue 'dispatch;
	}
	// 822DE280: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822DE284: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DE288: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE28C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DE290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DE294: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DE298: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE29C: 4082FFE8  bne 0x822de284
	if !ctx.cr[0].eq {
	pc = 0x822DE284; continue 'dispatch;
	}
	// 822DE2A0: 48000010  b 0x822de2b0
	pc = 0x822DE2B0; continue 'dispatch;
	// 822DE2A4: 933E0000  stw r25, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822DE2A8: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822DE2AC: 419A0008  beq cr6, 0x822de2b4
	if ctx.cr[6].eq {
	pc = 0x822DE2B4; continue 'dispatch;
	}
	// 822DE2B0: 4BFE25E1  bl 0x822c0890
	ctx.lr = 0x822DE2B4;
	sub_822C0890(ctx, base);
	// 822DE2B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE2B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DE2BC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822DE2C0: 48EC9EEC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE2C8 size=252
    let mut pc: u32 = 0x822DE2C8;
    'dispatch: loop {
        match pc {
            0x822DE2C8 => {
    //   block [0x822DE2C8..0x822DE3C4)
	// 822DE2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE2CC: 48EC9E95  bl 0x831a8160
	ctx.lr = 0x822DE2D0;
	sub_831A8130(ctx, base);
	// 822DE2D0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822DE2D4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE2D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE2DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DE2E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DE2E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE2E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822DE2EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DE2F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DE2F4: 388BA4A8  addi r4, r11, -0x5b58
	ctx.r[4].s64 = ctx.r[11].s64 + -23384;
	// 822DE2F8: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 822DE2FC: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 822DE300: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DE304: 48B140E5  bl 0x82df23e8
	ctx.lr = 0x822DE308;
	sub_82DF23E8(ctx, base);
	// 822DE308: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822DE30C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DE310: 41820014  beq 0x822de324
	if ctx.cr[0].eq {
	pc = 0x822DE324; continue 'dispatch;
	}
	// 822DE314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE318: 4BFFFDD9  bl 0x822de0f0
	ctx.lr = 0x822DE31C;
	sub_822DE0F0(ctx, base);
	// 822DE31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE320: 48000008  b 0x822de328
	pc = 0x822DE328; continue 'dispatch;
	// 822DE324: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822DE328: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822DE32C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE334: 4BFFFC6D  bl 0x822ddfa0
	ctx.lr = 0x822DE338;
	sub_822DDFA0(ctx, base);
	// 822DE338: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DE33C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE340: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE344: 4BFE1CBD  bl 0x822c0000
	ctx.lr = 0x822DE348;
	sub_822C0000(ctx, base);
	// 822DE348: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DE34C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DE350: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DE354: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822DE358: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DE35C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 822DE360: 4BFFFAC1  bl 0x822dde20
	ctx.lr = 0x822DE364;
	sub_822DDE20(ctx, base);
	// 822DE364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DE368: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DE36C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE370: 41820034  beq 0x822de3a4
	if ctx.cr[0].eq {
	pc = 0x822DE3A4; continue 'dispatch;
	}
	// 822DE374: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DE378: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822DE37C: 419A0038  beq cr6, 0x822de3b4
	if ctx.cr[6].eq {
	pc = 0x822DE3B4; continue 'dispatch;
	}
	// 822DE380: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822DE384: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DE388: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE38C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DE390: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DE394: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DE398: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE39C: 4082FFE8  bne 0x822de384
	if !ctx.cr[0].eq {
	pc = 0x822DE384; continue 'dispatch;
	}
	// 822DE3A0: 48000010  b 0x822de3b0
	pc = 0x822DE3B0; continue 'dispatch;
	// 822DE3A4: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 822DE3A8: 935E0004  stw r26, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 822DE3AC: 419A0008  beq cr6, 0x822de3b4
	if ctx.cr[6].eq {
	pc = 0x822DE3B4; continue 'dispatch;
	}
	// 822DE3B0: 4BFE24E1  bl 0x822c0890
	ctx.lr = 0x822DE3B4;
	sub_822C0890(ctx, base);
	// 822DE3B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE3B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DE3BC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822DE3C0: 48EC9DF0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DE3C8 size=8
    let mut pc: u32 = 0x822DE3C8;
    'dispatch: loop {
        match pc {
            0x822DE3C8 => {
    //   block [0x822DE3C8..0x822DE3D0)
	// 822DE3C8: 3863FEF0  addi r3, r3, -0x110
	ctx.r[3].s64 = ctx.r[3].s64 + -272;
	// 822DE3CC: 4800F26C  b 0x822ed638
	sub_822ED638(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE3D0 size=244
    let mut pc: u32 = 0x822DE3D0;
    'dispatch: loop {
        match pc {
            0x822DE3D0 => {
    //   block [0x822DE3D0..0x822DE4C4)
	// 822DE3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE3D4: 48EC9D95  bl 0x831a8168
	ctx.lr = 0x822DE3D8;
	sub_831A8130(ctx, base);
	// 822DE3D8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE3E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DE3E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822DE3E8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DE3EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DE3F0: 48BEE5F9  bl 0x82ecc9e8
	ctx.lr = 0x822DE3F4;
	sub_82ECC9E8(ctx, base);
	// 822DE3F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE3F8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 822DE3FC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 822DE400: 99610110  stb r11, 0x110(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u8 ) };
	// 822DE404: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 822DE408: 4800A6D9  bl 0x822e8ae0
	ctx.lr = 0x822DE40C;
	sub_822E8AE0(ctx, base);
	// 822DE40C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE410: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 822DE414: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822DE418: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 822DE41C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822DE420: 48BC2311  bl 0x82ea0730
	ctx.lr = 0x822DE424;
	sub_82EA0730(ctx, base);
	// 822DE424: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 822DE428: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822DE42C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822DE430: 48BED4B1  bl 0x82ecb8e0
	ctx.lr = 0x822DE434;
	sub_82ECB8E0(ctx, base);
	// 822DE434: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822DE438: 3BFFFEF0  addi r31, r31, -0x110
	ctx.r[31].s64 = ctx.r[31].s64 + -272;
	// 822DE43C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822DE440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE444: 4800F16D  bl 0x822ed5b0
	ctx.lr = 0x822DE448;
	sub_822ED5B0(ctx, base);
	// 822DE448: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DE44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE450: 481B0F51  bl 0x8248f3a0
	ctx.lr = 0x822DE454;
	sub_8248F3A0(ctx, base);
	// 822DE454: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822DE458: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DE45C: 3BCB1748  addi r30, r11, 0x1748
	ctx.r[30].s64 = ctx.r[11].s64 + 5960;
	// 822DE460: 816A174C  lwz r11, 0x174c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5964 as u32) ) } as u64;
	// 822DE464: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822DE468: 4082001C  bne 0x822de484
	if !ctx.cr[0].eq {
	pc = 0x822DE484; continue 'dispatch;
	}
	// 822DE46C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822DE470: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DE474: 916A174C  stw r11, 0x174c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5964 as u32), ctx.r[11].u32 ) };
	// 822DE478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE47C: 3889A43C  addi r4, r9, -0x5bc4
	ctx.r[4].s64 = ctx.r[9].s64 + -23492;
	// 822DE480: 48B1B0B1  bl 0x82df9530
	ctx.lr = 0x822DE484;
	sub_82DF9530(ctx, base);
	// 822DE484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DE488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE48C: 481B0BDD  bl 0x8248f068
	ctx.lr = 0x822DE490;
	sub_8248F068(ctx, base);
	// 822DE490: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DE498: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 822DE49C: 409A0008  bne cr6, 0x822de4a4
	if !ctx.cr[6].eq {
	pc = 0x822DE4A4; continue 'dispatch;
	}
	// 822DE4A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DE4A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE4A8: 48249B49  bl 0x82527ff0
	ctx.lr = 0x822DE4AC;
	sub_82527FF0(ctx, base);
	// 822DE4AC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DE4B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE4B4: 419A0008  beq cr6, 0x822de4bc
	if ctx.cr[6].eq {
	pc = 0x822DE4BC; continue 'dispatch;
	}
	// 822DE4B8: 48009DB1  bl 0x822e8268
	ctx.lr = 0x822DE4BC;
	sub_822E8268(ctx, base);
	// 822DE4BC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822DE4C0: 48EC9CF8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE4C8 size=196
    let mut pc: u32 = 0x822DE4C8;
    'dispatch: loop {
        match pc {
            0x822DE4C8 => {
    //   block [0x822DE4C8..0x822DE58C)
	// 822DE4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE4D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DE4D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE4D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE4DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DE4E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DE4E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DE4E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE4EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE4F0: 4BFE2449  bl 0x822c0938
	ctx.lr = 0x822DE4F4;
	sub_822C0938(ctx, base);
	// 822DE4F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DE4F8: 41820028  beq 0x822de520
	if ctx.cr[0].eq {
	pc = 0x822DE520; continue 'dispatch;
	}
	// 822DE4FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE500: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DE504: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DE508: 392BA4F8  addi r9, r11, -0x5b08
	ctx.r[9].s64 = ctx.r[11].s64 + -23304;
	// 822DE50C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DE510: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DE514: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DE518: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DE51C: 48000008  b 0x822de524
	pc = 0x822DE524; continue 'dispatch;
	// 822DE520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DE524: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DE52C: 409A0044  bne cr6, 0x822de570
	if !ctx.cr[6].eq {
	pc = 0x822DE570; continue 'dispatch;
	}
	// 822DE530: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DE534: 419A001C  beq cr6, 0x822de550
	if ctx.cr[6].eq {
	pc = 0x822DE550; continue 'dispatch;
	}
	// 822DE538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE53C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DE540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE544: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DE54C: 4E800421  bctrl
	ctx.lr = 0x822DE550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DE550: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DE554: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DE558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DE55C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DE560: 816B3430  lwz r11, 0x3430(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13360 as u32) ) } as u64;
	// 822DE564: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DE568: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DE56C: 4BFE1A95  bl 0x822c0000
	ctx.lr = 0x822DE570;
	sub_822C0000(ctx, base);
	// 822DE570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE574: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DE578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE57C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DE584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE590 size=92
    let mut pc: u32 = 0x822DE590;
    'dispatch: loop {
        match pc {
            0x822DE590 => {
    //   block [0x822DE590..0x822DE5EC)
	// 822DE590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE598: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE59C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE5A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE5A4: 4800F83D  bl 0x822edde0
	ctx.lr = 0x822DE5A8;
	sub_822EDDE0(ctx, base);
	// 822DE5A8: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 822DE5AC: 4BFFD5DD  bl 0x822dbb88
	ctx.lr = 0x822DE5B0;
	sub_822DBB88(ctx, base);
	// 822DE5B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE5B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DE5B8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822DE5BC: 396BA524  addi r11, r11, -0x5adc
	ctx.r[11].s64 = ctx.r[11].s64 + -23260;
	// 822DE5C0: 394AA518  addi r10, r10, -0x5ae8
	ctx.r[10].s64 = ctx.r[10].s64 + -23272;
	// 822DE5C4: 3929A50C  addi r9, r9, -0x5af4
	ctx.r[9].s64 = ctx.r[9].s64 + -23284;
	// 822DE5C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE5CC: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DE5D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE5D4: 913F0110  stw r9, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 822DE5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DE5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DE5F0 size=8
    let mut pc: u32 = 0x822DE5F0;
    'dispatch: loop {
        match pc {
            0x822DE5F0 => {
    //   block [0x822DE5F0..0x822DE5F8)
	// 822DE5F0: 3863FFB0  addi r3, r3, -0x50
	ctx.r[3].s64 = ctx.r[3].s64 + -80;
	// 822DE5F4: 48000004  b 0x822de5f8
	sub_822DE5F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE5F8 size=100
    let mut pc: u32 = 0x822DE5F8;
    'dispatch: loop {
        match pc {
            0x822DE5F8 => {
    //   block [0x822DE5F8..0x822DE65C)
	// 822DE5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DE604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE610: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DE614: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DE618: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 822DE61C: 409A0008  bne cr6, 0x822de624
	if !ctx.cr[6].eq {
	pc = 0x822DE624; continue 'dispatch;
	}
	// 822DE620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DE624: 4BFFFA45  bl 0x822de068
	ctx.lr = 0x822DE628;
	sub_822DE068(ctx, base);
	// 822DE628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE62C: 4800EEC5  bl 0x822ed4f0
	ctx.lr = 0x822DE630;
	sub_822ED4F0(ctx, base);
	// 822DE630: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DE634: 4182000C  beq 0x822de640
	if ctx.cr[0].eq {
	pc = 0x822DE640; continue 'dispatch;
	}
	// 822DE638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE63C: 48B13D9D  bl 0x82df23d8
	ctx.lr = 0x822DE640;
	sub_82DF23D8(ctx, base);
	// 822DE640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE644: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DE648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE64C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DE654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE660 size=260
    let mut pc: u32 = 0x822DE660;
    'dispatch: loop {
        match pc {
            0x822DE660 => {
    //   block [0x822DE660..0x822DE764)
	// 822DE660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE664: 48EC9AF9  bl 0x831a815c
	ctx.lr = 0x822DE668;
	sub_831A8130(ctx, base);
	// 822DE668: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822DE66C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE670: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE674: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DE678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DE67C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE680: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822DE684: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DE688: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DE68C: 388BA558  addi r4, r11, -0x5aa8
	ctx.r[4].s64 = ctx.r[11].s64 + -23208;
	// 822DE690: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 822DE694: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 822DE698: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822DE69C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822DE6A0: 48B13D49  bl 0x82df23e8
	ctx.lr = 0x822DE6A4;
	sub_82DF23E8(ctx, base);
	// 822DE6A4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822DE6A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DE6AC: 41820014  beq 0x822de6c0
	if ctx.cr[0].eq {
	pc = 0x822DE6C0; continue 'dispatch;
	}
	// 822DE6B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE6B4: 4BFFFEDD  bl 0x822de590
	ctx.lr = 0x822DE6B8;
	sub_822DE590(ctx, base);
	// 822DE6B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE6BC: 48000008  b 0x822de6c4
	pc = 0x822DE6C4; continue 'dispatch;
	// 822DE6C0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822DE6C4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822DE6C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE6CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE6D0: 4BFFFDF9  bl 0x822de4c8
	ctx.lr = 0x822DE6D4;
	sub_822DE4C8(ctx, base);
	// 822DE6D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DE6D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DE6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822DE6E0: 4BFE1921  bl 0x822c0000
	ctx.lr = 0x822DE6E4;
	sub_822C0000(ctx, base);
	// 822DE6E4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DE6E8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 822DE6EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DE6F0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822DE6F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822DE6F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DE6FC: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 822DE700: 4BFFF621  bl 0x822ddd20
	ctx.lr = 0x822DE704;
	sub_822DDD20(ctx, base);
	// 822DE704: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DE708: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DE70C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE710: 41820034  beq 0x822de744
	if ctx.cr[0].eq {
	pc = 0x822DE744; continue 'dispatch;
	}
	// 822DE714: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DE718: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822DE71C: 419A0038  beq cr6, 0x822de754
	if ctx.cr[6].eq {
	pc = 0x822DE754; continue 'dispatch;
	}
	// 822DE720: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822DE724: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DE728: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE72C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DE730: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DE734: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DE738: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DE73C: 4082FFE8  bne 0x822de724
	if !ctx.cr[0].eq {
	pc = 0x822DE724; continue 'dispatch;
	}
	// 822DE740: 48000010  b 0x822de750
	pc = 0x822DE750; continue 'dispatch;
	// 822DE744: 933E0000  stw r25, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822DE748: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822DE74C: 419A0008  beq cr6, 0x822de754
	if ctx.cr[6].eq {
	pc = 0x822DE754; continue 'dispatch;
	}
	// 822DE750: 4BFE2141  bl 0x822c0890
	ctx.lr = 0x822DE754;
	sub_822C0890(ctx, base);
	// 822DE754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DE758: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DE75C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822DE760: 48EC9A4C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DE768 size=128
    let mut pc: u32 = 0x822DE768;
    'dispatch: loop {
        match pc {
            0x822DE768 => {
    //   block [0x822DE768..0x822DE7E8)
	// 822DE768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE76C: 48EC9A01  bl 0x831a816c
	ctx.lr = 0x822DE770;
	sub_831A8130(ctx, base);
	// 822DE770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE778: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DE77C: 397F00C4  addi r11, r31, 0xc4
	ctx.r[11].s64 = ctx.r[31].s64 + 196;
	// 822DE780: 395E0018  addi r10, r30, 0x18
	ctx.r[10].s64 = ctx.r[30].s64 + 24;
	// 822DE784: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DE788: 813F00C4  lwz r9, 0xc4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822DE78C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 822DE790: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 822DE794: 4BFE5CCD  bl 0x822c4460
	ctx.lr = 0x822DE798;
	sub_822C4460(ctx, base);
	// 822DE798: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DE79C: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 822DE7A0: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 822DE7A4: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DE7A8: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822DE7AC: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 822DE7B0: 48510F89  bl 0x827ef738
	ctx.lr = 0x822DE7B4;
	sub_827EF738(ctx, base);
	// 822DE7B4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 822DE7B8: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE7BC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 822DE7C0: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 822DE7C4: 13C91C07  vcmpneb. (lvlx128) v30, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE7C8: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE7CC: 138B1C07  vcmpneb. (lvlx128) v28, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DE7E8 size=164
    let mut pc: u32 = 0x822DE7E8;
    'dispatch: loop {
        match pc {
            0x822DE7E8 => {
    //   block [0x822DE7E8..0x822DE88C)
	// 822DE7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE7EC: 48EC9981  bl 0x831a816c
	ctx.lr = 0x822DE7F0;
	sub_831A8130(ctx, base);
	// 822DE7F0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822DE7F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE7F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE7FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DE800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DE804: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 822DE808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DE80C: 807D0120  lwz r3, 0x120(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 822DE810: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DE814: 4BFF1CB5  bl 0x822d04c8
	ctx.lr = 0x822DE818;
	sub_822D04C8(ctx, base);
	// 822DE818: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822DE81C: 807D0120  lwz r3, 0x120(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 822DE820: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DE824: 4BFF19AD  bl 0x822d01d0
	ctx.lr = 0x822DE828;
	sub_822D01D0(ctx, base);
	// 822DE828: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822DE890 size=60
    let mut pc: u32 = 0x822DE890;
    'dispatch: loop {
        match pc {
            0x822DE890 => {
    //   block [0x822DE890..0x822DE8CC)
	// 822DE890: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 822DE894: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE898: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822DE89C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822DE8A0: 396300E0  addi r11, r3, 0xe0
	ctx.r[11].s64 = ctx.r[3].s64 + 224;
	// 822DE8A4: 13C82407  vcmpneb. (lvlx128) v30, v8, v4
	tmp.u32 = ctx.r[8].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE8A8: 13A92407  vcmpneb. (lvlx128) v29, v9, v4
	tmp.u32 = ctx.r[9].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DE8AC: 138A2407  vcmpneb. (lvlx128) v28, v10, v4
	tmp.u32 = ctx.r[10].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE8CC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DE8CC size=8
    let mut pc: u32 = 0x822DE8CC;
    'dispatch: loop {
        match pc {
            0x822DE8CC => {
    //   block [0x822DE8CC..0x822DE8D4)
	// 822DE8CC: 4BFF209C  b 0x822d0968
	sub_822D0968(ctx, base);
	return;
	// 822DE8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE8D8 size=104
    let mut pc: u32 = 0x822DE8D8;
    'dispatch: loop {
        match pc {
            0x822DE8D8 => {
    //   block [0x822DE8D8..0x822DE940)
	// 822DE8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE8E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE8E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE8E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DE8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DE8F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE8F4: 808B00C4  lwz r4, 0xc4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 822DE8F8: 80AB00CC  lwz r5, 0xcc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DE8FC: 4BFF0F3D  bl 0x822cf838
	ctx.lr = 0x822DE900;
	sub_822CF838(ctx, base);
	// 822DE900: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DE904: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 822DE908: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DE90C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 822DE910: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE914: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822DE918: 4BFE5B49  bl 0x822c4460
	ctx.lr = 0x822DE91C;
	sub_822C4460(ctx, base);
	// 822DE91C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DE920: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DE924: 419A0008  beq cr6, 0x822de92c
	if ctx.cr[6].eq {
	pc = 0x822DE92C; continue 'dispatch;
	}
	// 822DE928: 4BFE1F69  bl 0x822c0890
	ctx.lr = 0x822DE92C;
	sub_822C0890(ctx, base);
	// 822DE92C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DE930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE938: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE940 size=80
    let mut pc: u32 = 0x822DE940;
    'dispatch: loop {
        match pc {
            0x822DE940 => {
    //   block [0x822DE940..0x822DE990)
	// 822DE940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE950: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DE954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DE958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DE95C: 396B0110  addi r11, r11, 0x110
	ctx.r[11].s64 = ctx.r[11].s64 + 272;
	// 822DE960: 409A0008  bne cr6, 0x822de968
	if !ctx.cr[6].eq {
	pc = 0x822DE968; continue 'dispatch;
	}
	// 822DE964: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DE968: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE96C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 822DE970: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822DE974: 4BFE5AED  bl 0x822c4460
	ctx.lr = 0x822DE978;
	sub_822C4460(ctx, base);
	// 822DE978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DE97C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DE980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DE984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DE988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DE98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DE990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DE990 size=196
    let mut pc: u32 = 0x822DE990;
    'dispatch: loop {
        match pc {
            0x822DE990 => {
    //   block [0x822DE990..0x822DEA54)
	// 822DE990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DE994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DE998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DE99C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DE9A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DE9A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DE9A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DE9AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DE9B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DE9B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE9B8: 4BFE1F81  bl 0x822c0938
	ctx.lr = 0x822DE9BC;
	sub_822C0938(ctx, base);
	// 822DE9BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DE9C0: 41820028  beq 0x822de9e8
	if ctx.cr[0].eq {
	pc = 0x822DE9E8; continue 'dispatch;
	}
	// 822DE9C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DE9C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DE9CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DE9D0: 392BA5A8  addi r9, r11, -0x5a58
	ctx.r[9].s64 = ctx.r[11].s64 + -23128;
	// 822DE9D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DE9D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DE9DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DE9E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DE9E4: 48000008  b 0x822de9ec
	pc = 0x822DE9EC; continue 'dispatch;
	// 822DE9E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DE9EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DE9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DE9F4: 409A0044  bne cr6, 0x822dea38
	if !ctx.cr[6].eq {
	pc = 0x822DEA38; continue 'dispatch;
	}
	// 822DE9F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DE9FC: 419A001C  beq cr6, 0x822dea18
	if ctx.cr[6].eq {
	pc = 0x822DEA18; continue 'dispatch;
	}
	// 822DEA00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEA04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DEA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEA0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DEA14: 4E800421  bctrl
	ctx.lr = 0x822DEA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DEA18: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DEA1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DEA20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEA24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DEA28: 816B34F4  lwz r11, 0x34f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13556 as u32) ) } as u64;
	// 822DEA2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DEA30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DEA34: 4BFE15CD  bl 0x822c0000
	ctx.lr = 0x822DEA38;
	sub_822C0000(ctx, base);
	// 822DEA38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DEA3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DEA40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DEA44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DEA48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DEA4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DEA50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DEA58 size=196
    let mut pc: u32 = 0x822DEA58;
    'dispatch: loop {
        match pc {
            0x822DEA58 => {
    //   block [0x822DEA58..0x822DEB1C)
	// 822DEA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEA5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DEA60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DEA64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DEA68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEA6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DEA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DEA74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DEA78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DEA7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DEA80: 4BFE1EB9  bl 0x822c0938
	ctx.lr = 0x822DEA84;
	sub_822C0938(ctx, base);
	// 822DEA84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DEA88: 41820028  beq 0x822deab0
	if ctx.cr[0].eq {
	pc = 0x822DEAB0; continue 'dispatch;
	}
	// 822DEA8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEA90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DEA94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DEA98: 392BA5BC  addi r9, r11, -0x5a44
	ctx.r[9].s64 = ctx.r[11].s64 + -23108;
	// 822DEA9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DEAA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DEAA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DEAA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DEAAC: 48000008  b 0x822deab4
	pc = 0x822DEAB4; continue 'dispatch;
	// 822DEAB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DEAB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DEAB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DEABC: 409A0044  bne cr6, 0x822deb00
	if !ctx.cr[6].eq {
	pc = 0x822DEB00; continue 'dispatch;
	}
	// 822DEAC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DEAC4: 419A001C  beq cr6, 0x822deae0
	if ctx.cr[6].eq {
	pc = 0x822DEAE0; continue 'dispatch;
	}
	// 822DEAC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEACC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DEAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEAD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEAD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DEADC: 4E800421  bctrl
	ctx.lr = 0x822DEAE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DEAE0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DEAE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DEAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEAEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DEAF0: 816B34F4  lwz r11, 0x34f4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13556 as u32) ) } as u64;
	// 822DEAF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DEAF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DEAFC: 4BFE1505  bl 0x822c0000
	ctx.lr = 0x822DEB00;
	sub_822C0000(ctx, base);
	// 822DEB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DEB04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DEB08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DEB0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DEB10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DEB14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DEB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DEB20 size=108
    let mut pc: u32 = 0x822DEB20;
    'dispatch: loop {
        match pc {
            0x822DEB20 => {
    //   block [0x822DEB20..0x822DEB8C)
	// 822DEB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DEB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DEB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DEB34: 482325BD  bl 0x825110f0
	ctx.lr = 0x822DEB38;
	sub_825110F0(ctx, base);
	// 822DEB38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEB3C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DEB40: 396BA5E4  addi r11, r11, -0x5a1c
	ctx.r[11].s64 = ctx.r[11].s64 + -23068;
	// 822DEB44: 394AA5D0  addi r10, r10, -0x5a30
	ctx.r[10].s64 = ctx.r[10].s64 + -23088;
	// 822DEB48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DEB4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822DEB50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DEB54: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822DEB58: 993F00C0  stb r9, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u8 ) };
	// 822DEB5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEB60: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822DEB64: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822DEB68: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 822DEB6C: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 822DEB70: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 822DEB74: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 822DEB78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DEB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DEB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DEB84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DEB88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DEB90 size=8
    let mut pc: u32 = 0x822DEB90;
    'dispatch: loop {
        match pc {
            0x822DEB90 => {
    //   block [0x822DEB90..0x822DEB98)
	// 822DEB90: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 822DEB94: 48000064  b 0x822debf8
	sub_822DEBF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DEB98 size=96
    let mut pc: u32 = 0x822DEB98;
    'dispatch: loop {
        match pc {
            0x822DEB98 => {
    //   block [0x822DEB98..0x822DEBF8)
	// 822DEB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DEBA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DEBA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DEBAC: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 822DEBB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DEBB4: 419A0008  beq cr6, 0x822debbc
	if ctx.cr[6].eq {
	pc = 0x822DEBBC; continue 'dispatch;
	}
	// 822DEBB8: 4BFE1CD9  bl 0x822c0890
	ctx.lr = 0x822DEBBC;
	sub_822C0890(ctx, base);
	// 822DEBBC: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 822DEBC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DEBC4: 419A0008  beq cr6, 0x822debcc
	if ctx.cr[6].eq {
	pc = 0x822DEBCC; continue 'dispatch;
	}
	// 822DEBC8: 4BFE1CC9  bl 0x822c0890
	ctx.lr = 0x822DEBCC;
	sub_822C0890(ctx, base);
	// 822DEBCC: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 822DEBD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DEBD4: 419A0008  beq cr6, 0x822debdc
	if ctx.cr[6].eq {
	pc = 0x822DEBDC; continue 'dispatch;
	}
	// 822DEBD8: 4BFE1CB9  bl 0x822c0890
	ctx.lr = 0x822DEBDC;
	sub_822C0890(ctx, base);
	// 822DEBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEBE0: 482325B9  bl 0x82511198
	ctx.lr = 0x822DEBE4;
	sub_82511198(ctx, base);
	// 822DEBE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DEBE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DEBEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DEBF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DEBF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DEBF8 size=76
    let mut pc: u32 = 0x822DEBF8;
    'dispatch: loop {
        match pc {
            0x822DEBF8 => {
    //   block [0x822DEBF8..0x822DEC44)
	// 822DEBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DEC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DEC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DEC08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DEC10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DEC14: 4BFFFF85  bl 0x822deb98
	ctx.lr = 0x822DEC18;
	sub_822DEB98(ctx, base);
	// 822DEC18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DEC1C: 4182000C  beq 0x822dec28
	if ctx.cr[0].eq {
	pc = 0x822DEC28; continue 'dispatch;
	}
	// 822DEC20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEC24: 48B137B5  bl 0x82df23d8
	ctx.lr = 0x822DEC28;
	sub_82DF23D8(ctx, base);
	// 822DEC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEC2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DEC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DEC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DEC38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DEC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DEC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DEC48 size=116
    let mut pc: u32 = 0x822DEC48;
    'dispatch: loop {
        match pc {
            0x822DEC48 => {
    //   block [0x822DEC48..0x822DECBC)
	// 822DEC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DEC50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DEC54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DEC58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DEC60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DEC64: 4823248D  bl 0x825110f0
	ctx.lr = 0x822DEC68;
	sub_825110F0(ctx, base);
	// 822DEC68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEC6C: 9BDF00C0  stb r30, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 822DEC70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DEC74: 392BA5E4  addi r9, r11, -0x5a1c
	ctx.r[9].s64 = ctx.r[11].s64 + -23068;
	// 822DEC78: 394AA5D0  addi r10, r10, -0x5a30
	ctx.r[10].s64 = ctx.r[10].s64 + -23088;
	// 822DEC7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DEC80: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DEC84: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822DEC88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEC8C: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822DEC90: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 822DEC94: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 822DEC98: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 822DEC9C: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 822DECA0: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 822DECA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DECA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DECAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DECB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DECB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DECB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DECC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DECC0 size=576
    let mut pc: u32 = 0x822DECC0;
    'dispatch: loop {
        match pc {
            0x822DECC0 => {
    //   block [0x822DECC0..0x822DEF00)
	// 822DECC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DECC4: 48EC94A1  bl 0x831a8164
	ctx.lr = 0x822DECC8;
	sub_831A8130(ctx, base);
	// 822DECC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DECCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DECD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DECD4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DECD8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DECDC: D03F0134  stfs f1, 0x134(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 822DECE0: 98FF0130  stb r7, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[7].u8 ) };
	// 822DECE4: 991F0131  stb r8, 0x131(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(305 as u32), ctx.r[8].u8 ) };
	// 822DECE8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DECEC: 4BFF3095  bl 0x822d1d80
	ctx.lr = 0x822DECF0;
	sub_822D1D80(ctx, base);
	// 822DECF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DECF4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DECF8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822DECFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DED00: 4BFF3209  bl 0x822d1f08
	ctx.lr = 0x822DED04;
	sub_822D1F08(ctx, base);
	// 822DED04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DED08: 3BDF00C4  addi r30, r31, 0xc4
	ctx.r[30].s64 = ctx.r[31].s64 + 196;
	// 822DED0C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DED10: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822DED14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DED18: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822DED1C: 4BFE5745  bl 0x822c4460
	ctx.lr = 0x822DED20;
	sub_822C4460(ctx, base);
	// 822DED20: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822DED24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DED28: 419A0008  beq cr6, 0x822ded30
	if ctx.cr[6].eq {
	pc = 0x822DED30; continue 'dispatch;
	}
	// 822DED2C: 4BFE1B65  bl 0x822c0890
	ctx.lr = 0x822DED30;
	sub_822C0890(ctx, base);
	// 822DED30: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DED34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DED38: 409A0018  bne cr6, 0x822ded50
	if !ctx.cr[6].eq {
	pc = 0x822DED50; continue 'dispatch;
	}
	// 822DED3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DED40: 4BFF3059  bl 0x822d1d98
	ctx.lr = 0x822DED44;
	sub_822D1D98(ctx, base);
	// 822DED44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DED48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822DED4C: 48EC9468  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 822DED50: 48B1FA91  bl 0x82dfe7e0
	ctx.lr = 0x822DED54;
	sub_82DFE7E0(ctx, base);
	// 822DED54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DED58: 40820064  bne 0x822dedbc
	if !ctx.cr[0].eq {
	pc = 0x822DEDBC; continue 'dispatch;
	}
	// 822DED5C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DED60: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DED64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DED68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DED6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DED70: 419A0024  beq cr6, 0x822ded94
	if ctx.cr[6].eq {
	pc = 0x822DED94; continue 'dispatch;
	}
	// 822DED74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DED78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DED7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DED80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DED84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DED88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DED8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DED90: 4082FFE8  bne 0x822ded78
	if !ctx.cr[0].eq {
	pc = 0x822DED78; continue 'dispatch;
	}
	// 822DED94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822DED98: 4820BCF1  bl 0x824eaa88
	ctx.lr = 0x822DED9C;
	sub_824EAA88(ctx, base);
	// 822DED9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEDA0: 38C0004C  li r6, 0x4c
	ctx.r[6].s64 = 76;
	// 822DEDA4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEDA8: 38ABA61C  addi r5, r11, -0x59e4
	ctx.r[5].s64 = ctx.r[11].s64 + -23012;
	// 822DEDAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822DEDB0: 488DB3D1  bl 0x82bba180
	ctx.lr = 0x822DEDB4;
	sub_82BBA180(ctx, base);
	// 822DEDB4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822DEDB8: 48B12ED9  bl 0x82df1c90
	ctx.lr = 0x822DEDBC;
	sub_82DF1C90(ctx, base);
	// 822DEDBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DEDC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEDC4: 4BFF05DD  bl 0x822cf3a0
	ctx.lr = 0x822DEDC8;
	sub_822CF3A0(ctx, base);
	// 822DEDC8: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 822DEDCC: 907F00CC  stw r3, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[3].u32 ) };
	// 822DEDD0: 817D16D8  lwz r11, 0x16d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5848 as u32) ) } as u64;
	// 822DEDD4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DEDD8: 419AFF64  beq cr6, 0x822ded3c
	if ctx.cr[6].eq {
	pc = 0x822DED3C; continue 'dispatch;
	}
	// 822DEDDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEDE0: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEDE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DEDE8: 38ABA618  addi r5, r11, -0x59e8
	ctx.r[5].s64 = ctx.r[11].s64 + -23016;
	// 822DEDEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEDF0: 48B14F09  bl 0x82df3cf8
	ctx.lr = 0x822DEDF4;
	sub_82DF3CF8(ctx, base);
	// 822DEDF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DEDF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DEDFC: 4BFF05A5  bl 0x822cf3a0
	ctx.lr = 0x822DEE00;
	sub_822CF3A0(ctx, base);
	// 822DEE00: 907F00D0  stw r3, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 822DEE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEE08: 48B14621  bl 0x82df3428
	ctx.lr = 0x822DEE0C;
	sub_82DF3428(ctx, base);
	// 822DEE0C: 817D16D8  lwz r11, 0x16d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5848 as u32) ) } as u64;
	// 822DEE10: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DEE14: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DEE18: 409A0078  bne cr6, 0x822dee90
	if !ctx.cr[6].eq {
	pc = 0x822DEE90; continue 'dispatch;
	}
	// 822DEE1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEE20: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEE24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DEE28: 38ABA614  addi r5, r11, -0x59ec
	ctx.r[5].s64 = ctx.r[11].s64 + -23020;
	// 822DEE2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEE30: 48B14EC9  bl 0x82df3cf8
	ctx.lr = 0x822DEE34;
	sub_82DF3CF8(ctx, base);
	// 822DEE34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DEE38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DEE3C: 4BFF0565  bl 0x822cf3a0
	ctx.lr = 0x822DEE40;
	sub_822CF3A0(ctx, base);
	// 822DEE40: 907F00D0  stw r3, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 822DEE44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEE48: 48B145E1  bl 0x82df3428
	ctx.lr = 0x822DEE4C;
	sub_82DF3428(ctx, base);
	// 822DEE4C: 817D16D8  lwz r11, 0x16d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5848 as u32) ) } as u64;
	// 822DEE50: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DEE54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DEE58: 409A0038  bne cr6, 0x822dee90
	if !ctx.cr[6].eq {
	pc = 0x822DEE90; continue 'dispatch;
	}
	// 822DEE5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEE60: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEE64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822DEE68: 38ABA60C  addi r5, r11, -0x59f4
	ctx.r[5].s64 = ctx.r[11].s64 + -23028;
	// 822DEE6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEE70: 48B14E89  bl 0x82df3cf8
	ctx.lr = 0x822DEE74;
	sub_82DF3CF8(ctx, base);
	// 822DEE74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DEE78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DEE7C: 4BFF0525  bl 0x822cf3a0
	ctx.lr = 0x822DEE80;
	sub_822CF3A0(ctx, base);
	// 822DEE80: 907F00D0  stw r3, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 822DEE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEE88: 48B145A1  bl 0x82df3428
	ctx.lr = 0x822DEE8C;
	sub_82DF3428(ctx, base);
	// 822DEE8C: 817D16D8  lwz r11, 0x16d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5848 as u32) ) } as u64;
	// 822DEE90: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DEE94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DEE98: 409A0018  bne cr6, 0x822deeb0
	if !ctx.cr[6].eq {
	pc = 0x822DEEB0; continue 'dispatch;
	}
	// 822DEE9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DEEA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DEEA4: 4BFF2EF5  bl 0x822d1d98
	ctx.lr = 0x822DEEA8;
	sub_822D1D98(ctx, base);
	// 822DEEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DEEAC: 4BFFFE9C  b 0x822ded48
	pc = 0x822DED48; continue 'dispatch;
	// 822DEEB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822DEEB4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEEB8: 80BF00CC  lwz r5, 0xcc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DEEBC: 4BFF097D  bl 0x822cf838
	ctx.lr = 0x822DEEC0;
	sub_822CF838(ctx, base);
	// 822DEEC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DEEC4: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 822DEEC8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DEECC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822DEED0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEED4: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 822DEED8: 4BFE5589  bl 0x822c4460
	ctx.lr = 0x822DEEDC;
	sub_822C4460(ctx, base);
	// 822DEEDC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DEEE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DEEE4: 419A0008  beq cr6, 0x822deeec
	if ctx.cr[6].eq {
	pc = 0x822DEEEC; continue 'dispatch;
	}
	// 822DEEE8: 4BFE19A9  bl 0x822c0890
	ctx.lr = 0x822DEEEC;
	sub_822C0890(ctx, base);
	// 822DEEEC: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 822DEEF0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEEF4: 4BFF1A75  bl 0x822d0968
	ctx.lr = 0x822DEEF8;
	sub_822D0968(ctx, base);
	// 822DEEF8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822DEEFC: 4BFFFFA4  b 0x822deea0
	pc = 0x822DEEA0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DEF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DEF00 size=1096
    let mut pc: u32 = 0x822DEF00;
    'dispatch: loop {
        match pc {
            0x822DEF00 => {
    //   block [0x822DEF00..0x822DF348)
	// 822DEF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DEF04: 48EC9259  bl 0x831a815c
	ctx.lr = 0x822DEF08;
	sub_831A8130(ctx, base);
	// 822DEF08: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 822DEF0C: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DEF10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DEF14: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 822DEF18: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 822DEF1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822DEF20: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 822DEF24: 409A0008  bne cr6, 0x822def2c
	if !ctx.cr[6].eq {
	pc = 0x822DEF2C; continue 'dispatch;
	}
	// 822DEF28: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 822DEF2C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 822DEF30: 48229871  bl 0x825087a0
	ctx.lr = 0x822DEF34;
	sub_825087A0(ctx, base);
	// 822DEF34: 897D0130  lbz r11, 0x130(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(304 as u32) ) } as u64;
	// 822DEF38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DEF3C: 41820010  beq 0x822def4c
	if ctx.cr[0].eq {
	pc = 0x822DEF4C; continue 'dispatch;
	}
	// 822DEF40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DEF44: 83EB66A8  lwz r31, 0x66a8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26280 as u32) ) } as u64;
	// 822DEF48: 4800000C  b 0x822def54
	pc = 0x822DEF54; continue 'dispatch;
	// 822DEF4C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DEF50: 83EB66AC  lwz r31, 0x66ac(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26284 as u32) ) } as u64;
	// 822DEF54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DEF58: 83DD0120  lwz r30, 0x120(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(288 as u32) ) } as u64;
	// 822DEF5C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822DEF60: C3FD0134  lfs f31, 0x134(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822DEF64: 3B9D0128  addi r28, r29, 0x128
	ctx.r[28].s64 = ctx.r[29].s64 + 296;
	// 822DEF68: 482305B1  bl 0x8250f518
	ctx.lr = 0x822DEF6C;
	sub_8250F518(ctx, base);
	// 822DEF6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822DEF70: 38BD0028  addi r5, r29, 0x28
	ctx.r[5].s64 = ctx.r[29].s64 + 40;
	// 822DEF74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822DEF78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DEF7C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 822DEF80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822DEF84: 4BFF1E85  bl 0x822d0e08
	ctx.lr = 0x822DEF88;
	sub_822D0E08(ctx, base);
	// 822DEF88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DEF8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822DEF90: 4BFFF9B1  bl 0x822de940
	ctx.lr = 0x822DEF94;
	sub_822DE940(ctx, base);
	// 822DEF94: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 822DEF98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DEF9C: 419A0008  beq cr6, 0x822defa4
	if ctx.cr[6].eq {
	pc = 0x822DEFA4; continue 'dispatch;
	}
	// 822DEFA0: 4BFE18F1  bl 0x822c0890
	ctx.lr = 0x822DEFA4;
	sub_822C0890(ctx, base);
	// 822DEFA4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822DEFA8: 48B12CE9  bl 0x82df1c90
	ctx.lr = 0x822DEFAC;
	sub_82DF1C90(ctx, base);
	// 822DEFAC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DEFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DEFB4: 386BFEF0  addi r3, r11, -0x110
	ctx.r[3].s64 = ctx.r[11].s64 + -272;
	// 822DEFB8: 409A0008  bne cr6, 0x822defc0
	if !ctx.cr[6].eq {
	pc = 0x822DEFC0; continue 'dispatch;
	}
	// 822DEFBC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822DEFC0: 48007DC1  bl 0x822e6d80
	ctx.lr = 0x822DEFC4;
	sub_822E6D80(ctx, base);
	// 822DEFC4: 897D00C0  lbz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 822DEFC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DEFCC: 41820370  beq 0x822df33c
	if ctx.cr[0].eq {
	pc = 0x822DF33C; continue 'dispatch;
	}
	// 822DEFD0: 895D0131  lbz r10, 0x131(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(305 as u32) ) } as u64;
	// 822DEFD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEFD8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DEFDC: 3B6BA61C  addi r27, r11, -0x59e4
	ctx.r[27].s64 = ctx.r[11].s64 + -23012;
	// 822DEFE0: 418201C8  beq 0x822df1a8
	if ctx.cr[0].eq {
	pc = 0x822DF1A8; continue 'dispatch;
	}
	// 822DEFE4: 897D0130  lbz r11, 0x130(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(304 as u32) ) } as u64;
	// 822DEFE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DEFEC: 418201BC  beq 0x822df1a8
	if ctx.cr[0].eq {
	pc = 0x822DF1A8; continue 'dispatch;
	}
	// 822DEFF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DEFF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DEFF8: 388BA658  addi r4, r11, -0x59a8
	ctx.r[4].s64 = ctx.r[11].s64 + -22952;
	// 822DEFFC: 48B14A0D  bl 0x82df3a08
	ctx.lr = 0x822DF000;
	sub_82DF3A08(ctx, base);
	// 822DF000: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF004: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DF008: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF00C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 822DF010: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF014: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822DF018: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822DF01C: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822DF020: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822DF024: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822DF028: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822DF02C: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822DF030: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822DF034: 4858C515  bl 0x8286b548
	ctx.lr = 0x822DF038;
	sub_8286B548(ctx, base);
	// 822DF038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DF03C: 48B143ED  bl 0x82df3428
	ctx.lr = 0x822DF040;
	sub_82DF3428(ctx, base);
	// 822DF040: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822DF044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF048: 419A0150  beq cr6, 0x822df198
	if ctx.cr[6].eq {
	pc = 0x822DF198; continue 'dispatch;
	}
	// 822DF04C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822DF050: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 822DF054: 4800640D  bl 0x822e5460
	ctx.lr = 0x822DF058;
	sub_822E5460(ctx, base);
	// 822DF058: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DF05C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DF060: 38A00092  li r5, 0x92
	ctx.r[5].s64 = 146;
	// 822DF064: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822DF068: 48B13381  bl 0x82df23e8
	ctx.lr = 0x822DF06C;
	sub_82DF23E8(ctx, base);
	// 822DF06C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF070: 41820018  beq 0x822df088
	if ctx.cr[0].eq {
	pc = 0x822DF088; continue 'dispatch;
	}
	// 822DF074: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 822DF078: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DF07C: 484D7395  bl 0x827b6410
	ctx.lr = 0x822DF080;
	sub_827B6410(ctx, base);
	// 822DF080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF084: 48000008  b 0x822df08c
	pc = 0x822DF08C; continue 'dispatch;
	// 822DF088: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822DF08C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822DF090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF094: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF098: 4BFFF8F9  bl 0x822de990
	ctx.lr = 0x822DF09C;
	sub_822DE990(ctx, base);
	// 822DF09C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DF0A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF0A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF0A8: 4BFE0F59  bl 0x822c0000
	ctx.lr = 0x822DF0AC;
	sub_822C0000(ctx, base);
	// 822DF0AC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822DF0B0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822DF0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF0B8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822DF0BC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 822DF0C0: 419A0024  beq cr6, 0x822df0e4
	if ctx.cr[6].eq {
	pc = 0x822DF0E4; continue 'dispatch;
	}
	// 822DF0C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DF0C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF0CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF0D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF0D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF0D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF0DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF0E0: 4082FFE8  bne 0x822df0c8
	if !ctx.cr[0].eq {
	pc = 0x822DF0C8; continue 'dispatch;
	}
	// 822DF0E4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DF0E8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822DF0EC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822DF0F0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822DF0F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF0F8: 808B7078  lwz r4, 0x7078(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28792 as u32) ) } as u64;
	// 822DF0FC: 482318FD  bl 0x825109f8
	ctx.lr = 0x822DF100;
	sub_825109F8(ctx, base);
	// 822DF100: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 822DF104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF108: 419A0008  beq cr6, 0x822df110
	if ctx.cr[6].eq {
	pc = 0x822DF110; continue 'dispatch;
	}
	// 822DF10C: 4BFE1785  bl 0x822c0890
	ctx.lr = 0x822DF110;
	sub_822C0890(ctx, base);
	// 822DF110: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DF114: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 822DF118: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF11C: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 822DF120: 419A0024  beq cr6, 0x822df144
	if ctx.cr[6].eq {
	pc = 0x822DF144; continue 'dispatch;
	}
	// 822DF124: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822DF128: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF12C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF130: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF134: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF138: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF13C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF140: 4082FFE8  bne 0x822df128
	if !ctx.cr[0].eq {
	pc = 0x822DF128; continue 'dispatch;
	}
	// 822DF144: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DF148: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822DF14C: 4823037D  bl 0x8250f4c8
	ctx.lr = 0x822DF150;
	sub_8250F4C8(ctx, base);
	// 822DF150: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF158: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822DF15C: 409A0008  bne cr6, 0x822df164
	if !ctx.cr[6].eq {
	pc = 0x822DF164; continue 'dispatch;
	}
	// 822DF160: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822DF164: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 822DF168: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822DF16C: 4822B8DD  bl 0x8250aa48
	ctx.lr = 0x822DF170;
	sub_8250AA48(ctx, base);
	// 822DF170: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822DF174: 48B12B1D  bl 0x82df1c90
	ctx.lr = 0x822DF178;
	sub_82DF1C90(ctx, base);
	// 822DF178: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 822DF17C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF180: 419A0008  beq cr6, 0x822df188
	if ctx.cr[6].eq {
	pc = 0x822DF188; continue 'dispatch;
	}
	// 822DF184: 4BFE170D  bl 0x822c0890
	ctx.lr = 0x822DF188;
	sub_822C0890(ctx, base);
	// 822DF188: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF18C: 419A000C  beq cr6, 0x822df198
	if ctx.cr[6].eq {
	pc = 0x822DF198; continue 'dispatch;
	}
	// 822DF190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF194: 4BFE16FD  bl 0x822c0890
	ctx.lr = 0x822DF198;
	sub_822C0890(ctx, base);
	// 822DF198: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822DF19C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF1A0: 419A0008  beq cr6, 0x822df1a8
	if ctx.cr[6].eq {
	pc = 0x822DF1A8; continue 'dispatch;
	}
	// 822DF1A4: 4BFE16ED  bl 0x822c0890
	ctx.lr = 0x822DF1A8;
	sub_822C0890(ctx, base);
	// 822DF1A8: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 822DF1AC: 9B210061  stb r25, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[25].u8 ) };
	// 822DF1B0: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 822DF1B4: 9B210063  stb r25, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[25].u8 ) };
	// 822DF1B8: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 822DF1BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822DF1C0: 99410062  stb r10, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[10].u8 ) };
	// 822DF1C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822DF1C8: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF1CC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF1D0: 4858C379  bl 0x8286b548
	ctx.lr = 0x822DF1D4;
	sub_8286B548(ctx, base);
	// 822DF1D4: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822DF1D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF1DC: 419A0150  beq cr6, 0x822df32c
	if ctx.cr[6].eq {
	pc = 0x822DF32C; continue 'dispatch;
	}
	// 822DF1E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822DF1E4: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 822DF1E8: 48006061  bl 0x822e5248
	ctx.lr = 0x822DF1EC;
	sub_822E5248(ctx, base);
	// 822DF1EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DF1F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DF1F4: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 822DF1F8: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822DF1FC: 48B131ED  bl 0x82df23e8
	ctx.lr = 0x822DF200;
	sub_82DF23E8(ctx, base);
	// 822DF200: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF204: 41820018  beq 0x822df21c
	if ctx.cr[0].eq {
	pc = 0x822DF21C; continue 'dispatch;
	}
	// 822DF208: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 822DF20C: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DF210: 484D7201  bl 0x827b6410
	ctx.lr = 0x822DF214;
	sub_827B6410(ctx, base);
	// 822DF214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF218: 48000008  b 0x822df220
	pc = 0x822DF220; continue 'dispatch;
	// 822DF21C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822DF220: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822DF224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF228: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF22C: 4BFFF765  bl 0x822de990
	ctx.lr = 0x822DF230;
	sub_822DE990(ctx, base);
	// 822DF230: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DF234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF238: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF23C: 4BFE0DC5  bl 0x822c0000
	ctx.lr = 0x822DF240;
	sub_822C0000(ctx, base);
	// 822DF240: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DF244: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 822DF248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF24C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 822DF250: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 822DF254: 419A0024  beq cr6, 0x822df278
	if ctx.cr[6].eq {
	pc = 0x822DF278; continue 'dispatch;
	}
	// 822DF258: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DF25C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF260: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF264: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF268: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF26C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF270: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF274: 4082FFE8  bne 0x822df25c
	if !ctx.cr[0].eq {
	pc = 0x822DF25C; continue 'dispatch;
	}
	// 822DF278: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DF27C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822DF280: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822DF284: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 822DF288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF28C: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 822DF290: 48231769  bl 0x825109f8
	ctx.lr = 0x822DF294;
	sub_825109F8(ctx, base);
	// 822DF294: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822DF298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF29C: 419A0008  beq cr6, 0x822df2a4
	if ctx.cr[6].eq {
	pc = 0x822DF2A4; continue 'dispatch;
	}
	// 822DF2A0: 4BFE15F1  bl 0x822c0890
	ctx.lr = 0x822DF2A4;
	sub_822C0890(ctx, base);
	// 822DF2A4: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DF2A8: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 822DF2AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF2B0: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 822DF2B4: 419A0024  beq cr6, 0x822df2d8
	if ctx.cr[6].eq {
	pc = 0x822DF2D8; continue 'dispatch;
	}
	// 822DF2B8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822DF2BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF2C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF2C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF2C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF2CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF2D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF2D4: 4082FFE8  bne 0x822df2bc
	if !ctx.cr[0].eq {
	pc = 0x822DF2BC; continue 'dispatch;
	}
	// 822DF2D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DF2DC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 822DF2E0: 482301E9  bl 0x8250f4c8
	ctx.lr = 0x822DF2E4;
	sub_8250F4C8(ctx, base);
	// 822DF2E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF2EC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822DF2F0: 409A0008  bne cr6, 0x822df2f8
	if !ctx.cr[6].eq {
	pc = 0x822DF2F8; continue 'dispatch;
	}
	// 822DF2F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822DF2F8: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 822DF2FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822DF300: 4822B749  bl 0x8250aa48
	ctx.lr = 0x822DF304;
	sub_8250AA48(ctx, base);
	// 822DF304: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 822DF308: 48B12989  bl 0x82df1c90
	ctx.lr = 0x822DF30C;
	sub_82DF1C90(ctx, base);
	// 822DF30C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 822DF310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF314: 419A0008  beq cr6, 0x822df31c
	if ctx.cr[6].eq {
	pc = 0x822DF31C; continue 'dispatch;
	}
	// 822DF318: 4BFE1579  bl 0x822c0890
	ctx.lr = 0x822DF31C;
	sub_822C0890(ctx, base);
	// 822DF31C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF320: 419A000C  beq cr6, 0x822df32c
	if ctx.cr[6].eq {
	pc = 0x822DF32C; continue 'dispatch;
	}
	// 822DF324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF328: 4BFE1569  bl 0x822c0890
	ctx.lr = 0x822DF32C;
	sub_822C0890(ctx, base);
	// 822DF32C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DF330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF334: 419A0008  beq cr6, 0x822df33c
	if ctx.cr[6].eq {
	pc = 0x822DF33C; continue 'dispatch;
	}
	// 822DF338: 4BFE1559  bl 0x822c0890
	ctx.lr = 0x822DF33C;
	sub_822C0890(ctx, base);
	// 822DF33C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 822DF340: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 822DF344: 48EC8E68  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DF348 size=144
    let mut pc: u32 = 0x822DF348;
    'dispatch: loop {
        match pc {
            0x822DF348 => {
    //   block [0x822DF348..0x822DF3D8)
	// 822DF348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF34C: 48EC8E19  bl 0x831a8164
	ctx.lr = 0x822DF350;
	sub_831A8130(ctx, base);
	// 822DF350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF354: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF358: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822DF35C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DF360: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DF364: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822DF368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DF36C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 822DF370: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 822DF374: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 822DF378: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 822DF37C: 48B1306D  bl 0x82df23e8
	ctx.lr = 0x822DF380;
	sub_82DF23E8(ctx, base);
	// 822DF380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF384: 41820020  beq 0x822df3a4
	if ctx.cr[0].eq {
	pc = 0x822DF3A4; continue 'dispatch;
	}
	// 822DF388: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822DF38C: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF394: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF398: 488772C1  bl 0x82b56658
	ctx.lr = 0x822DF39C;
	sub_82B56658(ctx, base);
	// 822DF39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF3A0: 48000008  b 0x822df3a8
	pc = 0x822DF3A8; continue 'dispatch;
	// 822DF3A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DF3A8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DF3AC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 822DF3B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF3B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF3B8: 4BFFF6A1  bl 0x822dea58
	ctx.lr = 0x822DF3BC;
	sub_822DEA58(ctx, base);
	// 822DF3BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DF3C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF3C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF3C8: 4BFE0C39  bl 0x822c0000
	ctx.lr = 0x822DF3CC;
	sub_822C0000(ctx, base);
	// 822DF3CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822DF3D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DF3D4: 48EC8DE0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DF3D8 size=220
    let mut pc: u32 = 0x822DF3D8;
    'dispatch: loop {
        match pc {
            0x822DF3D8 => {
    //   block [0x822DF3D8..0x822DF4B4)
	// 822DF3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DF3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DF3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DF3E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF3F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DF3F4: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 822DF3F8: 48510341  bl 0x827ef738
	ctx.lr = 0x822DF3FC;
	sub_827EF738(ctx, base);
	// 822DF3FC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 822DF400: 38DF00D0  addi r6, r31, 0xd0
	ctx.r[6].s64 = ctx.r[31].s64 + 208;
	// 822DF404: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 822DF408: 389F00C4  addi r4, r31, 0xc4
	ctx.r[4].s64 = ctx.r[31].s64 + 196;
	// 822DF40C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DF410: 4BFFFF39  bl 0x822df348
	ctx.lr = 0x822DF414;
	sub_822DF348(ctx, base);
	// 822DF414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF418: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822DF41C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DF420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF424: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DF428: 419A0024  beq cr6, 0x822df44c
	if ctx.cr[6].eq {
	pc = 0x822DF44C; continue 'dispatch;
	}
	// 822DF42C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DF430: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF434: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF438: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF43C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF440: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF444: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF448: 4082FFE8  bne 0x822df430
	if !ctx.cr[0].eq {
	pc = 0x822DF430; continue 'dispatch;
	}
	// 822DF44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF450: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822DF454: 48D28CD5  bl 0x83008128
	ctx.lr = 0x822DF458;
	sub_83008128(ctx, base);
	// 822DF458: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DF45C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DF460: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822DF464: 388AA61C  addi r4, r10, -0x59e4
	ctx.r[4].s64 = ctx.r[10].s64 + -23012;
	// 822DF468: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 822DF46C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 822DF470: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DF474: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822DF478: 48B795C9  bl 0x82e58a40
	ctx.lr = 0x822DF47C;
	sub_82E58A40(ctx, base);
	// 822DF47C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DF480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF484: 419A0008  beq cr6, 0x822df48c
	if ctx.cr[6].eq {
	pc = 0x822DF48C; continue 'dispatch;
	}
	// 822DF488: 4BFE1409  bl 0x822c0890
	ctx.lr = 0x822DF48C;
	sub_822C0890(ctx, base);
	// 822DF48C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DF490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF494: 419A0008  beq cr6, 0x822df49c
	if ctx.cr[6].eq {
	pc = 0x822DF49C; continue 'dispatch;
	}
	// 822DF498: 4BFE13F9  bl 0x822c0890
	ctx.lr = 0x822DF49C;
	sub_822C0890(ctx, base);
	// 822DF49C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DF4A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DF4A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DF4A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DF4AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DF4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DF4B8 size=276
    let mut pc: u32 = 0x822DF4B8;
    'dispatch: loop {
        match pc {
            0x822DF4B8 => {
    //   block [0x822DF4B8..0x822DF5CC)
	// 822DF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF4BC: 48EC8CAD  bl 0x831a8168
	ctx.lr = 0x822DF4C0;
	sub_831A8130(ctx, base);
	// 822DF4C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF4C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822DF4C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DF4CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DF4D0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822DF4D4: 41820038  beq 0x822df50c
	if ctx.cr[0].eq {
	pc = 0x822DF50C; continue 'dispatch;
	}
	// 822DF4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF4DC: 48ECA4AD  bl 0x831a9988
	ctx.lr = 0x822DF4E0;
	sub_831A9988(ctx, base);
	// 822DF4E0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DF4E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DF4E8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 822DF4EC: 48EC8C0D  bl 0x831a80f8
	ctx.lr = 0x822DF4F0;
	sub_831A80F8(ctx, base);
	// 822DF4F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DF4F4: 41820018  beq 0x822df50c
	if ctx.cr[0].eq {
	pc = 0x822DF50C; continue 'dispatch;
	}
	// 822DF4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF4FC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822DF500: 4BFFFED9  bl 0x822df3d8
	ctx.lr = 0x822DF504;
	sub_822DF3D8(ctx, base);
	// 822DF504: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DF508: 480000BC  b 0x822df5c4
	pc = 0x822DF5C4; continue 'dispatch;
	// 822DF50C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822DF510: 419A00A4  beq cr6, 0x822df5b4
	if ctx.cr[6].eq {
	pc = 0x822DF5B4; continue 'dispatch;
	}
	// 822DF514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF518: 48ECA471  bl 0x831a9988
	ctx.lr = 0x822DF51C;
	sub_831A9988(ctx, base);
	// 822DF51C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DF520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DF524: 386B361C  addi r3, r11, 0x361c
	ctx.r[3].s64 = ctx.r[11].s64 + 13852;
	// 822DF528: 48EC8BD1  bl 0x831a80f8
	ctx.lr = 0x822DF52C;
	sub_831A80F8(ctx, base);
	// 822DF52C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DF530: 41820014  beq 0x822df544
	if ctx.cr[0].eq {
	pc = 0x822DF544; continue 'dispatch;
	}
	// 822DF534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF538: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822DF53C: 4BFFF22D  bl 0x822de768
	ctx.lr = 0x822DF540;
	sub_822DE768(ctx, base);
	// 822DF540: 4BFFFFC4  b 0x822df504
	pc = 0x822DF504; continue 'dispatch;
	// 822DF544: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822DF548: 419A006C  beq cr6, 0x822df5b4
	if ctx.cr[6].eq {
	pc = 0x822DF5B4; continue 'dispatch;
	}
	// 822DF54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF550: 48ECA439  bl 0x831a9988
	ctx.lr = 0x822DF554;
	sub_831A9988(ctx, base);
	// 822DF554: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DF558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DF55C: 386B35EC  addi r3, r11, 0x35ec
	ctx.r[3].s64 = ctx.r[11].s64 + 13804;
	// 822DF560: 48EC8B99  bl 0x831a80f8
	ctx.lr = 0x822DF564;
	sub_831A80F8(ctx, base);
	// 822DF564: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DF568: 41820014  beq 0x822df57c
	if ctx.cr[0].eq {
	pc = 0x822DF57C; continue 'dispatch;
	}
	// 822DF56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF570: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822DF574: 4BFFF275  bl 0x822de7e8
	ctx.lr = 0x822DF578;
	sub_822DE7E8(ctx, base);
	// 822DF578: 4BFFFF8C  b 0x822df504
	pc = 0x822DF504; continue 'dispatch;
	// 822DF57C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822DF580: 419A0034  beq cr6, 0x822df5b4
	if ctx.cr[6].eq {
	pc = 0x822DF5B4; continue 'dispatch;
	}
	// 822DF584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF588: 48ECA401  bl 0x831a9988
	ctx.lr = 0x822DF58C;
	sub_831A9988(ctx, base);
	// 822DF58C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DF590: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DF594: 386B35BC  addi r3, r11, 0x35bc
	ctx.r[3].s64 = ctx.r[11].s64 + 13756;
	// 822DF598: 48EC8B61  bl 0x831a80f8
	ctx.lr = 0x822DF59C;
	sub_831A80F8(ctx, base);
	// 822DF59C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DF5A0: 41820014  beq 0x822df5b4
	if ctx.cr[0].eq {
	pc = 0x822DF5B4; continue 'dispatch;
	}
	// 822DF5A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF5A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822DF5AC: 4BFFF32D  bl 0x822de8d8
	ctx.lr = 0x822DF5B0;
	sub_822DE8D8(ctx, base);
	// 822DF5B0: 4BFFFF54  b 0x822df504
	pc = 0x822DF504; continue 'dispatch;
	// 822DF5B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822DF5B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF5BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF5C0: 48231FD9  bl 0x82511598
	ctx.lr = 0x822DF5C4;
	sub_82511598(ctx, base);
	// 822DF5C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DF5C8: 48EC8BF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DF5D0 size=196
    let mut pc: u32 = 0x822DF5D0;
    'dispatch: loop {
        match pc {
            0x822DF5D0 => {
    //   block [0x822DF5D0..0x822DF694)
	// 822DF5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DF5D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DF5DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DF5E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF5E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DF5E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DF5EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DF5F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DF5F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DF5F8: 4BFE1341  bl 0x822c0938
	ctx.lr = 0x822DF5FC;
	sub_822C0938(ctx, base);
	// 822DF5FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF600: 41820028  beq 0x822df628
	if ctx.cr[0].eq {
	pc = 0x822DF628; continue 'dispatch;
	}
	// 822DF604: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF608: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DF60C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DF610: 392BA6A0  addi r9, r11, -0x5960
	ctx.r[9].s64 = ctx.r[11].s64 + -22880;
	// 822DF614: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DF618: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DF61C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DF620: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DF624: 48000008  b 0x822df62c
	pc = 0x822DF62C; continue 'dispatch;
	// 822DF628: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DF62C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DF630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF634: 409A0044  bne cr6, 0x822df678
	if !ctx.cr[6].eq {
	pc = 0x822DF678; continue 'dispatch;
	}
	// 822DF638: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DF63C: 419A001C  beq cr6, 0x822df658
	if ctx.cr[6].eq {
	pc = 0x822DF658; continue 'dispatch;
	}
	// 822DF640: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF644: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DF648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF64C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DF654: 4E800421  bctrl
	ctx.lr = 0x822DF658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DF658: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DF65C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DF660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DF664: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DF668: 816B3674  lwz r11, 0x3674(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13940 as u32) ) } as u64;
	// 822DF66C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DF670: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DF674: 4BFE098D  bl 0x822c0000
	ctx.lr = 0x822DF678;
	sub_822C0000(ctx, base);
	// 822DF678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF67C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DF680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DF684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DF688: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DF68C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DF690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DF698 size=104
    let mut pc: u32 = 0x822DF698;
    'dispatch: loop {
        match pc {
            0x822DF698 => {
    //   block [0x822DF698..0x822DF700)
	// 822DF698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DF6A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DF6A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF6A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF6AC: 387F012C  addi r3, r31, 0x12c
	ctx.r[3].s64 = ctx.r[31].s64 + 300;
	// 822DF6B0: 48B13D79  bl 0x82df3428
	ctx.lr = 0x822DF6B4;
	sub_82DF3428(ctx, base);
	// 822DF6B4: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 822DF6B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF6BC: 419A0008  beq cr6, 0x822df6c4
	if ctx.cr[6].eq {
	pc = 0x822DF6C4; continue 'dispatch;
	}
	// 822DF6C0: 4BFE11D1  bl 0x822c0890
	ctx.lr = 0x822DF6C4;
	sub_822C0890(ctx, base);
	// 822DF6C4: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DF6C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF6CC: 419A0008  beq cr6, 0x822df6d4
	if ctx.cr[6].eq {
	pc = 0x822DF6D4; continue 'dispatch;
	}
	// 822DF6D0: 4BFE11C1  bl 0x822c0890
	ctx.lr = 0x822DF6D4;
	sub_822C0890(ctx, base);
	// 822DF6D4: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822DF6D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF6DC: 419A0008  beq cr6, 0x822df6e4
	if ctx.cr[6].eq {
	pc = 0x822DF6E4; continue 'dispatch;
	}
	// 822DF6E0: 4BFE11B1  bl 0x822c0890
	ctx.lr = 0x822DF6E4;
	sub_822C0890(ctx, base);
	// 822DF6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF6E8: 48231AB1  bl 0x82511198
	ctx.lr = 0x822DF6EC;
	sub_82511198(ctx, base);
	// 822DF6EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DF6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DF6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DF6F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DF6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DF700 size=92
    let mut pc: u32 = 0x822DF700;
    'dispatch: loop {
        match pc {
            0x822DF700 => {
    //   block [0x822DF700..0x822DF75C)
	// 822DF700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DF708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DF70C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF710: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DF714: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DF718: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822DF71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF720: 808B66A4  lwz r4, 0x66a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26276 as u32) ) } as u64;
	// 822DF724: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DF728: 48002F09  bl 0x822e2630
	ctx.lr = 0x822DF72C;
	sub_822E2630(ctx, base);
	// 822DF72C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF730: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DF734: 396BA6C8  addi r11, r11, -0x5938
	ctx.r[11].s64 = ctx.r[11].s64 + -22840;
	// 822DF738: 394AA6B4  addi r10, r10, -0x594c
	ctx.r[10].s64 = ctx.r[10].s64 + -22860;
	// 822DF73C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DF740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF744: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822DF748: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DF74C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DF750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DF754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DF758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DF760 size=444
    let mut pc: u32 = 0x822DF760;
    'dispatch: loop {
        match pc {
            0x822DF760 => {
    //   block [0x822DF760..0x822DF91C)
	// 822DF760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF764: 48EC8A09  bl 0x831a816c
	ctx.lr = 0x822DF768;
	sub_831A8130(ctx, base);
	// 822DF768: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF76C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DF770: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822DF774: 48002FCD  bl 0x822e2740
	ctx.lr = 0x822DF778;
	sub_822E2740(ctx, base);
	// 822DF778: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 822DF77C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF780: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 822DF784: 809D00D4  lwz r4, 0xd4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 822DF788: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822DF78C: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 822DF790: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 822DF794: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822DF798: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 822DF79C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DF7A0: 99210053  stb r9, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[9].u8 ) };
	// 822DF7A4: 4858BDA5  bl 0x8286b548
	ctx.lr = 0x822DF7A8;
	sub_8286B548(ctx, base);
	// 822DF7A8: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822DF7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF7B0: 419A0154  beq cr6, 0x822df904
	if ctx.cr[6].eq {
	pc = 0x822DF904; continue 'dispatch;
	}
	// 822DF7B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822DF7B8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822DF7BC: 48005A8D  bl 0x822e5248
	ctx.lr = 0x822DF7C0;
	sub_822E5248(ctx, base);
	// 822DF7C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF7C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DF7C8: 388BA6F0  addi r4, r11, -0x5910
	ctx.r[4].s64 = ctx.r[11].s64 + -22800;
	// 822DF7CC: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 822DF7D0: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822DF7D4: 48B12C15  bl 0x82df23e8
	ctx.lr = 0x822DF7D8;
	sub_82DF23E8(ctx, base);
	// 822DF7D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF7DC: 41820018  beq 0x822df7f4
	if ctx.cr[0].eq {
	pc = 0x822DF7F4; continue 'dispatch;
	}
	// 822DF7E0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822DF7E4: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DF7E8: 484D6C29  bl 0x827b6410
	ctx.lr = 0x822DF7EC;
	sub_827B6410(ctx, base);
	// 822DF7EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF7F0: 48000008  b 0x822df7f8
	pc = 0x822DF7F8; continue 'dispatch;
	// 822DF7F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DF7F8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822DF7FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF800: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF804: 4BFFF18D  bl 0x822de990
	ctx.lr = 0x822DF808;
	sub_822DE990(ctx, base);
	// 822DF808: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DF80C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF810: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822DF814: 4BFE07ED  bl 0x822c0000
	ctx.lr = 0x822DF818;
	sub_822C0000(ctx, base);
	// 822DF818: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822DF81C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822DF820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF824: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822DF828: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822DF82C: 419A0024  beq cr6, 0x822df850
	if ctx.cr[6].eq {
	pc = 0x822DF850; continue 'dispatch;
	}
	// 822DF830: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DF834: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF838: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF83C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF840: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF844: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF848: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF84C: 4082FFE8  bne 0x822df834
	if !ctx.cr[0].eq {
	pc = 0x822DF834; continue 'dispatch;
	}
	// 822DF850: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DF854: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822DF858: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822DF85C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 822DF860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DF864: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 822DF868: 48231191  bl 0x825109f8
	ctx.lr = 0x822DF86C;
	sub_825109F8(ctx, base);
	// 822DF86C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822DF870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF874: 419A0008  beq cr6, 0x822df87c
	if ctx.cr[6].eq {
	pc = 0x822DF87C; continue 'dispatch;
	}
	// 822DF878: 4BFE1019  bl 0x822c0890
	ctx.lr = 0x822DF87C;
	sub_822C0890(ctx, base);
	// 822DF87C: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DF880: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 822DF884: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF888: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 822DF88C: 419A0024  beq cr6, 0x822df8b0
	if ctx.cr[6].eq {
	pc = 0x822DF8B0; continue 'dispatch;
	}
	// 822DF890: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822DF894: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF898: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF89C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF8A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF8A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF8A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF8AC: 4082FFE8  bne 0x822df894
	if !ctx.cr[0].eq {
	pc = 0x822DF894; continue 'dispatch;
	}
	// 822DF8B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DF8B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822DF8B8: 4822FC11  bl 0x8250f4c8
	ctx.lr = 0x822DF8BC;
	sub_8250F4C8(ctx, base);
	// 822DF8BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF8C4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822DF8C8: 409A0008  bne cr6, 0x822df8d0
	if !ctx.cr[6].eq {
	pc = 0x822DF8D0; continue 'dispatch;
	}
	// 822DF8CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DF8D0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822DF8D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822DF8D8: 4822B171  bl 0x8250aa48
	ctx.lr = 0x822DF8DC;
	sub_8250AA48(ctx, base);
	// 822DF8DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822DF8E0: 48B123B1  bl 0x82df1c90
	ctx.lr = 0x822DF8E4;
	sub_82DF1C90(ctx, base);
	// 822DF8E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DF8E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF8EC: 419A0008  beq cr6, 0x822df8f4
	if ctx.cr[6].eq {
	pc = 0x822DF8F4; continue 'dispatch;
	}
	// 822DF8F0: 4BFE0FA1  bl 0x822c0890
	ctx.lr = 0x822DF8F4;
	sub_822C0890(ctx, base);
	// 822DF8F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DF8F8: 419A000C  beq cr6, 0x822df904
	if ctx.cr[6].eq {
	pc = 0x822DF904; continue 'dispatch;
	}
	// 822DF8FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF900: 4BFE0F91  bl 0x822c0890
	ctx.lr = 0x822DF904;
	sub_822C0890(ctx, base);
	// 822DF904: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822DF908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DF90C: 419A0008  beq cr6, 0x822df914
	if ctx.cr[6].eq {
	pc = 0x822DF914; continue 'dispatch;
	}
	// 822DF910: 4BFE0F81  bl 0x822c0890
	ctx.lr = 0x822DF914;
	sub_822C0890(ctx, base);
	// 822DF914: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822DF918: 48EC88A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DF920 size=128
    let mut pc: u32 = 0x822DF920;
    'dispatch: loop {
        match pc {
            0x822DF920 => {
    //   block [0x822DF920..0x822DF9A0)
	// 822DF920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF924: 48EC8849  bl 0x831a816c
	ctx.lr = 0x822DF928;
	sub_831A8130(ctx, base);
	// 822DF928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF92C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DF930: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DF934: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DF938: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DF93C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DF940: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 822DF944: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 822DF948: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 822DF94C: 48B12A9D  bl 0x82df23e8
	ctx.lr = 0x822DF950;
	sub_82DF23E8(ctx, base);
	// 822DF950: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DF954: 41820018  beq 0x822df96c
	if ctx.cr[0].eq {
	pc = 0x822DF96C; continue 'dispatch;
	}
	// 822DF958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF95C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF960: 48876C81  bl 0x82b565e0
	ctx.lr = 0x822DF964;
	sub_82B565E0(ctx, base);
	// 822DF964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF968: 48000008  b 0x822df970
	pc = 0x822DF970; continue 'dispatch;
	// 822DF96C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DF970: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822DF974: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822DF978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF980: 4BFFFC51  bl 0x822df5d0
	ctx.lr = 0x822DF984;
	sub_822DF5D0(ctx, base);
	// 822DF984: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DF988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DF98C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DF990: 4BFE0671  bl 0x822c0000
	ctx.lr = 0x822DF994;
	sub_822C0000(ctx, base);
	// 822DF994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DF998: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DF99C: 48EC8820  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DF9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DF9A0 size=204
    let mut pc: u32 = 0x822DF9A0;
    'dispatch: loop {
        match pc {
            0x822DF9A0 => {
    //   block [0x822DF9A0..0x822DFA6C)
	// 822DF9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DF9A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DF9A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DF9AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DF9B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DF9B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DF9B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DF9BC: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 822DF9C0: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 822DF9C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822DF9C8: 4BFFFF59  bl 0x822df920
	ctx.lr = 0x822DF9CC;
	sub_822DF920(ctx, base);
	// 822DF9CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DF9D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822DF9D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DF9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DF9DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DF9E0: 419A0024  beq cr6, 0x822dfa04
	if ctx.cr[6].eq {
	pc = 0x822DFA04; continue 'dispatch;
	}
	// 822DF9E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DF9E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DF9EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DF9F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DF9F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DF9F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DF9FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DFA00: 4082FFE8  bne 0x822df9e8
	if !ctx.cr[0].eq {
	pc = 0x822DF9E8; continue 'dispatch;
	}
	// 822DFA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DFA08: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822DFA0C: 48D2871D  bl 0x83008128
	ctx.lr = 0x822DFA10;
	sub_83008128(ctx, base);
	// 822DFA10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DFA14: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DFA18: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822DFA1C: 388AA6F0  addi r4, r10, -0x5910
	ctx.r[4].s64 = ctx.r[10].s64 + -22800;
	// 822DFA20: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 822DFA24: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 822DFA28: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DFA2C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822DFA30: 48B79011  bl 0x82e58a40
	ctx.lr = 0x822DFA34;
	sub_82E58A40(ctx, base);
	// 822DFA34: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DFA38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFA3C: 419A0008  beq cr6, 0x822dfa44
	if ctx.cr[6].eq {
	pc = 0x822DFA44; continue 'dispatch;
	}
	// 822DFA40: 4BFE0E51  bl 0x822c0890
	ctx.lr = 0x822DFA44;
	sub_822C0890(ctx, base);
	// 822DFA44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822DFA48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFA4C: 419A0008  beq cr6, 0x822dfa54
	if ctx.cr[6].eq {
	pc = 0x822DFA54; continue 'dispatch;
	}
	// 822DFA50: 4BFE0E41  bl 0x822c0890
	ctx.lr = 0x822DFA54;
	sub_822C0890(ctx, base);
	// 822DFA54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822DFA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DFA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DFA60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DFA64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DFA68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DFA70 size=108
    let mut pc: u32 = 0x822DFA70;
    'dispatch: loop {
        match pc {
            0x822DFA70 => {
    //   block [0x822DFA70..0x822DFADC)
	// 822DFA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFA74: 48EC86F9  bl 0x831a816c
	ctx.lr = 0x822DFA78;
	sub_831A8130(ctx, base);
	// 822DFA78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFA7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822DFA80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DFA84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DFA88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFA8C: 41820038  beq 0x822dfac4
	if ctx.cr[0].eq {
	pc = 0x822DFAC4; continue 'dispatch;
	}
	// 822DFA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFA94: 48EC9EF5  bl 0x831a9988
	ctx.lr = 0x822DFA98;
	sub_831A9988(ctx, base);
	// 822DFA98: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DFA9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822DFAA0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 822DFAA4: 48EC8655  bl 0x831a80f8
	ctx.lr = 0x822DFAA8;
	sub_831A80F8(ctx, base);
	// 822DFAA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFAAC: 41820018  beq 0x822dfac4
	if ctx.cr[0].eq {
	pc = 0x822DFAC4; continue 'dispatch;
	}
	// 822DFAB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DFAB4: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 822DFAB8: 4BFFFEE9  bl 0x822df9a0
	ctx.lr = 0x822DFABC;
	sub_822DF9A0(ctx, base);
	// 822DFABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822DFAC0: 48000014  b 0x822dfad4
	pc = 0x822DFAD4; continue 'dispatch;
	// 822DFAC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822DFAC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822DFACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822DFAD0: 48002A81  bl 0x822e2550
	ctx.lr = 0x822DFAD4;
	sub_822E2550(ctx, base);
	// 822DFAD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFAD8: 48EC86E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFAE0 size=164
    let mut pc: u32 = 0x822DFAE0;
    'dispatch: loop {
        match pc {
            0x822DFAE0 => {
    //   block [0x822DFAE0..0x822DFB84)
	// 822DFAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFAE4: 48EC8689  bl 0x831a816c
	ctx.lr = 0x822DFAE8;
	sub_831A8130(ctx, base);
	// 822DFAE8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822DFAEC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFAF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DFAF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822DFAF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822DFAFC: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 822DFB00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822DFB04: 807D00CC  lwz r3, 0xcc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DFB08: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DFB0C: 4BFF09BD  bl 0x822d04c8
	ctx.lr = 0x822DFB10;
	sub_822D04C8(ctx, base);
	// 822DFB10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822DFB14: 807D00CC  lwz r3, 0xcc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DFB18: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822DFB1C: 4BFF06B5  bl 0x822d01d0
	ctx.lr = 0x822DFB20;
	sub_822D01D0(ctx, base);
	// 822DFB20: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DFB88 size=196
    let mut pc: u32 = 0x822DFB88;
    'dispatch: loop {
        match pc {
            0x822DFB88 => {
    //   block [0x822DFB88..0x822DFC4C)
	// 822DFB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DFB90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DFB94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DFB98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFB9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DFBA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822DFBA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822DFBAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DFBB0: 4BFE0D89  bl 0x822c0938
	ctx.lr = 0x822DFBB4;
	sub_822C0938(ctx, base);
	// 822DFBB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822DFBB8: 41820028  beq 0x822dfbe0
	if ctx.cr[0].eq {
	pc = 0x822DFBE0; continue 'dispatch;
	}
	// 822DFBBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DFBC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822DFBC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822DFBC8: 392BA73C  addi r9, r11, -0x58c4
	ctx.r[9].s64 = ctx.r[11].s64 + -22724;
	// 822DFBCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822DFBD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DFBD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DFBD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822DFBDC: 48000008  b 0x822dfbe4
	pc = 0x822DFBE4; continue 'dispatch;
	// 822DFBE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFBE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822DFBE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFBEC: 409A0044  bne cr6, 0x822dfc30
	if !ctx.cr[6].eq {
	pc = 0x822DFC30; continue 'dispatch;
	}
	// 822DFBF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822DFBF4: 419A001C  beq cr6, 0x822dfc10
	if ctx.cr[6].eq {
	pc = 0x822DFC10; continue 'dispatch;
	}
	// 822DFBF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFBFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822DFC00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFC04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DFC0C: 4E800421  bctrl
	ctx.lr = 0x822DFC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DFC10: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DFC14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822DFC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DFC1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822DFC20: 816B3708  lwz r11, 0x3708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14088 as u32) ) } as u64;
	// 822DFC24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822DFC28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822DFC2C: 4BFE03D5  bl 0x822c0000
	ctx.lr = 0x822DFC30;
	sub_822C0000(ctx, base);
	// 822DFC30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822DFC34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFC38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DFC3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DFC40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DFC44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DFC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFC50 size=156
    let mut pc: u32 = 0x822DFC50;
    'dispatch: loop {
        match pc {
            0x822DFC50 => {
    //   block [0x822DFC50..0x822DFCEC)
	// 822DFC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DFC58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DFC5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFC60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DFC64: 4823148D  bl 0x825110f0
	ctx.lr = 0x822DFC68;
	sub_825110F0(ctx, base);
	// 822DFC68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DFC6C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822DFC70: 392BA764  addi r9, r11, -0x589c
	ctx.r[9].s64 = ctx.r[11].s64 + -22684;
	// 822DFC74: 394AA750  addi r10, r10, -0x58b0
	ctx.r[10].s64 = ctx.r[10].s64 + -22704;
	// 822DFC78: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822DFC7C: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 822DFC80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822DFC84: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822DFC88: 38C96880  addi r6, r9, 0x6880
	ctx.r[6].s64 = ctx.r[9].s64 + 26752;
	// 822DFC8C: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 822DFC90: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 822DFC94: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 822DFC98: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 822DFC9C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 822DFCA0: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 822DFCA4: 395F00E0  addi r10, r31, 0xe0
	ctx.r[10].s64 = ctx.r[31].s64 + 224;
	// 822DFCA8: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 822DFCAC: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 822DFCB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFCB4: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 822DFCB8: 13E73407  vcmpneb. (lvlx128) v31, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DFCBC: 13C83407  vcmpneb. (lvlx128) v30, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DFCC0: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822DFCC4: 13803407  vcmpneb. (lvlx128) v28, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822DFCF0 size=8
    let mut pc: u32 = 0x822DFCF0;
    'dispatch: loop {
        match pc {
            0x822DFCF0 => {
    //   block [0x822DFCF0..0x822DFCF8)
	// 822DFCF0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 822DFCF4: 48000064  b 0x822dfd58
	sub_822DFD58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DFCF8 size=96
    let mut pc: u32 = 0x822DFCF8;
    'dispatch: loop {
        match pc {
            0x822DFCF8 => {
    //   block [0x822DFCF8..0x822DFD58)
	// 822DFCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DFD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DFD04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFD08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DFD0C: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 822DFD10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFD14: 419A0008  beq cr6, 0x822dfd1c
	if ctx.cr[6].eq {
	pc = 0x822DFD1C; continue 'dispatch;
	}
	// 822DFD18: 4BFE0B79  bl 0x822c0890
	ctx.lr = 0x822DFD1C;
	sub_822C0890(ctx, base);
	// 822DFD1C: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822DFD20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFD24: 419A0008  beq cr6, 0x822dfd2c
	if ctx.cr[6].eq {
	pc = 0x822DFD2C; continue 'dispatch;
	}
	// 822DFD28: 4BFE0B69  bl 0x822c0890
	ctx.lr = 0x822DFD2C;
	sub_822C0890(ctx, base);
	// 822DFD2C: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822DFD30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFD34: 419A0008  beq cr6, 0x822dfd3c
	if ctx.cr[6].eq {
	pc = 0x822DFD3C; continue 'dispatch;
	}
	// 822DFD38: 4BFE0B59  bl 0x822c0890
	ctx.lr = 0x822DFD3C;
	sub_822C0890(ctx, base);
	// 822DFD3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFD40: 48231459  bl 0x82511198
	ctx.lr = 0x822DFD44;
	sub_82511198(ctx, base);
	// 822DFD44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822DFD48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DFD4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DFD50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DFD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822DFD58 size=76
    let mut pc: u32 = 0x822DFD58;
    'dispatch: loop {
        match pc {
            0x822DFD58 => {
    //   block [0x822DFD58..0x822DFDA4)
	// 822DFD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFD5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DFD60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DFD64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DFD68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DFD70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DFD74: 4BFFFF85  bl 0x822dfcf8
	ctx.lr = 0x822DFD78;
	sub_822DFCF8(ctx, base);
	// 822DFD78: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFD7C: 4182000C  beq 0x822dfd88
	if ctx.cr[0].eq {
	pc = 0x822DFD88; continue 'dispatch;
	}
	// 822DFD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFD84: 48B12655  bl 0x82df23d8
	ctx.lr = 0x822DFD88;
	sub_82DF23D8(ctx, base);
	// 822DFD88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFD8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFD90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DFD94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DFD98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DFD9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DFDA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFDA8 size=140
    let mut pc: u32 = 0x822DFDA8;
    'dispatch: loop {
        match pc {
            0x822DFDA8 => {
    //   block [0x822DFDA8..0x822DFE34)
	// 822DFDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFDAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822DFDB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822DFDB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822DFDB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFDBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822DFDC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822DFDC4: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 822DFDC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DFDCC: C03F0120  lfs f1, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822DFDD0: 80DF0124  lwz r6, 0x124(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 822DFDD4: 80BF00C8  lwz r5, 0xc8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 822DFDD8: 48004151  bl 0x822e3f28
	ctx.lr = 0x822DFDDC;
	sub_822E3F28(ctx, base);
	// 822DFDDC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DFDE0: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 822DFDE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFDE8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 822DFDEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822DFDF0: 4E800421  bctrl
	ctx.lr = 0x822DFDF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822DFDF4: 397E0018  addi r11, r30, 0x18
	ctx.r[11].s64 = ctx.r[30].s64 + 24;
	// 822DFDF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822DFDFC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822DFE00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822DFE04: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822DFE08: 4BFE4659  bl 0x822c4460
	ctx.lr = 0x822DFE0C;
	sub_822C4460(ctx, base);
	// 822DFE0C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822DFE10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFE14: 419A0008  beq cr6, 0x822dfe1c
	if ctx.cr[6].eq {
	pc = 0x822DFE1C; continue 'dispatch;
	}
	// 822DFE18: 4BFE0A79  bl 0x822c0890
	ctx.lr = 0x822DFE1C;
	sub_822C0890(ctx, base);
	// 822DFE1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822DFE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822DFE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822DFE28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822DFE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822DFE30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFE38 size=380
    let mut pc: u32 = 0x822DFE38;
    'dispatch: loop {
        match pc {
            0x822DFE38 => {
    //   block [0x822DFE38..0x822DFFB4)
	// 822DFE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFE3C: 48EC8331  bl 0x831a816c
	ctx.lr = 0x822DFE40;
	sub_831A8130(ctx, base);
	// 822DFE40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFE44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DFE48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DFE4C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822DFE50: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822DFE54: D03E0120  stfs f1, 0x120(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 822DFE58: 90FE0124  stw r7, 0x124(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(292 as u32), ctx.r[7].u32 ) };
	// 822DFE5C: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFE60: 4BFF1F21  bl 0x822d1d80
	ctx.lr = 0x822DFE64;
	sub_822D1D80(ctx, base);
	// 822DFE64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822DFE68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822DFE6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822DFE70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822DFE74: 4BFF2095  bl 0x822d1f08
	ctx.lr = 0x822DFE78;
	sub_822D1F08(ctx, base);
	// 822DFE78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DFE7C: 3BFE00C0  addi r31, r30, 0xc0
	ctx.r[31].s64 = ctx.r[30].s64 + 192;
	// 822DFE80: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DFE84: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822DFE88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFE8C: 917E00C0  stw r11, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 822DFE90: 4BFE45D1  bl 0x822c4460
	ctx.lr = 0x822DFE94;
	sub_822C4460(ctx, base);
	// 822DFE94: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822DFE98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFE9C: 419A0008  beq cr6, 0x822dfea4
	if ctx.cr[6].eq {
	pc = 0x822DFEA4; continue 'dispatch;
	}
	// 822DFEA0: 4BFE09F1  bl 0x822c0890
	ctx.lr = 0x822DFEA4;
	sub_822C0890(ctx, base);
	// 822DFEA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFEAC: 409A0018  bne cr6, 0x822dfec4
	if !ctx.cr[6].eq {
	pc = 0x822DFEC4; continue 'dispatch;
	}
	// 822DFEB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DFEB4: 4BFF1EE5  bl 0x822d1d98
	ctx.lr = 0x822DFEB8;
	sub_822D1D98(ctx, base);
	// 822DFEB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822DFEBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822DFEC0: 48EC82FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
	// 822DFEC4: 48B1E91D  bl 0x82dfe7e0
	ctx.lr = 0x822DFEC8;
	sub_82DFE7E0(ctx, base);
	// 822DFEC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822DFECC: 40820064  bne 0x822dff30
	if !ctx.cr[0].eq {
	pc = 0x822DFF30; continue 'dispatch;
	}
	// 822DFED0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822DFED4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822DFEDC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 822DFEE0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 822DFEE4: 419A0024  beq cr6, 0x822dff08
	if ctx.cr[6].eq {
	pc = 0x822DFF08; continue 'dispatch;
	}
	// 822DFEE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822DFEEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822DFEF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DFEF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822DFEF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822DFEFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822DFF00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822DFF04: 4082FFE8  bne 0x822dfeec
	if !ctx.cr[0].eq {
	pc = 0x822DFEEC; continue 'dispatch;
	}
	// 822DFF08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822DFF0C: 4820AB7D  bl 0x824eaa88
	ctx.lr = 0x822DFF10;
	sub_824EAA88(ctx, base);
	// 822DFF10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822DFF14: 38C00047  li r6, 0x47
	ctx.r[6].s64 = 71;
	// 822DFF18: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFF1C: 38ABA790  addi r5, r11, -0x5870
	ctx.r[5].s64 = ctx.r[11].s64 + -22640;
	// 822DFF20: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822DFF24: 488DA25D  bl 0x82bba180
	ctx.lr = 0x822DFF28;
	sub_82BBA180(ctx, base);
	// 822DFF28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822DFF2C: 48B11D65  bl 0x82df1c90
	ctx.lr = 0x822DFF30;
	sub_82DF1C90(ctx, base);
	// 822DFF30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822DFF34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFF38: 4BFEF469  bl 0x822cf3a0
	ctx.lr = 0x822DFF3C;
	sub_822CF3A0(ctx, base);
	// 822DFF3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822DFF40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822DFF44: 90BE00C8  stw r5, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[5].u32 ) };
	// 822DFF48: 816B16D8  lwz r11, 0x16d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5848 as u32) ) } as u64;
	// 822DFF4C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822DFF50: 409A0018  bne cr6, 0x822dff68
	if !ctx.cr[6].eq {
	pc = 0x822DFF68; continue 'dispatch;
	}
	// 822DFF54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822DFF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822DFF5C: 4BFF1E3D  bl 0x822d1d98
	ctx.lr = 0x822DFF60;
	sub_822D1D98(ctx, base);
	// 822DFF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822DFF64: 4BFFFF58  b 0x822dfebc
	pc = 0x822DFEBC; continue 'dispatch;
	// 822DFF68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822DFF6C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFF70: 4BFEF8C9  bl 0x822cf838
	ctx.lr = 0x822DFF74;
	sub_822CF838(ctx, base);
	// 822DFF74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822DFF78: 3BFE00CC  addi r31, r30, 0xcc
	ctx.r[31].s64 = ctx.r[30].s64 + 204;
	// 822DFF7C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822DFF80: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822DFF84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFF88: 917E00CC  stw r11, 0xcc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 822DFF8C: 4BFE44D5  bl 0x822c4460
	ctx.lr = 0x822DFF90;
	sub_822C4460(ctx, base);
	// 822DFF90: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822DFF94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822DFF98: 419A0008  beq cr6, 0x822dffa0
	if ctx.cr[6].eq {
	pc = 0x822DFFA0; continue 'dispatch;
	}
	// 822DFF9C: 4BFE08F5  bl 0x822c0890
	ctx.lr = 0x822DFFA0;
	sub_822C0890(ctx, base);
	// 822DFFA0: 389E00E0  addi r4, r30, 0xe0
	ctx.r[4].s64 = ctx.r[30].s64 + 224;
	// 822DFFA4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822DFFA8: 4BFF09C1  bl 0x822d0968
	ctx.lr = 0x822DFFAC;
	sub_822D0968(ctx, base);
	// 822DFFAC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 822DFFB0: 4BFFFFA8  b 0x822dff58
	pc = 0x822DFF58; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822DFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822DFFB8 size=656
    let mut pc: u32 = 0x822DFFB8;
    'dispatch: loop {
        match pc {
            0x822DFFB8 => {
    //   block [0x822DFFB8..0x822E0248)
	// 822DFFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822DFFBC: 48EC81A5  bl 0x831a8160
	ctx.lr = 0x822DFFC0;
	sub_831A8130(ctx, base);
	// 822DFFC0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822DFFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822DFFC8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822DFFCC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822DFFD0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822DFFD4: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 822DFFD8: 409A0008  bne cr6, 0x822dffe0
	if !ctx.cr[6].eq {
	pc = 0x822DFFE0; continue 'dispatch;
	}
	// 822DFFDC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822DFFE0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 822DFFE4: 482287BD  bl 0x825087a0
	ctx.lr = 0x822DFFE8;
	sub_825087A0(ctx, base);
	// 822DFFE8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822DFFEC: 809E00CC  lwz r4, 0xcc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 822DFFF0: 4BFF0DD9  bl 0x822d0dc8
	ctx.lr = 0x822DFFF4;
	sub_822D0DC8(ctx, base);
	// 822DFFF4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822DFFF8: 3D408325  lis r10, -0x7cdb
	ctx.r[10].s64 = -2094727168;
	// 822DFFFC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0000: 38CB2D50  addi r6, r11, 0x2d50
	ctx.r[6].s64 = ctx.r[11].s64 + 11600;
	// 822E0004: 38AA2D24  addi r5, r10, 0x2d24
	ctx.r[5].s64 = ctx.r[10].s64 + 11556;
	// 822E0008: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822E000C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E0010: 48EC9F39  bl 0x831a9f48
	ctx.lr = 0x822E0014;
	sub_831A9F48(ctx, base);
	// 822E0014: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822E0018: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E001C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0020: 419A000C  beq cr6, 0x822e002c
	if ctx.cr[6].eq {
	pc = 0x822E002C; continue 'dispatch;
	}
	// 822E0024: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822E0028: 4BFE0869  bl 0x822c0890
	ctx.lr = 0x822E002C;
	sub_822C0890(ctx, base);
	// 822E002C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0030: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E0034: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 822E0038: 3B5E00E0  addi r26, r30, 0xe0
	ctx.r[26].s64 = ctx.r[30].s64 + 224;
	// 822E003C: 83EB66A0  lwz r31, 0x66a0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26272 as u32) ) } as u64;
	// 822E0040: 4822F4D9  bl 0x8250f518
	ctx.lr = 0x822E0044;
	sub_8250F518(ctx, base);
	// 822E0044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0048: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822E004C: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 822E0050: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822E0054: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822E0058: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822E005C: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0060: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 822E0064: 4BFFE5FD  bl 0x822de660
	ctx.lr = 0x822E0068;
	sub_822DE660(ctx, base);
	// 822E0068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E006C: 3BFE00D4  addi r31, r30, 0xd4
	ctx.r[31].s64 = ctx.r[30].s64 + 212;
	// 822E0070: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822E0074: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822E0078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E007C: 917E00D4  stw r11, 0xd4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 822E0080: 4BFE43E1  bl 0x822c4460
	ctx.lr = 0x822E0084;
	sub_822C4460(ctx, base);
	// 822E0084: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E0088: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E008C: 419A0008  beq cr6, 0x822e0094
	if ctx.cr[6].eq {
	pc = 0x822E0094; continue 'dispatch;
	}
	// 822E0090: 4BFE0801  bl 0x822c0890
	ctx.lr = 0x822E0094;
	sub_822C0890(ctx, base);
	// 822E0094: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 822E0098: 48B11BF9  bl 0x82df1c90
	ctx.lr = 0x822E009C;
	sub_82DF1C90(ctx, base);
	// 822E009C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E00A0: 48006CE1  bl 0x822e6d80
	ctx.lr = 0x822E00A4;
	sub_822E6D80(ctx, base);
	// 822E00A4: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 822E00A8: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 822E00AC: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 822E00B0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 822E00B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E00B8: 9B610052  stb r27, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[27].u8 ) };
	// 822E00BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E00C0: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 822E00C4: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E00C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E00CC: 388B0110  addi r4, r11, 0x110
	ctx.r[4].s64 = ctx.r[11].s64 + 272;
	// 822E00D0: 4858B479  bl 0x8286b548
	ctx.lr = 0x822E00D4;
	sub_8286B548(ctx, base);
	// 822E00D4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E00D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E00DC: 419A0154  beq cr6, 0x822e0230
	if ctx.cr[6].eq {
	pc = 0x822E0230; continue 'dispatch;
	}
	// 822E00E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822E00E4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822E00E8: 48005161  bl 0x822e5248
	ctx.lr = 0x822E00EC;
	sub_822E5248(ctx, base);
	// 822E00EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E00F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E00F4: 388BA790  addi r4, r11, -0x5870
	ctx.r[4].s64 = ctx.r[11].s64 + -22640;
	// 822E00F8: 38A00074  li r5, 0x74
	ctx.r[5].s64 = 116;
	// 822E00FC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822E0100: 48B122E9  bl 0x82df23e8
	ctx.lr = 0x822E0104;
	sub_82DF23E8(ctx, base);
	// 822E0104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E0108: 41820018  beq 0x822e0120
	if ctx.cr[0].eq {
	pc = 0x822E0120; continue 'dispatch;
	}
	// 822E010C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822E0110: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0114: 484D62FD  bl 0x827b6410
	ctx.lr = 0x822E0118;
	sub_827B6410(ctx, base);
	// 822E0118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E011C: 48000008  b 0x822e0124
	pc = 0x822E0124; continue 'dispatch;
	// 822E0120: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 822E0124: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822E0128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E012C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0130: 4BFFE861  bl 0x822de990
	ctx.lr = 0x822E0134;
	sub_822DE990(ctx, base);
	// 822E0134: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E0138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E013C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0140: 4BFDFEC1  bl 0x822c0000
	ctx.lr = 0x822E0144;
	sub_822C0000(ctx, base);
	// 822E0144: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E0148: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E014C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0150: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822E0154: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822E0158: 419A0024  beq cr6, 0x822e017c
	if ctx.cr[6].eq {
	pc = 0x822E017C; continue 'dispatch;
	}
	// 822E015C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E0160: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0164: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0168: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E016C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0170: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0174: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0178: 4082FFE8  bne 0x822e0160
	if !ctx.cr[0].eq {
	pc = 0x822E0160; continue 'dispatch;
	}
	// 822E017C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0180: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E0184: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E0188: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 822E018C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0190: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 822E0194: 48230865  bl 0x825109f8
	ctx.lr = 0x822E0198;
	sub_825109F8(ctx, base);
	// 822E0198: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E019C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E01A0: 419A0008  beq cr6, 0x822e01a8
	if ctx.cr[6].eq {
	pc = 0x822E01A8; continue 'dispatch;
	}
	// 822E01A4: 4BFE06ED  bl 0x822c0890
	ctx.lr = 0x822E01A8;
	sub_822C0890(ctx, base);
	// 822E01A8: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E01AC: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 822E01B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E01B4: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 822E01B8: 419A0024  beq cr6, 0x822e01dc
	if ctx.cr[6].eq {
	pc = 0x822E01DC; continue 'dispatch;
	}
	// 822E01BC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 822E01C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E01C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E01C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E01CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E01D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E01D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E01D8: 4082FFE8  bne 0x822e01c0
	if !ctx.cr[0].eq {
	pc = 0x822E01C0; continue 'dispatch;
	}
	// 822E01DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E01E0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822E01E4: 4822F2E5  bl 0x8250f4c8
	ctx.lr = 0x822E01E8;
	sub_8250F4C8(ctx, base);
	// 822E01E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E01EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E01F0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822E01F4: 409A0008  bne cr6, 0x822e01fc
	if !ctx.cr[6].eq {
	pc = 0x822E01FC; continue 'dispatch;
	}
	// 822E01F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822E01FC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822E0200: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E0204: 4822A845  bl 0x8250aa48
	ctx.lr = 0x822E0208;
	sub_8250AA48(ctx, base);
	// 822E0208: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822E020C: 48B11A85  bl 0x82df1c90
	ctx.lr = 0x822E0210;
	sub_82DF1C90(ctx, base);
	// 822E0210: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822E0214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0218: 419A0008  beq cr6, 0x822e0220
	if ctx.cr[6].eq {
	pc = 0x822E0220; continue 'dispatch;
	}
	// 822E021C: 4BFE0675  bl 0x822c0890
	ctx.lr = 0x822E0220;
	sub_822C0890(ctx, base);
	// 822E0220: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E0224: 419A000C  beq cr6, 0x822e0230
	if ctx.cr[6].eq {
	pc = 0x822E0230; continue 'dispatch;
	}
	// 822E0228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E022C: 4BFE0665  bl 0x822c0890
	ctx.lr = 0x822E0230;
	sub_822C0890(ctx, base);
	// 822E0230: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E0234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0238: 419A0008  beq cr6, 0x822e0240
	if ctx.cr[6].eq {
	pc = 0x822E0240; continue 'dispatch;
	}
	// 822E023C: 4BFE0655  bl 0x822c0890
	ctx.lr = 0x822E0240;
	sub_822C0890(ctx, base);
	// 822E0240: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 822E0244: 48EC7F6C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0248 size=124
    let mut pc: u32 = 0x822E0248;
    'dispatch: loop {
        match pc {
            0x822E0248 => {
    //   block [0x822E0248..0x822E02C4)
	// 822E0248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E024C: 48EC7F21  bl 0x831a816c
	ctx.lr = 0x822E0250;
	sub_831A8130(ctx, base);
	// 822E0250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0254: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0258: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E025C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0260: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 822E0264: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 822E0268: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 822E026C: 48B1217D  bl 0x82df23e8
	ctx.lr = 0x822E0270;
	sub_82DF23E8(ctx, base);
	// 822E0270: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822E0274: 4182001C  beq 0x822e0290
	if ctx.cr[0].eq {
	pc = 0x822E0290; continue 'dispatch;
	}
	// 822E0278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E027C: 48B79405  bl 0x82e59680
	ctx.lr = 0x822E0280;
	sub_82E59680(ctx, base);
	// 822E0280: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0284: 396BA734  addi r11, r11, -0x58cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22732;
	// 822E0288: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E028C: 48000008  b 0x822e0294
	pc = 0x822E0294; continue 'dispatch;
	// 822E0290: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822E0294: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822E0298: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822E029C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E02A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E02A4: 4BFFF8E5  bl 0x822dfb88
	ctx.lr = 0x822E02A8;
	sub_822DFB88(ctx, base);
	// 822E02A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E02AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E02B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E02B4: 4BFDFD4D  bl 0x822c0000
	ctx.lr = 0x822E02B8;
	sub_822C0000(ctx, base);
	// 822E02B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E02BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E02C0: 48EC7EFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E02C8 size=196
    let mut pc: u32 = 0x822E02C8;
    'dispatch: loop {
        match pc {
            0x822E02C8 => {
    //   block [0x822E02C8..0x822E038C)
	// 822E02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E02CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E02D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E02D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E02D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E02DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E02E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822E02E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E02E8: 4BFFFF61  bl 0x822e0248
	ctx.lr = 0x822E02EC;
	sub_822E0248(ctx, base);
	// 822E02EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E02F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E02F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E02F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E02FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E0300: 419A0024  beq cr6, 0x822e0324
	if ctx.cr[6].eq {
	pc = 0x822E0324; continue 'dispatch;
	}
	// 822E0304: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E0308: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E030C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0310: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0318: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E031C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0320: 4082FFE8  bne 0x822e0308
	if !ctx.cr[0].eq {
	pc = 0x822E0308; continue 'dispatch;
	}
	// 822E0324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0328: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822E032C: 48D27DFD  bl 0x83008128
	ctx.lr = 0x822E0330;
	sub_83008128(ctx, base);
	// 822E0330: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E0334: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0338: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822E033C: 388AA790  addi r4, r10, -0x5870
	ctx.r[4].s64 = ctx.r[10].s64 + -22640;
	// 822E0340: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 822E0344: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 822E0348: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E034C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822E0350: 48B786F1  bl 0x82e58a40
	ctx.lr = 0x822E0354;
	sub_82E58A40(ctx, base);
	// 822E0354: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E0358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E035C: 419A0008  beq cr6, 0x822e0364
	if ctx.cr[6].eq {
	pc = 0x822E0364; continue 'dispatch;
	}
	// 822E0360: 4BFE0531  bl 0x822c0890
	ctx.lr = 0x822E0364;
	sub_822C0890(ctx, base);
	// 822E0364: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E0368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E036C: 419A0008  beq cr6, 0x822e0374
	if ctx.cr[6].eq {
	pc = 0x822E0374; continue 'dispatch;
	}
	// 822E0370: 4BFE0521  bl 0x822c0890
	ctx.lr = 0x822E0374;
	sub_822C0890(ctx, base);
	// 822E0374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E037C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E0384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0390 size=220
    let mut pc: u32 = 0x822E0390;
    'dispatch: loop {
        match pc {
            0x822E0390 => {
    //   block [0x822E0390..0x822E046C)
	// 822E0390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0394: 48EC7DD5  bl 0x831a8168
	ctx.lr = 0x822E0398;
	sub_831A8130(ctx, base);
	// 822E0398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E039C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822E03A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E03A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E03A8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822E03AC: 41820038  beq 0x822e03e4
	if ctx.cr[0].eq {
	pc = 0x822E03E4; continue 'dispatch;
	}
	// 822E03B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E03B4: 48EC95D5  bl 0x831a9988
	ctx.lr = 0x822E03B8;
	sub_831A9988(ctx, base);
	// 822E03B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E03BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E03C0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 822E03C4: 48EC7D35  bl 0x831a80f8
	ctx.lr = 0x822E03C8;
	sub_831A80F8(ctx, base);
	// 822E03C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E03CC: 41820018  beq 0x822e03e4
	if ctx.cr[0].eq {
	pc = 0x822E03E4; continue 'dispatch;
	}
	// 822E03D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E03D4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822E03D8: 4BFFFEF1  bl 0x822e02c8
	ctx.lr = 0x822E03DC;
	sub_822E02C8(ctx, base);
	// 822E03DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E03E0: 48000084  b 0x822e0464
	pc = 0x822E0464; continue 'dispatch;
	// 822E03E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E03E8: 419A006C  beq cr6, 0x822e0454
	if ctx.cr[6].eq {
	pc = 0x822E0454; continue 'dispatch;
	}
	// 822E03EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E03F0: 48EC9599  bl 0x831a9988
	ctx.lr = 0x822E03F4;
	sub_831A9988(ctx, base);
	// 822E03F4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E03F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E03FC: 386B3804  addi r3, r11, 0x3804
	ctx.r[3].s64 = ctx.r[11].s64 + 14340;
	// 822E0400: 48EC7CF9  bl 0x831a80f8
	ctx.lr = 0x822E0404;
	sub_831A80F8(ctx, base);
	// 822E0404: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0408: 41820014  beq 0x822e041c
	if ctx.cr[0].eq {
	pc = 0x822E041C; continue 'dispatch;
	}
	// 822E040C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0410: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822E0414: 4BFFF995  bl 0x822dfda8
	ctx.lr = 0x822E0418;
	sub_822DFDA8(ctx, base);
	// 822E0418: 4BFFFFC4  b 0x822e03dc
	pc = 0x822E03DC; continue 'dispatch;
	// 822E041C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E0420: 419A0034  beq cr6, 0x822e0454
	if ctx.cr[6].eq {
	pc = 0x822E0454; continue 'dispatch;
	}
	// 822E0424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0428: 48EC9561  bl 0x831a9988
	ctx.lr = 0x822E042C;
	sub_831A9988(ctx, base);
	// 822E042C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E0430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E0434: 386B35EC  addi r3, r11, 0x35ec
	ctx.r[3].s64 = ctx.r[11].s64 + 13804;
	// 822E0438: 48EC7CC1  bl 0x831a80f8
	ctx.lr = 0x822E043C;
	sub_831A80F8(ctx, base);
	// 822E043C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0440: 41820014  beq 0x822e0454
	if ctx.cr[0].eq {
	pc = 0x822E0454; continue 'dispatch;
	}
	// 822E0444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0448: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822E044C: 4BFFF695  bl 0x822dfae0
	ctx.lr = 0x822E0450;
	sub_822DFAE0(ctx, base);
	// 822E0450: 4BFFFF8C  b 0x822e03dc
	pc = 0x822E03DC; continue 'dispatch;
	// 822E0454: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822E0458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E045C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0460: 48231139  bl 0x82511598
	ctx.lr = 0x822E0464;
	sub_82511598(ctx, base);
	// 822E0464: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0468: 48EC7D50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0470 size=196
    let mut pc: u32 = 0x822E0470;
    'dispatch: loop {
        match pc {
            0x822E0470 => {
    //   block [0x822E0470..0x822E0534)
	// 822E0470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E047C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0484: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E048C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822E0490: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E0494: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0498: 4BFE04A1  bl 0x822c0938
	ctx.lr = 0x822E049C;
	sub_822C0938(ctx, base);
	// 822E049C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E04A0: 41820028  beq 0x822e04c8
	if ctx.cr[0].eq {
	pc = 0x822E04C8; continue 'dispatch;
	}
	// 822E04A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E04A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822E04AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E04B0: 392BA7D8  addi r9, r11, -0x5828
	ctx.r[9].s64 = ctx.r[11].s64 + -22568;
	// 822E04B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E04B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E04BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E04C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822E04C4: 48000008  b 0x822e04cc
	pc = 0x822E04CC; continue 'dispatch;
	// 822E04C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E04CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E04D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E04D4: 409A0044  bne cr6, 0x822e0518
	if !ctx.cr[6].eq {
	pc = 0x822E0518; continue 'dispatch;
	}
	// 822E04D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E04DC: 419A001C  beq cr6, 0x822e04f8
	if ctx.cr[6].eq {
	pc = 0x822E04F8; continue 'dispatch;
	}
	// 822E04E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E04E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822E04E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E04EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E04F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E04F4: 4E800421  bctrl
	ctx.lr = 0x822E04F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E04F8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E04FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822E0500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E0504: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822E0508: 816B383C  lwz r11, 0x383c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14396 as u32) ) } as u64;
	// 822E050C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822E0510: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E0514: 4BFDFAED  bl 0x822c0000
	ctx.lr = 0x822E0518;
	sub_822C0000(ctx, base);
	// 822E0518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E051C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0528: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E052C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0538 size=152
    let mut pc: u32 = 0x822E0538;
    'dispatch: loop {
        match pc {
            0x822E0538 => {
    //   block [0x822E0538..0x822E05D0)
	// 822E0538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E053C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E054C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E0554: 397E00C0  addi r11, r30, 0xc0
	ctx.r[11].s64 = ctx.r[30].s64 + 192;
	// 822E0558: 395F0018  addi r10, r31, 0x18
	ctx.r[10].s64 = ctx.r[31].s64 + 24;
	// 822E055C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 822E0560: 813E00C0  lwz r9, 0xc0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 822E0564: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 822E0568: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 822E056C: 4BFE3EF5  bl 0x822c4460
	ctx.lr = 0x822E0570;
	sub_822C4460(ctx, base);
	// 822E0570: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822E0574: 80BE00C8  lwz r5, 0xc8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 822E0578: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 822E057C: 38EB6880  addi r7, r11, 0x6880
	ctx.r[7].s64 = ctx.r[11].s64 + 26752;
	// 822E0580: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 822E0584: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 822E0588: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 822E058C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 822E0590: 90BF0020  stw r5, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 822E0594: 90DF0024  stw r6, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[6].u32 ) };
	// 822E0598: 13E83C07  vcmpneb. (lvlx128) v31, v8, v7
	tmp.u32 = ctx.r[8].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822E059C: 13C93C07  vcmpneb. (lvlx128) v30, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822E05A0: 13AA3C07  vcmpneb. (lvlx128) v29, v10, v7
	tmp.u32 = ctx.r[10].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822E05A4: 13803C07  vcmpneb. (lvlx128) v28, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E05D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E05D0 size=132
    let mut pc: u32 = 0x822E05D0;
    'dispatch: loop {
        match pc {
            0x822E05D0 => {
    //   block [0x822E05D0..0x822E0654)
	// 822E05D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E05D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E05D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E05DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E05E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E05E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E05E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E05EC: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E05F0: 41820010  beq 0x822e0600
	if ctx.cr[0].eq {
	pc = 0x822E0600; continue 'dispatch;
	}
	// 822E05F4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E05F8: 808B66B4  lwz r4, 0x66b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26292 as u32) ) } as u64;
	// 822E05FC: 4800000C  b 0x822e0608
	pc = 0x822E0608; continue 'dispatch;
	// 822E0600: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0604: 808B66B8  lwz r4, 0x66b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26296 as u32) ) } as u64;
	// 822E0608: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E060C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0614: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0618: 48002019  bl 0x822e2630
	ctx.lr = 0x822E061C;
	sub_822E2630(ctx, base);
	// 822E061C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0620: 9BDF0130  stb r30, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u8 ) };
	// 822E0624: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0628: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 822E062C: 394AA7EC  addi r10, r10, -0x5814
	ctx.r[10].s64 = ctx.r[10].s64 + -22548;
	// 822E0630: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0638: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822E063C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0648: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E064C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0658 size=908
    let mut pc: u32 = 0x822E0658;
    'dispatch: loop {
        match pc {
            0x822E0658 => {
    //   block [0x822E0658..0x822E09E4)
	// 822E0658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E065C: 48EC7B05  bl 0x831a8160
	ctx.lr = 0x822E0660;
	sub_831A8130(ctx, base);
	// 822E0660: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0664: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822E0668: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822E066C: 480020D5  bl 0x822e2740
	ctx.lr = 0x822E0670;
	sub_822E2740(ctx, base);
	// 822E0670: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0674: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 822E0678: 3B6BA834  addi r27, r11, -0x57cc
	ctx.r[27].s64 = ctx.r[11].s64 + -22476;
	// 822E067C: 897C0130  lbz r11, 0x130(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(304 as u32) ) } as u64;
	// 822E0680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E0684: 418201C4  beq 0x822e0848
	if ctx.cr[0].eq {
	pc = 0x822E0848; continue 'dispatch;
	}
	// 822E0688: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E068C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822E0690: 388BA828  addi r4, r11, -0x57d8
	ctx.r[4].s64 = ctx.r[11].s64 + -22488;
	// 822E0694: 48B13375  bl 0x82df3a08
	ctx.lr = 0x822E0698;
	sub_82DF3A08(ctx, base);
	// 822E0698: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 822E069C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 822E06A0: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E06A4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822E06A8: 809C00D4  lwz r4, 0xd4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E06AC: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 822E06B0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 822E06B4: C1AB89AC  lfs f13, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E06B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E06BC: C18AD7BC  lfs f12, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822E06C0: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E06C4: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 822E06C8: D18100A4  stfs f12, 0xa4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 822E06CC: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 822E06D0: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 822E06D4: 4858AE75  bl 0x8286b548
	ctx.lr = 0x822E06D8;
	sub_8286B548(ctx, base);
	// 822E06D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822E06DC: 48B12D4D  bl 0x82df3428
	ctx.lr = 0x822E06E0;
	sub_82DF3428(ctx, base);
	// 822E06E0: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E06E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E06E8: 419A0150  beq cr6, 0x822e0838
	if ctx.cr[6].eq {
	pc = 0x822E0838; continue 'dispatch;
	}
	// 822E06EC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822E06F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 822E06F4: 48004D6D  bl 0x822e5460
	ctx.lr = 0x822E06F8;
	sub_822E5460(ctx, base);
	// 822E06F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822E06FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0700: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 822E0704: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822E0708: 48B11CE1  bl 0x82df23e8
	ctx.lr = 0x822E070C;
	sub_82DF23E8(ctx, base);
	// 822E070C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E0710: 41820018  beq 0x822e0728
	if ctx.cr[0].eq {
	pc = 0x822E0728; continue 'dispatch;
	}
	// 822E0714: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 822E0718: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E071C: 484D5CF5  bl 0x827b6410
	ctx.lr = 0x822E0720;
	sub_827B6410(ctx, base);
	// 822E0720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0724: 48000008  b 0x822e072c
	pc = 0x822E072C; continue 'dispatch;
	// 822E0728: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822E072C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822E0730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0734: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0738: 4BFFE259  bl 0x822de990
	ctx.lr = 0x822E073C;
	sub_822DE990(ctx, base);
	// 822E073C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E0740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0744: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0748: 4BFDF8B9  bl 0x822c0000
	ctx.lr = 0x822E074C;
	sub_822C0000(ctx, base);
	// 822E074C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E0750: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E0754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0758: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 822E075C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 822E0760: 419A0024  beq cr6, 0x822e0784
	if ctx.cr[6].eq {
	pc = 0x822E0784; continue 'dispatch;
	}
	// 822E0764: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E0768: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E076C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0770: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0774: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0778: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E077C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0780: 4082FFE8  bne 0x822e0768
	if !ctx.cr[0].eq {
	pc = 0x822E0768; continue 'dispatch;
	}
	// 822E0784: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0788: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E078C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E0790: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822E0794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0798: 808B7078  lwz r4, 0x7078(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28792 as u32) ) } as u64;
	// 822E079C: 4823025D  bl 0x825109f8
	ctx.lr = 0x822E07A0;
	sub_825109F8(ctx, base);
	// 822E07A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822E07A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E07A8: 419A0008  beq cr6, 0x822e07b0
	if ctx.cr[6].eq {
	pc = 0x822E07B0; continue 'dispatch;
	}
	// 822E07AC: 4BFE00E5  bl 0x822c0890
	ctx.lr = 0x822E07B0;
	sub_822C0890(ctx, base);
	// 822E07B0: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E07B4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 822E07B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E07BC: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 822E07C0: 419A0024  beq cr6, 0x822e07e4
	if ctx.cr[6].eq {
	pc = 0x822E07E4; continue 'dispatch;
	}
	// 822E07C4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822E07C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E07CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E07D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E07D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E07D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E07DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E07E0: 4082FFE8  bne 0x822e07c8
	if !ctx.cr[0].eq {
	pc = 0x822E07C8; continue 'dispatch;
	}
	// 822E07E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E07E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822E07EC: 4822ECDD  bl 0x8250f4c8
	ctx.lr = 0x822E07F0;
	sub_8250F4C8(ctx, base);
	// 822E07F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E07F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E07F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822E07FC: 409A0008  bne cr6, 0x822e0804
	if !ctx.cr[6].eq {
	pc = 0x822E0804; continue 'dispatch;
	}
	// 822E0800: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822E0804: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 822E0808: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E080C: 4822A23D  bl 0x8250aa48
	ctx.lr = 0x822E0810;
	sub_8250AA48(ctx, base);
	// 822E0810: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822E0814: 48B1147D  bl 0x82df1c90
	ctx.lr = 0x822E0818;
	sub_82DF1C90(ctx, base);
	// 822E0818: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822E081C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0820: 419A0008  beq cr6, 0x822e0828
	if ctx.cr[6].eq {
	pc = 0x822E0828; continue 'dispatch;
	}
	// 822E0824: 4BFE006D  bl 0x822c0890
	ctx.lr = 0x822E0828;
	sub_822C0890(ctx, base);
	// 822E0828: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E082C: 419A000C  beq cr6, 0x822e0838
	if ctx.cr[6].eq {
	pc = 0x822E0838; continue 'dispatch;
	}
	// 822E0830: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0834: 4BFE005D  bl 0x822c0890
	ctx.lr = 0x822E0838;
	sub_822C0890(ctx, base);
	// 822E0838: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E083C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0840: 419A0008  beq cr6, 0x822e0848
	if ctx.cr[6].eq {
	pc = 0x822E0848; continue 'dispatch;
	}
	// 822E0844: 4BFE004D  bl 0x822c0890
	ctx.lr = 0x822E0848;
	sub_822C0890(ctx, base);
	// 822E0848: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 822E084C: 9B410052  stb r26, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[26].u8 ) };
	// 822E0850: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 822E0854: 9B410053  stb r26, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[26].u8 ) };
	// 822E0858: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 822E085C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E0860: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 822E0864: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822E0868: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E086C: 809C00D4  lwz r4, 0xd4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E0870: 4858ACD9  bl 0x8286b548
	ctx.lr = 0x822E0874;
	sub_8286B548(ctx, base);
	// 822E0874: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822E0878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E087C: 419A0150  beq cr6, 0x822e09cc
	if ctx.cr[6].eq {
	pc = 0x822E09CC; continue 'dispatch;
	}
	// 822E0880: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822E0884: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 822E0888: 480049C1  bl 0x822e5248
	ctx.lr = 0x822E088C;
	sub_822E5248(ctx, base);
	// 822E088C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822E0890: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0894: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 822E0898: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822E089C: 48B11B4D  bl 0x82df23e8
	ctx.lr = 0x822E08A0;
	sub_82DF23E8(ctx, base);
	// 822E08A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E08A4: 41820018  beq 0x822e08bc
	if ctx.cr[0].eq {
	pc = 0x822E08BC; continue 'dispatch;
	}
	// 822E08A8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 822E08AC: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E08B0: 484D5B61  bl 0x827b6410
	ctx.lr = 0x822E08B4;
	sub_827B6410(ctx, base);
	// 822E08B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E08B8: 48000008  b 0x822e08c0
	pc = 0x822E08C0; continue 'dispatch;
	// 822E08BC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822E08C0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822E08C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E08C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E08CC: 4BFFE0C5  bl 0x822de990
	ctx.lr = 0x822E08D0;
	sub_822DE990(ctx, base);
	// 822E08D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E08D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E08D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E08DC: 4BFDF725  bl 0x822c0000
	ctx.lr = 0x822E08E0;
	sub_822C0000(ctx, base);
	// 822E08E0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E08E4: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822E08E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E08EC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 822E08F0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 822E08F4: 419A0024  beq cr6, 0x822e0918
	if ctx.cr[6].eq {
	pc = 0x822E0918; continue 'dispatch;
	}
	// 822E08F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E08FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0900: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0904: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0908: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E090C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0910: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0914: 4082FFE8  bne 0x822e08fc
	if !ctx.cr[0].eq {
	pc = 0x822E08FC; continue 'dispatch;
	}
	// 822E0918: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E091C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E0920: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E0924: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822E0928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E092C: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 822E0930: 482300C9  bl 0x825109f8
	ctx.lr = 0x822E0934;
	sub_825109F8(ctx, base);
	// 822E0934: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 822E0938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E093C: 419A0008  beq cr6, 0x822e0944
	if ctx.cr[6].eq {
	pc = 0x822E0944; continue 'dispatch;
	}
	// 822E0940: 4BFDFF51  bl 0x822c0890
	ctx.lr = 0x822E0944;
	sub_822C0890(ctx, base);
	// 822E0944: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E0948: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 822E094C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E0950: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 822E0954: 419A0024  beq cr6, 0x822e0978
	if ctx.cr[6].eq {
	pc = 0x822E0978; continue 'dispatch;
	}
	// 822E0958: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822E095C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0960: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0964: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E096C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0970: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0974: 4082FFE8  bne 0x822e095c
	if !ctx.cr[0].eq {
	pc = 0x822E095C; continue 'dispatch;
	}
	// 822E0978: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E097C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 822E0980: 4822EB49  bl 0x8250f4c8
	ctx.lr = 0x822E0984;
	sub_8250F4C8(ctx, base);
	// 822E0984: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E098C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822E0990: 409A0008  bne cr6, 0x822e0998
	if !ctx.cr[6].eq {
	pc = 0x822E0998; continue 'dispatch;
	}
	// 822E0994: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822E0998: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 822E099C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E09A0: 4822A0A9  bl 0x8250aa48
	ctx.lr = 0x822E09A4;
	sub_8250AA48(ctx, base);
	// 822E09A4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 822E09A8: 48B112E9  bl 0x82df1c90
	ctx.lr = 0x822E09AC;
	sub_82DF1C90(ctx, base);
	// 822E09AC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 822E09B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E09B4: 419A0008  beq cr6, 0x822e09bc
	if ctx.cr[6].eq {
	pc = 0x822E09BC; continue 'dispatch;
	}
	// 822E09B8: 4BFDFED9  bl 0x822c0890
	ctx.lr = 0x822E09BC;
	sub_822C0890(ctx, base);
	// 822E09BC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822E09C0: 419A000C  beq cr6, 0x822e09cc
	if ctx.cr[6].eq {
	pc = 0x822E09CC; continue 'dispatch;
	}
	// 822E09C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E09C8: 4BFDFEC9  bl 0x822c0890
	ctx.lr = 0x822E09CC;
	sub_822C0890(ctx, base);
	// 822E09CC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E09D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E09D4: 419A0008  beq cr6, 0x822e09dc
	if ctx.cr[6].eq {
	pc = 0x822E09DC; continue 'dispatch;
	}
	// 822E09D8: 4BFDFEB9  bl 0x822c0890
	ctx.lr = 0x822E09DC;
	sub_822C0890(ctx, base);
	// 822E09DC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 822E09E0: 48EC77D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E09E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E09E8 size=128
    let mut pc: u32 = 0x822E09E8;
    'dispatch: loop {
        match pc {
            0x822E09E8 => {
    //   block [0x822E09E8..0x822E0A68)
	// 822E09E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E09EC: 48EC7781  bl 0x831a816c
	ctx.lr = 0x822E09F0;
	sub_831A8130(ctx, base);
	// 822E09F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E09F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E09F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822E09FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E0A00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822E0A04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0A08: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 822E0A0C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 822E0A10: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 822E0A14: 48B119D5  bl 0x82df23e8
	ctx.lr = 0x822E0A18;
	sub_82DF23E8(ctx, base);
	// 822E0A18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E0A1C: 41820018  beq 0x822e0a34
	if ctx.cr[0].eq {
	pc = 0x822E0A34; continue 'dispatch;
	}
	// 822E0A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0A24: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0A28: 48875B41  bl 0x82b56568
	ctx.lr = 0x822E0A2C;
	sub_82B56568(ctx, base);
	// 822E0A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0A30: 48000008  b 0x822e0a38
	pc = 0x822E0A38; continue 'dispatch;
	// 822E0A34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822E0A38: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822E0A3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822E0A40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0A48: 4BFFFA29  bl 0x822e0470
	ctx.lr = 0x822E0A4C;
	sub_822E0470(ctx, base);
	// 822E0A4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E0A50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0A58: 4BFDF5A9  bl 0x822c0000
	ctx.lr = 0x822E0A5C;
	sub_822C0000(ctx, base);
	// 822E0A5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0A60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0A64: 48EC7758  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0A68 size=204
    let mut pc: u32 = 0x822E0A68;
    'dispatch: loop {
        match pc {
            0x822E0A68 => {
    //   block [0x822E0A68..0x822E0B34)
	// 822E0A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0A78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0A7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0A80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E0A84: 38BF00C8  addi r5, r31, 0xc8
	ctx.r[5].s64 = ctx.r[31].s64 + 200;
	// 822E0A88: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 822E0A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822E0A90: 4BFFFF59  bl 0x822e09e8
	ctx.lr = 0x822E0A94;
	sub_822E09E8(ctx, base);
	// 822E0A94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0A98: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822E0A9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822E0AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0AA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E0AA8: 419A0024  beq cr6, 0x822e0acc
	if ctx.cr[6].eq {
	pc = 0x822E0ACC; continue 'dispatch;
	}
	// 822E0AAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E0AB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0AB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0AB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0ABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0AC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0AC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0AC8: 4082FFE8  bne 0x822e0ab0
	if !ctx.cr[0].eq {
	pc = 0x822E0AB0; continue 'dispatch;
	}
	// 822E0ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0AD0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822E0AD4: 48D27655  bl 0x83008128
	ctx.lr = 0x822E0AD8;
	sub_83008128(ctx, base);
	// 822E0AD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E0ADC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0AE0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822E0AE4: 388AA834  addi r4, r10, -0x57cc
	ctx.r[4].s64 = ctx.r[10].s64 + -22476;
	// 822E0AE8: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 822E0AEC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 822E0AF0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0AF4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822E0AF8: 48B77F49  bl 0x82e58a40
	ctx.lr = 0x822E0AFC;
	sub_82E58A40(ctx, base);
	// 822E0AFC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822E0B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0B04: 419A0008  beq cr6, 0x822e0b0c
	if ctx.cr[6].eq {
	pc = 0x822E0B0C; continue 'dispatch;
	}
	// 822E0B08: 4BFDFD89  bl 0x822c0890
	ctx.lr = 0x822E0B0C;
	sub_822C0890(ctx, base);
	// 822E0B0C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E0B10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0B14: 419A0008  beq cr6, 0x822e0b1c
	if ctx.cr[6].eq {
	pc = 0x822E0B1C; continue 'dispatch;
	}
	// 822E0B18: 4BFDFD79  bl 0x822c0890
	ctx.lr = 0x822E0B1C;
	sub_822C0890(ctx, base);
	// 822E0B1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0B28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E0B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E0B38 size=164
    let mut pc: u32 = 0x822E0B38;
    'dispatch: loop {
        match pc {
            0x822E0B38 => {
    //   block [0x822E0B38..0x822E0BDC)
	// 822E0B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0B3C: 48EC762D  bl 0x831a8168
	ctx.lr = 0x822E0B40;
	sub_831A8130(ctx, base);
	// 822E0B40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0B44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822E0B48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0B4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E0B50: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822E0B54: 41820038  beq 0x822e0b8c
	if ctx.cr[0].eq {
	pc = 0x822E0B8C; continue 'dispatch;
	}
	// 822E0B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0B5C: 48EC8E2D  bl 0x831a9988
	ctx.lr = 0x822E0B60;
	sub_831A9988(ctx, base);
	// 822E0B60: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E0B64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E0B68: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 822E0B6C: 48EC758D  bl 0x831a80f8
	ctx.lr = 0x822E0B70;
	sub_831A80F8(ctx, base);
	// 822E0B70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0B74: 41820018  beq 0x822e0b8c
	if ctx.cr[0].eq {
	pc = 0x822E0B8C; continue 'dispatch;
	}
	// 822E0B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0B7C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822E0B80: 4BFFFEE9  bl 0x822e0a68
	ctx.lr = 0x822E0B84;
	sub_822E0A68(ctx, base);
	// 822E0B84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822E0B88: 4800004C  b 0x822e0bd4
	pc = 0x822E0BD4; continue 'dispatch;
	// 822E0B8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822E0B90: 419A0034  beq cr6, 0x822e0bc4
	if ctx.cr[6].eq {
	pc = 0x822E0BC4; continue 'dispatch;
	}
	// 822E0B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0B98: 48EC8DF1  bl 0x831a9988
	ctx.lr = 0x822E0B9C;
	sub_831A9988(ctx, base);
	// 822E0B9C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E0BA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E0BA4: 386B361C  addi r3, r11, 0x361c
	ctx.r[3].s64 = ctx.r[11].s64 + 13852;
	// 822E0BA8: 48EC7551  bl 0x831a80f8
	ctx.lr = 0x822E0BAC;
	sub_831A80F8(ctx, base);
	// 822E0BAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822E0BB0: 41820014  beq 0x822e0bc4
	if ctx.cr[0].eq {
	pc = 0x822E0BC4; continue 'dispatch;
	}
	// 822E0BB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0BB8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 822E0BBC: 4BFFF97D  bl 0x822e0538
	ctx.lr = 0x822E0BC0;
	sub_822E0538(ctx, base);
	// 822E0BC0: 4BFFFFC4  b 0x822e0b84
	pc = 0x822E0B84; continue 'dispatch;
	// 822E0BC4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822E0BC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0BCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E0BD0: 48001981  bl 0x822e2550
	ctx.lr = 0x822E0BD4;
	sub_822E2550(ctx, base);
	// 822E0BD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822E0BD8: 48EC75E0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0BE0 size=204
    let mut pc: u32 = 0x822E0BE0;
    'dispatch: loop {
        match pc {
            0x822E0BE0 => {
    //   block [0x822E0BE0..0x822E0CAC)
	// 822E0BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0BE4: 48EC7581  bl 0x831a8164
	ctx.lr = 0x822E0BE8;
	sub_831A8130(ctx, base);
	// 822E0BE8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0BF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822E0BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E0BF8: 4822E8D1  bl 0x8250f4c8
	ctx.lr = 0x822E0BFC;
	sub_8250F4C8(ctx, base);
	// 822E0BFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0C04: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 822E0C08: 409A0008  bne cr6, 0x822e0c10
	if !ctx.cr[6].eq {
	pc = 0x822E0C10; continue 'dispatch;
	}
	// 822E0C0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E0C10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E0C14: 48227D9D  bl 0x825089b0
	ctx.lr = 0x822E0C18;
	sub_825089B0(ctx, base);
	// 822E0C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822E0C1C: 48B11075  bl 0x82df1c90
	ctx.lr = 0x822E0C20;
	sub_82DF1C90(ctx, base);
	// 822E0C20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E0C24: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 822E0C28: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E0C2C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 822E0C30: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822E0C34: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0C38: 4BFEF4E9  bl 0x822d0120
	ctx.lr = 0x822E0C3C;
	sub_822D0120(ctx, base);
	// 822E0C3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822E0C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0C44: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 822E0C48: 409A0008  bne cr6, 0x822e0c50
	if !ctx.cr[6].eq {
	pc = 0x822E0C50; continue 'dispatch;
	}
	// 822E0C4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822E0C50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0C54: 83BE0130  lwz r29, 0x130(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 822E0C58: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 822E0C5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E0C60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E0C64: 3BCBA874  addi r30, r11, -0x578c
	ctx.r[30].s64 = ctx.r[11].s64 + -22412;
	// 822E0C68: 3B8A9FC0  addi r28, r10, -0x6040
	ctx.r[28].s64 = ctx.r[10].s64 + -24640;
	// 822E0C6C: 3B610070  addi r27, r1, 0x70
	ctx.r[27].s64 = ctx.r[1].s64 + 112;
	// 822E0C70: 4822E8A9  bl 0x8250f518
	ctx.lr = 0x822E0C74;
	sub_8250F518(ctx, base);
	// 822E0C74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822E0C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0C7C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822E0C80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0C84: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 822E0C88: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 822E0C8C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 822E0C90: 4BFE4251  bl 0x822c4ee0
	ctx.lr = 0x822E0C94;
	sub_822C4EE0(ctx, base);
	// 822E0C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E0C98: 48B10FF9  bl 0x82df1c90
	ctx.lr = 0x822E0C9C;
	sub_82DF1C90(ctx, base);
	// 822E0C9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E0CA0: 48B10FF1  bl 0x82df1c90
	ctx.lr = 0x822E0CA4;
	sub_82DF1C90(ctx, base);
	// 822E0CA4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822E0CA8: 48EC750C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0CB0 size=108
    let mut pc: u32 = 0x822E0CB0;
    'dispatch: loop {
        match pc {
            0x822E0CB0 => {
    //   block [0x822E0CB0..0x822E0D1C)
	// 822E0CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0CB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0CBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0CC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0CC4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0CC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822E0CCC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822E0CD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E0CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0CD8: 808B66C0  lwz r4, 0x66c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26304 as u32) ) } as u64;
	// 822E0CDC: C02A08A8  lfs f1, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0CE0: 48001951  bl 0x822e2630
	ctx.lr = 0x822E0CE4;
	sub_822E2630(ctx, base);
	// 822E0CE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0CE8: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 822E0CEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0CF0: 396BA8AC  addi r11, r11, -0x5754
	ctx.r[11].s64 = ctx.r[11].s64 + -22356;
	// 822E0CF4: 394AA898  addi r10, r10, -0x5768
	ctx.r[10].s64 = ctx.r[10].s64 + -22376;
	// 822E0CF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E0CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0D00: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822E0D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E0D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0D20 size=488
    let mut pc: u32 = 0x822E0D20;
    'dispatch: loop {
        match pc {
            0x822E0D20 => {
    //   block [0x822E0D20..0x822E0F08)
	// 822E0D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0D24: 48EC7449  bl 0x831a816c
	ctx.lr = 0x822E0D28;
	sub_831A8130(ctx, base);
	// 822E0D28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0D2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E0D30: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822E0D34: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822E0D38: 48001A09  bl 0x822e2740
	ctx.lr = 0x822E0D3C;
	sub_822E2740(ctx, base);
	// 822E0D3C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 822E0D40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822E0D44: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 822E0D48: 48B12CC1  bl 0x82df3a08
	ctx.lr = 0x822E0D4C;
	sub_82DF3A08(ctx, base);
	// 822E0D4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822E0D50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822E0D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0D58: 48227A29  bl 0x82508780
	ctx.lr = 0x822E0D5C;
	sub_82508780(ctx, base);
	// 822E0D5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822E0D60: 48B126C9  bl 0x82df3428
	ctx.lr = 0x822E0D64;
	sub_82DF3428(ctx, base);
	// 822E0D64: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 822E0D68: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 822E0D6C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0D70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822E0D74: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 822E0D78: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 822E0D7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E0D80: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 822E0D84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E0D88: 99210053  stb r9, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[9].u8 ) };
	// 822E0D8C: 809E00D4  lwz r4, 0xd4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 822E0D90: 4858A7B9  bl 0x8286b548
	ctx.lr = 0x822E0D94;
	sub_8286B548(ctx, base);
	// 822E0D94: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E0D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0D9C: 419A0154  beq cr6, 0x822e0ef0
	if ctx.cr[6].eq {
	pc = 0x822E0EF0; continue 'dispatch;
	}
	// 822E0DA0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 822E0DA4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822E0DA8: 480044A1  bl 0x822e5248
	ctx.lr = 0x822E0DAC;
	sub_822E5248(ctx, base);
	// 822E0DAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E0DB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822E0DB4: 388BA8D4  addi r4, r11, -0x572c
	ctx.r[4].s64 = ctx.r[11].s64 + -22316;
	// 822E0DB8: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 822E0DBC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 822E0DC0: 48B11629  bl 0x82df23e8
	ctx.lr = 0x822E0DC4;
	sub_82DF23E8(ctx, base);
	// 822E0DC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E0DC8: 41820018  beq 0x822e0de0
	if ctx.cr[0].eq {
	pc = 0x822E0DE0; continue 'dispatch;
	}
	// 822E0DCC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822E0DD0: C0210054  lfs f1, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0DD4: 484D563D  bl 0x827b6410
	ctx.lr = 0x822E0DD8;
	sub_827B6410(ctx, base);
	// 822E0DD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0DDC: 48000008  b 0x822e0de4
	pc = 0x822E0DE4; continue 'dispatch;
	// 822E0DE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822E0DE4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822E0DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0DEC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0DF0: 4BFFDBA1  bl 0x822de990
	ctx.lr = 0x822E0DF4;
	sub_822DE990(ctx, base);
	// 822E0DF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822E0DF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822E0DFC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822E0E00: 4BFDF201  bl 0x822c0000
	ctx.lr = 0x822E0E04;
	sub_822C0000(ctx, base);
	// 822E0E04: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E0E08: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822E0E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0E10: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822E0E14: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822E0E18: 419A0024  beq cr6, 0x822e0e3c
	if ctx.cr[6].eq {
	pc = 0x822E0E3C; continue 'dispatch;
	}
	// 822E0E1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822E0E20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0E24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0E28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0E2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0E30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0E34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0E38: 4082FFE8  bne 0x822e0e20
	if !ctx.cr[0].eq {
	pc = 0x822E0E20; continue 'dispatch;
	}
	// 822E0E3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822E0E40: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822E0E44: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 822E0E48: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 822E0E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E0E50: 808B7084  lwz r4, 0x7084(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28804 as u32) ) } as u64;
	// 822E0E54: 4822FBA5  bl 0x825109f8
	ctx.lr = 0x822E0E58;
	sub_825109F8(ctx, base);
	// 822E0E58: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822E0E5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0E60: 419A0008  beq cr6, 0x822e0e68
	if ctx.cr[6].eq {
	pc = 0x822E0E68; continue 'dispatch;
	}
	// 822E0E64: 4BFDFA2D  bl 0x822c0890
	ctx.lr = 0x822E0E68;
	sub_822C0890(ctx, base);
	// 822E0E68: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822E0E6C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 822E0E70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E0E74: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 822E0E78: 419A0024  beq cr6, 0x822e0e9c
	if ctx.cr[6].eq {
	pc = 0x822E0E9C; continue 'dispatch;
	}
	// 822E0E7C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 822E0E80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822E0E84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0E88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822E0E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822E0E90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822E0E94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822E0E98: 4082FFE8  bne 0x822e0e80
	if !ctx.cr[0].eq {
	pc = 0x822E0E80; continue 'dispatch;
	}
	// 822E0E9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E0EA0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822E0EA4: 4822E625  bl 0x8250f4c8
	ctx.lr = 0x822E0EA8;
	sub_8250F4C8(ctx, base);
	// 822E0EA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E0EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E0EB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 822E0EB4: 409A0008  bne cr6, 0x822e0ebc
	if !ctx.cr[6].eq {
	pc = 0x822E0EBC; continue 'dispatch;
	}
	// 822E0EB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822E0EBC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 822E0EC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822E0EC4: 48229B85  bl 0x8250aa48
	ctx.lr = 0x822E0EC8;
	sub_8250AA48(ctx, base);
	// 822E0EC8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822E0ECC: 48B10DC5  bl 0x82df1c90
	ctx.lr = 0x822E0ED0;
	sub_82DF1C90(ctx, base);
	// 822E0ED0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822E0ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0ED8: 419A0008  beq cr6, 0x822e0ee0
	if ctx.cr[6].eq {
	pc = 0x822E0EE0; continue 'dispatch;
	}
	// 822E0EDC: 4BFDF9B5  bl 0x822c0890
	ctx.lr = 0x822E0EE0;
	sub_822C0890(ctx, base);
	// 822E0EE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822E0EE4: 419A000C  beq cr6, 0x822e0ef0
	if ctx.cr[6].eq {
	pc = 0x822E0EF0; continue 'dispatch;
	}
	// 822E0EE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822E0EEC: 4BFDF9A5  bl 0x822c0890
	ctx.lr = 0x822E0EF0;
	sub_822C0890(ctx, base);
	// 822E0EF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822E0EF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E0EF8: 419A0008  beq cr6, 0x822e0f00
	if ctx.cr[6].eq {
	pc = 0x822E0F00; continue 'dispatch;
	}
	// 822E0EFC: 4BFDF995  bl 0x822c0890
	ctx.lr = 0x822E0F00;
	sub_822C0890(ctx, base);
	// 822E0F00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822E0F04: 48EC72B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0F08 size=16
    let mut pc: u32 = 0x822E0F08;
    'dispatch: loop {
        match pc {
            0x822E0F08 => {
    //   block [0x822E0F08..0x822E0F18)
	// 822E0F08: 80C30164  lwz r6, 0x164(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 822E0F0C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 822E0F10: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822E0F14: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E0F18 size=28
    let mut pc: u32 = 0x822E0F18;
    'dispatch: loop {
        match pc {
            0x822E0F18 => {
    //   block [0x822E0F18..0x822E0F34)
	// 822E0F18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E0F1C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0F20: 38A001B4  li r5, 0x1b4
	ctx.r[5].s64 = 436;
	// 822E0F24: 388AA914  addi r4, r10, -0x56ec
	ctx.r[4].s64 = ctx.r[10].s64 + -22252;
	// 822E0F28: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 822E0F2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0F30: 48B77D70  b 0x82e58ca0
	sub_82E58CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0F34 size=4
    let mut pc: u32 = 0x822E0F34;
    'dispatch: loop {
        match pc {
            0x822E0F34 => {
    //   block [0x822E0F34..0x822E0F38)
	// 822E0F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0F38 size=16
    let mut pc: u32 = 0x822E0F38;
    'dispatch: loop {
        match pc {
            0x822E0F38 => {
    //   block [0x822E0F38..0x822E0F48)
	// 822E0F38: 80C30164  lwz r6, 0x164(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 822E0F3C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 822E0F40: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 822E0F44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822E0F48 size=28
    let mut pc: u32 = 0x822E0F48;
    'dispatch: loop {
        match pc {
            0x822E0F48 => {
    //   block [0x822E0F48..0x822E0F64)
	// 822E0F48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E0F4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E0F50: 38A001BC  li r5, 0x1bc
	ctx.r[5].s64 = 444;
	// 822E0F54: 388AA914  addi r4, r10, -0x56ec
	ctx.r[4].s64 = ctx.r[10].s64 + -22252;
	// 822E0F58: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 822E0F5C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E0F60: 48B77D40  b 0x82e58ca0
	sub_82E58CA0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E0F64 size=4
    let mut pc: u32 = 0x822E0F64;
    'dispatch: loop {
        match pc {
            0x822E0F64 => {
    //   block [0x822E0F64..0x822E0F68)
	// 822E0F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0F68 size=72
    let mut pc: u32 = 0x822E0F68;
    'dispatch: loop {
        match pc {
            0x822E0F68 => {
    //   block [0x822E0F68..0x822E0FB0)
	// 822E0F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0F78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0F80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E0F84: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E0F88: 4BFEEF89  bl 0x822cff10
	ctx.lr = 0x822E0F8C;
	sub_822CFF10(ctx, base);
	// 822E0F8C: C01F0160  lfs f0, 0x160(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0F90: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E0F94: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 822E0F98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E0F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E0FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E0FA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E0FA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E0FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E0FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E0FB0 size=104
    let mut pc: u32 = 0x822E0FB0;
    'dispatch: loop {
        match pc {
            0x822E0FB0 => {
    //   block [0x822E0FB0..0x822E1018)
	// 822E0FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E0FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E0FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E0FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E0FC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E0FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E0FC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822E0FCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E0FD0: C1BF0160  lfs f13, 0x160(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822E0FD4: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E0FD8: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E0FDC: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 822E0FE0: 4BFEF1F1  bl 0x822d01d0
	ctx.lr = 0x822E0FE4;
	sub_822D01D0(ctx, base);
	// 822E0FE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822E0FE8: 389F00E0  addi r4, r31, 0xe0
	ctx.r[4].s64 = ctx.r[31].s64 + 224;
	// 822E0FEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E0FF0: 48B9ACD9  bl 0x82e7bcc8
	ctx.lr = 0x822E0FF4;
	sub_82E7BCC8(ctx, base);
	// 822E0FF4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 822E0FF8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E1018 size=196
    let mut pc: u32 = 0x822E1018;
    'dispatch: loop {
        match pc {
            0x822E1018 => {
    //   block [0x822E1018..0x822E10DC)
	// 822E1018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E101C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E1020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E1024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E1028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E102C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E1030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E1034: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822E1038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E103C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E1040: 4BFDF8F9  bl 0x822c0938
	ctx.lr = 0x822E1044;
	sub_822C0938(ctx, base);
	// 822E1044: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E1048: 41820028  beq 0x822e1070
	if ctx.cr[0].eq {
	pc = 0x822E1070; continue 'dispatch;
	}
	// 822E104C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E1050: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822E1054: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E1058: 392BA958  addi r9, r11, -0x56a8
	ctx.r[9].s64 = ctx.r[11].s64 + -22184;
	// 822E105C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E1060: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E1064: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E1068: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822E106C: 48000008  b 0x822e1074
	pc = 0x822E1074; continue 'dispatch;
	// 822E1070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E1074: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E107C: 409A0044  bne cr6, 0x822e10c0
	if !ctx.cr[6].eq {
	pc = 0x822E10C0; continue 'dispatch;
	}
	// 822E1080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E1084: 419A001C  beq cr6, 0x822e10a0
	if ctx.cr[6].eq {
	pc = 0x822E10A0; continue 'dispatch;
	}
	// 822E1088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E108C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822E1090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1094: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E109C: 4E800421  bctrl
	ctx.lr = 0x822E10A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E10A0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E10A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822E10A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E10AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822E10B0: 816B38D4  lwz r11, 0x38d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14548 as u32) ) } as u64;
	// 822E10B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822E10B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E10BC: 4BFDEF45  bl 0x822c0000
	ctx.lr = 0x822E10C0;
	sub_822C0000(ctx, base);
	// 822E10C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E10C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E10C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E10CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E10D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E10D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E10D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E10E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E10E0 size=196
    let mut pc: u32 = 0x822E10E0;
    'dispatch: loop {
        match pc {
            0x822E10E0 => {
    //   block [0x822E10E0..0x822E11A4)
	// 822E10E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E10E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E10E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822E10EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E10F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E10F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E10F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E10FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822E1100: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822E1104: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E1108: 4BFDF831  bl 0x822c0938
	ctx.lr = 0x822E110C;
	sub_822C0938(ctx, base);
	// 822E110C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822E1110: 41820028  beq 0x822e1138
	if ctx.cr[0].eq {
	pc = 0x822E1138; continue 'dispatch;
	}
	// 822E1114: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E1118: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822E111C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822E1120: 392BA96C  addi r9, r11, -0x5694
	ctx.r[9].s64 = ctx.r[11].s64 + -22164;
	// 822E1124: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822E1128: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822E112C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822E1130: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822E1134: 48000008  b 0x822e113c
	pc = 0x822E113C; continue 'dispatch;
	// 822E1138: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822E113C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E1140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1144: 409A0044  bne cr6, 0x822e1188
	if !ctx.cr[6].eq {
	pc = 0x822E1188; continue 'dispatch;
	}
	// 822E1148: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822E114C: 419A001C  beq cr6, 0x822e1168
	if ctx.cr[6].eq {
	pc = 0x822E1168; continue 'dispatch;
	}
	// 822E1150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1154: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822E1158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E115C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822E1164: 4E800421  bctrl
	ctx.lr = 0x822E1168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822E1168: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822E116C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822E1170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822E1174: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822E1178: 816B38D4  lwz r11, 0x38d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14548 as u32) ) } as u64;
	// 822E117C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822E1180: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822E1184: 4BFDEE7D  bl 0x822c0000
	ctx.lr = 0x822E1188;
	sub_822C0000(ctx, base);
	// 822E1188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822E118C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822E1190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E1194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E1198: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822E119C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E11A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E11A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822E11A8 size=180
    let mut pc: u32 = 0x822E11A8;
    'dispatch: loop {
        match pc {
            0x822E11A8 => {
    //   block [0x822E11A8..0x822E125C)
	// 822E11A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E11AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822E11B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822E11B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E11B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822E11BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822E11C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E11C4: 396BA9AC  addi r11, r11, -0x5654
	ctx.r[11].s64 = ctx.r[11].s64 + -22100;
	// 822E11C8: 394AA998  addi r10, r10, -0x5668
	ctx.r[10].s64 = ctx.r[10].s64 + -22120;
	// 822E11CC: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 822E11D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822E11D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E11D8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 822E11DC: 419A0014  beq cr6, 0x822e11f0
	if ctx.cr[6].eq {
	pc = 0x822E11F0; continue 'dispatch;
	}
	// 822E11E0: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 822E11E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822E11E8: 419A0008  beq cr6, 0x822e11f0
	if ctx.cr[6].eq {
	pc = 0x822E11F0; continue 'dispatch;
	}
	// 822E11EC: 48B31355  bl 0x82e12540
	ctx.lr = 0x822E11F0;
	sub_82E12540(ctx, base);
	// 822E11F0: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 822E11F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E11F8: 419A0008  beq cr6, 0x822e1200
	if ctx.cr[6].eq {
	pc = 0x822E1200; continue 'dispatch;
	}
	// 822E11FC: 4BFDF695  bl 0x822c0890
	ctx.lr = 0x822E1200;
	sub_822C0890(ctx, base);
	// 822E1200: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 822E1204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E1208: 419A0008  beq cr6, 0x822e1210
	if ctx.cr[6].eq {
	pc = 0x822E1210; continue 'dispatch;
	}
	// 822E120C: 4BFDF685  bl 0x822c0890
	ctx.lr = 0x822E1210;
	sub_822C0890(ctx, base);
	// 822E1210: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 822E1214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E1218: 419A0008  beq cr6, 0x822e1220
	if ctx.cr[6].eq {
	pc = 0x822E1220; continue 'dispatch;
	}
	// 822E121C: 4BFDF675  bl 0x822c0890
	ctx.lr = 0x822E1220;
	sub_822C0890(ctx, base);
	// 822E1220: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822E1224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E1228: 419A0008  beq cr6, 0x822e1230
	if ctx.cr[6].eq {
	pc = 0x822E1230; continue 'dispatch;
	}
	// 822E122C: 4BFDF665  bl 0x822c0890
	ctx.lr = 0x822E1230;
	sub_822C0890(ctx, base);
	// 822E1230: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822E1234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822E1238: 419A0008  beq cr6, 0x822e1240
	if ctx.cr[6].eq {
	pc = 0x822E1240; continue 'dispatch;
	}
	// 822E123C: 4BFDF655  bl 0x822c0890
	ctx.lr = 0x822E1240;
	sub_822C0890(ctx, base);
	// 822E1240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822E1244: 4822FF55  bl 0x82511198
	ctx.lr = 0x822E1248;
	sub_82511198(ctx, base);
	// 822E1248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822E124C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822E1250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822E1254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822E1258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822E1260 size=8
    let mut pc: u32 = 0x822E1260;
    'dispatch: loop {
        match pc {
            0x822E1260 => {
    //   block [0x822E1260..0x822E1268)
	// 822E1260: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 822E1264: 480008AC  b 0x822e1b10
	sub_822E1B10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822E1268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822E1268 size=576
    let mut pc: u32 = 0x822E1268;
    'dispatch: loop {
        match pc {
            0x822E1268 => {
    //   block [0x822E1268..0x822E14A8)
	// 822E1268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822E126C: 48EC6EF9  bl 0x831a8164
	ctx.lr = 0x822E1270;
	sub_831A8130(ctx, base);
	// 822E1270: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 822E1274: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822E1278: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822E127C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822E1280: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E1284: 4BFEEC8D  bl 0x822cff10
	ctx.lr = 0x822E1288;
	sub_822CFF10(ctx, base);
	// 822E1288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822E128C: C01E0160  lfs f0, 0x160(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822E1290: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 822E1294: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822E1298: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E129C: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822E12A0: 4BFEEF31  bl 0x822d01d0
	ctx.lr = 0x822E12A4;
	sub_822D01D0(ctx, base);
	// 822E12A4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 822E12A8: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 822E12AC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822E12B0: 4BFEEF21  bl 0x822d01d0
	ctx.lr = 0x822E12B4;
	sub_822D01D0(ctx, base);
	// 822E12B4: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	// 822E12B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E12BC: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 822E12C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822E12C4: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 822E12C8: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 822E12CC: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 822E12D0: 4822E1F9  bl 0x8250f4c8
	ctx.lr = 0x822E12D4;
	sub_8250F4C8(ctx, base);
	// 822E12D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E12D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822E12DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E12E0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 822E12E4: 409A0008  bne cr6, 0x822e12ec
	if !ctx.cr[6].eq {
	pc = 0x822E12EC; continue 'dispatch;
	}
	// 822E12E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E12EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E12F0: 482276C1  bl 0x825089b0
	ctx.lr = 0x822E12F4;
	sub_825089B0(ctx, base);
	// 822E12F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E12F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E12FC: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 822E1300: 409A0008  bne cr6, 0x822e1308
	if !ctx.cr[6].eq {
	pc = 0x822E1308; continue 'dispatch;
	}
	// 822E1304: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822E1308: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 822E130C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822E1310: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 822E1314: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822E1318: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822E131C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 822E1320: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822E1324: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E1328: 4BFE6741  bl 0x822c7a68
	ctx.lr = 0x822E132C;
	sub_822C7A68(ctx, base);
	// 822E132C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822E1330: 48B10961  bl 0x82df1c90
	ctx.lr = 0x822E1334;
	sub_82DF1C90(ctx, base);
	// 822E1334: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822E1338: 48B10959  bl 0x82df1c90
	ctx.lr = 0x822E133C;
	sub_82DF1C90(ctx, base);
	// 822E133C: 9BE10054  stb r31, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u8 ) };
	// 822E1340: 9BE10055  stb r31, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[31].u8 ) };
	// 822E1344: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E1348: 9B810056  stb r28, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[28].u8 ) };
	// 822E134C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822E1350: 9B810057  stb r28, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[28].u8 ) };
	// 822E1354: 4822E175  bl 0x8250f4c8
	ctx.lr = 0x822E1358;
	sub_8250F4C8(ctx, base);
	// 822E1358: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E135C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E1360: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 822E1364: 409A0008  bne cr6, 0x822e136c
	if !ctx.cr[6].eq {
	pc = 0x822E136C; continue 'dispatch;
	}
	// 822E1368: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822E136C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822E1370: 48227641  bl 0x825089b0
	ctx.lr = 0x822E1374;
	sub_825089B0(ctx, base);
	// 822E1374: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822E1378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822E137C: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 822E1380: 409A0008  bne cr6, 0x822e1388
	if !ctx.cr[6].eq {
	pc = 0x822E1388; continue 'dispatch;
	}
	// 822E1384: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822E1388: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822E138C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822E1390: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 822E1394: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 822E1398: 4BFE66D1  bl 0x822c7a68
	ctx.lr = 0x822E139C;
	sub_822C7A68(ctx, base);
	// 822E139C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822E13A0: 48B108F1  bl 0x82df1c90
	ctx.lr = 0x822E13A4;
	sub_82DF1C90(ctx, base);
	// 822E13A4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822E13A8: 48B108E9  bl 0x82df1c90
	ctx.lr = 0x822E13AC;
	sub_82DF1C90(ctx, base);
	// 822E13AC: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 822E13B0: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 822E13B4: 9BE10058  stb r31, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u8 ) };
	// 822E13B8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822E13BC: 9BE10059  stb r31, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[31].u8 ) };
	// 822E13C0: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 822E13C4: 9B81005A  stb r28, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[28].u8 ) };
	// 822E13C8: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 822E13CC: 9B81005B  stb r28, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[28].u8 ) };
	// 822E13D0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822E13D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822E13D8: 13A050C7  vcmpequd (lvx128) v29, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822E13DC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


