pub fn sub_822F3C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F3C88 size=28
    let mut pc: u32 = 0x822F3C88;
    'dispatch: loop {
        match pc {
            0x822F3C88 => {
    //   block [0x822F3C88..0x822F3CA4)
	// 822F3C88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3C8C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3C90: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3C94: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 822F3C98: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3CA8 size=32
    let mut pc: u32 = 0x822F3CA8;
    'dispatch: loop {
        match pc {
            0x822F3CA8 => {
    //   block [0x822F3CA8..0x822F3CC8)
	// 822F3CA8: 816400A8  lwz r11, 0xa8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3CAC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3CB0: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3CB4: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F3CB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3CBC: 4098000C  bge cr6, 0x822f3cc8
	if !ctx.cr[6].lt {
		sub_822F3CC8(ctx, base);
		return;
	}
	// 822F3CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F3CC4: 48000010  b 0x822f3cd4
	sub_822F3CC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F3CC8 size=28
    let mut pc: u32 = 0x822F3CC8;
    'dispatch: loop {
        match pc {
            0x822F3CC8 => {
    //   block [0x822F3CC8..0x822F3CE4)
	// 822F3CC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3CCC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3CD0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3CD4: 394001A0  li r10, 0x1a0
	ctx.r[10].s64 = 416;
	// 822F3CD8: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3CE8 size=32
    let mut pc: u32 = 0x822F3CE8;
    'dispatch: loop {
        match pc {
            0x822F3CE8 => {
    //   block [0x822F3CE8..0x822F3D08)
	// 822F3CE8: 816400A8  lwz r11, 0xa8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3CEC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3CF0: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3CF4: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F3CF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3CFC: 4098000C  bge cr6, 0x822f3d08
	if !ctx.cr[6].lt {
		sub_822F3D08(ctx, base);
		return;
	}
	// 822F3D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F3D04: 48000010  b 0x822f3d14
	sub_822F3D08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F3D08 size=48
    let mut pc: u32 = 0x822F3D08;
    'dispatch: loop {
        match pc {
            0x822F3D08 => {
    //   block [0x822F3D08..0x822F3D38)
	// 822F3D08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3D0C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3D10: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3D14: C00B0150  lfs f0, 0x150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F3D18: C1AB0154  lfs f13, 0x154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F3D1C: C18B0158  lfs f12, 0x158(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F3D20: C16B015C  lfs f11, 0x15c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(348 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F3D24: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822F3D28: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 822F3D2C: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F3D30: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822F3D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3D38 size=32
    let mut pc: u32 = 0x822F3D38;
    'dispatch: loop {
        match pc {
            0x822F3D38 => {
    //   block [0x822F3D38..0x822F3D58)
	// 822F3D38: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3D3C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3D40: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3D44: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F3D48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3D4C: 4098000C  bge cr6, 0x822f3d58
	if !ctx.cr[6].lt {
		sub_822F3D58(ctx, base);
		return;
	}
	// 822F3D50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F3D54: 48000010  b 0x822f3d64
	sub_822F3D58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3D58 size=20
    let mut pc: u32 = 0x822F3D58;
    'dispatch: loop {
        match pc {
            0x822F3D58 => {
    //   block [0x822F3D58..0x822F3D6C)
	// 822F3D58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3D5C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3D60: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3D64: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822F3D68: 4BFF5A58  b 0x822e97c0
	sub_822E97C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F3D70 size=152
    let mut pc: u32 = 0x822F3D70;
    'dispatch: loop {
        match pc {
            0x822F3D70 => {
    //   block [0x822F3D70..0x822F3E08)
	// 822F3D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3D74: 48EB43ED  bl 0x831a8160
	ctx.lr = 0x822F3D78;
	sub_831A8130(ctx, base);
	// 822F3D78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3D7C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F3D80: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822F3D84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F3D88: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3D8C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3D90: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3D94: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3D98: 40990068  ble cr6, 0x822f3e00
	if !ctx.cr[6].gt {
	pc = 0x822F3E00; continue 'dispatch;
	}
	// 822F3D9C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 822F3DA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F3DA4: 3B6A6910  addi r27, r10, 0x6910
	ctx.r[27].s64 = ctx.r[10].s64 + 26896;
	// 822F3DA8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3DAC: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F3DB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3DB4: 4098000C  bge cr6, 0x822f3dc0
	if !ctx.cr[6].lt {
	pc = 0x822F3DC0; continue 'dispatch;
	}
	// 822F3DB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F3DBC: 48000010  b 0x822f3dcc
	pc = 0x822F3DCC; continue 'dispatch;
	// 822F3DC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3DC4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3DC8: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3DCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822F3DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3DD4: 4BFF9125  bl 0x822ecef8
	ctx.lr = 0x822F3DD8;
	sub_822ECEF8(ctx, base);
	// 822F3DD8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822F3DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3DE0: 4BFF59E1  bl 0x822e97c0
	ctx.lr = 0x822F3DE4;
	sub_822E97C0(ctx, base);
	// 822F3DE4: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3DE8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F3DEC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F3DF0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3DF4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3DF8: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F3DFC: 4198FFAC  blt cr6, 0x822f3da8
	if ctx.cr[6].lt {
	pc = 0x822F3DA8; continue 'dispatch;
	}
	// 822F3E00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F3E04: 48EB43AC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3E08 size=32
    let mut pc: u32 = 0x822F3E08;
    'dispatch: loop {
        match pc {
            0x822F3E08 => {
    //   block [0x822F3E08..0x822F3E28)
	// 822F3E08: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3E0C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3E10: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3E14: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F3E18: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3E1C: 4098000C  bge cr6, 0x822f3e28
	if !ctx.cr[6].lt {
		sub_822F3E28(ctx, base);
		return;
	}
	// 822F3E20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F3E24: 48000010  b 0x822f3e34
	sub_822F3E28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F3E28 size=20
    let mut pc: u32 = 0x822F3E28;
    'dispatch: loop {
        match pc {
            0x822F3E28 => {
    //   block [0x822F3E28..0x822F3E3C)
	// 822F3E28: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3E2C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3E30: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3E34: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822F3E38: 4BFF90C0  b 0x822ecef8
	sub_822ECEF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F3E40 size=128
    let mut pc: u32 = 0x822F3E40;
    'dispatch: loop {
        match pc {
            0x822F3E40 => {
    //   block [0x822F3E40..0x822F3EC0)
	// 822F3E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3E44: 48EB4325  bl 0x831a8168
	ctx.lr = 0x822F3E48;
	sub_831A8130(ctx, base);
	// 822F3E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3E4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F3E50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822F3E54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F3E58: 817D00A8  lwz r11, 0xa8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3E5C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3E60: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3E64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3E68: 40990050  ble cr6, 0x822f3eb8
	if !ctx.cr[6].gt {
	pc = 0x822F3EB8; continue 'dispatch;
	}
	// 822F3E6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F3E70: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3E74: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822F3E78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3E7C: 4098000C  bge cr6, 0x822f3e88
	if !ctx.cr[6].lt {
	pc = 0x822F3E88; continue 'dispatch;
	}
	// 822F3E80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F3E84: 48000010  b 0x822f3e94
	pc = 0x822F3E94; continue 'dispatch;
	// 822F3E88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3E8C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3E90: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3E94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F3E98: 4BFF8FC1  bl 0x822ece58
	ctx.lr = 0x822F3E9C;
	sub_822ECE58(ctx, base);
	// 822F3E9C: 817D00A8  lwz r11, 0xa8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3EA0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F3EA4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F3EA8: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3EAC: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3EB0: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F3EB4: 4198FFBC  blt cr6, 0x822f3e70
	if ctx.cr[6].lt {
	pc = 0x822F3E70; continue 'dispatch;
	}
	// 822F3EB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F3EBC: 48EB42FC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F3EC0 size=160
    let mut pc: u32 = 0x822F3EC0;
    'dispatch: loop {
        match pc {
            0x822F3EC0 => {
    //   block [0x822F3EC0..0x822F3F60)
	// 822F3EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3EC4: 48EB429D  bl 0x831a8160
	ctx.lr = 0x822F3EC8;
	sub_831A8130(ctx, base);
	// 822F3EC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3ECC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F3ED0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822F3ED4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 822F3ED8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F3EDC: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3EE0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3EE4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3EE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3EEC: 4099006C  ble cr6, 0x822f3f58
	if !ctx.cr[6].gt {
	pc = 0x822F3F58; continue 'dispatch;
	}
	// 822F3EF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F3EF4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3EF8: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F3EFC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3F00: 4098000C  bge cr6, 0x822f3f0c
	if !ctx.cr[6].lt {
	pc = 0x822F3F0C; continue 'dispatch;
	}
	// 822F3F04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F3F08: 48000010  b 0x822f3f18
	pc = 0x822F3F18; continue 'dispatch;
	// 822F3F0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3F10: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3F14: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3F1C: 48BE4D4D  bl 0x82ed8c68
	ctx.lr = 0x822F3F20;
	sub_82ED8C68(ctx, base);
	// 822F3F20: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822F3F24: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 822F3F28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 822F3F2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822F3F30: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 822F3F34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F3F38: 4E800421  bctrl
	ctx.lr = 0x822F3F3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F3F3C: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3F40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F3F44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F3F48: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F3F4C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F3F50: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F3F54: 4198FFA0  blt cr6, 0x822f3ef4
	if ctx.cr[6].lt {
	pc = 0x822F3EF4; continue 'dispatch;
	}
	// 822F3F58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F3F5C: 48EB4254  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F3F60 size=152
    let mut pc: u32 = 0x822F3F60;
    'dispatch: loop {
        match pc {
            0x822F3F60 => {
    //   block [0x822F3F60..0x822F3FF8)
	// 822F3F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F3F68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F3F6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F3F70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F3F74: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F3F78: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3F7C: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F3F80: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F3F84: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F3F88: 4098000C  bge cr6, 0x822f3f94
	if !ctx.cr[6].lt {
	pc = 0x822F3F94; continue 'dispatch;
	}
	// 822F3F8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F3F90: 48000010  b 0x822f3fa0
	pc = 0x822F3FA0; continue 'dispatch;
	// 822F3F94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3F98: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F3F9C: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F3FA0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F3FA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F3FA8: 419A000C  beq cr6, 0x822f3fb4
	if ctx.cr[6].eq {
	pc = 0x822F3FB4; continue 'dispatch;
	}
	// 822F3FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F3FB0: 48BDA851  bl 0x82ece800
	ctx.lr = 0x822F3FB4;
	sub_82ECE800(ctx, base);
	// 822F3FB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F3FB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F3FBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F3FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F3FC4: 48BD7BCD  bl 0x82ecbb90
	ctx.lr = 0x822F3FC8;
	sub_82ECBB90(ctx, base);
	// 822F3FC8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 822F3FCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F3FD0: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	// 822F3FD4: 419A000C  beq cr6, 0x822f3fe0
	if ctx.cr[6].eq {
	pc = 0x822F3FE0; continue 'dispatch;
	}
	// 822F3FD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F3FDC: 48BD902D  bl 0x82ecd008
	ctx.lr = 0x822F3FE0;
	sub_82ECD008(ctx, base);
	// 822F3FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F3FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F3FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F3FEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F3FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F3FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F3FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F3FF8 size=284
    let mut pc: u32 = 0x822F3FF8;
    'dispatch: loop {
        match pc {
            0x822F3FF8 => {
    //   block [0x822F3FF8..0x822F4114)
	// 822F3FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F3FFC: 48EB416D  bl 0x831a8168
	ctx.lr = 0x822F4000;
	sub_831A8130(ctx, base);
	// 822F4000: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 822F4004: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F4008: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F400C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F4010: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822F4014: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F4018: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F401C: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F4020: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F4024: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F4028: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F402C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F4030: 40990054  ble cr6, 0x822f4084
	if !ctx.cr[6].gt {
	pc = 0x822F4084; continue 'dispatch;
	}
	// 822F4034: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F4038: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F403C: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F4040: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F4044: 4098000C  bge cr6, 0x822f4050
	if !ctx.cr[6].lt {
	pc = 0x822F4050; continue 'dispatch;
	}
	// 822F4048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F404C: 48000010  b 0x822f405c
	pc = 0x822F405C; continue 'dispatch;
	// 822F4050: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4054: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F4058: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F405C: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 822F4060: 48BE6519  bl 0x82eda578
	ctx.lr = 0x822F4064;
	sub_82EDA578(ctx, base);
	// 822F4064: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F4068: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F406C: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 822F4070: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 822F4074: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F4078: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F407C: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F4080: 4198FFB8  blt cr6, 0x822f4038
	if ctx.cr[6].lt {
	pc = 0x822F4038; continue 'dispatch;
	}
	// 822F4084: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F4088: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F408C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F4090: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F4094: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F4098: 4099006C  ble cr6, 0x822f4104
	if !ctx.cr[6].gt {
	pc = 0x822F4104; continue 'dispatch;
	}
	// 822F409C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F40A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F40A4: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F40A8: EFE0F824  fdivs f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 822F40AC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F40B0: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 822F40B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F40B8: 4098000C  bge cr6, 0x822f40c4
	if !ctx.cr[6].lt {
	pc = 0x822F40C4; continue 'dispatch;
	}
	// 822F40BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F40C0: 48000010  b 0x822f40d0
	pc = 0x822F40D0; continue 'dispatch;
	// 822F40C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F40C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F40CC: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F40D0: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 822F40D4: 48BE64A5  bl 0x82eda578
	ctx.lr = 0x822F40D8;
	sub_82EDA578(ctx, base);
	// 822F40D8: EC0107F2  fmuls f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 822F40DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F40E0: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 822F40E4: 48BD740D  bl 0x82ecb4f0
	ctx.lr = 0x822F40E8;
	sub_82ECB4F0(ctx, base);
	// 822F40E8: 817C00A8  lwz r11, 0xa8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F40EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 822F40F0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F40F4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F40F8: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F40FC: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F4100: 4198FFAC  blt cr6, 0x822f40ac
	if ctx.cr[6].lt {
	pc = 0x822F40AC; continue 'dispatch;
	}
	// 822F4104: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F4108: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822F410C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F4110: 48EB40A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F4118 size=176
    let mut pc: u32 = 0x822F4118;
    'dispatch: loop {
        match pc {
            0x822F4118 => {
    //   block [0x822F4118..0x822F41C8)
	// 822F4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F411C: 48EB4051  bl 0x831a816c
	ctx.lr = 0x822F4120;
	sub_831A8130(ctx, base);
	// 822F4120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4124: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F4128: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F412C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F4130: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F4134: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F4138: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F413C: 4098000C  bge cr6, 0x822f4148
	if !ctx.cr[6].lt {
	pc = 0x822F4148; continue 'dispatch;
	}
	// 822F4140: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F4144: 48000010  b 0x822f4154
	pc = 0x822F4154; continue 'dispatch;
	// 822F4148: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F414C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F4150: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F4154: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F4158: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F415C: 419A000C  beq cr6, 0x822f4168
	if ctx.cr[6].eq {
	pc = 0x822F4168; continue 'dispatch;
	}
	// 822F4160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F4164: 48BDA69D  bl 0x82ece800
	ctx.lr = 0x822F4168;
	sub_82ECE800(ctx, base);
	// 822F4168: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F416C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F4170: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 822F4174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4178: 48BD7A19  bl 0x82ecbb90
	ctx.lr = 0x822F417C;
	sub_82ECBB90(ctx, base);
	// 822F417C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 822F4180: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F4184: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	// 822F4188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F418C: 48BD7E35  bl 0x82ecbfc0
	ctx.lr = 0x822F4190;
	sub_82ECBFC0(ctx, base);
	// 822F4190: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822F4194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F4198: 3BAB7060  addi r29, r11, 0x7060
	ctx.r[29].s64 = ctx.r[11].s64 + 28768;
	// 822F419C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F41A0: 4BFF5621  bl 0x822e97c0
	ctx.lr = 0x822F41A4;
	sub_822E97C0(ctx, base);
	// 822F41A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F41A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F41AC: 4BFF8D4D  bl 0x822ecef8
	ctx.lr = 0x822F41B0;
	sub_822ECEF8(ctx, base);
	// 822F41B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F41B4: 419A000C  beq cr6, 0x822f41c0
	if ctx.cr[6].eq {
	pc = 0x822F41C0; continue 'dispatch;
	}
	// 822F41B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F41BC: 48BD8E4D  bl 0x82ecd008
	ctx.lr = 0x822F41C0;
	sub_82ECD008(ctx, base);
	// 822F41C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F41C4: 48EB3FF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F41C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F41C8 size=140
    let mut pc: u32 = 0x822F41C8;
    'dispatch: loop {
        match pc {
            0x822F41C8 => {
    //   block [0x822F41C8..0x822F4254)
	// 822F41C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F41CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F41D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F41D4: 816300A8  lwz r11, 0xa8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F41D8: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F41DC: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F41E0: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F41E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F41E8: 4098000C  bge cr6, 0x822f41f4
	if !ctx.cr[6].lt {
	pc = 0x822F41F4; continue 'dispatch;
	}
	// 822F41EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F41F0: 48000010  b 0x822f4200
	pc = 0x822F4200; continue 'dispatch;
	// 822F41F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F41F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822F41FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F4200: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822F4204: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F4258 size=1024
    let mut pc: u32 = 0x822F4258;
    'dispatch: loop {
        match pc {
            0x822F4258 => {
    //   block [0x822F4258..0x822F4658)
	// 822F4258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F425C: 48EB3EFD  bl 0x831a8158
	ctx.lr = 0x822F4260;
	sub_831A8130(ctx, base);
	// 822F4260: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F4658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F4658 size=5088
    let mut pc: u32 = 0x822F4658;
    'dispatch: loop {
        match pc {
            0x822F4658 => {
    //   block [0x822F4658..0x822F5A38)
	// 822F4658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F465C: 48EB3ADD  bl 0x831a8138
	ctx.lr = 0x822F4660;
	sub_831A8130(ctx, base);
	// 822F4660: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 822F4664: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 822F4668: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 822F466C: 3981FF60  addi r12, r1, -0xa0
	ctx.r[12].s64 = ctx.r[1].s64 + -160;
	// 822F4670: 48EB659D  bl 0x831aac0c
	ctx.lr = 0x822F4674;
	sub_831AA9A0(ctx, base);
	// 822F4674: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F4678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F467C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822F4680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F4684: 7CD03378  mr r16, r6
	ctx.r[16].u64 = ctx.r[6].u64;
	// 822F4688: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 822F468C: 897E00A6  lbz r11, 0xa6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(166 as u32) ) } as u64;
	// 822F4690: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F4694: 418206A8  beq 0x822f4d3c
	if ctx.cr[0].eq {
	pc = 0x822F4D3C; continue 'dispatch;
	}
	// 822F4698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F469C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F46A0: 997E00A6  stb r11, 0xa6(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(166 as u32), ctx.r[11].u8 ) };
	// 822F46A4: 13E090C7  vcmpequd (lvx128) v31, v0, v18
	tmp.u32 = ctx.r[18].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822F46A8: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F5A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F5A38 size=676
    let mut pc: u32 = 0x822F5A38;
    'dispatch: loop {
        match pc {
            0x822F5A38 => {
    //   block [0x822F5A38..0x822F5CDC)
	// 822F5A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F5A3C: 48EB2725  bl 0x831a8160
	ctx.lr = 0x822F5A40;
	sub_831A8130(ctx, base);
	// 822F5A40: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 822F5A44: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822F5A48: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F5CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F5CE0 size=556
    let mut pc: u32 = 0x822F5CE0;
    'dispatch: loop {
        match pc {
            0x822F5CE0 => {
    //   block [0x822F5CE0..0x822F5F0C)
	// 822F5CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F5CE4: 48EB2471  bl 0x831a8154
	ctx.lr = 0x822F5CE8;
	sub_831A8130(ctx, base);
	// 822F5CE8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F5CEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F5CF0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822F5CF4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 822F5CF8: 3AE000FF  li r23, 0xff
	ctx.r[23].s64 = 255;
	// 822F5CFC: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 822F5D00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F5D04: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F5D08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F5D0C: 4099011C  ble cr6, 0x822f5e28
	if !ctx.cr[6].gt {
	pc = 0x822F5E28; continue 'dispatch;
	}
	// 822F5D10: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 822F5D14: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 822F5D18: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 822F5D1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F5D20: 7FCBDAAE  lhax r30, r11, r27
	ctx.r[30].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as i16) as i64;
	// 822F5D24: 2C1E0000  cmpwi r30, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 822F5D28: 418000E0  blt 0x822f5e08
	if ctx.cr[0].lt {
	pc = 0x822F5E08; continue 'dispatch;
	}
	// 822F5D2C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F5D30: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F5D34: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F5D38: 40820010  bne 0x822f5d48
	if !ctx.cr[0].eq {
	pc = 0x822F5D48; continue 'dispatch;
	}
	// 822F5D3C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F5D40: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 822F5D44: 48000010  b 0x822f5d54
	pc = 0x822F5D54; continue 'dispatch;
	// 822F5D48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F5D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F5D50: 48CB8A29  bl 0x82fae778
	ctx.lr = 0x822F5D54;
	sub_82FAE778(ctx, base);
	// 822F5D54: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 822F5D58: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 822F5D5C: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F5D60: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F5F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F5F10 size=188
    let mut pc: u32 = 0x822F5F10;
    'dispatch: loop {
        match pc {
            0x822F5F10 => {
    //   block [0x822F5F10..0x822F5FCC)
	// 822F5F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F5F14: 48EB2251  bl 0x831a8164
	ctx.lr = 0x822F5F18;
	sub_831A8130(ctx, base);
	// 822F5F18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F5F1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F5F20: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822F5F24: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822F5F28: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 822F5F2C: 3B6B1800  addi r27, r11, 0x1800
	ctx.r[27].s64 = ctx.r[11].s64 + 6144;
	// 822F5F30: 895F00D8  lbz r10, 0xd8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 822F5F34: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 822F5F38: 419A0030  beq cr6, 0x822f5f68
	if ctx.cr[6].eq {
	pc = 0x822F5F68; continue 'dispatch;
	}
	// 822F5F3C: A17F002A  lhz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 822F5F40: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 822F5F44: 409A0024  bne cr6, 0x822f5f68
	if !ctx.cr[6].eq {
	pc = 0x822F5F68; continue 'dispatch;
	}
	// 822F5F48: 1D7C001E  mulli r11, r28, 0x1e
	ctx.r[11].s64 = ctx.r[28].s64 * 30;
	// 822F5F4C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F5F50: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822F5F54: 393B007C  addi r9, r27, 0x7c
	ctx.r[9].s64 = ctx.r[27].s64 + 124;
	// 822F5F58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F5F5C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 822F5F60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822F5F64: 419A0060  beq cr6, 0x822f5fc4
	if ctx.cr[6].eq {
	pc = 0x822F5FC4; continue 'dispatch;
	}
	// 822F5F68: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F5F6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F5F70: 419A000C  beq cr6, 0x822f5f7c
	if ctx.cr[6].eq {
	pc = 0x822F5F7C; continue 'dispatch;
	}
	// 822F5F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F5F78: 48BD8889  bl 0x82ece800
	ctx.lr = 0x822F5F7C;
	sub_82ECE800(ctx, base);
	// 822F5F7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F5F80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F5F84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F5F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F5F8C: 48BD5C05  bl 0x82ecbb90
	ctx.lr = 0x822F5F90;
	sub_82ECBB90(ctx, base);
	// 822F5F90: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 822F5F94: 1D7C001E  mulli r11, r28, 0x1e
	ctx.r[11].s64 = ctx.r[28].s64 * 30;
	// 822F5F98: B15F002A  sth r10, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[10].u16 ) };
	// 822F5F9C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822F5FA0: 395B007C  addi r10, r27, 0x7c
	ctx.r[10].s64 = ctx.r[27].s64 + 124;
	// 822F5FA4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F5FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F5FAC: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F5FB0: 4BFF2759  bl 0x822e8708
	ctx.lr = 0x822F5FB4;
	sub_822E8708(ctx, base);
	// 822F5FB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F5FB8: 419A000C  beq cr6, 0x822f5fc4
	if ctx.cr[6].eq {
	pc = 0x822F5FC4; continue 'dispatch;
	}
	// 822F5FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F5FC0: 48BD7049  bl 0x82ecd008
	ctx.lr = 0x822F5FC4;
	sub_82ECD008(ctx, base);
	// 822F5FC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F5FC8: 48EB21EC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F5FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F5FD0 size=84
    let mut pc: u32 = 0x822F5FD0;
    'dispatch: loop {
        match pc {
            0x822F5FD0 => {
    //   block [0x822F5FD0..0x822F6024)
	// 822F5FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F5FD4: 48EB2199  bl 0x831a816c
	ctx.lr = 0x822F5FD8;
	sub_831A8130(ctx, base);
	// 822F5FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F5FDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F5FE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F5FE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F5FE8: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 822F5FEC: 409A0008  bne cr6, 0x822f5ff4
	if !ctx.cr[6].eq {
	pc = 0x822F5FF4; continue 'dispatch;
	}
	// 822F5FF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F5FF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F5FF8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 822F5FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F6000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F6004: 4BFFD9BD  bl 0x822f39c0
	ctx.lr = 0x822F6008;
	sub_822F39C0(ctx, base);
	// 822F6008: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F600C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F6010: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F6014: 4BFC9FED  bl 0x822c0000
	ctx.lr = 0x822F6018;
	sub_822C0000(ctx, base);
	// 822F6018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F601C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F6020: 48EB219C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F6028 size=152
    let mut pc: u32 = 0x822F6028;
    'dispatch: loop {
        match pc {
            0x822F6028 => {
    //   block [0x822F6028..0x822F60C0)
	// 822F6028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F602C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F6030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F6034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F6038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F603C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F6040: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F6044: 4BFFDB55  bl 0x822f3b98
	ctx.lr = 0x822F6048;
	sub_822F3B98(ctx, base);
	// 822F6048: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F604C: 41820058  beq 0x822f60a4
	if ctx.cr[0].eq {
	pc = 0x822F60A4; continue 'dispatch;
	}
	// 822F6050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F6054: 419A0050  beq cr6, 0x822f60a4
	if ctx.cr[6].eq {
	pc = 0x822F60A4; continue 'dispatch;
	}
	// 822F6058: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F605C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 822F6060: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F6064: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F6068: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 822F606C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822F6070: 41980018  blt cr6, 0x822f6088
	if ctx.cr[6].lt {
	pc = 0x822F6088; continue 'dispatch;
	}
	// 822F6074: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 822F6078: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F607C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 822F6080: 48BA9FE1  bl 0x82ea0060
	ctx.lr = 0x822F6084;
	sub_82EA0060(ctx, base);
	// 822F6084: 48000020  b 0x822f60a4
	pc = 0x822F60A4; continue 'dispatch;
	// 822F6088: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F608C: 39630060  addi r11, r3, 0x60
	ctx.r[11].s64 = ctx.r[3].s64 + 96;
	// 822F6090: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F6094: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F6098: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822F609C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F60A0: 93E30060  stw r31, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822F60A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F60A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F60AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F60B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F60B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F60B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F60BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F60C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F60C0 size=204
    let mut pc: u32 = 0x822F60C0;
    'dispatch: loop {
        match pc {
            0x822F60C0 => {
    //   block [0x822F60C0..0x822F618C)
	// 822F60C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F60C4: 48EB20A1  bl 0x831a8164
	ctx.lr = 0x822F60C8;
	sub_831A8130(ctx, base);
	// 822F60C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F60CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F60D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F60D4: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F60D8: 837F00C8  lwz r27, 0xc8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 822F60DC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F60E0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F60E4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822F60E8: 4099009C  ble cr6, 0x822f6184
	if !ctx.cr[6].gt {
	pc = 0x822F6184; continue 'dispatch;
	}
	// 822F60EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F60F0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 822F60F4: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F60F8: 7D29E82E  lwzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822F60FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822F6100: 41980064  blt cr6, 0x822f6164
	if ctx.cr[6].lt {
	pc = 0x822F6164; continue 'dispatch;
	}
	// 822F6104: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F6108: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 822F610C: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F6110: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F6114: 419A0050  beq cr6, 0x822f6164
	if ctx.cr[6].eq {
	pc = 0x822F6164; continue 'dispatch;
	}
	// 822F6118: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F611C: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F6120: 7CCBE2AE  lhax r6, r11, r28
	ctx.r[6].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as i16) as i64;
	// 822F6124: 7D7D502E  lwzx r11, r29, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6128: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F612C: 419A0024  beq cr6, 0x822f6150
	if ctx.cr[6].eq {
	pc = 0x822F6150; continue 'dispatch;
	}
	// 822F6130: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822F6134: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F6138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F613C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822F6140: 419A0008  beq cr6, 0x822f6148
	if ctx.cr[6].eq {
	pc = 0x822F6148; continue 'dispatch;
	}
	// 822F6144: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822F6148: 4BFFF8F1  bl 0x822f5a38
	ctx.lr = 0x822F614C;
	sub_822F5A38(ctx, base);
	// 822F614C: 48000018  b 0x822f6164
	pc = 0x822F6164; continue 'dispatch;
	// 822F6150: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 822F6154: 80BF013C  lwz r5, 0x13c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 822F6158: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822F615C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F6160: 4BFFFDB1  bl 0x822f5f10
	ctx.lr = 0x822F6164;
	sub_822F5F10(ctx, base);
	// 822F6164: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F6168: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 822F616C: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	// 822F6170: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F6174: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F6178: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F617C: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 822F6180: 4198FF74  blt cr6, 0x822f60f4
	if ctx.cr[6].lt {
	pc = 0x822F60F4; continue 'dispatch;
	}
	// 822F6184: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F6188: 48EB202C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F6190 size=2720
    let mut pc: u32 = 0x822F6190;
    'dispatch: loop {
        match pc {
            0x822F6190 => {
    //   block [0x822F6190..0x822F6C30)
	// 822F6190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F6194: 48EB1F9D  bl 0x831a8130
	ctx.lr = 0x822F6198;
	sub_831A8130(ctx, base);
	// 822F6198: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 822F619C: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 822F61A0: 3981FF50  addi r12, r1, -0xb0
	ctx.r[12].s64 = ctx.r[1].s64 + -176;
	// 822F61A4: 48EB4A71  bl 0x831aac14
	ctx.lr = 0x822F61A8;
	sub_831AA9A0(ctx, base);
	// 822F61A8: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F61AC: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 822F61B0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822F61B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 822F61B8: 90C1025C  stw r6, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[6].u32 ) };
	// 822F61BC: 39010100  addi r8, r1, 0x100
	ctx.r[8].s64 = ctx.r[1].s64 + 256;
	// 822F61C0: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 822F61C4: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 822F61C8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 822F61CC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 822F61D0: C3E908A8  lfs f31, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F61D4: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 822F61D8: D3E10100  stfs f31, 0x100(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 822F61DC: 3AEBFFE0  addi r23, r11, -0x20
	ctx.r[23].s64 = ctx.r[11].s64 + -32;
	// 822F61E0: 13C040C7  vcmpequd (lvx128) v30, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F6C30 size=96
    let mut pc: u32 = 0x822F6C30;
    'dispatch: loop {
        match pc {
            0x822F6C30 => {
    //   block [0x822F6C30..0x822F6C90)
	// 822F6C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F6C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F6C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F6C3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F6C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F6C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F6C48: 4BFFF389  bl 0x822f5fd0
	ctx.lr = 0x822F6C4C;
	sub_822F5FD0(ctx, base);
	// 822F6C4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6C50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6C54: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F6C58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F6C5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F6C60: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F6C64: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F6C68: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F6C6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F6C70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6C74: 419A0008  beq cr6, 0x822f6c7c
	if ctx.cr[6].eq {
	pc = 0x822F6C7C; continue 'dispatch;
	}
	// 822F6C78: 4BFC9C19  bl 0x822c0890
	ctx.lr = 0x822F6C7C;
	sub_822C0890(ctx, base);
	// 822F6C7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F6C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F6C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F6C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F6C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F6C90 size=184
    let mut pc: u32 = 0x822F6C90;
    'dispatch: loop {
        match pc {
            0x822F6C90 => {
    //   block [0x822F6C90..0x822F6D48)
	// 822F6C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F6C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F6C98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F6C9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F6CA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F6CA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F6CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F6CAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822F6CB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F6CB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F6CB8: 4BFC9C81  bl 0x822c0938
	ctx.lr = 0x822F6CBC;
	sub_822C0938(ctx, base);
	// 822F6CBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F6CC0: 41820028  beq 0x822f6ce8
	if ctx.cr[0].eq {
	pc = 0x822F6CE8; continue 'dispatch;
	}
	// 822F6CC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F6CC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F6CCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F6CD0: 392BC560  addi r9, r11, -0x3aa0
	ctx.r[9].s64 = ctx.r[11].s64 + -15008;
	// 822F6CD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F6CD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F6CDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F6CE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F6CE4: 48000008  b 0x822f6cec
	pc = 0x822F6CEC; continue 'dispatch;
	// 822F6CE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F6CEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F6CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F6CF4: 409A0038  bne cr6, 0x822f6d2c
	if !ctx.cr[6].eq {
	pc = 0x822F6D2C; continue 'dispatch;
	}
	// 822F6CF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F6CFC: 419A0010  beq cr6, 0x822f6d0c
	if ctx.cr[6].eq {
	pc = 0x822F6D0C; continue 'dispatch;
	}
	// 822F6D00: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F6D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F6D08: 4BFFCD81  bl 0x822f3a88
	ctx.lr = 0x822F6D0C;
	sub_822F3A88(ctx, base);
	// 822F6D0C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822F6D10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F6D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F6D18: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822F6D1C: 816B4AF4  lwz r11, 0x4af4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19188 as u32) ) } as u64;
	// 822F6D20: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822F6D24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822F6D28: 4BFC92D9  bl 0x822c0000
	ctx.lr = 0x822F6D2C;
	sub_822C0000(ctx, base);
	// 822F6D2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F6D30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F6D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F6D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F6D3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F6D40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F6D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F6D48 size=12
    let mut pc: u32 = 0x822F6D48;
    'dispatch: loop {
        match pc {
            0x822F6D48 => {
    //   block [0x822F6D48..0x822F6D54)
	// 822F6D48: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F6D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6D50: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6D54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F6D54 size=8
    let mut pc: u32 = 0x822F6D54;
    'dispatch: loop {
        match pc {
            0x822F6D54 => {
    //   block [0x822F6D54..0x822F6D5C)
	// 822F6D54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F6D58: 4BFFCD30  b 0x822f3a88
	sub_822F3A88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6D5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F6D5C size=4
    let mut pc: u32 = 0x822F6D5C;
    'dispatch: loop {
        match pc {
            0x822F6D5C => {
    //   block [0x822F6D5C..0x822F6D60)
	// 822F6D5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F6D60 size=112
    let mut pc: u32 = 0x822F6D60;
    'dispatch: loop {
        match pc {
            0x822F6D60 => {
    //   block [0x822F6D60..0x822F6DD0)
	// 822F6D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F6D64: 48EB1409  bl 0x831a816c
	ctx.lr = 0x822F6D68;
	sub_831A8130(ctx, base);
	// 822F6D68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F6D6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F6D70: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F6D74: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F6D78: 40990024  ble cr6, 0x822f6d9c
	if !ctx.cr[6].gt {
	pc = 0x822F6D9C; continue 'dispatch;
	}
	// 822F6D7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F6D80: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6D84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F6D88: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822F6D8C: 4BFFCB9D  bl 0x822f3928
	ctx.lr = 0x822F6D90;
	sub_822F3928(ctx, base);
	// 822F6D90: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F6D94: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 822F6D98: 4082FFE8  bne 0x822f6d80
	if !ctx.cr[0].eq {
	pc = 0x822F6D80; continue 'dispatch;
	}
	// 822F6D9C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F6DA0: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6DA4: 40820024  bne 0x822f6dc8
	if !ctx.cr[0].eq {
	pc = 0x822F6DC8; continue 'dispatch;
	}
	// 822F6DA8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6DAC: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6DB0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6DB4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6DB8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6DBC: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6DC0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6DC4: 48BA99ED  bl 0x82ea07b0
	ctx.lr = 0x822F6DC8;
	sub_82EA07B0(ctx, base);
	// 822F6DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F6DCC: 48EB13F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F6DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F6DD0 size=572
    let mut pc: u32 = 0x822F6DD0;
    'dispatch: loop {
        match pc {
            0x822F6DD0 => {
    //   block [0x822F6DD0..0x822F700C)
	// 822F6DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F6DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F6DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F6DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F6DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F6DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F6DE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F6DEC: 396BC5FC  addi r11, r11, -0x3a04
	ctx.r[11].s64 = ctx.r[11].s64 + -14852;
	// 822F6DF0: 809F00E0  lwz r4, 0xe0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 822F6DF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F6DF8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822F6DFC: 419A0008  beq cr6, 0x822f6e04
	if ctx.cr[6].eq {
	pc = 0x822F6E04; continue 'dispatch;
	}
	// 822F6E00: 4BFFCAC1  bl 0x822f38c0
	ctx.lr = 0x822F6E04;
	sub_822F38C0(ctx, base);
	// 822F6E04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F6E08: 397F00AC  addi r11, r31, 0xac
	ctx.r[11].s64 = ctx.r[31].s64 + 172;
	// 822F6E0C: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 822F6E10: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 822F6E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6E18: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 822F6E1C: 419A0008  beq cr6, 0x822f6e24
	if ctx.cr[6].eq {
	pc = 0x822F6E24; continue 'dispatch;
	}
	// 822F6E20: 4BFC9A71  bl 0x822c0890
	ctx.lr = 0x822F6E24;
	sub_822C0890(ctx, base);
	// 822F6E24: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 822F6E28: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6E2C: 40820024  bne 0x822f6e50
	if !ctx.cr[0].eq {
	pc = 0x822F6E50; continue 'dispatch;
	}
	// 822F6E30: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6E34: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6E38: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6E3C: 809F0130  lwz r4, 0x130(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 822F6E40: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6E44: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6E48: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6E4C: 48BA9965  bl 0x82ea07b0
	ctx.lr = 0x822F6E50;
	sub_82EA07B0(ctx, base);
	// 822F6E50: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 822F6E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6E58: 419A0008  beq cr6, 0x822f6e60
	if ctx.cr[6].eq {
	pc = 0x822F6E60; continue 'dispatch;
	}
	// 822F6E5C: 4BFC9A35  bl 0x822c0890
	ctx.lr = 0x822F6E60;
	sub_822C0890(ctx, base);
	// 822F6E60: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 822F6E64: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6E68: 40820020  bne 0x822f6e88
	if !ctx.cr[0].eq {
	pc = 0x822F6E88; continue 'dispatch;
	}
	// 822F6E6C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6E70: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6E74: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6E78: 809F011C  lwz r4, 0x11c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 822F6E7C: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 822F6E80: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6E84: 48BA992D  bl 0x82ea07b0
	ctx.lr = 0x822F6E88;
	sub_82EA07B0(ctx, base);
	// 822F6E88: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 822F6E8C: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6E90: 40820020  bne 0x822f6eb0
	if !ctx.cr[0].eq {
	pc = 0x822F6EB0; continue 'dispatch;
	}
	// 822F6E94: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6E98: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6E9C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6EA0: 809F0110  lwz r4, 0x110(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 822F6EA4: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 822F6EA8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6EAC: 48BA9905  bl 0x82ea07b0
	ctx.lr = 0x822F6EB0;
	sub_82EA07B0(ctx, base);
	// 822F6EB0: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 822F6EB4: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6EB8: 40820024  bne 0x822f6edc
	if !ctx.cr[0].eq {
	pc = 0x822F6EDC; continue 'dispatch;
	}
	// 822F6EBC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6EC0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6EC4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6EC8: 809F0104  lwz r4, 0x104(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 822F6ECC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6ED0: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6ED4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6ED8: 48BA98D9  bl 0x82ea07b0
	ctx.lr = 0x822F6EDC;
	sub_82EA07B0(ctx, base);
	// 822F6EDC: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 822F6EE0: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6EE4: 40820024  bne 0x822f6f08
	if !ctx.cr[0].eq {
	pc = 0x822F6F08; continue 'dispatch;
	}
	// 822F6EE8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6EEC: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6EF0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6EF4: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 822F6EF8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6EFC: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6F00: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6F04: 48BA98AD  bl 0x82ea07b0
	ctx.lr = 0x822F6F08;
	sub_82EA07B0(ctx, base);
	// 822F6F08: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 822F6F0C: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6F10: 40820024  bne 0x822f6f34
	if !ctx.cr[0].eq {
	pc = 0x822F6F34; continue 'dispatch;
	}
	// 822F6F14: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6F18: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6F1C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6F20: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 822F6F24: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6F28: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6F2C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6F30: 48BA9881  bl 0x82ea07b0
	ctx.lr = 0x822F6F34;
	sub_82EA07B0(ctx, base);
	// 822F6F34: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 822F6F38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6F3C: 419A0008  beq cr6, 0x822f6f44
	if ctx.cr[6].eq {
	pc = 0x822F6F44; continue 'dispatch;
	}
	// 822F6F40: 4BFC9951  bl 0x822c0890
	ctx.lr = 0x822F6F44;
	sub_822C0890(ctx, base);
	// 822F6F44: 807F00DC  lwz r3, 0xdc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 822F6F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6F4C: 419A0008  beq cr6, 0x822f6f54
	if ctx.cr[6].eq {
	pc = 0x822F6F54; continue 'dispatch;
	}
	// 822F6F50: 4BFC9941  bl 0x822c0890
	ctx.lr = 0x822F6F54;
	sub_822C0890(ctx, base);
	// 822F6F54: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 822F6F58: 4BFFFE09  bl 0x822f6d60
	ctx.lr = 0x822F6F5C;
	sub_822F6D60(ctx, base);
	// 822F6F5C: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 822F6F60: 488B6D99  bl 0x82badcf8
	ctx.lr = 0x822F6F64;
	sub_82BADCF8(ctx, base);
	// 822F6F64: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F6F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6F6C: 419A000C  beq cr6, 0x822f6f78
	if ctx.cr[6].eq {
	pc = 0x822F6F78; continue 'dispatch;
	}
	// 822F6F70: 48BDE199  bl 0x82ed5108
	ctx.lr = 0x822F6F74;
	sub_82ED5108(ctx, base);
	// 822F6F74: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 822F6F78: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 822F6F7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6F80: 419A0008  beq cr6, 0x822f6f88
	if ctx.cr[6].eq {
	pc = 0x822F6F88; continue 'dispatch;
	}
	// 822F6F84: 4BFC990D  bl 0x822c0890
	ctx.lr = 0x822F6F88;
	sub_822C0890(ctx, base);
	// 822F6F88: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 822F6F8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F6F90: 419A0008  beq cr6, 0x822f6f98
	if ctx.cr[6].eq {
	pc = 0x822F6F98; continue 'dispatch;
	}
	// 822F6F94: 4BFC98FD  bl 0x822c0890
	ctx.lr = 0x822F6F98;
	sub_822C0890(ctx, base);
	// 822F6F98: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 822F6F9C: 488B6D5D  bl 0x82badcf8
	ctx.lr = 0x822F6FA0;
	sub_82BADCF8(ctx, base);
	// 822F6FA0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F6FA4: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6FA8: 40820024  bne 0x822f6fcc
	if !ctx.cr[0].eq {
	pc = 0x822F6FCC; continue 'dispatch;
	}
	// 822F6FAC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6FB0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6FB4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F6FB8: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F6FBC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6FC0: 1CAB0030  mulli r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 * 48;
	// 822F6FC4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6FC8: 48BA97E9  bl 0x82ea07b0
	ctx.lr = 0x822F6FCC;
	sub_82EA07B0(ctx, base);
	// 822F6FCC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F6FD0: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F6FD4: 40820020  bne 0x822f6ff4
	if !ctx.cr[0].eq {
	pc = 0x822F6FF4; continue 'dispatch;
	}
	// 822F6FD8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F6FDC: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 822F6FE0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 822F6FE4: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F6FE8: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 822F6FEC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F6FF0: 48BA97C1  bl 0x82ea07b0
	ctx.lr = 0x822F6FF4;
	sub_82EA07B0(ctx, base);
	// 822F6FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F6FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F6FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F7000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F7004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F7008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F7010 size=184
    let mut pc: u32 = 0x822F7010;
    'dispatch: loop {
        match pc {
            0x822F7010 => {
    //   block [0x822F7010..0x822F70C8)
	// 822F7010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F7018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F701C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F7020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F7028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F702C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822F7030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F7034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F7038: 4BFC9901  bl 0x822c0938
	ctx.lr = 0x822F703C;
	sub_822C0938(ctx, base);
	// 822F703C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F7040: 41820028  beq 0x822f7068
	if ctx.cr[0].eq {
	pc = 0x822F7068; continue 'dispatch;
	}
	// 822F7044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F7048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F704C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F7050: 392BC588  addi r9, r11, -0x3a78
	ctx.r[9].s64 = ctx.r[11].s64 + -14968;
	// 822F7054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F7058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F705C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F7060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F7064: 48000008  b 0x822f706c
	pc = 0x822F706C; continue 'dispatch;
	// 822F7068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F706C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F7070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F7074: 409A0038  bne cr6, 0x822f70ac
	if !ctx.cr[6].eq {
	pc = 0x822F70AC; continue 'dispatch;
	}
	// 822F7078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F707C: 419A0010  beq cr6, 0x822f708c
	if ctx.cr[6].eq {
	pc = 0x822F708C; continue 'dispatch;
	}
	// 822F7080: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F7084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F7088: 4BFFEFA1  bl 0x822f6028
	ctx.lr = 0x822F708C;
	sub_822F6028(ctx, base);
	// 822F708C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822F7090: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F7094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F7098: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822F709C: 816B4AF4  lwz r11, 0x4af4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19188 as u32) ) } as u64;
	// 822F70A0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822F70A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822F70A8: 4BFC8F59  bl 0x822c0000
	ctx.lr = 0x822F70AC;
	sub_822C0000(ctx, base);
	// 822F70AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F70B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F70B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F70B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F70BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F70C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F70C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F70C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F70C8 size=12
    let mut pc: u32 = 0x822F70C8;
    'dispatch: loop {
        match pc {
            0x822F70C8 => {
    //   block [0x822F70C8..0x822F70D4)
	// 822F70C8: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F70CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F70D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F70D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F70D4 size=8
    let mut pc: u32 = 0x822F70D4;
    'dispatch: loop {
        match pc {
            0x822F70D4 => {
    //   block [0x822F70D4..0x822F70DC)
	// 822F70D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822F70D8: 4BFFEF50  b 0x822f6028
	sub_822F6028(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F70DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F70DC size=4
    let mut pc: u32 = 0x822F70DC;
    'dispatch: loop {
        match pc {
            0x822F70DC => {
    //   block [0x822F70DC..0x822F70E0)
	// 822F70DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F70E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F70E0 size=112
    let mut pc: u32 = 0x822F70E0;
    'dispatch: loop {
        match pc {
            0x822F70E0 => {
    //   block [0x822F70E0..0x822F7150)
	// 822F70E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F70E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F70E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F70EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F70F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F70F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F70F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F70FC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822F7100: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F7104: 4BFFFB8D  bl 0x822f6c90
	ctx.lr = 0x822F7108;
	sub_822F6C90(ctx, base);
	// 822F7108: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F710C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F7110: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F7114: 4BFC8EED  bl 0x822c0000
	ctx.lr = 0x822F7118;
	sub_822C0000(ctx, base);
	// 822F7118: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F711C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F7120: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F7124: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F7128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F712C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F7130: 419A0008  beq cr6, 0x822f7138
	if ctx.cr[6].eq {
	pc = 0x822F7138; continue 'dispatch;
	}
	// 822F7134: 4BFC975D  bl 0x822c0890
	ctx.lr = 0x822F7138;
	sub_822C0890(ctx, base);
	// 822F7138: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F713C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F7140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F7144: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F7148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F714C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F7150 size=112
    let mut pc: u32 = 0x822F7150;
    'dispatch: loop {
        match pc {
            0x822F7150 => {
    //   block [0x822F7150..0x822F71C0)
	// 822F7150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F7158: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F715C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F7160: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7164: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F7168: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F716C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822F7170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F7174: 4BFFFE9D  bl 0x822f7010
	ctx.lr = 0x822F7178;
	sub_822F7010(ctx, base);
	// 822F7178: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F717C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F7180: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F7184: 4BFC8E7D  bl 0x822c0000
	ctx.lr = 0x822F7188;
	sub_822C0000(ctx, base);
	// 822F7188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F718C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F7190: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F7194: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F7198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F719C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F71A0: 419A0008  beq cr6, 0x822f71a8
	if ctx.cr[6].eq {
	pc = 0x822F71A8; continue 'dispatch;
	}
	// 822F71A4: 4BFC96ED  bl 0x822c0890
	ctx.lr = 0x822F71A8;
	sub_822C0890(ctx, base);
	// 822F71A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F71AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F71B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F71B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F71B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F71BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F71C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F71C0 size=188
    let mut pc: u32 = 0x822F71C0;
    'dispatch: loop {
        match pc {
            0x822F71C0 => {
    //   block [0x822F71C0..0x822F727C)
	// 822F71C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F71C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F71C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F71CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F71D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F71D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F71D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F71DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822F71E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F71E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F71E8: 4BFC9751  bl 0x822c0938
	ctx.lr = 0x822F71EC;
	sub_822C0938(ctx, base);
	// 822F71EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F71F0: 41820028  beq 0x822f7218
	if ctx.cr[0].eq {
	pc = 0x822F7218; continue 'dispatch;
	}
	// 822F71F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F71F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822F71FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F7200: 392BC54C  addi r9, r11, -0x3ab4
	ctx.r[9].s64 = ctx.r[11].s64 + -15028;
	// 822F7204: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F7208: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F720C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F7210: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F7214: 48000008  b 0x822f721c
	pc = 0x822F721C; continue 'dispatch;
	// 822F7218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F721C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F7220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F7224: 409A003C  bne cr6, 0x822f7260
	if !ctx.cr[6].eq {
	pc = 0x822F7260; continue 'dispatch;
	}
	// 822F7228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F722C: 419A0014  beq cr6, 0x822f7240
	if ctx.cr[6].eq {
	pc = 0x822F7240; continue 'dispatch;
	}
	// 822F7230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F7234: 4BFFFB9D  bl 0x822f6dd0
	ctx.lr = 0x822F7238;
	sub_822F6DD0(ctx, base);
	// 822F7238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F723C: 48AFB19D  bl 0x82df23d8
	ctx.lr = 0x822F7240;
	sub_82DF23D8(ctx, base);
	// 822F7240: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822F7244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F7248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F724C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822F7250: 816B4AF4  lwz r11, 0x4af4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19188 as u32) ) } as u64;
	// 822F7254: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822F7258: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822F725C: 4BFC8DA5  bl 0x822c0000
	ctx.lr = 0x822F7260;
	sub_822C0000(ctx, base);
	// 822F7260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F7264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F7268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F726C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F7270: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F7274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F7278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F7280 size=64
    let mut pc: u32 = 0x822F7280;
    'dispatch: loop {
        match pc {
            0x822F7280 => {
    //   block [0x822F7280..0x822F72C0)
	// 822F7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F7288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F728C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7290: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F7294: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F7298: 419A0014  beq cr6, 0x822f72ac
	if ctx.cr[6].eq {
	pc = 0x822F72AC; continue 'dispatch;
	}
	// 822F729C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F72A0: 4BFFFB31  bl 0x822f6dd0
	ctx.lr = 0x822F72A4;
	sub_822F6DD0(ctx, base);
	// 822F72A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F72A8: 48AFB131  bl 0x82df23d8
	ctx.lr = 0x822F72AC;
	sub_82DF23D8(ctx, base);
	// 822F72AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F72B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F72B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F72B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F72BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F72C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F72C0 size=1248
    let mut pc: u32 = 0x822F72C0;
    'dispatch: loop {
        match pc {
            0x822F72C0 => {
    //   block [0x822F72C0..0x822F77A0)
	// 822F72C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F72C4: 48EB0E91  bl 0x831a8154
	ctx.lr = 0x822F72C8;
	sub_831A8130(ctx, base);
	// 822F72C8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822F72CC: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 822F72D0: 48EB3945  bl 0x831aac14
	ctx.lr = 0x822F72D4;
	sub_831AA9A0(ctx, base);
	// 822F72D4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F72D8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822F72DC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F72E0: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 822F72E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F72E8: 388AC644  addi r4, r10, -0x39bc
	ctx.r[4].s64 = ctx.r[10].s64 + -14780;
	// 822F72EC: 817A00A8  lwz r11, 0xa8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F72F0: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F72F4: 48CB5A1D  bl 0x82facd10
	ctx.lr = 0x822F72F8;
	sub_82FACD10(ctx, base);
	// 822F72F8: 817A00A8  lwz r11, 0xa8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F72FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F7300: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7304: 388AC634  addi r4, r10, -0x39cc
	ctx.r[4].s64 = ctx.r[10].s64 + -14796;
	// 822F7308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F730C: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F7310: 48CB5A01  bl 0x82facd10
	ctx.lr = 0x822F7314;
	sub_82FACD10(ctx, base);
	// 822F7314: 817A00A8  lwz r11, 0xa8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7318: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F731C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7320: 388AC61C  addi r4, r10, -0x39e4
	ctx.r[4].s64 = ctx.r[10].s64 + -14820;
	// 822F7324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F7328: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F732C: 48CB59E5  bl 0x82facd10
	ctx.lr = 0x822F7330;
	sub_82FACD10(ctx, base);
	// 822F7330: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 822F7334: 815A00A8  lwz r10, 0xa8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7338: 7FE90734  extsh r9, r31
	ctx.r[9].s64 = ctx.r[31].s16 as i64;
	// 822F733C: 7FC80734  extsh r8, r30
	ctx.r[8].s64 = ctx.r[30].s16 as i64;
	// 822F7340: 917A009C  stw r11, 0x9c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 822F7344: 913A0090  stw r9, 0x90(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 822F7348: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F734C: 911A0098  stw r8, 0x98(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(152 as u32), ctx.r[8].u32 ) };
	// 822F7350: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7354: 388BC60C  addi r4, r11, -0x39f4
	ctx.r[4].s64 = ctx.r[11].s64 + -14836;
	// 822F7358: 806A002C  lwz r3, 0x2c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F735C: 48CB59B5  bl 0x82facd10
	ctx.lr = 0x822F7360;
	sub_82FACD10(ctx, base);
	// 822F7360: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 822F7364: 917A0094  stw r11, 0x94(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 822F7368: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F736C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822F7370: 3BEBC604  addi r31, r11, -0x39fc
	ctx.r[31].s64 = ctx.r[11].s64 + -14844;
	// 822F7374: 488B5495  bl 0x82bac808
	ctx.lr = 0x822F7378;
	sub_82BAC808(ctx, base);
	// 822F7378: 484F2EF1  bl 0x827ea268
	ctx.lr = 0x822F737C;
	sub_827EA268(ctx, base);
	// 822F737C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F7380: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7384: 48CB598D  bl 0x82facd10
	ctx.lr = 0x822F7388;
	sub_82FACD10(ctx, base);
	// 822F7388: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F738C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 822F7390: 7C690734  extsh r9, r3
	ctx.r[9].s64 = ctx.r[3].s16 as i64;
	// 822F7394: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822F7398: 913A00A0  stw r9, 0xa0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 822F739C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F73A0: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F73A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F73A8: 41820020  beq 0x822f73c8
	if ctx.cr[0].eq {
	pc = 0x822F73C8; continue 'dispatch;
	}
	// 822F73AC: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F73B0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 822F73B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F73B8: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 822F73BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F73C0: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822F73C4: 48000008  b 0x822f73cc
	pc = 0x822F73CC; continue 'dispatch;
	// 822F73C8: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 822F73CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F73D0: 409A001C  bne cr6, 0x822f73ec
	if !ctx.cr[6].eq {
	pc = 0x822F73EC; continue 'dispatch;
	}
	// 822F73D4: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 822F73D8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 822F73DC: 48BA9285  bl 0x82ea0660
	ctx.lr = 0x822F73E0;
	sub_82EA0660(ctx, base);
	// 822F73E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F73E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F73E8: 419A0144  beq cr6, 0x822f752c
	if ctx.cr[6].eq {
	pc = 0x822F752C; continue 'dispatch;
	}
	// 822F73EC: 815A00A8  lwz r10, 0xa8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F73F0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 822F73F4: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 822F73F8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 822F73FC: 3B9F001C  addi r28, r31, 0x1c
	ctx.r[28].s64 = ctx.r[31].s64 + 28;
	// 822F7400: 3B3F002C  addi r25, r31, 0x2c
	ctx.r[25].s64 = ctx.r[31].s64 + 44;
	// 822F7404: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F7408: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F740C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822F7410: 931F0004  stw r24, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 822F7414: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 822F7418: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 822F741C: 931F0010  stw r24, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[24].u32 ) };
	// 822F7420: 931F0014  stw r24, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[24].u32 ) };
	// 822F7424: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 822F7428: 931F001C  stw r24, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[24].u32 ) };
	// 822F742C: 931F0020  stw r24, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 822F7430: 9B1F0028  stb r24, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[24].u8 ) };
	// 822F7434: 9B1F0029  stb r24, 0x29(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(41 as u32), ctx.r[24].u8 ) };
	// 822F7438: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 822F743C: 931F002C  stw r24, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[24].u32 ) };
	// 822F7440: 931F0030  stw r24, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[24].u32 ) };
	// 822F7444: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7448: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F744C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F7450: 83CA0010  lwz r30, 0x10(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F7454: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F7458: 40980024  bge cr6, 0x822f747c
	if !ctx.cr[6].lt {
	pc = 0x822F747C; continue 'dispatch;
	}
	// 822F745C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F7460: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7464: 41980008  blt cr6, 0x822f746c
	if ctx.cr[6].lt {
	pc = 0x822F746C; continue 'dispatch;
	}
	// 822F7468: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F746C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822F7470: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F7474: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F7478: 48BAF381  bl 0x82ea67f8
	ctx.lr = 0x822F747C;
	sub_82EA67F8(ctx, base);
	// 822F747C: 93DB0004  stw r30, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F7480: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F7484: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F7488: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F748C: 40980024  bge cr6, 0x822f74b0
	if !ctx.cr[6].lt {
	pc = 0x822F74B0; continue 'dispatch;
	}
	// 822F7490: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F7494: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7498: 41980008  blt cr6, 0x822f74a0
	if ctx.cr[6].lt {
	pc = 0x822F74A0; continue 'dispatch;
	}
	// 822F749C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F74A0: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822F74A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F74A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F74AC: 48BAF34D  bl 0x82ea67f8
	ctx.lr = 0x822F74B0;
	sub_82EA67F8(ctx, base);
	// 822F74B0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F74B4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F74B8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F74BC: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F74C0: 40980024  bge cr6, 0x822f74e4
	if !ctx.cr[6].lt {
	pc = 0x822F74E4; continue 'dispatch;
	}
	// 822F74C4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F74C8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F74CC: 41980008  blt cr6, 0x822f74d4
	if ctx.cr[6].lt {
	pc = 0x822F74D4; continue 'dispatch;
	}
	// 822F74D0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F74D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822F74D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F74DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F74E0: 48BAF319  bl 0x82ea67f8
	ctx.lr = 0x822F74E4;
	sub_82EA67F8(ctx, base);
	// 822F74E4: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F74E8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F74EC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F74F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F74F4: 83CA0020  lwz r30, 0x20(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F74F8: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 822F74FC: 40980024  bge cr6, 0x822f7520
	if !ctx.cr[6].lt {
	pc = 0x822F7520; continue 'dispatch;
	}
	// 822F7500: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F7504: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7508: 41980008  blt cr6, 0x822f7510
	if ctx.cr[6].lt {
	pc = 0x822F7510; continue 'dispatch;
	}
	// 822F750C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F7510: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822F7514: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F7518: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F751C: 48BAF2DD  bl 0x82ea67f8
	ctx.lr = 0x822F7520;
	sub_82EA67F8(ctx, base);
	// 822F7520: 93D90004  stw r30, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 822F7524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F7528: 48000008  b 0x822f7530
	pc = 0x822F7530; continue 'dispatch;
	// 822F752C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 822F7530: 387A00E4  addi r3, r26, 0xe4
	ctx.r[3].s64 = ctx.r[26].s64 + 228;
	// 822F7534: 4BFFFC1D  bl 0x822f7150
	ctx.lr = 0x822F7538;
	sub_822F7150(ctx, base);
	// 822F7538: 807A00E4  lwz r3, 0xe4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(228 as u32) ) } as u64;
	// 822F753C: 48CB6F6D  bl 0x82fae4a8
	ctx.lr = 0x822F7540;
	sub_82FAE4A8(ctx, base);
	// 822F7540: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822F7544: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 822F7548: 488B52C1  bl 0x82bac808
	ctx.lr = 0x822F754C;
	sub_82BAC808(ctx, base);
	// 822F754C: 488BE3F5  bl 0x82bb5940
	ctx.lr = 0x822F7550;
	sub_82BB5940(ctx, base);
	// 822F7550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F7554: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 822F7558: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 822F755C: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 822F7560: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F7564: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F7568: 3B2BFFE0  addi r25, r11, -0x20
	ctx.r[25].s64 = ctx.r[11].s64 + -32;
	// 822F756C: 418200FC  beq 0x822f7668
	if ctx.cr[0].eq {
	pc = 0x822F7668; continue 'dispatch;
	}
	// 822F7570: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822F7574: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 822F7578: 3BDA00EC  addi r30, r26, 0xec
	ctx.r[30].s64 = ctx.r[26].s64 + 236;
	// 822F757C: 3BFA0104  addi r31, r26, 0x104
	ctx.r[31].s64 = ctx.r[26].s64 + 260;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F77A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F77A0 size=120
    let mut pc: u32 = 0x822F77A0;
    'dispatch: loop {
        match pc {
            0x822F77A0 => {
    //   block [0x822F77A0..0x822F7818)
	// 822F77A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F77A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F77A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F77AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F77B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F77B4: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 822F77B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F77BC: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 822F77C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822F77C4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F77C8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822F77CC: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 822F77D0: 4080FFF0  bge 0x822f77c0
	if !ctx.cr[0].lt {
	pc = 0x822F77C0; continue 'dispatch;
	}
	// 822F77D4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 822F77D8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 822F77DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 822F77E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F77E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F77E8: 4BFED671  bl 0x822e4e58
	ctx.lr = 0x822F77EC;
	sub_822E4E58(ctx, base);
	// 822F77EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F77F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F77F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F77F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F77FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F7800: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F7804: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F7808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F780C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F7810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F7814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F7818 size=124
    let mut pc: u32 = 0x822F7818;
    'dispatch: loop {
        match pc {
            0x822F7818 => {
    //   block [0x822F7818..0x822F7894)
	// 822F7818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F781C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F7820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F7824: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F782C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 822F7830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F7834: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 822F7838: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822F783C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F7840: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822F7844: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 822F7848: 4080FFF0  bge 0x822f7838
	if !ctx.cr[0].lt {
	pc = 0x822F7838; continue 'dispatch;
	}
	// 822F784C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 822F7850: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822F7854: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 822F7858: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822F785C: 90C10060  stw r6, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u32 ) };
	// 822F7860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F7864: 4BFED5F5  bl 0x822e4e58
	ctx.lr = 0x822F7868;
	sub_822E4E58(ctx, base);
	// 822F7868: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F786C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F7870: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7874: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F7878: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F787C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F7880: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F7884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F7888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F788C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F7890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F7898 size=672
    let mut pc: u32 = 0x822F7898;
    'dispatch: loop {
        match pc {
            0x822F7898 => {
    //   block [0x822F7898..0x822F7B38)
	// 822F7898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F789C: 48EB08CD  bl 0x831a8168
	ctx.lr = 0x822F78A0;
	sub_831A8130(ctx, base);
	// 822F78A0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 822F78A4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 822F78A8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F78AC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F78B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F78B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F78B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F78BC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 822F78C0: 390BC5FC  addi r8, r11, -0x3a04
	ctx.r[8].s64 = ctx.r[11].s64 + -14852;
	// 822F78C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F78C8: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 822F78CC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 822F78D0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822F78D4: C3CA964C  lfs f30, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822F78D8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822F78DC: D3DF0054  stfs f30, 0x54(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822F78E0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 822F78E4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822F78E8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 822F78EC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 822F78F0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822F78F4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 822F78F8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 822F78FC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 822F7900: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 822F7904: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822F7908: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822F790C: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 822F7910: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 822F7914: 915F0094  stw r10, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 822F7918: C0089534  lfs f0, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F791C: 915F0098  stw r10, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 822F7920: C3A708A8  lfs f29, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822F7924: 915F009C  stw r10, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 822F7928: C3E608A4  lfs f31, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F792C: 915F00A0  stw r10, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 822F7930: 3BBF00AC  addi r29, r31, 0xac
	ctx.r[29].s64 = ctx.r[31].s64 + 172;
	// 822F7934: 9BDF00A4  stb r30, 0xa4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u8 ) };
	// 822F7938: 993F00A5  stb r9, 0xa5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(165 as u32), ctx.r[9].u8 ) };
	// 822F793C: 993F00A6  stb r9, 0xa6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(166 as u32), ctx.r[9].u8 ) };
	// 822F7940: 993F00A7  stb r9, 0xa7(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(167 as u32), ctx.r[9].u8 ) };
	// 822F7944: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 822F7948: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 822F794C: 93DF00B0  stw r30, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 822F7950: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822F7954: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 822F7958: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 822F795C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 822F7960: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 822F7964: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 822F7968: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 822F796C: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 822F7970: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 822F7974: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 822F7978: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 822F797C: 93DF00E0  stw r30, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u32 ) };
	// 822F7980: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 822F7984: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 822F7988: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 822F798C: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 822F7990: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 822F7994: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 822F7998: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 822F799C: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 822F79A0: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 822F79A4: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 822F79A8: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 822F79AC: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 822F79B0: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 822F79B4: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 822F79B8: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 822F79BC: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 822F79C0: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 822F79C4: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 822F79C8: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 822F79CC: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 822F79D0: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 822F79D4: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 822F79D8: D3BF0144  stfs f29, 0x144(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 822F79DC: D3FF0148  stfs f31, 0x148(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 822F79E0: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 822F79E4: D3FF014C  stfs f31, 0x14c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 822F79E8: 9BDF0140  stb r30, 0x140(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u8 ) };
	// 822F79EC: D3FF015C  stfs f31, 0x15c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 822F79F0: 9BDF0150  stb r30, 0x150(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u8 ) };
	// 822F79F4: D3FF0160  stfs f31, 0x160(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 822F79F8: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 822F79FC: 9BDF0158  stb r30, 0x158(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u8 ) };
	// 822F7A00: 909F0164  stw r4, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[4].u32 ) };
	// 822F7A04: 488B62F5  bl 0x82badcf8
	ctx.lr = 0x822F7A08;
	sub_82BADCF8(ctx, base);
	// 822F7A08: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7A0C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 822F7A10: 939F00A8  stw r28, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 822F7A14: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F7A18: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F7A1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F7A20: 4182001C  beq 0x822f7a3c
	if ctx.cr[0].eq {
	pc = 0x822F7A3C; continue 'dispatch;
	}
	// 822F7A24: 8143006C  lwz r10, 0x6c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F7A28: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 822F7A2C: 9143006C  stw r10, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 822F7A30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7A34: 91430068  stw r10, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 822F7A38: 48000008  b 0x822f7a40
	pc = 0x822F7A40; continue 'dispatch;
	// 822F7A3C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F7A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F7A44: 419A000C  beq cr6, 0x822f7a50
	if ctx.cr[6].eq {
	pc = 0x822F7A50; continue 'dispatch;
	}
	// 822F7A48: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F7A4C: 48000010  b 0x822f7a5c
	pc = 0x822F7A5C; continue 'dispatch;
	// 822F7A50: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 822F7A54: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 822F7A58: 48BA8C09  bl 0x82ea0660
	ctx.lr = 0x822F7A5C;
	sub_82EA0660(ctx, base);
	// 822F7A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F7A60: 419A0014  beq cr6, 0x822f7a74
	if ctx.cr[6].eq {
	pc = 0x822F7A74; continue 'dispatch;
	}
	// 822F7A64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822F7A68: 48BD2429  bl 0x82ec9e90
	ctx.lr = 0x822F7A6C;
	sub_82EC9E90(ctx, base);
	// 822F7A6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F7A70: 48000008  b 0x822f7a78
	pc = 0x822F7A78; continue 'dispatch;
	// 822F7A74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F7A78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F7A7C: 4BFFF665  bl 0x822f70e0
	ctx.lr = 0x822F7A80;
	sub_822F70E0(ctx, base);
	// 822F7A80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F7A84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F7A88: D3FF0028  stfs f31, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 822F7A8C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822F7A90: D3BF002C  stfs f29, 0x2c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 822F7A94: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822F7A98: D3DF0040  stfs f30, 0x40(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 822F7A9C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 822F7AA0: D3DF0050  stfs f30, 0x50(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 822F7AA4: C1ABC668  lfs f13, -0x3998(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14744 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F7AA8: 3CC08203  lis r6, -0x7dfd
	ctx.r[6].s64 = -2113732608;
	// 822F7AAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F7AB0: C18AC664  lfs f12, -0x399c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 822F7AB4: C169C660  lfs f11, -0x39a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14752 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 822F7AB8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822F7ABC: C148C65C  lfs f10, -0x39a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-14756 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 822F7AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F7AC4: C127C658  lfs f9, -0x39a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14760 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 822F7AC8: C0067BC8  lfs f0, 0x7bc8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(31688 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F7ACC: C10BC654  lfs f8, -0x39ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14764 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 822F7AD0: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 822F7AD4: D19F0030  stfs f12, 0x30(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 822F7AD8: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 822F7ADC: D15F0038  stfs f10, 0x38(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 822F7AE0: D13F003C  stfs f9, 0x3c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 822F7AE4: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 822F7AE8: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 822F7AEC: D11F004C  stfs f8, 0x4c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 822F7AF0: 808A6750  lwz r4, 0x6750(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26448 as u32) ) } as u64;
	// 822F7AF4: 4BFED43D  bl 0x822e4f30
	ctx.lr = 0x822F7AF8;
	sub_822E4F30(ctx, base);
	// 822F7AF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F7AFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F7B00: 4BFED3C1  bl 0x822e4ec0
	ctx.lr = 0x822F7B04;
	sub_822E4EC0(ctx, base);
	// 822F7B04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822F7B08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F7B0C: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 822F7B10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7B14: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822F7B18: 48194771  bl 0x8248c288
	ctx.lr = 0x822F7B1C;
	sub_8248C288(ctx, base);
	// 822F7B1C: 907F0154  stw r3, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[3].u32 ) };
	// 822F7B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F7B24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F7B28: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822F7B2C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822F7B30: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F7B34: 48EB0684  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F7B38 size=160
    let mut pc: u32 = 0x822F7B38;
    'dispatch: loop {
        match pc {
            0x822F7B38 => {
    //   block [0x822F7B38..0x822F7BD8)
	// 822F7B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7B3C: 48EB0615  bl 0x831a8150
	ctx.lr = 0x822F7B40;
	sub_831A8130(ctx, base);
	// 822F7B40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7B44: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822F7B48: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822F7B4C: 3AEB1800  addi r23, r11, 0x1800
	ctx.r[23].s64 = ctx.r[11].s64 + 6144;
	// 822F7B50: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 822F7B54: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 822F7B58: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 822F7B5C: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 822F7B60: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822F7B64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F7B68: 571D063E  clrlwi r29, r24, 0x18
	ctx.r[29].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 822F7B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F7B70: 80DC67C8  lwz r6, 0x67c8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26568 as u32) ) } as u64;
	// 822F7B74: 80BB6750  lwz r5, 0x6750(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26448 as u32) ) } as u64;
	// 822F7B78: 809A67D4  lwz r4, 0x67d4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26580 as u32) ) } as u64;
	// 822F7B7C: 4BFFFC9D  bl 0x822f7818
	ctx.lr = 0x822F7B80;
	sub_822F7818(ctx, base);
	// 822F7B80: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 822F7B84: 80BC67C8  lwz r5, 0x67c8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26568 as u32) ) } as u64;
	// 822F7B88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F7B8C: 80996774  lwz r4, 0x6774(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26484 as u32) ) } as u64;
	// 822F7B90: 4BFFFC11  bl 0x822f77a0
	ctx.lr = 0x822F7B94;
	sub_822F77A0(ctx, base);
	// 822F7B94: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822F7B98: 57E6063E  clrlwi r6, r31, 0x18
	ctx.r[6].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 822F7B9C: E8960000  ld r4, 0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	// 822F7BA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822F7BA4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822F7BA8: 481946E1  bl 0x8248c288
	ctx.lr = 0x822F7BAC;
	sub_8248C288(ctx, base);
	// 822F7BAC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822F7BB0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 822F7BB4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822F7BB8: 2F1F001E  cmpwi cr6, r31, 0x1e
	ctx.cr[6].compare_i32(ctx.r[31].s32, 30, &mut ctx.xer);
	// 822F7BBC: 4198FFB0  blt cr6, 0x822f7b6c
	if ctx.cr[6].lt {
	pc = 0x822F7B6C; continue 'dispatch;
	}
	// 822F7BC0: 39770E10  addi r11, r23, 0xe10
	ctx.r[11].s64 = ctx.r[23].s64 + 3600;
	// 822F7BC4: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 822F7BC8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7BCC: 4198FF98  blt cr6, 0x822f7b64
	if ctx.cr[6].lt {
	pc = 0x822F7B64; continue 'dispatch;
	}
	// 822F7BD0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822F7BD4: 48EB05CC  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F7BD8 size=804
    let mut pc: u32 = 0x822F7BD8;
    'dispatch: loop {
        match pc {
            0x822F7BD8 => {
    //   block [0x822F7BD8..0x822F7EFC)
	// 822F7BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7BDC: 48EB057D  bl 0x831a8158
	ctx.lr = 0x822F7BE0;
	sub_831A8130(ctx, base);
	// 822F7BE0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F7BE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F7BE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F7BEC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 822F7BF0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 822F7BF4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 822F7BF8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F7BFC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 822F7C00: D01E0160  stfs f0, 0x160(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 822F7C04: 937E00E0  stw r27, 0xe0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), ctx.r[27].u32 ) };
	// 822F7C08: 90FE00B4  stw r7, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 822F7C0C: 9B5E00A6  stb r26, 0xa6(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(166 as u32), ctx.r[26].u8 ) };
	// 822F7C10: 9B5E00A7  stb r26, 0xa7(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(167 as u32), ctx.r[26].u8 ) };
	// 822F7C14: 419A0010  beq cr6, 0x822f7c24
	if ctx.cr[6].eq {
	pc = 0x822F7C24; continue 'dispatch;
	}
	// 822F7C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F7C1C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F7C20: 4800000C  b 0x822f7c2c
	pc = 0x822F7C2C; continue 'dispatch;
	// 822F7C24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F7C28: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F7C2C: D01E00B8  stfs f0, 0xb8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 822F7C30: 833B0000  lwz r25, 0(r27)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7C34: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822F7C38: 419A000C  beq cr6, 0x822f7c44
	if ctx.cr[6].eq {
	pc = 0x822F7C44; continue 'dispatch;
	}
	// 822F7C3C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F7C40: 48BD6BC1  bl 0x82ece800
	ctx.lr = 0x822F7C44;
	sub_82ECE800(ctx, base);
	// 822F7C44: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822F7C48: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7C4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F7C50: 807E00A8  lwz r3, 0xa8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7C54: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 822F7C58: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7C5C: 48BD035D  bl 0x82ec7fb8
	ctx.lr = 0x822F7C60;
	sub_82EC7FB8(ctx, base);
	// 822F7C60: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 822F7C64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F7C68: 419A0278  beq cr6, 0x822f7ee0
	if ctx.cr[6].eq {
	pc = 0x822F7EE0; continue 'dispatch;
	}
	// 822F7C6C: 817E00A8  lwz r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7C70: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 822F7C74: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F7C78: 914100AC  stw r10, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 822F7C7C: 914100C4  stw r10, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 822F7C80: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 822F7C84: 914100D4  stw r10, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 822F7C88: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 822F7C8C: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 822F7C90: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 822F7C94: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 822F7C98: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 822F7C9C: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 822F7CA0: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 822F7CA4: 9BE100C8  stb r31, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[31].u8 ) };
	// 822F7CA8: 9BE100C9  stb r31, 0xc9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(201 as u32), ctx.r[31].u8 ) };
	// 822F7CAC: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 822F7CB0: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 822F7CB4: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F7CB8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822F7CBC: 4099001C  ble cr6, 0x822f7cd8
	if !ctx.cr[6].gt {
	pc = 0x822F7CD8; continue 'dispatch;
	}
	// 822F7CC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F7CC4: 41980008  blt cr6, 0x822f7ccc
	if ctx.cr[6].lt {
	pc = 0x822F7CCC; continue 'dispatch;
	}
	// 822F7CC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F7CCC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822F7CD0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822F7CD4: 48BAEB25  bl 0x82ea67f8
	ctx.lr = 0x822F7CD8;
	sub_82EA67F8(ctx, base);
	// 822F7CD8: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 822F7CDC: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 822F7CE0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F7CE4: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F7CE8: 40980020  bge cr6, 0x822f7d08
	if !ctx.cr[6].lt {
	pc = 0x822F7D08; continue 'dispatch;
	}
	// 822F7CEC: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 822F7CF0: 7F1D2000  cmpw cr6, r29, r4
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[4].s32, &mut ctx.xer);
	// 822F7CF4: 41980008  blt cr6, 0x822f7cfc
	if ctx.cr[6].lt {
	pc = 0x822F7CFC; continue 'dispatch;
	}
	// 822F7CF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F7CFC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822F7D00: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 822F7D04: 48BAEAF5  bl 0x82ea67f8
	ctx.lr = 0x822F7D08;
	sub_82EA67F8(ctx, base);
	// 822F7D08: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F7D0C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 822F7D10: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F7D14: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 822F7D18: 40980024  bge cr6, 0x822f7d3c
	if !ctx.cr[6].lt {
	pc = 0x822F7D3C; continue 'dispatch;
	}
	// 822F7D1C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F7D20: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7D24: 41980008  blt cr6, 0x822f7d2c
	if ctx.cr[6].lt {
	pc = 0x822F7D2C; continue 'dispatch;
	}
	// 822F7D28: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822F7D2C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822F7D30: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F7D34: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 822F7D38: 48BAEAC1  bl 0x82ea67f8
	ctx.lr = 0x822F7D3C;
	sub_82EA67F8(ctx, base);
	// 822F7D3C: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 822F7D40: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 822F7D44: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 822F7D48: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 822F7D4C: 83EA0020  lwz r31, 0x20(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F7D50: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 822F7D54: 40980024  bge cr6, 0x822f7d78
	if !ctx.cr[6].lt {
	pc = 0x822F7D78; continue 'dispatch;
	}
	// 822F7D58: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F7D5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F7D60: 41980008  blt cr6, 0x822f7d68
	if ctx.cr[6].lt {
	pc = 0x822F7D68; continue 'dispatch;
	}
	// 822F7D64: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822F7D68: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 822F7D6C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F7D70: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 822F7D74: 48BAEA85  bl 0x82ea67f8
	ctx.lr = 0x822F7D78;
	sub_82EA67F8(ctx, base);
	// 822F7D78: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 822F7D7C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822F7D80: 48CB6729  bl 0x82fae4a8
	ctx.lr = 0x822F7D84;
	sub_82FAE4A8(ctx, base);
	// 822F7D84: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822F7D88: 48CB7439  bl 0x82faf1c0
	ctx.lr = 0x822F7D8C;
	sub_82FAF1C0(ctx, base);
	// 822F7D8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F7D90: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 822F7D94: 807E00A8  lwz r3, 0xa8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7D98: 38AA7080  addi r5, r10, 0x7080
	ctx.r[5].s64 = ctx.r[10].s64 + 28800;
	// 822F7D9C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7DA0: 48BD0FA9  bl 0x82ec8d48
	ctx.lr = 0x822F7DA4;
	sub_82EC8D48(ctx, base);
	// 822F7DA4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822F7DA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822F7DAC: 48CB734D  bl 0x82faf0f8
	ctx.lr = 0x822F7DB0;
	sub_82FAF0F8(ctx, base);
	// 822F7DB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822F7DB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F7DB8: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 822F7DBC: 4BFED175  bl 0x822e4f30
	ctx.lr = 0x822F7DC0;
	sub_822E4F30(ctx, base);
	// 822F7DC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F7DC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822F7DC8: 4BFED0F9  bl 0x822e4ec0
	ctx.lr = 0x822F7DCC;
	sub_822E4EC0(ctx, base);
	// 822F7DCC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822F7DD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F7DD4: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 822F7DD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F7DDC: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 822F7DE0: 481944A9  bl 0x8248c288
	ctx.lr = 0x822F7DE4;
	sub_8248C288(ctx, base);
	// 822F7DE4: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7DE8: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 822F7DEC: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 822F7DF0: 388000D0  li r4, 0xd0
	ctx.r[4].s64 = 208;
	// 822F7DF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822F7DF8: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F7DFC: 48BA8935  bl 0x82ea0730
	ctx.lr = 0x822F7E00;
	sub_82EA0730(ctx, base);
	// 822F7E00: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 822F7E04: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F7E08: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822F7E0C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 822F7E10: 3B9E00C4  addi r28, r30, 0xc4
	ctx.r[28].s64 = ctx.r[30].s64 + 196;
	// 822F7E14: 48BE3695  bl 0x82edb4a8
	ctx.lr = 0x822F7E18;
	sub_82EDB4A8(ctx, base);
	// 822F7E18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F7E1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F7E20: 4BFFB8B9  bl 0x822f36d8
	ctx.lr = 0x822F7E24;
	sub_822F36D8(ctx, base);
	// 822F7E24: 809E00C4  lwz r4, 0xc4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F7E28: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7E2C: 48BD6C15  bl 0x82ecea40
	ctx.lr = 0x822F7E30;
	sub_82ECEA40(ctx, base);
	// 822F7E30: 38A00013  li r5, 0x13
	ctx.r[5].s64 = 19;
	// 822F7E34: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F7E38: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 822F7E3C: 48BA88F5  bl 0x82ea0730
	ctx.lr = 0x822F7E40;
	sub_82EA0730(ctx, base);
	// 822F7E40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F7E44: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 822F7E48: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822F7E4C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 822F7E50: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 822F7E54: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 822F7E58: 3949C540  addi r10, r9, -0x3ac0
	ctx.r[10].s64 = ctx.r[9].s64 + -15040;
	// 822F7E5C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F7E60: 3908C5D0  addi r8, r8, -0x3a30
	ctx.r[8].s64 = ctx.r[8].s64 + -14896;
	// 822F7E64: 38E7C5C4  addi r7, r7, -0x3a3c
	ctx.r[7].s64 = ctx.r[7].s64 + -14908;
	// 822F7E68: B34B0006  sth r26, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[26].u16 ) };
	// 822F7E6C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822F7E70: 387E00BC  addi r3, r30, 0xbc
	ctx.r[3].s64 = ctx.r[30].s64 + 188;
	// 822F7E74: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822F7E78: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822F7E7C: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 822F7E80: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 822F7E84: 4BFFEDAD  bl 0x822f6c30
	ctx.lr = 0x822F7E88;
	sub_822F6C30(ctx, base);
	// 822F7E88: 817E00A8  lwz r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 822F7E8C: 815E00BC  lwz r10, 0xbc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) } as u64;
	// 822F7E90: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 822F7E94: 813E00C4  lwz r9, 0xc4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 822F7E98: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 822F7E9C: 7C7DF82E  lwzx r3, r29, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F7EA0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F7EA4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 822F7EA8: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 822F7EAC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822F7EB0: 48BA8881  bl 0x82ea0730
	ctx.lr = 0x822F7EB4;
	sub_82EA0730(ctx, base);
	// 822F7EB4: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 822F7EB8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 822F7EBC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822F7EC0: 48BD18F9  bl 0x82ec97b8
	ctx.lr = 0x822F7EC4;
	sub_82EC97B8(ctx, base);
	// 822F7EC4: 397E00C8  addi r11, r30, 0xc8
	ctx.r[11].s64 = ctx.r[30].s64 + 200;
	// 822F7EC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F7ECC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F7ED0: 488B5E29  bl 0x82badcf8
	ctx.lr = 0x822F7ED4;
	sub_82BADCF8(ctx, base);
	// 822F7ED4: 93FE00C8  stw r31, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[31].u32 ) };
	// 822F7ED8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822F7EDC: 4BFFBCBD  bl 0x822f3b98
	ctx.lr = 0x822F7EE0;
	sub_822F3B98(ctx, base);
	// 822F7EE0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 822F7EE4: 419A000C  beq cr6, 0x822f7ef0
	if ctx.cr[6].eq {
	pc = 0x822F7EF0; continue 'dispatch;
	}
	// 822F7EE8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 822F7EEC: 48BD511D  bl 0x82ecd008
	ctx.lr = 0x822F7EF0;
	sub_82ECD008(ctx, base);
	// 822F7EF0: 931E0020  stw r24, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 822F7EF4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 822F7EF8: 48EB02B0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F7F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F7F00 size=1040
    let mut pc: u32 = 0x822F7F00;
    'dispatch: loop {
        match pc {
            0x822F7F00 => {
    //   block [0x822F7F00..0x822F8310)
	// 822F7F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F7F04: 48EB0251  bl 0x831a8154
	ctx.lr = 0x822F7F08;
	sub_831A8130(ctx, base);
	// 822F7F08: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822F7F0C: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8310 size=112
    let mut pc: u32 = 0x822F8310;
    'dispatch: loop {
        match pc {
            0x822F8310 => {
    //   block [0x822F8310..0x822F8380)
	// 822F8310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F831C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8324: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822F8328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F832C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F8330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8334: 388B4D08  addi r4, r11, 0x4d08
	ctx.r[4].s64 = ctx.r[11].s64 + 19720;
	// 822F8338: 48AFB6D1  bl 0x82df3a08
	ctx.lr = 0x822F833C;
	sub_82DF3A08(ctx, base);
	// 822F833C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F8340: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F8344: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F8348: 4BFF0DC1  bl 0x822e9108
	ctx.lr = 0x822F834C;
	sub_822E9108(ctx, base);
	// 822F834C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F8350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8354: 48B0A0E5  bl 0x82e02438
	ctx.lr = 0x822F8358;
	sub_82E02438(ctx, base);
	// 822F8358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F835C: 48AFB0CD  bl 0x82df3428
	ctx.lr = 0x822F8360;
	sub_82DF3428(ctx, base);
	// 822F8360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8364: 48AFB0C5  bl 0x82df3428
	ctx.lr = 0x822F8368;
	sub_82DF3428(ctx, base);
	// 822F8368: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F836C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8374: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F837C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8380 size=92
    let mut pc: u32 = 0x822F8380;
    'dispatch: loop {
        match pc {
            0x822F8380 => {
    //   block [0x822F8380..0x822F83DC)
	// 822F8380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F838C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8394: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F8398: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F839C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F83A0: 419A0024  beq cr6, 0x822f83c4
	if ctx.cr[6].eq {
	pc = 0x822F83C4; continue 'dispatch;
	}
	// 822F83A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F83A8: 48B06439  bl 0x82dfe7e0
	ctx.lr = 0x822F83AC;
	sub_82DFE7E0(ctx, base);
	// 822F83AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F83B0: 40820014  bne 0x822f83c4
	if !ctx.cr[0].eq {
	pc = 0x822F83C4; continue 'dispatch;
	}
	// 822F83B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F83B8: 481F13B9  bl 0x824e9770
	ctx.lr = 0x822F83BC;
	sub_824E9770(ctx, base);
	// 822F83BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F83C0: 4BFF60F9  bl 0x822ee4b8
	ctx.lr = 0x822F83C4;
	sub_822EE4B8(ctx, base);
	// 822F83C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F83C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F83CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F83D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F83D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F83D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F83E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F83E0 size=116
    let mut pc: u32 = 0x822F83E0;
    'dispatch: loop {
        match pc {
            0x822F83E0 => {
    //   block [0x822F83E0..0x822F8454)
	// 822F83E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F83E4: 48EAFD89  bl 0x831a816c
	ctx.lr = 0x822F83E8;
	sub_831A8130(ctx, base);
	// 822F83E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F83EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F83F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F83F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F83F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F83FC: 419A003C  beq cr6, 0x822f8438
	if ctx.cr[6].eq {
	pc = 0x822F8438; continue 'dispatch;
	}
	// 822F8400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8404: 48B063DD  bl 0x82dfe7e0
	ctx.lr = 0x822F8408;
	sub_82DFE7E0(ctx, base);
	// 822F8408: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F840C: 4082002C  bne 0x822f8438
	if !ctx.cr[0].eq {
	pc = 0x822F8438; continue 'dispatch;
	}
	// 822F8410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8414: 481F2675  bl 0x824eaa88
	ctx.lr = 0x822F8418;
	sub_824EAA88(ctx, base);
	// 822F8418: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F841C: 38C000BA  li r6, 0xba
	ctx.r[6].s64 = 186;
	// 822F8420: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8424: 38ABC6A8  addi r5, r11, -0x3958
	ctx.r[5].s64 = ctx.r[11].s64 + -14680;
	// 822F8428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F842C: 4BFFFF55  bl 0x822f8380
	ctx.lr = 0x822F8430;
	sub_822F8380(ctx, base);
	// 822F8430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8434: 48AF985D  bl 0x82df1c90
	ctx.lr = 0x822F8438;
	sub_82DF1C90(ctx, base);
	// 822F8438: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822F843C: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F8440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F8444: 4BFFFABD  bl 0x822f7f00
	ctx.lr = 0x822F8448;
	sub_822F7F00(ctx, base);
	// 822F8448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F844C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F8450: 48EAFD6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8458 size=76
    let mut pc: u32 = 0x822F8458;
    'dispatch: loop {
        match pc {
            0x822F8458 => {
    //   block [0x822F8458..0x822F84A4)
	// 822F8458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F845C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F846C: 48B0632D  bl 0x82dfe798
	ctx.lr = 0x822F8470;
	sub_82DFE798(ctx, base);
	// 822F8470: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F8474: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F8478: 394AC6F4  addi r10, r10, -0x390c
	ctx.r[10].s64 = ctx.r[10].s64 + -14604;
	// 822F847C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8480: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F8484: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822F8488: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 822F848C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 822F8490: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F8494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F849C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F84A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F84A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F84A8 size=96
    let mut pc: u32 = 0x822F84A8;
    'dispatch: loop {
        match pc {
            0x822F84A8 => {
    //   block [0x822F84A8..0x822F8508)
	// 822F84A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F84AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F84B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F84B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F84B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F84BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F84C0: 396BC6F4  addi r11, r11, -0x390c
	ctx.r[11].s64 = ctx.r[11].s64 + -14604;
	// 822F84C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F84C8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F84CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F84D0: 419A0008  beq cr6, 0x822f84d8
	if ctx.cr[6].eq {
	pc = 0x822F84D8; continue 'dispatch;
	}
	// 822F84D4: 4BFC83BD  bl 0x822c0890
	ctx.lr = 0x822F84D8;
	sub_822C0890(ctx, base);
	// 822F84D8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822F84DC: 488B581D  bl 0x82badcf8
	ctx.lr = 0x822F84E0;
	sub_82BADCF8(ctx, base);
	// 822F84E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F84E4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 822F84E8: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 822F84EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F84F0: 48AFAF39  bl 0x82df3428
	ctx.lr = 0x822F84F4;
	sub_82DF3428(ctx, base);
	// 822F84F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F84F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F84FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8508 size=76
    let mut pc: u32 = 0x822F8508;
    'dispatch: loop {
        match pc {
            0x822F8508 => {
    //   block [0x822F8508..0x822F8554)
	// 822F8508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F850C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F851C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F8524: 4BFFFF85  bl 0x822f84a8
	ctx.lr = 0x822F8528;
	sub_822F84A8(ctx, base);
	// 822F8528: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F852C: 4182000C  beq 0x822f8538
	if ctx.cr[0].eq {
	pc = 0x822F8538; continue 'dispatch;
	}
	// 822F8530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8534: 48AF9EA5  bl 0x82df23d8
	ctx.lr = 0x822F8538;
	sub_82DF23D8(ctx, base);
	// 822F8538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F853C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F8540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F854C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F8558 size=1132
    let mut pc: u32 = 0x822F8558;
    'dispatch: loop {
        match pc {
            0x822F8558 => {
    //   block [0x822F8558..0x822F89C4)
	// 822F8558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F855C: 48EAFBF9  bl 0x831a8154
	ctx.lr = 0x822F8560;
	sub_831A8130(ctx, base);
	// 822F8560: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 822F8564: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 822F8568: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F856C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8570: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822F8574: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F8578: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F857C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822F8580: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822F8584: 48000445  bl 0x822f89c8
	ctx.lr = 0x822F8588;
	sub_822F89C8(ctx, base);
	// 822F8588: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F858C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F8590: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 822F8594: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F8598: 480005B9  bl 0x822f8b50
	ctx.lr = 0x822F859C;
	sub_822F8B50(ctx, base);
	// 822F859C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F85A0: 48B062C9  bl 0x82dfe868
	ctx.lr = 0x822F85A4;
	sub_82DFE868(ctx, base);
	// 822F85A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F85A8: 408203F4  bne 0x822f899c
	if !ctx.cr[0].eq {
	pc = 0x822F899C; continue 'dispatch;
	}
	// 822F85AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822F85B0: 419A03EC  beq cr6, 0x822f899c
	if ctx.cr[6].eq {
	pc = 0x822F899C; continue 'dispatch;
	}
	// 822F85B4: 83ED0000  lwz r31, 0(r13)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F85B8: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 822F85BC: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 822F85C0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 822F85C4: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F85C8: 48BA8169  bl 0x82ea0730
	ctx.lr = 0x822F85CC;
	sub_82EA0730(ctx, base);
	// 822F85CC: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	// 822F85D0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 822F85D4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822F85D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822F85DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F85E0: 48BB0289  bl 0x82ea8868
	ctx.lr = 0x822F85E4;
	sub_82EA8868(ctx, base);
	// 822F85E4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 822F85E8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 822F85EC: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 822F85F0: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F85F4: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 822F85F8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 822F85FC: 4182002C  beq 0x822f8628
	if ctx.cr[0].eq {
	pc = 0x822F8628; continue 'dispatch;
	}
	// 822F8600: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 822F8604: 48BA812D  bl 0x82ea0730
	ctx.lr = 0x822F8608;
	sub_82EA0730(ctx, base);
	// 822F8608: 39600048  li r11, 0x48
	ctx.r[11].s64 = 72;
	// 822F860C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822F8610: 48BC2C51  bl 0x82ebb260
	ctx.lr = 0x822F8614;
	sub_82EBB260(ctx, base);
	// 822F8614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F8618: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F861C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F8620: 480ADE99  bl 0x823a64b8
	ctx.lr = 0x822F8624;
	sub_823A64B8(ctx, base);
	// 822F8624: 48000028  b 0x822f864c
	pc = 0x822F864C; continue 'dispatch;
	// 822F8628: 38800088  li r4, 0x88
	ctx.r[4].s64 = 136;
	// 822F862C: 48BA8105  bl 0x82ea0730
	ctx.lr = 0x822F8630;
	sub_82EA0730(ctx, base);
	// 822F8630: 39600088  li r11, 0x88
	ctx.r[11].s64 = 136;
	// 822F8634: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 822F8638: 48BBFCC9  bl 0x82eb8300
	ctx.lr = 0x822F863C;
	sub_82EB8300(ctx, base);
	// 822F863C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F8640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F8644: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F8648: 480ADE71  bl 0x823a64b8
	ctx.lr = 0x822F864C;
	sub_823A64B8(ctx, base);
	// 822F864C: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F8650: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 822F8654: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F8658: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F865C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F8660: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F8664: 4E800421  bctrl
	ctx.lr = 0x822F8668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F8668: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822F866C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F8670: 808B71DC  lwz r4, 0x71dc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29148 as u32) ) } as u64;
	// 822F8674: 48BBD48D  bl 0x82eb5b00
	ctx.lr = 0x822F8678;
	sub_82EB5B00(ctx, base);
	// 822F8678: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F867C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F8680: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F8684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F8688: 4E800421  bctrl
	ctx.lr = 0x822F868C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F868C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F8690: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F8694: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 822F8698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F869C: 488B565D  bl 0x82badcf8
	ctx.lr = 0x822F86A0;
	sub_82BADCF8(ctx, base);
	// 822F86A0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F86A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F86A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F86AC: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F86B0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F86B4: 41820010  beq 0x822f86c4
	if ctx.cr[0].eq {
	pc = 0x822F86C4; continue 'dispatch;
	}
	// 822F86B8: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 822F86BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F86C0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 822F86C4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822F86C8: 83FA0000  lwz r31, 0(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F86CC: 386B714C  addi r3, r11, 0x714c
	ctx.r[3].s64 = ctx.r[11].s64 + 29004;
	// 822F86D0: 48BAF539  bl 0x82ea7c08
	ctx.lr = 0x822F86D4;
	sub_82EA7C08(ctx, base);
	// 822F86D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F86D8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F86DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F86E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F86E4: 4E800421  bctrl
	ctx.lr = 0x822F86E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F86E8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 822F86EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822F86F0: 386B7A80  addi r3, r11, 0x7a80
	ctx.r[3].s64 = ctx.r[11].s64 + 31360;
	// 822F86F4: 48BAF515  bl 0x82ea7c08
	ctx.lr = 0x822F86F8;
	sub_82EA7C08(ctx, base);
	// 822F86F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F86FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F8700: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F8704: 48BBEBB5  bl 0x82eb72b8
	ctx.lr = 0x822F8708;
	sub_82EB72B8(ctx, base);
	// 822F8708: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F870C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8710: 388BC6A8  addi r4, r11, -0x3958
	ctx.r[4].s64 = ctx.r[11].s64 + -14680;
	// 822F8714: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F8718: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 822F871C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 822F8720: 48AF9CC9  bl 0x82df23e8
	ctx.lr = 0x822F8724;
	sub_82DF23E8(ctx, base);
	// 822F8724: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F8728: 41820018  beq 0x822f8740
	if ctx.cr[0].eq {
	pc = 0x822F8740; continue 'dispatch;
	}
	// 822F872C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F8730: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822F8734: 4BFFF165  bl 0x822f7898
	ctx.lr = 0x822F8738;
	sub_822F7898(ctx, base);
	// 822F8738: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F873C: 48000008  b 0x822f8744
	pc = 0x822F8744; continue 'dispatch;
	// 822F8740: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 822F8744: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 822F8748: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F874C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 822F8750: 4BFFEA71  bl 0x822f71c0
	ctx.lr = 0x822F8754;
	sub_822F71C0(ctx, base);
	// 822F8754: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822F8758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F875C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 822F8760: 4BFC78A1  bl 0x822c0000
	ctx.lr = 0x822F8764;
	sub_822C0000(ctx, base);
	// 822F8764: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F8768: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822F876C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822F8770: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F8774: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822F8778: 409900C4  ble cr6, 0x822f883c
	if !ctx.cr[6].gt {
	pc = 0x822F883C; continue 'dispatch;
	}
	// 822F877C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 822F8780: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F8784: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 822F8788: C3CBE830  lfs f30, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822F878C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F8790: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F8794: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F8798: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F879C: 4080000C  bge 0x822f87a8
	if !ctx.cr[0].lt {
	pc = 0x822F87A8; continue 'dispatch;
	}
	// 822F87A0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 822F87A4: 48000010  b 0x822f87b4
	pc = 0x822F87B4; continue 'dispatch;
	// 822F87A8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F87AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F87B0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F87B4: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F87B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F87BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F87C0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F87C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F87C8: 4E800421  bctrl
	ctx.lr = 0x822F87CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F87CC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 822F87D0: 419A001C  beq cr6, 0x822f87ec
	if ctx.cr[6].eq {
	pc = 0x822F87EC; continue 'dispatch;
	}
	// 822F87D4: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 822F87D8: 409A0018  bne cr6, 0x822f87f0
	if !ctx.cr[6].eq {
	pc = 0x822F87F0; continue 'dispatch;
	}
	// 822F87DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F87E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F87E4: 48BE30E5  bl 0x82edb8c8
	ctx.lr = 0x822F87E8;
	sub_82EDB8C8(ctx, base);
	// 822F87E8: 48000008  b 0x822f87f0
	pc = 0x822F87F0; continue 'dispatch;
	// 822F87EC: D3FE00BC  stfs f31, 0xbc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 822F87F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F87F4: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F87F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F87FC: 4098000C  bge cr6, 0x822f8808
	if !ctx.cr[6].lt {
	pc = 0x822F8808; continue 'dispatch;
	}
	// 822F8800: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 822F8804: 48000010  b 0x822f8814
	pc = 0x822F8814; continue 'dispatch;
	// 822F8808: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F880C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F8810: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F8814: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 822F8818: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 822F881C: 386B018D  addi r3, r11, 0x18d
	ctx.r[3].s64 = ctx.r[11].s64 + 397;
	// 822F8820: 48BAF231  bl 0x82ea7a50
	ctx.lr = 0x822F8824;
	sub_82EA7A50(ctx, base);
	// 822F8824: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F8828: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 822F882C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822F8830: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822F8834: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 822F8838: 4198FF58  blt cr6, 0x822f8790
	if ctx.cr[6].lt {
	pc = 0x822F8790; continue 'dispatch;
	}
	// 822F883C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F8840: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F8848: 4098000C  bge cr6, 0x822f8854
	if !ctx.cr[6].lt {
	pc = 0x822F8854; continue 'dispatch;
	}
	// 822F884C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 822F8850: 48000010  b 0x822f8860
	pc = 0x822F8860; continue 'dispatch;
	// 822F8854: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8858: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F885C: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F8860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F8864: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F8868: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F886C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F8870: 48C59B09  bl 0x82f52378
	ctx.lr = 0x822F8874;
	sub_82F52378(ctx, base);
	// 822F8874: 3D608339  lis r11, -0x7cc7
	ctx.r[11].s64 = -2093416448;
	// 822F8878: 3BABB5F4  addi r29, r11, -0x4a0c
	ctx.r[29].s64 = ctx.r[11].s64 + -18956;
	// 822F887C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F8880: 839F002C  lwz r28, 0x2c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F8884: 48BAF385  bl 0x82ea7c08
	ctx.lr = 0x822F8888;
	sub_82EA7C08(ctx, base);
	// 822F8888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F888C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F8890: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F8894: 48BBEA25  bl 0x82eb72b8
	ctx.lr = 0x822F8898;
	sub_82EB72B8(ctx, base);
	// 822F8898: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 822F889C: 48000034  b 0x822f88d0
	pc = 0x822F88D0; continue 'dispatch;
	// 822F88A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F88A4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 822F88A8: 409A000C  bne cr6, 0x822f88b4
	if !ctx.cr[6].eq {
	pc = 0x822F88B4; continue 'dispatch;
	}
	// 822F88AC: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 822F88B0: 48000008  b 0x822f88b8
	pc = 0x822F88B8; continue 'dispatch;
	// 822F88B4: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 822F88B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F88BC: 48BAF34D  bl 0x82ea7c08
	ctx.lr = 0x822F88C0;
	sub_82EA7C08(ctx, base);
	// 822F88C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F88C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822F88C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F88CC: 48BBE9ED  bl 0x82eb72b8
	ctx.lr = 0x822F88D0;
	sub_82EB72B8(ctx, base);
	// 822F88D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F88D4: 4082FFCC  bne 0x822f88a0
	if !ctx.cr[0].eq {
	pc = 0x822F88A0; continue 'dispatch;
	}
	// 822F88D8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F88DC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 822F88E0: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 822F88E4: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F88E8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F88EC: 48CB43CD  bl 0x82faccb8
	ctx.lr = 0x822F88F0;
	sub_82FACCB8(ctx, base);
	// 822F88F0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F88F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822F88F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822F88FC: 388AC604  addi r4, r10, -0x39fc
	ctx.r[4].s64 = ctx.r[10].s64 + -14844;
	// 822F8900: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8904: 48CB440D  bl 0x82facd10
	ctx.lr = 0x822F8908;
	sub_82FACD10(ctx, base);
	// 822F8908: 7C6B0735  extsh. r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F890C: 4180001C  blt 0x822f8928
	if ctx.cr[0].lt {
	pc = 0x822F8928; continue 'dispatch;
	}
	// 822F8910: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 822F8914: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F8918: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F891C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F8920: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F8924: 9B0B0004  stb r24, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u8 ) };
	// 822F8928: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F892C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822F8930: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 822F8934: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F8938: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F893C: 48CB437D  bl 0x82faccb8
	ctx.lr = 0x822F8940;
	sub_82FACCB8(ctx, base);
	// 822F8940: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 822F8944: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 822F8948: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F894C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822F8950: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8954: 9B0B0004  stb r24, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u8 ) };
	// 822F8958: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F895C: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 822F8960: 93CB0010  stw r30, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 822F8964: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 822F8968: 4BFCBAF9  bl 0x822c4460
	ctx.lr = 0x822F896C;
	sub_822C4460(ctx, base);
	// 822F896C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 822F8970: 48B05EE9  bl 0x82dfe858
	ctx.lr = 0x822F8974;
	sub_82DFE858(ctx, base);
	// 822F8974: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F8978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F897C: 419A0008  beq cr6, 0x822f8984
	if ctx.cr[6].eq {
	pc = 0x822F8984; continue 'dispatch;
	}
	// 822F8980: 4BFC7F11  bl 0x822c0890
	ctx.lr = 0x822F8984;
	sub_822C0890(ctx, base);
	// 822F8984: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822F8988: 4BFEF8E1  bl 0x822e8268
	ctx.lr = 0x822F898C;
	sub_822E8268(ctx, base);
	// 822F898C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 822F8990: 419A000C  beq cr6, 0x822f899c
	if ctx.cr[6].eq {
	pc = 0x822F899C; continue 'dispatch;
	}
	// 822F8994: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 822F8998: 4BFEF8D1  bl 0x822e8268
	ctx.lr = 0x822F899C;
	sub_822E8268(ctx, base);
	// 822F899C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F89A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F89A4: 419A0008  beq cr6, 0x822f89ac
	if ctx.cr[6].eq {
	pc = 0x822F89AC; continue 'dispatch;
	}
	// 822F89A8: 4BFC7EE9  bl 0x822c0890
	ctx.lr = 0x822F89AC;
	sub_822C0890(ctx, base);
	// 822F89AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822F89B0: 48000031  bl 0x822f89e0
	ctx.lr = 0x822F89B4;
	sub_822F89E0(ctx, base);
	// 822F89B4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822F89B8: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 822F89BC: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 822F89C0: 48EAF7E4  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F89C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F89C8 size=20
    let mut pc: u32 = 0x822F89C8;
    'dispatch: loop {
        match pc {
            0x822F89C8 => {
    //   block [0x822F89C8..0x822F89DC)
	// 822F89C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F89CC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 822F89D0: 396BC700  addi r11, r11, -0x3900
	ctx.r[11].s64 = ctx.r[11].s64 + -14592;
	// 822F89D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F89D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F89E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F89E0 size=16
    let mut pc: u32 = 0x822F89E0;
    'dispatch: loop {
        match pc {
            0x822F89E0 => {
    //   block [0x822F89E0..0x822F89F0)
	// 822F89E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F89E4: 396BC700  addi r11, r11, -0x3900
	ctx.r[11].s64 = ctx.r[11].s64 + -14592;
	// 822F89E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F89EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F89F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F89F0 size=68
    let mut pc: u32 = 0x822F89F0;
    'dispatch: loop {
        match pc {
            0x822F89F0 => {
    //   block [0x822F89F0..0x822F8A34)
	// 822F89F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F89F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F89F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F89FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8A00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8A04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F8A08: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F8A0C: 396BC700  addi r11, r11, -0x3900
	ctx.r[11].s64 = ctx.r[11].s64 + -14592;
	// 822F8A10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F8A14: 41820008  beq 0x822f8a1c
	if ctx.cr[0].eq {
	pc = 0x822F8A1C; continue 'dispatch;
	}
	// 822F8A18: 4BFC7851  bl 0x822c0268
	ctx.lr = 0x822F8A1C;
	sub_822C0268(ctx, base);
	// 822F8A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8A20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F8A24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8A28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8A38 size=112
    let mut pc: u32 = 0x822F8A38;
    'dispatch: loop {
        match pc {
            0x822F8A38 => {
    //   block [0x822F8A38..0x822F8AA8)
	// 822F8A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F8A50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F8A54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822F8A58: 388B9B98  addi r4, r11, -0x6468
	ctx.r[4].s64 = ctx.r[11].s64 + -25704;
	// 822F8A5C: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 822F8A60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 822F8A64: 48AF9985  bl 0x82df23e8
	ctx.lr = 0x822F8A68;
	sub_82DF23E8(ctx, base);
	// 822F8A68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F8A6C: 41820010  beq 0x822f8a7c
	if ctx.cr[0].eq {
	pc = 0x822F8A7C; continue 'dispatch;
	}
	// 822F8A70: 4BFFF9E9  bl 0x822f8458
	ctx.lr = 0x822F8A74;
	sub_822F8458(ctx, base);
	// 822F8A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8A78: 48000008  b 0x822f8a80
	pc = 0x822F8A80; continue 'dispatch;
	// 822F8A7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F8A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8A84: 889E0068  lbz r4, 0x68(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 822F8A88: 48B05DF1  bl 0x82dfe878
	ctx.lr = 0x822F8A8C;
	sub_82DFE878(ctx, base);
	// 822F8A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8A90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F8A94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8A98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8A9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8AA8 size=164
    let mut pc: u32 = 0x822F8AA8;
    'dispatch: loop {
        match pc {
            0x822F8AA8 => {
    //   block [0x822F8AA8..0x822F8B4C)
	// 822F8AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8AAC: 48EAF6C1  bl 0x831a816c
	ctx.lr = 0x822F8AB0;
	sub_831A8130(ctx, base);
	// 822F8AB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8AB4: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 822F8AB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8ABC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F8AC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F8AC4: 396B8A38  addi r11, r11, -0x75c8
	ctx.r[11].s64 = ctx.r[11].s64 + -30152;
	// 822F8AC8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822F8ACC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F8AD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822F8AD4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822F8AD8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822F8ADC: 48B05E1D  bl 0x82dfe8f8
	ctx.lr = 0x822F8AE0;
	sub_82DFE8F8(ctx, base);
	// 822F8AE0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822F8AE4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822F8AE8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822F8AEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F8AF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F8AF4: 48B08DA5  bl 0x82e01898
	ctx.lr = 0x822F8AF8;
	sub_82E01898(ctx, base);
	// 822F8AF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8AFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F8B00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8B04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F8B08: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F8B0C: 419A0024  beq cr6, 0x822f8b30
	if ctx.cr[6].eq {
	pc = 0x822F8B30; continue 'dispatch;
	}
	// 822F8B10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F8B14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F8B18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F8B1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F8B20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F8B24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F8B28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F8B2C: 4082FFE8  bne 0x822f8b14
	if !ctx.cr[0].eq {
	pc = 0x822F8B14; continue 'dispatch;
	}
	// 822F8B30: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F8B34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F8B38: 419A0008  beq cr6, 0x822f8b40
	if ctx.cr[6].eq {
	pc = 0x822F8B40; continue 'dispatch;
	}
	// 822F8B3C: 4BFC7D55  bl 0x822c0890
	ctx.lr = 0x822F8B40;
	sub_822C0890(ctx, base);
	// 822F8B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8B44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F8B48: 48EAF674  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8B50 size=108
    let mut pc: u32 = 0x822F8B50;
    'dispatch: loop {
        match pc {
            0x822F8B50 => {
    //   block [0x822F8B50..0x822F8BBC)
	// 822F8B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8B54: 48EAF615  bl 0x831a8168
	ctx.lr = 0x822F8B58;
	sub_831A8130(ctx, base);
	// 822F8B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8B5C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822F8B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8B64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F8B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8B6C: 388B4D08  addi r4, r11, 0x4d08
	ctx.r[4].s64 = ctx.r[11].s64 + 19720;
	// 822F8B70: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F8B74: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822F8B78: 48AFAE91  bl 0x82df3a08
	ctx.lr = 0x822F8B7C;
	sub_82DF3A08(ctx, base);
	// 822F8B7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822F8B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F8B84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F8B88: 4BFF0581  bl 0x822e9108
	ctx.lr = 0x822F8B8C;
	sub_822E9108(ctx, base);
	// 822F8B8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822F8B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8B94: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8B98: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822F8B9C: 4BFFFF0D  bl 0x822f8aa8
	ctx.lr = 0x822F8BA0;
	sub_822F8AA8(ctx, base);
	// 822F8BA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822F8BA4: 48AFA885  bl 0x82df3428
	ctx.lr = 0x822F8BA8;
	sub_82DF3428(ctx, base);
	// 822F8BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8BAC: 48AFA87D  bl 0x82df3428
	ctx.lr = 0x822F8BB0;
	sub_82DF3428(ctx, base);
	// 822F8BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8BB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F8BB8: 48EAF600  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8BC0 size=260
    let mut pc: u32 = 0x822F8BC0;
    'dispatch: loop {
        match pc {
            0x822F8BC0 => {
    //   block [0x822F8BC0..0x822F8CC4)
	// 822F8BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8BC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8BCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8BD0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8BD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F8BD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F8BDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8BE0: 388BC710  addi r4, r11, -0x38f0
	ctx.r[4].s64 = ctx.r[11].s64 + -14576;
	// 822F8BE4: 48AFAE25  bl 0x82df3a08
	ctx.lr = 0x822F8BE8;
	sub_82DF3A08(ctx, base);
	// 822F8BE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822F8BEC: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 822F8BF0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822F8BF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822F8BF8: 388B8310  addi r4, r11, -0x7cf0
	ctx.r[4].s64 = ctx.r[11].s64 + -31984;
	// 822F8BFC: 4BFD9525  bl 0x822d2120
	ctx.lr = 0x822F8C00;
	sub_822D2120(ctx, base);
	// 822F8C00: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 822F8C04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822F8C08: 9BE1005C  stb r31, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u8 ) };
	// 822F8C0C: 396B8558  addi r11, r11, -0x7aa8
	ctx.r[11].s64 = ctx.r[11].s64 + -31400;
	// 822F8C10: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 822F8C14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822F8C18: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822F8C1C: 4BFD95AD  bl 0x822d21c8
	ctx.lr = 0x822F8C20;
	sub_822D21C8(ctx, base);
	// 822F8C20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F8C24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822F8C28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 822F8C2C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 822F8C30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F8C34: 48B0A5D5  bl 0x82e03208
	ctx.lr = 0x822F8C38;
	sub_82E03208(ctx, base);
	// 822F8C38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8C3C: 48AFA7ED  bl 0x82df3428
	ctx.lr = 0x822F8C40;
	sub_82DF3428(ctx, base);
	// 822F8C40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822F8C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8C48: 388BC704  addi r4, r11, -0x38fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14588;
	// 822F8C4C: 48AFADBD  bl 0x82df3a08
	ctx.lr = 0x822F8C50;
	sub_82DF3A08(ctx, base);
	// 822F8C50: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 822F8C54: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 822F8C58: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822F8C5C: 388B8310  addi r4, r11, -0x7cf0
	ctx.r[4].s64 = ctx.r[11].s64 + -31984;
	// 822F8C60: 4BFD94C1  bl 0x822d2120
	ctx.lr = 0x822F8C64;
	sub_822D2120(ctx, base);
	// 822F8C64: 3D608230  lis r11, -0x7dd0
	ctx.r[11].s64 = -2110783488;
	// 822F8C68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F8C6C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 822F8C70: 396B8558  addi r11, r11, -0x7aa8
	ctx.r[11].s64 = ctx.r[11].s64 + -31400;
	// 822F8C74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822F8C78: 9941005C  stb r10, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 822F8C7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822F8C80: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 822F8C84: 4BFD9545  bl 0x822d21c8
	ctx.lr = 0x822F8C88;
	sub_822D21C8(ctx, base);
	// 822F8C88: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 822F8C8C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 822F8C90: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822F8C94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822F8C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F8C9C: 48B0A56D  bl 0x82e03208
	ctx.lr = 0x822F8CA0;
	sub_82E03208(ctx, base);
	// 822F8CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F8CA4: 48AFA785  bl 0x82df3428
	ctx.lr = 0x822F8CA8;
	sub_82DF3428(ctx, base);
	// 822F8CA8: 4BFFEE91  bl 0x822f7b38
	ctx.lr = 0x822F8CAC;
	sub_822F7B38(ctx, base);
	// 822F8CAC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822F8CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8CB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F8CC8 size=40
    let mut pc: u32 = 0x822F8CC8;
    'dispatch: loop {
        match pc {
            0x822F8CC8 => {
    //   block [0x822F8CC8..0x822F8CF0)
	// 822F8CC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F8CCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F8CD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 822F8CD4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F8CD8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822F8CDC: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F8CE0: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 822F8CE4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F8CE8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822F8CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F8CF0 size=32
    let mut pc: u32 = 0x822F8CF0;
    'dispatch: loop {
        match pc {
            0x822F8CF0 => {
    //   block [0x822F8CF0..0x822F8D10)
	// 822F8CF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F8CF4: D0230008  stfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F8CF8: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822F8CFC: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 822F8D00: 98E30010  stb r7, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 822F8D04: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F8D08: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822F8D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F8D10 size=28
    let mut pc: u32 = 0x822F8D10;
    'dispatch: loop {
        match pc {
            0x822F8D10 => {
    //   block [0x822F8D10..0x822F8D2C)
	// 822F8D10: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 822F8D14: D0430008  stfs f2, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 822F8D18: D023000C  stfs f1, 0xc(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822F8D1C: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822F8D20: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F8D24: 98E30010  stb r7, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 822F8D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8D30 size=76
    let mut pc: u32 = 0x822F8D30;
    'dispatch: loop {
        match pc {
            0x822F8D30 => {
    //   block [0x822F8D30..0x822F8D7C)
	// 822F8D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8D48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F8D4C: 48B67C25  bl 0x82e60970
	ctx.lr = 0x822F8D50;
	sub_82E60970(ctx, base);
	// 822F8D50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F8D54: 4182000C  beq 0x822f8d60
	if ctx.cr[0].eq {
	pc = 0x822F8D60; continue 'dispatch;
	}
	// 822F8D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8D5C: 4BFC750D  bl 0x822c0268
	ctx.lr = 0x822F8D60;
	sub_822C0268(ctx, base);
	// 822F8D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8D64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F8D68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8D6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8D70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8D74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8D78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F8D80 size=16
    let mut pc: u32 = 0x822F8D80;
    'dispatch: loop {
        match pc {
            0x822F8D80 => {
    //   block [0x822F8D80..0x822F8D90)
	// 822F8D80: C00300C8  lfs f0, 0xc8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F8D84: C1A300C4  lfs f13, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F8D88: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822F8D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8D90 size=40
    let mut pc: u32 = 0x822F8D90;
    'dispatch: loop {
        match pc {
            0x822F8D90 => {
    //   block [0x822F8D90..0x822F8DB8)
	// 822F8D90: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 822F8D94: 39430060  addi r10, r3, 0x60
	ctx.r[10].s64 = ctx.r[3].s64 + 96;
	// 822F8D98: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822F8D9C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822F8DA0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8DA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F8DA8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F8DAC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F8DB0: 4200FFF0  bdnz 0x822f8da0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F8DA0; continue 'dispatch;
	}
	// 822F8DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F8DB8 size=20
    let mut pc: u32 = 0x822F8DB8;
    'dispatch: loop {
        match pc {
            0x822F8DB8 => {
    //   block [0x822F8DB8..0x822F8DCC)
	// 822F8DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F8DBC: D023008C  stfs f1, 0x8c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 822F8DC0: 99630090  stb r11, 0x90(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 822F8DC4: 38630088  addi r3, r3, 0x88
	ctx.r[3].s64 = ctx.r[3].s64 + 136;
	// 822F8DC8: 48AFAE08  b 0x82df3bd0
	sub_82DF3BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8DD0 size=8
    let mut pc: u32 = 0x822F8DD0;
    'dispatch: loop {
        match pc {
            0x822F8DD0 => {
    //   block [0x822F8DD0..0x822F8DD8)
	// 822F8DD0: 38630088  addi r3, r3, 0x88
	ctx.r[3].s64 = ctx.r[3].s64 + 136;
	// 822F8DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F8DD8 size=108
    let mut pc: u32 = 0x822F8DD8;
    'dispatch: loop {
        match pc {
            0x822F8DD8 => {
    //   block [0x822F8DD8..0x822F8E44)
	// 822F8DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8DF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822F8DF4: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 822F8DF8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822F8DFC: D03F0098  stfs f1, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 822F8E00: 997F0091  stb r11, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 822F8E04: 48AFADCD  bl 0x82df3bd0
	ctx.lr = 0x822F8E08;
	sub_82DF3BD0(ctx, base);
	// 822F8E08: 395F009C  addi r10, r31, 0x9c
	ctx.r[10].s64 = ctx.r[31].s64 + 156;
	// 822F8E0C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F8E10: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822F8E14: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822F8E18: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8E1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F8E20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F8E24: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F8E28: 4200FFF0  bdnz 0x822f8e18
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F8E18; continue 'dispatch;
	}
	// 822F8E2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F8E30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8E34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8E38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8E48 size=84
    let mut pc: u32 = 0x822F8E48;
    'dispatch: loop {
        match pc {
            0x822F8E48 => {
    //   block [0x822F8E48..0x822F8E9C)
	// 822F8E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8E50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8E54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8E5C: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 822F8E60: 48B63839  bl 0x82e5c698
	ctx.lr = 0x822F8E64;
	sub_82E5C698(ctx, base);
	// 822F8E64: 387F016C  addi r3, r31, 0x16c
	ctx.r[3].s64 = ctx.r[31].s64 + 364;
	// 822F8E68: 48B66F49  bl 0x82e5fdb0
	ctx.lr = 0x822F8E6C;
	sub_82E5FDB0(ctx, base);
	// 822F8E6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F8E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8E74: 997F0091  stb r11, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 822F8E78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8E7C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 822F8E80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F8E84: 4E800421  bctrl
	ctx.lr = 0x822F8E88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F8E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F8E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8EA0 size=56
    let mut pc: u32 = 0x822F8EA0;
    'dispatch: loop {
        match pc {
            0x822F8EA0 => {
    //   block [0x822F8EA0..0x822F8ED8)
	// 822F8EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8EA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8EAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8EB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8EB4: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 822F8EB8: 48AFAD19  bl 0x82df3bd0
	ctx.lr = 0x822F8EBC;
	sub_82DF3BD0(ctx, base);
	// 822F8EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F8EC0: 997F0090  stb r11, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 822F8EC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F8EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8ED8 size=8
    let mut pc: u32 = 0x822F8ED8;
    'dispatch: loop {
        match pc {
            0x822F8ED8 => {
    //   block [0x822F8ED8..0x822F8EE0)
	// 822F8ED8: 90830184  stw r4, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[4].u32 ) };
	// 822F8EDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8EE0 size=12
    let mut pc: u32 = 0x822F8EE0;
    'dispatch: loop {
        match pc {
            0x822F8EE0 => {
    //   block [0x822F8EE0..0x822F8EEC)
	// 822F8EE0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 822F8EE4: 91630184  stw r11, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 822F8EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F8EF0 size=96
    let mut pc: u32 = 0x822F8EF0;
    'dispatch: loop {
        match pc {
            0x822F8EF0 => {
    //   block [0x822F8EF0..0x822F8F50)
	// 822F8EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F8EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F8EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F8EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F8F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F8F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F8F08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822F8F0C: 48AFACF5  bl 0x82df3c00
	ctx.lr = 0x822F8F10;
	sub_82DF3C00(ctx, base);
	// 822F8F10: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 822F8F14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 822F8F18: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822F8F1C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822F8F20: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8F24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F8F28: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F8F2C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F8F30: 4200FFF0  bdnz 0x822f8f20
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F8F20; continue 'dispatch;
	}
	// 822F8F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F8F38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F8F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F8F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F8F44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F8F48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F8F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8F50 size=64
    let mut pc: u32 = 0x822F8F50;
    'dispatch: loop {
        match pc {
            0x822F8F50 => {
    //   block [0x822F8F50..0x822F8F90)
	// 822F8F50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8F54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8F58: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F8F5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8F60: 892A0025  lbz r9, 0x25(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F8F64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822F8F68: 409A0008  bne cr6, 0x822f8f70
	if !ctx.cr[6].eq {
	pc = 0x822F8F70; continue 'dispatch;
	}
	// 822F8F6C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 822F8F70: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8F74: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822F8F78: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8F7C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8F80: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F8F84: 409A000C  bne cr6, 0x822f8f90
	if !ctx.cr[6].eq {
		sub_822F8F90(ctx, base);
		return;
	}
	// 822F8F88: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F8F8C: 48000020  b 0x822f8fac
	sub_822F8FA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8F90 size=24
    let mut pc: u32 = 0x822F8F90;
    'dispatch: loop {
        match pc {
            0x822F8F90 => {
    //   block [0x822F8F90..0x822F8FA8)
	// 822F8F90: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F8F94: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8F98: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F8F9C: 409A000C  bne cr6, 0x822f8fa8
	if !ctx.cr[6].eq {
		sub_822F8FA8(ctx, base);
		return;
	}
	// 822F8FA0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822F8FA4: 48000008  b 0x822f8fac
	sub_822F8FA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8FA8 size=16
    let mut pc: u32 = 0x822F8FA8;
    'dispatch: loop {
        match pc {
            0x822F8FA8 => {
    //   block [0x822F8FA8..0x822F8FB8)
	// 822F8FA8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F8FAC: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 822F8FB0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F8FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8FB8 size=24
    let mut pc: u32 = 0x822F8FB8;
    'dispatch: loop {
        match pc {
            0x822F8FB8 => {
    //   block [0x822F8FB8..0x822F8FD0)
	// 822F8FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8FBC: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F8FC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F8FC4: 419A000C  beq cr6, 0x822f8fd0
	if ctx.cr[6].eq {
		sub_822F8FD0(ctx, base);
		return;
	}
	// 822F8FC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8FCC: 48000070  b 0x822f903c
	sub_822F903C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8FD0 size=24
    let mut pc: u32 = 0x822F8FD0;
    'dispatch: loop {
        match pc {
            0x822F8FD0 => {
    //   block [0x822F8FD0..0x822F8FE8)
	// 822F8FD0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F8FD4: 892A0025  lbz r9, 0x25(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F8FD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822F8FDC: 409A0040  bne cr6, 0x822f901c
	if !ctx.cr[6].eq {
		sub_822F9004(ctx, base);
		return;
	}
	// 822F8FE0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8FE4: 4800000C  b 0x822f8ff0
	sub_822F8FE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F8FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F8FE8 size=28
    let mut pc: u32 = 0x822F8FE8;
    'dispatch: loop {
        match pc {
            0x822F8FE8 => {
    //   block [0x822F8FE8..0x822F9004)
	// 822F8FE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822F8FEC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F8FF0: 892B0025  lbz r9, 0x25(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F8FF4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822F8FF8: 419AFFF0  beq cr6, 0x822f8fe8
	if ctx.cr[6].eq {
	pc = 0x822F8FE8; continue 'dispatch;
	}
	// 822F8FFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F9000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9004(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F9004 size=56
    let mut pc: u32 = 0x822F9004;
    'dispatch: loop {
        match pc {
            0x822F9004 => {
    //   block [0x822F9004..0x822F903C)
	// 822F9004: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9008: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F900C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822F9010: 409A001C  bne cr6, 0x822f902c
	if !ctx.cr[6].eq {
	pc = 0x822F902C; continue 'dispatch;
	}
	// 822F9014: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F9018: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F901C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9020: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F9024: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F9028: 419AFFDC  beq cr6, 0x822f9004
	if ctx.cr[6].eq {
	pc = 0x822F9004; continue 'dispatch;
	}
	// 822F902C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9030: 894A0025  lbz r10, 0x25(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F9034: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F9038: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F903C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F903C size=8
    let mut pc: u32 = 0x822F903C;
    'dispatch: loop {
        match pc {
            0x822F903C => {
    //   block [0x822F903C..0x822F9044)
	// 822F903C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F9040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9048 size=96
    let mut pc: u32 = 0x822F9048;
    'dispatch: loop {
        match pc {
            0x822F9048 => {
    //   block [0x822F9048..0x822F90A8)
	// 822F9048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F904C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F9054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F9058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F905C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F9060: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F9064: 48AFAB9D  bl 0x82df3c00
	ctx.lr = 0x822F9068;
	sub_82DF3C00(ctx, base);
	// 822F9068: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F906C: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 822F9070: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822F9074: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822F9078: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F907C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F9080: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822F9084: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822F9088: 4200FFF0  bdnz 0x822f9078
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822F9078; continue 'dispatch;
	}
	// 822F908C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F9090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F9094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F909C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F90A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F90A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F90A8 size=20
    let mut pc: u32 = 0x822F90A8;
    'dispatch: loop {
        match pc {
            0x822F90A8 => {
    //   block [0x822F90A8..0x822F90BC)
	// 822F90A8: 81630178  lwz r11, 0x178(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F90AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F90B0: 409A000C  bne cr6, 0x822f90bc
	if !ctx.cr[6].eq {
		sub_822F90BC(ctx, base);
		return;
	}
	// 822F90B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F90B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F90BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F90BC size=16
    let mut pc: u32 = 0x822F90BC;
    'dispatch: loop {
        match pc {
            0x822F90BC => {
    //   block [0x822F90BC..0x822F90CC)
	// 822F90BC: 8143017C  lwz r10, 0x17c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F90C0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F90C4: 7D631E70  srawi r3, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F90C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F90D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F90D0 size=20
    let mut pc: u32 = 0x822F90D0;
    'dispatch: loop {
        match pc {
            0x822F90D0 => {
    //   block [0x822F90D0..0x822F90E4)
	// 822F90D0: 81430178  lwz r10, 0x178(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F90D4: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F90D8: 386300D8  addi r3, r3, 0xd8
	ctx.r[3].s64 = ctx.r[3].s64 + 216;
	// 822F90DC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822F90E0: 480043E8  b 0x822fd4c8
	sub_822FD4C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F90E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F90E8 size=88
    let mut pc: u32 = 0x822F90E8;
    'dispatch: loop {
        match pc {
            0x822F90E8 => {
    //   block [0x822F90E8..0x822F9140)
	// 822F90E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F90EC: 48EAF081  bl 0x831a816c
	ctx.lr = 0x822F90F0;
	sub_831A8130(ctx, base);
	// 822F90F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F90F4: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F90F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822F90FC: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9100: 48000028  b 0x822f9128
	pc = 0x822F9128; continue 'dispatch;
	// 822F9104: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9108: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822F910C: 48AFA12D  bl 0x82df3238
	ctx.lr = 0x822F9110;
	sub_82DF3238(ctx, base);
	// 822F9110: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9114: 4182000C  beq 0x822f9120
	if ctx.cr[0].eq {
	pc = 0x822F9120; continue 'dispatch;
	}
	// 822F9118: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F911C: 4800000C  b 0x822f9128
	pc = 0x822F9128; continue 'dispatch;
	// 822F9120: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822F9124: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9128: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 822F912C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9130: 419AFFD4  beq cr6, 0x822f9104
	if ctx.cr[6].eq {
	pc = 0x822F9104; continue 'dispatch;
	}
	// 822F9134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F9138: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F913C: 48EAF080  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F9140 size=20
    let mut pc: u32 = 0x822F9140;
    'dispatch: loop {
        match pc {
            0x822F9140 => {
    //   block [0x822F9140..0x822F9154)
	// 822F9140: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9144: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9148: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822F914C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F9150: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9154(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822F9154 size=40
    let mut pc: u32 = 0x822F9154;
    'dispatch: loop {
        match pc {
            0x822F9154 => {
    //   block [0x822F9154..0x822F917C)
	// 822F9154: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F9158: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F915C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822F9160: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822F9164: 41980008  blt cr6, 0x822f916c
	if ctx.cr[6].lt {
	pc = 0x822F916C; continue 'dispatch;
	}
	// 822F9168: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822F916C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822F9170: 4182000C  beq 0x822f917c
	if ctx.cr[0].eq {
		sub_822F917C(ctx, base);
		return;
	}
	// 822F9174: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F9178: 4800000C  b 0x822f9184
	sub_822F917C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F917C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F917C size=24
    let mut pc: u32 = 0x822F917C;
    'dispatch: loop {
        match pc {
            0x822F917C => {
    //   block [0x822F917C..0x822F9194)
	// 822F917C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F9180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9184: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822F9188: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822F918C: 419AFFCC  beq cr6, 0x822f9158
	if ctx.cr[6].eq {
		sub_822F9154(ctx, base);
		return;
	}
	// 822F9190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9198 size=116
    let mut pc: u32 = 0x822F9198;
    'dispatch: loop {
        match pc {
            0x822F9198 => {
    //   block [0x822F9198..0x822F920C)
	// 822F9198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F919C: 48EAEFC5  bl 0x831a8160
	ctx.lr = 0x822F91A0;
	sub_831A8130(ctx, base);
	// 822F91A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F91A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822F91A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F91AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F91B0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822F91B4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822F91B8: 38C00028  li r6, 0x28
	ctx.r[6].s64 = 40;
	// 822F91BC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822F91C0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 822F91C4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822F91C8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822F91CC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822F91D0: 48AF8EF9  bl 0x82df20c8
	ctx.lr = 0x822F91D4;
	sub_82DF20C8(ctx, base);
	// 822F91D4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F91D8: 41820028  beq 0x822f9200
	if ctx.cr[0].eq {
	pc = 0x822F9200; continue 'dispatch;
	}
	// 822F91DC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F91E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822F91E4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 822F91E8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 822F91EC: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822F91F0: 4BFFFE59  bl 0x822f9048
	ctx.lr = 0x822F91F4;
	sub_822F9048(ctx, base);
	// 822F91F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F91F8: 9B5F0024  stb r26, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u8 ) };
	// 822F91FC: 997F0025  stb r11, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 822F9200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9204: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F9208: 48EAEFA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9210 size=132
    let mut pc: u32 = 0x822F9210;
    'dispatch: loop {
        match pc {
            0x822F9210 => {
    //   block [0x822F9210..0x822F9294)
	// 822F9210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9214: 48EAEF4D  bl 0x831a8160
	ctx.lr = 0x822F9218;
	sub_831A8130(ctx, base);
	// 822F9218: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F921C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822F9220: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822F9224: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822F9228: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822F922C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822F9230: 38C00018  li r6, 0x18
	ctx.r[6].s64 = 24;
	// 822F9234: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822F9238: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 822F923C: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822F9240: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822F9244: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822F9248: 48AF8E81  bl 0x82df20c8
	ctx.lr = 0x822F924C;
	sub_82DF20C8(ctx, base);
	// 822F924C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822F9250: 41820038  beq 0x822f9288
	if ctx.cr[0].eq {
	pc = 0x822F9288; continue 'dispatch;
	}
	// 822F9254: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822F9258: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 822F925C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822F9260: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9264: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 822F9268: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F926C: 48AFA995  bl 0x82df3c00
	ctx.lr = 0x822F9270;
	sub_82DF3C00(ctx, base);
	// 822F9270: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 822F9274: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 822F9278: 48AFA989  bl 0x82df3c00
	ctx.lr = 0x822F927C;
	sub_82DF3C00(ctx, base);
	// 822F927C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F9280: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 822F9284: 997F0015  stb r11, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 822F9288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F928C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F9290: 48EAEF20  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F9298 size=36
    let mut pc: u32 = 0x822F9298;
    'dispatch: loop {
        match pc {
            0x822F9298 => {
    //   block [0x822F9298..0x822F92BC)
	// 822F9298: 81440178  lwz r10, 0x178(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F929C: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F92A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 822F92A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F92A8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822F92AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F92B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F92B4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F92B8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F92BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F92BC size=36
    let mut pc: u32 = 0x822F92BC;
    'dispatch: loop {
        match pc {
            0x822F92BC => {
    //   block [0x822F92BC..0x822F92E0)
	// 822F92BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F92C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F92C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F92C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F92CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F92D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F92D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F92D8: 4082FFE8  bne 0x822f92c0
	if !ctx.cr[0].eq {
	pc = 0x822F92C0; continue 'dispatch;
	}
	// 822F92DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F92E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F92E0 size=328
    let mut pc: u32 = 0x822F92E0;
    'dispatch: loop {
        match pc {
            0x822F92E0 => {
    //   block [0x822F92E0..0x822F9428)
	// 822F92E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F92E4: 48EAEE85  bl 0x831a8168
	ctx.lr = 0x822F92E8;
	sub_831A8130(ctx, base);
	// 822F92E8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F92EC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F92F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F92F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F92F8: 549D1838  slwi r29, r4, 3
	ctx.r[29].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 822F92FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F9300: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822F9304: 817F0178  lwz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9308: 7FDD582E  lwzx r30, r29, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F930C: 48B60685  bl 0x82e59990
	ctx.lr = 0x822F9310;
	sub_82E59990(ctx, base);
	// 822F9310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F9318: 48B60659  bl 0x82e59970
	ctx.lr = 0x822F931C;
	sub_82E59970(ctx, base);
	// 822F931C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F9320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9324: 419A0008  beq cr6, 0x822f932c
	if ctx.cr[6].eq {
	pc = 0x822F932C; continue 'dispatch;
	}
	// 822F9328: 4BFC7569  bl 0x822c0890
	ctx.lr = 0x822F932C;
	sub_822C0890(ctx, base);
	// 822F932C: 817F0178  lwz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9330: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9334: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F9338: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822F933C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 822F9340: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9344: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 822F9348: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F934C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9350: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822F9354: 419A0024  beq cr6, 0x822f9378
	if ctx.cr[6].eq {
	pc = 0x822F9378; continue 'dispatch;
	}
	// 822F9358: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F935C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F936C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9374: 4082FFE8  bne 0x822f935c
	if !ctx.cr[0].eq {
	pc = 0x822F935C; continue 'dispatch;
	}
	// 822F9378: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F937C: 3B9F016C  addi r28, r31, 0x16c
	ctx.r[28].s64 = ctx.r[31].s64 + 364;
	// 822F9380: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822F9384: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F9388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F938C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9390: 48B668B1  bl 0x82e5fc40
	ctx.lr = 0x822F9394;
	sub_82E5FC40(ctx, base);
	// 822F9394: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F939C: 419A0008  beq cr6, 0x822f93a4
	if ctx.cr[6].eq {
	pc = 0x822F93A4; continue 'dispatch;
	}
	// 822F93A0: 4BFC74F1  bl 0x822c0890
	ctx.lr = 0x822F93A4;
	sub_822C0890(ctx, base);
	// 822F93A4: 817F0178  lwz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F93A8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 822F93AC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 822F93B0: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 822F93B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F93B8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 822F93BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F93C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F93C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822F93C8: 419A0024  beq cr6, 0x822f93ec
	if ctx.cr[6].eq {
	pc = 0x822F93EC; continue 'dispatch;
	}
	// 822F93CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F93D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F93D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F93D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F93DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F93E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F93E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F93E8: 4082FFE8  bne 0x822f93d0
	if !ctx.cr[0].eq {
	pc = 0x822F93D0; continue 'dispatch;
	}
	// 822F93EC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 822F93F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F93F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822F93F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822F93FC: 48B66FED  bl 0x82e603e8
	ctx.lr = 0x822F9400;
	sub_82E603E8(ctx, base);
	// 822F9400: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F9404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9408: 419A0008  beq cr6, 0x822f9410
	if ctx.cr[6].eq {
	pc = 0x822F9410; continue 'dispatch;
	}
	// 822F940C: 4BFC7485  bl 0x822c0890
	ctx.lr = 0x822F9410;
	sub_822C0890(ctx, base);
	// 822F9410: 817F0178  lwz r11, 0x178(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9414: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 822F9418: 48B606C1  bl 0x82e59ad8
	ctx.lr = 0x822F941C;
	sub_82E59AD8(ctx, base);
	// 822F941C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822F9420: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F9424: 48EAED94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9428 size=136
    let mut pc: u32 = 0x822F9428;
    'dispatch: loop {
        match pc {
            0x822F9428 => {
    //   block [0x822F9428..0x822F94B0)
	// 822F9428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F942C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9430: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F9434: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9438: 81640184  lwz r11, 0x184(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(388 as u32) ) } as u64;
	// 822F943C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F9440: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9444: 40980040  bge cr6, 0x822f9484
	if !ctx.cr[6].lt {
	pc = 0x822F9484; continue 'dispatch;
	}
	// 822F9448: 81640080  lwz r11, 0x80(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 822F944C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F9450: 81640084  lwz r11, 0x84(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 822F9454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9458: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822F945C: 419A003C  beq cr6, 0x822f9498
	if ctx.cr[6].eq {
	pc = 0x822F9498; continue 'dispatch;
	}
	// 822F9460: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822F9464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F946C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F947C: 4082FFE8  bne 0x822f9464
	if !ctx.cr[0].eq {
	pc = 0x822F9464; continue 'dispatch;
	}
	// 822F9480: 48000018  b 0x822f9498
	pc = 0x822F9498; continue 'dispatch;
	// 822F9484: 81440178  lwz r10, 0x178(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9488: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822F948C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9490: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 822F9494: 4BFFFF95  bl 0x822f9428
	ctx.lr = 0x822F9498;
	sub_822F9428(ctx, base);
	// 822F9498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F949C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822F94A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F94A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F94A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F94AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F94B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822F94B0 size=28
    let mut pc: u32 = 0x822F94B0;
    'dispatch: loop {
        match pc {
            0x822F94B0 => {
    //   block [0x822F94B0..0x822F94CC)
	// 822F94B0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F94B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822F94B8: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 822F94BC: 394B0080  addi r10, r11, 0x80
	ctx.r[10].s64 = ctx.r[11].s64 + 128;
	// 822F94C0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 822F94C4: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 822F94C8: 4BFCAF98  b 0x822c4460
	sub_822C4460(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F94D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F94D0 size=112
    let mut pc: u32 = 0x822F94D0;
    'dispatch: loop {
        match pc {
            0x822F94D0 => {
    //   block [0x822F94D0..0x822F9540)
	// 822F94D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F94D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F94D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822F94DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F94E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F94E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F94E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F94EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F94F0: 4BFFFF39  bl 0x822f9428
	ctx.lr = 0x822F94F4;
	sub_822F9428(ctx, base);
	// 822F94F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F94F8: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F94FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9500: 419A000C  beq cr6, 0x822f950c
	if ctx.cr[6].eq {
	pc = 0x822F950C; continue 'dispatch;
	}
	// 822F9504: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F9508: 4BFC7389  bl 0x822c0890
	ctx.lr = 0x822F950C;
	sub_822C0890(ctx, base);
	// 822F950C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822F9510: 419A0018  beq cr6, 0x822f9528
	if ctx.cr[6].eq {
	pc = 0x822F9528; continue 'dispatch;
	}
	// 822F9514: C01F00C8  lfs f0, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F9518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F951C: C1BF00C4  lfs f13, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F9520: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822F9524: 488BDF45  bl 0x82bb7468
	ctx.lr = 0x822F9528;
	sub_82BB7468(ctx, base);
	// 822F9528: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F952C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F9534: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822F9538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F953C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9540 size=112
    let mut pc: u32 = 0x822F9540;
    'dispatch: loop {
        match pc {
            0x822F9540 => {
    //   block [0x822F9540..0x822F95B0)
	// 822F9540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9544: 48EAEC29  bl 0x831a816c
	ctx.lr = 0x822F9548;
	sub_831A8130(ctx, base);
	// 822F9548: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F954C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822F9550: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822F9554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F9558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822F955C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9560: 4BFFFB89  bl 0x822f90e8
	ctx.lr = 0x822F9564;
	sub_822F90E8(ctx, base);
	// 822F9564: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9568: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822F956C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822F9570: 419A0020  beq cr6, 0x822f9590
	if ctx.cr[6].eq {
	pc = 0x822F9590; continue 'dispatch;
	}
	// 822F9574: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 822F9578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822F957C: 48AF9CBD  bl 0x82df3238
	ctx.lr = 0x822F9580;
	sub_82DF3238(ctx, base);
	// 822F9580: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9584: 4082000C  bne 0x822f9590
	if !ctx.cr[0].eq {
	pc = 0x822F9590; continue 'dispatch;
	}
	// 822F9588: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822F958C: 48000010  b 0x822f959c
	pc = 0x822F959C; continue 'dispatch;
	// 822F9590: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9594: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 822F9598: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 822F959C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F95A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822F95A4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822F95A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F95AC: 48EAEC10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F95B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F95B0 size=80
    let mut pc: u32 = 0x822F95B0;
    'dispatch: loop {
        match pc {
            0x822F95B0 => {
    //   block [0x822F95B0..0x822F9600)
	// 822F95B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F95B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F95B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F95BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F95C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F95C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822F95C8: 389F0074  addi r4, r31, 0x74
	ctx.r[4].s64 = ctx.r[31].s64 + 116;
	// 822F95CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F95D0: 4BFFFF71  bl 0x822f9540
	ctx.lr = 0x822F95D4;
	sub_822F9540(ctx, base);
	// 822F95D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F95D8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 822F95DC: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 822F95E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822F95E4: 409A0008  bne cr6, 0x822f95ec
	if !ctx.cr[6].eq {
	pc = 0x822F95EC; continue 'dispatch;
	}
	// 822F95E8: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 822F95EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F95F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F95F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F95F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F95FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9600 size=196
    let mut pc: u32 = 0x822F9600;
    'dispatch: loop {
        match pc {
            0x822F9600 => {
    //   block [0x822F9600..0x822F96C4)
	// 822F9600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9604: 48EAEB65  bl 0x831a8168
	ctx.lr = 0x822F9608;
	sub_831A8130(ctx, base);
	// 822F9608: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F960C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F9610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9614: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9618: 4BFFFE11  bl 0x822f9428
	ctx.lr = 0x822F961C;
	sub_822F9428(ctx, base);
	// 822F961C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9624: 419A0008  beq cr6, 0x822f962c
	if ctx.cr[6].eq {
	pc = 0x822F962C; continue 'dispatch;
	}
	// 822F9628: 488BFA49  bl 0x82bb9070
	ctx.lr = 0x822F962C;
	sub_82BB9070(ctx, base);
	// 822F962C: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9634: 419A0010  beq cr6, 0x822f9644
	if ctx.cr[6].eq {
	pc = 0x822F9644; continue 'dispatch;
	}
	// 822F9638: 815D017C  lwz r10, 0x17c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F963C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F9640: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9648: 419A0064  beq cr6, 0x822f96ac
	if ctx.cr[6].eq {
	pc = 0x822F96AC; continue 'dispatch;
	}
	// 822F964C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9650: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9654: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9658: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822F965C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9660: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9664: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9668: 419A0024  beq cr6, 0x822f968c
	if ctx.cr[6].eq {
	pc = 0x822F968C; continue 'dispatch;
	}
	// 822F966C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F9670: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9674: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9678: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F967C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9680: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9684: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9688: 4082FFE8  bne 0x822f9670
	if !ctx.cr[0].eq {
	pc = 0x822F9670; continue 'dispatch;
	}
	// 822F968C: 4BFFFF75  bl 0x822f9600
	ctx.lr = 0x822F9690;
	sub_822F9600(ctx, base);
	// 822F9690: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9694: 419A000C  beq cr6, 0x822f96a0
	if ctx.cr[6].eq {
	pc = 0x822F96A0; continue 'dispatch;
	}
	// 822F9698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F969C: 4BFC71F5  bl 0x822c0890
	ctx.lr = 0x822F96A0;
	sub_822C0890(ctx, base);
	// 822F96A0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F96A4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F96A8: 4082FFAC  bne 0x822f9654
	if !ctx.cr[0].eq {
	pc = 0x822F9654; continue 'dispatch;
	}
	// 822F96AC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F96B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F96B4: 419A0008  beq cr6, 0x822f96bc
	if ctx.cr[6].eq {
	pc = 0x822F96BC; continue 'dispatch;
	}
	// 822F96B8: 4BFC71D9  bl 0x822c0890
	ctx.lr = 0x822F96BC;
	sub_822C0890(ctx, base);
	// 822F96BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F96C0: 48EAEAF8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F96C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F96C8 size=216
    let mut pc: u32 = 0x822F96C8;
    'dispatch: loop {
        match pc {
            0x822F96C8 => {
    //   block [0x822F96C8..0x822F97A0)
	// 822F96C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F96CC: 48EAEA9D  bl 0x831a8168
	ctx.lr = 0x822F96D0;
	sub_831A8130(ctx, base);
	// 822F96D0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F96D4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F96D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F96DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F96E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F96E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F96E8: 4BFFFD41  bl 0x822f9428
	ctx.lr = 0x822F96EC;
	sub_822F9428(ctx, base);
	// 822F96EC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F96F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F96F4: 419A000C  beq cr6, 0x822f9700
	if ctx.cr[6].eq {
	pc = 0x822F9700; continue 'dispatch;
	}
	// 822F96F8: 488BFD39  bl 0x82bb9430
	ctx.lr = 0x822F96FC;
	sub_82BB9430(ctx, base);
	// 822F96FC: D3FD00C0  stfs f31, 0xc0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822F9700: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9708: 419A0010  beq cr6, 0x822f9718
	if ctx.cr[6].eq {
	pc = 0x822F9718; continue 'dispatch;
	}
	// 822F970C: 815D017C  lwz r10, 0x17c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F9710: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F9714: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F971C: 419A0068  beq cr6, 0x822f9784
	if ctx.cr[6].eq {
	pc = 0x822F9784; continue 'dispatch;
	}
	// 822F9720: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9724: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9728: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F972C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822F9730: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9734: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9738: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F973C: 419A0024  beq cr6, 0x822f9760
	if ctx.cr[6].eq {
	pc = 0x822F9760; continue 'dispatch;
	}
	// 822F9740: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F9744: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9748: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F974C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9750: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9754: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9758: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F975C: 4082FFE8  bne 0x822f9744
	if !ctx.cr[0].eq {
	pc = 0x822F9744; continue 'dispatch;
	}
	// 822F9760: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F9764: 4BFFFF65  bl 0x822f96c8
	ctx.lr = 0x822F9768;
	sub_822F96C8(ctx, base);
	// 822F9768: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F976C: 419A000C  beq cr6, 0x822f9778
	if ctx.cr[6].eq {
	pc = 0x822F9778; continue 'dispatch;
	}
	// 822F9770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9774: 4BFC711D  bl 0x822c0890
	ctx.lr = 0x822F9778;
	sub_822C0890(ctx, base);
	// 822F9778: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F977C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F9780: 4082FFA8  bne 0x822f9728
	if !ctx.cr[0].eq {
	pc = 0x822F9728; continue 'dispatch;
	}
	// 822F9784: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F978C: 419A0008  beq cr6, 0x822f9794
	if ctx.cr[6].eq {
	pc = 0x822F9794; continue 'dispatch;
	}
	// 822F9790: 4BFC7101  bl 0x822c0890
	ctx.lr = 0x822F9794;
	sub_822C0890(ctx, base);
	// 822F9794: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F9798: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F979C: 48EAEA1C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F97A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F97A0 size=116
    let mut pc: u32 = 0x822F97A0;
    'dispatch: loop {
        match pc {
            0x822F97A0 => {
    //   block [0x822F97A0..0x822F9814)
	// 822F97A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F97A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F97A8: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 822F97AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F97B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F97B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F97B8: 4BFFFC71  bl 0x822f9428
	ctx.lr = 0x822F97BC;
	sub_822F9428(ctx, base);
	// 822F97BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F97C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F97C4: 419A0024  beq cr6, 0x822f97e8
	if ctx.cr[6].eq {
	pc = 0x822F97E8; continue 'dispatch;
	}
	// 822F97C8: 488BD271  bl 0x82bb6a38
	ctx.lr = 0x822F97CC;
	sub_82BB6A38(ctx, base);
	// 822F97CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F97D0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F97D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F97D8: 419A0008  beq cr6, 0x822f97e0
	if ctx.cr[6].eq {
	pc = 0x822F97E0; continue 'dispatch;
	}
	// 822F97DC: 4BFC70B5  bl 0x822c0890
	ctx.lr = 0x822F97E0;
	sub_822C0890(ctx, base);
	// 822F97E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F97E4: 4800001C  b 0x822f9800
	pc = 0x822F9800; continue 'dispatch;
	// 822F97E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F97EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F97F0: 419A0008  beq cr6, 0x822f97f8
	if ctx.cr[6].eq {
	pc = 0x822F97F8; continue 'dispatch;
	}
	// 822F97F4: 4BFC709D  bl 0x822c0890
	ctx.lr = 0x822F97F8;
	sub_822C0890(ctx, base);
	// 822F97F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F97FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F9804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F980C: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F9810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F9818 size=224
    let mut pc: u32 = 0x822F9818;
    'dispatch: loop {
        match pc {
            0x822F9818 => {
    //   block [0x822F9818..0x822F98F8)
	// 822F9818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F981C: 48EAE94D  bl 0x831a8168
	ctx.lr = 0x822F9820;
	sub_831A8130(ctx, base);
	// 822F9820: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F9824: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9828: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F982C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F9830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9838: 4BFFFBF1  bl 0x822f9428
	ctx.lr = 0x822F983C;
	sub_822F9428(ctx, base);
	// 822F983C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9844: 419A0014  beq cr6, 0x822f9858
	if ctx.cr[6].eq {
	pc = 0x822F9858; continue 'dispatch;
	}
	// 822F9848: 488BF2C9  bl 0x82bb8b10
	ctx.lr = 0x822F984C;
	sub_82BB8B10(ctx, base);
	// 822F984C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9850: 488BD1E9  bl 0x82bb6a38
	ctx.lr = 0x822F9854;
	sub_82BB6A38(ctx, base);
	// 822F9854: D03D00C0  stfs f1, 0xc0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822F9858: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F985C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9860: 419A0010  beq cr6, 0x822f9870
	if ctx.cr[6].eq {
	pc = 0x822F9870; continue 'dispatch;
	}
	// 822F9864: 815D017C  lwz r10, 0x17c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F9868: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F986C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9874: 419A0068  beq cr6, 0x822f98dc
	if ctx.cr[6].eq {
	pc = 0x822F98DC; continue 'dispatch;
	}
	// 822F9878: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F987C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9880: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9884: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822F9888: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F988C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9890: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9894: 419A0024  beq cr6, 0x822f98b8
	if ctx.cr[6].eq {
	pc = 0x822F98B8; continue 'dispatch;
	}
	// 822F9898: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F989C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F98A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F98A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F98A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F98AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F98B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F98B4: 4082FFE8  bne 0x822f989c
	if !ctx.cr[0].eq {
	pc = 0x822F989C; continue 'dispatch;
	}
	// 822F98B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F98BC: 4BFFFF5D  bl 0x822f9818
	ctx.lr = 0x822F98C0;
	sub_822F9818(ctx, base);
	// 822F98C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F98C4: 419A000C  beq cr6, 0x822f98d0
	if ctx.cr[6].eq {
	pc = 0x822F98D0; continue 'dispatch;
	}
	// 822F98C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F98CC: 4BFC6FC5  bl 0x822c0890
	ctx.lr = 0x822F98D0;
	sub_822C0890(ctx, base);
	// 822F98D0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F98D4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F98D8: 4082FFA8  bne 0x822f9880
	if !ctx.cr[0].eq {
	pc = 0x822F9880; continue 'dispatch;
	}
	// 822F98DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F98E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F98E4: 419A0008  beq cr6, 0x822f98ec
	if ctx.cr[6].eq {
	pc = 0x822F98EC; continue 'dispatch;
	}
	// 822F98E8: 4BFC6FA9  bl 0x822c0890
	ctx.lr = 0x822F98EC;
	sub_822C0890(ctx, base);
	// 822F98EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F98F0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F98F4: 48EAE8C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F98F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F98F8 size=116
    let mut pc: u32 = 0x822F98F8;
    'dispatch: loop {
        match pc {
            0x822F98F8 => {
    //   block [0x822F98F8..0x822F996C)
	// 822F98F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F98FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9900: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 822F9904: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9908: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F990C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9910: 4BFFFB19  bl 0x822f9428
	ctx.lr = 0x822F9914;
	sub_822F9428(ctx, base);
	// 822F9914: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F991C: 419A0024  beq cr6, 0x822f9940
	if ctx.cr[6].eq {
	pc = 0x822F9940; continue 'dispatch;
	}
	// 822F9920: 488BCBE1  bl 0x82bb6500
	ctx.lr = 0x822F9924;
	sub_82BB6500(ctx, base);
	// 822F9924: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9928: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F992C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9930: 419A0008  beq cr6, 0x822f9938
	if ctx.cr[6].eq {
	pc = 0x822F9938; continue 'dispatch;
	}
	// 822F9934: 4BFC6F5D  bl 0x822c0890
	ctx.lr = 0x822F9938;
	sub_822C0890(ctx, base);
	// 822F9938: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F993C: 4800001C  b 0x822f9958
	pc = 0x822F9958; continue 'dispatch;
	// 822F9940: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9948: 419A0008  beq cr6, 0x822f9950
	if ctx.cr[6].eq {
	pc = 0x822F9950; continue 'dispatch;
	}
	// 822F994C: 4BFC6F45  bl 0x822c0890
	ctx.lr = 0x822F9950;
	sub_822C0890(ctx, base);
	// 822F9950: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F9954: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9958: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F995C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F9964: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F9968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F9970 size=128
    let mut pc: u32 = 0x822F9970;
    'dispatch: loop {
        match pc {
            0x822F9970 => {
    //   block [0x822F9970..0x822F99F0)
	// 822F9970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9978: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 822F997C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9988: 4BFFFAA1  bl 0x822f9428
	ctx.lr = 0x822F998C;
	sub_822F9428(ctx, base);
	// 822F998C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9994: 419A0030  beq cr6, 0x822f99c4
	if ctx.cr[6].eq {
	pc = 0x822F99C4; continue 'dispatch;
	}
	// 822F9998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F999C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822F99A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F99A4: 4E800421  bctrl
	ctx.lr = 0x822F99A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F99A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F99AC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F99B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F99B4: 419A0008  beq cr6, 0x822f99bc
	if ctx.cr[6].eq {
	pc = 0x822F99BC; continue 'dispatch;
	}
	// 822F99B8: 4BFC6ED9  bl 0x822c0890
	ctx.lr = 0x822F99BC;
	sub_822C0890(ctx, base);
	// 822F99BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F99C0: 4800001C  b 0x822f99dc
	pc = 0x822F99DC; continue 'dispatch;
	// 822F99C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F99C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F99CC: 419A0008  beq cr6, 0x822f99d4
	if ctx.cr[6].eq {
	pc = 0x822F99D4; continue 'dispatch;
	}
	// 822F99D0: 4BFC6EC1  bl 0x822c0890
	ctx.lr = 0x822F99D4;
	sub_822C0890(ctx, base);
	// 822F99D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F99D8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F99DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F99E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F99E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F99E8: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F99EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F99F0 size=168
    let mut pc: u32 = 0x822F99F0;
    'dispatch: loop {
        match pc {
            0x822F99F0 => {
    //   block [0x822F99F0..0x822F9A98)
	// 822F99F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F99F4: 48EAE775  bl 0x831a8168
	ctx.lr = 0x822F99F8;
	sub_831A8130(ctx, base);
	// 822F99F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F99FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822F9A00: D03E00C8  stfs f1, 0xc8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822F9A04: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9A0C: 419A0010  beq cr6, 0x822f9a1c
	if ctx.cr[6].eq {
	pc = 0x822F9A1C; continue 'dispatch;
	}
	// 822F9A10: 815E017C  lwz r10, 0x17c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F9A14: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F9A18: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9A20: 419A0070  beq cr6, 0x822f9a90
	if ctx.cr[6].eq {
	pc = 0x822F9A90; continue 'dispatch;
	}
	// 822F9A24: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822F9A28: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9A2C: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9A30: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822F9A34: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9A38: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9A3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9A40: 419A0024  beq cr6, 0x822f9a64
	if ctx.cr[6].eq {
	pc = 0x822F9A64; continue 'dispatch;
	}
	// 822F9A44: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F9A48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9A4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9A50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9A54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9A58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9A5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9A60: 4082FFE8  bne 0x822f9a48
	if !ctx.cr[0].eq {
	pc = 0x822F9A48; continue 'dispatch;
	}
	// 822F9A64: C01E00C4  lfs f0, 0xc4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F9A68: C1BE00C8  lfs f13, 0xc8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822F9A6C: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822F9A70: 4BFFFF81  bl 0x822f99f0
	ctx.lr = 0x822F9A74;
	sub_822F99F0(ctx, base);
	// 822F9A74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9A78: 419A000C  beq cr6, 0x822f9a84
	if ctx.cr[6].eq {
	pc = 0x822F9A84; continue 'dispatch;
	}
	// 822F9A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9A80: 4BFC6E11  bl 0x822c0890
	ctx.lr = 0x822F9A84;
	sub_822C0890(ctx, base);
	// 822F9A84: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F9A88: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 822F9A8C: 4082FFA0  bne 0x822f9a2c
	if !ctx.cr[0].eq {
	pc = 0x822F9A2C; continue 'dispatch;
	}
	// 822F9A90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F9A94: 48EAE724  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F9A98 size=188
    let mut pc: u32 = 0x822F9A98;
    'dispatch: loop {
        match pc {
            0x822F9A98 => {
    //   block [0x822F9A98..0x822F9B54)
	// 822F9A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F9AA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9AA8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822F9AAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9AB0: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 822F9AB4: 4BFFF975  bl 0x822f9428
	ctx.lr = 0x822F9AB8;
	sub_822F9428(ctx, base);
	// 822F9AB8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9ABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9AC0: 419A006C  beq cr6, 0x822f9b2c
	if ctx.cr[6].eq {
	pc = 0x822F9B2C; continue 'dispatch;
	}
	// 822F9AC4: 89680090  lbz r11, 0x90(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(144 as u32) ) } as u64;
	// 822F9AC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F9ACC: 40820048  bne 0x822f9b14
	if !ctx.cr[0].eq {
	pc = 0x822F9B14; continue 'dispatch;
	}
	// 822F9AD0: 89680091  lbz r11, 0x91(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(145 as u32) ) } as u64;
	// 822F9AD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F9AD8: 4082003C  bne 0x822f9b14
	if !ctx.cr[0].eq {
	pc = 0x822F9B14; continue 'dispatch;
	}
	// 822F9ADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F9AE0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9AE4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9AE8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F9AEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F9AF0: 4E800421  bctrl
	ctx.lr = 0x822F9AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F9AF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9AF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F9AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9B00: 419A000C  beq cr6, 0x822f9b0c
	if ctx.cr[6].eq {
	pc = 0x822F9B0C; continue 'dispatch;
	}
	// 822F9B04: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F9B08: 4BFC6D89  bl 0x822c0890
	ctx.lr = 0x822F9B0C;
	sub_822C0890(ctx, base);
	// 822F9B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9B10: 48000030  b 0x822f9b40
	pc = 0x822F9B40; continue 'dispatch;
	// 822F9B14: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9B18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9B1C: 419A0008  beq cr6, 0x822f9b24
	if ctx.cr[6].eq {
	pc = 0x822F9B24; continue 'dispatch;
	}
	// 822F9B20: 4BFC6D71  bl 0x822c0890
	ctx.lr = 0x822F9B24;
	sub_822C0890(ctx, base);
	// 822F9B24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F9B28: 48000018  b 0x822f9b40
	pc = 0x822F9B40; continue 'dispatch;
	// 822F9B2C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9B34: 419A0008  beq cr6, 0x822f9b3c
	if ctx.cr[6].eq {
	pc = 0x822F9B3C; continue 'dispatch;
	}
	// 822F9B38: 4BFC6D59  bl 0x822c0890
	ctx.lr = 0x822F9B3C;
	sub_822C0890(ctx, base);
	// 822F9B3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822F9B40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F9B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F9B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F9B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9B58 size=116
    let mut pc: u32 = 0x822F9B58;
    'dispatch: loop {
        match pc {
            0x822F9B58 => {
    //   block [0x822F9B58..0x822F9BCC)
	// 822F9B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9B60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822F9B64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9B68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9B70: 4BFFF8B9  bl 0x822f9428
	ctx.lr = 0x822F9B74;
	sub_822F9428(ctx, base);
	// 822F9B74: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9B78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9B7C: 419A0028  beq cr6, 0x822f9ba4
	if ctx.cr[6].eq {
	pc = 0x822F9BA4; continue 'dispatch;
	}
	// 822F9B80: 488BC7E1  bl 0x82bb6360
	ctx.lr = 0x822F9B84;
	sub_82BB6360(ctx, base);
	// 822F9B84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F9B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9B90: 419A000C  beq cr6, 0x822f9b9c
	if ctx.cr[6].eq {
	pc = 0x822F9B9C; continue 'dispatch;
	}
	// 822F9B94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822F9B98: 4BFC6CF9  bl 0x822c0890
	ctx.lr = 0x822F9B9C;
	sub_822C0890(ctx, base);
	// 822F9B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9BA0: 48000018  b 0x822f9bb8
	pc = 0x822F9BB8; continue 'dispatch;
	// 822F9BA4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9BA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9BAC: 419A0008  beq cr6, 0x822f9bb4
	if ctx.cr[6].eq {
	pc = 0x822F9BB4; continue 'dispatch;
	}
	// 822F9BB0: 4BFC6CE1  bl 0x822c0890
	ctx.lr = 0x822F9BB4;
	sub_822C0890(ctx, base);
	// 822F9BB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822F9BB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F9BBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9BC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F9BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F9BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9BD0 size=216
    let mut pc: u32 = 0x822F9BD0;
    'dispatch: loop {
        match pc {
            0x822F9BD0 => {
    //   block [0x822F9BD0..0x822F9CA8)
	// 822F9BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9BD4: 48EAE595  bl 0x831a8168
	ctx.lr = 0x822F9BD8;
	sub_831A8130(ctx, base);
	// 822F9BD8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822F9BDC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9BE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F9BE4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F9BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9BEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9BF0: 4BFFF839  bl 0x822f9428
	ctx.lr = 0x822F9BF4;
	sub_822F9428(ctx, base);
	// 822F9BF4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9BFC: 419A000C  beq cr6, 0x822f9c08
	if ctx.cr[6].eq {
	pc = 0x822F9C08; continue 'dispatch;
	}
	// 822F9C00: 488BEE71  bl 0x82bb8a70
	ctx.lr = 0x822F9C04;
	sub_82BB8A70(ctx, base);
	// 822F9C04: 48000088  b 0x822f9c8c
	pc = 0x822F9C8C; continue 'dispatch;
	// 822F9C08: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9C10: 419A0010  beq cr6, 0x822f9c20
	if ctx.cr[6].eq {
	pc = 0x822F9C20; continue 'dispatch;
	}
	// 822F9C14: 815D017C  lwz r10, 0x17c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F9C18: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F9C1C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9C24: 419A0068  beq cr6, 0x822f9c8c
	if ctx.cr[6].eq {
	pc = 0x822F9C8C; continue 'dispatch;
	}
	// 822F9C28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9C2C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9C30: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9C34: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822F9C38: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9C3C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9C40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9C44: 419A0024  beq cr6, 0x822f9c68
	if ctx.cr[6].eq {
	pc = 0x822F9C68; continue 'dispatch;
	}
	// 822F9C48: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F9C4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9C54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9C58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9C5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9C60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9C64: 4082FFE8  bne 0x822f9c4c
	if !ctx.cr[0].eq {
	pc = 0x822F9C4C; continue 'dispatch;
	}
	// 822F9C68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F9C6C: 4BFFFF65  bl 0x822f9bd0
	ctx.lr = 0x822F9C70;
	sub_822F9BD0(ctx, base);
	// 822F9C70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9C74: 419A000C  beq cr6, 0x822f9c80
	if ctx.cr[6].eq {
	pc = 0x822F9C80; continue 'dispatch;
	}
	// 822F9C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9C7C: 4BFC6C15  bl 0x822c0890
	ctx.lr = 0x822F9C80;
	sub_822C0890(ctx, base);
	// 822F9C80: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F9C84: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F9C88: 4082FFA8  bne 0x822f9c30
	if !ctx.cr[0].eq {
	pc = 0x822F9C30; continue 'dispatch;
	}
	// 822F9C8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9C90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9C94: 419A0008  beq cr6, 0x822f9c9c
	if ctx.cr[6].eq {
	pc = 0x822F9C9C; continue 'dispatch;
	}
	// 822F9C98: 4BFC6BF9  bl 0x822c0890
	ctx.lr = 0x822F9C9C;
	sub_822C0890(ctx, base);
	// 822F9C9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822F9CA0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822F9CA4: 48EAE514  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F9CA8 size=116
    let mut pc: u32 = 0x822F9CA8;
    'dispatch: loop {
        match pc {
            0x822F9CA8 => {
    //   block [0x822F9CA8..0x822F9D1C)
	// 822F9CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822F9CB0: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 822F9CB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9CB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9CC0: 4BFFF769  bl 0x822f9428
	ctx.lr = 0x822F9CC4;
	sub_822F9428(ctx, base);
	// 822F9CC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9CCC: 419A0024  beq cr6, 0x822f9cf0
	if ctx.cr[6].eq {
	pc = 0x822F9CF0; continue 'dispatch;
	}
	// 822F9CD0: 488BC7F1  bl 0x82bb64c0
	ctx.lr = 0x822F9CD4;
	sub_82BB64C0(ctx, base);
	// 822F9CD4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9CD8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822F9CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9CE0: 419A0008  beq cr6, 0x822f9ce8
	if ctx.cr[6].eq {
	pc = 0x822F9CE8; continue 'dispatch;
	}
	// 822F9CE4: 4BFC6BAD  bl 0x822c0890
	ctx.lr = 0x822F9CE8;
	sub_822C0890(ctx, base);
	// 822F9CE8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F9CEC: 4800001C  b 0x822f9d08
	pc = 0x822F9D08; continue 'dispatch;
	// 822F9CF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9CF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9CF8: 419A0008  beq cr6, 0x822f9d00
	if ctx.cr[6].eq {
	pc = 0x822F9D00; continue 'dispatch;
	}
	// 822F9CFC: 4BFC6B95  bl 0x822c0890
	ctx.lr = 0x822F9D00;
	sub_822C0890(ctx, base);
	// 822F9D00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F9D04: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9D08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822F9D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822F9D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822F9D14: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822F9D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822F9D20 size=196
    let mut pc: u32 = 0x822F9D20;
    'dispatch: loop {
        match pc {
            0x822F9D20 => {
    //   block [0x822F9D20..0x822F9DE4)
	// 822F9D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9D24: 48EAE445  bl 0x831a8168
	ctx.lr = 0x822F9D28;
	sub_831A8130(ctx, base);
	// 822F9D28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9D2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822F9D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9D34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822F9D38: 4BFFF6F1  bl 0x822f9428
	ctx.lr = 0x822F9D3C;
	sub_822F9428(ctx, base);
	// 822F9D3C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9D44: 419A0008  beq cr6, 0x822f9d4c
	if ctx.cr[6].eq {
	pc = 0x822F9D4C; continue 'dispatch;
	}
	// 822F9D48: 488BF399  bl 0x82bb90e0
	ctx.lr = 0x822F9D4C;
	sub_82BB90E0(ctx, base);
	// 822F9D4C: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9D54: 419A0010  beq cr6, 0x822f9d64
	if ctx.cr[6].eq {
	pc = 0x822F9D64; continue 'dispatch;
	}
	// 822F9D58: 815D017C  lwz r10, 0x17c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 822F9D5C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822F9D60: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822F9D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822F9D68: 419A0064  beq cr6, 0x822f9dcc
	if ctx.cr[6].eq {
	pc = 0x822F9DCC; continue 'dispatch;
	}
	// 822F9D6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9D70: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822F9D74: 817D0178  lwz r11, 0x178(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 822F9D78: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 822F9D7C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822F9D80: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9D84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9D88: 419A0024  beq cr6, 0x822f9dac
	if ctx.cr[6].eq {
	pc = 0x822F9DAC; continue 'dispatch;
	}
	// 822F9D8C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822F9D90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822F9D94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9D98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822F9D9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822F9DA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822F9DA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822F9DA8: 4082FFE8  bne 0x822f9d90
	if !ctx.cr[0].eq {
	pc = 0x822F9D90; continue 'dispatch;
	}
	// 822F9DAC: 4BFFFF75  bl 0x822f9d20
	ctx.lr = 0x822F9DB0;
	sub_822F9D20(ctx, base);
	// 822F9DB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822F9DB4: 419A000C  beq cr6, 0x822f9dc0
	if ctx.cr[6].eq {
	pc = 0x822F9DC0; continue 'dispatch;
	}
	// 822F9DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9DBC: 4BFC6AD5  bl 0x822c0890
	ctx.lr = 0x822F9DC0;
	sub_822C0890(ctx, base);
	// 822F9DC0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822F9DC4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822F9DC8: 4082FFAC  bne 0x822f9d74
	if !ctx.cr[0].eq {
	pc = 0x822F9D74; continue 'dispatch;
	}
	// 822F9DCC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9DD4: 419A0008  beq cr6, 0x822f9ddc
	if ctx.cr[6].eq {
	pc = 0x822F9DDC; continue 'dispatch;
	}
	// 822F9DD8: 4BFC6AB9  bl 0x822c0890
	ctx.lr = 0x822F9DDC;
	sub_822C0890(ctx, base);
	// 822F9DDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822F9DE0: 48EAE3D8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822F9DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822F9DE8 size=604
    let mut pc: u32 = 0x822F9DE8;
    'dispatch: loop {
        match pc {
            0x822F9DE8 => {
    //   block [0x822F9DE8..0x822FA044)
	// 822F9DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822F9DEC: 48EAE381  bl 0x831a816c
	ctx.lr = 0x822F9DF0;
	sub_831A8130(ctx, base);
	// 822F9DF0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 822F9DF4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 822F9DF8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822F9DFC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822F9E00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822F9E04: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822F9E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822F9E0C: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 822F9E10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822F9E14: 4BFFF615  bl 0x822f9428
	ctx.lr = 0x822F9E18;
	sub_822F9428(ctx, base);
	// 822F9E18: 897F0091  lbz r11, 0x91(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 822F9E1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F9E20: 41820110  beq 0x822f9f30
	if ctx.cr[0].eq {
	pc = 0x822F9F30; continue 'dispatch;
	}
	// 822F9E24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F9E28: C01F0098  lfs f0, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F9E2C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F9E30: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822F9E34: 409800C0  bge cr6, 0x822f9ef4
	if !ctx.cr[6].lt {
	pc = 0x822F9EF4; continue 'dispatch;
	}
	// 822F9E38: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9E3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9E40: 488BC521  bl 0x82bb6360
	ctx.lr = 0x822F9E44;
	sub_82BB6360(ctx, base);
	// 822F9E44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9E48: 4182002C  beq 0x822f9e74
	if ctx.cr[0].eq {
	pc = 0x822F9E74; continue 'dispatch;
	}
	// 822F9E4C: C03F0098  lfs f1, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9E50: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822F9E54: 4098000C  bge cr6, 0x822f9e60
	if !ctx.cr[6].lt {
	pc = 0x822F9E60; continue 'dispatch;
	}
	// 822F9E58: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9E5C: 488BCBA5  bl 0x82bb6a00
	ctx.lr = 0x822F9E60;
	sub_82BB6A00(ctx, base);
	// 822F9E60: FF1E0800  fcmpu cr6, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 822F9E64: 40980034  bge cr6, 0x822f9e98
	if !ctx.cr[6].lt {
	pc = 0x822F9E98; continue 'dispatch;
	}
	// 822F9E68: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 822F9E6C: 4199002C  bgt cr6, 0x822f9e98
	if ctx.cr[6].gt {
	pc = 0x822F9E98; continue 'dispatch;
	}
	// 822F9E70: 48000024  b 0x822f9e94
	pc = 0x822F9E94; continue 'dispatch;
	// 822F9E74: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9E78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F9E7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9E80: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F9E84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F9E88: 4E800421  bctrl
	ctx.lr = 0x822F9E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F9E8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9E90: 41820008  beq 0x822f9e98
	if ctx.cr[0].eq {
	pc = 0x822F9E98; continue 'dispatch;
	}
	// 822F9E94: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822F9E98: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9E9C: 41820180  beq 0x822fa01c
	if ctx.cr[0].eq {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9EA4: 3BDF009C  addi r30, r31, 0x9c
	ctx.r[30].s64 = ctx.r[31].s64 + 156;
	// 822F9EA8: 3BBF0094  addi r29, r31, 0x94
	ctx.r[29].s64 = ctx.r[31].s64 + 148;
	// 822F9EAC: 48D0E27D  bl 0x83008128
	ctx.lr = 0x822F9EB0;
	sub_83008128(ctx, base);
	// 822F9EB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9EB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822F9EB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822F9EBC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822F9EC0: 480040D9  bl 0x822fdf98
	ctx.lr = 0x822F9EC4;
	sub_822FDF98(ctx, base);
	// 822F9EC4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822F9EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9ECC: 419A0008  beq cr6, 0x822f9ed4
	if ctx.cr[6].eq {
	pc = 0x822F9ED4; continue 'dispatch;
	}
	// 822F9ED0: 4BFC69C1  bl 0x822c0890
	ctx.lr = 0x822F9ED4;
	sub_822C0890(ctx, base);
	// 822F9ED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822F9ED8: 997F0091  stb r11, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 822F9EDC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822F9EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9EE4: 419A0008  beq cr6, 0x822f9eec
	if ctx.cr[6].eq {
	pc = 0x822F9EEC; continue 'dispatch;
	}
	// 822F9EE8: 4BFC69A9  bl 0x822c0890
	ctx.lr = 0x822F9EEC;
	sub_822C0890(ctx, base);
	// 822F9EEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822F9EF0: 48000140  b 0x822fa030
	pc = 0x822FA030; continue 'dispatch;
	// 822F9EF4: FF1E0000  fcmpu cr6, f30, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 822F9EF8: 40980124  bge cr6, 0x822fa01c
	if !ctx.cr[6].lt {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9EFC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 822F9F00: 4199011C  bgt cr6, 0x822fa01c
	if ctx.cr[6].gt {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9F08: 3BDF009C  addi r30, r31, 0x9c
	ctx.r[30].s64 = ctx.r[31].s64 + 156;
	// 822F9F0C: 3BBF0094  addi r29, r31, 0x94
	ctx.r[29].s64 = ctx.r[31].s64 + 148;
	// 822F9F10: 48D0E219  bl 0x83008128
	ctx.lr = 0x822F9F14;
	sub_83008128(ctx, base);
	// 822F9F14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9F18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822F9F1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822F9F20: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822F9F24: 48004075  bl 0x822fdf98
	ctx.lr = 0x822F9F28;
	sub_822FDF98(ctx, base);
	// 822F9F28: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822F9F2C: 4BFFFF9C  b 0x822f9ec8
	pc = 0x822F9EC8; continue 'dispatch;
	// 822F9F30: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 822F9F34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822F9F38: 418200E4  beq 0x822fa01c
	if ctx.cr[0].eq {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9F3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822F9F40: C01F008C  lfs f0, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822F9F44: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822F9F48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822F9F4C: 4098009C  bge cr6, 0x822f9fe8
	if !ctx.cr[6].lt {
	pc = 0x822F9FE8; continue 'dispatch;
	}
	// 822F9F50: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9F54: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822F9F58: 488BC409  bl 0x82bb6360
	ctx.lr = 0x822F9F5C;
	sub_82BB6360(ctx, base);
	// 822F9F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9F60: 4182002C  beq 0x822f9f8c
	if ctx.cr[0].eq {
	pc = 0x822F9F8C; continue 'dispatch;
	}
	// 822F9F64: C03F008C  lfs f1, 0x8c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822F9F68: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822F9F6C: 4098000C  bge cr6, 0x822f9f78
	if !ctx.cr[6].lt {
	pc = 0x822F9F78; continue 'dispatch;
	}
	// 822F9F70: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9F74: 488BCA8D  bl 0x82bb6a00
	ctx.lr = 0x822F9F78;
	sub_82BB6A00(ctx, base);
	// 822F9F78: FF1E0800  fcmpu cr6, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 822F9F7C: 40980034  bge cr6, 0x822f9fb0
	if !ctx.cr[6].lt {
	pc = 0x822F9FB0; continue 'dispatch;
	}
	// 822F9F80: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 822F9F84: 4199002C  bgt cr6, 0x822f9fb0
	if ctx.cr[6].gt {
	pc = 0x822F9FB0; continue 'dispatch;
	}
	// 822F9F88: 48000024  b 0x822f9fac
	pc = 0x822F9FAC; continue 'dispatch;
	// 822F9F8C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822F9F90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822F9F94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822F9F98: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822F9F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822F9FA0: 4E800421  bctrl
	ctx.lr = 0x822F9FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822F9FA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9FA8: 41820008  beq 0x822f9fb0
	if ctx.cr[0].eq {
	pc = 0x822F9FB0; continue 'dispatch;
	}
	// 822F9FAC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822F9FB0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822F9FB4: 41820068  beq 0x822fa01c
	if ctx.cr[0].eq {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9FBC: 3BFF0088  addi r31, r31, 0x88
	ctx.r[31].s64 = ctx.r[31].s64 + 136;
	// 822F9FC0: 48D0E169  bl 0x83008128
	ctx.lr = 0x822F9FC4;
	sub_83008128(ctx, base);
	// 822F9FC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822F9FC8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822F9FCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822F9FD0: 48003EC1  bl 0x822fde90
	ctx.lr = 0x822F9FD4;
	sub_822FDE90(ctx, base);
	// 822F9FD4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822F9FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822F9FDC: 419AFF00  beq cr6, 0x822f9edc
	if ctx.cr[6].eq {
	pc = 0x822F9EDC; continue 'dispatch;
	}
	// 822F9FE0: 4BFC68B1  bl 0x822c0890
	ctx.lr = 0x822F9FE4;
	sub_822C0890(ctx, base);
	// 822F9FE4: 4BFFFEF8  b 0x822f9edc
	pc = 0x822F9EDC; continue 'dispatch;
	// 822F9FE8: FF1E0000  fcmpu cr6, f30, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 822F9FEC: 40980030  bge cr6, 0x822fa01c
	if !ctx.cr[6].lt {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9FF0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 822F9FF4: 41990028  bgt cr6, 0x822fa01c
	if ctx.cr[6].gt {
	pc = 0x822FA01C; continue 'dispatch;
	}
	// 822F9FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822F9FFC: 3BFF0088  addi r31, r31, 0x88
	ctx.r[31].s64 = ctx.r[31].s64 + 136;
	// 822FA000: 48D0E129  bl 0x83008128
	ctx.lr = 0x822FA004;
	sub_83008128(ctx, base);
	// 822FA004: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FA008: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FA00C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FA010: 48003E81  bl 0x822fde90
	ctx.lr = 0x822FA014;
	sub_822FDE90(ctx, base);
	// 822FA014: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822FA018: 4BFFFFC0  b 0x822f9fd8
	pc = 0x822F9FD8; continue 'dispatch;
	// 822FA01C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FA020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FA024: 419A0008  beq cr6, 0x822fa02c
	if ctx.cr[6].eq {
	pc = 0x822FA02C; continue 'dispatch;
	}
	// 822FA028: 4BFC6869  bl 0x822c0890
	ctx.lr = 0x822FA02C;
	sub_822C0890(ctx, base);
	// 822FA02C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822FA030: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FA034: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822FA038: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822FA03C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FA040: 48EAE17C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FA048 size=316
    let mut pc: u32 = 0x822FA048;
    'dispatch: loop {
        match pc {
            0x822FA048 => {
    //   block [0x822FA048..0x822FA184)
	// 822FA048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FA050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FA054: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 822FA058: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 822FA05C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FA060: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FA068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA06C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FA070: 4BFFF3B9  bl 0x822f9428
	ctx.lr = 0x822FA074;
	sub_822F9428(ctx, base);
	// 822FA074: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA07C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822FA080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA084: 4E800421  bctrl
	ctx.lr = 0x822FA088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA088: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA08C: 418200C4  beq 0x822fa150
	if ctx.cr[0].eq {
	pc = 0x822FA150; continue 'dispatch;
	}
	// 822FA090: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA094: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FA098: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA09C: C3AB08A4  lfs f29, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822FA0A0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822FA0A4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FA0A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA0AC: 4E800421  bctrl
	ctx.lr = 0x822FA0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA0B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA0B4: 4182003C  beq 0x822fa0f0
	if ctx.cr[0].eq {
	pc = 0x822FA0F0; continue 'dispatch;
	}
	// 822FA0B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA0BC: 488BC945  bl 0x82bb6a00
	ctx.lr = 0x822FA0C0;
	sub_82BB6A00(ctx, base);
	// 822FA0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA0C4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 822FA0C8: C03F00C0  lfs f1, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FA0CC: 4BFFFD1D  bl 0x822f9de8
	ctx.lr = 0x822FA0D0;
	sub_822F9DE8(ctx, base);
	// 822FA0D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA0D4: 4182001C  beq 0x822fa0f0
	if ctx.cr[0].eq {
	pc = 0x822FA0F0; continue 'dispatch;
	}
	// 822FA0D8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FA0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FA0E0: 419A0008  beq cr6, 0x822fa0e8
	if ctx.cr[6].eq {
	pc = 0x822FA0E8; continue 'dispatch;
	}
	// 822FA0E4: 4BFC67AD  bl 0x822c0890
	ctx.lr = 0x822FA0E8;
	sub_822C0890(ctx, base);
	// 822FA0E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822FA0EC: 48000078  b 0x822fa164
	pc = 0x822FA164; continue 'dispatch;
	// 822FA0F0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA0F4: 488BC945  bl 0x82bb6a38
	ctx.lr = 0x822FA0F8;
	sub_82BB6A38(ctx, base);
	// 822FA0F8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FA0FC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA100: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 822FA104: 488BC3BD  bl 0x82bb64c0
	ctx.lr = 0x822FA108;
	sub_82BB64C0(ctx, base);
	// 822FA108: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FA10C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FA110: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822FA114: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 822FA118: 4098001C  bge cr6, 0x822fa134
	if !ctx.cr[6].lt {
	pc = 0x822FA134; continue 'dispatch;
	}
	// 822FA11C: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 822FA120: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA124: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA128: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 822FA12C: 488BC8D5  bl 0x82bb6a00
	ctx.lr = 0x822FA130;
	sub_82BB6A00(ctx, base);
	// 822FA130: EFC1F82A  fadds f30, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 822FA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA138: C03F00C0  lfs f1, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FA13C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 822FA140: 4BFFFCA9  bl 0x822f9de8
	ctx.lr = 0x822FA144;
	sub_822F9DE8(ctx, base);
	// 822FA144: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA148: 4082FF90  bne 0x822fa0d8
	if !ctx.cr[0].eq {
	pc = 0x822FA0D8; continue 'dispatch;
	}
	// 822FA14C: D3FF00C0  stfs f31, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822FA150: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FA154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FA158: 419A0008  beq cr6, 0x822fa160
	if ctx.cr[6].eq {
	pc = 0x822FA160; continue 'dispatch;
	}
	// 822FA15C: 4BFC6735  bl 0x822c0890
	ctx.lr = 0x822FA160;
	sub_822C0890(ctx, base);
	// 822FA160: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822FA164: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FA168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FA16C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FA170: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FA174: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FA178: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FA17C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FA180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FA188 size=344
    let mut pc: u32 = 0x822FA188;
    'dispatch: loop {
        match pc {
            0x822FA188 => {
    //   block [0x822FA188..0x822FA2E0)
	// 822FA188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA18C: 48EADFDD  bl 0x831a8168
	ctx.lr = 0x822FA190;
	sub_831A8130(ctx, base);
	// 822FA190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FA198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA19C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FA1A0: 4BFFF289  bl 0x822f9428
	ctx.lr = 0x822FA1A4;
	sub_822F9428(ctx, base);
	// 822FA1A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA1A8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FA1AC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822FA1B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA1B4: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822FA1B8: 695F0001  xori r31, r10, 1
	ctx.r[31].u64 = ctx.r[10].u64 ^ 1;
	// 822FA1BC: 419A000C  beq cr6, 0x822fa1c8
	if ctx.cr[6].eq {
	pc = 0x822FA1C8; continue 'dispatch;
	}
	// 822FA1C0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FA1C4: 4BFC66CD  bl 0x822c0890
	ctx.lr = 0x822FA1C8;
	sub_822C0890(ctx, base);
	// 822FA1C8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA1CC: 41820068  beq 0x822fa234
	if ctx.cr[0].eq {
	pc = 0x822FA234; continue 'dispatch;
	}
	// 822FA1D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA1D4: 48E5A42D  bl 0x83154600
	ctx.lr = 0x822FA1D8;
	sub_83154600(ctx, base);
	// 822FA1D8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 822FA1DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FA1E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FA1E4: 4BFFF245  bl 0x822f9428
	ctx.lr = 0x822FA1E8;
	sub_822F9428(ctx, base);
	// 822FA1E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FA1EC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA1F0: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 822FA1F4: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA1F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA1FC: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA204: 4E800421  bctrl
	ctx.lr = 0x822FA208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA208: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FA20C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FA210: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 822FA214: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FA218: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FA21C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 822FA220: 4E800421  bctrl
	ctx.lr = 0x822FA224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA224: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FA228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FA22C: 419A0008  beq cr6, 0x822fa234
	if ctx.cr[6].eq {
	pc = 0x822FA234; continue 'dispatch;
	}
	// 822FA230: 4BFC6661  bl 0x822c0890
	ctx.lr = 0x822FA234;
	sub_822C0890(ctx, base);
	// 822FA234: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FA238: 9BBE0091  stb r29, 0x91(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(145 as u32), ctx.r[29].u8 ) };
	// 822FA23C: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FA240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA244: 409A000C  bne cr6, 0x822fa250
	if !ctx.cr[6].eq {
	pc = 0x822FA250; continue 'dispatch;
	}
	// 822FA248: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 822FA24C: 48000010  b 0x822fa25c
	pc = 0x822FA25C; continue 'dispatch;
	// 822FA250: 815E017C  lwz r10, 0x17c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 822FA254: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FA258: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822FA25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA260: 419A0060  beq cr6, 0x822fa2c0
	if ctx.cr[6].eq {
	pc = 0x822FA2C0; continue 'dispatch;
	}
	// 822FA264: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822FA268: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FA26C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822FA270: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA274: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA278: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FA27C: 419A0024  beq cr6, 0x822fa2a0
	if ctx.cr[6].eq {
	pc = 0x822FA2A0; continue 'dispatch;
	}
	// 822FA280: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FA284: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FA288: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FA28C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FA290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FA294: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FA298: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FA29C: 4082FFE8  bne 0x822fa284
	if !ctx.cr[0].eq {
	pc = 0x822FA284; continue 'dispatch;
	}
	// 822FA2A0: 4BFFFEE9  bl 0x822fa188
	ctx.lr = 0x822FA2A4;
	sub_822FA188(ctx, base);
	// 822FA2A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FA2A8: 419A000C  beq cr6, 0x822fa2b4
	if ctx.cr[6].eq {
	pc = 0x822FA2B4; continue 'dispatch;
	}
	// 822FA2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA2B0: 4BFC65E1  bl 0x822c0890
	ctx.lr = 0x822FA2B4;
	sub_822C0890(ctx, base);
	// 822FA2B4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822FA2B8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 822FA2BC: 4082FFAC  bne 0x822fa268
	if !ctx.cr[0].eq {
	pc = 0x822FA268; continue 'dispatch;
	}
	// 822FA2C0: 817E00B8  lwz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 822FA2C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA2C8: 419A0010  beq cr6, 0x822fa2d8
	if ctx.cr[6].eq {
	pc = 0x822FA2D8; continue 'dispatch;
	}
	// 822FA2CC: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 822FA2D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA2D4: 917E00BC  stw r11, 0xbc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 822FA2D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FA2DC: 48EADEDC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA2E0 size=136
    let mut pc: u32 = 0x822FA2E0;
    'dispatch: loop {
        match pc {
            0x822FA2E0 => {
    //   block [0x822FA2E0..0x822FA368)
	// 822FA2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA2E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FA2E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FA2EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA2F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FA2F4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FA2F8: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 822FA2FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA300: 48198009  bl 0x82492308
	ctx.lr = 0x822FA304;
	sub_82492308(ctx, base);
	// 822FA304: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FA308: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 822FA30C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FA310: 419A000C  beq cr6, 0x822fa31c
	if ctx.cr[6].eq {
	pc = 0x822FA31C; continue 'dispatch;
	}
	// 822FA314: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 822FA318: 4800003C  b 0x822fa354
	pc = 0x822FA354; continue 'dispatch;
	// 822FA31C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822FA320: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FA324: 3BEB2610  addi r31, r11, 0x2610
	ctx.r[31].s64 = ctx.r[11].s64 + 9744;
	// 822FA328: 816A2614  lwz r11, 0x2614(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9748 as u32) ) } as u64;
	// 822FA32C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822FA330: 40820020  bne 0x822fa350
	if !ctx.cr[0].eq {
	pc = 0x822FA350; continue 'dispatch;
	}
	// 822FA334: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822FA338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA33C: 916A2614  stw r11, 0x2614(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9748 as u32), ctx.r[11].u32 ) };
	// 822FA340: 48AF8DB1  bl 0x82df30f0
	ctx.lr = 0x822FA344;
	sub_82DF30F0(ctx, base);
	// 822FA344: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 822FA348: 386BEBD0  addi r3, r11, -0x1430
	ctx.r[3].s64 = ctx.r[11].s64 + -5168;
	// 822FA34C: 48EAE18D  bl 0x831a84d8
	ctx.lr = 0x822FA350;
	sub_831A84D8(ctx, base);
	// 822FA350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA354: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FA358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FA35C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FA360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FA364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA368 size=100
    let mut pc: u32 = 0x822FA368;
    'dispatch: loop {
        match pc {
            0x822FA368 => {
    //   block [0x822FA368..0x822FA3CC)
	// 822FA368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA36C: 48EADDFD  bl 0x831a8168
	ctx.lr = 0x822FA370;
	sub_831A8130(ctx, base);
	// 822FA370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA374: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FA378: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FA37C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822FA380: 897E0025  lbz r11, 0x25(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FA384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA388: 409A003C  bne cr6, 0x822fa3c4
	if !ctx.cr[6].eq {
	pc = 0x822FA3C4; continue 'dispatch;
	}
	// 822FA38C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822FA390: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FA394: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA398: 4BFFFFD1  bl 0x822fa368
	ctx.lr = 0x822FA39C;
	sub_822FA368(ctx, base);
	// 822FA39C: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 822FA3A0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA3A4: 48AF9085  bl 0x82df3428
	ctx.lr = 0x822FA3A8;
	sub_82DF3428(ctx, base);
	// 822FA3A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FA3AC: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FA3B0: 48AF7DD9  bl 0x82df2188
	ctx.lr = 0x822FA3B4;
	sub_82DF2188(ctx, base);
	// 822FA3B4: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FA3B8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822FA3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA3C0: 419AFFD0  beq cr6, 0x822fa390
	if ctx.cr[6].eq {
	pc = 0x822FA390; continue 'dispatch;
	}
	// 822FA3C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FA3C8: 48EADDF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA3D0 size=112
    let mut pc: u32 = 0x822FA3D0;
    'dispatch: loop {
        match pc {
            0x822FA3D0 => {
    //   block [0x822FA3D0..0x822FA440)
	// 822FA3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA3D4: 48EADD91  bl 0x831a8164
	ctx.lr = 0x822FA3D8;
	sub_831A8130(ctx, base);
	// 822FA3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA3DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FA3E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FA3E4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822FA3E8: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FA3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA3F0: 409A0048  bne cr6, 0x822fa438
	if !ctx.cr[6].eq {
	pc = 0x822FA438; continue 'dispatch;
	}
	// 822FA3F4: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 822FA3F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FA3FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA400: 4BFFFFD1  bl 0x822fa3d0
	ctx.lr = 0x822FA404;
	sub_822FA3D0(ctx, base);
	// 822FA404: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 822FA408: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 822FA40C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA410: 48AF9019  bl 0x82df3428
	ctx.lr = 0x822FA414;
	sub_82DF3428(ctx, base);
	// 822FA414: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FA418: 48AF9011  bl 0x82df3428
	ctx.lr = 0x822FA41C;
	sub_82DF3428(ctx, base);
	// 822FA41C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FA420: 807B110C  lwz r3, 0x110c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FA424: 48AF7D65  bl 0x82df2188
	ctx.lr = 0x822FA428;
	sub_82DF2188(ctx, base);
	// 822FA428: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FA42C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822FA430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA434: 419AFFC4  beq cr6, 0x822fa3f8
	if ctx.cr[6].eq {
	pc = 0x822FA3F8; continue 'dispatch;
	}
	// 822FA438: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FA43C: 48EADD78  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FA440 size=168
    let mut pc: u32 = 0x822FA440;
    'dispatch: loop {
        match pc {
            0x822FA440 => {
    //   block [0x822FA440..0x822FA4E8)
	// 822FA440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA444: 48EADD25  bl 0x831a8168
	ctx.lr = 0x822FA448;
	sub_831A8130(ctx, base);
	// 822FA448: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA44C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FA450: D03E00C4  stfs f1, 0xc4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822FA454: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FA458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA45C: 419A0010  beq cr6, 0x822fa46c
	if ctx.cr[6].eq {
	pc = 0x822FA46C; continue 'dispatch;
	}
	// 822FA460: 815E017C  lwz r10, 0x17c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 822FA464: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FA468: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822FA46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA470: 419A0070  beq cr6, 0x822fa4e0
	if ctx.cr[6].eq {
	pc = 0x822FA4E0; continue 'dispatch;
	}
	// 822FA474: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FA478: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822FA47C: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FA480: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822FA484: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA488: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA48C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FA490: 419A0024  beq cr6, 0x822fa4b4
	if ctx.cr[6].eq {
	pc = 0x822FA4B4; continue 'dispatch;
	}
	// 822FA494: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FA498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FA49C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FA4A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FA4A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FA4A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FA4AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FA4B0: 4082FFE8  bne 0x822fa498
	if !ctx.cr[0].eq {
	pc = 0x822FA498; continue 'dispatch;
	}
	// 822FA4B4: C01E00C8  lfs f0, 0xc8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FA4B8: C1BE00C4  lfs f13, 0xc4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FA4BC: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 822FA4C0: 4BFFF531  bl 0x822f99f0
	ctx.lr = 0x822FA4C4;
	sub_822F99F0(ctx, base);
	// 822FA4C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FA4C8: 419A000C  beq cr6, 0x822fa4d4
	if ctx.cr[6].eq {
	pc = 0x822FA4D4; continue 'dispatch;
	}
	// 822FA4CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA4D0: 4BFC63C1  bl 0x822c0890
	ctx.lr = 0x822FA4D4;
	sub_822C0890(ctx, base);
	// 822FA4D4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 822FA4D8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 822FA4DC: 4082FFA0  bne 0x822fa47c
	if !ctx.cr[0].eq {
	pc = 0x822FA47C; continue 'dispatch;
	}
	// 822FA4E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FA4E4: 48EADCD4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FA4E8 size=300
    let mut pc: u32 = 0x822FA4E8;
    'dispatch: loop {
        match pc {
            0x822FA4E8 => {
    //   block [0x822FA4E8..0x822FA614)
	// 822FA4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA4EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FA4F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FA4F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FA4F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA4FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FA500: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FA504: 3BDF00D8  addi r30, r31, 0xd8
	ctx.r[30].s64 = ctx.r[31].s64 + 216;
	// 822FA508: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 822FA50C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FA510: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA514: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 822FA518: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 822FA51C: 48E5A0E5  bl 0x83154600
	ctx.lr = 0x822FA520;
	sub_83154600(ctx, base);
	// 822FA520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FA524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA528: 482E31E1  bl 0x825dd708
	ctx.lr = 0x822FA52C;
	sub_825DD708(ctx, base);
	// 822FA52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA530: 48E5A0D1  bl 0x83154600
	ctx.lr = 0x822FA534;
	sub_83154600(ctx, base);
	// 822FA534: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FA538: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FA53C: 387F016C  addi r3, r31, 0x16c
	ctx.r[3].s64 = ctx.r[31].s64 + 364;
	// 822FA540: 48B645C1  bl 0x82e5eb00
	ctx.lr = 0x822FA544;
	sub_82E5EB00(ctx, base);
	// 822FA544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA548: 48B62151  bl 0x82e5c698
	ctx.lr = 0x822FA54C;
	sub_82E5C698(ctx, base);
	// 822FA54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA550: 48B5F1A9  bl 0x82e596f8
	ctx.lr = 0x822FA554;
	sub_82E596F8(ctx, base);
	// 822FA554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA558: 48B5F189  bl 0x82e596e0
	ctx.lr = 0x822FA55C;
	sub_82E596E0(ctx, base);
	// 822FA55C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA564: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FA568: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA56C: 4E800421  bctrl
	ctx.lr = 0x822FA570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FA574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA578: 48B5F419  bl 0x82e59990
	ctx.lr = 0x822FA57C;
	sub_82E59990(ctx, base);
	// 822FA57C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA580: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FA584: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822FA588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA58C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822FA590: 695E0001  xori r30, r10, 1
	ctx.r[30].u64 = ctx.r[10].u64 ^ 1;
	// 822FA594: 419A000C  beq cr6, 0x822fa5a0
	if ctx.cr[6].eq {
	pc = 0x822FA5A0; continue 'dispatch;
	}
	// 822FA598: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FA59C: 4BFC62F5  bl 0x822c0890
	ctx.lr = 0x822FA5A0;
	sub_822C0890(ctx, base);
	// 822FA5A0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA5A4: 4182003C  beq 0x822fa5e0
	if ctx.cr[0].eq {
	pc = 0x822FA5E0; continue 'dispatch;
	}
	// 822FA5A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FA5AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FA5B0: 48B5F3E1  bl 0x82e59990
	ctx.lr = 0x822FA5B4;
	sub_82E59990(ctx, base);
	// 822FA5B4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FA5B8: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FA5C0: 419A000C  beq cr6, 0x822fa5cc
	if ctx.cr[6].eq {
	pc = 0x822FA5CC; continue 'dispatch;
	}
	// 822FA5C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FA5C8: 4BFC62C9  bl 0x822c0890
	ctx.lr = 0x822FA5CC;
	sub_822C0890(ctx, base);
	// 822FA5CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA5D4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 822FA5D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA5DC: 4E800421  bctrl
	ctx.lr = 0x822FA5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA5E4: 4BFFF73D  bl 0x822f9d20
	ctx.lr = 0x822FA5E8;
	sub_822F9D20(ctx, base);
	// 822FA5E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FA5F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822FA5F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FA5F8: 4E800421  bctrl
	ctx.lr = 0x822FA5FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FA5FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FA600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FA604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FA608: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FA60C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FA610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA618 size=84
    let mut pc: u32 = 0x822FA618;
    'dispatch: loop {
        match pc {
            0x822FA618 => {
    //   block [0x822FA618..0x822FA66C)
	// 822FA618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FA620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FA624: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FA62C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA630: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA634: 4BFFFD35  bl 0x822fa368
	ctx.lr = 0x822FA638;
	sub_822FA368(ctx, base);
	// 822FA638: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA63C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FA640: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822FA644: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FA648: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA64C: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FA650: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA654: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FA658: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FA65C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FA660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FA664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FA668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA670 size=84
    let mut pc: u32 = 0x822FA670;
    'dispatch: loop {
        match pc {
            0x822FA670 => {
    //   block [0x822FA670..0x822FA6C4)
	// 822FA670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FA678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FA67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FA684: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA688: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA68C: 4BFFFD45  bl 0x822fa3d0
	ctx.lr = 0x822FA690;
	sub_822FA3D0(ctx, base);
	// 822FA690: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FA698: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822FA69C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FA6A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA6A4: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FA6A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA6AC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FA6B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FA6B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FA6B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FA6BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FA6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA6C8 size=548
    let mut pc: u32 = 0x822FA6C8;
    'dispatch: loop {
        match pc {
            0x822FA6C8 => {
    //   block [0x822FA6C8..0x822FA8EC)
	// 822FA6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA6CC: 48EADA95  bl 0x831a8160
	ctx.lr = 0x822FA6D0;
	sub_831A8130(ctx, base);
	// 822FA6D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA6D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FA6D8: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 822FA6DC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822FA6E0: 616BAAA9  ori r11, r11, 0xaaa9
	ctx.r[11].u64 = ctx.r[11].u64 | 43689;
	// 822FA6E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FA6E8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA6EC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FA6F0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822FA6F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA6F8: 41980048  blt cr6, 0x822fa740
	if ctx.cr[6].lt {
	pc = 0x822FA740; continue 'dispatch;
	}
	// 822FA6FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FA700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA704: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 822FA708: 4BFCB1C1  bl 0x822c58c8
	ctx.lr = 0x822FA70C;
	sub_822C58C8(ctx, base);
	// 822FA70C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FA710: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FA714: 4BFCB105  bl 0x822c5818
	ctx.lr = 0x822FA718;
	sub_822C5818(ctx, base);
	// 822FA718: 4BFC9B99  bl 0x822c42b0
	ctx.lr = 0x822FA71C;
	sub_822C42B0(ctx, base);
	// 822FA71C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FA720: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FA724: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 822FA728: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FA72C: 4BFCAD45  bl 0x822c5470
	ctx.lr = 0x822FA730;
	sub_822C5470(ctx, base);
	// 822FA730: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FA734: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FA738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA73C: 4BFCA5A5  bl 0x822c4ce0
	ctx.lr = 0x822FA740;
	sub_822C4CE0(ctx, base);
	// 822FA740: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA744: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822FA748: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FA74C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822FA750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FA754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA758: 4BFFEA41  bl 0x822f9198
	ctx.lr = 0x822FA75C;
	sub_822F9198(ctx, base);
	// 822FA75C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA760: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA764: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FA768: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FA76C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA770: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FA774: 409A0018  bne cr6, 0x822fa78c
	if !ctx.cr[6].eq {
	pc = 0x822FA78C; continue 'dispatch;
	}
	// 822FA778: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FA77C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA780: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA784: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA788: 4800003C  b 0x822fa7c4
	pc = 0x822FA7C4; continue 'dispatch;
	// 822FA78C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA790: 41820020  beq 0x822fa7b0
	if ctx.cr[0].eq {
	pc = 0x822FA7B0; continue 'dispatch;
	}
	// 822FA794: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA798: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA79C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA7A0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FA7A4: 409A0024  bne cr6, 0x822fa7c8
	if !ctx.cr[6].eq {
	pc = 0x822FA7C8; continue 'dispatch;
	}
	// 822FA7A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA7AC: 4800001C  b 0x822fa7c8
	pc = 0x822FA7C8; continue 'dispatch;
	// 822FA7B0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FA7B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA7B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA7BC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FA7C0: 409A0008  bne cr6, 0x822fa7c8
	if !ctx.cr[6].eq {
	pc = 0x822FA7C8; continue 'dispatch;
	}
	// 822FA7C4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FA7C8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA7CC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 822FA7D0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822FA7D4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822FA7D8: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FA7DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FA7E0: 409A00F0  bne cr6, 0x822fa8d0
	if !ctx.cr[6].eq {
	pc = 0x822FA8D0; continue 'dispatch;
	}
	// 822FA7E4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822FA7E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA7EC: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA7F0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA7F4: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822FA7F8: 409A0054  bne cr6, 0x822fa84c
	if !ctx.cr[6].eq {
	pc = 0x822FA84C; continue 'dispatch;
	}
	// 822FA7FC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA800: 892A0024  lbz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FA804: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FA808: 419A0054  beq cr6, 0x822fa85c
	if ctx.cr[6].eq {
	pc = 0x822FA85C; continue 'dispatch;
	}
	// 822FA80C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA810: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA814: 409A0010  bne cr6, 0x822fa824
	if !ctx.cr[6].eq {
	pc = 0x822FA824; continue 'dispatch;
	}
	// 822FA818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA81C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FA820: 4818FC29  bl 0x8248a448
	ctx.lr = 0x822FA824;
	sub_8248A448(ctx, base);
	// 822FA824: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA82C: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FA830: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA838: 9B6B0024  stb r27, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[27].u8 ) };
	// 822FA83C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA840: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA844: 4BFFE70D  bl 0x822f8f50
	ctx.lr = 0x822FA848;
	sub_822F8F50(ctx, base);
	// 822FA848: 48000074  b 0x822fa8bc
	pc = 0x822FA8BC; continue 'dispatch;
	// 822FA84C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA850: 892A0024  lbz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FA854: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FA858: 409A0028  bne cr6, 0x822fa880
	if !ctx.cr[6].eq {
	pc = 0x822FA880; continue 'dispatch;
	}
	// 822FA85C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA860: 9BA90024  stb r29, 0x24(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FA864: 9BAA0024  stb r29, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FA868: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA86C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA870: 9B6A0024  stb r27, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[27].u8 ) };
	// 822FA874: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA878: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA87C: 48000040  b 0x822fa8bc
	pc = 0x822FA8BC; continue 'dispatch;
	// 822FA880: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA884: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA888: 409A0010  bne cr6, 0x822fa898
	if !ctx.cr[6].eq {
	pc = 0x822FA898; continue 'dispatch;
	}
	// 822FA88C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA890: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FA894: 4BFFE6BD  bl 0x822f8f50
	ctx.lr = 0x822FA898;
	sub_822F8F50(ctx, base);
	// 822FA898: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA89C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA8A0: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FA8A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8AC: 9B6B0024  stb r27, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[27].u8 ) };
	// 822FA8B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8B4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8B8: 4818FB91  bl 0x8248a448
	ctx.lr = 0x822FA8BC;
	sub_8248A448(ctx, base);
	// 822FA8BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8C0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FA8C4: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FA8C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FA8CC: 419AFF1C  beq cr6, 0x822fa7e8
	if ctx.cr[6].eq {
	pc = 0x822FA7E8; continue 'dispatch;
	}
	// 822FA8D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8D4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FA8D8: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA8DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA8E0: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FA8E4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822FA8E8: 48EAD8C8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FA8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FA8F0 size=548
    let mut pc: u32 = 0x822FA8F0;
    'dispatch: loop {
        match pc {
            0x822FA8F0 => {
    //   block [0x822FA8F0..0x822FAB14)
	// 822FA8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FA8F4: 48EAD86D  bl 0x831a8160
	ctx.lr = 0x822FA8F8;
	sub_831A8130(ctx, base);
	// 822FA8F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FA8FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FA900: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 822FA904: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822FA908: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 822FA90C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FA910: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA914: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FA918: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822FA91C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA920: 41980048  blt cr6, 0x822fa968
	if ctx.cr[6].lt {
	pc = 0x822FA968; continue 'dispatch;
	}
	// 822FA924: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FA928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA92C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 822FA930: 4BFCAF99  bl 0x822c58c8
	ctx.lr = 0x822FA934;
	sub_822C58C8(ctx, base);
	// 822FA934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FA938: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FA93C: 4BFCAEDD  bl 0x822c5818
	ctx.lr = 0x822FA940;
	sub_822C5818(ctx, base);
	// 822FA940: 4BFC9971  bl 0x822c42b0
	ctx.lr = 0x822FA944;
	sub_822C42B0(ctx, base);
	// 822FA944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FA948: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FA94C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 822FA950: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FA954: 4BFCAB1D  bl 0x822c5470
	ctx.lr = 0x822FA958;
	sub_822C5470(ctx, base);
	// 822FA958: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FA95C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FA960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FA964: 4BFCA37D  bl 0x822c4ce0
	ctx.lr = 0x822FA968;
	sub_822C4CE0(ctx, base);
	// 822FA968: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA96C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822FA970: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FA974: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822FA978: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FA97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FA980: 4BFFE891  bl 0x822f9210
	ctx.lr = 0x822FA984;
	sub_822F9210(ctx, base);
	// 822FA984: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA988: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA98C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FA990: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FA994: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FA998: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FA99C: 409A0018  bne cr6, 0x822fa9b4
	if !ctx.cr[6].eq {
	pc = 0x822FA9B4; continue 'dispatch;
	}
	// 822FA9A0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FA9A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA9A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA9AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA9B0: 4800003C  b 0x822fa9ec
	pc = 0x822FA9EC; continue 'dispatch;
	// 822FA9B4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FA9B8: 41820020  beq 0x822fa9d8
	if ctx.cr[0].eq {
	pc = 0x822FA9D8; continue 'dispatch;
	}
	// 822FA9BC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA9C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA9C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FA9C8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FA9CC: 409A0024  bne cr6, 0x822fa9f0
	if !ctx.cr[6].eq {
	pc = 0x822FA9F0; continue 'dispatch;
	}
	// 822FA9D0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FA9D4: 4800001C  b 0x822fa9f0
	pc = 0x822FA9F0; continue 'dispatch;
	// 822FA9D8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FA9DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA9E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FA9E4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FA9E8: 409A0008  bne cr6, 0x822fa9f0
	if !ctx.cr[6].eq {
	pc = 0x822FA9F0; continue 'dispatch;
	}
	// 822FA9EC: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FA9F0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FA9F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 822FA9F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822FA9FC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822FAA00: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FAA04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAA08: 409A00F0  bne cr6, 0x822faaf8
	if !ctx.cr[6].eq {
	pc = 0x822FAAF8; continue 'dispatch;
	}
	// 822FAA0C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822FAA10: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAA14: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA18: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAA1C: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822FAA20: 409A0054  bne cr6, 0x822faa74
	if !ctx.cr[6].eq {
	pc = 0x822FAA74; continue 'dispatch;
	}
	// 822FAA24: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAA28: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FAA2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FAA30: 419A0054  beq cr6, 0x822faa84
	if ctx.cr[6].eq {
	pc = 0x822FAA84; continue 'dispatch;
	}
	// 822FAA34: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAA38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FAA3C: 409A0010  bne cr6, 0x822faa4c
	if !ctx.cr[6].eq {
	pc = 0x822FAA4C; continue 'dispatch;
	}
	// 822FAA40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FAA44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FAA48: 488BC189  bl 0x82bb6bd0
	ctx.lr = 0x822FAA4C;
	sub_82BB6BD0(ctx, base);
	// 822FAA4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FAA54: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FAA58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA60: 9B6B0014  stb r27, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 822FAA64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA68: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA6C: 4BFF3AA5  bl 0x822ee510
	ctx.lr = 0x822FAA70;
	sub_822EE510(ctx, base);
	// 822FAA70: 48000074  b 0x822faae4
	pc = 0x822FAAE4; continue 'dispatch;
	// 822FAA74: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAA78: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FAA7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FAA80: 409A0028  bne cr6, 0x822faaa8
	if !ctx.cr[6].eq {
	pc = 0x822FAAA8; continue 'dispatch;
	}
	// 822FAA84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAA88: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FAA8C: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FAA90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAA94: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAA98: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 822FAA9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAAA0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAA4: 48000040  b 0x822faae4
	pc = 0x822FAAE4; continue 'dispatch;
	// 822FAAA8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAAAC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FAAB0: 409A0010  bne cr6, 0x822faac0
	if !ctx.cr[6].eq {
	pc = 0x822FAAC0; continue 'dispatch;
	}
	// 822FAAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FAAB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FAABC: 4BFF3A55  bl 0x822ee510
	ctx.lr = 0x822FAAC0;
	sub_822EE510(ctx, base);
	// 822FAAC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FAAC8: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FAACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAD4: 9B6B0014  stb r27, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 822FAAD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAADC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAE0: 488BC0F1  bl 0x82bb6bd0
	ctx.lr = 0x822FAAE4;
	sub_82BB6BD0(ctx, base);
	// 822FAAE4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAE8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FAAEC: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FAAF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAAF4: 419AFF1C  beq cr6, 0x822faa10
	if ctx.cr[6].eq {
	pc = 0x822FAA10; continue 'dispatch;
	}
	// 822FAAF8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAAFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAB00: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FAB04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAB08: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FAB0C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822FAB10: 48EAD6A0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FAB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FAB18 size=1024
    let mut pc: u32 = 0x822FAB18;
    'dispatch: loop {
        match pc {
            0x822FAB18 => {
    //   block [0x822FAB18..0x822FAF18)
	// 822FAB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FAB1C: 48EAD63D  bl 0x831a8158
	ctx.lr = 0x822FAB20;
	sub_831A8130(ctx, base);
	// 822FAB20: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FAB24: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FAB28: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822FAB2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FAB30: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 822FAB34: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAB38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAB3C: 419A0048  beq cr6, 0x822fab84
	if ctx.cr[6].eq {
	pc = 0x822FAB84; continue 'dispatch;
	}
	// 822FAB40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FAB44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FAB48: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 822FAB4C: 4BFCAD7D  bl 0x822c58c8
	ctx.lr = 0x822FAB50;
	sub_822C58C8(ctx, base);
	// 822FAB50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FAB54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FAB58: 4BFCF359  bl 0x822c9eb0
	ctx.lr = 0x822FAB5C;
	sub_822C9EB0(ctx, base);
	// 822FAB5C: 4BFC9755  bl 0x822c42b0
	ctx.lr = 0x822FAB60;
	sub_822C42B0(ctx, base);
	// 822FAB60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FAB64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FAB68: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 822FAB6C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FAB70: 4BFCA901  bl 0x822c5470
	ctx.lr = 0x822FAB74;
	sub_822C5470(ctx, base);
	// 822FAB74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FAB78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FAB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FAB80: 4BFCA161  bl 0x822c4ce0
	ctx.lr = 0x822FAB84;
	sub_822C4CE0(ctx, base);
	// 822FAB84: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 822FAB88: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822FAB8C: 4818F845  bl 0x8248a3d0
	ctx.lr = 0x822FAB90;
	sub_8248A3D0(ctx, base);
	// 822FAB90: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAB94: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAB98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAB9C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822FABA0: 419A000C  beq cr6, 0x822fabac
	if ctx.cr[6].eq {
	pc = 0x822FABAC; continue 'dispatch;
	}
	// 822FABA4: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FABA8: 48000028  b 0x822fabd0
	pc = 0x822FABD0; continue 'dispatch;
	// 822FABAC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FABB0: 894A0025  lbz r10, 0x25(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FABB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FABB8: 419A000C  beq cr6, 0x822fabc4
	if ctx.cr[6].eq {
	pc = 0x822FABC4; continue 'dispatch;
	}
	// 822FABBC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822FABC0: 48000010  b 0x822fabd0
	pc = 0x822FABD0; continue 'dispatch;
	// 822FABC4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FABC8: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FABCC: 409A00DC  bne cr6, 0x822faca8
	if !ctx.cr[6].eq {
	pc = 0x822FACA8; continue 'dispatch;
	}
	// 822FABD0: 897C0025  lbz r11, 0x25(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FABD4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FABD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FABDC: 409A0008  bne cr6, 0x822fabe4
	if !ctx.cr[6].eq {
	pc = 0x822FABE4; continue 'dispatch;
	}
	// 822FABE0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FABE4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FABE8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FABEC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FABF0: 409A000C  bne cr6, 0x822fabfc
	if !ctx.cr[6].eq {
	pc = 0x822FABFC; continue 'dispatch;
	}
	// 822FABF4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FABF8: 4800001C  b 0x822fac14
	pc = 0x822FAC14; continue 'dispatch;
	// 822FABFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAC00: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAC04: 409A000C  bne cr6, 0x822fac10
	if !ctx.cr[6].eq {
	pc = 0x822FAC10; continue 'dispatch;
	}
	// 822FAC08: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FAC0C: 48000008  b 0x822fac14
	pc = 0x822FAC14; continue 'dispatch;
	// 822FAC10: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FAC14: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAC18: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAC1C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAC20: 409A003C  bne cr6, 0x822fac5c
	if !ctx.cr[6].eq {
	pc = 0x822FAC5C; continue 'dispatch;
	}
	// 822FAC24: 897C0025  lbz r11, 0x25(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAC28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAC2C: 419A000C  beq cr6, 0x822fac38
	if ctx.cr[6].eq {
	pc = 0x822FAC38; continue 'dispatch;
	}
	// 822FAC30: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FAC34: 48000024  b 0x822fac58
	pc = 0x822FAC58; continue 'dispatch;
	// 822FAC38: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAC3C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FAC40: 4800000C  b 0x822fac4c
	pc = 0x822FAC4C; continue 'dispatch;
	// 822FAC44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FAC48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAC4C: 890B0025  lbz r8, 0x25(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAC50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FAC54: 419AFFF0  beq cr6, 0x822fac44
	if ctx.cr[6].eq {
	pc = 0x822FAC44; continue 'dispatch;
	}
	// 822FAC58: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FAC5C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAC60: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAC64: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAC68: 409A00D4  bne cr6, 0x822fad3c
	if !ctx.cr[6].eq {
	pc = 0x822FAD3C; continue 'dispatch;
	}
	// 822FAC6C: 897C0025  lbz r11, 0x25(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAC70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAC74: 419A000C  beq cr6, 0x822fac80
	if ctx.cr[6].eq {
	pc = 0x822FAC80; continue 'dispatch;
	}
	// 822FAC78: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FAC7C: 48000024  b 0x822faca0
	pc = 0x822FACA0; continue 'dispatch;
	// 822FAC80: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAC84: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FAC88: 4800000C  b 0x822fac94
	pc = 0x822FAC94; continue 'dispatch;
	// 822FAC8C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FAC90: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAC94: 890B0025  lbz r8, 0x25(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAC98: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FAC9C: 419AFFF0  beq cr6, 0x822fac8c
	if ctx.cr[6].eq {
	pc = 0x822FAC8C; continue 'dispatch;
	}
	// 822FACA0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FACA4: 48000098  b 0x822fad3c
	pc = 0x822FAD3C; continue 'dispatch;
	// 822FACA8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FACAC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FACB0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FACB4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FACB8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FACBC: 409A000C  bne cr6, 0x822facc8
	if !ctx.cr[6].eq {
	pc = 0x822FACC8; continue 'dispatch;
	}
	// 822FACC0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822FACC4: 4800002C  b 0x822facf0
	pc = 0x822FACF0; continue 'dispatch;
	// 822FACC8: 897C0025  lbz r11, 0x25(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FACCC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FACD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FACD4: 409A0008  bne cr6, 0x822facdc
	if !ctx.cr[6].eq {
	pc = 0x822FACDC; continue 'dispatch;
	}
	// 822FACD8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FACDC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FACE0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FACE4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FACE8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FACEC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FACF0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FACF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FACF8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FACFC: 409A000C  bne cr6, 0x822fad08
	if !ctx.cr[6].eq {
	pc = 0x822FAD08; continue 'dispatch;
	}
	// 822FAD00: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FAD04: 48000020  b 0x822fad24
	pc = 0x822FAD24; continue 'dispatch;
	// 822FAD08: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAD0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAD10: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAD14: 409A000C  bne cr6, 0x822fad20
	if !ctx.cr[6].eq {
	pc = 0x822FAD20; continue 'dispatch;
	}
	// 822FAD18: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FAD1C: 48000008  b 0x822fad24
	pc = 0x822FAD24; continue 'dispatch;
	// 822FAD20: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 822FAD24: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAD28: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FAD2C: 897B0024  lbz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAD30: 89590024  lbz r10, 0x24(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAD34: 99790024  stb r11, 0x24(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 822FAD38: 995B0024  stb r10, 0x24(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 822FAD3C: 897B0024  lbz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAD40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FAD44: 409A0198  bne cr6, 0x822faedc
	if !ctx.cr[6].eq {
	pc = 0x822FAEDC; continue 'dispatch;
	}
	// 822FAD48: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAD4C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822FAD50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAD54: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FAD58: 419A0180  beq cr6, 0x822faed8
	if ctx.cr[6].eq {
	pc = 0x822FAED8; continue 'dispatch;
	}
	// 822FAD5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FAD60: 897C0024  lbz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAD64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FAD68: 409A0170  bne cr6, 0x822faed8
	if !ctx.cr[6].eq {
	pc = 0x822FAED8; continue 'dispatch;
	}
	// 822FAD6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAD70: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FAD74: 409A00A8  bne cr6, 0x822fae1c
	if !ctx.cr[6].eq {
	pc = 0x822FAE1C; continue 'dispatch;
	}
	// 822FAD78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAD7C: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAD80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAD84: 409A001C  bne cr6, 0x822fada0
	if !ctx.cr[6].eq {
	pc = 0x822FADA0; continue 'dispatch;
	}
	// 822FAD88: 9BCB0024  stb r30, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAD8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FAD90: 9BBF0024  stb r29, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FAD94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAD98: 4818F6B1  bl 0x8248a448
	ctx.lr = 0x822FAD9C;
	sub_8248A448(ctx, base);
	// 822FAD9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FADA0: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FADA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FADA8: 409A00C8  bne cr6, 0x822fae70
	if !ctx.cr[6].eq {
	pc = 0x822FAE70; continue 'dispatch;
	}
	// 822FADAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FADB0: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FADB4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FADB8: 409A0014  bne cr6, 0x822fadcc
	if !ctx.cr[6].eq {
	pc = 0x822FADCC; continue 'dispatch;
	}
	// 822FADBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FADC0: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FADC4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FADC8: 419A00A4  beq cr6, 0x822fae6c
	if ctx.cr[6].eq {
	pc = 0x822FAE6C; continue 'dispatch;
	}
	// 822FADCC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FADD0: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FADD4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FADD8: 409A0020  bne cr6, 0x822fadf8
	if !ctx.cr[6].eq {
	pc = 0x822FADF8; continue 'dispatch;
	}
	// 822FADDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FADE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FADE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FADE8: 9BCA0024  stb r30, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FADEC: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FADF0: 4BFFE161  bl 0x822f8f50
	ctx.lr = 0x822FADF4;
	sub_822F8F50(ctx, base);
	// 822FADF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FADF8: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FADFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FAE00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAE04: 994B0024  stb r10, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 822FAE08: 9BDF0024  stb r30, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAE0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAE10: 9BCB0024  stb r30, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAE14: 4818F635  bl 0x8248a448
	ctx.lr = 0x822FAE18;
	sub_8248A448(ctx, base);
	// 822FAE18: 480000C0  b 0x822faed8
	pc = 0x822FAED8; continue 'dispatch;
	// 822FAE1C: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAE20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAE24: 409A001C  bne cr6, 0x822fae40
	if !ctx.cr[6].eq {
	pc = 0x822FAE40; continue 'dispatch;
	}
	// 822FAE28: 9BCB0024  stb r30, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAE2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FAE30: 9BBF0024  stb r29, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FAE34: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAE38: 4BFFE119  bl 0x822f8f50
	ctx.lr = 0x822FAE3C;
	sub_822F8F50(ctx, base);
	// 822FAE3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAE40: 894B0025  lbz r10, 0x25(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FAE44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAE48: 409A0028  bne cr6, 0x822fae70
	if !ctx.cr[6].eq {
	pc = 0x822FAE70; continue 'dispatch;
	}
	// 822FAE4C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAE50: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAE54: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FAE58: 409A0034  bne cr6, 0x822fae8c
	if !ctx.cr[6].eq {
	pc = 0x822FAE8C; continue 'dispatch;
	}
	// 822FAE5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAE60: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAE64: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FAE68: 409A0024  bne cr6, 0x822fae8c
	if !ctx.cr[6].eq {
	pc = 0x822FAE8C; continue 'dispatch;
	}
	// 822FAE6C: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FAE70: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAE74: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 822FAE78: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAE7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAE80: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FAE84: 409AFEDC  bne cr6, 0x822fad60
	if !ctx.cr[6].eq {
	pc = 0x822FAD60; continue 'dispatch;
	}
	// 822FAE88: 48000050  b 0x822faed8
	pc = 0x822FAED8; continue 'dispatch;
	// 822FAE8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAE90: 894A0024  lbz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAE94: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FAE98: 409A0020  bne cr6, 0x822faeb8
	if !ctx.cr[6].eq {
	pc = 0x822FAEB8; continue 'dispatch;
	}
	// 822FAE9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAEA0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FAEA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAEA8: 9BCA0024  stb r30, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAEAC: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 822FAEB0: 4818F599  bl 0x8248a448
	ctx.lr = 0x822FAEB4;
	sub_8248A448(ctx, base);
	// 822FAEB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAEB8: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 822FAEBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FAEC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FAEC4: 994B0024  stb r10, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 822FAEC8: 9BDF0024  stb r30, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAECC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAED0: 9BCB0024  stb r30, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAED4: 4BFFE07D  bl 0x822f8f50
	ctx.lr = 0x822FAED8;
	sub_822F8F50(ctx, base);
	// 822FAED8: 9BDC0024  stb r30, 0x24(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 822FAEDC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 822FAEE0: 48AF8549  bl 0x82df3428
	ctx.lr = 0x822FAEE4;
	sub_82DF3428(ctx, base);
	// 822FAEE4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FAEE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FAEEC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FAEF0: 48AF7299  bl 0x82df2188
	ctx.lr = 0x822FAEF4;
	sub_82DF2188(ctx, base);
	// 822FAEF4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAEFC: 419A000C  beq cr6, 0x822faf08
	if ctx.cr[6].eq {
	pc = 0x822FAF08; continue 'dispatch;
	}
	// 822FAF00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822FAF04: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FAF08: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FAF0C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822FAF10: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822FAF14: 48EAD294  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FAF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FAF18 size=1036
    let mut pc: u32 = 0x822FAF18;
    'dispatch: loop {
        match pc {
            0x822FAF18 => {
    //   block [0x822FAF18..0x822FB324)
	// 822FAF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FAF1C: 48EAD23D  bl 0x831a8158
	ctx.lr = 0x822FAF20;
	sub_831A8130(ctx, base);
	// 822FAF20: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FAF24: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FAF28: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822FAF2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FAF30: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 822FAF34: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FAF38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAF3C: 419A0048  beq cr6, 0x822faf84
	if ctx.cr[6].eq {
	pc = 0x822FAF84; continue 'dispatch;
	}
	// 822FAF40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FAF44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FAF48: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 822FAF4C: 4BFCA97D  bl 0x822c58c8
	ctx.lr = 0x822FAF50;
	sub_822C58C8(ctx, base);
	// 822FAF50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FAF54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FAF58: 4BFCEF59  bl 0x822c9eb0
	ctx.lr = 0x822FAF5C;
	sub_822C9EB0(ctx, base);
	// 822FAF5C: 4BFC9355  bl 0x822c42b0
	ctx.lr = 0x822FAF60;
	sub_822C42B0(ctx, base);
	// 822FAF60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FAF64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FAF68: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 822FAF6C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FAF70: 4BFCA501  bl 0x822c5470
	ctx.lr = 0x822FAF74;
	sub_822C5470(ctx, base);
	// 822FAF74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FAF78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FAF7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FAF80: 4BFC9D61  bl 0x822c4ce0
	ctx.lr = 0x822FAF84;
	sub_822C4CE0(ctx, base);
	// 822FAF84: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 822FAF88: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822FAF8C: 481EE105  bl 0x824e9090
	ctx.lr = 0x822FAF90;
	sub_824E9090(ctx, base);
	// 822FAF90: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FAF94: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FAF98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAF9C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822FAFA0: 419A000C  beq cr6, 0x822fafac
	if ctx.cr[6].eq {
	pc = 0x822FAFAC; continue 'dispatch;
	}
	// 822FAFA4: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAFA8: 48000028  b 0x822fafd0
	pc = 0x822FAFD0; continue 'dispatch;
	// 822FAFAC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAFB0: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FAFB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FAFB8: 419A000C  beq cr6, 0x822fafc4
	if ctx.cr[6].eq {
	pc = 0x822FAFC4; continue 'dispatch;
	}
	// 822FAFBC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822FAFC0: 48000010  b 0x822fafd0
	pc = 0x822FAFD0; continue 'dispatch;
	// 822FAFC4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FAFC8: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAFCC: 409A00DC  bne cr6, 0x822fb0a8
	if !ctx.cr[6].eq {
	pc = 0x822FB0A8; continue 'dispatch;
	}
	// 822FAFD0: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FAFD4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAFD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FAFDC: 409A0008  bne cr6, 0x822fafe4
	if !ctx.cr[6].eq {
	pc = 0x822FAFE4; continue 'dispatch;
	}
	// 822FAFE0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FAFE4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAFE8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FAFEC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FAFF0: 409A000C  bne cr6, 0x822faffc
	if !ctx.cr[6].eq {
	pc = 0x822FAFFC; continue 'dispatch;
	}
	// 822FAFF4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FAFF8: 4800001C  b 0x822fb014
	pc = 0x822FB014; continue 'dispatch;
	// 822FAFFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB000: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FB004: 409A000C  bne cr6, 0x822fb010
	if !ctx.cr[6].eq {
	pc = 0x822FB010; continue 'dispatch;
	}
	// 822FB008: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FB00C: 48000008  b 0x822fb014
	pc = 0x822FB014; continue 'dispatch;
	// 822FB010: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FB014: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB018: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB01C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FB020: 409A003C  bne cr6, 0x822fb05c
	if !ctx.cr[6].eq {
	pc = 0x822FB05C; continue 'dispatch;
	}
	// 822FB024: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB02C: 419A000C  beq cr6, 0x822fb038
	if ctx.cr[6].eq {
	pc = 0x822FB038; continue 'dispatch;
	}
	// 822FB030: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FB034: 48000024  b 0x822fb058
	pc = 0x822FB058; continue 'dispatch;
	// 822FB038: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB03C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FB040: 4800000C  b 0x822fb04c
	pc = 0x822FB04C; continue 'dispatch;
	// 822FB044: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FB048: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB04C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB050: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FB054: 419AFFF0  beq cr6, 0x822fb044
	if ctx.cr[6].eq {
	pc = 0x822FB044; continue 'dispatch;
	}
	// 822FB058: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FB05C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB060: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB064: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FB068: 409A00D4  bne cr6, 0x822fb13c
	if !ctx.cr[6].eq {
	pc = 0x822FB13C; continue 'dispatch;
	}
	// 822FB06C: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB074: 419A000C  beq cr6, 0x822fb080
	if ctx.cr[6].eq {
	pc = 0x822FB080; continue 'dispatch;
	}
	// 822FB078: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FB07C: 48000024  b 0x822fb0a0
	pc = 0x822FB0A0; continue 'dispatch;
	// 822FB080: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB084: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FB088: 4800000C  b 0x822fb094
	pc = 0x822FB094; continue 'dispatch;
	// 822FB08C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FB090: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB094: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB098: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FB09C: 419AFFF0  beq cr6, 0x822fb08c
	if ctx.cr[6].eq {
	pc = 0x822FB08C; continue 'dispatch;
	}
	// 822FB0A0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FB0A4: 48000098  b 0x822fb13c
	pc = 0x822FB13C; continue 'dispatch;
	// 822FB0A8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FB0AC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB0B0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FB0B4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB0B8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB0BC: 409A000C  bne cr6, 0x822fb0c8
	if !ctx.cr[6].eq {
	pc = 0x822FB0C8; continue 'dispatch;
	}
	// 822FB0C0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822FB0C4: 4800002C  b 0x822fb0f0
	pc = 0x822FB0F0; continue 'dispatch;
	// 822FB0C8: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB0CC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB0D4: 409A0008  bne cr6, 0x822fb0dc
	if !ctx.cr[6].eq {
	pc = 0x822FB0DC; continue 'dispatch;
	}
	// 822FB0D8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FB0DC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FB0E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB0E4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FB0E8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB0EC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FB0F0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB0F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB0F8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FB0FC: 409A000C  bne cr6, 0x822fb108
	if !ctx.cr[6].eq {
	pc = 0x822FB108; continue 'dispatch;
	}
	// 822FB100: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FB104: 48000020  b 0x822fb124
	pc = 0x822FB124; continue 'dispatch;
	// 822FB108: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB10C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB110: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FB114: 409A000C  bne cr6, 0x822fb120
	if !ctx.cr[6].eq {
	pc = 0x822FB120; continue 'dispatch;
	}
	// 822FB118: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FB11C: 48000008  b 0x822fb124
	pc = 0x822FB124; continue 'dispatch;
	// 822FB120: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 822FB124: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB128: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FB12C: 897B0014  lbz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB130: 89590014  lbz r10, 0x14(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB134: 99790014  stb r11, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 822FB138: 995B0014  stb r10, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 822FB13C: 897B0014  lbz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB140: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FB144: 409A0198  bne cr6, 0x822fb2dc
	if !ctx.cr[6].eq {
	pc = 0x822FB2DC; continue 'dispatch;
	}
	// 822FB148: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB14C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822FB150: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB154: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB158: 419A0180  beq cr6, 0x822fb2d8
	if ctx.cr[6].eq {
	pc = 0x822FB2D8; continue 'dispatch;
	}
	// 822FB15C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FB160: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB164: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FB168: 409A0170  bne cr6, 0x822fb2d8
	if !ctx.cr[6].eq {
	pc = 0x822FB2D8; continue 'dispatch;
	}
	// 822FB16C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB170: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB174: 409A00A8  bne cr6, 0x822fb21c
	if !ctx.cr[6].eq {
	pc = 0x822FB21C; continue 'dispatch;
	}
	// 822FB178: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB17C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FB184: 409A001C  bne cr6, 0x822fb1a0
	if !ctx.cr[6].eq {
	pc = 0x822FB1A0; continue 'dispatch;
	}
	// 822FB188: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB18C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB190: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FB194: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB198: 488BBA39  bl 0x82bb6bd0
	ctx.lr = 0x822FB19C;
	sub_82BB6BD0(ctx, base);
	// 822FB19C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB1A0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB1A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FB1A8: 409A00C8  bne cr6, 0x822fb270
	if !ctx.cr[6].eq {
	pc = 0x822FB270; continue 'dispatch;
	}
	// 822FB1AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB1B0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB1B4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB1B8: 409A0014  bne cr6, 0x822fb1cc
	if !ctx.cr[6].eq {
	pc = 0x822FB1CC; continue 'dispatch;
	}
	// 822FB1BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB1C0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB1C4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB1C8: 419A00A4  beq cr6, 0x822fb26c
	if ctx.cr[6].eq {
	pc = 0x822FB26C; continue 'dispatch;
	}
	// 822FB1CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB1D0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB1D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB1D8: 409A0020  bne cr6, 0x822fb1f8
	if !ctx.cr[6].eq {
	pc = 0x822FB1F8; continue 'dispatch;
	}
	// 822FB1DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB1E0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FB1E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB1E8: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB1EC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FB1F0: 4BFF3321  bl 0x822ee510
	ctx.lr = 0x822FB1F4;
	sub_822EE510(ctx, base);
	// 822FB1F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB1F8: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB1FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB200: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB204: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 822FB208: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB20C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB210: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB214: 488BB9BD  bl 0x82bb6bd0
	ctx.lr = 0x822FB218;
	sub_82BB6BD0(ctx, base);
	// 822FB218: 480000C0  b 0x822fb2d8
	pc = 0x822FB2D8; continue 'dispatch;
	// 822FB21C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB220: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FB224: 409A001C  bne cr6, 0x822fb240
	if !ctx.cr[6].eq {
	pc = 0x822FB240; continue 'dispatch;
	}
	// 822FB228: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB22C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB230: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FB234: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB238: 4BFF32D9  bl 0x822ee510
	ctx.lr = 0x822FB23C;
	sub_822EE510(ctx, base);
	// 822FB23C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB240: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FB248: 409A0028  bne cr6, 0x822fb270
	if !ctx.cr[6].eq {
	pc = 0x822FB270; continue 'dispatch;
	}
	// 822FB24C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB250: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB254: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB258: 409A0034  bne cr6, 0x822fb28c
	if !ctx.cr[6].eq {
	pc = 0x822FB28C; continue 'dispatch;
	}
	// 822FB25C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB260: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB264: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB268: 409A0024  bne cr6, 0x822fb28c
	if !ctx.cr[6].eq {
	pc = 0x822FB28C; continue 'dispatch;
	}
	// 822FB26C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FB270: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB274: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 822FB278: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB27C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB280: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB284: 409AFEDC  bne cr6, 0x822fb160
	if !ctx.cr[6].eq {
	pc = 0x822FB160; continue 'dispatch;
	}
	// 822FB288: 48000050  b 0x822fb2d8
	pc = 0x822FB2D8; continue 'dispatch;
	// 822FB28C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB290: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB294: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FB298: 409A0020  bne cr6, 0x822fb2b8
	if !ctx.cr[6].eq {
	pc = 0x822FB2B8; continue 'dispatch;
	}
	// 822FB29C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB2A0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FB2A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB2A8: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB2AC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 822FB2B0: 488BB921  bl 0x82bb6bd0
	ctx.lr = 0x822FB2B4;
	sub_82BB6BD0(ctx, base);
	// 822FB2B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB2B8: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB2BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB2C0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB2C4: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 822FB2C8: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB2CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB2D0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB2D4: 4BFF323D  bl 0x822ee510
	ctx.lr = 0x822FB2D8;
	sub_822EE510(ctx, base);
	// 822FB2D8: 9BDC0014  stb r30, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 822FB2DC: 3BFB000C  addi r31, r27, 0xc
	ctx.r[31].s64 = ctx.r[27].s64 + 12;
	// 822FB2E0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 822FB2E4: 48AF8145  bl 0x82df3428
	ctx.lr = 0x822FB2E8;
	sub_82DF3428(ctx, base);
	// 822FB2E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB2EC: 48AF813D  bl 0x82df3428
	ctx.lr = 0x822FB2F0;
	sub_82DF3428(ctx, base);
	// 822FB2F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FB2F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FB2F8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FB2FC: 48AF6E8D  bl 0x82df2188
	ctx.lr = 0x822FB300;
	sub_82DF2188(ctx, base);
	// 822FB300: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB308: 419A000C  beq cr6, 0x822fb314
	if ctx.cr[6].eq {
	pc = 0x822FB314; continue 'dispatch;
	}
	// 822FB30C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822FB310: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FB314: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FB318: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822FB31C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822FB320: 48EACE88  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FB328 size=372
    let mut pc: u32 = 0x822FB328;
    'dispatch: loop {
        match pc {
            0x822FB328 => {
    //   block [0x822FB328..0x822FB49C)
	// 822FB328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB32C: 48EACE3D  bl 0x831a8168
	ctx.lr = 0x822FB330;
	sub_831A8130(ctx, base);
	// 822FB330: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822FB334: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB338: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FB33C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB344: 4BFFE0E5  bl 0x822f9428
	ctx.lr = 0x822FB348;
	sub_822F9428(ctx, base);
	// 822FB348: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FB34C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FB350: 419A0130  beq cr6, 0x822fb480
	if ctx.cr[6].eq {
	pc = 0x822FB480; continue 'dispatch;
	}
	// 822FB354: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB358: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 822FB35C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FB360: 4E800421  bctrl
	ctx.lr = 0x822FB364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FB364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB368: 41820118  beq 0x822fb480
	if ctx.cr[0].eq {
	pc = 0x822FB480; continue 'dispatch;
	}
	// 822FB36C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FB370: 488BB6C9  bl 0x82bb6a38
	ctx.lr = 0x822FB374;
	sub_82BB6A38(ctx, base);
	// 822FB374: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 822FB378: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FB37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB380: 419A0054  beq cr6, 0x822fb3d4
	if ctx.cr[6].eq {
	pc = 0x822FB3D4; continue 'dispatch;
	}
	// 822FB384: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 822FB388: 3B9F00BC  addi r28, r31, 0xbc
	ctx.r[28].s64 = ctx.r[31].s64 + 188;
	// 822FB38C: 4800003C  b 0x822fb3c8
	pc = 0x822FB3C8; continue 'dispatch;
	// 822FB390: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FB394: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822FB398: 4098003C  bge cr6, 0x822fb3d4
	if !ctx.cr[6].lt {
	pc = 0x822FB3D4; continue 'dispatch;
	}
	// 822FB39C: 83AB0018  lwz r29, 0x18(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 822FB3A0: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FB3A4: 48000010  b 0x822fb3b4
	pc = 0x822FB3B4; continue 'dispatch;
	// 822FB3A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FB3AC: 481582D5  bl 0x82453680
	ctx.lr = 0x822FB3B0;
	sub_82453680(ctx, base);
	// 822FB3B0: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822FB3B4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FB3B8: 409AFFF0  bne cr6, 0x822fb3a8
	if !ctx.cr[6].eq {
	pc = 0x822FB3A8; continue 'dispatch;
	}
	// 822FB3BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FB3C0: 484CDC71  bl 0x827c9030
	ctx.lr = 0x822FB3C4;
	sub_827C9030(ctx, base);
	// 822FB3C4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB3C8: 815F00B4  lwz r10, 0xb4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 822FB3CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FB3D0: 409AFFC0  bne cr6, 0x822fb390
	if !ctx.cr[6].eq {
	pc = 0x822FB390; continue 'dispatch;
	}
	// 822FB3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB3D8: 3BDF00D8  addi r30, r31, 0xd8
	ctx.r[30].s64 = ctx.r[31].s64 + 216;
	// 822FB3DC: 48B5E31D  bl 0x82e596f8
	ctx.lr = 0x822FB3E0;
	sub_82E596F8(ctx, base);
	// 822FB3E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FB3E4: 48B5E2FD  bl 0x82e596e0
	ctx.lr = 0x822FB3E8;
	sub_82E596E0(ctx, base);
	// 822FB3E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB3EC: 48B5E37D  bl 0x82e59768
	ctx.lr = 0x822FB3F0;
	sub_82E59768(ctx, base);
	// 822FB3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FB3F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FB3F8: 48B61A81  bl 0x82e5ce78
	ctx.lr = 0x822FB3FC;
	sub_82E5CE78(ctx, base);
	// 822FB3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB400: 48B5E369  bl 0x82e59768
	ctx.lr = 0x822FB404;
	sub_82E59768(ctx, base);
	// 822FB404: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FB408: 387F016C  addi r3, r31, 0x16c
	ctx.r[3].s64 = ctx.r[31].s64 + 364;
	// 822FB40C: 48B64A6D  bl 0x82e5fe78
	ctx.lr = 0x822FB410;
	sub_82E5FE78(ctx, base);
	// 822FB410: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FB414: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FB418: 48002781  bl 0x822fdb98
	ctx.lr = 0x822FB41C;
	sub_822FDB98(ctx, base);
	// 822FB41C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB420: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FB424: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 822FB428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB42C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 822FB430: 695D0001  xori r29, r10, 1
	ctx.r[29].u64 = ctx.r[10].u64 ^ 1;
	// 822FB434: 419A000C  beq cr6, 0x822fb440
	if ctx.cr[6].eq {
	pc = 0x822FB440; continue 'dispatch;
	}
	// 822FB438: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FB43C: 4BFC5455  bl 0x822c0890
	ctx.lr = 0x822FB440;
	sub_822C0890(ctx, base);
	// 822FB440: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB444: 41820028  beq 0x822fb46c
	if ctx.cr[0].eq {
	pc = 0x822FB46C; continue 'dispatch;
	}
	// 822FB448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FB44C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FB450: 48002749  bl 0x822fdb98
	ctx.lr = 0x822FB454;
	sub_822FDB98(ctx, base);
	// 822FB454: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB458: 4BFFEBF1  bl 0x822fa048
	ctx.lr = 0x822FB45C;
	sub_822FA048(ctx, base);
	// 822FB45C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FB460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FB464: 419A0008  beq cr6, 0x822fb46c
	if ctx.cr[6].eq {
	pc = 0x822FB46C; continue 'dispatch;
	}
	// 822FB468: 4BFC5429  bl 0x822c0890
	ctx.lr = 0x822FB46C;
	sub_822C0890(ctx, base);
	// 822FB46C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB474: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 822FB478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FB47C: 4E800421  bctrl
	ctx.lr = 0x822FB480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FB480: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FB484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FB488: 419A0008  beq cr6, 0x822fb490
	if ctx.cr[6].eq {
	pc = 0x822FB490; continue 'dispatch;
	}
	// 822FB48C: 4BFC5405  bl 0x822c0890
	ctx.lr = 0x822FB490;
	sub_822C0890(ctx, base);
	// 822FB490: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FB494: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822FB498: 48EACD20  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB4A0 size=208
    let mut pc: u32 = 0x822FB4A0;
    'dispatch: loop {
        match pc {
            0x822FB4A0 => {
    //   block [0x822FB4A0..0x822FB570)
	// 822FB4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB4A4: 48EACCBD  bl 0x831a8160
	ctx.lr = 0x822FB4A8;
	sub_831A8130(ctx, base);
	// 822FB4A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB4AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FB4B0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FB4B4: 817C0184  lwz r11, 0x184(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) } as u64;
	// 822FB4B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB4BC: 40980010  bge cr6, 0x822fb4cc
	if !ctx.cr[6].lt {
	pc = 0x822FB4CC; continue 'dispatch;
	}
	// 822FB4C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FB4C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB4C8: 482B6401  bl 0x825b18c8
	ctx.lr = 0x822FB4CC;
	sub_825B18C8(ctx, base);
	// 822FB4CC: 817C0178  lwz r11, 0x178(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FB4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB4D4: 419A0010  beq cr6, 0x822fb4e4
	if ctx.cr[6].eq {
	pc = 0x822FB4E4; continue 'dispatch;
	}
	// 822FB4D8: 815C017C  lwz r10, 0x17c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(380 as u32) ) } as u64;
	// 822FB4DC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FB4E0: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822FB4E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB4E8: 419A0078  beq cr6, 0x822fb560
	if ctx.cr[6].eq {
	pc = 0x822FB560; continue 'dispatch;
	}
	// 822FB4EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822FB4F0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 822FB4F4: 817C0178  lwz r11, 0x178(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FB4F8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 822FB4FC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB500: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB504: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FB508: 419A0024  beq cr6, 0x822fb52c
	if ctx.cr[6].eq {
	pc = 0x822FB52C; continue 'dispatch;
	}
	// 822FB50C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FB510: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FB514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FB518: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FB51C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FB520: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FB524: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FB528: 4082FFE8  bne 0x822fb510
	if !ctx.cr[0].eq {
	pc = 0x822FB510; continue 'dispatch;
	}
	// 822FB52C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822FB530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB534: 482909DD  bl 0x8258bf10
	ctx.lr = 0x822FB538;
	sub_8258BF10(ctx, base);
	// 822FB538: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FB53C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FB540: 4BFFFF61  bl 0x822fb4a0
	ctx.lr = 0x822FB544;
	sub_822FB4A0(ctx, base);
	// 822FB544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FB548: 419A000C  beq cr6, 0x822fb554
	if ctx.cr[6].eq {
	pc = 0x822FB554; continue 'dispatch;
	}
	// 822FB54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB550: 4BFC5341  bl 0x822c0890
	ctx.lr = 0x822FB554;
	sub_822C0890(ctx, base);
	// 822FB554: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 822FB558: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 822FB55C: 4082FF98  bne 0x822fb4f4
	if !ctx.cr[0].eq {
	pc = 0x822FB4F4; continue 'dispatch;
	}
	// 822FB560: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FB564: 4BFCD755  bl 0x822c8cb8
	ctx.lr = 0x822FB568;
	sub_822C8CB8(ctx, base);
	// 822FB568: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FB56C: 48EACC44  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB570 size=236
    let mut pc: u32 = 0x822FB570;
    'dispatch: loop {
        match pc {
            0x822FB570 => {
    //   block [0x822FB570..0x822FB65C)
	// 822FB570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB574: 48EACBE9  bl 0x831a815c
	ctx.lr = 0x822FB578;
	sub_831A8130(ctx, base);
	// 822FB578: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB57C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FB580: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822FB584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FB588: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FB58C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822FB590: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB594: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB598: 4800002C  b 0x822fb5c4
	pc = 0x822FB5C4; continue 'dispatch;
	// 822FB59C: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 822FB5A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822FB5A4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822FB5A8: 48AF7C91  bl 0x82df3238
	ctx.lr = 0x822FB5AC;
	sub_82DF3238(ctx, base);
	// 822FB5AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FB5B0: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB5B4: 4182000C  beq 0x822fb5c0
	if ctx.cr[0].eq {
	pc = 0x822FB5C0; continue 'dispatch;
	}
	// 822FB5B8: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB5BC: 48000008  b 0x822fb5c4
	pc = 0x822FB5C4; continue 'dispatch;
	// 822FB5C0: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB5C4: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FB5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB5CC: 419AFFD0  beq cr6, 0x822fb59c
	if ctx.cr[6].eq {
	pc = 0x822FB59C; continue 'dispatch;
	}
	// 822FB5D0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822FB5D4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB5D8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822FB5DC: 41820048  beq 0x822fb624
	if ctx.cr[0].eq {
	pc = 0x822FB624; continue 'dispatch;
	}
	// 822FB5E0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB5E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB5EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB5F0: 409A002C  bne cr6, 0x822fb61c
	if !ctx.cr[6].eq {
	pc = 0x822FB61C; continue 'dispatch;
	}
	// 822FB5F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FB5F8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822FB5FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FB600: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822FB604: 4BFFF0C5  bl 0x822fa6c8
	ctx.lr = 0x822FB608;
	sub_822FA6C8(ctx, base);
	// 822FB608: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FB60C: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 822FB610: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB614: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FB618: 48000038  b 0x822fb650
	pc = 0x822FB650; continue 'dispatch;
	// 822FB61C: 4BFFD99D  bl 0x822f8fb8
	ctx.lr = 0x822FB620;
	sub_822F8FB8(ctx, base);
	// 822FB620: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FB624: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FB628: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 822FB62C: 48AF7C0D  bl 0x82df3238
	ctx.lr = 0x822FB630;
	sub_82DF3238(ctx, base);
	// 822FB630: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB634: 41820010  beq 0x822fb644
	if ctx.cr[0].eq {
	pc = 0x822FB644; continue 'dispatch;
	}
	// 822FB638: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FB63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB640: 4BFFFFB8  b 0x822fb5f8
	pc = 0x822FB5F8; continue 'dispatch;
	// 822FB644: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FB648: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822FB64C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 822FB650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB654: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FB658: 48EACB54  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB660 size=132
    let mut pc: u32 = 0x822FB660;
    'dispatch: loop {
        match pc {
            0x822FB660 => {
    //   block [0x822FB660..0x822FB6E4)
	// 822FB660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB664: 48EACB05  bl 0x831a8168
	ctx.lr = 0x822FB668;
	sub_831A8130(ctx, base);
	// 822FB668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB66C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FB670: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 822FB674: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FB678: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822FB67C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB680: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB684: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FB688: 409A0044  bne cr6, 0x822fb6cc
	if !ctx.cr[6].eq {
	pc = 0x822FB6CC; continue 'dispatch;
	}
	// 822FB68C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB690: 409A003C  bne cr6, 0x822fb6cc
	if !ctx.cr[6].eq {
	pc = 0x822FB6CC; continue 'dispatch;
	}
	// 822FB694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB698: 4BFFEF81  bl 0x822fa618
	ctx.lr = 0x822FB69C;
	sub_822FA618(ctx, base);
	// 822FB69C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB6A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB6A4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FB6A8: 48000030  b 0x822fb6d8
	pc = 0x822FB6D8; continue 'dispatch;
	// 822FB6AC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 822FB6B0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FB6B4: 4818ED1D  bl 0x8248a3d0
	ctx.lr = 0x822FB6B8;
	sub_8248A3D0(ctx, base);
	// 822FB6B8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FB6BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB6C4: 4BFFF455  bl 0x822fab18
	ctx.lr = 0x822FB6C8;
	sub_822FAB18(ctx, base);
	// 822FB6C8: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822FB6CC: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FB6D0: 409AFFDC  bne cr6, 0x822fb6ac
	if !ctx.cr[6].eq {
	pc = 0x822FB6AC; continue 'dispatch;
	}
	// 822FB6D4: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822FB6D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FB6DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FB6E0: 48EACAD8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB6E8 size=236
    let mut pc: u32 = 0x822FB6E8;
    'dispatch: loop {
        match pc {
            0x822FB6E8 => {
    //   block [0x822FB6E8..0x822FB7D4)
	// 822FB6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB6EC: 48EACA71  bl 0x831a815c
	ctx.lr = 0x822FB6F0;
	sub_831A8130(ctx, base);
	// 822FB6F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB6F4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FB6F8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 822FB6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FB700: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FB704: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 822FB708: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB70C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB710: 4800002C  b 0x822fb73c
	pc = 0x822FB73C; continue 'dispatch;
	// 822FB714: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 822FB718: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822FB71C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 822FB720: 48AF7B19  bl 0x82df3238
	ctx.lr = 0x822FB724;
	sub_82DF3238(ctx, base);
	// 822FB724: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FB728: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB72C: 4182000C  beq 0x822fb738
	if ctx.cr[0].eq {
	pc = 0x822FB738; continue 'dispatch;
	}
	// 822FB730: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB734: 48000008  b 0x822fb73c
	pc = 0x822FB73C; continue 'dispatch;
	// 822FB738: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB73C: 897D0015  lbz r11, 0x15(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FB740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB744: 419AFFD0  beq cr6, 0x822fb714
	if ctx.cr[6].eq {
	pc = 0x822FB714; continue 'dispatch;
	}
	// 822FB748: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 822FB74C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB750: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 822FB754: 41820048  beq 0x822fb79c
	if ctx.cr[0].eq {
	pc = 0x822FB79C; continue 'dispatch;
	}
	// 822FB758: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB75C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB760: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB764: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB768: 409A002C  bne cr6, 0x822fb794
	if !ctx.cr[6].eq {
	pc = 0x822FB794; continue 'dispatch;
	}
	// 822FB76C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FB770: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822FB774: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FB778: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822FB77C: 4BFFF175  bl 0x822fa8f0
	ctx.lr = 0x822FB780;
	sub_822FA8F0(ctx, base);
	// 822FB780: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FB784: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 822FB788: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB78C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FB790: 48000038  b 0x822fb7c8
	pc = 0x822FB7C8; continue 'dispatch;
	// 822FB794: 488BB4A5  bl 0x82bb6c38
	ctx.lr = 0x822FB798;
	sub_82BB6C38(ctx, base);
	// 822FB798: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FB79C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FB7A0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 822FB7A4: 48AF7A95  bl 0x82df3238
	ctx.lr = 0x822FB7A8;
	sub_82DF3238(ctx, base);
	// 822FB7A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB7AC: 41820010  beq 0x822fb7bc
	if ctx.cr[0].eq {
	pc = 0x822FB7BC; continue 'dispatch;
	}
	// 822FB7B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FB7B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB7B8: 4BFFFFB8  b 0x822fb770
	pc = 0x822FB770; continue 'dispatch;
	// 822FB7BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FB7C0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822FB7C4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 822FB7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB7CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FB7D0: 48EAC9DC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB7D8 size=132
    let mut pc: u32 = 0x822FB7D8;
    'dispatch: loop {
        match pc {
            0x822FB7D8 => {
    //   block [0x822FB7D8..0x822FB85C)
	// 822FB7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB7DC: 48EAC98D  bl 0x831a8168
	ctx.lr = 0x822FB7E0;
	sub_831A8130(ctx, base);
	// 822FB7E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB7E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FB7E8: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 822FB7EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FB7F0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822FB7F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB7F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB7FC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FB800: 409A0044  bne cr6, 0x822fb844
	if !ctx.cr[6].eq {
	pc = 0x822FB844; continue 'dispatch;
	}
	// 822FB804: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB808: 409A003C  bne cr6, 0x822fb844
	if !ctx.cr[6].eq {
	pc = 0x822FB844; continue 'dispatch;
	}
	// 822FB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB810: 4BFFEE61  bl 0x822fa670
	ctx.lr = 0x822FB814;
	sub_822FA670(ctx, base);
	// 822FB814: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB818: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB81C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FB820: 48000030  b 0x822fb850
	pc = 0x822FB850; continue 'dispatch;
	// 822FB824: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 822FB828: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FB82C: 481ED865  bl 0x824e9090
	ctx.lr = 0x822FB830;
	sub_824E9090(ctx, base);
	// 822FB830: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FB834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB83C: 4BFFF6DD  bl 0x822faf18
	ctx.lr = 0x822FB840;
	sub_822FAF18(ctx, base);
	// 822FB840: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822FB844: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FB848: 409AFFDC  bne cr6, 0x822fb824
	if !ctx.cr[6].eq {
	pc = 0x822FB824; continue 'dispatch;
	}
	// 822FB84C: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822FB850: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FB854: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FB858: 48EAC960  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB860 size=156
    let mut pc: u32 = 0x822FB860;
    'dispatch: loop {
        match pc {
            0x822FB860 => {
    //   block [0x822FB860..0x822FB8FC)
	// 822FB860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FB868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FB86C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FB870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FB878: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FB87C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 822FB880: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FB884: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FB888: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822FB88C: 409A000C  bne cr6, 0x822fb898
	if !ctx.cr[6].eq {
	pc = 0x822FB898; continue 'dispatch;
	}
	// 822FB890: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822FB894: 48000050  b 0x822fb8e4
	pc = 0x822FB8E4; continue 'dispatch;
	// 822FB898: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 822FB89C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 822FB8A0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB8A4: 4099000C  ble cr6, 0x822fb8b0
	if !ctx.cr[6].gt {
	pc = 0x822FB8B0; continue 'dispatch;
	}
	// 822FB8A8: 488BC479  bl 0x82bb7d20
	ctx.lr = 0x822FB8AC;
	sub_82BB7D20(ctx, base);
	// 822FB8AC: 48000034  b 0x822fb8e0
	pc = 0x822FB8E0; continue 'dispatch;
	// 822FB8B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FB8B4: 549E2834  slwi r30, r4, 5
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 822FB8B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FB8BC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FB8C0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 822FB8C4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822FB8C8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FB8CC: 48AF67FD  bl 0x82df20c8
	ctx.lr = 0x822FB8D0;
	sub_82DF20C8(ctx, base);
	// 822FB8D0: 7D7E1A14  add r11, r30, r3
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 822FB8D4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822FB8D8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 822FB8DC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 822FB8E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822FB8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FB8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FB8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FB8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FB8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FB8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FB900 size=424
    let mut pc: u32 = 0x822FB900;
    'dispatch: loop {
        match pc {
            0x822FB900 => {
    //   block [0x822FB900..0x822FBAA8)
	// 822FB900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FB904: 48EAC85D  bl 0x831a8160
	ctx.lr = 0x822FB908;
	sub_831A8130(ctx, base);
	// 822FB908: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FB90C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FB910: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FB914: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FB918: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FB91C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB924: 409A0020  bne cr6, 0x822fb944
	if !ctx.cr[6].eq {
	pc = 0x822FB944; continue 'dispatch;
	}
	// 822FB928: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB92C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FB930: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FB934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FB938: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FB93C: 4BFFED8D  bl 0x822fa6c8
	ctx.lr = 0x822FB940;
	sub_822FA6C8(ctx, base);
	// 822FB940: 4800015C  b 0x822fba9c
	pc = 0x822FBA9C; continue 'dispatch;
	// 822FB944: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB948: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FB94C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FB950: 409A0020  bne cr6, 0x822fb970
	if !ctx.cr[6].eq {
	pc = 0x822FB970; continue 'dispatch;
	}
	// 822FB954: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 822FB958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB95C: 48AF78DD  bl 0x82df3238
	ctx.lr = 0x822FB960;
	sub_82DF3238(ctx, base);
	// 822FB960: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB964: 4182011C  beq 0x822fba80
	if ctx.cr[0].eq {
	pc = 0x822FBA80; continue 'dispatch;
	}
	// 822FB968: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FB96C: 4BFFFFC0  b 0x822fb92c
	pc = 0x822FB92C; continue 'dispatch;
	// 822FB970: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FB974: 409A002C  bne cr6, 0x822fb9a0
	if !ctx.cr[6].eq {
	pc = 0x822FB9A0; continue 'dispatch;
	}
	// 822FB978: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB97C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB980: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 822FB984: 48AF78B5  bl 0x82df3238
	ctx.lr = 0x822FB988;
	sub_82DF3238(ctx, base);
	// 822FB988: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB98C: 418200F4  beq 0x822fba80
	if ctx.cr[0].eq {
	pc = 0x822FBA80; continue 'dispatch;
	}
	// 822FB990: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FB994: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FB998: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB99C: 4BFFFF94  b 0x822fb930
	pc = 0x822FB930; continue 'dispatch;
	// 822FB9A0: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 822FB9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FB9A8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822FB9AC: 48AF788D  bl 0x82df3238
	ctx.lr = 0x822FB9B0;
	sub_82DF3238(ctx, base);
	// 822FB9B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB9B4: 4182005C  beq 0x822fba10
	if ctx.cr[0].eq {
	pc = 0x822FBA10; continue 'dispatch;
	}
	// 822FB9B8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822FB9BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FB9C0: 4BFFD5F9  bl 0x822f8fb8
	ctx.lr = 0x822FB9C4;
	sub_822F8FB8(ctx, base);
	// 822FB9C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FB9C8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FB9CC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 822FB9D0: 48AF7869  bl 0x82df3238
	ctx.lr = 0x822FB9D4;
	sub_82DF3238(ctx, base);
	// 822FB9D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FB9D8: 41820038  beq 0x822fba10
	if ctx.cr[0].eq {
	pc = 0x822FBA10; continue 'dispatch;
	}
	// 822FB9DC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FB9E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FB9E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FB9E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FB9EC: 896B0025  lbz r11, 0x25(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FB9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FB9F4: 419A0010  beq cr6, 0x822fba04
	if ctx.cr[6].eq {
	pc = 0x822FBA04; continue 'dispatch;
	}
	// 822FB9F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822FB9FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FBA00: 4BFFFF3C  b 0x822fb93c
	pc = 0x822FB93C; continue 'dispatch;
	// 822FBA04: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FBA08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FBA0C: 4BFFFF30  b 0x822fb93c
	pc = 0x822FB93C; continue 'dispatch;
	// 822FBA10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBA14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FBA18: 48AF7821  bl 0x82df3238
	ctx.lr = 0x822FBA1C;
	sub_82DF3238(ctx, base);
	// 822FBA1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBA20: 41820060  beq 0x822fba80
	if ctx.cr[0].eq {
	pc = 0x822FBA80; continue 'dispatch;
	}
	// 822FBA24: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822FBA28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBA2C: 4818E9A5  bl 0x8248a3d0
	ctx.lr = 0x822FBA30;
	sub_8248A3D0(ctx, base);
	// 822FBA30: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBA34: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FBA38: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBA3C: 419A0018  beq cr6, 0x822fba54
	if ctx.cr[6].eq {
	pc = 0x822FBA54; continue 'dispatch;
	}
	// 822FBA40: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 822FBA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FBA48: 48AF77F1  bl 0x82df3238
	ctx.lr = 0x822FBA4C;
	sub_82DF3238(ctx, base);
	// 822FBA4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBA50: 41820030  beq 0x822fba80
	if ctx.cr[0].eq {
	pc = 0x822FBA80; continue 'dispatch;
	}
	// 822FBA54: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBA58: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FBA5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBA64: 896B0025  lbz r11, 0x25(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(37 as u32) ) } as u64;
	// 822FBA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FBA6C: 419A000C  beq cr6, 0x822fba78
	if ctx.cr[6].eq {
	pc = 0x822FBA78; continue 'dispatch;
	}
	// 822FBA70: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FBA74: 4BFFFF88  b 0x822fb9fc
	pc = 0x822FB9FC; continue 'dispatch;
	// 822FBA78: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822FBA7C: 4BFFFF8C  b 0x822fba08
	pc = 0x822FBA08; continue 'dispatch;
	// 822FBA80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FBA84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBA8C: 4BFFFAE5  bl 0x822fb570
	ctx.lr = 0x822FBA90;
	sub_822FB570(ctx, base);
	// 822FBA90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FBA94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBA98: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FBA9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBAA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FBAA4: 48EAC70C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBAA8 size=88
    let mut pc: u32 = 0x822FBAA8;
    'dispatch: loop {
        match pc {
            0x822FBAA8 => {
    //   block [0x822FBAA8..0x822FBB00)
	// 822FBAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FBAB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FBAB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBAB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FBABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBAC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBAC4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBAC8: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBACC: 4BFFFB95  bl 0x822fb660
	ctx.lr = 0x822FBAD0;
	sub_822FB660(ctx, base);
	// 822FBAD0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FBAD4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBAD8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FBADC: 48AF66AD  bl 0x82df2188
	ctx.lr = 0x822FBAE0;
	sub_82DF2188(ctx, base);
	// 822FBAE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBAE4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FBAE8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FBAEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FBAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FBAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FBAF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FBAFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBB00 size=424
    let mut pc: u32 = 0x822FBB00;
    'dispatch: loop {
        match pc {
            0x822FBB00 => {
    //   block [0x822FBB00..0x822FBCA8)
	// 822FBB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBB04: 48EAC65D  bl 0x831a8160
	ctx.lr = 0x822FBB08;
	sub_831A8130(ctx, base);
	// 822FBB08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBB0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FBB10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FBB14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FBB18: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FBB1C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FBB24: 409A0020  bne cr6, 0x822fbb44
	if !ctx.cr[6].eq {
	pc = 0x822FBB44; continue 'dispatch;
	}
	// 822FBB28: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBB2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FBB30: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FBB34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBB38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBB3C: 4BFFEDB5  bl 0x822fa8f0
	ctx.lr = 0x822FBB40;
	sub_822FA8F0(ctx, base);
	// 822FBB40: 4800015C  b 0x822fbc9c
	pc = 0x822FBC9C; continue 'dispatch;
	// 822FBB44: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBB48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBB4C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FBB50: 409A0020  bne cr6, 0x822fbb70
	if !ctx.cr[6].eq {
	pc = 0x822FBB70; continue 'dispatch;
	}
	// 822FBB54: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 822FBB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FBB5C: 48AF76DD  bl 0x82df3238
	ctx.lr = 0x822FBB60;
	sub_82DF3238(ctx, base);
	// 822FBB60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBB64: 4182011C  beq 0x822fbc80
	if ctx.cr[0].eq {
	pc = 0x822FBC80; continue 'dispatch;
	}
	// 822FBB68: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FBB6C: 4BFFFFC0  b 0x822fbb2c
	pc = 0x822FBB2C; continue 'dispatch;
	// 822FBB70: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBB74: 409A002C  bne cr6, 0x822fbba0
	if !ctx.cr[6].eq {
	pc = 0x822FBBA0; continue 'dispatch;
	}
	// 822FBB78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBB7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBB80: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 822FBB84: 48AF76B5  bl 0x82df3238
	ctx.lr = 0x822FBB88;
	sub_82DF3238(ctx, base);
	// 822FBB88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBB8C: 418200F4  beq 0x822fbc80
	if ctx.cr[0].eq {
	pc = 0x822FBC80; continue 'dispatch;
	}
	// 822FBB90: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBB94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FBB98: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBB9C: 4BFFFF94  b 0x822fbb30
	pc = 0x822FBB30; continue 'dispatch;
	// 822FBBA0: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 822FBBA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FBBA8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 822FBBAC: 48AF768D  bl 0x82df3238
	ctx.lr = 0x822FBBB0;
	sub_82DF3238(ctx, base);
	// 822FBBB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBBB4: 4182005C  beq 0x822fbc10
	if ctx.cr[0].eq {
	pc = 0x822FBC10; continue 'dispatch;
	}
	// 822FBBB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822FBBBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBBC0: 488BB079  bl 0x82bb6c38
	ctx.lr = 0x822FBBC4;
	sub_82BB6C38(ctx, base);
	// 822FBBC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBBC8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FBBCC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 822FBBD0: 48AF7669  bl 0x82df3238
	ctx.lr = 0x822FBBD4;
	sub_82DF3238(ctx, base);
	// 822FBBD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBBD8: 41820038  beq 0x822fbc10
	if ctx.cr[0].eq {
	pc = 0x822FBC10; continue 'dispatch;
	}
	// 822FBBDC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBBE0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FBBE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBBE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBBEC: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FBBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FBBF4: 419A0010  beq cr6, 0x822fbc04
	if ctx.cr[6].eq {
	pc = 0x822FBC04; continue 'dispatch;
	}
	// 822FBBF8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822FBBFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FBC00: 4BFFFF3C  b 0x822fbb3c
	pc = 0x822FBB3C; continue 'dispatch;
	// 822FBC04: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FBC08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FBC0C: 4BFFFF30  b 0x822fbb3c
	pc = 0x822FBB3C; continue 'dispatch;
	// 822FBC10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBC14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FBC18: 48AF7621  bl 0x82df3238
	ctx.lr = 0x822FBC1C;
	sub_82DF3238(ctx, base);
	// 822FBC1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBC20: 41820060  beq 0x822fbc80
	if ctx.cr[0].eq {
	pc = 0x822FBC80; continue 'dispatch;
	}
	// 822FBC24: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 822FBC28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBC2C: 481ED465  bl 0x824e9090
	ctx.lr = 0x822FBC30;
	sub_824E9090(ctx, base);
	// 822FBC30: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBC34: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FBC38: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBC3C: 419A0018  beq cr6, 0x822fbc54
	if ctx.cr[6].eq {
	pc = 0x822FBC54; continue 'dispatch;
	}
	// 822FBC40: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 822FBC44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FBC48: 48AF75F1  bl 0x82df3238
	ctx.lr = 0x822FBC4C;
	sub_82DF3238(ctx, base);
	// 822FBC4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBC50: 41820030  beq 0x822fbc80
	if ctx.cr[0].eq {
	pc = 0x822FBC80; continue 'dispatch;
	}
	// 822FBC54: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBC58: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FBC5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBC60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBC64: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 822FBC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FBC6C: 419A000C  beq cr6, 0x822fbc78
	if ctx.cr[6].eq {
	pc = 0x822FBC78; continue 'dispatch;
	}
	// 822FBC70: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FBC74: 4BFFFF88  b 0x822fbbfc
	pc = 0x822FBBFC; continue 'dispatch;
	// 822FBC78: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 822FBC7C: 4BFFFF8C  b 0x822fbc08
	pc = 0x822FBC08; continue 'dispatch;
	// 822FBC80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FBC84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBC8C: 4BFFFA5D  bl 0x822fb6e8
	ctx.lr = 0x822FBC90;
	sub_822FB6E8(ctx, base);
	// 822FBC90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FBC94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBC98: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FBC9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBCA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FBCA4: 48EAC50C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBCA8 size=88
    let mut pc: u32 = 0x822FBCA8;
    'dispatch: loop {
        match pc {
            0x822FBCA8 => {
    //   block [0x822FBCA8..0x822FBD00)
	// 822FBCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBCAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FBCB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FBCB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FBCBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBCC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FBCC4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBCC8: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBCCC: 4BFFFB0D  bl 0x822fb7d8
	ctx.lr = 0x822FBCD0;
	sub_822FB7D8(ctx, base);
	// 822FBCD0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FBCD4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBCD8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FBCDC: 48AF64AD  bl 0x82df2188
	ctx.lr = 0x822FBCE0;
	sub_82DF2188(ctx, base);
	// 822FBCE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBCE4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FBCE8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FBCEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FBCF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FBCF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FBCF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FBCFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBD00 size=132
    let mut pc: u32 = 0x822FBD00;
    'dispatch: loop {
        match pc {
            0x822FBD00 => {
    //   block [0x822FBD00..0x822FBD84)
	// 822FBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBD04: 48EAC469  bl 0x831a816c
	ctx.lr = 0x822FBD08;
	sub_831A8130(ctx, base);
	// 822FBD08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBD0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FBD10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FBD14: 4BFFD3D5  bl 0x822f90e8
	ctx.lr = 0x822FBD18;
	sub_822F90E8(ctx, base);
	// 822FBD18: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBD1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FBD20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBD24: 419A0018  beq cr6, 0x822fbd3c
	if ctx.cr[6].eq {
	pc = 0x822FBD3C; continue 'dispatch;
	}
	// 822FBD28: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 822FBD2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBD30: 48AF7509  bl 0x82df3238
	ctx.lr = 0x822FBD34;
	sub_82DF3238(ctx, base);
	// 822FBD34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBD38: 41820040  beq 0x822fbd78
	if ctx.cr[0].eq {
	pc = 0x822FBD78; continue 'dispatch;
	}
	// 822FBD3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FBD40: 4BFFCF89  bl 0x822f8cc8
	ctx.lr = 0x822FBD44;
	sub_822F8CC8(ctx, base);
	// 822FBD44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FBD48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FBD4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822FBD50: 4BFFD1A1  bl 0x822f8ef0
	ctx.lr = 0x822FBD54;
	sub_822F8EF0(ctx, base);
	// 822FBD54: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822FBD58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FBD5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBD60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBD64: 4BFFFB9D  bl 0x822fb900
	ctx.lr = 0x822FBD68;
	sub_822FB900(ctx, base);
	// 822FBD68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FBD6C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822FBD70: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBD74: 48AF76B5  bl 0x82df3428
	ctx.lr = 0x822FBD78;
	sub_82DF3428(ctx, base);
	// 822FBD78: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 822FBD7C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822FBD80: 48EAC43C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBD88 size=160
    let mut pc: u32 = 0x822FBD88;
    'dispatch: loop {
        match pc {
            0x822FBD88 => {
    //   block [0x822FBD88..0x822FBE28)
	// 822FBD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBD8C: 48EAC3DD  bl 0x831a8168
	ctx.lr = 0x822FBD90;
	sub_831A8130(ctx, base);
	// 822FBD90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBD94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FBD98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FBD9C: 484C4F95  bl 0x827c0d30
	ctx.lr = 0x822FBDA0;
	sub_827C0D30(ctx, base);
	// 822FBDA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBDA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FBDA8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBDAC: 419A0018  beq cr6, 0x822fbdc4
	if ctx.cr[6].eq {
	pc = 0x822FBDC4; continue 'dispatch;
	}
	// 822FBDB0: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 822FBDB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FBDB8: 48AF7481  bl 0x82df3238
	ctx.lr = 0x822FBDBC;
	sub_82DF3238(ctx, base);
	// 822FBDBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBDC0: 4182005C  beq 0x822fbe1c
	if ctx.cr[0].eq {
	pc = 0x822FBE1C; continue 'dispatch;
	}
	// 822FBDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBDC8: 48AF7329  bl 0x82df30f0
	ctx.lr = 0x822FBDCC;
	sub_82DF30F0(ctx, base);
	// 822FBDCC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FBDD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FBDD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FBDD8: 48AF7E29  bl 0x82df3c00
	ctx.lr = 0x822FBDDC;
	sub_82DF3C00(ctx, base);
	// 822FBDDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FBDE0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822FBDE4: 48AF7E1D  bl 0x82df3c00
	ctx.lr = 0x822FBDE8;
	sub_82DF3C00(ctx, base);
	// 822FBDE8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 822FBDEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FBDF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FBDF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822FBDF8: 4BFFFD09  bl 0x822fbb00
	ctx.lr = 0x822FBDFC;
	sub_822FBB00(ctx, base);
	// 822FBDFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FBE00: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822FBE04: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FBE08: 48AF7621  bl 0x82df3428
	ctx.lr = 0x822FBE0C;
	sub_82DF3428(ctx, base);
	// 822FBE0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FBE10: 48AF7619  bl 0x82df3428
	ctx.lr = 0x822FBE14;
	sub_82DF3428(ctx, base);
	// 822FBE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBE18: 48AF7611  bl 0x82df3428
	ctx.lr = 0x822FBE1C;
	sub_82DF3428(ctx, base);
	// 822FBE1C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 822FBE20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FBE24: 48EAC394  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBE28 size=144
    let mut pc: u32 = 0x822FBE28;
    'dispatch: loop {
        match pc {
            0x822FBE28 => {
    //   block [0x822FBE28..0x822FBEB8)
	// 822FBE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBE2C: 48EAC33D  bl 0x831a8168
	ctx.lr = 0x822FBE30;
	sub_831A8130(ctx, base);
	// 822FBE30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBE34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FBE38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FBE3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FBE44: 409A000C  bne cr6, 0x822fbe50
	if !ctx.cr[6].eq {
	pc = 0x822FBE50; continue 'dispatch;
	}
	// 822FBE48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FBE4C: 48000010  b 0x822fbe5c
	pc = 0x822FBE5C; continue 'dispatch;
	// 822FBE50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBE54: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FBE58: 7D642E70  srawi r4, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FBE5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FBE60: 4BFFFA01  bl 0x822fb860
	ctx.lr = 0x822FBE64;
	sub_822FB860(ctx, base);
	// 822FBE64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FBE68: 41820044  beq 0x822fbeac
	if ctx.cr[0].eq {
	pc = 0x822FBEAC; continue 'dispatch;
	}
	// 822FBE6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBE70: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBE74: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBE78: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822FBE7C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FBE80: 419A0028  beq cr6, 0x822fbea8
	if ctx.cr[6].eq {
	pc = 0x822FBEA8; continue 'dispatch;
	}
	// 822FBE84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FBE88: 419A0010  beq cr6, 0x822fbe98
	if ctx.cr[6].eq {
	pc = 0x822FBE98; continue 'dispatch;
	}
	// 822FBE8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FBE90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FBE94: 4829007D  bl 0x8258bf10
	ctx.lr = 0x822FBE98;
	sub_8258BF10(ctx, base);
	// 822FBE98: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822FBE9C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 822FBEA0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FBEA4: 409AFFE0  bne cr6, 0x822fbe84
	if !ctx.cr[6].eq {
	pc = 0x822FBE84; continue 'dispatch;
	}
	// 822FBEA8: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 822FBEAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FBEB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FBEB4: 48EAC304  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FBEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FBEB8 size=872
    let mut pc: u32 = 0x822FBEB8;
    'dispatch: loop {
        match pc {
            0x822FBEB8 => {
    //   block [0x822FBEB8..0x822FC220)
	// 822FBEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FBEBC: 48EAC299  bl 0x831a8154
	ctx.lr = 0x822FBEC0;
	sub_831A8130(ctx, base);
	// 822FBEC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FBEC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FBEC8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FBECC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 822FBED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FBED4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 822FBED8: 48290039  bl 0x8258bf10
	ctx.lr = 0x822FBEDC;
	sub_8258BF10(ctx, base);
	// 822FBEDC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBEE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FBEE4: 409A000C  bne cr6, 0x822fbef0
	if !ctx.cr[6].eq {
	pc = 0x822FBEF0; continue 'dispatch;
	}
	// 822FBEE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822FBEEC: 48000010  b 0x822fbefc
	pc = 0x822FBEFC; continue 'dispatch;
	// 822FBEF0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822FBEF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822FBEF8: 7D682E70  srawi r8, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FBEFC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 822FBF00: 419A0310  beq cr6, 0x822fc210
	if ctx.cr[6].eq {
	pc = 0x822FC210; continue 'dispatch;
	}
	// 822FBF04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FBF08: 409A000C  bne cr6, 0x822fbf14
	if !ctx.cr[6].eq {
	pc = 0x822FBF14; continue 'dispatch;
	}
	// 822FBF0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBF10: 48000010  b 0x822fbf20
	pc = 0x822FBF20; continue 'dispatch;
	// 822FBF14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBF18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822FBF1C: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FBF20: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 822FBF24: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 822FBF28: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FBF2C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 822FBF30: 4098000C  bge cr6, 0x822fbf3c
	if !ctx.cr[6].lt {
	pc = 0x822FBF3C; continue 'dispatch;
	}
	// 822FBF34: 488BBDED  bl 0x82bb7d20
	ctx.lr = 0x822FBF38;
	sub_82BB7D20(ctx, base);
	// 822FBF38: 480002D8  b 0x822fc210
	pc = 0x822FC210; continue 'dispatch;
	// 822FBF3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FBF40: 409A000C  bne cr6, 0x822fbf4c
	if !ctx.cr[6].eq {
	pc = 0x822FBF4C; continue 'dispatch;
	}
	// 822FBF44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBF48: 48000010  b 0x822fbf58
	pc = 0x822FBF58; continue 'dispatch;
	// 822FBF4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBF50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822FBF54: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FBF58: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 822FBF5C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FBF60: 40980180  bge cr6, 0x822fc0e0
	if !ctx.cr[6].lt {
	pc = 0x822FC0E0; continue 'dispatch;
	}
	// 822FBF64: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822FBF68: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FBF6C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 822FBF70: 4098000C  bge cr6, 0x822fbf7c
	if !ctx.cr[6].lt {
	pc = 0x822FBF7C; continue 'dispatch;
	}
	// 822FBF74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBF78: 48000008  b 0x822fbf80
	pc = 0x822FBF80; continue 'dispatch;
	// 822FBF7C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 822FBF80: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FBF84: 409A000C  bne cr6, 0x822fbf90
	if !ctx.cr[6].eq {
	pc = 0x822FBF90; continue 'dispatch;
	}
	// 822FBF88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FBF8C: 48000010  b 0x822fbf9c
	pc = 0x822FBF9C; continue 'dispatch;
	// 822FBF90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBF94: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 822FBF98: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 822FBF9C: 7D4ABA14  add r10, r10, r23
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 822FBFA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FBFA4: 40980024  bge cr6, 0x822fbfc8
	if !ctx.cr[6].lt {
	pc = 0x822FBFC8; continue 'dispatch;
	}
	// 822FBFA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FBFAC: 409A000C  bne cr6, 0x822fbfb8
	if !ctx.cr[6].eq {
	pc = 0x822FBFB8; continue 'dispatch;
	}
	// 822FBFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FBFB4: 48000010  b 0x822fbfc4
	pc = 0x822FBFC4; continue 'dispatch;
	// 822FBFB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FBFBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 822FBFC0: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FBFC4: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 822FBFC8: 55782834  slwi r24, r11, 5
	ctx.r[24].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 822FBFCC: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 822FBFD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FBFD4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 822FBFD8: 388B08B0  addi r4, r11, 0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + 2224;
	// 822FBFDC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822FBFE0: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FBFE4: 48AF60E5  bl 0x82df20c8
	ctx.lr = 0x822FBFE8;
	sub_82DF20C8(ctx, base);
	// 822FBFE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822FBFEC: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FBFF0: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 822FBFF4: 48000020  b 0x822fc014
	pc = 0x822FC014; continue 'dispatch;
	// 822FBFF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822FBFFC: 419A0010  beq cr6, 0x822fc00c
	if ctx.cr[6].eq {
	pc = 0x822FC00C; continue 'dispatch;
	}
	// 822FC000: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FC004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FC008: 4828FF09  bl 0x8258bf10
	ctx.lr = 0x822FC00C;
	sub_8258BF10(ctx, base);
	// 822FC00C: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822FC010: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 822FC014: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822FC018: 409AFFE0  bne cr6, 0x822fbff8
	if !ctx.cr[6].eq {
	pc = 0x822FBFF8; continue 'dispatch;
	}
	// 822FC01C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822FC020: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 822FC024: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FC028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC02C: 487E13DD  bl 0x82add408
	ctx.lr = 0x822FC030;
	sub_82ADD408(ctx, base);
	// 822FC030: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FC038: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FC03C: 419A002C  beq cr6, 0x822fc068
	if ctx.cr[6].eq {
	pc = 0x822FC068; continue 'dispatch;
	}
	// 822FC040: 7F9ED050  subf r28, r30, r26
	ctx.r[28].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 822FC044: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822FC048: 419A0010  beq cr6, 0x822fc058
	if ctx.cr[6].eq {
	pc = 0x822FC058; continue 'dispatch;
	}
	// 822FC04C: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822FC050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC054: 4828FEBD  bl 0x8258bf10
	ctx.lr = 0x822FC058;
	sub_8258BF10(ctx, base);
	// 822FC058: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822FC05C: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 822FC060: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FC064: 409AFFE0  bne cr6, 0x822fc044
	if !ctx.cr[6].eq {
	pc = 0x822FC044; continue 'dispatch;
	}
	// 822FC068: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC070: 409A000C  bne cr6, 0x822fc07c
	if !ctx.cr[6].eq {
	pc = 0x822FC07C; continue 'dispatch;
	}
	// 822FC074: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FC078: 48000010  b 0x822fc088
	pc = 0x822FC088; continue 'dispatch;
	// 822FC07C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC080: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FC084: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 822FC088: 7F8ABA14  add r28, r10, r23
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 822FC08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC090: 419A0034  beq cr6, 0x822fc0c4
	if ctx.cr[6].eq {
	pc = 0x822FC0C4; continue 'dispatch;
	}
	// 822FC094: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC098: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822FC09C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FC0A0: 419A0018  beq cr6, 0x822fc0b8
	if ctx.cr[6].eq {
	pc = 0x822FC0B8; continue 'dispatch;
	}
	// 822FC0A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC0A8: 4BFCCC11  bl 0x822c8cb8
	ctx.lr = 0x822FC0AC;
	sub_822C8CB8(ctx, base);
	// 822FC0AC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 822FC0B0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FC0B4: 409AFFF0  bne cr6, 0x822fc0a4
	if !ctx.cr[6].eq {
	pc = 0x822FC0A4; continue 'dispatch;
	}
	// 822FC0B8: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FC0BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC0C0: 48AF60C9  bl 0x82df2188
	ctx.lr = 0x822FC0C4;
	sub_82DF2188(ctx, base);
	// 822FC0C4: 578B2834  slwi r11, r28, 5
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822FC0C8: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822FC0CC: 7D58DA14  add r10, r24, r27
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 822FC0D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 822FC0D4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 822FC0D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FC0DC: 48000134  b 0x822fc210
	pc = 0x822FC210; continue 'dispatch;
	// 822FC0E0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC0E4: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 822FC0E8: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FC0EC: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 822FC0F0: 40980090  bge cr6, 0x822fc180
	if !ctx.cr[6].lt {
	pc = 0x822FC180; continue 'dispatch;
	}
	// 822FC0F4: 56FD2834  slwi r29, r23, 5
	ctx.r[29].u32 = ctx.r[23].u32.wrapping_shl(5);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 822FC0F8: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC0FC: 7F9DD214  add r28, r29, r26
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 822FC100: 419A002C  beq cr6, 0x822fc12c
	if ctx.cr[6].eq {
	pc = 0x822FC12C; continue 'dispatch;
	}
	// 822FC104: 7F7DE050  subf r27, r29, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 822FC108: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822FC10C: 419A0010  beq cr6, 0x822fc11c
	if ctx.cr[6].eq {
	pc = 0x822FC11C; continue 'dispatch;
	}
	// 822FC110: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FC114: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FC118: 4828FDF9  bl 0x8258bf10
	ctx.lr = 0x822FC11C;
	sub_8258BF10(ctx, base);
	// 822FC11C: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 822FC120: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 822FC124: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC128: 409AFFE0  bne cr6, 0x822fc108
	if !ctx.cr[6].eq {
	pc = 0x822FC108; continue 'dispatch;
	}
	// 822FC12C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC130: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 822FC134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC138: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 822FC13C: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FC140: 7CABB850  subf r5, r11, r23
	ctx.r[5].s64 = ctx.r[23].s64 - ctx.r[11].s64;
	// 822FC144: 487E12C5  bl 0x82add408
	ctx.lr = 0x822FC148;
	sub_82ADD408(ctx, base);
	// 822FC148: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC14C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 822FC150: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 822FC154: 7FDD5850  subf r30, r29, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 822FC158: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FC15C: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC160: 419A00B0  beq cr6, 0x822fc210
	if ctx.cr[6].eq {
	pc = 0x822FC210; continue 'dispatch;
	}
	// 822FC164: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FC168: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FC16C: 48174F5D  bl 0x824710c8
	ctx.lr = 0x822FC170;
	sub_824710C8(ctx, base);
	// 822FC170: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 822FC174: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC178: 409AFFEC  bne cr6, 0x822fc164
	if !ctx.cr[6].eq {
	pc = 0x822FC164; continue 'dispatch;
	}
	// 822FC17C: 48000094  b 0x822fc210
	pc = 0x822FC210; continue 'dispatch;
	// 822FC180: 56F92834  slwi r25, r23, 5
	ctx.r[25].u32 = ctx.r[23].u32.wrapping_shl(5);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 822FC184: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 822FC188: 7FB9F050  subf r29, r25, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 822FC18C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 822FC190: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC194: 419A0028  beq cr6, 0x822fc1bc
	if ctx.cr[6].eq {
	pc = 0x822FC1BC; continue 'dispatch;
	}
	// 822FC198: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 822FC19C: 419A0010  beq cr6, 0x822fc1ac
	if ctx.cr[6].eq {
	pc = 0x822FC1AC; continue 'dispatch;
	}
	// 822FC1A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FC1A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FC1A8: 4828FD69  bl 0x8258bf10
	ctx.lr = 0x822FC1AC;
	sub_8258BF10(ctx, base);
	// 822FC1AC: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 822FC1B0: 3B9C0020  addi r28, r28, 0x20
	ctx.r[28].s64 = ctx.r[28].s64 + 32;
	// 822FC1B4: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC1B8: 409AFFE0  bne cr6, 0x822fc198
	if !ctx.cr[6].eq {
	pc = 0x822FC198; continue 'dispatch;
	}
	// 822FC1BC: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FC1C0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 822FC1C4: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 822FC1C8: 419A0020  beq cr6, 0x822fc1e8
	if ctx.cr[6].eq {
	pc = 0x822FC1E8; continue 'dispatch;
	}
	// 822FC1CC: 7FDDF050  subf r30, r29, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 822FC1D0: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 822FC1D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FC1D8: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 822FC1DC: 48174EED  bl 0x824710c8
	ctx.lr = 0x822FC1E0;
	sub_824710C8(ctx, base);
	// 822FC1E0: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 822FC1E4: 409AFFEC  bne cr6, 0x822fc1d0
	if !ctx.cr[6].eq {
	pc = 0x822FC1D0; continue 'dispatch;
	}
	// 822FC1E8: 7FD9D214  add r30, r25, r26
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 822FC1EC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 822FC1F0: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC1F4: 419A001C  beq cr6, 0x822fc210
	if ctx.cr[6].eq {
	pc = 0x822FC210; continue 'dispatch;
	}
	// 822FC1F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FC1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC200: 48174EC9  bl 0x824710c8
	ctx.lr = 0x822FC204;
	sub_824710C8(ctx, base);
	// 822FC204: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 822FC208: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FC20C: 409AFFEC  bne cr6, 0x822fc1f8
	if !ctx.cr[6].eq {
	pc = 0x822FC1F8; continue 'dispatch;
	}
	// 822FC210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC214: 4BFCCAA5  bl 0x822c8cb8
	ctx.lr = 0x822FC218;
	sub_822C8CB8(ctx, base);
	// 822FC218: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 822FC21C: 48EABF88  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC220 size=84
    let mut pc: u32 = 0x822FC220;
    'dispatch: loop {
        match pc {
            0x822FC220 => {
    //   block [0x822FC220..0x822FC274)
	// 822FC220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FC228: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FC22C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC230: 38630074  addi r3, r3, 0x74
	ctx.r[3].s64 = ctx.r[3].s64 + 116;
	// 822FC234: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FC238: 4BFFFAC9  bl 0x822fbd00
	ctx.lr = 0x822FC23C;
	sub_822FBD00(ctx, base);
	// 822FC23C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 822FC240: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 822FC244: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822FC248: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822FC24C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC250: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822FC254: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822FC258: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822FC25C: 4200FFF0  bdnz 0x822fc24c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822FC24C; continue 'dispatch;
	}
	// 822FC260: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FC264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FC268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FC26C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FC270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC278 size=56
    let mut pc: u32 = 0x822FC278;
    'dispatch: loop {
        match pc {
            0x822FC278 => {
    //   block [0x822FC278..0x822FC2B0)
	// 822FC278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FC280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FC284: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC288: 386300CC  addi r3, r3, 0xcc
	ctx.r[3].s64 = ctx.r[3].s64 + 204;
	// 822FC28C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FC290: 4BFFFAF9  bl 0x822fbd88
	ctx.lr = 0x822FC294;
	sub_822FBD88(ctx, base);
	// 822FC294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FC298: 48AF7939  bl 0x82df3bd0
	ctx.lr = 0x822FC29C;
	sub_82DF3BD0(ctx, base);
	// 822FC29C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FC2A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FC2A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FC2A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FC2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC2B0 size=108
    let mut pc: u32 = 0x822FC2B0;
    'dispatch: loop {
        match pc {
            0x822FC2B0 => {
    //   block [0x822FC2B0..0x822FC31C)
	// 822FC2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC2B4: 48EABEB9  bl 0x831a816c
	ctx.lr = 0x822FC2B8;
	sub_831A8130(ctx, base);
	// 822FC2B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC2BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FC2C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FC2C4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 822FC2C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC2D0: 419A0014  beq cr6, 0x822fc2e4
	if ctx.cr[6].eq {
	pc = 0x822FC2E4; continue 'dispatch;
	}
	// 822FC2D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC2D8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FC2DC: 7D4A2E71  srawi. r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822FC2E0: 4082000C  bne 0x822fc2ec
	if !ctx.cr[0].eq {
	pc = 0x822FC2EC; continue 'dispatch;
	}
	// 822FC2E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FC2E8: 4800000C  b 0x822fc2f4
	pc = 0x822FC2F4; continue 'dispatch;
	// 822FC2EC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 822FC2F0: 7D7D2E70  srawi r29, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FC2F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FC2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC2FC: 4BFFFBBD  bl 0x822fbeb8
	ctx.lr = 0x822FC300;
	sub_822FBEB8(ctx, base);
	// 822FC300: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC304: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 822FC308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC30C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822FC310: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FC314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FC318: 48EABEA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC320 size=88
    let mut pc: u32 = 0x822FC320;
    'dispatch: loop {
        match pc {
            0x822FC320 => {
    //   block [0x822FC320..0x822FC378)
	// 822FC320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FC328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FC32C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FC330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FC338: 3BFE0174  addi r31, r30, 0x174
	ctx.r[31].s64 = ctx.r[30].s64 + 372;
	// 822FC33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC340: 488B6DC9  bl 0x82bb3108
	ctx.lr = 0x822FC344;
	sub_82BB3108(ctx, base);
	// 822FC344: 817E0178  lwz r11, 0x178(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 822FC348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC34C: 419A0010  beq cr6, 0x822fc35c
	if ctx.cr[6].eq {
	pc = 0x822FC35C; continue 'dispatch;
	}
	// 822FC350: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC354: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FC358: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 822FC35C: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 822FC360: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FC364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FC368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FC36C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FC370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FC374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC378 size=160
    let mut pc: u32 = 0x822FC378;
    'dispatch: loop {
        match pc {
            0x822FC378 => {
    //   block [0x822FC378..0x822FC418)
	// 822FC378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FC380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FC384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FC388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FC390: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC398: 409A000C  bne cr6, 0x822fc3a4
	if !ctx.cr[6].eq {
	pc = 0x822FC3A4; continue 'dispatch;
	}
	// 822FC39C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FC3A0: 48000010  b 0x822fc3b0
	pc = 0x822FC3B0; continue 'dispatch;
	// 822FC3A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC3A8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FC3AC: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 822FC3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC3B4: 419A0038  beq cr6, 0x822fc3ec
	if ctx.cr[6].eq {
	pc = 0x822FC3EC; continue 'dispatch;
	}
	// 822FC3B8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 822FC3BC: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 822FC3C0: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 822FC3C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC3C8: 40980024  bge cr6, 0x822fc3ec
	if !ctx.cr[6].lt {
	pc = 0x822FC3EC; continue 'dispatch;
	}
	// 822FC3CC: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC3D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822FC3D4: 419A000C  beq cr6, 0x822fc3e0
	if ctx.cr[6].eq {
	pc = 0x822FC3E0; continue 'dispatch;
	}
	// 822FC3D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC3DC: 4828FB35  bl 0x8258bf10
	ctx.lr = 0x822FC3E0;
	sub_8258BF10(ctx, base);
	// 822FC3E0: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 822FC3E4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FC3E8: 48000018  b 0x822fc400
	pc = 0x822FC400; continue 'dispatch;
	// 822FC3EC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822FC3F0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC3F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FC3F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC3FC: 4BFFFEB5  bl 0x822fc2b0
	ctx.lr = 0x822FC400;
	sub_822FC2B0(ctx, base);
	// 822FC400: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FC404: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FC408: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FC40C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FC410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FC414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FC418 size=104
    let mut pc: u32 = 0x822FC418;
    'dispatch: loop {
        match pc {
            0x822FC418 => {
    //   block [0x822FC418..0x822FC480)
	// 822FC418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FC420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FC424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FC428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FC430: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 822FC434: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 822FC438: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 822FC43C: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 822FC440: 38870004  addi r4, r7, 4
	ctx.r[4].s64 = ctx.r[7].s64 + 4;
	// 822FC444: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 822FC448: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 822FC44C: C0070000  lfs f0, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FC450: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 822FC454: 4BFFF9D5  bl 0x822fbe28
	ctx.lr = 0x822FC458;
	sub_822FBE28(ctx, base);
	// 822FC458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FC45C: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FC460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC464: 997F0021  stb r11, 0x21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(33 as u32), ctx.r[11].u8 ) };
	// 822FC468: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FC46C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FC470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FC474: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FC478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FC47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC480 size=108
    let mut pc: u32 = 0x822FC480;
    'dispatch: loop {
        match pc {
            0x822FC480 => {
    //   block [0x822FC480..0x822FC4EC)
	// 822FC480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC484: 48EABCDD  bl 0x831a8160
	ctx.lr = 0x822FC488;
	sub_831A8130(ctx, base);
	// 822FC488: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC48C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FC490: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FC494: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FC498: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822FC49C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822FC4A0: 38C00024  li r6, 0x24
	ctx.r[6].s64 = 36;
	// 822FC4A4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FC4A8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 822FC4AC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 822FC4B0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 822FC4B4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 822FC4B8: 48AF5C11  bl 0x82df20c8
	ctx.lr = 0x822FC4BC;
	sub_82DF20C8(ctx, base);
	// 822FC4BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822FC4C0: 41820020  beq 0x822fc4e0
	if ctx.cr[0].eq {
	pc = 0x822FC4E0; continue 'dispatch;
	}
	// 822FC4C4: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 822FC4C8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822FC4CC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FC4D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FC4D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FC4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC4DC: 4BFFFF3D  bl 0x822fc418
	ctx.lr = 0x822FC4E0;
	sub_822FC418(ctx, base);
	// 822FC4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FC4E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FC4E8: 48EABCC8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC4F0 size=548
    let mut pc: u32 = 0x822FC4F0;
    'dispatch: loop {
        match pc {
            0x822FC4F0 => {
    //   block [0x822FC4F0..0x822FC714)
	// 822FC4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC4F4: 48EABC6D  bl 0x831a8160
	ctx.lr = 0x822FC4F8;
	sub_831A8130(ctx, base);
	// 822FC4F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC4FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FC500: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 822FC504: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 822FC508: 616BCCCB  ori r11, r11, 0xcccb
	ctx.r[11].u64 = ctx.r[11].u64 | 52427;
	// 822FC50C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FC510: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC514: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FC518: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 822FC51C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC520: 41980048  blt cr6, 0x822fc568
	if ctx.cr[6].lt {
	pc = 0x822FC568; continue 'dispatch;
	}
	// 822FC524: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FC528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC52C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 822FC530: 4BFC9399  bl 0x822c58c8
	ctx.lr = 0x822FC534;
	sub_822C58C8(ctx, base);
	// 822FC534: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FC538: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FC53C: 4BFC92DD  bl 0x822c5818
	ctx.lr = 0x822FC540;
	sub_822C5818(ctx, base);
	// 822FC540: 4BFC7D71  bl 0x822c42b0
	ctx.lr = 0x822FC544;
	sub_822C42B0(ctx, base);
	// 822FC544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FC548: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FC54C: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 822FC550: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FC554: 4BFC8F1D  bl 0x822c5470
	ctx.lr = 0x822FC558;
	sub_822C5470(ctx, base);
	// 822FC558: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FC55C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FC560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC564: 4BFC877D  bl 0x822c4ce0
	ctx.lr = 0x822FC568;
	sub_822C4CE0(ctx, base);
	// 822FC568: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC56C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 822FC570: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FC574: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 822FC578: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FC57C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC580: 4BFFFF01  bl 0x822fc480
	ctx.lr = 0x822FC584;
	sub_822FC480(ctx, base);
	// 822FC584: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC588: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC58C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FC590: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FC594: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC598: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FC59C: 409A0018  bne cr6, 0x822fc5b4
	if !ctx.cr[6].eq {
	pc = 0x822FC5B4; continue 'dispatch;
	}
	// 822FC5A0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FC5A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC5A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC5AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC5B0: 4800003C  b 0x822fc5ec
	pc = 0x822FC5EC; continue 'dispatch;
	// 822FC5B4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FC5B8: 41820020  beq 0x822fc5d8
	if ctx.cr[0].eq {
	pc = 0x822FC5D8; continue 'dispatch;
	}
	// 822FC5BC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC5C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC5C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC5C8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FC5CC: 409A0024  bne cr6, 0x822fc5f0
	if !ctx.cr[6].eq {
	pc = 0x822FC5F0; continue 'dispatch;
	}
	// 822FC5D0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC5D4: 4800001C  b 0x822fc5f0
	pc = 0x822FC5F0; continue 'dispatch;
	// 822FC5D8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FC5DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC5E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC5E4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FC5E8: 409A0008  bne cr6, 0x822fc5f0
	if !ctx.cr[6].eq {
	pc = 0x822FC5F0; continue 'dispatch;
	}
	// 822FC5EC: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FC5F0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC5F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 822FC5F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 822FC5FC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 822FC600: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC604: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC608: 409A00F0  bne cr6, 0x822fc6f8
	if !ctx.cr[6].eq {
	pc = 0x822FC6F8; continue 'dispatch;
	}
	// 822FC60C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822FC610: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC614: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC618: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC61C: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 822FC620: 409A0054  bne cr6, 0x822fc674
	if !ctx.cr[6].eq {
	pc = 0x822FC674; continue 'dispatch;
	}
	// 822FC624: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC628: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC62C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FC630: 419A0054  beq cr6, 0x822fc684
	if ctx.cr[6].eq {
	pc = 0x822FC684; continue 'dispatch;
	}
	// 822FC634: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC638: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC63C: 409A0010  bne cr6, 0x822fc64c
	if !ctx.cr[6].eq {
	pc = 0x822FC64C; continue 'dispatch;
	}
	// 822FC640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC644: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FC648: 48157AD1  bl 0x82454118
	ctx.lr = 0x822FC64C;
	sub_82454118(ctx, base);
	// 822FC64C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC654: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC658: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC65C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC660: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 822FC664: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC668: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC66C: 484CCA3D  bl 0x827c90a8
	ctx.lr = 0x822FC670;
	sub_827C90A8(ctx, base);
	// 822FC670: 48000074  b 0x822fc6e4
	pc = 0x822FC6E4; continue 'dispatch;
	// 822FC674: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC678: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC67C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 822FC680: 409A0028  bne cr6, 0x822fc6a8
	if !ctx.cr[6].eq {
	pc = 0x822FC6A8; continue 'dispatch;
	}
	// 822FC684: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC688: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC68C: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC690: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC694: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC698: 9B6A0020  stb r27, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 822FC69C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC6A0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6A4: 48000040  b 0x822fc6e4
	pc = 0x822FC6E4; continue 'dispatch;
	// 822FC6A8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC6AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC6B0: 409A0010  bne cr6, 0x822fc6c0
	if !ctx.cr[6].eq {
	pc = 0x822FC6C0; continue 'dispatch;
	}
	// 822FC6B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC6B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FC6BC: 484CC9ED  bl 0x827c90a8
	ctx.lr = 0x822FC6C0;
	sub_827C90A8(ctx, base);
	// 822FC6C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FC6C8: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC6CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6D4: 9B6B0020  stb r27, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[27].u8 ) };
	// 822FC6D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6DC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6E0: 48157A39  bl 0x82454118
	ctx.lr = 0x822FC6E4;
	sub_82454118(ctx, base);
	// 822FC6E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6E8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FC6EC: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC6F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC6F4: 419AFF1C  beq cr6, 0x822fc610
	if ctx.cr[6].eq {
	pc = 0x822FC610; continue 'dispatch;
	}
	// 822FC6F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC6FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FC700: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC704: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC708: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC70C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 822FC710: 48EABAA0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FC718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FC718 size=1024
    let mut pc: u32 = 0x822FC718;
    'dispatch: loop {
        match pc {
            0x822FC718 => {
    //   block [0x822FC718..0x822FCB18)
	// 822FC718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FC71C: 48EABA3D  bl 0x831a8158
	ctx.lr = 0x822FC720;
	sub_831A8130(ctx, base);
	// 822FC720: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FC724: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FC728: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 822FC72C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 822FC730: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 822FC734: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC73C: 419A0048  beq cr6, 0x822fc784
	if ctx.cr[6].eq {
	pc = 0x822FC784; continue 'dispatch;
	}
	// 822FC740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FC744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC748: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 822FC74C: 4BFC917D  bl 0x822c58c8
	ctx.lr = 0x822FC750;
	sub_822C58C8(ctx, base);
	// 822FC750: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FC754: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FC758: 4BFCD759  bl 0x822c9eb0
	ctx.lr = 0x822FC75C;
	sub_822C9EB0(ctx, base);
	// 822FC75C: 4BFC7B55  bl 0x822c42b0
	ctx.lr = 0x822FC760;
	sub_822C42B0(ctx, base);
	// 822FC760: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FC764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FC768: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 822FC76C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 822FC770: 4BFC8D01  bl 0x822c5470
	ctx.lr = 0x822FC774;
	sub_822C5470(ctx, base);
	// 822FC774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FC778: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FC77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FC780: 4BFC8561  bl 0x822c4ce0
	ctx.lr = 0x822FC784;
	sub_822C4CE0(ctx, base);
	// 822FC784: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 822FC788: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 822FC78C: 484CC8A5  bl 0x827c9030
	ctx.lr = 0x822FC790;
	sub_827C9030(ctx, base);
	// 822FC790: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC794: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC798: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC79C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822FC7A0: 419A000C  beq cr6, 0x822fc7ac
	if ctx.cr[6].eq {
	pc = 0x822FC7AC; continue 'dispatch;
	}
	// 822FC7A4: 839B0008  lwz r28, 8(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC7A8: 48000028  b 0x822fc7d0
	pc = 0x822FC7D0; continue 'dispatch;
	// 822FC7AC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC7B0: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC7B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC7B8: 419A000C  beq cr6, 0x822fc7c4
	if ctx.cr[6].eq {
	pc = 0x822FC7C4; continue 'dispatch;
	}
	// 822FC7BC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 822FC7C0: 48000010  b 0x822fc7d0
	pc = 0x822FC7D0; continue 'dispatch;
	// 822FC7C4: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC7C8: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC7CC: 409A00DC  bne cr6, 0x822fc8a8
	if !ctx.cr[6].eq {
	pc = 0x822FC8A8; continue 'dispatch;
	}
	// 822FC7D0: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC7D4: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC7DC: 409A0008  bne cr6, 0x822fc7e4
	if !ctx.cr[6].eq {
	pc = 0x822FC7E4; continue 'dispatch;
	}
	// 822FC7E0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FC7E4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC7E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC7EC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC7F0: 409A000C  bne cr6, 0x822fc7fc
	if !ctx.cr[6].eq {
	pc = 0x822FC7FC; continue 'dispatch;
	}
	// 822FC7F4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 822FC7F8: 4800001C  b 0x822fc814
	pc = 0x822FC814; continue 'dispatch;
	// 822FC7FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC800: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC804: 409A000C  bne cr6, 0x822fc810
	if !ctx.cr[6].eq {
	pc = 0x822FC810; continue 'dispatch;
	}
	// 822FC808: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC80C: 48000008  b 0x822fc814
	pc = 0x822FC814; continue 'dispatch;
	// 822FC810: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 822FC814: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC818: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC81C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC820: 409A003C  bne cr6, 0x822fc85c
	if !ctx.cr[6].eq {
	pc = 0x822FC85C; continue 'dispatch;
	}
	// 822FC824: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC82C: 419A000C  beq cr6, 0x822fc838
	if ctx.cr[6].eq {
	pc = 0x822FC838; continue 'dispatch;
	}
	// 822FC830: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FC834: 48000024  b 0x822fc858
	pc = 0x822FC858; continue 'dispatch;
	// 822FC838: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC83C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FC840: 4800000C  b 0x822fc84c
	pc = 0x822FC84C; continue 'dispatch;
	// 822FC844: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FC848: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC84C: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC850: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FC854: 419AFFF0  beq cr6, 0x822fc844
	if ctx.cr[6].eq {
	pc = 0x822FC844; continue 'dispatch;
	}
	// 822FC858: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FC85C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC860: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC864: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC868: 409A00D4  bne cr6, 0x822fc93c
	if !ctx.cr[6].eq {
	pc = 0x822FC93C; continue 'dispatch;
	}
	// 822FC86C: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC874: 419A000C  beq cr6, 0x822fc880
	if ctx.cr[6].eq {
	pc = 0x822FC880; continue 'dispatch;
	}
	// 822FC878: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 822FC87C: 48000024  b 0x822fc8a0
	pc = 0x822FC8A0; continue 'dispatch;
	// 822FC880: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC884: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 822FC888: 4800000C  b 0x822fc894
	pc = 0x822FC894; continue 'dispatch;
	// 822FC88C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FC890: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC894: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC898: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 822FC89C: 419AFFF0  beq cr6, 0x822fc88c
	if ctx.cr[6].eq {
	pc = 0x822FC88C; continue 'dispatch;
	}
	// 822FC8A0: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FC8A4: 48000098  b 0x822fc93c
	pc = 0x822FC93C; continue 'dispatch;
	// 822FC8A8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FC8AC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC8B0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FC8B4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC8B8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC8BC: 409A000C  bne cr6, 0x822fc8c8
	if !ctx.cr[6].eq {
	pc = 0x822FC8C8; continue 'dispatch;
	}
	// 822FC8C0: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 822FC8C4: 4800002C  b 0x822fc8f0
	pc = 0x822FC8F0; continue 'dispatch;
	// 822FC8C8: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC8CC: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FC8D4: 409A0008  bne cr6, 0x822fc8dc
	if !ctx.cr[6].eq {
	pc = 0x822FC8DC; continue 'dispatch;
	}
	// 822FC8D8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 822FC8DC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 822FC8E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC8E4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FC8E8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC8EC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FC8F0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC8F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC8F8: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC8FC: 409A000C  bne cr6, 0x822fc908
	if !ctx.cr[6].eq {
	pc = 0x822FC908; continue 'dispatch;
	}
	// 822FC900: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 822FC904: 48000020  b 0x822fc924
	pc = 0x822FC924; continue 'dispatch;
	// 822FC908: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC90C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC910: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FC914: 409A000C  bne cr6, 0x822fc920
	if !ctx.cr[6].eq {
	pc = 0x822FC920; continue 'dispatch;
	}
	// 822FC918: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FC91C: 48000008  b 0x822fc924
	pc = 0x822FC924; continue 'dispatch;
	// 822FC920: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 822FC924: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC928: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FC92C: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC930: 89590020  lbz r10, 0x20(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC934: 99790020  stb r11, 0x20(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 822FC938: 995B0020  stb r10, 0x20(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 822FC93C: 897B0020  lbz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC940: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FC944: 409A0198  bne cr6, 0x822fcadc
	if !ctx.cr[6].eq {
	pc = 0x822FCADC; continue 'dispatch;
	}
	// 822FC948: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC94C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 822FC950: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FC954: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC958: 419A0180  beq cr6, 0x822fcad8
	if ctx.cr[6].eq {
	pc = 0x822FCAD8; continue 'dispatch;
	}
	// 822FC95C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FC960: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC964: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FC968: 409A0170  bne cr6, 0x822fcad8
	if !ctx.cr[6].eq {
	pc = 0x822FCAD8; continue 'dispatch;
	}
	// 822FC96C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC970: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FC974: 409A00A8  bne cr6, 0x822fca1c
	if !ctx.cr[6].eq {
	pc = 0x822FCA1C; continue 'dispatch;
	}
	// 822FC978: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC97C: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC980: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC984: 409A001C  bne cr6, 0x822fc9a0
	if !ctx.cr[6].eq {
	pc = 0x822FC9A0; continue 'dispatch;
	}
	// 822FC988: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FC98C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FC990: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC994: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FC998: 48157781  bl 0x82454118
	ctx.lr = 0x822FC99C;
	sub_82454118(ctx, base);
	// 822FC99C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC9A0: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FC9A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FC9A8: 409A00C8  bne cr6, 0x822fca70
	if !ctx.cr[6].eq {
	pc = 0x822FCA70; continue 'dispatch;
	}
	// 822FC9AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC9B0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC9B4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FC9B8: 409A0014  bne cr6, 0x822fc9cc
	if !ctx.cr[6].eq {
	pc = 0x822FC9CC; continue 'dispatch;
	}
	// 822FC9BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC9C0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC9C4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FC9C8: 419A00A4  beq cr6, 0x822fca6c
	if ctx.cr[6].eq {
	pc = 0x822FCA6C; continue 'dispatch;
	}
	// 822FC9CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC9D0: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC9D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FC9D8: 409A0020  bne cr6, 0x822fc9f8
	if !ctx.cr[6].eq {
	pc = 0x822FC9F8; continue 'dispatch;
	}
	// 822FC9DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FC9E0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FC9E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FC9E8: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FC9EC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FC9F0: 484CC6B9  bl 0x827c90a8
	ctx.lr = 0x822FC9F4;
	sub_827C90A8(ctx, base);
	// 822FC9F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FC9F8: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FC9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FCA00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FCA04: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 822FCA08: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCA0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCA10: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCA14: 48157705  bl 0x82454118
	ctx.lr = 0x822FCA18;
	sub_82454118(ctx, base);
	// 822FCA18: 480000C0  b 0x822fcad8
	pc = 0x822FCAD8; continue 'dispatch;
	// 822FCA1C: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FCA20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FCA24: 409A001C  bne cr6, 0x822fca40
	if !ctx.cr[6].eq {
	pc = 0x822FCA40; continue 'dispatch;
	}
	// 822FCA28: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCA2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FCA30: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FCA34: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FCA38: 484CC671  bl 0x827c90a8
	ctx.lr = 0x822FCA3C;
	sub_827C90A8(ctx, base);
	// 822FCA3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCA40: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FCA48: 409A0028  bne cr6, 0x822fca70
	if !ctx.cr[6].eq {
	pc = 0x822FCA70; continue 'dispatch;
	}
	// 822FCA4C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCA50: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FCA54: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FCA58: 409A0034  bne cr6, 0x822fca8c
	if !ctx.cr[6].eq {
	pc = 0x822FCA8C; continue 'dispatch;
	}
	// 822FCA5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCA60: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FCA64: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FCA68: 409A0024  bne cr6, 0x822fca8c
	if !ctx.cr[6].eq {
	pc = 0x822FCA8C; continue 'dispatch;
	}
	// 822FCA6C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FCA70: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCA74: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 822FCA78: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCA7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCA80: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FCA84: 409AFEDC  bne cr6, 0x822fc960
	if !ctx.cr[6].eq {
	pc = 0x822FC960; continue 'dispatch;
	}
	// 822FCA88: 48000050  b 0x822fcad8
	pc = 0x822FCAD8; continue 'dispatch;
	// 822FCA8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCA90: 894A0020  lbz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FCA94: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 822FCA98: 409A0020  bne cr6, 0x822fcab8
	if !ctx.cr[6].eq {
	pc = 0x822FCAB8; continue 'dispatch;
	}
	// 822FCA9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCAA0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FCAA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FCAA8: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCAAC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 822FCAB0: 48157669  bl 0x82454118
	ctx.lr = 0x822FCAB4;
	sub_82454118(ctx, base);
	// 822FCAB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCAB8: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FCABC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FCAC0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FCAC4: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 822FCAC8: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCACC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCAD0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCAD4: 484CC5D5  bl 0x827c90a8
	ctx.lr = 0x822FCAD8;
	sub_827C90A8(ctx, base);
	// 822FCAD8: 9BDC0020  stb r30, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 822FCADC: 387B0010  addi r3, r27, 0x10
	ctx.r[3].s64 = ctx.r[27].s64 + 16;
	// 822FCAE0: 487E0A11  bl 0x82add4f0
	ctx.lr = 0x822FCAE4;
	sub_82ADD4F0(ctx, base);
	// 822FCAE4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FCAE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FCAEC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FCAF0: 48AF5699  bl 0x82df2188
	ctx.lr = 0x822FCAF4;
	sub_82DF2188(ctx, base);
	// 822FCAF4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCAF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCAFC: 419A000C  beq cr6, 0x822fcb08
	if ctx.cr[6].eq {
	pc = 0x822FCB08; continue 'dispatch;
	}
	// 822FCB00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 822FCB04: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FCB08: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 822FCB0C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 822FCB10: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 822FCB14: 48EAB694  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FCB18 size=100
    let mut pc: u32 = 0x822FCB18;
    'dispatch: loop {
        match pc {
            0x822FCB18 => {
    //   block [0x822FCB18..0x822FCB7C)
	// 822FCB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCB1C: 48EAB64D  bl 0x831a8168
	ctx.lr = 0x822FCB20;
	sub_831A8130(ctx, base);
	// 822FCB20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCB24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FCB28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FCB2C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 822FCB30: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCB34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCB38: 409A003C  bne cr6, 0x822fcb74
	if !ctx.cr[6].eq {
	pc = 0x822FCB74; continue 'dispatch;
	}
	// 822FCB3C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 822FCB40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FCB44: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCB48: 4BFFFFD1  bl 0x822fcb18
	ctx.lr = 0x822FCB4C;
	sub_822FCB18(ctx, base);
	// 822FCB4C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 822FCB50: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCB54: 487E099D  bl 0x82add4f0
	ctx.lr = 0x822FCB58;
	sub_82ADD4F0(ctx, base);
	// 822FCB58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FCB5C: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FCB60: 48AF5629  bl 0x82df2188
	ctx.lr = 0x822FCB64;
	sub_82DF2188(ctx, base);
	// 822FCB64: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCB68: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 822FCB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCB70: 419AFFD0  beq cr6, 0x822fcb40
	if ctx.cr[6].eq {
	pc = 0x822FCB40; continue 'dispatch;
	}
	// 822FCB74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FCB78: 48EAB640  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FCB80 size=264
    let mut pc: u32 = 0x822FCB80;
    'dispatch: loop {
        match pc {
            0x822FCB80 => {
    //   block [0x822FCB80..0x822FCC88)
	// 822FCB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCB84: 48EAB5DD  bl 0x831a8160
	ctx.lr = 0x822FCB88;
	sub_831A8130(ctx, base);
	// 822FCB88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCB8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822FCB90: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 822FCB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FCB98: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 822FCB9C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 822FCBA0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCBA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCBA8: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCBAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FCBB0: 409A0040  bne cr6, 0x822fcbf0
	if !ctx.cr[6].eq {
	pc = 0x822FCBF0; continue 'dispatch;
	}
	// 822FCBB4: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCBB8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FCBBC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 822FCBC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822FCBC4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 822FCBC8: 41980008  blt cr6, 0x822fcbd0
	if ctx.cr[6].lt {
	pc = 0x822FCBD0; continue 'dispatch;
	}
	// 822FCBCC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FCBD0: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822FCBD4: 4182000C  beq 0x822fcbe0
	if ctx.cr[0].eq {
	pc = 0x822FCBE0; continue 'dispatch;
	}
	// 822FCBD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCBDC: 48000008  b 0x822fcbe4
	pc = 0x822FCBE4; continue 'dispatch;
	// 822FCBE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCBE4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCBE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 822FCBEC: 419AFFCC  beq cr6, 0x822fcbb8
	if ctx.cr[6].eq {
	pc = 0x822FCBB8; continue 'dispatch;
	}
	// 822FCBF0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 822FCBF4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCBF8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822FCBFC: 41820048  beq 0x822fcc44
	if ctx.cr[0].eq {
	pc = 0x822FCC44; continue 'dispatch;
	}
	// 822FCC00: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCC04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCC08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCC0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FCC10: 409A002C  bne cr6, 0x822fcc3c
	if !ctx.cr[6].eq {
	pc = 0x822FCC3C; continue 'dispatch;
	}
	// 822FCC14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FCC18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FCC1C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FCC20: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 822FCC24: 4BFFF8CD  bl 0x822fc4f0
	ctx.lr = 0x822FCC28;
	sub_822FC4F0(ctx, base);
	// 822FCC28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FCC2C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 822FCC30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCC34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FCC38: 48000044  b 0x822fcc7c
	pc = 0x822FCC7C; continue 'dispatch;
	// 822FCC3C: 4889171D  bl 0x82b8e358
	ctx.lr = 0x822FCC40;
	sub_82B8E358(ctx, base);
	// 822FCC40: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FCC44: C00A000C  lfs f0, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCC48: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 822FCC4C: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FCC50: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822FCC54: 41980008  blt cr6, 0x822fcc5c
	if ctx.cr[6].lt {
	pc = 0x822FCC5C; continue 'dispatch;
	}
	// 822FCC58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCC5C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCC60: 41820010  beq 0x822fcc70
	if ctx.cr[0].eq {
	pc = 0x822FCC70; continue 'dispatch;
	}
	// 822FCC64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FCC68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCC6C: 4BFFFFAC  b 0x822fcc18
	pc = 0x822FCC18; continue 'dispatch;
	// 822FCC70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCC74: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FCC78: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 822FCC7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCC80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FCC84: 48EAB52C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FCC88 size=84
    let mut pc: u32 = 0x822FCC88;
    'dispatch: loop {
        match pc {
            0x822FCC88 => {
    //   block [0x822FCC88..0x822FCCDC)
	// 822FCC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FCC90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FCC94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCC98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FCC9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCCA0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCCA4: 4BFFFE75  bl 0x822fcb18
	ctx.lr = 0x822FCCA8;
	sub_822FCB18(ctx, base);
	// 822FCCA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCCAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCCB0: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822FCCB4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FCCB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCCBC: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FCCC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCCC4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FCCC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FCCCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FCCD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FCCD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FCCD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FCCE0 size=460
    let mut pc: u32 = 0x822FCCE0;
    'dispatch: loop {
        match pc {
            0x822FCCE0 => {
    //   block [0x822FCCE0..0x822FCEAC)
	// 822FCCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCCE4: 48EAB481  bl 0x831a8164
	ctx.lr = 0x822FCCE8;
	sub_831A8130(ctx, base);
	// 822FCCE8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 822FCCEC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 822FCCF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCCF4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822FCCF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FCCFC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822FCD00: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822FCD04: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCD0C: 409A0020  bne cr6, 0x822fcd2c
	if !ctx.cr[6].eq {
	pc = 0x822FCD2C; continue 'dispatch;
	}
	// 822FCD10: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCD14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FCD18: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FCD1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FCD20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCD24: 4BFFF7CD  bl 0x822fc4f0
	ctx.lr = 0x822FCD28;
	sub_822FC4F0(ctx, base);
	// 822FCD28: 48000170  b 0x822fce98
	pc = 0x822FCE98; continue 'dispatch;
	// 822FCD2C: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCD30: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCD34: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FCD38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822FCD3C: 409A0028  bne cr6, 0x822fcd64
	if !ctx.cr[6].eq {
	pc = 0x822FCD64; continue 'dispatch;
	}
	// 822FCD40: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCD44: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FCD48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822FCD4C: 41980008  blt cr6, 0x822fcd54
	if ctx.cr[6].lt {
	pc = 0x822FCD54; continue 'dispatch;
	}
	// 822FCD50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCD54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCD58: 41820124  beq 0x822fce7c
	if ctx.cr[0].eq {
	pc = 0x822FCE7C; continue 'dispatch;
	}
	// 822FCD5C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FCD60: 4BFFFFB4  b 0x822fcd14
	pc = 0x822FCD14; continue 'dispatch;
	// 822FCD64: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FCD68: 409A002C  bne cr6, 0x822fcd94
	if !ctx.cr[6].eq {
	pc = 0x822FCD94; continue 'dispatch;
	}
	// 822FCD6C: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCD70: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCD74: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FCD78: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 822FCD7C: 41980008  blt cr6, 0x822fcd84
	if ctx.cr[6].lt {
	pc = 0x822FCD84; continue 'dispatch;
	}
	// 822FCD80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCD84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCD88: 418200F4  beq 0x822fce7c
	if ctx.cr[0].eq {
	pc = 0x822FCE7C; continue 'dispatch;
	}
	// 822FCD8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FCD90: 4BFFFF88  b 0x822fcd18
	pc = 0x822FCD18; continue 'dispatch;
	// 822FCD94: C3FD0000  lfs f31, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FCD98: C3DE000C  lfs f30, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822FCD9C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 822FCDA0: 41980008  blt cr6, 0x822fcda8
	if ctx.cr[6].lt {
	pc = 0x822FCDA8; continue 'dispatch;
	}
	// 822FCDA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCDA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCDAC: 41820060  beq 0x822fce0c
	if ctx.cr[0].eq {
	pc = 0x822FCE0C; continue 'dispatch;
	}
	// 822FCDB0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822FCDB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCDB8: 488915A1  bl 0x82b8e358
	ctx.lr = 0x822FCDBC;
	sub_82B8E358(ctx, base);
	// 822FCDBC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FCDC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822FCDC4: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCDC8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 822FCDCC: 41980008  blt cr6, 0x822fcdd4
	if ctx.cr[6].lt {
	pc = 0x822FCDD4; continue 'dispatch;
	}
	// 822FCDD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCDD4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCDD8: 41820034  beq 0x822fce0c
	if ctx.cr[0].eq {
	pc = 0x822FCE0C; continue 'dispatch;
	}
	// 822FCDDC: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCDE0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FCDE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FCDE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCDEC: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCDF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCDF4: 419A000C  beq cr6, 0x822fce00
	if ctx.cr[6].eq {
	pc = 0x822FCE00; continue 'dispatch;
	}
	// 822FCDF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FCDFC: 4BFFFF28  b 0x822fcd24
	pc = 0x822FCD24; continue 'dispatch;
	// 822FCE00: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FCE04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 822FCE08: 4BFFFF1C  b 0x822fcd24
	pc = 0x822FCD24; continue 'dispatch;
	// 822FCE0C: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 822FCE10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822FCE14: 41980008  blt cr6, 0x822fce1c
	if ctx.cr[6].lt {
	pc = 0x822FCE1C; continue 'dispatch;
	}
	// 822FCE18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCE1C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCE20: 4182005C  beq 0x822fce7c
	if ctx.cr[0].eq {
	pc = 0x822FCE7C; continue 'dispatch;
	}
	// 822FCE24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 822FCE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCE2C: 484CC205  bl 0x827c9030
	ctx.lr = 0x822FCE30;
	sub_827C9030(ctx, base);
	// 822FCE30: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FCE34: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 822FCE38: 419A0020  beq cr6, 0x822fce58
	if ctx.cr[6].eq {
	pc = 0x822FCE58; continue 'dispatch;
	}
	// 822FCE3C: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCE40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822FCE44: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 822FCE48: 41980008  blt cr6, 0x822fce50
	if ctx.cr[6].lt {
	pc = 0x822FCE50; continue 'dispatch;
	}
	// 822FCE4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCE50: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FCE54: 41820028  beq 0x822fce7c
	if ctx.cr[0].eq {
	pc = 0x822FCE7C; continue 'dispatch;
	}
	// 822FCE58: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FCE5C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 822FCE60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FCE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCE68: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 822FCE6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FCE70: 419AFF94  beq cr6, 0x822fce04
	if ctx.cr[6].eq {
	pc = 0x822FCE04; continue 'dispatch;
	}
	// 822FCE74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 822FCE78: 4BFFFF80  b 0x822fcdf8
	pc = 0x822FCDF8; continue 'dispatch;
	// 822FCE7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FCE80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FCE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCE88: 4BFFFCF9  bl 0x822fcb80
	ctx.lr = 0x822FCE8C;
	sub_822FCB80(ctx, base);
	// 822FCE8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FCE90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCE94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FCE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCE9C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FCEA0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822FCEA4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 822FCEA8: 48EAB30C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FCEB0 size=132
    let mut pc: u32 = 0x822FCEB0;
    'dispatch: loop {
        match pc {
            0x822FCEB0 => {
    //   block [0x822FCEB0..0x822FCF34)
	// 822FCEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCEB4: 48EAB2B5  bl 0x831a8168
	ctx.lr = 0x822FCEB8;
	sub_831A8130(ctx, base);
	// 822FCEB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCEBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FCEC0: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 822FCEC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FCEC8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822FCECC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCED0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCED4: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FCED8: 409A0044  bne cr6, 0x822fcf1c
	if !ctx.cr[6].eq {
	pc = 0x822FCF1C; continue 'dispatch;
	}
	// 822FCEDC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FCEE0: 409A003C  bne cr6, 0x822fcf1c
	if !ctx.cr[6].eq {
	pc = 0x822FCF1C; continue 'dispatch;
	}
	// 822FCEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FCEE8: 4BFFFDA1  bl 0x822fcc88
	ctx.lr = 0x822FCEEC;
	sub_822FCC88(ctx, base);
	// 822FCEEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCEF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCEF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FCEF8: 48000030  b 0x822fcf28
	pc = 0x822FCF28; continue 'dispatch;
	// 822FCEFC: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 822FCF00: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FCF04: 484CC12D  bl 0x827c9030
	ctx.lr = 0x822FCF08;
	sub_827C9030(ctx, base);
	// 822FCF08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FCF0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FCF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCF14: 4BFFF805  bl 0x822fc718
	ctx.lr = 0x822FCF18;
	sub_822FC718(ctx, base);
	// 822FCF18: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822FCF1C: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 822FCF20: 409AFFDC  bne cr6, 0x822fcefc
	if !ctx.cr[6].eq {
	pc = 0x822FCEFC; continue 'dispatch;
	}
	// 822FCF24: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 822FCF28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FCF2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FCF30: 48EAB288  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FCF38 size=164
    let mut pc: u32 = 0x822FCF38;
    'dispatch: loop {
        match pc {
            0x822FCF38 => {
    //   block [0x822FCF38..0x822FCFDC)
	// 822FCF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCF3C: 48EAB231  bl 0x831a816c
	ctx.lr = 0x822FCF40;
	sub_831A8130(ctx, base);
	// 822FCF40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCF44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FCF48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FCF4C: 4BFFC1F5  bl 0x822f9140
	ctx.lr = 0x822FCF50;
	sub_822F9140(ctx, base);
	// 822FCF50: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FCF54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FCF58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FCF5C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FCF60: 419A0024  beq cr6, 0x822fcf84
	if ctx.cr[6].eq {
	pc = 0x822FCF84; continue 'dispatch;
	}
	// 822FCF64: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCF68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822FCF6C: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FCF70: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822FCF74: 41980008  blt cr6, 0x822fcf7c
	if ctx.cr[6].lt {
	pc = 0x822FCF7C; continue 'dispatch;
	}
	// 822FCF78: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 822FCF7C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 822FCF80: 41820050  beq 0x822fcfd0
	if ctx.cr[0].eq {
	pc = 0x822FCFD0; continue 'dispatch;
	}
	// 822FCF84: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FCF88: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 822FCF8C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 822FCF90: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 822FCF94: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 822FCF98: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 822FCF9C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 822FCFA0: 4BFFEE89  bl 0x822fbe28
	ctx.lr = 0x822FCFA4;
	sub_822FBE28(ctx, base);
	// 822FCFA4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 822FCFA8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FCFAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FCFB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCFB4: 4BFFFD2D  bl 0x822fcce0
	ctx.lr = 0x822FCFB8;
	sub_822FCCE0(ctx, base);
	// 822FCFB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FCFBC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 822FCFC0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FCFC4: 487E052D  bl 0x82add4f0
	ctx.lr = 0x822FCFC8;
	sub_82ADD4F0(ctx, base);
	// 822FCFC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FCFCC: 487E0525  bl 0x82add4f0
	ctx.lr = 0x822FCFD0;
	sub_82ADD4F0(ctx, base);
	// 822FCFD0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 822FCFD4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FCFD8: 48EAB1E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FCFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FCFE0 size=88
    let mut pc: u32 = 0x822FCFE0;
    'dispatch: loop {
        match pc {
            0x822FCFE0 => {
    //   block [0x822FCFE0..0x822FD038)
	// 822FCFE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FCFE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FCFE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FCFEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FCFF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FCFF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FCFF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FCFFC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD000: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD004: 4BFFFEAD  bl 0x822fceb0
	ctx.lr = 0x822FD008;
	sub_822FCEB0(ctx, base);
	// 822FD008: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FD00C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD010: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 822FD014: 48AF5175  bl 0x82df2188
	ctx.lr = 0x822FD018;
	sub_82DF2188(ctx, base);
	// 822FD018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FD01C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FD020: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FD024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD038 size=72
    let mut pc: u32 = 0x822FD038;
    'dispatch: loop {
        match pc {
            0x822FD038 => {
    //   block [0x822FD038..0x822FD080)
	// 822FD038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD040: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD044: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD048: D021007C  stfs f1, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 822FD04C: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 822FD050: 386300B0  addi r3, r3, 0xb0
	ctx.r[3].s64 = ctx.r[3].s64 + 176;
	// 822FD054: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FD058: 4BFFFEE1  bl 0x822fcf38
	ctx.lr = 0x822FD05C;
	sub_822FCF38(ctx, base);
	// 822FD05C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD060: 4BFFF319  bl 0x822fc378
	ctx.lr = 0x822FD064;
	sub_822FC378(ctx, base);
	// 822FD064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD068: 4BFCBC51  bl 0x822c8cb8
	ctx.lr = 0x822FD06C;
	sub_822C8CB8(ctx, base);
	// 822FD06C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FD070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD080 size=212
    let mut pc: u32 = 0x822FD080;
    'dispatch: loop {
        match pc {
            0x822FD080 => {
    //   block [0x822FD080..0x822FD154)
	// 822FD080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD08C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FD098: 48B5F891  bl 0x82e5c928
	ctx.lr = 0x822FD09C;
	sub_82E5C928(ctx, base);
	// 822FD09C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FD0A0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 822FD0A4: 396BC728  addi r11, r11, -0x38d8
	ctx.r[11].s64 = ctx.r[11].s64 + -14552;
	// 822FD0A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FD0AC: 4BFFBC1D  bl 0x822f8cc8
	ctx.lr = 0x822FD0B0;
	sub_822F8CC8(ctx, base);
	// 822FD0B0: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 822FD0B4: 4818D60D  bl 0x8248a6c0
	ctx.lr = 0x822FD0B8;
	sub_8248A6C0(ctx, base);
	// 822FD0B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 822FD0BC: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 822FD0C0: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 822FD0C4: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 822FD0C8: 48AF6029  bl 0x82df30f0
	ctx.lr = 0x822FD0CC;
	sub_82DF30F0(ctx, base);
	// 822FD0CC: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 822FD0D0: 9BDF0091  stb r30, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[30].u8 ) };
	// 822FD0D4: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 822FD0D8: 48AF6019  bl 0x82df30f0
	ctx.lr = 0x822FD0DC;
	sub_82DF30F0(ctx, base);
	// 822FD0DC: 387F009C  addi r3, r31, 0x9c
	ctx.r[3].s64 = ctx.r[31].s64 + 156;
	// 822FD0E0: 4BFFBBE9  bl 0x822f8cc8
	ctx.lr = 0x822FD0E4;
	sub_822F8CC8(ctx, base);
	// 822FD0E4: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 822FD0E8: 488924B1  bl 0x82b8f598
	ctx.lr = 0x822FD0EC;
	sub_82B8F598(ctx, base);
	// 822FD0EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FD0F0: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 822FD0F4: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 822FD0F8: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FD0FC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 822FD100: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 822FD104: 4800C325  bl 0x82309428
	ctx.lr = 0x822FD108;
	sub_82309428(ctx, base);
	// 822FD108: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 822FD10C: 480018A5  bl 0x822fe9b0
	ctx.lr = 0x822FD110;
	sub_822FE9B0(ctx, base);
	// 822FD110: 387F016C  addi r3, r31, 0x16c
	ctx.r[3].s64 = ctx.r[31].s64 + 364;
	// 822FD114: 48B637ED  bl 0x82e60900
	ctx.lr = 0x822FD118;
	sub_82E60900(ctx, base);
	// 822FD118: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FD11C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 822FD120: 396BC71C  addi r11, r11, -0x38e4
	ctx.r[11].s64 = ctx.r[11].s64 + -14564;
	// 822FD124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD128: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 822FD12C: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 822FD130: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 822FD134: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 822FD138: 915F0184  stw r10, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 822FD13C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD158 size=164
    let mut pc: u32 = 0x822FD158;
    'dispatch: loop {
        match pc {
            0x822FD158 => {
    //   block [0x822FD158..0x822FD1FC)
	// 822FD158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FD170: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 822FD174: 481B412D  bl 0x824b12a0
	ctx.lr = 0x822FD178;
	sub_824B12A0(ctx, base);
	// 822FD178: 387F016C  addi r3, r31, 0x16c
	ctx.r[3].s64 = ctx.r[31].s64 + 364;
	// 822FD17C: 48B637F5  bl 0x82e60970
	ctx.lr = 0x822FD180;
	sub_82E60970(ctx, base);
	// 822FD180: 3BDF00D8  addi r30, r31, 0xd8
	ctx.r[30].s64 = ctx.r[31].s64 + 216;
	// 822FD184: 387E0090  addi r3, r30, 0x90
	ctx.r[3].s64 = ctx.r[30].s64 + 144;
	// 822FD188: 48AF62A1  bl 0x82df3428
	ctx.lr = 0x822FD18C;
	sub_82DF3428(ctx, base);
	// 822FD18C: 387E006C  addi r3, r30, 0x6c
	ctx.r[3].s64 = ctx.r[30].s64 + 108;
	// 822FD190: 48AF6299  bl 0x82df3428
	ctx.lr = 0x822FD194;
	sub_82DF3428(ctx, base);
	// 822FD194: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 822FD198: 482B2F79  bl 0x825b0110
	ctx.lr = 0x822FD19C;
	sub_825B0110(ctx, base);
	// 822FD19C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD1A0: 48B606A9  bl 0x82e5d848
	ctx.lr = 0x822FD1A4;
	sub_82E5D848(ctx, base);
	// 822FD1A4: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 822FD1A8: 4BFFEB01  bl 0x822fbca8
	ctx.lr = 0x822FD1AC;
	sub_822FBCA8(ctx, base);
	// 822FD1AC: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 822FD1B0: 4BFFFE31  bl 0x822fcfe0
	ctx.lr = 0x822FD1B4;
	sub_822FCFE0(ctx, base);
	// 822FD1B4: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 822FD1B8: 48AF6271  bl 0x82df3428
	ctx.lr = 0x822FD1BC;
	sub_82DF3428(ctx, base);
	// 822FD1BC: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 822FD1C0: 48AF6269  bl 0x82df3428
	ctx.lr = 0x822FD1C4;
	sub_82DF3428(ctx, base);
	// 822FD1C4: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 822FD1C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FD1CC: 419A0008  beq cr6, 0x822fd1d4
	if ctx.cr[6].eq {
	pc = 0x822FD1D4; continue 'dispatch;
	}
	// 822FD1D0: 4BFC36C1  bl 0x822c0890
	ctx.lr = 0x822FD1D4;
	sub_822C0890(ctx, base);
	// 822FD1D4: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 822FD1D8: 4BFFE8D1  bl 0x822fbaa8
	ctx.lr = 0x822FD1DC;
	sub_822FBAA8(ctx, base);
	// 822FD1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD1E0: 48B5F3A9  bl 0x82e5c588
	ctx.lr = 0x822FD1E4;
	sub_82E5C588(ctx, base);
	// 822FD1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD1F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822FD200 size=40
    let mut pc: u32 = 0x822FD200;
    'dispatch: loop {
        match pc {
            0x822FD200 => {
    //   block [0x822FD200..0x822FD228)
	// 822FD200: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 822FD204: 39430078  addi r10, r3, 0x78
	ctx.r[10].s64 = ctx.r[3].s64 + 120;
	// 822FD208: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 822FD20C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 822FD210: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD214: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822FD218: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822FD21C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 822FD220: 4200FFF0  bdnz 0x822fd210
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x822FD210; continue 'dispatch;
	}
	// 822FD224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822FD228 size=8
    let mut pc: u32 = 0x822FD228;
    'dispatch: loop {
        match pc {
            0x822FD228 => {
    //   block [0x822FD228..0x822FD230)
	// 822FD228: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FD22C: 48B5F3CC  b 0x82e5c5f8
	sub_82E5C5F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD230 size=196
    let mut pc: u32 = 0x822FD230;
    'dispatch: loop {
        match pc {
            0x822FD230 => {
    //   block [0x822FD230..0x822FD2F4)
	// 822FD230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD23C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FD248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FD24C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 822FD250: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD254: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FD258: 4BFC36E1  bl 0x822c0938
	ctx.lr = 0x822FD25C;
	sub_822C0938(ctx, base);
	// 822FD25C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FD260: 41820028  beq 0x822fd288
	if ctx.cr[0].eq {
	pc = 0x822FD288; continue 'dispatch;
	}
	// 822FD264: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FD268: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 822FD26C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 822FD270: 392BC760  addi r9, r11, -0x38a0
	ctx.r[9].s64 = ctx.r[11].s64 + -14496;
	// 822FD274: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 822FD278: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FD27C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 822FD280: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 822FD284: 48000008  b 0x822fd28c
	pc = 0x822FD28C; continue 'dispatch;
	// 822FD288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FD28C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FD290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD294: 409A0044  bne cr6, 0x822fd2d8
	if !ctx.cr[6].eq {
	pc = 0x822FD2D8; continue 'dispatch;
	}
	// 822FD298: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FD29C: 419A001C  beq cr6, 0x822fd2b8
	if ctx.cr[6].eq {
	pc = 0x822FD2B8; continue 'dispatch;
	}
	// 822FD2A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD2A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FD2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD2AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD2B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FD2B4: 4E800421  bctrl
	ctx.lr = 0x822FD2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FD2B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822FD2BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FD2C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD2C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 822FD2C8: 816B4E9C  lwz r11, 0x4e9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20124 as u32) ) } as u64;
	// 822FD2CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822FD2D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822FD2D4: 4BFC2D2D  bl 0x822c0000
	ctx.lr = 0x822FD2D8;
	sub_822C0000(ctx, base);
	// 822FD2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD2DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD2E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD2E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD2E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD2EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD2F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD2F8 size=460
    let mut pc: u32 = 0x822FD2F8;
    'dispatch: loop {
        match pc {
            0x822FD2F8 => {
    //   block [0x822FD2F8..0x822FD4C4)
	// 822FD2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD2FC: 48EAAE69  bl 0x831a8164
	ctx.lr = 0x822FD300;
	sub_831A8130(ctx, base);
	// 822FD300: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 822FD304: 48EAB775  bl 0x831a8a78
	ctx.lr = 0x822FD308;
	sub_831A8A40(ctx, base);
	// 822FD308: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD30C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FD310: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822FD314: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FD318: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FD31C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD320: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FD324: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 822FD328: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD32C: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 822FD330: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822FD334: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 822FD338: 48B7B221  bl 0x82e78558
	ctx.lr = 0x822FD33C;
	sub_82E78558(ctx, base);
	// 822FD33C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD340: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD344: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822FD348: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 822FD34C: 419A00CC  beq cr6, 0x822fd418
	if ctx.cr[6].eq {
	pc = 0x822FD418; continue 'dispatch;
	}
	// 822FD350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD354: 419A0050  beq cr6, 0x822fd3a4
	if ctx.cr[6].eq {
	pc = 0x822FD3A4; continue 'dispatch;
	}
	// 822FD358: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD35C: 4BFFC59D  bl 0x822f98f8
	ctx.lr = 0x822FD360;
	sub_822F98F8(ctx, base);
	// 822FD360: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD364: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 822FD368: 4BFFC439  bl 0x822f97a0
	ctx.lr = 0x822FD36C;
	sub_822F97A0(ctx, base);
	// 822FD36C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD370: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 822FD374: 4BFFC5FD  bl 0x822f9970
	ctx.lr = 0x822FD378;
	sub_822F9970(ctx, base);
	// 822FD378: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD37C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 822FD380: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 822FD384: 409A000C  bne cr6, 0x822fd390
	if !ctx.cr[6].eq {
	pc = 0x822FD390; continue 'dispatch;
	}
	// 822FD388: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD38C: 4BFFC275  bl 0x822f9600
	ctx.lr = 0x822FD390;
	sub_822F9600(ctx, base);
	// 822FD390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD398: 419A000C  beq cr6, 0x822fd3a4
	if ctx.cr[6].eq {
	pc = 0x822FD3A4; continue 'dispatch;
	}
	// 822FD39C: C03C0008  lfs f1, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FD3A0: 48000008  b 0x822fd3a8
	pc = 0x822FD3A8; continue 'dispatch;
	// 822FD3A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD3A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD3AC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD3B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822FD3B8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 822FD3BC: 419A0024  beq cr6, 0x822fd3e0
	if ctx.cr[6].eq {
	pc = 0x822FD3E0; continue 'dispatch;
	}
	// 822FD3C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822FD3C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FD3C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD3CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FD3D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FD3D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FD3D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD3DC: 4082FFE8  bne 0x822fd3c4
	if !ctx.cr[0].eq {
	pc = 0x822FD3C4; continue 'dispatch;
	}
	// 822FD3E0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 822FD3E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FD3E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822FD3EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FD3F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FD3F4: 48B612B5  bl 0x82e5e6a8
	ctx.lr = 0x822FD3F8;
	sub_82E5E6A8(ctx, base);
	// 822FD3F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FD3FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FD400: 419A0008  beq cr6, 0x822fd408
	if ctx.cr[6].eq {
	pc = 0x822FD408; continue 'dispatch;
	}
	// 822FD404: 4BFC348D  bl 0x822c0890
	ctx.lr = 0x822FD408;
	sub_822C0890(ctx, base);
	// 822FD408: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD40C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FD410: 419A0008  beq cr6, 0x822fd418
	if ctx.cr[6].eq {
	pc = 0x822FD418; continue 'dispatch;
	}
	// 822FD414: 4BFC347D  bl 0x822c0890
	ctx.lr = 0x822FD418;
	sub_822C0890(ctx, base);
	// 822FD418: 577D063F  clrlwi. r29, r27, 0x18
	ctx.r[29].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 822FD41C: 41820010  beq 0x822fd42c
	if ctx.cr[0].eq {
	pc = 0x822FD42C; continue 'dispatch;
	}
	// 822FD420: 897C0010  lbz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 822FD424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FD428: 4182007C  beq 0x822fd4a4
	if ctx.cr[0].eq {
	pc = 0x822FD4A4; continue 'dispatch;
	}
	// 822FD42C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD434: 419A0070  beq cr6, 0x822fd4a4
	if ctx.cr[6].eq {
	pc = 0x822FD4A4; continue 'dispatch;
	}
	// 822FD438: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD43C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 822FD440: 41980058  blt cr6, 0x822fd498
	if ctx.cr[6].lt {
	pc = 0x822FD498; continue 'dispatch;
	}
	// 822FD444: 419A004C  beq cr6, 0x822fd490
	if ctx.cr[6].eq {
	pc = 0x822FD490; continue 'dispatch;
	}
	// 822FD448: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 822FD44C: 41980034  blt cr6, 0x822fd480
	if ctx.cr[6].lt {
	pc = 0x822FD480; continue 'dispatch;
	}
	// 822FD450: 419A0014  beq cr6, 0x822fd464
	if ctx.cr[6].eq {
	pc = 0x822FD464; continue 'dispatch;
	}
	// 822FD454: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 822FD458: 4098004C  bge cr6, 0x822fd4a4
	if !ctx.cr[6].lt {
	pc = 0x822FD4A4; continue 'dispatch;
	}
	// 822FD45C: C03C000C  lfs f1, 0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FD460: 4800003C  b 0x822fd49c
	pc = 0x822FD49C; continue 'dispatch;
	// 822FD464: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD46C: 4BFFC505  bl 0x822f9970
	ctx.lr = 0x822FD470;
	sub_822F9970(ctx, base);
	// 822FD470: EC1EE824  fdivs f0, f30, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[29].f64) as f32) as f64;
	// 822FD474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD478: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 822FD47C: 4800000C  b 0x822fd488
	pc = 0x822FD488; continue 'dispatch;
	// 822FD480: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD484: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822FD488: 4BFFC391  bl 0x822f9818
	ctx.lr = 0x822FD48C;
	sub_822F9818(ctx, base);
	// 822FD48C: 48000018  b 0x822fd4a4
	pc = 0x822FD4A4; continue 'dispatch;
	// 822FD490: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 822FD494: 48000008  b 0x822fd49c
	pc = 0x822FD49C; continue 'dispatch;
	// 822FD498: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD49C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD4A0: 4BFFC229  bl 0x822f96c8
	ctx.lr = 0x822FD4A4;
	sub_822F96C8(ctx, base);
	// 822FD4A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822FD4A8: 419A000C  beq cr6, 0x822fd4b4
	if ctx.cr[6].eq {
	pc = 0x822FD4B4; continue 'dispatch;
	}
	// 822FD4AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD4B0: 4BFFCCD9  bl 0x822fa188
	ctx.lr = 0x822FD4B4;
	sub_822FA188(ctx, base);
	// 822FD4B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FD4B8: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 822FD4BC: 48EAB609  bl 0x831a8ac4
	ctx.lr = 0x822FD4C0;
	sub_831A8A8C(ctx, base);
	// 822FD4C0: 48EAACF4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD4C8 size=152
    let mut pc: u32 = 0x822FD4C8;
    'dispatch: loop {
        match pc {
            0x822FD4C8 => {
    //   block [0x822FD4C8..0x822FD560)
	// 822FD4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD4CC: 48EAAC9D  bl 0x831a8168
	ctx.lr = 0x822FD4D0;
	sub_831A8130(ctx, base);
	// 822FD4D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD4D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FD4D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FD4DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FD4E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FD4E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FD4E8: 48B5D039  bl 0x82e5a520
	ctx.lr = 0x822FD4EC;
	sub_82E5A520(ctx, base);
	// 822FD4EC: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FD4F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD4F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FD4F8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 822FD4FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822FD500: 419A0024  beq cr6, 0x822fd524
	if ctx.cr[6].eq {
	pc = 0x822FD524; continue 'dispatch;
	}
	// 822FD504: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FD508: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FD50C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD510: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FD514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FD518: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FD51C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD520: 4082FFE8  bne 0x822fd508
	if !ctx.cr[0].eq {
	pc = 0x822FD508; continue 'dispatch;
	}
	// 822FD524: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FD528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FD52C: 419A0008  beq cr6, 0x822fd534
	if ctx.cr[6].eq {
	pc = 0x822FD534; continue 'dispatch;
	}
	// 822FD530: 4BFC3361  bl 0x822c0890
	ctx.lr = 0x822FD534;
	sub_822C0890(ctx, base);
	// 822FD534: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 822FD538: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FD53C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FD540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD544: 4BFFFDB5  bl 0x822fd2f8
	ctx.lr = 0x822FD548;
	sub_822FD2F8(ctx, base);
	// 822FD548: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FD54C: 419A000C  beq cr6, 0x822fd558
	if ctx.cr[6].eq {
	pc = 0x822FD558; continue 'dispatch;
	}
	// 822FD550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD554: 4BFC333D  bl 0x822c0890
	ctx.lr = 0x822FD558;
	sub_822C0890(ctx, base);
	// 822FD558: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FD55C: 48EAAC5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD560 size=156
    let mut pc: u32 = 0x822FD560;
    'dispatch: loop {
        match pc {
            0x822FD560 => {
    //   block [0x822FD560..0x822FD5FC)
	// 822FD560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD574: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FD578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FD57C: 389E0060  addi r4, r30, 0x60
	ctx.r[4].s64 = ctx.r[30].s64 + 96;
	// 822FD580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD584: 484F9245  bl 0x827f67c8
	ctx.lr = 0x822FD588;
	sub_827F67C8(ctx, base);
	// 822FD588: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FD58C: 815E0064  lwz r10, 0x64(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FD590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 822FD594: 419A0040  beq cr6, 0x822fd5d4
	if ctx.cr[6].eq {
	pc = 0x822FD5D4; continue 'dispatch;
	}
	// 822FD598: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 822FD59C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FD5A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 822FD5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD5A8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FD5AC: 419A0034  beq cr6, 0x822fd5e0
	if ctx.cr[6].eq {
	pc = 0x822FD5E0; continue 'dispatch;
	}
	// 822FD5B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822FD5B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FD5B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD5BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FD5C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FD5C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FD5C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FD5CC: 4082FFE8  bne 0x822fd5b4
	if !ctx.cr[0].eq {
	pc = 0x822FD5B4; continue 'dispatch;
	}
	// 822FD5D0: 48000010  b 0x822fd5e0
	pc = 0x822FD5E0; continue 'dispatch;
	// 822FD5D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FD5D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FD5DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FD5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FD5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD5F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD600 size=108
    let mut pc: u32 = 0x822FD600;
    'dispatch: loop {
        match pc {
            0x822FD600 => {
    //   block [0x822FD600..0x822FD66C)
	// 822FD600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD604: 48EAAB69  bl 0x831a816c
	ctx.lr = 0x822FD608;
	sub_831A8130(ctx, base);
	// 822FD608: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD60C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD610: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD618: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822FD61C: 4BFFFF45  bl 0x822fd560
	ctx.lr = 0x822FD620;
	sub_822FD560(ctx, base);
	// 822FD620: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD624: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD62C: 419A000C  beq cr6, 0x822fd638
	if ctx.cr[6].eq {
	pc = 0x822FD638; continue 'dispatch;
	}
	// 822FD630: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD634: 4BFC325D  bl 0x822c0890
	ctx.lr = 0x822FD638;
	sub_822C0890(ctx, base);
	// 822FD638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FD63C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822FD640: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FD644: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FD648: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD64C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FD650: 4BFFB6A1  bl 0x822f8cf0
	ctx.lr = 0x822FD654;
	sub_822F8CF0(ctx, base);
	// 822FD654: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FD658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD65C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FD660: 4BFFEBC1  bl 0x822fc220
	ctx.lr = 0x822FD664;
	sub_822FC220(ctx, base);
	// 822FD664: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FD668: 48EAAB54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD670 size=116
    let mut pc: u32 = 0x822FD670;
    'dispatch: loop {
        match pc {
            0x822FD670 => {
    //   block [0x822FD670..0x822FD6E4)
	// 822FD670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD674: 48EAAAF9  bl 0x831a816c
	ctx.lr = 0x822FD678;
	sub_831A8130(ctx, base);
	// 822FD678: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FD67C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD684: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FD688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD68C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD690: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 822FD694: 4BFFFECD  bl 0x822fd560
	ctx.lr = 0x822FD698;
	sub_822FD560(ctx, base);
	// 822FD698: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD69C: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD6A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD6A4: 419A000C  beq cr6, 0x822fd6b0
	if ctx.cr[6].eq {
	pc = 0x822FD6B0; continue 'dispatch;
	}
	// 822FD6A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD6AC: 4BFC31E5  bl 0x822c0890
	ctx.lr = 0x822FD6B0;
	sub_822C0890(ctx, base);
	// 822FD6B0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822FD6B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD6B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FD6BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FD6C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD6C4: 4BFFB62D  bl 0x822f8cf0
	ctx.lr = 0x822FD6C8;
	sub_822F8CF0(ctx, base);
	// 822FD6C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FD6CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD6D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FD6D4: 4BFFEB4D  bl 0x822fc220
	ctx.lr = 0x822FD6D8;
	sub_822FC220(ctx, base);
	// 822FD6D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FD6DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FD6E0: 48EAAADC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD6E8 size=80
    let mut pc: u32 = 0x822FD6E8;
    'dispatch: loop {
        match pc {
            0x822FD6E8 => {
    //   block [0x822FD6E8..0x822FD738)
	// 822FD6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD6EC: 48EAAA81  bl 0x831a816c
	ctx.lr = 0x822FD6F0;
	sub_831A8130(ctx, base);
	// 822FD6F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD6F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD6F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD6FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD700: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 822FD704: 4BFFFE5D  bl 0x822fd560
	ctx.lr = 0x822FD708;
	sub_822FD560(ctx, base);
	// 822FD708: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD70C: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD714: 419A000C  beq cr6, 0x822fd720
	if ctx.cr[6].eq {
	pc = 0x822FD720; continue 'dispatch;
	}
	// 822FD718: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD71C: 4BFC3175  bl 0x822c0890
	ctx.lr = 0x822FD720;
	sub_822C0890(ctx, base);
	// 822FD720: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FD724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD728: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FD72C: 4BFFEAF5  bl 0x822fc220
	ctx.lr = 0x822FD730;
	sub_822FC220(ctx, base);
	// 822FD730: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FD734: 48EAAA88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD738 size=116
    let mut pc: u32 = 0x822FD738;
    'dispatch: loop {
        match pc {
            0x822FD738 => {
    //   block [0x822FD738..0x822FD7AC)
	// 822FD738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD73C: 48EAAA31  bl 0x831a816c
	ctx.lr = 0x822FD740;
	sub_831A8130(ctx, base);
	// 822FD740: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FD744: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD748: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FD74C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FD750: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD758: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 822FD75C: 4BFFFE05  bl 0x822fd560
	ctx.lr = 0x822FD760;
	sub_822FD560(ctx, base);
	// 822FD760: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD764: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD76C: 419A000C  beq cr6, 0x822fd778
	if ctx.cr[6].eq {
	pc = 0x822FD778; continue 'dispatch;
	}
	// 822FD770: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD774: 4BFC311D  bl 0x822c0890
	ctx.lr = 0x822FD778;
	sub_822C0890(ctx, base);
	// 822FD778: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 822FD77C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD780: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822FD784: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FD788: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD78C: 4BFFB565  bl 0x822f8cf0
	ctx.lr = 0x822FD790;
	sub_822F8CF0(ctx, base);
	// 822FD790: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FD794: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD798: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FD79C: 4BFFEA85  bl 0x822fc220
	ctx.lr = 0x822FD7A0;
	sub_822FC220(ctx, base);
	// 822FD7A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FD7A4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FD7A8: 48EAAA14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD7B0 size=128
    let mut pc: u32 = 0x822FD7B0;
    'dispatch: loop {
        match pc {
            0x822FD7B0 => {
    //   block [0x822FD7B0..0x822FD830)
	// 822FD7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD7C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD7C4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FD7C8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FD7CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD7D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD7D4: 4BFFFD8D  bl 0x822fd560
	ctx.lr = 0x822FD7D8;
	sub_822FD560(ctx, base);
	// 822FD7D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD7DC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD7E4: 419A000C  beq cr6, 0x822fd7f0
	if ctx.cr[6].eq {
	pc = 0x822FD7F0; continue 'dispatch;
	}
	// 822FD7E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD7EC: 4BFC30A5  bl 0x822c0890
	ctx.lr = 0x822FD7F0;
	sub_822C0890(ctx, base);
	// 822FD7F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FD7F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FD7F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FD7FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FD800: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD804: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FD808: 4BFFB4E9  bl 0x822f8cf0
	ctx.lr = 0x822FD80C;
	sub_822F8CF0(ctx, base);
	// 822FD80C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD814: 4BFFB57D  bl 0x822f8d90
	ctx.lr = 0x822FD818;
	sub_822F8D90(ctx, base);
	// 822FD818: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FD81C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD824: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD830 size=136
    let mut pc: u32 = 0x822FD830;
    'dispatch: loop {
        match pc {
            0x822FD830 => {
    //   block [0x822FD830..0x822FD8B8)
	// 822FD830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD83C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD840: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FD844: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD848: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FD84C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FD850: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD858: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FD85C: 4BFFFD05  bl 0x822fd560
	ctx.lr = 0x822FD860;
	sub_822FD560(ctx, base);
	// 822FD860: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD864: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD86C: 419A000C  beq cr6, 0x822fd878
	if ctx.cr[6].eq {
	pc = 0x822FD878; continue 'dispatch;
	}
	// 822FD870: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD874: 4BFC301D  bl 0x822c0890
	ctx.lr = 0x822FD878;
	sub_822C0890(ctx, base);
	// 822FD878: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FD87C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD880: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FD884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FD888: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD88C: 4BFFB465  bl 0x822f8cf0
	ctx.lr = 0x822FD890;
	sub_822F8CF0(ctx, base);
	// 822FD890: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD898: 4BFFB4F9  bl 0x822f8d90
	ctx.lr = 0x822FD89C;
	sub_822F8D90(ctx, base);
	// 822FD89C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FD8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD8A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FD8AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD8B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD8B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD8B8 size=136
    let mut pc: u32 = 0x822FD8B8;
    'dispatch: loop {
        match pc {
            0x822FD8B8 => {
    //   block [0x822FD8B8..0x822FD940)
	// 822FD8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD8C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD8C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD8C8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FD8CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD8D0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FD8D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FD8D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD8E0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FD8E4: 4BFFFC7D  bl 0x822fd560
	ctx.lr = 0x822FD8E8;
	sub_822FD560(ctx, base);
	// 822FD8E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD8EC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD8F4: 419A000C  beq cr6, 0x822fd900
	if ctx.cr[6].eq {
	pc = 0x822FD900; continue 'dispatch;
	}
	// 822FD8F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD8FC: 4BFC2F95  bl 0x822c0890
	ctx.lr = 0x822FD900;
	sub_822C0890(ctx, base);
	// 822FD900: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 822FD904: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FD908: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822FD90C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FD910: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FD914: 4BFFB3DD  bl 0x822f8cf0
	ctx.lr = 0x822FD918;
	sub_822F8CF0(ctx, base);
	// 822FD918: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD91C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD920: 4BFFB471  bl 0x822f8d90
	ctx.lr = 0x822FD924;
	sub_822F8D90(ctx, base);
	// 822FD924: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FD928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD92C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD930: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FD934: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD938: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FD940 size=108
    let mut pc: u32 = 0x822FD940;
    'dispatch: loop {
        match pc {
            0x822FD940 => {
    //   block [0x822FD940..0x822FD9AC)
	// 822FD940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD950: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD954: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FD958: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FD95C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD964: 4BFFFBFD  bl 0x822fd560
	ctx.lr = 0x822FD968;
	sub_822FD560(ctx, base);
	// 822FD968: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD96C: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD974: 419A000C  beq cr6, 0x822fd980
	if ctx.cr[6].eq {
	pc = 0x822FD980; continue 'dispatch;
	}
	// 822FD978: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD97C: 4BFC2F15  bl 0x822c0890
	ctx.lr = 0x822FD980;
	sub_822C0890(ctx, base);
	// 822FD980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FD984: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FD98C: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FD990: 4BFFB429  bl 0x822f8db8
	ctx.lr = 0x822FD994;
	sub_822F8DB8(ctx, base);
	// 822FD994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FD998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FD99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FD9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FD9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FD9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FD9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FD9B0 size=116
    let mut pc: u32 = 0x822FD9B0;
    'dispatch: loop {
        match pc {
            0x822FD9B0 => {
    //   block [0x822FD9B0..0x822FDA24)
	// 822FD9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FD9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FD9B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FD9BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FD9C0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FD9C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FD9C8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FD9CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FD9D0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FD9D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FD9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FD9DC: 4BFFFB85  bl 0x822fd560
	ctx.lr = 0x822FD9E0;
	sub_822FD560(ctx, base);
	// 822FD9E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FD9E4: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FD9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FD9EC: 419A000C  beq cr6, 0x822fd9f8
	if ctx.cr[6].eq {
	pc = 0x822FD9F8; continue 'dispatch;
	}
	// 822FD9F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FD9F4: 4BFC2E9D  bl 0x822c0890
	ctx.lr = 0x822FD9F8;
	sub_822C0890(ctx, base);
	// 822FD9F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FD9FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FDA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDA04: 4BFFB3B5  bl 0x822f8db8
	ctx.lr = 0x822FDA08;
	sub_822F8DB8(ctx, base);
	// 822FDA08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FDA0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FDA10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FDA14: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FDA18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FDA1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FDA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDA28 size=112
    let mut pc: u32 = 0x822FDA28;
    'dispatch: loop {
        match pc {
            0x822FDA28 => {
    //   block [0x822FDA28..0x822FDA98)
	// 822FDA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDA2C: 48EAA741  bl 0x831a816c
	ctx.lr = 0x822FDA30;
	sub_831A8130(ctx, base);
	// 822FDA30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDA34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDA38: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822FDA3C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FDA40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDA48: 4BFFFB19  bl 0x822fd560
	ctx.lr = 0x822FDA4C;
	sub_822FD560(ctx, base);
	// 822FDA4C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDA50: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDA54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FDA58: 419A000C  beq cr6, 0x822fda64
	if ctx.cr[6].eq {
	pc = 0x822FDA64; continue 'dispatch;
	}
	// 822FDA5C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FDA60: 4BFC2E31  bl 0x822c0890
	ctx.lr = 0x822FDA64;
	sub_822C0890(ctx, base);
	// 822FDA64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FDA68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDA6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FDA70: 4BFFFAF1  bl 0x822fd560
	ctx.lr = 0x822FDA74;
	sub_822FD560(ctx, base);
	// 822FDA74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FDA78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FDA7C: 4BFFB425  bl 0x822f8ea0
	ctx.lr = 0x822FDA80;
	sub_822F8EA0(ctx, base);
	// 822FDA80: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FDA84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDA88: 419A0008  beq cr6, 0x822fda90
	if ctx.cr[6].eq {
	pc = 0x822FDA90; continue 'dispatch;
	}
	// 822FDA8C: 4BFC2E05  bl 0x822c0890
	ctx.lr = 0x822FDA90;
	sub_822C0890(ctx, base);
	// 822FDA90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FDA94: 48EAA728  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDA98 size=120
    let mut pc: u32 = 0x822FDA98;
    'dispatch: loop {
        match pc {
            0x822FDA98 => {
    //   block [0x822FDA98..0x822FDB10)
	// 822FDA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDA9C: 48EAA6CD  bl 0x831a8168
	ctx.lr = 0x822FDAA0;
	sub_831A8130(ctx, base);
	// 822FDAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDAA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDAA8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822FDAAC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FDAB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDAB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDAB8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822FDABC: 4BFFFAA5  bl 0x822fd560
	ctx.lr = 0x822FDAC0;
	sub_822FD560(ctx, base);
	// 822FDAC0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDAC4: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDAC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FDACC: 419A000C  beq cr6, 0x822fdad8
	if ctx.cr[6].eq {
	pc = 0x822FDAD8; continue 'dispatch;
	}
	// 822FDAD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FDAD4: 4BFC2DBD  bl 0x822c0890
	ctx.lr = 0x822FDAD8;
	sub_822C0890(ctx, base);
	// 822FDAD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FDADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDAE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FDAE4: 4BFFFA7D  bl 0x822fd560
	ctx.lr = 0x822FDAE8;
	sub_822FD560(ctx, base);
	// 822FDAE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FDAEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FDAF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FDAF4: 4BFFE785  bl 0x822fc278
	ctx.lr = 0x822FDAF8;
	sub_822FC278(ctx, base);
	// 822FDAF8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FDAFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDB00: 419A0008  beq cr6, 0x822fdb08
	if ctx.cr[6].eq {
	pc = 0x822FDB08; continue 'dispatch;
	}
	// 822FDB04: 4BFC2D8D  bl 0x822c0890
	ctx.lr = 0x822FDB08;
	sub_822C0890(ctx, base);
	// 822FDB08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FDB0C: 48EAA6AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDB10 size=136
    let mut pc: u32 = 0x822FDB10;
    'dispatch: loop {
        match pc {
            0x822FDB10 => {
    //   block [0x822FDB10..0x822FDB98)
	// 822FDB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FDB18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FDB1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FDB20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FDB24: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDB28: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 822FDB2C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FDB30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FDB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDB38: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FDB3C: 4BFFFA25  bl 0x822fd560
	ctx.lr = 0x822FDB40;
	sub_822FD560(ctx, base);
	// 822FDB40: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDB44: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FDB4C: 419A000C  beq cr6, 0x822fdb58
	if ctx.cr[6].eq {
	pc = 0x822FDB58; continue 'dispatch;
	}
	// 822FDB50: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FDB54: 4BFC2D3D  bl 0x822c0890
	ctx.lr = 0x822FDB58;
	sub_822C0890(ctx, base);
	// 822FDB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDB5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FDB60: 4828E3B1  bl 0x8258bf10
	ctx.lr = 0x822FDB64;
	sub_8258BF10(ctx, base);
	// 822FDB64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FDB68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDB6C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FDB70: 4BFFF4C9  bl 0x822fd038
	ctx.lr = 0x822FDB74;
	sub_822FD038(ctx, base);
	// 822FDB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDB78: 4BFCB141  bl 0x822c8cb8
	ctx.lr = 0x822FDB7C;
	sub_822C8CB8(ctx, base);
	// 822FDB7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FDB80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FDB84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FDB88: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FDB8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FDB90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FDB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDB98 size=124
    let mut pc: u32 = 0x822FDB98;
    'dispatch: loop {
        match pc {
            0x822FDB98 => {
    //   block [0x822FDB98..0x822FDC14)
	// 822FDB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDB9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FDBA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FDBA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDBAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDBB0: 48B5C971  bl 0x82e5a520
	ctx.lr = 0x822FDBB4;
	sub_82E5A520(ctx, base);
	// 822FDBB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDBB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FDBBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FDBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FDBC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FDBC8: 419A0024  beq cr6, 0x822fdbec
	if ctx.cr[6].eq {
	pc = 0x822FDBEC; continue 'dispatch;
	}
	// 822FDBCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 822FDBD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FDBD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FDBD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FDBDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FDBE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FDBE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FDBE8: 4082FFE8  bne 0x822fdbd0
	if !ctx.cr[0].eq {
	pc = 0x822FDBD0; continue 'dispatch;
	}
	// 822FDBEC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDBF4: 419A0008  beq cr6, 0x822fdbfc
	if ctx.cr[6].eq {
	pc = 0x822FDBFC; continue 'dispatch;
	}
	// 822FDBF8: 4BFC2C99  bl 0x822c0890
	ctx.lr = 0x822FDBFC;
	sub_822C0890(ctx, base);
	// 822FDBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDC00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FDC04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FDC08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FDC0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FDC10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDC18 size=104
    let mut pc: u32 = 0x822FDC18;
    'dispatch: loop {
        match pc {
            0x822FDC18 => {
    //   block [0x822FDC18..0x822FDC80)
	// 822FDC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FDC20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FDC24: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FDC28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDC2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDC30: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FDC34: 48B5BAED  bl 0x82e59720
	ctx.lr = 0x822FDC38;
	sub_82E59720(ctx, base);
	// 822FDC38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FDC3C: 4082002C  bne 0x822fdc68
	if !ctx.cr[0].eq {
	pc = 0x822FDC68; continue 'dispatch;
	}
	// 822FDC40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDC48: 4BFFFF51  bl 0x822fdb98
	ctx.lr = 0x822FDC4C;
	sub_822FDB98(ctx, base);
	// 822FDC4C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDC50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FDC54: 4BFFBA75  bl 0x822f96c8
	ctx.lr = 0x822FDC58;
	sub_822F96C8(ctx, base);
	// 822FDC58: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDC5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDC60: 419A0008  beq cr6, 0x822fdc68
	if ctx.cr[6].eq {
	pc = 0x822FDC68; continue 'dispatch;
	}
	// 822FDC64: 4BFC2C2D  bl 0x822c0890
	ctx.lr = 0x822FDC68;
	sub_822C0890(ctx, base);
	// 822FDC68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FDC6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FDC70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FDC74: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FDC78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FDC7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDC80 size=104
    let mut pc: u32 = 0x822FDC80;
    'dispatch: loop {
        match pc {
            0x822FDC80 => {
    //   block [0x822FDC80..0x822FDCE8)
	// 822FDC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDC84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FDC88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FDC8C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FDC90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDC94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDC98: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FDC9C: 48B5BA85  bl 0x82e59720
	ctx.lr = 0x822FDCA0;
	sub_82E59720(ctx, base);
	// 822FDCA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FDCA4: 4082002C  bne 0x822fdcd0
	if !ctx.cr[0].eq {
	pc = 0x822FDCD0; continue 'dispatch;
	}
	// 822FDCA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDCAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDCB0: 4BFFFEE9  bl 0x822fdb98
	ctx.lr = 0x822FDCB4;
	sub_822FDB98(ctx, base);
	// 822FDCB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDCB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FDCBC: 4BFFBB5D  bl 0x822f9818
	ctx.lr = 0x822FDCC0;
	sub_822F9818(ctx, base);
	// 822FDCC0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDCC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDCC8: 419A0008  beq cr6, 0x822fdcd0
	if ctx.cr[6].eq {
	pc = 0x822FDCD0; continue 'dispatch;
	}
	// 822FDCCC: 4BFC2BC5  bl 0x822c0890
	ctx.lr = 0x822FDCD0;
	sub_822C0890(ctx, base);
	// 822FDCD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FDCD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FDCD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FDCDC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FDCE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FDCE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDCE8 size=420
    let mut pc: u32 = 0x822FDCE8;
    'dispatch: loop {
        match pc {
            0x822FDCE8 => {
    //   block [0x822FDCE8..0x822FDE8C)
	// 822FDCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDCEC: 48EAA481  bl 0x831a816c
	ctx.lr = 0x822FDCF0;
	sub_831A8130(ctx, base);
	// 822FDCF0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDCF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDCF8: 48B5F181  bl 0x82e5ce78
	ctx.lr = 0x822FDCFC;
	sub_82E5CE78(ctx, base);
	// 822FDCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDD00: 48B5BA21  bl 0x82e59720
	ctx.lr = 0x822FDD04;
	sub_82E59720(ctx, base);
	// 822FDD04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FDD08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDD0C: 41820038  beq 0x822fdd44
	if ctx.cr[0].eq {
	pc = 0x822FDD44; continue 'dispatch;
	}
	// 822FDD10: 48B7A839  bl 0x82e78548
	ctx.lr = 0x822FDD14;
	sub_82E78548(ctx, base);
	// 822FDD14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FDD18: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 822FDD1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 822FDD20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 822FDD24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDD28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDD2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDD30: 4E800421  bctrl
	ctx.lr = 0x822FDD34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDD34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FDD38: 488B14C1  bl 0x82baf1f8
	ctx.lr = 0x822FDD3C;
	sub_82BAF1F8(ctx, base);
	// 822FDD3C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FDD40: 480000E8  b 0x822fde28
	pc = 0x822FDE28; continue 'dispatch;
	// 822FDD44: 48B7A805  bl 0x82e78548
	ctx.lr = 0x822FDD48;
	sub_82E78548(ctx, base);
	// 822FDD48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FDD4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDD50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FDD54: 4BFFFE45  bl 0x822fdb98
	ctx.lr = 0x822FDD58;
	sub_822FDB98(ctx, base);
	// 822FDD58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FDD5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FDD60: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDD64: 4BFFB6C5  bl 0x822f9428
	ctx.lr = 0x822FDD68;
	sub_822F9428(ctx, base);
	// 822FDD68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDD6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FDD70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDD74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDD78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDD7C: 4E800421  bctrl
	ctx.lr = 0x822FDD80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDD80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FDD84: 488B1475  bl 0x82baf1f8
	ctx.lr = 0x822FDD88;
	sub_82BAF1F8(ctx, base);
	// 822FDD88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FDD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDD90: 419A0008  beq cr6, 0x822fdd98
	if ctx.cr[6].eq {
	pc = 0x822FDD98; continue 'dispatch;
	}
	// 822FDD94: 4BFC2AFD  bl 0x822c0890
	ctx.lr = 0x822FDD98;
	sub_822C0890(ctx, base);
	// 822FDD98: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FDD9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDDA0: 419A0008  beq cr6, 0x822fdda8
	if ctx.cr[6].eq {
	pc = 0x822FDDA8; continue 'dispatch;
	}
	// 822FDDA4: 4BFC2AED  bl 0x822c0890
	ctx.lr = 0x822FDDA8;
	sub_822C0890(ctx, base);
	// 822FDDA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDDAC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822FDDB0: 4BFFFDE9  bl 0x822fdb98
	ctx.lr = 0x822FDDB4;
	sub_822FDB98(ctx, base);
	// 822FDDB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDDB8: 4BFFC291  bl 0x822fa048
	ctx.lr = 0x822FDDBC;
	sub_822FA048(ctx, base);
	// 822FDDBC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822FDDC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDDC4: 419A0008  beq cr6, 0x822fddcc
	if ctx.cr[6].eq {
	pc = 0x822FDDCC; continue 'dispatch;
	}
	// 822FDDC8: 4BFC2AC9  bl 0x822c0890
	ctx.lr = 0x822FDDCC;
	sub_822C0890(ctx, base);
	// 822FDDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDDD0: 48B7A779  bl 0x82e78548
	ctx.lr = 0x822FDDD4;
	sub_82E78548(ctx, base);
	// 822FDDD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FDDD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDDDC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822FDDE0: 4BFFFDB9  bl 0x822fdb98
	ctx.lr = 0x822FDDE4;
	sub_822FDB98(ctx, base);
	// 822FDDE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FDDE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FDDEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDDF0: 4BFFB639  bl 0x822f9428
	ctx.lr = 0x822FDDF4;
	sub_822F9428(ctx, base);
	// 822FDDF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDDF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FDDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDE00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDE04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDE08: 4E800421  bctrl
	ctx.lr = 0x822FDE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDE0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FDE10: 488B13E9  bl 0x82baf1f8
	ctx.lr = 0x822FDE14;
	sub_82BAF1F8(ctx, base);
	// 822FDE14: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822FDE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDE1C: 419A0008  beq cr6, 0x822fde24
	if ctx.cr[6].eq {
	pc = 0x822FDE24; continue 'dispatch;
	}
	// 822FDE20: 4BFC2A71  bl 0x822c0890
	ctx.lr = 0x822FDE24;
	sub_822C0890(ctx, base);
	// 822FDE24: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822FDE28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDE2C: 419A0008  beq cr6, 0x822fde34
	if ctx.cr[6].eq {
	pc = 0x822FDE34; continue 'dispatch;
	}
	// 822FDE30: 4BFC2A61  bl 0x822c0890
	ctx.lr = 0x822FDE34;
	sub_822C0890(ctx, base);
	// 822FDE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDE38: 48B7A711  bl 0x82e78548
	ctx.lr = 0x822FDE3C;
	sub_82E78548(ctx, base);
	// 822FDE3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FDE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDE44: 48B7A705  bl 0x82e78548
	ctx.lr = 0x822FDE48;
	sub_82E78548(ctx, base);
	// 822FDE48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDE4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDE50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FDE54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822FDE58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FDE5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDE60: 4E800421  bctrl
	ctx.lr = 0x822FDE64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDE64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDE68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FDE6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDE70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDE74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDE78: 4E800421  bctrl
	ctx.lr = 0x822FDE7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDE7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FDE80: 4849A819  bl 0x82798698
	ctx.lr = 0x822FDE84;
	sub_82798698(ctx, base);
	// 822FDE84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FDE88: 48EAA334  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDE90 size=260
    let mut pc: u32 = 0x822FDE90;
    'dispatch: loop {
        match pc {
            0x822FDE90 => {
    //   block [0x822FDE90..0x822FDF94)
	// 822FDE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDE94: 48EAA2D1  bl 0x831a8164
	ctx.lr = 0x822FDE98;
	sub_831A8130(ctx, base);
	// 822FDE98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDE9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FDEA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FDEA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FDEA8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FDEAC: 48B5C675  bl 0x82e5a520
	ctx.lr = 0x822FDEB0;
	sub_82E5A520(ctx, base);
	// 822FDEB0: 83630004  lwz r27, 4(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FDEB4: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDEB8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822FDEBC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 822FDEC0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 822FDEC4: 419A0024  beq cr6, 0x822fdee8
	if ctx.cr[6].eq {
	pc = 0x822FDEE8; continue 'dispatch;
	}
	// 822FDEC8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 822FDECC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FDED0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FDED4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FDED8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FDEDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FDEE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FDEE4: 4082FFE8  bne 0x822fdecc
	if !ctx.cr[0].eq {
	pc = 0x822FDECC; continue 'dispatch;
	}
	// 822FDEE8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FDEEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FDEF0: 419A0008  beq cr6, 0x822fdef8
	if ctx.cr[6].eq {
	pc = 0x822FDEF8; continue 'dispatch;
	}
	// 822FDEF4: 4BFC299D  bl 0x822c0890
	ctx.lr = 0x822FDEF8;
	sub_822C0890(ctx, base);
	// 822FDEF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FDEFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDF00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDF04: 4BFFF65D  bl 0x822fd560
	ctx.lr = 0x822FDF08;
	sub_822FD560(ctx, base);
	// 822FDF08: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 822FDF0C: 419A0030  beq cr6, 0x822fdf3c
	if ctx.cr[6].eq {
	pc = 0x822FDF3C; continue 'dispatch;
	}
	// 822FDF10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDF14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FDF18: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDF1C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FDF20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDF24: 4E800421  bctrl
	ctx.lr = 0x822FDF28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDF28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FDF2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FDF30: 4BFFB681  bl 0x822f95b0
	ctx.lr = 0x822FDF34;
	sub_822F95B0(ctx, base);
	// 822FDF34: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822FDF38: 48000030  b 0x822fdf68
	pc = 0x822FDF68; continue 'dispatch;
	// 822FDF3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FDF40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDF44: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 822FDF48: 48AF5AC1  bl 0x82df3a08
	ctx.lr = 0x822FDF4C;
	sub_82DF3A08(ctx, base);
	// 822FDF4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FDF50: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDF54: 4BFFB65D  bl 0x822f95b0
	ctx.lr = 0x822FDF58;
	sub_822F95B0(ctx, base);
	// 822FDF58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FDF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FDF60: 48AF54C9  bl 0x82df3428
	ctx.lr = 0x822FDF64;
	sub_82DF3428(ctx, base);
	// 822FDF64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 822FDF68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FDF6C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822FDF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDF74: 4BFFF385  bl 0x822fd2f8
	ctx.lr = 0x822FDF78;
	sub_822FD2F8(ctx, base);
	// 822FDF78: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 822FDF7C: 419A000C  beq cr6, 0x822fdf88
	if ctx.cr[6].eq {
	pc = 0x822FDF88; continue 'dispatch;
	}
	// 822FDF80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822FDF84: 4BFC290D  bl 0x822c0890
	ctx.lr = 0x822FDF88;
	sub_822C0890(ctx, base);
	// 822FDF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDF8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FDF90: 48EAA224  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDF98 size=56
    let mut pc: u32 = 0x822FDF98;
    'dispatch: loop {
        match pc {
            0x822FDF98 => {
    //   block [0x822FDF98..0x822FDFD0)
	// 822FDF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDF9C: 48EAA1D1  bl 0x831a816c
	ctx.lr = 0x822FDFA0;
	sub_831A8130(ctx, base);
	// 822FDFA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDFA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDFA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FDFAC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 822FDFB0: 4BFFF5B1  bl 0x822fd560
	ctx.lr = 0x822FDFB4;
	sub_822FD560(ctx, base);
	// 822FDFB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FDFB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FDFBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FDFC0: 4BFFF509  bl 0x822fd4c8
	ctx.lr = 0x822FDFC4;
	sub_822FD4C8(ctx, base);
	// 822FDFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FDFC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FDFCC: 48EAA1F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FDFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FDFD0 size=144
    let mut pc: u32 = 0x822FDFD0;
    'dispatch: loop {
        match pc {
            0x822FDFD0 => {
    //   block [0x822FDFD0..0x822FE060)
	// 822FDFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FDFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FDFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FDFDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FDFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FDFE4: 48B7A565  bl 0x82e78548
	ctx.lr = 0x822FDFE8;
	sub_82E78548(ctx, base);
	// 822FDFE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDFEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FDFF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FDFF4: 4E800421  bctrl
	ctx.lr = 0x822FDFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FDFF8: 488B6821  bl 0x82bb4818
	ctx.lr = 0x822FDFFC;
	sub_82BB4818(ctx, base);
	// 822FDFFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE000: 4082000C  bne 0x822fe00c
	if !ctx.cr[0].eq {
	pc = 0x822FE00C; continue 'dispatch;
	}
	// 822FE004: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822FE008: 48000044  b 0x822fe04c
	pc = 0x822FE04C; continue 'dispatch;
	// 822FE00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE010: 48B5B711  bl 0x82e59720
	ctx.lr = 0x822FE014;
	sub_82E59720(ctx, base);
	// 822FE014: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE018: 4082FFEC  bne 0x822fe004
	if !ctx.cr[0].eq {
	pc = 0x822FE004; continue 'dispatch;
	}
	// 822FE01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE024: 4BFFFB75  bl 0x822fdb98
	ctx.lr = 0x822FE028;
	sub_822FDB98(ctx, base);
	// 822FE028: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE02C: 4BFFBA6D  bl 0x822f9a98
	ctx.lr = 0x822FE030;
	sub_822F9A98(ctx, base);
	// 822FE030: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE03C: 419A000C  beq cr6, 0x822fe048
	if ctx.cr[6].eq {
	pc = 0x822FE048; continue 'dispatch;
	}
	// 822FE040: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE044: 4BFC284D  bl 0x822c0890
	ctx.lr = 0x822FE048;
	sub_822C0890(ctx, base);
	// 822FE048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE04C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE060 size=108
    let mut pc: u32 = 0x822FE060;
    'dispatch: loop {
        match pc {
            0x822FE060 => {
    //   block [0x822FE060..0x822FE0CC)
	// 822FE060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE06C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE074: 48B5B6AD  bl 0x82e59720
	ctx.lr = 0x822FE078;
	sub_82E59720(ctx, base);
	// 822FE078: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE07C: 4182000C  beq 0x822fe088
	if ctx.cr[0].eq {
	pc = 0x822FE088; continue 'dispatch;
	}
	// 822FE080: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822FE084: 48000034  b 0x822fe0b8
	pc = 0x822FE0B8; continue 'dispatch;
	// 822FE088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE08C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE090: 4BFFFB09  bl 0x822fdb98
	ctx.lr = 0x822FE094;
	sub_822FDB98(ctx, base);
	// 822FE094: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE098: 4BFFBAC1  bl 0x822f9b58
	ctx.lr = 0x822FE09C;
	sub_822F9B58(ctx, base);
	// 822FE09C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE0A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE0A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE0A8: 419A000C  beq cr6, 0x822fe0b4
	if ctx.cr[6].eq {
	pc = 0x822FE0B4; continue 'dispatch;
	}
	// 822FE0AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE0B0: 4BFC27E1  bl 0x822c0890
	ctx.lr = 0x822FE0B4;
	sub_822C0890(ctx, base);
	// 822FE0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE0B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE0C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE0C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE0D0 size=188
    let mut pc: u32 = 0x822FE0D0;
    'dispatch: loop {
        match pc {
            0x822FE0D0 => {
    //   block [0x822FE0D0..0x822FE18C)
	// 822FE0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE0D4: 48EAA095  bl 0x831a8168
	ctx.lr = 0x822FE0D8;
	sub_831A8130(ctx, base);
	// 822FE0D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE0DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FE0E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE0E8: 48B5B639  bl 0x82e59720
	ctx.lr = 0x822FE0EC;
	sub_82E59720(ctx, base);
	// 822FE0EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE0F0: 40820084  bne 0x822fe174
	if !ctx.cr[0].eq {
	pc = 0x822FE174; continue 'dispatch;
	}
	// 822FE0F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE0F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FE0FC: 4BFFFA9D  bl 0x822fdb98
	ctx.lr = 0x822FE100;
	sub_822FDB98(ctx, base);
	// 822FE100: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE104: 4BFFACCD  bl 0x822f8dd0
	ctx.lr = 0x822FE108;
	sub_822F8DD0(ctx, base);
	// 822FE108: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FE10C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FE110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE114: 419A000C  beq cr6, 0x822fe120
	if ctx.cr[6].eq {
	pc = 0x822FE120; continue 'dispatch;
	}
	// 822FE118: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE11C: 4BFC2775  bl 0x822c0890
	ctx.lr = 0x822FE120;
	sub_822C0890(ctx, base);
	// 822FE120: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE128: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 822FE12C: 48AF58DD  bl 0x82df3a08
	ctx.lr = 0x822FE130;
	sub_82DF3A08(ctx, base);
	// 822FE130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FE134: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FE138: 48AF5169  bl 0x82df32a0
	ctx.lr = 0x822FE13C;
	sub_82DF32A0(ctx, base);
	// 822FE13C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FE140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE144: 48AF52E5  bl 0x82df3428
	ctx.lr = 0x822FE148;
	sub_82DF3428(ctx, base);
	// 822FE148: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE14C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE150: 41820014  beq 0x822fe164
	if ctx.cr[0].eq {
	pc = 0x822FE164; continue 'dispatch;
	}
	// 822FE154: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE15C: 4BFFFD35  bl 0x822fde90
	ctx.lr = 0x822FE160;
	sub_822FDE90(ctx, base);
	// 822FE160: 48000020  b 0x822fe180
	pc = 0x822FE180; continue 'dispatch;
	// 822FE164: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE168: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE16C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE170: 48000014  b 0x822fe184
	pc = 0x822FE184; continue 'dispatch;
	// 822FE174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE178: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE17C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE184: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FE188: 48EAA030  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE190 size=196
    let mut pc: u32 = 0x822FE190;
    'dispatch: loop {
        match pc {
            0x822FE190 => {
    //   block [0x822FE190..0x822FE254)
	// 822FE190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE194: 48EA9FD5  bl 0x831a8168
	ctx.lr = 0x822FE198;
	sub_831A8130(ctx, base);
	// 822FE198: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE19C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FE1A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE1A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE1A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822FE1AC: 48B5B575  bl 0x82e59720
	ctx.lr = 0x822FE1B0;
	sub_82E59720(ctx, base);
	// 822FE1B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE1B4: 40820088  bne 0x822fe23c
	if !ctx.cr[0].eq {
	pc = 0x822FE23C; continue 'dispatch;
	}
	// 822FE1B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE1BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FE1C0: 4BFFF9D9  bl 0x822fdb98
	ctx.lr = 0x822FE1C4;
	sub_822FDB98(ctx, base);
	// 822FE1C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FE1C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE1CC: 4BFFC115  bl 0x822fa2e0
	ctx.lr = 0x822FE1D0;
	sub_822FA2E0(ctx, base);
	// 822FE1D0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FE1D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FE1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE1DC: 419A000C  beq cr6, 0x822fe1e8
	if ctx.cr[6].eq {
	pc = 0x822FE1E8; continue 'dispatch;
	}
	// 822FE1E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE1E4: 4BFC26AD  bl 0x822c0890
	ctx.lr = 0x822FE1E8;
	sub_822C0890(ctx, base);
	// 822FE1E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE1EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE1F0: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 822FE1F4: 48AF5815  bl 0x82df3a08
	ctx.lr = 0x822FE1F8;
	sub_82DF3A08(ctx, base);
	// 822FE1F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FE1FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FE200: 48AF50A1  bl 0x82df32a0
	ctx.lr = 0x822FE204;
	sub_82DF32A0(ctx, base);
	// 822FE204: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FE208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE20C: 48AF521D  bl 0x82df3428
	ctx.lr = 0x822FE210;
	sub_82DF3428(ctx, base);
	// 822FE210: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE218: 41820014  beq 0x822fe22c
	if ctx.cr[0].eq {
	pc = 0x822FE22C; continue 'dispatch;
	}
	// 822FE21C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE224: 4BFFFC6D  bl 0x822fde90
	ctx.lr = 0x822FE228;
	sub_822FDE90(ctx, base);
	// 822FE228: 48000020  b 0x822fe248
	pc = 0x822FE248; continue 'dispatch;
	// 822FE22C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE230: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE234: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE238: 48000014  b 0x822fe24c
	pc = 0x822FE24C; continue 'dispatch;
	// 822FE23C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE240: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE244: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE24C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FE250: 48EA9F68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE258 size=176
    let mut pc: u32 = 0x822FE258;
    'dispatch: loop {
        match pc {
            0x822FE258 => {
    //   block [0x822FE258..0x822FE308)
	// 822FE258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE264: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE26C: 48B5B4B5  bl 0x82e59720
	ctx.lr = 0x822FE270;
	sub_82E59720(ctx, base);
	// 822FE270: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE274: 40820040  bne 0x822fe2b4
	if !ctx.cr[0].eq {
	pc = 0x822FE2B4; continue 'dispatch;
	}
	// 822FE278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE27C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE280: 4BFFF919  bl 0x822fdb98
	ctx.lr = 0x822FE284;
	sub_822FDB98(ctx, base);
	// 822FE284: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE288: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE28C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 822FE290: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FE294: 4E800421  bctrl
	ctx.lr = 0x822FE298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FE298: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE2A4: 419A004C  beq cr6, 0x822fe2f0
	if ctx.cr[6].eq {
	pc = 0x822FE2F0; continue 'dispatch;
	}
	// 822FE2A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE2AC: 4BFC25E5  bl 0x822c0890
	ctx.lr = 0x822FE2B0;
	sub_822C0890(ctx, base);
	// 822FE2B0: 48000040  b 0x822fe2f0
	pc = 0x822FE2F0; continue 'dispatch;
	// 822FE2B4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822FE2B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FE2BC: 3BEB2618  addi r31, r11, 0x2618
	ctx.r[31].s64 = ctx.r[11].s64 + 9752;
	// 822FE2C0: 816A261C  lwz r11, 0x261c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9756 as u32) ) } as u64;
	// 822FE2C4: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822FE2C8: 40820028  bne 0x822fe2f0
	if !ctx.cr[0].eq {
	pc = 0x822FE2F0; continue 'dispatch;
	}
	// 822FE2CC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822FE2D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 822FE2D4: 916A261C  stw r11, 0x261c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9756 as u32), ctx.r[11].u32 ) };
	// 822FE2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE2DC: 38899BC9  addi r4, r9, -0x6437
	ctx.r[4].s64 = ctx.r[9].s64 + -25655;
	// 822FE2E0: 48AF5729  bl 0x82df3a08
	ctx.lr = 0x822FE2E4;
	sub_82DF3A08(ctx, base);
	// 822FE2E4: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 822FE2E8: 386BEBE0  addi r3, r11, -0x1420
	ctx.r[3].s64 = ctx.r[11].s64 + -5152;
	// 822FE2EC: 48EAA1ED  bl 0x831a84d8
	ctx.lr = 0x822FE2F0;
	sub_831A84D8(ctx, base);
	// 822FE2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE2F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE2F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE2FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE300: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE308 size=104
    let mut pc: u32 = 0x822FE308;
    'dispatch: loop {
        match pc {
            0x822FE308 => {
    //   block [0x822FE308..0x822FE370)
	// 822FE308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE310: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE314: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FE318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE320: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE324: 48B5B3FD  bl 0x82e59720
	ctx.lr = 0x822FE328;
	sub_82E59720(ctx, base);
	// 822FE328: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE32C: 4082002C  bne 0x822fe358
	if !ctx.cr[0].eq {
	pc = 0x822FE358; continue 'dispatch;
	}
	// 822FE330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE338: 4BFFF861  bl 0x822fdb98
	ctx.lr = 0x822FE33C;
	sub_822FDB98(ctx, base);
	// 822FE33C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE340: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE344: 4BFFB88D  bl 0x822f9bd0
	ctx.lr = 0x822FE348;
	sub_822F9BD0(ctx, base);
	// 822FE348: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE34C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE350: 419A0008  beq cr6, 0x822fe358
	if ctx.cr[6].eq {
	pc = 0x822FE358; continue 'dispatch;
	}
	// 822FE354: 4BFC253D  bl 0x822c0890
	ctx.lr = 0x822FE358;
	sub_822C0890(ctx, base);
	// 822FE358: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE35C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE364: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FE368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE36C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FE370 size=116
    let mut pc: u32 = 0x822FE370;
    'dispatch: loop {
        match pc {
            0x822FE370 => {
    //   block [0x822FE370..0x822FE3E4)
	// 822FE370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE378: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE37C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FE380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE388: 48B5B399  bl 0x82e59720
	ctx.lr = 0x822FE38C;
	sub_82E59720(ctx, base);
	// 822FE38C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE390: 40820034  bne 0x822fe3c4
	if !ctx.cr[0].eq {
	pc = 0x822FE3C4; continue 'dispatch;
	}
	// 822FE394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE39C: 4BFFF7FD  bl 0x822fdb98
	ctx.lr = 0x822FE3A0;
	sub_822FDB98(ctx, base);
	// 822FE3A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE3A4: 4BFFB3FD  bl 0x822f97a0
	ctx.lr = 0x822FE3A8;
	sub_822F97A0(ctx, base);
	// 822FE3A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE3AC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE3B4: 419A0008  beq cr6, 0x822fe3bc
	if ctx.cr[6].eq {
	pc = 0x822FE3BC; continue 'dispatch;
	}
	// 822FE3B8: 4BFC24D9  bl 0x822c0890
	ctx.lr = 0x822FE3BC;
	sub_822C0890(ctx, base);
	// 822FE3BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE3C0: 4800000C  b 0x822fe3cc
	pc = 0x822FE3CC; continue 'dispatch;
	// 822FE3C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FE3C8: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FE3CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE3D8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FE3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FE3E8 size=116
    let mut pc: u32 = 0x822FE3E8;
    'dispatch: loop {
        match pc {
            0x822FE3E8 => {
    //   block [0x822FE3E8..0x822FE45C)
	// 822FE3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE3F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE3F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FE3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE400: 48B5B321  bl 0x82e59720
	ctx.lr = 0x822FE404;
	sub_82E59720(ctx, base);
	// 822FE404: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE408: 40820034  bne 0x822fe43c
	if !ctx.cr[0].eq {
	pc = 0x822FE43C; continue 'dispatch;
	}
	// 822FE40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE414: 4BFFF785  bl 0x822fdb98
	ctx.lr = 0x822FE418;
	sub_822FDB98(ctx, base);
	// 822FE418: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE41C: 4BFFB555  bl 0x822f9970
	ctx.lr = 0x822FE420;
	sub_822F9970(ctx, base);
	// 822FE420: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE424: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE42C: 419A0008  beq cr6, 0x822fe434
	if ctx.cr[6].eq {
	pc = 0x822FE434; continue 'dispatch;
	}
	// 822FE430: 4BFC2461  bl 0x822c0890
	ctx.lr = 0x822FE434;
	sub_822C0890(ctx, base);
	// 822FE434: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE438: 4800000C  b 0x822fe444
	pc = 0x822FE444; continue 'dispatch;
	// 822FE43C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FE440: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FE444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE450: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FE454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FE460 size=116
    let mut pc: u32 = 0x822FE460;
    'dispatch: loop {
        match pc {
            0x822FE460 => {
    //   block [0x822FE460..0x822FE4D4)
	// 822FE460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE46C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FE470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE478: 48B5B2A9  bl 0x82e59720
	ctx.lr = 0x822FE47C;
	sub_82E59720(ctx, base);
	// 822FE47C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE480: 40820034  bne 0x822fe4b4
	if !ctx.cr[0].eq {
	pc = 0x822FE4B4; continue 'dispatch;
	}
	// 822FE484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE48C: 4BFFF70D  bl 0x822fdb98
	ctx.lr = 0x822FE490;
	sub_822FDB98(ctx, base);
	// 822FE490: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE494: 4BFFB815  bl 0x822f9ca8
	ctx.lr = 0x822FE498;
	sub_822F9CA8(ctx, base);
	// 822FE498: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE49C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE4A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE4A4: 419A0008  beq cr6, 0x822fe4ac
	if ctx.cr[6].eq {
	pc = 0x822FE4AC; continue 'dispatch;
	}
	// 822FE4A8: 4BFC23E9  bl 0x822c0890
	ctx.lr = 0x822FE4AC;
	sub_822C0890(ctx, base);
	// 822FE4AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE4B0: 4800000C  b 0x822fe4bc
	pc = 0x822FE4BC; continue 'dispatch;
	// 822FE4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FE4B8: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FE4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FE4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE4C8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FE4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE4D8 size=236
    let mut pc: u32 = 0x822FE4D8;
    'dispatch: loop {
        match pc {
            0x822FE4D8 => {
    //   block [0x822FE4D8..0x822FE5C4)
	// 822FE4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE4DC: 48EA9C85  bl 0x831a8160
	ctx.lr = 0x822FE4E0;
	sub_831A8130(ctx, base);
	// 822FE4E0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 822FE4E4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE4E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 822FE4EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE4F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FE4F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822FE4FC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 822FE500: 48B5C021  bl 0x82e5a520
	ctx.lr = 0x822FE504;
	sub_82E5A520(ctx, base);
	// 822FE504: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FE508: 83430000  lwz r26, 0(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE50C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822FE510: 419A0024  beq cr6, 0x822fe534
	if ctx.cr[6].eq {
	pc = 0x822FE534; continue 'dispatch;
	}
	// 822FE514: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 822FE518: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FE51C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE520: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FE524: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FE528: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FE52C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE530: 4082FFE8  bne 0x822fe518
	if !ctx.cr[0].eq {
	pc = 0x822FE518; continue 'dispatch;
	}
	// 822FE534: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE53C: 419A0008  beq cr6, 0x822fe544
	if ctx.cr[6].eq {
	pc = 0x822FE544; continue 'dispatch;
	}
	// 822FE540: 4BFC2351  bl 0x822c0890
	ctx.lr = 0x822FE544;
	sub_822C0890(ctx, base);
	// 822FE544: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 822FE548: 419A003C  beq cr6, 0x822fe584
	if ctx.cr[6].eq {
	pc = 0x822FE584; continue 'dispatch;
	}
	// 822FE54C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FE550: 4BFFB251  bl 0x822f97a0
	ctx.lr = 0x822FE554;
	sub_822F97A0(ctx, base);
	// 822FE554: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822FE558: 419A002C  beq cr6, 0x822fe584
	if ctx.cr[6].eq {
	pc = 0x822FE584; continue 'dispatch;
	}
	// 822FE55C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822FE560: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FE568: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 822FE56C: 4BFFA86D  bl 0x822f8dd8
	ctx.lr = 0x822FE570;
	sub_822F8DD8(ctx, base);
	// 822FE570: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE578: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FE57C: 4BFFEFE5  bl 0x822fd560
	ctx.lr = 0x822FE580;
	sub_822FD560(ctx, base);
	// 822FE580: 48000024  b 0x822fe5a4
	pc = 0x822FE5A4; continue 'dispatch;
	// 822FE584: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE58C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FE590: 4BFFEFD1  bl 0x822fd560
	ctx.lr = 0x822FE594;
	sub_822FD560(ctx, base);
	// 822FE594: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 822FE598: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FE59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE5A0: 4BFFEF29  bl 0x822fd4c8
	ctx.lr = 0x822FE5A4;
	sub_822FD4C8(ctx, base);
	// 822FE5A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822FE5A8: 419A000C  beq cr6, 0x822fe5b4
	if ctx.cr[6].eq {
	pc = 0x822FE5B4; continue 'dispatch;
	}
	// 822FE5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE5B0: 4BFC22E1  bl 0x822c0890
	ctx.lr = 0x822FE5B4;
	sub_822C0890(ctx, base);
	// 822FE5B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 822FE5B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 822FE5BC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 822FE5C0: 48EA9BF0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE5C8 size=156
    let mut pc: u32 = 0x822FE5C8;
    'dispatch: loop {
        match pc {
            0x822FE5C8 => {
    //   block [0x822FE5C8..0x822FE664)
	// 822FE5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE5CC: 48EA9BA1  bl 0x831a816c
	ctx.lr = 0x822FE5D0;
	sub_831A8130(ctx, base);
	// 822FE5D0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FE5D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE5D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FE5DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE5E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FE5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE5E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822FE5EC: 48B5B135  bl 0x82e59720
	ctx.lr = 0x822FE5F0;
	sub_82E59720(ctx, base);
	// 822FE5F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE5F4: 40820054  bne 0x822fe648
	if !ctx.cr[0].eq {
	pc = 0x822FE648; continue 'dispatch;
	}
	// 822FE5F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE5FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE604: 4BFFEF5D  bl 0x822fd560
	ctx.lr = 0x822FE608;
	sub_822FD560(ctx, base);
	// 822FE608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE60C: 4BFFFC4D  bl 0x822fe258
	ctx.lr = 0x822FE610;
	sub_822FE258(ctx, base);
	// 822FE610: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FE614: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FE618: 4BFFAF99  bl 0x822f95b0
	ctx.lr = 0x822FE61C;
	sub_822F95B0(ctx, base);
	// 822FE61C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 822FE620: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE624: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE62C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE630: 4BFFFEA9  bl 0x822fe4d8
	ctx.lr = 0x822FE634;
	sub_822FE4D8(ctx, base);
	// 822FE634: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE63C: 419A0018  beq cr6, 0x822fe654
	if ctx.cr[6].eq {
	pc = 0x822FE654; continue 'dispatch;
	}
	// 822FE640: 4BFC2251  bl 0x822c0890
	ctx.lr = 0x822FE644;
	sub_822C0890(ctx, base);
	// 822FE644: 48000010  b 0x822fe654
	pc = 0x822FE654; continue 'dispatch;
	// 822FE648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE64C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE650: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FE65C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FE660: 48EA9B5C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FE668 size=56
    let mut pc: u32 = 0x822FE668;
    'dispatch: loop {
        match pc {
            0x822FE668 => {
    //   block [0x822FE668..0x822FE6A0)
	// 822FE668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE674: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE678: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE680: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FE684: 4BFFFF45  bl 0x822fe5c8
	ctx.lr = 0x822FE688;
	sub_822FE5C8(ctx, base);
	// 822FE688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE68C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FE690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE6A0 size=140
    let mut pc: u32 = 0x822FE6A0;
    'dispatch: loop {
        match pc {
            0x822FE6A0 => {
    //   block [0x822FE6A0..0x822FE72C)
	// 822FE6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE6A4: 48EA9AC9  bl 0x831a816c
	ctx.lr = 0x822FE6A8;
	sub_831A8130(ctx, base);
	// 822FE6A8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FE6AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE6B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FE6B4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FE6B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE6BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE6C0: 48B5B061  bl 0x82e59720
	ctx.lr = 0x822FE6C4;
	sub_82E59720(ctx, base);
	// 822FE6C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE6C8: 40820048  bne 0x822fe710
	if !ctx.cr[0].eq {
	pc = 0x822FE710; continue 'dispatch;
	}
	// 822FE6CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE6D4: 4BFFF4C5  bl 0x822fdb98
	ctx.lr = 0x822FE6D8;
	sub_822FDB98(ctx, base);
	// 822FE6D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE6DC: 4BFFA6F5  bl 0x822f8dd0
	ctx.lr = 0x822FE6E0;
	sub_822F8DD0(ctx, base);
	// 822FE6E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE6E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FE6E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FE6EC: 419A000C  beq cr6, 0x822fe6f8
	if ctx.cr[6].eq {
	pc = 0x822FE6F8; continue 'dispatch;
	}
	// 822FE6F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FE6F4: 4BFC219D  bl 0x822c0890
	ctx.lr = 0x822FE6F8;
	sub_822C0890(ctx, base);
	// 822FE6F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 822FE6FC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FE700: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FE704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE708: 4BFFFEC1  bl 0x822fe5c8
	ctx.lr = 0x822FE70C;
	sub_822FE5C8(ctx, base);
	// 822FE70C: 48000010  b 0x822fe71c
	pc = 0x822FE71C; continue 'dispatch;
	// 822FE710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FE714: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE718: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FE71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE720: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FE724: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FE728: 48EA9A94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FE730 size=56
    let mut pc: u32 = 0x822FE730;
    'dispatch: loop {
        match pc {
            0x822FE730 => {
    //   block [0x822FE730..0x822FE768)
	// 822FE730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE73C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE748: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FE74C: 4BFFFF55  bl 0x822fe6a0
	ctx.lr = 0x822FE750;
	sub_822FE6A0(ctx, base);
	// 822FE750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE754: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FE758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE768 size=292
    let mut pc: u32 = 0x822FE768;
    'dispatch: loop {
        match pc {
            0x822FE768 => {
    //   block [0x822FE768..0x822FE88C)
	// 822FE768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE76C: 48EA99F9  bl 0x831a8164
	ctx.lr = 0x822FE770;
	sub_831A8130(ctx, base);
	// 822FE770: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE778: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 822FE77C: 3BBF0060  addi r29, r31, 0x60
	ctx.r[29].s64 = ctx.r[31].s64 + 96;
	// 822FE780: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 822FE784: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 822FE788: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FE78C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE790: 484F8039  bl 0x827f67c8
	ctx.lr = 0x822FE794;
	sub_827F67C8(ctx, base);
	// 822FE794: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FE798: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FE79C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FE7A0: 409A00E0  bne cr6, 0x822fe880
	if !ctx.cr[6].eq {
	pc = 0x822FE880; continue 'dispatch;
	}
	// 822FE7A4: 389F0078  addi r4, r31, 0x78
	ctx.r[4].s64 = ctx.r[31].s64 + 120;
	// 822FE7A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE7AC: 4BFFA5E5  bl 0x822f8d90
	ctx.lr = 0x822FE7B0;
	sub_822F8D90(ctx, base);
	// 822FE7B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE7B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 822FE7B8: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FE7BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FE7C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 822FE7C4: 419A0024  beq cr6, 0x822fe7e8
	if ctx.cr[6].eq {
	pc = 0x822FE7E8; continue 'dispatch;
	}
	// 822FE7C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 822FE7CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FE7D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE7D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FE7D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FE7DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FE7E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE7E4: 4082FFE8  bne 0x822fe7cc
	if !ctx.cr[0].eq {
	pc = 0x822FE7CC; continue 'dispatch;
	}
	// 822FE7E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FE7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FE7F0: 48AF5411  bl 0x82df3c00
	ctx.lr = 0x822FE7F4;
	sub_82DF3C00(ctx, base);
	// 822FE7F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 822FE7F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 822FE7FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 822FE800: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FE804: 4878D00D  bl 0x82a8b810
	ctx.lr = 0x822FE808;
	sub_82A8B810(ctx, base);
	// 822FE808: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 822FE80C: 48AF4C1D  bl 0x82df3428
	ctx.lr = 0x822FE810;
	sub_82DF3428(ctx, base);
	// 822FE810: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FE814: 419A000C  beq cr6, 0x822fe820
	if ctx.cr[6].eq {
	pc = 0x822FE820; continue 'dispatch;
	}
	// 822FE818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE81C: 4BFC2075  bl 0x822c0890
	ctx.lr = 0x822FE820;
	sub_822C0890(ctx, base);
	// 822FE820: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 822FE824: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FE828: 48886F89  bl 0x82b857b0
	ctx.lr = 0x822FE82C;
	sub_82B857B0(ctx, base);
	// 822FE82C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 822FE830: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FE834: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FE838: 48888189  bl 0x82b869c0
	ctx.lr = 0x822FE83C;
	sub_82B869C0(ctx, base);
	// 822FE83C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 822FE840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE844: 419A0008  beq cr6, 0x822fe84c
	if ctx.cr[6].eq {
	pc = 0x822FE84C; continue 'dispatch;
	}
	// 822FE848: 4BFC2049  bl 0x822c0890
	ctx.lr = 0x822FE84C;
	sub_822C0890(ctx, base);
	// 822FE84C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FE850: 48AF4BD9  bl 0x82df3428
	ctx.lr = 0x822FE854;
	sub_82DF3428(ctx, base);
	// 822FE854: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 822FE858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE85C: 419A0008  beq cr6, 0x822fe864
	if ctx.cr[6].eq {
	pc = 0x822FE864; continue 'dispatch;
	}
	// 822FE860: 4BFC2031  bl 0x822c0890
	ctx.lr = 0x822FE864;
	sub_822C0890(ctx, base);
	// 822FE864: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FE868: 48AF4BC1  bl 0x82df3428
	ctx.lr = 0x822FE86C;
	sub_82DF3428(ctx, base);
	// 822FE86C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FE870: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FE874: 48B5AE75  bl 0x82e596e8
	ctx.lr = 0x822FE878;
	sub_82E596E8(ctx, base);
	// 822FE878: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 822FE87C: 48000008  b 0x822fe884
	pc = 0x822FE884; continue 'dispatch;
	// 822FE880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 822FE884: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FE888: 48EA992C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE890 size=228
    let mut pc: u32 = 0x822FE890;
    'dispatch: loop {
        match pc {
            0x822FE890 => {
    //   block [0x822FE890..0x822FE974)
	// 822FE890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE894: 48EA98D1  bl 0x831a8164
	ctx.lr = 0x822FE898;
	sub_831A8130(ctx, base);
	// 822FE898: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE89C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE8A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FE8A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FE8A8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 822FE8AC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 822FE8B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FE8B4: 388BC770  addi r4, r11, -0x3890
	ctx.r[4].s64 = ctx.r[11].s64 + -14480;
	// 822FE8B8: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 822FE8BC: 3860018C  li r3, 0x18c
	ctx.r[3].s64 = 396;
	// 822FE8C0: 48AF3B29  bl 0x82df23e8
	ctx.lr = 0x822FE8C4;
	sub_82DF23E8(ctx, base);
	// 822FE8C4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 822FE8C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FE8CC: 41820014  beq 0x822fe8e0
	if ctx.cr[0].eq {
	pc = 0x822FE8E0; continue 'dispatch;
	}
	// 822FE8D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE8D4: 480009C5  bl 0x822ff298
	ctx.lr = 0x822FE8D8;
	sub_822FF298(ctx, base);
	// 822FE8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE8DC: 48000008  b 0x822fe8e4
	pc = 0x822FE8E4; continue 'dispatch;
	// 822FE8E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 822FE8E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822FE8E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE8EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822FE8F0: 4BFFE941  bl 0x822fd230
	ctx.lr = 0x822FE8F4;
	sub_822FD230(ctx, base);
	// 822FE8F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FE8F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FE8FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822FE900: 4BFC1701  bl 0x822c0000
	ctx.lr = 0x822FE904;
	sub_822C0000(ctx, base);
	// 822FE904: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 822FE908: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 822FE90C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FE910: 4BFFFE59  bl 0x822fe768
	ctx.lr = 0x822FE914;
	sub_822FE768(ctx, base);
	// 822FE914: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FE918: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FE91C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FE920: 41820038  beq 0x822fe958
	if ctx.cr[0].eq {
	pc = 0x822FE958; continue 'dispatch;
	}
	// 822FE924: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FE928: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE92C: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 822FE930: 419A0038  beq cr6, 0x822fe968
	if ctx.cr[6].eq {
	pc = 0x822FE968; continue 'dispatch;
	}
	// 822FE934: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 822FE938: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 822FE93C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE940: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 822FE944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 822FE948: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 822FE94C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 822FE950: 4082FFE8  bne 0x822fe938
	if !ctx.cr[0].eq {
	pc = 0x822FE938; continue 'dispatch;
	}
	// 822FE954: 48000010  b 0x822fe964
	pc = 0x822FE964; continue 'dispatch;
	// 822FE958: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 822FE95C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 822FE960: 419A0008  beq cr6, 0x822fe968
	if ctx.cr[6].eq {
	pc = 0x822FE968; continue 'dispatch;
	}
	// 822FE964: 4BFC1F2D  bl 0x822c0890
	ctx.lr = 0x822FE968;
	sub_822C0890(ctx, base);
	// 822FE968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FE96C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FE970: 48EA9844  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE978 size=52
    let mut pc: u32 = 0x822FE978;
    'dispatch: loop {
        match pc {
            0x822FE978 => {
    //   block [0x822FE978..0x822FE9AC)
	// 822FE978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE984: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE988: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 822FE98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE990: 4BFFFF01  bl 0x822fe890
	ctx.lr = 0x822FE994;
	sub_822FE890(ctx, base);
	// 822FE994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FE99C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FE9A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FE9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FE9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FE9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FE9B0 size=92
    let mut pc: u32 = 0x822FE9B0;
    'dispatch: loop {
        match pc {
            0x822FE9B0 => {
    //   block [0x822FE9B0..0x822FEA0C)
	// 822FE9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FE9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FE9B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FE9BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FE9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FE9C4: 48B5EF0D  bl 0x82e5d8d0
	ctx.lr = 0x822FE9C8;
	sub_82E5D8D0(ctx, base);
	// 822FE9C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FE9CC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 822FE9D0: 396BC7C4  addi r11, r11, -0x383c
	ctx.r[11].s64 = ctx.r[11].s64 + -14396;
	// 822FE9D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FE9D8: 4849D221  bl 0x8279bbf8
	ctx.lr = 0x822FE9DC;
	sub_8279BBF8(ctx, base);
	// 822FE9DC: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 822FE9E0: 48AF4711  bl 0x82df30f0
	ctx.lr = 0x822FE9E4;
	sub_82DF30F0(ctx, base);
	// 822FE9E4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 822FE9E8: 4BFFA2E1  bl 0x822f8cc8
	ctx.lr = 0x822FE9EC;
	sub_822F8CC8(ctx, base);
	// 822FE9EC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 822FE9F0: 48AF4701  bl 0x82df30f0
	ctx.lr = 0x822FE9F4;
	sub_82DF30F0(ctx, base);
	// 822FE9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FE9F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FE9FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEA00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEA04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEA08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FEA10 size=104
    let mut pc: u32 = 0x822FEA10;
    'dispatch: loop {
        match pc {
            0x822FEA10 => {
    //   block [0x822FEA10..0x822FEA78)
	// 822FEA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEA18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FEA1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEA24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FEA28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FEA2C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 822FEA30: 48AF49F9  bl 0x82df3428
	ctx.lr = 0x822FEA34;
	sub_82DF3428(ctx, base);
	// 822FEA34: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 822FEA38: 48AF49F1  bl 0x82df3428
	ctx.lr = 0x822FEA3C;
	sub_82DF3428(ctx, base);
	// 822FEA3C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 822FEA40: 482B16D1  bl 0x825b0110
	ctx.lr = 0x822FEA44;
	sub_825B0110(ctx, base);
	// 822FEA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEA48: 48B5EE01  bl 0x82e5d848
	ctx.lr = 0x822FEA4C;
	sub_82E5D848(ctx, base);
	// 822FEA4C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FEA50: 4182000C  beq 0x822fea5c
	if ctx.cr[0].eq {
	pc = 0x822FEA5C; continue 'dispatch;
	}
	// 822FEA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEA58: 48AF3981  bl 0x82df23d8
	ctx.lr = 0x822FEA5C;
	sub_82DF23D8(ctx, base);
	// 822FEA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEA60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FEA64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEA68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEA6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FEA70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEA78 size=192
    let mut pc: u32 = 0x822FEA78;
    'dispatch: loop {
        match pc {
            0x822FEA78 => {
    //   block [0x822FEA78..0x822FEB38)
	// 822FEA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEA80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FEA84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEA88: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FEA8C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FEA94: 48711DDD  bl 0x82a10870
	ctx.lr = 0x822FEA98;
	sub_82A10870(ctx, base);
	// 822FEA98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEA9C: 3BDF0190  addi r30, r31, 0x190
	ctx.r[30].s64 = ctx.r[31].s64 + 400;
	// 822FEAA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEAA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FEAA8: 4E800421  bctrl
	ctx.lr = 0x822FEAAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FEAAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FEAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FEAB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FEAB8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FEABC: 488B41BD  bl 0x82bb2c78
	ctx.lr = 0x822FEAC0;
	sub_82BB2C78(ctx, base);
	// 822FEAC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FEAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEAC8: 4BFFA9E9  bl 0x822f94b0
	ctx.lr = 0x822FEACC;
	sub_822F94B0(ctx, base);
	// 822FEACC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FEAD0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FEAD4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FEAD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FEADC: 488BA715  bl 0x82bb91f0
	ctx.lr = 0x822FEAE0;
	sub_82BB91F0(ctx, base);
	// 822FEAE0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FEAE4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FEAE8: 488BA949  bl 0x82bb9430
	ctx.lr = 0x822FEAEC;
	sub_82BB9430(ctx, base);
	// 822FEAEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FEAF0: C03F018C  lfs f1, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FEAF4: 488BA89D  bl 0x82bb9390
	ctx.lr = 0x822FEAF8;
	sub_82BB9390(ctx, base);
	// 822FEAF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FEAFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FEB00: 488B7859  bl 0x82bb6358
	ctx.lr = 0x822FEB04;
	sub_82BB6358(ctx, base);
	// 822FEB04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FEB08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FEB0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FEB10: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 822FEB14: 419A0008  beq cr6, 0x822feb1c
	if ctx.cr[6].eq {
	pc = 0x822FEB1C; continue 'dispatch;
	}
	// 822FEB18: 4BFC1D79  bl 0x822c0890
	ctx.lr = 0x822FEB1C;
	sub_822C0890(ctx, base);
	// 822FEB1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FEB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEB28: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FEB2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FEB30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEB38 size=176
    let mut pc: u32 = 0x822FEB38;
    'dispatch: loop {
        match pc {
            0x822FEB38 => {
    //   block [0x822FEB38..0x822FEBE8)
	// 822FEB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEB40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FEB44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEB48: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FEB4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEB50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FEB54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FEB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FEB5C: 4BFFA8CD  bl 0x822f9428
	ctx.lr = 0x822FEB60;
	sub_822F9428(ctx, base);
	// 822FEB60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FEB64: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FEB6C: 419A000C  beq cr6, 0x822feb78
	if ctx.cr[6].eq {
	pc = 0x822FEB78; continue 'dispatch;
	}
	// 822FEB70: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FEB74: 4BFC1D1D  bl 0x822c0890
	ctx.lr = 0x822FEB78;
	sub_822C0890(ctx, base);
	// 822FEB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEB7C: 4BFFA205  bl 0x822f8d80
	ctx.lr = 0x822FEB80;
	sub_822F8D80(ctx, base);
	// 822FEB80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEB84: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FEB88: 48B5AB71  bl 0x82e596f8
	ctx.lr = 0x822FEB8C;
	sub_82E596F8(ctx, base);
	// 822FEB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FEB90: EC3F0072  fmuls f1, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[1].f64) as f32) as f64);
	// 822FEB94: 488BA94D  bl 0x82bb94e0
	ctx.lr = 0x822FEB98;
	sub_82BB94E0(ctx, base);
	// 822FEB98: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FEB9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FEBA0: 409A002C  bne cr6, 0x822febcc
	if !ctx.cr[6].eq {
	pc = 0x822FEBCC; continue 'dispatch;
	}
	// 822FEBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FEBA8: C3FF0188  lfs f31, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FEBAC: 488B7E8D  bl 0x82bb6a38
	ctx.lr = 0x822FEBB0;
	sub_82BB6A38(ctx, base);
	// 822FEBB0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822FEBB4: 40990018  ble cr6, 0x822febcc
	if !ctx.cr[6].gt {
	pc = 0x822FEBCC; continue 'dispatch;
	}
	// 822FEBB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FEBBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FEBC0: 488BA631  bl 0x82bb91f0
	ctx.lr = 0x822FEBC4;
	sub_82BB91F0(ctx, base);
	// 822FEBC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 822FEBC8: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 822FEBCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FEBD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEBD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEBD8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FEBDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FEBE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEBE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEBE8 size=128
    let mut pc: u32 = 0x822FEBE8;
    'dispatch: loop {
        match pc {
            0x822FEBE8 => {
    //   block [0x822FEBE8..0x822FEC68)
	// 822FEBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEBF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FEBF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEBF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEBFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FEC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FEC04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FEC08: 4BFFA821  bl 0x822f9428
	ctx.lr = 0x822FEC0C;
	sub_822F9428(ctx, base);
	// 822FEC0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FEC10: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEC14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FEC18: 419A000C  beq cr6, 0x822fec24
	if ctx.cr[6].eq {
	pc = 0x822FEC24; continue 'dispatch;
	}
	// 822FEC1C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FEC20: 4BFC1C71  bl 0x822c0890
	ctx.lr = 0x822FEC24;
	sub_822C0890(ctx, base);
	// 822FEC24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FEC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEC2C: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FEC30: 488BA761  bl 0x82bb9390
	ctx.lr = 0x822FEC34;
	sub_82BB9390(ctx, base);
	// 822FEC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEC38: 488B7EC9  bl 0x82bb6b00
	ctx.lr = 0x822FEC3C;
	sub_82BB6B00(ctx, base);
	// 822FEC3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 822FEC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEC44: 488B7715  bl 0x82bb6358
	ctx.lr = 0x822FEC48;
	sub_82BB6358(ctx, base);
	// 822FEC48: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 822FEC4C: 917E0194  stw r11, 0x194(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 822FEC50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FEC54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEC58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEC5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FEC60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEC64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEC68 size=144
    let mut pc: u32 = 0x822FEC68;
    'dispatch: loop {
        match pc {
            0x822FEC68 => {
    //   block [0x822FEC68..0x822FECF8)
	// 822FEC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEC6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEC70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEC74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEC78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FEC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FEC80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FEC84: 4BFFA7A5  bl 0x822f9428
	ctx.lr = 0x822FEC88;
	sub_822F9428(ctx, base);
	// 822FEC88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FEC8C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEC90: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FEC94: 488BA84D  bl 0x82bb94e0
	ctx.lr = 0x822FEC98;
	sub_82BB94E0(ctx, base);
	// 822FEC98: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FEC9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FECA0: 419A0008  beq cr6, 0x822feca8
	if ctx.cr[6].eq {
	pc = 0x822FECA8; continue 'dispatch;
	}
	// 822FECA4: 4BFC1BED  bl 0x822c0890
	ctx.lr = 0x822FECA8;
	sub_822C0890(ctx, base);
	// 822FECA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FECAC: 48711BC5  bl 0x82a10870
	ctx.lr = 0x822FECB0;
	sub_82A10870(ctx, base);
	// 822FECB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FECB4: 3BFF0190  addi r31, r31, 0x190
	ctx.r[31].s64 = ctx.r[31].s64 + 400;
	// 822FECB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FECBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FECC0: 4E800421  bctrl
	ctx.lr = 0x822FECC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FECC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FECC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FECCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FECD0: 488B4051  bl 0x82bb2d20
	ctx.lr = 0x822FECD4;
	sub_82BB2D20(ctx, base);
	// 822FECD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FECD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FECDC: 419A0008  beq cr6, 0x822fece4
	if ctx.cr[6].eq {
	pc = 0x822FECE4; continue 'dispatch;
	}
	// 822FECE0: 4BFC1BB1  bl 0x822c0890
	ctx.lr = 0x822FECE4;
	sub_822C0890(ctx, base);
	// 822FECE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FECE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FECEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FECF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FECF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FECF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FECF8 size=108
    let mut pc: u32 = 0x822FECF8;
    'dispatch: loop {
        match pc {
            0x822FECF8 => {
    //   block [0x822FECF8..0x822FED64)
	// 822FECF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FECFC: 48EA9471  bl 0x831a816c
	ctx.lr = 0x822FED00;
	sub_831A8130(ctx, base);
	// 822FED00: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 822FED04: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FED08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FED0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FED10: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FED14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FED18: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 822FED1C: 4BFFE365  bl 0x822fd080
	ctx.lr = 0x822FED20;
	sub_822FD080(ctx, base);
	// 822FED20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FED24: D3FF0188  stfs f31, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 822FED28: 3BDF0190  addi r30, r31, 0x190
	ctx.r[30].s64 = ctx.r[31].s64 + 400;
	// 822FED2C: 396BC7D4  addi r11, r11, -0x382c
	ctx.r[11].s64 = ctx.r[11].s64 + -14380;
	// 822FED30: D3DF018C  stfs f30, 0x18c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 822FED34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FED38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FED3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FED40: 48AF4EC1  bl 0x82df3c00
	ctx.lr = 0x822FED44;
	sub_82DF3C00(ctx, base);
	// 822FED44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FED48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FED4C: 48B5A99D  bl 0x82e596e8
	ctx.lr = 0x822FED50;
	sub_82E596E8(ctx, base);
	// 822FED50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FED54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FED58: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822FED5C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FED60: 48EA945C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FED68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FED68 size=88
    let mut pc: u32 = 0x822FED68;
    'dispatch: loop {
        match pc {
            0x822FED68 => {
    //   block [0x822FED68..0x822FEDC0)
	// 822FED68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FED6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FED70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FED74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FED78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FED7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FED80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FED84: 387F0190  addi r3, r31, 0x190
	ctx.r[3].s64 = ctx.r[31].s64 + 400;
	// 822FED88: 48AF46A1  bl 0x82df3428
	ctx.lr = 0x822FED8C;
	sub_82DF3428(ctx, base);
	// 822FED8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FED90: 4BFFE3C9  bl 0x822fd158
	ctx.lr = 0x822FED94;
	sub_822FD158(ctx, base);
	// 822FED94: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FED98: 4182000C  beq 0x822feda4
	if ctx.cr[0].eq {
	pc = 0x822FEDA4; continue 'dispatch;
	}
	// 822FED9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEDA0: 48AF3639  bl 0x82df23d8
	ctx.lr = 0x822FEDA4;
	sub_82DF23D8(ctx, base);
	// 822FEDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FEDA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FEDAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEDB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEDB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FEDB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEDBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEDC0 size=128
    let mut pc: u32 = 0x822FEDC0;
    'dispatch: loop {
        match pc {
            0x822FEDC0 => {
    //   block [0x822FEDC0..0x822FEE40)
	// 822FEDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEDC4: 48EA93A5  bl 0x831a8168
	ctx.lr = 0x822FEDC8;
	sub_831A8130(ctx, base);
	// 822FEDC8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822FEDCC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEDD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FEDD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FEDD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822FEDDC: 3B9E0188  addi r28, r30, 0x188
	ctx.r[28].s64 = ctx.r[30].s64 + 392;
	// 822FEDE0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FEDE4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FEDE8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FEDEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FEDF0: 419A0038  beq cr6, 0x822fee28
	if ctx.cr[6].eq {
	pc = 0x822FEE28; continue 'dispatch;
	}
	// 822FEDF4: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FEDF8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FEDFC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822FEE00: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FEE04: 40980024  bge cr6, 0x822fee28
	if !ctx.cr[6].lt {
	pc = 0x822FEE28; continue 'dispatch;
	}
	// 822FEE08: 817E018C  lwz r11, 0x18c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FEE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FEE10: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FEE14: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 822FEE18: 4BFFA4C9  bl 0x822f92e0
	ctx.lr = 0x822FEE1C;
	sub_822F92E0(ctx, base);
	// 822FEE1C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822FEE20: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 822FEE24: 4BFFFFC4  b 0x822fede8
	pc = 0x822FEDE8; continue 'dispatch;
	// 822FEE28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FEE2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FEE30: 4BFFA0A9  bl 0x822f8ed8
	ctx.lr = 0x822FEE34;
	sub_822F8ED8(ctx, base);
	// 822FEE34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FEE38: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822FEE3C: 48EA937C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FEE40 size=320
    let mut pc: u32 = 0x822FEE40;
    'dispatch: loop {
        match pc {
            0x822FEE40 => {
    //   block [0x822FEE40..0x822FEF80)
	// 822FEE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEE44: 48EA9329  bl 0x831a816c
	ctx.lr = 0x822FEE48;
	sub_831A8130(ctx, base);
	// 822FEE48: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 822FEE4C: 48EA9C25  bl 0x831a8a70
	ctx.lr = 0x822FEE50;
	sub_831A8A40(ctx, base);
	// 822FEE50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEE54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FEE58: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 822FEE5C: 3BDD0188  addi r30, r29, 0x188
	ctx.r[30].s64 = ctx.r[29].s64 + 392;
	// 822FEE60: 817D018C  lwz r11, 0x18c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FEE64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FEE68: 419A0010  beq cr6, 0x822fee78
	if ctx.cr[6].eq {
	pc = 0x822FEE78; continue 'dispatch;
	}
	// 822FEE6C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FEE70: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FEE74: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822FEE78: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 822FEE7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822FEE80: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822FEE84: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822FEE88: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822FEE8C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 822FEE90: 41980008  blt cr6, 0x822fee98
	if ctx.cr[6].lt {
	pc = 0x822FEE98; continue 'dispatch;
	}
	// 822FEE94: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 822FEE98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FEE9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 822FEEA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822FEEA4: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 822FEEA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FEEAC: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 822FEEB0: FF80E82E  fsel f28, f0, f0, f29
	ctx.f[28].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[29].f64 };
	// 822FEEB4: C36B9534  lfs f27, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 822FEEB8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FEEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FEEC0: 419A0090  beq cr6, 0x822fef50
	if ctx.cr[6].eq {
	pc = 0x822FEF50; continue 'dispatch;
	}
	// 822FEEC4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FEEC8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FEECC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 822FEED0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FEED4: 4098007C  bge cr6, 0x822fef50
	if !ctx.cr[6].lt {
	pc = 0x822FEF50; continue 'dispatch;
	}
	// 822FEED8: 7BEB0020  clrldi r11, r31, 0x20
	ctx.r[11].u64 = ctx.r[31].u64 & 0x00000000FFFFFFFFu64;
	// 822FEEDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 822FEEE0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 822FEEE4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 822FEEE8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 822FEEEC: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FEEF0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 822FEEF4: 4199000C  bgt cr6, 0x822fef00
	if ctx.cr[6].gt {
	pc = 0x822FEF00; continue 'dispatch;
	}
	// 822FEEF8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 822FEEFC: 4098000C  bge cr6, 0x822fef08
	if !ctx.cr[6].lt {
	pc = 0x822FEF08; continue 'dispatch;
	}
	// 822FEF00: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	// 822FEF04: 48000018  b 0x822fef1c
	pc = 0x822FEF1C; continue 'dispatch;
	// 822FEF08: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 822FEF0C: 4098000C  bge cr6, 0x822fef18
	if !ctx.cr[6].lt {
	pc = 0x822FEF18; continue 'dispatch;
	}
	// 822FEF10: EFE0F02A  fadds f31, f0, f30
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 822FEF14: 48000008  b 0x822fef1c
	pc = 0x822FEF1C; continue 'dispatch;
	// 822FEF18: EFFE0028  fsubs f31, f30, f0
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FEF1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FEF20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FEF24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FEF28: 4BFFA371  bl 0x822f9298
	ctx.lr = 0x822FEF2C;
	sub_822F9298(ctx, base);
	// 822FEF2C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FEF30: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FEF34: 4BFFB50D  bl 0x822fa440
	ctx.lr = 0x822FEF38;
	sub_822FA440(ctx, base);
	// 822FEF38: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FEF3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FEF40: 419A0008  beq cr6, 0x822fef48
	if ctx.cr[6].eq {
	pc = 0x822FEF48; continue 'dispatch;
	}
	// 822FEF44: 4BFC194D  bl 0x822c0890
	ctx.lr = 0x822FEF48;
	sub_822C0890(ctx, base);
	// 822FEF48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822FEF4C: 4BFFFF6C  b 0x822feeb8
	pc = 0x822FEEB8; continue 'dispatch;
	// 822FEF50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FEF54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FEF58: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FEF5C: EC1A002A  fadds f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64;
	// 822FEF60: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 822FEF64: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 822FEF68: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FEF6C: 4BFF9F6D  bl 0x822f8ed8
	ctx.lr = 0x822FEF70;
	sub_822F8ED8(ctx, base);
	// 822FEF70: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 822FEF74: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 822FEF78: 48EA9B45  bl 0x831a8abc
	ctx.lr = 0x822FEF7C;
	sub_831A8A8C(ctx, base);
	// 822FEF7C: 48EA9240  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FEF80 size=60
    let mut pc: u32 = 0x822FEF80;
    'dispatch: loop {
        match pc {
            0x822FEF80 => {
    //   block [0x822FEF80..0x822FEFBC)
	// 822FEF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEF88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEF8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FEF94: 4BFFD38D  bl 0x822fc320
	ctx.lr = 0x822FEF98;
	sub_822FC320(ctx, base);
	// 822FEF98: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822FEF9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FEFA0: 387F0188  addi r3, r31, 0x188
	ctx.r[3].s64 = ctx.r[31].s64 + 392;
	// 822FEFA4: 481B6235  bl 0x824b51d8
	ctx.lr = 0x822FEFA8;
	sub_824B51D8(ctx, base);
	// 822FEFA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FEFAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FEFB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FEFB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FEFB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FEFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FEFC0 size=180
    let mut pc: u32 = 0x822FEFC0;
    'dispatch: loop {
        match pc {
            0x822FEFC0 => {
    //   block [0x822FEFC0..0x822FF074)
	// 822FEFC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FEFC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FEFC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FEFCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FEFD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FEFD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FEFD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FEFDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FEFE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FEFE4: 388BC808  addi r4, r11, -0x37f8
	ctx.r[4].s64 = ctx.r[11].s64 + -14328;
	// 822FEFE8: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 822FEFEC: 3860018C  li r3, 0x18c
	ctx.r[3].s64 = 396;
	// 822FEFF0: 48AF33F9  bl 0x82df23e8
	ctx.lr = 0x822FEFF4;
	sub_82DF23E8(ctx, base);
	// 822FEFF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FEFF8: 41820014  beq 0x822ff00c
	if ctx.cr[0].eq {
	pc = 0x822FF00C; continue 'dispatch;
	}
	// 822FEFFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF000: 48000299  bl 0x822ff298
	ctx.lr = 0x822FF004;
	sub_822FF298(ctx, base);
	// 822FF004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF008: 48000008  b 0x822ff010
	pc = 0x822FF010; continue 'dispatch;
	// 822FF00C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822FF010: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 822FF014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF018: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822FF01C: 4BFFE215  bl 0x822fd230
	ctx.lr = 0x822FF020;
	sub_822FD230(ctx, base);
	// 822FF020: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FF024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF028: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 822FF02C: 4BFC0FD5  bl 0x822c0000
	ctx.lr = 0x822FF030;
	sub_822C0000(ctx, base);
	// 822FF030: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 822FF034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FF038: 4BFFD2E9  bl 0x822fc320
	ctx.lr = 0x822FF03C;
	sub_822FC320(ctx, base);
	// 822FF03C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 822FF040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FF044: 387E0188  addi r3, r30, 0x188
	ctx.r[3].s64 = ctx.r[30].s64 + 392;
	// 822FF048: 481B6191  bl 0x824b51d8
	ctx.lr = 0x822FF04C;
	sub_824B51D8(ctx, base);
	// 822FF04C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FF050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF054: 419A0008  beq cr6, 0x822ff05c
	if ctx.cr[6].eq {
	pc = 0x822FF05C; continue 'dispatch;
	}
	// 822FF058: 4BFC1839  bl 0x822c0890
	ctx.lr = 0x822FF05C;
	sub_822C0890(ctx, base);
	// 822FF05C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FF060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FF06C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF078 size=76
    let mut pc: u32 = 0x822FF078;
    'dispatch: loop {
        match pc {
            0x822FF078 => {
    //   block [0x822FF078..0x822FF0C4)
	// 822FF078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF084: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF08C: 4BFFDFF5  bl 0x822fd080
	ctx.lr = 0x822FF090;
	sub_822FD080(ctx, base);
	// 822FF090: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 822FF094: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FF098: 394AC860  addi r10, r10, -0x37a0
	ctx.r[10].s64 = ctx.r[10].s64 + -14240;
	// 822FF09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF0A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 822FF0A4: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 822FF0A8: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 822FF0AC: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 822FF0B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FF0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF0BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF0C8 size=120
    let mut pc: u32 = 0x822FF0C8;
    'dispatch: loop {
        match pc {
            0x822FF0C8 => {
    //   block [0x822FF0C8..0x822FF140)
	// 822FF0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF0D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FF0D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF0D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF0E0: 48711791  bl 0x82a10870
	ctx.lr = 0x822FF0E4;
	sub_82A10870(ctx, base);
	// 822FF0E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF0E8: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 822FF0EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF0F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FF0F4: 4E800421  bctrl
	ctx.lr = 0x822FF0F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FF0F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FF0FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FF100: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 822FF104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FF108: 488B3B71  bl 0x82bb2c78
	ctx.lr = 0x822FF10C;
	sub_82BB2C78(ctx, base);
	// 822FF10C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FF110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF114: 4BFFA39D  bl 0x822f94b0
	ctx.lr = 0x822FF118;
	sub_822F94B0(ctx, base);
	// 822FF118: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FF11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF120: 419A0008  beq cr6, 0x822ff128
	if ctx.cr[6].eq {
	pc = 0x822FF128; continue 'dispatch;
	}
	// 822FF124: 4BFC176D  bl 0x822c0890
	ctx.lr = 0x822FF128;
	sub_822C0890(ctx, base);
	// 822FF128: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FF12C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF130: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF134: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FF138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF140 size=124
    let mut pc: u32 = 0x822FF140;
    'dispatch: loop {
        match pc {
            0x822FF140 => {
    //   block [0x822FF140..0x822FF1BC)
	// 822FF140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF148: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FF14C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF150: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 822FF154: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF15C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FF160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF164: 4BFFA2C5  bl 0x822f9428
	ctx.lr = 0x822FF168;
	sub_822F9428(ctx, base);
	// 822FF168: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FF16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF170: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF174: 4BFF9C0D  bl 0x822f8d80
	ctx.lr = 0x822FF178;
	sub_822F8D80(ctx, base);
	// 822FF178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF17C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FF180: 48B5A579  bl 0x82e596f8
	ctx.lr = 0x822FF184;
	sub_82E596F8(ctx, base);
	// 822FF184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FF188: EC3F0072  fmuls f1, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[1].f64) as f32) as f64);
	// 822FF18C: 488BA355  bl 0x82bb94e0
	ctx.lr = 0x822FF190;
	sub_82BB94E0(ctx, base);
	// 822FF190: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FF194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF198: 419A0008  beq cr6, 0x822ff1a0
	if ctx.cr[6].eq {
	pc = 0x822FF1A0; continue 'dispatch;
	}
	// 822FF19C: 4BFC16F5  bl 0x822c0890
	ctx.lr = 0x822FF1A0;
	sub_822C0890(ctx, base);
	// 822FF1A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FF1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF1AC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 822FF1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FF1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FF1C0 size=144
    let mut pc: u32 = 0x822FF1C0;
    'dispatch: loop {
        match pc {
            0x822FF1C0 => {
    //   block [0x822FF1C0..0x822FF250)
	// 822FF1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF1C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF1CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF1D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FF1D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF1DC: 4BFFA24D  bl 0x822f9428
	ctx.lr = 0x822FF1E0;
	sub_822F9428(ctx, base);
	// 822FF1E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF1E4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF1E8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FF1EC: 488BA2F5  bl 0x82bb94e0
	ctx.lr = 0x822FF1F0;
	sub_82BB94E0(ctx, base);
	// 822FF1F0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FF1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF1F8: 419A0008  beq cr6, 0x822ff200
	if ctx.cr[6].eq {
	pc = 0x822FF200; continue 'dispatch;
	}
	// 822FF1FC: 4BFC1695  bl 0x822c0890
	ctx.lr = 0x822FF200;
	sub_822C0890(ctx, base);
	// 822FF200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF204: 4871166D  bl 0x82a10870
	ctx.lr = 0x822FF208;
	sub_82A10870(ctx, base);
	// 822FF208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF20C: 3BFF0188  addi r31, r31, 0x188
	ctx.r[31].s64 = ctx.r[31].s64 + 392;
	// 822FF210: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FF218: 4E800421  bctrl
	ctx.lr = 0x822FF21C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FF21C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FF220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FF224: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FF228: 488B3AF9  bl 0x82bb2d20
	ctx.lr = 0x822FF22C;
	sub_82BB2D20(ctx, base);
	// 822FF22C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FF230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF234: 419A0008  beq cr6, 0x822ff23c
	if ctx.cr[6].eq {
	pc = 0x822FF23C; continue 'dispatch;
	}
	// 822FF238: 4BFC1659  bl 0x822c0890
	ctx.lr = 0x822FF23C;
	sub_822C0890(ctx, base);
	// 822FF23C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FF240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF250 size=68
    let mut pc: u32 = 0x822FF250;
    'dispatch: loop {
        match pc {
            0x822FF250 => {
    //   block [0x822FF250..0x822FF294)
	// 822FF250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF25C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF264: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FF268: 387F0188  addi r3, r31, 0x188
	ctx.r[3].s64 = ctx.r[31].s64 + 392;
	// 822FF26C: 396BC898  addi r11, r11, -0x3768
	ctx.r[11].s64 = ctx.r[11].s64 + -14184;
	// 822FF270: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FF274: 48AF41B5  bl 0x82df3428
	ctx.lr = 0x822FF278;
	sub_82DF3428(ctx, base);
	// 822FF278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF27C: 4BFFDEDD  bl 0x822fd158
	ctx.lr = 0x822FF280;
	sub_822FD158(ctx, base);
	// 822FF280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FF284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF28C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF298 size=76
    let mut pc: u32 = 0x822FF298;
    'dispatch: loop {
        match pc {
            0x822FF298 => {
    //   block [0x822FF298..0x822FF2E4)
	// 822FF298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF29C: 48EA8ED1  bl 0x831a816c
	ctx.lr = 0x822FF2A0;
	sub_831A8130(ctx, base);
	// 822FF2A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF2A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF2A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FF2AC: 4BFFDDD5  bl 0x822fd080
	ctx.lr = 0x822FF2B0;
	sub_822FD080(ctx, base);
	// 822FF2B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FF2B4: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 822FF2B8: 396BC898  addi r11, r11, -0x3768
	ctx.r[11].s64 = ctx.r[11].s64 + -14184;
	// 822FF2BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FF2C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FF2C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FF2C8: 48AF4939  bl 0x82df3c00
	ctx.lr = 0x822FF2CC;
	sub_82DF3C00(ctx, base);
	// 822FF2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF2D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FF2D4: 48B5A415  bl 0x82e596e8
	ctx.lr = 0x822FF2D8;
	sub_82E596E8(ctx, base);
	// 822FF2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF2DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FF2E0: 48EA8EDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF2E8 size=76
    let mut pc: u32 = 0x822FF2E8;
    'dispatch: loop {
        match pc {
            0x822FF2E8 => {
    //   block [0x822FF2E8..0x822FF334)
	// 822FF2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF2F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FF2F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF2F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FF304: 4BFFFF4D  bl 0x822ff250
	ctx.lr = 0x822FF308;
	sub_822FF250(ctx, base);
	// 822FF308: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FF30C: 4182000C  beq 0x822ff318
	if ctx.cr[0].eq {
	pc = 0x822FF318; continue 'dispatch;
	}
	// 822FF310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF314: 48AF30C5  bl 0x82df23d8
	ctx.lr = 0x822FF318;
	sub_82DF23D8(ctx, base);
	// 822FF318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF31C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FF320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF328: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FF32C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FF338 size=92
    let mut pc: u32 = 0x822FF338;
    'dispatch: loop {
        match pc {
            0x822FF338 => {
    //   block [0x822FF338..0x822FF394)
	// 822FF338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF33C: 48EA8E2D  bl 0x831a8168
	ctx.lr = 0x822FF340;
	sub_831A8130(ctx, base);
	// 822FF340: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 822FF344: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FF34C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF350: 3B9D0188  addi r28, r29, 0x188
	ctx.r[28].s64 = ctx.r[29].s64 + 392;
	// 822FF354: 3BE00005  li r31, 5
	ctx.r[31].s64 = 5;
	// 822FF358: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 822FF35C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FF360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FF364: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF368: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF36C: 4BFF9F75  bl 0x822f92e0
	ctx.lr = 0x822FF370;
	sub_822F92E0(ctx, base);
	// 822FF370: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 822FF374: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 822FF378: 4082FFE8  bne 0x822ff360
	if !ctx.cr[0].eq {
	pc = 0x822FF360; continue 'dispatch;
	}
	// 822FF37C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 822FF380: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF384: 4BFF9B55  bl 0x822f8ed8
	ctx.lr = 0x822FF388;
	sub_822F8ED8(ctx, base);
	// 822FF388: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FF38C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 822FF390: 48EA8E28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x822FF398 size=4
    let mut pc: u32 = 0x822FF398;
    'dispatch: loop {
        match pc {
            0x822FF398 => {
    //   block [0x822FF398..0x822FF39C)
	// 822FF398: 4BFF9B48  b 0x822f8ee0
	sub_822F8EE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FF3A0 size=1240
    let mut pc: u32 = 0x822FF3A0;
    'dispatch: loop {
        match pc {
            0x822FF3A0 => {
    //   block [0x822FF3A0..0x822FF878)
	// 822FF3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF3A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF3AC: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 822FF3B0: 48EA96C9  bl 0x831a8a78
	ctx.lr = 0x822FF3B4;
	sub_831A8A40(ctx, base);
	// 822FF3B4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF3B8: FC000A10  fabs f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 822FF3BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FF3C0: FD801210  fabs f12, f2
	ctx.f[12].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 822FF3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF3C8: C1AB9F7C  lfs f13, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 822FF3CC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 822FF3D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 822FF3D4: 409800E4  bge cr6, 0x822ff4b8
	if !ctx.cr[6].lt {
	pc = 0x822FF4B8; continue 'dispatch;
	}
	// 822FF3D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF3DC: 80BF018C  lwz r5, 0x18c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FF3E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FF3E4: 4BFF9EB5  bl 0x822f9298
	ctx.lr = 0x822FF3E8;
	sub_822F9298(ctx, base);
	// 822FF3E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF3EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF3F0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FF3F4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF3F8: 4BFFB049  bl 0x822fa440
	ctx.lr = 0x822FF3FC;
	sub_822FA440(ctx, base);
	// 822FF3FC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FF400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF404: 419A0008  beq cr6, 0x822ff40c
	if ctx.cr[6].eq {
	pc = 0x822FF40C; continue 'dispatch;
	}
	// 822FF408: 4BFC1489  bl 0x822c0890
	ctx.lr = 0x822FF40C;
	sub_822C0890(ctx, base);
	// 822FF40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF410: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822FF414: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 822FF418: 4BFF9E81  bl 0x822f9298
	ctx.lr = 0x822FF41C;
	sub_822F9298(ctx, base);
	// 822FF41C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF420: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF424: 4BFFB01D  bl 0x822fa440
	ctx.lr = 0x822FF428;
	sub_822FA440(ctx, base);
	// 822FF428: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 822FF42C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF430: 419A0008  beq cr6, 0x822ff438
	if ctx.cr[6].eq {
	pc = 0x822FF438; continue 'dispatch;
	}
	// 822FF434: 4BFC145D  bl 0x822c0890
	ctx.lr = 0x822FF438;
	sub_822C0890(ctx, base);
	// 822FF438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF43C: 80BF0194  lwz r5, 0x194(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FF440: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 822FF444: 4BFF9E55  bl 0x822f9298
	ctx.lr = 0x822FF448;
	sub_822F9298(ctx, base);
	// 822FF448: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF44C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF450: 4BFFAFF1  bl 0x822fa440
	ctx.lr = 0x822FF454;
	sub_822FA440(ctx, base);
	// 822FF454: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 822FF458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF45C: 419A0008  beq cr6, 0x822ff464
	if ctx.cr[6].eq {
	pc = 0x822FF464; continue 'dispatch;
	}
	// 822FF460: 4BFC1431  bl 0x822c0890
	ctx.lr = 0x822FF464;
	sub_822C0890(ctx, base);
	// 822FF464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF468: 80BF0198  lwz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822FF46C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 822FF470: 4BFF9E29  bl 0x822f9298
	ctx.lr = 0x822FF474;
	sub_822F9298(ctx, base);
	// 822FF474: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF478: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF47C: 4BFFAFC5  bl 0x822fa440
	ctx.lr = 0x822FF480;
	sub_822FA440(ctx, base);
	// 822FF480: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 822FF484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF488: 419A0008  beq cr6, 0x822ff490
	if ctx.cr[6].eq {
	pc = 0x822FF490; continue 'dispatch;
	}
	// 822FF48C: 4BFC1405  bl 0x822c0890
	ctx.lr = 0x822FF490;
	sub_822C0890(ctx, base);
	// 822FF490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF494: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822FF498: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 822FF49C: 4BFF9DFD  bl 0x822f9298
	ctx.lr = 0x822FF4A0;
	sub_822F9298(ctx, base);
	// 822FF4A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF4A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF4A8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FF4AC: 4BFFAF95  bl 0x822fa440
	ctx.lr = 0x822FF4B0;
	sub_822FA440(ctx, base);
	// 822FF4B0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 822FF4B4: 4800039C  b 0x822ff850
	pc = 0x822FF850; continue 'dispatch;
	// 822FF4B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF4BC: C38B08A8  lfs f28, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 822FF4C0: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 822FF4C4: 4099001C  ble cr6, 0x822ff4e0
	if !ctx.cr[6].gt {
	pc = 0x822FF4E0; continue 'dispatch;
	}
	// 822FF4C8: EC1C0024  fdivs f0, f28, f0
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	// 822FF4CC: EDA00072  fmuls f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 822FF4D0: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 822FF4D4: FFC06A10  fabs f30, f13
	ctx.f[30].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 822FF4D8: FFA00210  fabs f29, f0
	ctx.f[29].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 822FF4DC: 4800000C  b 0x822ff4e8
	pc = 0x822FF4E8; continue 'dispatch;
	// 822FF4E0: FFC00A10  fabs f30, f1
	ctx.f[30].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 822FF4E4: FFA01210  fabs f29, f2
	ctx.f[29].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 822FF4E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 822FF4EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF4F0: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 822FF4F4: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 822FF4F8: 409901B0  ble cr6, 0x822ff6a8
	if !ctx.cr[6].gt {
	pc = 0x822FF6A8; continue 'dispatch;
	}
	// 822FF4FC: 80BF018C  lwz r5, 0x18c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FF500: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 822FF504: 409900D4  ble cr6, 0x822ff5d8
	if !ctx.cr[6].gt {
	pc = 0x822FF5D8; continue 'dispatch;
	}
	// 822FF508: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 822FF50C: 4BFF9D8D  bl 0x822f9298
	ctx.lr = 0x822FF510;
	sub_822F9298(ctx, base);
	// 822FF510: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF514: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF518: 4BFFAF29  bl 0x822fa440
	ctx.lr = 0x822FF51C;
	sub_822FA440(ctx, base);
	// 822FF51C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 822FF520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF524: 419A0008  beq cr6, 0x822ff52c
	if ctx.cr[6].eq {
	pc = 0x822FF52C; continue 'dispatch;
	}
	// 822FF528: 4BFC1369  bl 0x822c0890
	ctx.lr = 0x822FF52C;
	sub_822C0890(ctx, base);
	// 822FF52C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF530: 80BF0198  lwz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822FF534: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 822FF538: 4BFF9D61  bl 0x822f9298
	ctx.lr = 0x822FF53C;
	sub_822F9298(ctx, base);
	// 822FF53C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF540: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF544: 4BFFAEFD  bl 0x822fa440
	ctx.lr = 0x822FF548;
	sub_822FA440(ctx, base);
	// 822FF548: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 822FF54C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF550: 419A0008  beq cr6, 0x822ff558
	if ctx.cr[6].eq {
	pc = 0x822FF558; continue 'dispatch;
	}
	// 822FF554: 4BFC133D  bl 0x822c0890
	ctx.lr = 0x822FF558;
	sub_822C0890(ctx, base);
	// 822FF558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF55C: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822FF560: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 822FF564: 4BFF9D35  bl 0x822f9298
	ctx.lr = 0x822FF568;
	sub_822F9298(ctx, base);
	// 822FF568: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF56C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822FF570: 4BFFAED1  bl 0x822fa440
	ctx.lr = 0x822FF574;
	sub_822FA440(ctx, base);
	// 822FF574: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 822FF578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF57C: 419A0008  beq cr6, 0x822ff584
	if ctx.cr[6].eq {
	pc = 0x822FF584; continue 'dispatch;
	}
	// 822FF580: 4BFC1311  bl 0x822c0890
	ctx.lr = 0x822FF584;
	sub_822C0890(ctx, base);
	// 822FF584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF588: 80BF0194  lwz r5, 0x194(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FF58C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 822FF590: 4BFF9D09  bl 0x822f9298
	ctx.lr = 0x822FF594;
	sub_822F9298(ctx, base);
	// 822FF594: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF598: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822FF59C: 4BFFAEA5  bl 0x822fa440
	ctx.lr = 0x822FF5A0;
	sub_822FA440(ctx, base);
	// 822FF5A0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 822FF5A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF5A8: 419A0008  beq cr6, 0x822ff5b0
	if ctx.cr[6].eq {
	pc = 0x822FF5B0; continue 'dispatch;
	}
	// 822FF5AC: 4BFC12E5  bl 0x822c0890
	ctx.lr = 0x822FF5B0;
	sub_822C0890(ctx, base);
	// 822FF5B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF5B4: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822FF5B8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 822FF5BC: 4BFF9CDD  bl 0x822f9298
	ctx.lr = 0x822FF5C0;
	sub_822F9298(ctx, base);
	// 822FF5C0: EC1DF02A  fadds f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 822FF5C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF5C8: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FF5CC: 4BFFAE75  bl 0x822fa440
	ctx.lr = 0x822FF5D0;
	sub_822FA440(ctx, base);
	// 822FF5D0: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 822FF5D4: 4800027C  b 0x822ff850
	pc = 0x822FF850; continue 'dispatch;
	// 822FF5D8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 822FF5DC: 4BFF9CBD  bl 0x822f9298
	ctx.lr = 0x822FF5E0;
	sub_822F9298(ctx, base);
	// 822FF5E0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF5E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF5E8: 4BFFAE59  bl 0x822fa440
	ctx.lr = 0x822FF5EC;
	sub_822FA440(ctx, base);
	// 822FF5EC: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 822FF5F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF5F4: 419A0008  beq cr6, 0x822ff5fc
	if ctx.cr[6].eq {
	pc = 0x822FF5FC; continue 'dispatch;
	}
	// 822FF5F8: 4BFC1299  bl 0x822c0890
	ctx.lr = 0x822FF5FC;
	sub_822C0890(ctx, base);
	// 822FF5FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF600: 80BF0194  lwz r5, 0x194(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FF604: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 822FF608: 4BFF9C91  bl 0x822f9298
	ctx.lr = 0x822FF60C;
	sub_822F9298(ctx, base);
	// 822FF60C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF610: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF614: 4BFFAE2D  bl 0x822fa440
	ctx.lr = 0x822FF618;
	sub_822FA440(ctx, base);
	// 822FF618: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 822FF61C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF620: 419A0008  beq cr6, 0x822ff628
	if ctx.cr[6].eq {
	pc = 0x822FF628; continue 'dispatch;
	}
	// 822FF624: 4BFC126D  bl 0x822c0890
	ctx.lr = 0x822FF628;
	sub_822C0890(ctx, base);
	// 822FF628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF62C: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822FF630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FF634: 4BFF9C65  bl 0x822f9298
	ctx.lr = 0x822FF638;
	sub_822F9298(ctx, base);
	// 822FF638: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF63C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822FF640: 4BFFAE01  bl 0x822fa440
	ctx.lr = 0x822FF644;
	sub_822FA440(ctx, base);
	// 822FF644: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FF648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF64C: 419A0008  beq cr6, 0x822ff654
	if ctx.cr[6].eq {
	pc = 0x822FF654; continue 'dispatch;
	}
	// 822FF650: 4BFC1241  bl 0x822c0890
	ctx.lr = 0x822FF654;
	sub_822C0890(ctx, base);
	// 822FF654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF658: 80BF0198  lwz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822FF65C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FF660: 4BFF9C39  bl 0x822f9298
	ctx.lr = 0x822FF664;
	sub_822F9298(ctx, base);
	// 822FF664: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF668: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822FF66C: 4BFFADD5  bl 0x822fa440
	ctx.lr = 0x822FF670;
	sub_822FA440(ctx, base);
	// 822FF670: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 822FF674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF678: 419A0008  beq cr6, 0x822ff680
	if ctx.cr[6].eq {
	pc = 0x822FF680; continue 'dispatch;
	}
	// 822FF67C: 4BFC1215  bl 0x822c0890
	ctx.lr = 0x822FF680;
	sub_822C0890(ctx, base);
	// 822FF680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF684: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822FF688: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 822FF68C: 4BFF9C0D  bl 0x822f9298
	ctx.lr = 0x822FF690;
	sub_822F9298(ctx, base);
	// 822FF690: EC1DF02A  fadds f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 822FF694: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF698: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FF69C: 4BFFADA5  bl 0x822fa440
	ctx.lr = 0x822FF6A0;
	sub_822FA440(ctx, base);
	// 822FF6A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 822FF6A4: 480001AC  b 0x822ff850
	pc = 0x822FF850; continue 'dispatch;
	// 822FF6A8: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822FF6AC: FF02F800  fcmpu cr6, f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 822FF6B0: 409900D4  ble cr6, 0x822ff784
	if !ctx.cr[6].gt {
	pc = 0x822FF784; continue 'dispatch;
	}
	// 822FF6B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 822FF6B8: 4BFF9BE1  bl 0x822f9298
	ctx.lr = 0x822FF6BC;
	sub_822F9298(ctx, base);
	// 822FF6BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF6C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF6C4: 4BFFAD7D  bl 0x822fa440
	ctx.lr = 0x822FF6C8;
	sub_822FA440(ctx, base);
	// 822FF6C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 822FF6CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF6D0: 419A0008  beq cr6, 0x822ff6d8
	if ctx.cr[6].eq {
	pc = 0x822FF6D8; continue 'dispatch;
	}
	// 822FF6D4: 4BFC11BD  bl 0x822c0890
	ctx.lr = 0x822FF6D8;
	sub_822C0890(ctx, base);
	// 822FF6D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF6DC: 80BF0198  lwz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822FF6E0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 822FF6E4: 4BFF9BB5  bl 0x822f9298
	ctx.lr = 0x822FF6E8;
	sub_822F9298(ctx, base);
	// 822FF6E8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF6EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF6F0: 4BFFAD51  bl 0x822fa440
	ctx.lr = 0x822FF6F4;
	sub_822FA440(ctx, base);
	// 822FF6F4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 822FF6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF6FC: 419A0008  beq cr6, 0x822ff704
	if ctx.cr[6].eq {
	pc = 0x822FF704; continue 'dispatch;
	}
	// 822FF700: 4BFC1191  bl 0x822c0890
	ctx.lr = 0x822FF704;
	sub_822C0890(ctx, base);
	// 822FF704: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF708: 80BF018C  lwz r5, 0x18c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FF70C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 822FF710: 4BFF9B89  bl 0x822f9298
	ctx.lr = 0x822FF714;
	sub_822F9298(ctx, base);
	// 822FF714: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF718: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822FF71C: 4BFFAD25  bl 0x822fa440
	ctx.lr = 0x822FF720;
	sub_822FA440(ctx, base);
	// 822FF720: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 822FF724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF728: 419A0008  beq cr6, 0x822ff730
	if ctx.cr[6].eq {
	pc = 0x822FF730; continue 'dispatch;
	}
	// 822FF72C: 4BFC1165  bl 0x822c0890
	ctx.lr = 0x822FF730;
	sub_822C0890(ctx, base);
	// 822FF730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF734: 80BF0194  lwz r5, 0x194(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FF738: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 822FF73C: 4BFF9B5D  bl 0x822f9298
	ctx.lr = 0x822FF740;
	sub_822F9298(ctx, base);
	// 822FF740: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF744: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822FF748: 4BFFACF9  bl 0x822fa440
	ctx.lr = 0x822FF74C;
	sub_822FA440(ctx, base);
	// 822FF74C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 822FF750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF754: 419A0008  beq cr6, 0x822ff75c
	if ctx.cr[6].eq {
	pc = 0x822FF75C; continue 'dispatch;
	}
	// 822FF758: 4BFC1139  bl 0x822c0890
	ctx.lr = 0x822FF75C;
	sub_822C0890(ctx, base);
	// 822FF75C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF760: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822FF764: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 822FF768: 4BFF9B31  bl 0x822f9298
	ctx.lr = 0x822FF76C;
	sub_822F9298(ctx, base);
	// 822FF76C: EC1DF02A  fadds f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 822FF770: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF774: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FF778: 4BFFACC9  bl 0x822fa440
	ctx.lr = 0x822FF77C;
	sub_822FA440(ctx, base);
	// 822FF77C: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 822FF780: 480000D0  b 0x822ff850
	pc = 0x822FF850; continue 'dispatch;
	// 822FF784: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 822FF788: 4BFF9B11  bl 0x822f9298
	ctx.lr = 0x822FF78C;
	sub_822F9298(ctx, base);
	// 822FF78C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF790: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF794: 4BFFACAD  bl 0x822fa440
	ctx.lr = 0x822FF798;
	sub_822FA440(ctx, base);
	// 822FF798: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 822FF79C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF7A0: 419A0008  beq cr6, 0x822ff7a8
	if ctx.cr[6].eq {
	pc = 0x822FF7A8; continue 'dispatch;
	}
	// 822FF7A4: 4BFC10ED  bl 0x822c0890
	ctx.lr = 0x822FF7A8;
	sub_822C0890(ctx, base);
	// 822FF7A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF7AC: 80BF0194  lwz r5, 0x194(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 822FF7B0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 822FF7B4: 4BFF9AE5  bl 0x822f9298
	ctx.lr = 0x822FF7B8;
	sub_822F9298(ctx, base);
	// 822FF7B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF7BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FF7C0: 4BFFAC81  bl 0x822fa440
	ctx.lr = 0x822FF7C4;
	sub_822FA440(ctx, base);
	// 822FF7C4: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 822FF7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF7CC: 419A0008  beq cr6, 0x822ff7d4
	if ctx.cr[6].eq {
	pc = 0x822FF7D4; continue 'dispatch;
	}
	// 822FF7D0: 4BFC10C1  bl 0x822c0890
	ctx.lr = 0x822FF7D4;
	sub_822C0890(ctx, base);
	// 822FF7D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF7D8: 80BF018C  lwz r5, 0x18c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FF7DC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 822FF7E0: 4BFF9AB9  bl 0x822f9298
	ctx.lr = 0x822FF7E4;
	sub_822F9298(ctx, base);
	// 822FF7E4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF7E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 822FF7EC: 4BFFAC55  bl 0x822fa440
	ctx.lr = 0x822FF7F0;
	sub_822FA440(ctx, base);
	// 822FF7F0: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 822FF7F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF7F8: 419A0008  beq cr6, 0x822ff800
	if ctx.cr[6].eq {
	pc = 0x822FF800; continue 'dispatch;
	}
	// 822FF7FC: 4BFC1095  bl 0x822c0890
	ctx.lr = 0x822FF800;
	sub_822C0890(ctx, base);
	// 822FF800: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF804: 80BF0198  lwz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 822FF808: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 822FF80C: 4BFF9A8D  bl 0x822f9298
	ctx.lr = 0x822FF810;
	sub_822F9298(ctx, base);
	// 822FF810: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF814: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 822FF818: 4BFFAC29  bl 0x822fa440
	ctx.lr = 0x822FF81C;
	sub_822FA440(ctx, base);
	// 822FF81C: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 822FF820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF824: 419A0008  beq cr6, 0x822ff82c
	if ctx.cr[6].eq {
	pc = 0x822FF82C; continue 'dispatch;
	}
	// 822FF828: 4BFC1069  bl 0x822c0890
	ctx.lr = 0x822FF82C;
	sub_822C0890(ctx, base);
	// 822FF82C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF830: 80BF0188  lwz r5, 0x188(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 822FF834: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 822FF838: 4BFF9A61  bl 0x822f9298
	ctx.lr = 0x822FF83C;
	sub_822F9298(ctx, base);
	// 822FF83C: EC1DF02A  fadds f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 822FF840: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF844: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 822FF848: 4BFFABF9  bl 0x822fa440
	ctx.lr = 0x822FF84C;
	sub_822FA440(ctx, base);
	// 822FF84C: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 822FF850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FF854: 419A0008  beq cr6, 0x822ff85c
	if ctx.cr[6].eq {
	pc = 0x822FF85C; continue 'dispatch;
	}
	// 822FF858: 4BFC1039  bl 0x822c0890
	ctx.lr = 0x822FF85C;
	sub_822C0890(ctx, base);
	// 822FF85C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 822FF860: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 822FF864: 48EA9261  bl 0x831a8ac4
	ctx.lr = 0x822FF868;
	sub_831A8A8C(ctx, base);
	// 822FF868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF878 size=160
    let mut pc: u32 = 0x822FF878;
    'dispatch: loop {
        match pc {
            0x822FF878 => {
    //   block [0x822FF878..0x822FF918)
	// 822FF878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF87C: 48EA88F1  bl 0x831a816c
	ctx.lr = 0x822FF880;
	sub_831A8130(ctx, base);
	// 822FF880: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF884: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FF888: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FF88C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 822FF890: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 822FF894: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 822FF898: 388BC8D0  addi r4, r11, -0x3730
	ctx.r[4].s64 = ctx.r[11].s64 + -14128;
	// 822FF89C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 822FF8A0: 3860018C  li r3, 0x18c
	ctx.r[3].s64 = 396;
	// 822FF8A4: 48AF2B45  bl 0x82df23e8
	ctx.lr = 0x822FF8A8;
	sub_82DF23E8(ctx, base);
	// 822FF8A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FF8AC: 41820014  beq 0x822ff8c0
	if ctx.cr[0].eq {
	pc = 0x822FF8C0; continue 'dispatch;
	}
	// 822FF8B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF8B4: 4BFFF9E5  bl 0x822ff298
	ctx.lr = 0x822FF8B8;
	sub_822FF298(ctx, base);
	// 822FF8B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF8BC: 48000008  b 0x822ff8c4
	pc = 0x822FF8C4; continue 'dispatch;
	// 822FF8C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822FF8C4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 822FF8C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF8CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822FF8D0: 4BFFD961  bl 0x822fd230
	ctx.lr = 0x822FF8D4;
	sub_822FD230(ctx, base);
	// 822FF8D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FF8D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 822FF8DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 822FF8E0: 4BFC0721  bl 0x822c0000
	ctx.lr = 0x822FF8E4;
	sub_822C0000(ctx, base);
	// 822FF8E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 822FF8E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FF8EC: 4BFFCA35  bl 0x822fc320
	ctx.lr = 0x822FF8F0;
	sub_822FC320(ctx, base);
	// 822FF8F0: 395D0062  addi r10, r29, 0x62
	ctx.r[10].s64 = ctx.r[29].s64 + 98;
	// 822FF8F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FF8F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822FF8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FF900: 7C6AF12E  stwx r3, r10, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 822FF904: 419A000C  beq cr6, 0x822ff910
	if ctx.cr[6].eq {
	pc = 0x822FF910; continue 'dispatch;
	}
	// 822FF908: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FF90C: 4BFC0F85  bl 0x822c0890
	ctx.lr = 0x822FF910;
	sub_822C0890(ctx, base);
	// 822FF910: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FF914: 48EA88A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF918 size=60
    let mut pc: u32 = 0x822FF918;
    'dispatch: loop {
        match pc {
            0x822FF918 => {
    //   block [0x822FF918..0x822FF954)
	// 822FF918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF924: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF92C: 4BFFD755  bl 0x822fd080
	ctx.lr = 0x822FF930;
	sub_822FD080(ctx, base);
	// 822FF930: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 822FF934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF938: 396BC92C  addi r11, r11, -0x36d4
	ctx.r[11].s64 = ctx.r[11].s64 + -14036;
	// 822FF93C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FF940: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FF944: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF948: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF94C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF958 size=76
    let mut pc: u32 = 0x822FF958;
    'dispatch: loop {
        match pc {
            0x822FF958 => {
    //   block [0x822FF958..0x822FF9A4)
	// 822FF958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF960: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FF964: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FF970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FF974: 4BFFD7E5  bl 0x822fd158
	ctx.lr = 0x822FF978;
	sub_822FD158(ctx, base);
	// 822FF978: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FF97C: 4182000C  beq 0x822ff988
	if ctx.cr[0].eq {
	pc = 0x822FF988; continue 'dispatch;
	}
	// 822FF980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF984: 48AF2A55  bl 0x82df23d8
	ctx.lr = 0x822FF988;
	sub_82DF23D8(ctx, base);
	// 822FF988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FF98C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FF990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FF994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FF998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FF99C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FF9A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FF9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FF9A8 size=144
    let mut pc: u32 = 0x822FF9A8;
    'dispatch: loop {
        match pc {
            0x822FF9A8 => {
    //   block [0x822FF9A8..0x822FFA38)
	// 822FF9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FF9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FF9B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FF9B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FF9B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FF9BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FF9C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FF9C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822FF9C8: 409A0028  bne cr6, 0x822ff9f0
	if !ctx.cr[6].eq {
	pc = 0x822FF9F0; continue 'dispatch;
	}
	// 822FF9CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FF9D0: 419A0050  beq cr6, 0x822ffa20
	if ctx.cr[6].eq {
	pc = 0x822FFA20; continue 'dispatch;
	}
	// 822FF9D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FF9D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FF9DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FF9E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FF9E4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FF9E8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 822FF9EC: 48000034  b 0x822ffa20
	pc = 0x822FFA20; continue 'dispatch;
	// 822FF9F0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 822FF9F4: 419A002C  beq cr6, 0x822ffa20
	if ctx.cr[6].eq {
	pc = 0x822FFA20; continue 'dispatch;
	}
	// 822FF9F8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822FF9FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFA00: 388B5068  addi r4, r11, 0x5068
	ctx.r[4].s64 = ctx.r[11].s64 + 20584;
	// 822FFA04: 48EA86F5  bl 0x831a80f8
	ctx.lr = 0x822FFA08;
	sub_831A80F8(ctx, base);
	// 822FFA08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFA0C: 4182000C  beq 0x822ffa18
	if ctx.cr[0].eq {
	pc = 0x822FFA18; continue 'dispatch;
	}
	// 822FFA10: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822FFA14: 4800000C  b 0x822ffa20
	pc = 0x822FFA20; continue 'dispatch;
	// 822FFA18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FFA1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FFA20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FFA24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFA28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFA2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FFA30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FFA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFA38 size=136
    let mut pc: u32 = 0x822FFA38;
    'dispatch: loop {
        match pc {
            0x822FFA38 => {
    //   block [0x822FFA38..0x822FFAC0)
	// 822FFA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FFA40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FFA44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FFA48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFA4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FFA50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 822FFA54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 822FFA58: 409A0020  bne cr6, 0x822ffa78
	if !ctx.cr[6].eq {
	pc = 0x822FFA78; continue 'dispatch;
	}
	// 822FFA5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FFA60: 419A0048  beq cr6, 0x822ffaa8
	if ctx.cr[6].eq {
	pc = 0x822FFAA8; continue 'dispatch;
	}
	// 822FFA64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFA68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FFA6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FFA70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 822FFA74: 48000034  b 0x822ffaa8
	pc = 0x822FFAA8; continue 'dispatch;
	// 822FFA78: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 822FFA7C: 419A002C  beq cr6, 0x822ffaa8
	if ctx.cr[6].eq {
	pc = 0x822FFAA8; continue 'dispatch;
	}
	// 822FFA80: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822FFA84: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFA88: 388B50F8  addi r4, r11, 0x50f8
	ctx.r[4].s64 = ctx.r[11].s64 + 20728;
	// 822FFA8C: 48EA866D  bl 0x831a80f8
	ctx.lr = 0x822FFA90;
	sub_831A80F8(ctx, base);
	// 822FFA90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFA94: 4182000C  beq 0x822ffaa0
	if ctx.cr[0].eq {
	pc = 0x822FFAA0; continue 'dispatch;
	}
	// 822FFA98: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 822FFA9C: 4800000C  b 0x822ffaa8
	pc = 0x822FFAA8; continue 'dispatch;
	// 822FFAA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 822FFAA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FFAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FFAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FFAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FFABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FFAC0 size=184
    let mut pc: u32 = 0x822FFAC0;
    'dispatch: loop {
        match pc {
            0x822FFAC0 => {
    //   block [0x822FFAC0..0x822FFB78)
	// 822FFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FFAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 822FFACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FFAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FFAD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FFADC: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FFAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FFAE4: 419A007C  beq cr6, 0x822ffb60
	if ctx.cr[6].eq {
	pc = 0x822FFB60; continue 'dispatch;
	}
	// 822FFAE8: 815F0190  lwz r10, 0x190(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 822FFAEC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FFAF0: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 822FFAF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FFAF8: 40980068  bge cr6, 0x822ffb60
	if !ctx.cr[6].lt {
	pc = 0x822FFB60; continue 'dispatch;
	}
	// 822FFAFC: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFB00: 4182000C  beq 0x822ffb0c
	if ctx.cr[0].eq {
	pc = 0x822FFB0C; continue 'dispatch;
	}
	// 822FFB04: C03F0198  lfs f1, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FFB08: 48000008  b 0x822ffb10
	pc = 0x822FFB10; continue 'dispatch;
	// 822FFB0C: C03F019C  lfs f1, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FFB10: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 822FFB14: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 822FFB18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 822FFB1C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 822FFB20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 822FFB24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FFB28: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 822FFB2C: 896B000C  lbz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 822FFB30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 822FFB34: 40820008  bne 0x822ffb3c
	if !ctx.cr[0].eq {
	pc = 0x822FFB3C; continue 'dispatch;
	}
	// 822FFB38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 822FFB3C: 4BFF91B5  bl 0x822f8cf0
	ctx.lr = 0x822FFB40;
	sub_822F8CF0(ctx, base);
	// 822FFB40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 822FFB44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FFB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFB4C: 4BFF9585  bl 0x822f90d0
	ctx.lr = 0x822FFB50;
	sub_822F90D0(ctx, base);
	// 822FFB50: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 822FFB54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 822FFB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFB5C: 4BFF937D  bl 0x822f8ed8
	ctx.lr = 0x822FFB60;
	sub_822F8ED8(ctx, base);
	// 822FFB60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FFB64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFB68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFB6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FFB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FFB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFB78 size=120
    let mut pc: u32 = 0x822FFB78;
    'dispatch: loop {
        match pc {
            0x822FFB78 => {
    //   block [0x822FFB78..0x822FFBF0)
	// 822FFB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FFB80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 822FFB84: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 822FFB88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFB8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FFB90: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FFB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FFB98: 4BFF9891  bl 0x822f9428
	ctx.lr = 0x822FFB9C;
	sub_822F9428(ctx, base);
	// 822FFB9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FFBA0: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FFBA8: 419A000C  beq cr6, 0x822ffbb4
	if ctx.cr[6].eq {
	pc = 0x822FFBB4; continue 'dispatch;
	}
	// 822FFBAC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FFBB0: 4BFC0CE1  bl 0x822c0890
	ctx.lr = 0x822FFBB4;
	sub_822C0890(ctx, base);
	// 822FFBB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FFBB8: 419A0020  beq cr6, 0x822ffbd8
	if ctx.cr[6].eq {
	pc = 0x822FFBD8; continue 'dispatch;
	}
	// 822FFBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFBC0: 487BCEB9  bl 0x82abca78
	ctx.lr = 0x822FFBC4;
	sub_82ABCA78(ctx, base);
	// 822FFBC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFBC8: 41820010  beq 0x822ffbd8
	if ctx.cr[0].eq {
	pc = 0x822FFBD8; continue 'dispatch;
	}
	// 822FFBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFBD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 822FFBD4: 488B6865  bl 0x82bb6438
	ctx.lr = 0x822FFBD8;
	sub_82BB6438(ctx, base);
	// 822FFBD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 822FFBDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFBE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFBE4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 822FFBE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 822FFBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFBF0 size=188
    let mut pc: u32 = 0x822FFBF0;
    'dispatch: loop {
        match pc {
            0x822FFBF0 => {
    //   block [0x822FFBF0..0x822FFCAC)
	// 822FFBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFBF4: 48EA8575  bl 0x831a8168
	ctx.lr = 0x822FFBF8;
	sub_831A8130(ctx, base);
	// 822FFBF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFBFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 822FFC00: 4BFF92E1  bl 0x822f8ee0
	ctx.lr = 0x822FFC04;
	sub_822F8EE0(ctx, base);
	// 822FFC04: 3B9D0188  addi r28, r29, 0x188
	ctx.r[28].s64 = ctx.r[29].s64 + 392;
	// 822FFC08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 822FFC0C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 822FFC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FFC14: 419A0090  beq cr6, 0x822ffca4
	if ctx.cr[6].eq {
	pc = 0x822FFCA4; continue 'dispatch;
	}
	// 822FFC18: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FFC1C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 822FFC20: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 822FFC24: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 822FFC28: 4098007C  bge cr6, 0x822ffca4
	if !ctx.cr[6].lt {
	pc = 0x822FFCA4; continue 'dispatch;
	}
	// 822FFC2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 822FFC30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 822FFC34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 822FFC38: 4BFF9661  bl 0x822f9298
	ctx.lr = 0x822FFC3C;
	sub_822F9298(ctx, base);
	// 822FFC3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FFC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FFC44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFC48: 4BFF97E1  bl 0x822f9428
	ctx.lr = 0x822FFC4C;
	sub_822F9428(ctx, base);
	// 822FFC4C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FFC50: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FFC58: 419A000C  beq cr6, 0x822ffc64
	if ctx.cr[6].eq {
	pc = 0x822FFC64; continue 'dispatch;
	}
	// 822FFC5C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FFC60: 4BFC0C31  bl 0x822c0890
	ctx.lr = 0x822FFC64;
	sub_822C0890(ctx, base);
	// 822FFC64: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 822FFC68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 822FFC6C: 419A0008  beq cr6, 0x822ffc74
	if ctx.cr[6].eq {
	pc = 0x822FFC74; continue 'dispatch;
	}
	// 822FFC70: 4BFC0C21  bl 0x822c0890
	ctx.lr = 0x822FFC74;
	sub_822C0890(ctx, base);
	// 822FFC74: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 822FFC78: 419A0024  beq cr6, 0x822ffc9c
	if ctx.cr[6].eq {
	pc = 0x822FFC9C; continue 'dispatch;
	}
	// 822FFC7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FFC80: 487BCDF9  bl 0x82abca78
	ctx.lr = 0x822FFC84;
	sub_82ABCA78(ctx, base);
	// 822FFC84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFC88: 41820014  beq 0x822ffc9c
	if ctx.cr[0].eq {
	pc = 0x822FFC9C; continue 'dispatch;
	}
	// 822FFC8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FFC90: 484D5DE9  bl 0x827d5a78
	ctx.lr = 0x822FFC94;
	sub_827D5A78(ctx, base);
	// 822FFC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 822FFC98: 488B67A1  bl 0x82bb6438
	ctx.lr = 0x822FFC9C;
	sub_82BB6438(ctx, base);
	// 822FFC9C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 822FFCA0: 4BFFFF6C  b 0x822ffc0c
	pc = 0x822FFC0C; continue 'dispatch;
	// 822FFCA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 822FFCA8: 48EA8510  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFCB0 size=72
    let mut pc: u32 = 0x822FFCB0;
    'dispatch: loop {
        match pc {
            0x822FFCB0 => {
    //   block [0x822FFCB0..0x822FFCF8)
	// 822FFCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFCB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FFCB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFCBC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 822FFCC0: 419A001C  beq cr6, 0x822ffcdc
	if ctx.cr[6].eq {
	pc = 0x822FFCDC; continue 'dispatch;
	}
	// 822FFCC4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822FFCC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FFCCC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822FFCD0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FFCD4: 4BFFFCD5  bl 0x822ff9a8
	ctx.lr = 0x822FFCD8;
	sub_822FF9A8(ctx, base);
	// 822FFCD8: 48000010  b 0x822ffce8
	pc = 0x822FFCE8; continue 'dispatch;
	// 822FFCDC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822FFCE0: 396B5068  addi r11, r11, 0x5068
	ctx.r[11].s64 = ctx.r[11].s64 + 20584;
	// 822FFCE4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FFCE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FFCEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFCF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFCF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFCF8 size=72
    let mut pc: u32 = 0x822FFCF8;
    'dispatch: loop {
        match pc {
            0x822FFCF8 => {
    //   block [0x822FFCF8..0x822FFD40)
	// 822FFCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 822FFD00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFD04: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 822FFD08: 419A001C  beq cr6, 0x822ffd24
	if ctx.cr[6].eq {
	pc = 0x822FFD24; continue 'dispatch;
	}
	// 822FFD0C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822FFD10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 822FFD14: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 822FFD18: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FFD1C: 4BFFFD1D  bl 0x822ffa38
	ctx.lr = 0x822FFD20;
	sub_822FFA38(ctx, base);
	// 822FFD20: 48000010  b 0x822ffd30
	pc = 0x822FFD30; continue 'dispatch;
	// 822FFD24: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 822FFD28: 396B50F8  addi r11, r11, 0x50f8
	ctx.r[11].s64 = ctx.r[11].s64 + 20728;
	// 822FFD2C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 822FFD30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 822FFD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 822FFD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 822FFD3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x822FFD40 size=148
    let mut pc: u32 = 0x822FFD40;
    'dispatch: loop {
        match pc {
            0x822FFD40 => {
    //   block [0x822FFD40..0x822FFDD4)
	// 822FFD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFD44: 48EA8429  bl 0x831a816c
	ctx.lr = 0x822FFD48;
	sub_831A8130(ctx, base);
	// 822FFD48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 822FFD4C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFD50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 822FFD54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 822FFD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 822FFD5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 822FFD60: 4BFF96C9  bl 0x822f9428
	ctx.lr = 0x822FFD64;
	sub_822F9428(ctx, base);
	// 822FFD64: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 822FFD68: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFD6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 822FFD70: 419A000C  beq cr6, 0x822ffd7c
	if ctx.cr[6].eq {
	pc = 0x822FFD7C; continue 'dispatch;
	}
	// 822FFD74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 822FFD78: 4BFC0B19  bl 0x822c0890
	ctx.lr = 0x822FFD7C;
	sub_822C0890(ctx, base);
	// 822FFD7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 822FFD80: 419A0048  beq cr6, 0x822ffdc8
	if ctx.cr[6].eq {
	pc = 0x822FFDC8; continue 'dispatch;
	}
	// 822FFD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFD88: 487BCCF1  bl 0x82abca78
	ctx.lr = 0x822FFD8C;
	sub_82ABCA78(ctx, base);
	// 822FFD8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFD90: 41820038  beq 0x822ffdc8
	if ctx.cr[0].eq {
	pc = 0x822FFDC8; continue 'dispatch;
	}
	// 822FFD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFD98: 484D5CE1  bl 0x827d5a78
	ctx.lr = 0x822FFD9C;
	sub_827D5A78(ctx, base);
	// 822FFD9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFDA0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 822FFDA4: 488B6CF5  bl 0x82bb6a98
	ctx.lr = 0x822FFDA8;
	sub_82BB6A98(ctx, base);
	// 822FFDA8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FFDAC: EC1F007A  fmadds f0, f31, f1, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 822FFDB0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822FFDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFDB8: 488B6CE1  bl 0x82bb6a98
	ctx.lr = 0x822FFDBC;
	sub_82BB6A98(ctx, base);
	// 822FFDBC: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 822FFDC0: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 822FFDC4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 822FFDC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FFDCC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 822FFDD0: 48EA83EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFDD8 size=324
    let mut pc: u32 = 0x822FFDD8;
    'dispatch: loop {
        match pc {
            0x822FFDD8 => {
    //   block [0x822FFDD8..0x822FFF1C)
	// 822FFDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFDDC: 48EA8391  bl 0x831a816c
	ctx.lr = 0x822FFDE0;
	sub_831A8130(ctx, base);
	// 822FFDE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFDE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 822FFDE8: 48710A89  bl 0x82a10870
	ctx.lr = 0x822FFDEC;
	sub_82A10870(ctx, base);
	// 822FFDEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 822FFDF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 822FFDF4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 822FFDF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFDFC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 822FFE00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FFE04: 4E800421  bctrl
	ctx.lr = 0x822FFE08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 822FFE08: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x822FFF20 size=20
    let mut pc: u32 = 0x822FFF20;
    'dispatch: loop {
        match pc {
            0x822FFF20 => {
    //   block [0x822FFF20..0x822FFF34)
	// 822FFF20: C0230004  lfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 822FFF24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 822FFF28: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 822FFF2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 822FFF30: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFF38 size=140
    let mut pc: u32 = 0x822FFF38;
    'dispatch: loop {
        match pc {
            0x822FFF38 => {
    //   block [0x822FFF38..0x822FFFC4)
	// 822FFF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFF3C: 48EA8231  bl 0x831a816c
	ctx.lr = 0x822FFF40;
	sub_831A8130(ctx, base);
	// 822FFF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFF44: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822FFF48: F8A100A8  std r5, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u64 ) };
	// 822FFF4C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FFF50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FFF54: 3BEB2620  addi r31, r11, 0x2620
	ctx.r[31].s64 = ctx.r[11].s64 + 9760;
	// 822FFF58: 816A2628  lwz r11, 0x2628(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9768 as u32) ) } as u64;
	// 822FFF5C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822FFF60: 40820024  bne 0x822fff84
	if !ctx.cr[0].eq {
	pc = 0x822FFF84; continue 'dispatch;
	}
	// 822FFF64: 3D208252  lis r9, -0x7dae
	ctx.r[9].s64 = -2108555264;
	// 822FFF68: 3D008230  lis r8, -0x7dd0
	ctx.r[8].s64 = -2110783488;
	// 822FFF6C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822FFF70: 39292F80  addi r9, r9, 0x2f80
	ctx.r[9].s64 = ctx.r[9].s64 + 12160;
	// 822FFF74: 3908FCB0  addi r8, r8, -0x350
	ctx.r[8].s64 = ctx.r[8].s64 + -848;
	// 822FFF78: 916A2628  stw r11, 0x2628(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9768 as u32), ctx.r[11].u32 ) };
	// 822FFF7C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 822FFF80: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 822FFF84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 822FFF88: 814100A8  lwz r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 822FFF8C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 822FFF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 822FFF94: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 822FFF98: 794507E6  rldicr r5, r10, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 822FFF9C: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 822FFFA0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 822FFFA4: 4800771D  bl 0x823076c0
	ctx.lr = 0x822FFFA8;
	sub_823076C0(ctx, base);
	// 822FFFA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 822FFFAC: 4182000C  beq 0x822fffb8
	if ctx.cr[0].eq {
	pc = 0x822FFFB8; continue 'dispatch;
	}
	// 822FFFB0: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 822FFFB4: 48000008  b 0x822fffbc
	pc = 0x822FFFBC; continue 'dispatch;
	// 822FFFB8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 822FFFBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 822FFFC0: 48EA81FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_822FFFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x822FFFC8 size=128
    let mut pc: u32 = 0x822FFFC8;
    'dispatch: loop {
        match pc {
            0x822FFFC8 => {
    //   block [0x822FFFC8..0x82300048)
	// 822FFFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 822FFFCC: 48EA81A1  bl 0x831a816c
	ctx.lr = 0x822FFFD0;
	sub_831A8130(ctx, base);
	// 822FFFD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 822FFFD4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 822FFFD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 822FFFDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 822FFFE0: 3BEB262C  addi r31, r11, 0x262c
	ctx.r[31].s64 = ctx.r[11].s64 + 9772;
	// 822FFFE4: 816A2634  lwz r11, 0x2634(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9780 as u32) ) } as u64;
	// 822FFFE8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 822FFFEC: 40820024  bne 0x82300010
	if !ctx.cr[0].eq {
	pc = 0x82300010; continue 'dispatch;
	}
	// 822FFFF0: 3D208230  lis r9, -0x7dd0
	ctx.r[9].s64 = -2110783488;
	// 822FFFF4: 3D008230  lis r8, -0x7dd0
	ctx.r[8].s64 = -2110783488;
	// 822FFFF8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 822FFFFC: 3929FF20  addi r9, r9, -0xe0
	ctx.r[9].s64 = ctx.r[9].s64 + -224;
	// 82300000: 3908FCF8  addi r8, r8, -0x308
	ctx.r[8].s64 = ctx.r[8].s64 + -776;
	// 82300004: 916A2634  stw r11, 0x2634(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9780 as u32), ctx.r[11].u32 ) };
	// 82300008: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8230000C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82300010: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82300014: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82300018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8230001C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82300020: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82300024: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82300028: 482D28F9  bl 0x825d2920
	ctx.lr = 0x8230002C;
	sub_825D2920(ctx, base);
	// 8230002C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82300030: 4182000C  beq 0x8230003c
	if ctx.cr[0].eq {
	pc = 0x8230003C; continue 'dispatch;
	}
	// 82300034: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82300038: 48000008  b 0x82300040
	pc = 0x82300040; continue 'dispatch;
	// 8230003C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82300040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82300044: 48EA8178  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82300048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82300048 size=556
    let mut pc: u32 = 0x82300048;
    'dispatch: loop {
        match pc {
            0x82300048 => {
    //   block [0x82300048..0x82300274)
	// 82300048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8230004C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82300050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82300054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82300058: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8230005C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82300060: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82300064: 4871080D  bl 0x82a10870
	ctx.lr = 0x82300068;
	sub_82A10870(ctx, base);
	// 82300068: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8230006C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82300070: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82300074: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82300078: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8230007C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82300080: 4E800421  bctrl
	ctx.lr = 0x82300084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82300084: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82300278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82300278 size=200
    let mut pc: u32 = 0x82300278;
    'dispatch: loop {
        match pc {
            0x82300278 => {
    //   block [0x82300278..0x82300340)
	// 82300278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8230027C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82300280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82300284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82300288: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8230028C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82300290: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82300294: 8163018C  lwz r11, 0x18c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) } as u64;
	// 82300298: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8230029C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823002A0: 3BE30188  addi r31, r3, 0x188
	ctx.r[31].s64 = ctx.r[3].s64 + 392;
	// 823002A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823002A8: 419A0014  beq cr6, 0x823002bc
	if ctx.cr[6].eq {
	pc = 0x823002BC; continue 'dispatch;
	}
	// 823002AC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823002B0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823002B4: 7D6B2671  srawi. r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823002B8: 40820018  bne 0x823002d0
	if !ctx.cr[0].eq {
	pc = 0x823002D0; continue 'dispatch;
	}
	// 823002BC: 4BFFC065  bl 0x822fc320
	ctx.lr = 0x823002C0;
	sub_822FC320(ctx, base);
	// 823002C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823002C4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823002C8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823002CC: 4800003C  b 0x82300308
	pc = 0x82300308; continue 'dispatch;
	// 823002D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823002D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823002D8: 409A000C  bne cr6, 0x823002e4
	if !ctx.cr[6].eq {
	pc = 0x823002E4; continue 'dispatch;
	}
	// 823002DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823002E0: 48000010  b 0x823002f0
	pc = 0x823002F0; continue 'dispatch;
	// 823002E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823002E8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823002EC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 823002F0: 8163018C  lwz r11, 0x18c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) } as u64;
	// 823002F4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823002F8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823002FC: C3CBFFF8  lfs f30, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82300300: 4BFFC021  bl 0x822fc320
	ctx.lr = 0x82300304;
	sub_822FC320(ctx, base);
	// 82300304: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82300308: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8230030C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82300310: 9BC1005C  stb r30, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u8 ) };
	// 82300314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82300318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8230031C: 484C8F6D  bl 0x827c9288
	ctx.lr = 0x82300320;
	sub_827C9288(ctx, base);
	// 82300320: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82300324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82300328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8230032C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82300330: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82300334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82300338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8230033C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82300340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82300340 size=164
    let mut pc: u32 = 0x82300340;
    'dispatch: loop {
        match pc {
            0x82300340 => {
    //   block [0x82300340..0x823003E4)
	// 82300340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82300344: 48EA7E29  bl 0x831a816c
	ctx.lr = 0x82300348;
	sub_831A8130(ctx, base);
	// 82300348: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8230034C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82300350: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82300354: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82300358: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8230035C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82300360: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82300364: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82300368: 388BC960  addi r4, r11, -0x36a0
	ctx.r[4].s64 = ctx.r[11].s64 + -13984;
	// 8230036C: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 82300370: 3860018C  li r3, 0x18c
	ctx.r[3].s64 = 396;
	// 82300374: 48AF2075  bl 0x82df23e8
	ctx.lr = 0x82300378;
	sub_82DF23E8(ctx, base);
	// 82300378: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8230037C: 41820014  beq 0x82300390
	if ctx.cr[0].eq {
	pc = 0x82300390; continue 'dispatch;
	}
	// 82300380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82300384: 4BFFEF15  bl 0x822ff298
	ctx.lr = 0x82300388;
	sub_822FF298(ctx, base);
	// 82300388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8230038C: 48000008  b 0x82300394
	pc = 0x82300394; continue 'dispatch;
	// 82300390: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82300394: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82300398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8230039C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823003A0: 4BFFCE91  bl 0x822fd230
	ctx.lr = 0x823003A4;
	sub_822FD230(ctx, base);
	// 823003A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823003A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823003AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 823003B0: 4BFBFC51  bl 0x822c0000
	ctx.lr = 0x823003B4;
	sub_822C0000(ctx, base);
	// 823003B4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823003B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823003BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823003C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823003C4: 4BFFFEB5  bl 0x82300278
	ctx.lr = 0x823003C8;
	sub_82300278(ctx, base);
	// 823003C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823003CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823003D0: 419A0008  beq cr6, 0x823003d8
	if ctx.cr[6].eq {
	pc = 0x823003D8; continue 'dispatch;
	}
	// 823003D4: 4BFC04BD  bl 0x822c0890
	ctx.lr = 0x823003D8;
	sub_822C0890(ctx, base);
	// 823003D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823003DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823003E0: 48EA7DDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823003E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823003E8 size=112
    let mut pc: u32 = 0x823003E8;
    'dispatch: loop {
        match pc {
            0x823003E8 => {
    //   block [0x823003E8..0x82300458)
	// 823003E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823003EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823003F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823003F4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 823003F8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 823003FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82300400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82300404: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82300408: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 8230040C: 4BFFCC75  bl 0x822fd080
	ctx.lr = 0x82300410;
	sub_822FD080(ctx, base);
	// 82300410: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82300414: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82300418: 394AC9BC  addi r10, r10, -0x3644
	ctx.r[10].s64 = ctx.r[10].s64 + -13892;
	// 8230041C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82300420: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82300424: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82300428: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 8230042C: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82300430: D3FF0198  stfs f31, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 82300434: D3DF019C  stfs f30, 0x19c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82300438: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 8230043C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82300440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82300444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82300448: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8230044C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82300450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82300454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82300458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82300458 size=88
    let mut pc: u32 = 0x82300458;
    'dispatch: loop {
        match pc {
            0x82300458 => {
    //   block [0x82300458..0x823004B0)
	// 82300458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8230045C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82300460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82300464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82300468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8230046C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82300470: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82300474: 387F0188  addi r3, r31, 0x188
	ctx.r[3].s64 = ctx.r[31].s64 + 392;
	// 82300478: 48169B89  bl 0x8246a000
	ctx.lr = 0x8230047C;
	sub_8246A000(ctx, base);
	// 8230047C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82300480: 4BFFCCD9  bl 0x822fd158
	ctx.lr = 0x82300484;
	sub_822FD158(ctx, base);
	// 82300484: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82300488: 4182000C  beq 0x82300494
	if ctx.cr[0].eq {
	pc = 0x82300494; continue 'dispatch;
	}
	// 8230048C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82300490: 48AF1F49  bl 0x82df23d8
	ctx.lr = 0x82300494;
	sub_82DF23D8(ctx, base);
	// 82300494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82300498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8230049C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823004A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823004A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823004A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823004AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004B0 size=16
    let mut pc: u32 = 0x823004B0;
    'dispatch: loop {
        match pc {
            0x823004B0 => {
    //   block [0x823004B0..0x823004C0)
	// 823004B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823004B4: 409A000C  bne cr6, 0x823004c0
	if !ctx.cr[6].eq {
		sub_823004C0(ctx, base);
		return;
	}
	// 823004B8: 386300A4  addi r3, r3, 0xa4
	ctx.r[3].s64 = ctx.r[3].s64 + 164;
	// 823004BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004C0 size=16
    let mut pc: u32 = 0x823004C0;
    'dispatch: loop {
        match pc {
            0x823004C0 => {
    //   block [0x823004C0..0x823004D0)
	// 823004C0: 396300A4  addi r11, r3, 0xa4
	ctx.r[11].s64 = ctx.r[3].s64 + 164;
	// 823004C4: 38630114  addi r3, r3, 0x114
	ctx.r[3].s64 = ctx.r[3].s64 + 276;
	// 823004C8: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823004CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004D0 size=8
    let mut pc: u32 = 0x823004D0;
    'dispatch: loop {
        match pc {
            0x823004D0 => {
    //   block [0x823004D0..0x823004D8)
	// 823004D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823004D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004D8 size=8
    let mut pc: u32 = 0x823004D8;
    'dispatch: loop {
        match pc {
            0x823004D8 => {
    //   block [0x823004D8..0x823004E0)
	// 823004D8: 386300CC  addi r3, r3, 0xcc
	ctx.r[3].s64 = ctx.r[3].s64 + 204;
	// 823004DC: 48B5CBB4  b 0x82e5d090
	sub_82E5D090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004E0 size=8
    let mut pc: u32 = 0x823004E0;
    'dispatch: loop {
        match pc {
            0x823004E0 => {
    //   block [0x823004E0..0x823004E8)
	// 823004E0: 3863012C  addi r3, r3, 0x12c
	ctx.r[3].s64 = ctx.r[3].s64 + 300;
	// 823004E4: 48B5F994  b 0x82e5fe78
	sub_82E5FE78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823004E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823004E8 size=8
    let mut pc: u32 = 0x823004E8;
    'dispatch: loop {
        match pc {
            0x823004E8 => {
    //   block [0x823004E8..0x823004F0)
	// 823004E8: 38630224  addi r3, r3, 0x224
	ctx.r[3].s64 = ctx.r[3].s64 + 548;
	// 823004EC: 48B5F98C  b 0x82e5fe78
	sub_82E5FE78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


